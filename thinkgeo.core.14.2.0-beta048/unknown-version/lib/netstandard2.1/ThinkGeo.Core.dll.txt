internal class GRU=./Bk= : iBo= {
    internal double shc=;
    internal double sxc=;
    internal /Bk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=./Cg= : object {
    public static List`1<1iU=> /Sg=;
    public static List`1<4iU=> /ig=;
    private static /Cg=();
}
internal class GRU=./hk= : iBo= {
    internal double PRk=;
    internal double Phk=;
    internal /hk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=./ic= : object {
    public static string /yc=;
    public static string ACg=;
    public static string ASg=;
    public static string Aig=;
    public static string Ayg=;
    public static string BCg=;
    public static string BSg=;
    public static string Big=;
    public static string Byg=;
    public static string CCg=;
    public static string CSg=;
    public static string Cig=;
    public static string Cyg=;
    public static string DCg=;
}
internal class GRU=./iI= : GCM= {
    private 8yI= /yI=;
    private 8yI= ACM=;
    private 8yI= ASM=;
    private 8yI= AiM=;
    public 8yI= BSM= { get; public set; }
    public 8yI= CCM= { get; public set; }
    public 8yI= CyM= { get; public set; }
    public 8yI= DiM= { get; public set; }
    public 8yI= AyM=();
    public void BCM=(8yI= value);
    public 8yI= BiM=();
    public void ByM=(8yI= value);
    public 8yI= CSM=();
    public void CiM=(8yI= value);
    public 8yI= DCM=();
    public void DSM=(8yI= value);
}
internal class GRU=./Rk= : iBo= {
    internal double PRk=;
    internal double Phk=;
    internal /Rk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal static class GRU=./Ro= : object {
    private static Dictionary`2<string, Type> /ho=;
    private static string /xo=;
    private static EBs= ABs=;
    public static string ARs=;
    public static string Ahs=;
    public static string Axs=;
    public static string BBs=;
    public static string BRs=;
    public static string Bhs=;
    public static string Bxs=;
    public static Dictionary`2<string, Type> CRs= { get; }
    private static /Ro=();
    public static Dictionary`2<string, Type> CBs=();
    public static string Chs=(object targetObject);
    public static object Cxs=(string geoJson);
    public static GeoJsonObject DBs=(object targetObject);
    private static object DRs=(GeoJsonObject geoJsonObject);
    private static PolygonShape Dhs=(Collection`1<Collection`1<Double[]>> rings);
    private static RingShape Dxs=(Collection`1<Double[]> ring);
}
internal class GRU=./SE= : object {
    private int /iE=;
    private int /yE=;
    private int ACI=;
    private double ASI=;
    [CompilerGeneratedAttribute]
private GeoImage AiI=;
    public int BCI= { get; }
    public int BiI= { get; }
    public int CCI= { get; }
    public double CiI= { get; }
    public GeoImage DSI= { get; public set; }
    public /SE=(int column, int row, int zoomLevelNumber, double scale);
    public int AyI=();
    public int BSI=();
    public int ByI=();
    public double CSI=();
    [CompilerGeneratedAttribute]
public GeoImage CyI=();
    [CompilerGeneratedAttribute]
public void DCI=(GeoImage value);
}
internal class GRU=./xk= : iBo= {
    internal double shc=;
    internal double sxc=;
    internal double PRk=;
    internal double Phk=;
    internal double FBg=;
    internal /xk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=./yg= : ByU= {
    private string 7SU=;
    private Stream Vyg=;
    private ESg= 7iU=;
    private ySo= ACk=;
    private int Kyg=;
    private int ASk=;
    public int FR8=(string pszFname, FileAccess pszAccess);
    public int oR8=();
    public int Aik=(int nObjId);
    public int Ayk=(int nObjId, int nObjPtr);
    public sealed virtual void Dispose();
}
internal class GRU=./yk= : Hio= {
    public byte ACo=;
    public short 4Cg=;
    public byte ASo=;
    public byte Aio=;
    public byte Ayo=;
    public short BCo=;
    public byte 5yk=;
    public virtual int 2Sk=(6Ck= poObjBlock);
    public virtual int 2ik=(6Ck= poObjBlock);
}
internal class GRU=.0Cc= : 2Cc= {
    public sSc=[] 0Sc=;
    private tCc=[] vCc=;
    public virtual int jxU=();
    public string vyc=(Int32& bDefault);
    public string zSc=(Int32& bDefault);
    public double 0ic=(Int32& bDefault);
    public string wCc=(5yY= eParam, Int32& bValueIsNull);
    public double zyc=(5yY= eParam, Int32& bValueIsNull);
}
internal class GRU=.0Ck= : object {
    public int iCQ=;
    public int iiQ=;
    public int iSQ=;
    public int iyQ=;
    public int NCg=;
}
internal static class GRU=.0CQ= : object {
    public static bool 0SQ=;
    public static LocalDataStoreSlot 0iQ=;
    public static object 0yQ=(int nIndex);
    public static void 1CQ=(int nIndex, object pData, bool bFreeOnExit);
    public static Object[] 1SQ=();
}
internal class GRU=.0CU= : object {
    public hCo= 0SU=;
    public double 0iU=;
    public double 0yU=;
    public double 1CU=;
    public double 1SU=;
    public 0CU=(hCo= sProj, double dXMin, double dYMin, double dXMax, double dYMax);
}
internal class GRU=.0h8= : object {
    public double 0x8=;
    public sR8= 1B8=;
    public 0h8=(double minDist, sR8= node);
    public sealed virtual int CompareTo(object rhs);
}
internal class GRU=.0hw= : object {
    public static int 0xw=;
    private static int 0Rw=;
    private int 1Bw=;
    private thw= 1Rw=;
    private thw= 1hw=;
    private TextReader 1xw=;
    private thw= 2Bw=;
    private thw= 2Rw=;
    private 6Rw= 2hw=;
    public TextReader 3Rw= { get; public set; }
    public 6Rw= 3xw= { get; }
    public 0hw=(TextReader sr);
    public 0hw=(string str);
    private static 0hw=();
    public TextReader 2xw=();
    public void 3Bw=(TextReader value);
    public 6Rw= 3hw=();
    private void 4Bw=();
    private 2T4= 4Rw=(byte ctype, int c);
    private 2T4= 4Rw=(byte ctype, int c, 2T4= excludeState);
    private int 4hw=();
    public bool 4xw=(HB0=& token);
    private bool 5Bw=(thw= sb, bool allowPlus, Char& thisChar);
    public bool 5Rw=(List`1<HB0=> tokens);
    public bool 5hw=(TextReader tr, List`1<HB0=> tokens);
    public bool 5xw=(string str, List`1<HB0=> tokens);
    public bool 6Bw=(Stream s, List`1<HB0=> tokens);
}
internal class GRU=.0Sk= : BSo= {
    public int 0ik=;
    public int 0yk=;
    public int 1Ck=;
    public int 1Sk=;
    public int 1ik=;
    public int 1yk=;
    public byte 2Ck=;
    public virtual int 2Sk=(6Ck= poObjBlock);
    public virtual int 2ik=(6Ck= poObjBlock);
}
internal class GRU=.0yc= : object {
    private String[] 1Cc=;
    public string 1Sc=(string pszName);
    public int 1ic=(string pszName);
    public string 1yc=(string pszStyleString);
}
internal enum GRU=.0yY= : Enum {
    public int value__;
    public static 0yY= 1CY=;
    public static 0yY= 1SY=;
    public static 0yY= 1iY=;
    public static 0yY= 1yY=;
    public static 0yY= 2CY=;
    public static 0yY= 2SY=;
    public static 0yY= 2iY=;
    public static 0yY= 2yY=;
    public static 0yY= 3CY=;
}
internal class GRU=.1Bk= : iBo= {
    internal double 1Rk=;
    internal double 1hk=;
    internal double 1xk=;
    internal double 2Bk=;
    internal double 2Rk=;
    internal double 2hk=;
    internal 1Bk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.1i0= : object {
    private double 9yw=;
    [CompilerGeneratedAttribute]
private int 1y0=;
    [CompilerGeneratedAttribute]
private byte 2C0=;
    [CompilerGeneratedAttribute]
private int 2S0=;
    [CompilerGeneratedAttribute]
private int 2i0=;
    [CompilerGeneratedAttribute]
private ushort 2y0=;
    [CompilerGeneratedAttribute]
private ushort 3C0=;
    public int 3y0= { get; private set; }
    public byte 4i0= { get; private set; }
    public int 5S0= { get; private set; }
    public int 6C0= { get; private set; }
    public ushort 6y0= { get; private set; }
    public ushort 7i0= { get; private set; }
    public 1i0=(double extentWidthLimitation);
    [CompilerGeneratedAttribute]
private void 3i0=(int value);
    [CompilerGeneratedAttribute]
public int 3S0=();
    [CompilerGeneratedAttribute]
private void 4S0=(byte value);
    [CompilerGeneratedAttribute]
public byte 4C0=();
    [CompilerGeneratedAttribute]
private void 5C0=(int value);
    [CompilerGeneratedAttribute]
public int 4y0=();
    [CompilerGeneratedAttribute]
private void 5y0=(int value);
    [CompilerGeneratedAttribute]
public int 5i0=();
    [CompilerGeneratedAttribute]
private void 6i0=(ushort value);
    [CompilerGeneratedAttribute]
public ushort 6S0=();
    [CompilerGeneratedAttribute]
private void 7S0=(ushort value);
    [CompilerGeneratedAttribute]
public ushort 7C0=();
    public void fC0=(int featureDataOffset, byte objectType, mC0= subdivision);
}
internal class GRU=.1i4= : object {
    private int 1y4=;
    private int uC4=;
    private int zRM=;
    public int di4= { get; }
    public int 9i0= { get; }
    public int /S0= { get; }
    public int dC4=();
    public int 9C0=();
    public int 9y0=();
    public void oBw=(Stream stream, int rgnOffset);
}
internal class GRU=.1i8= : object {
    private Collection`1<RC8=> 1y8=;
    private Dictionary`2<string, string> 0CM=;
    private BaseShape 2C8=;
    private long RSA=;
    public long Vy8= { get; public set; }
    public string fxQ= { get; public set; }
    public Collection`1<RC8=> 2i8= { get; }
    public Dictionary`2<string, string> YiA= { get; }
    public BaseShape 3S8= { get; public set; }
    public long VS8=();
    public void Vi8=(long value);
    public string fRQ=();
    public void fhQ=(string value);
    public Collection`1<RC8=> 2S8=();
    public Dictionary`2<string, string> YSA=();
    private RectangleShape 3i8=();
    public BaseShape 2y8=();
    public void 3C8=(BaseShape value);
}
internal enum GRU=.1ig= : Enum {
    public int value__;
    public static 1ig= 1yg=;
    public static 1ig= 2Cg=;
    public static 1ig= 2Sg=;
    public static 1ig= 2ig=;
    public static 1ig= 2yg=;
}
internal static class GRU=.1iQ= : object {
    public static int 1yQ=;
    [ThreadStaticAttribute]
public static List`1<string> 2CQ=;
    [ThreadStaticAttribute]
public static int 2SQ=;
    private static 1iQ=();
    public static List`1<string> 2iQ=(List`1<string> papszStrList, string pszNewString);
    public static int 2yQ=(List`1<string> papszStrList);
    public static string 3CQ=(List`1<string> papszStrList, int iField);
    public static string 3SQ=(List`1<string> papszStrList, string pszName);
    public static void 3iQ=(List`1<string> papszStrList);
    public static int Ixc=(List`1<string> papszList, string pszTarget);
    public static List`1<string> 3yQ=(string pszString);
    public static List`1<string> 4CQ=(string pszString, string pszDelimiters, bool bHonourStrings, bool bAllowEmptyTokens);
    public static List`1<string> 4SQ=(string pszString, string pszDelimiters, int nCSLTFlags);
    public static string 4iQ=(string fmt, Object[] vaList);
    public static string 4yQ=(int nBytes, Byte[] pabyData);
}
internal class GRU=.1iU= : object {
    public int 1yU=;
    public string 2CU=;
    public int 2SU=;
    public double 2iU=;
    public double 2yU=;
    public double 3CU=;
    public double 3SU=;
    public double 3iU=;
    public double 3yU=;
    public double 4CU=;
    public double 4SU=;
    public 1iU=(int nMapInfoDatumID, string pszOGCDatumName, int nEllipsoid, double dfShiftX, double dfShiftY, double dfShiftZ, double dfDatumParm0, double dfDatumParm1, double dfDatumParm2, double dfDatumParm3, double dfDatumParm4);
}
internal class GRU=.1iw= : object {
    private int 1yw=;
    private bool 2Cw=;
    [CompilerGeneratedAttribute]
private Oy0= 2Sw=;
    [CompilerGeneratedAttribute]
private int 2iw=;
    [CompilerGeneratedAttribute]
private 7iw= 2yw=;
    [CompilerGeneratedAttribute]
private ushort uCw=;
    [CompilerGeneratedAttribute]
private ushort 3Cw=;
    public Oy0= 3yw= { get; public set; }
    public int 4iw= { get; private set; }
    public 7iw= 5Sw= { get; public set; }
    public ushort vyw= { get; public set; }
    public ushort 6Cw= { get; public set; }
    public 1iw=(RectangleShape box);
    public 1iw=(Oy0= saver);
    [CompilerGeneratedAttribute]
public void 3iw=(Oy0= value);
    [CompilerGeneratedAttribute]
public Oy0= 3Sw=();
    [CompilerGeneratedAttribute]
private void 4Sw=(int value);
    [CompilerGeneratedAttribute]
public int 4Cw=();
    [CompilerGeneratedAttribute]
public 7iw= 4yw=();
    [CompilerGeneratedAttribute]
public void 5Cw=(7iw= value);
    [CompilerGeneratedAttribute]
public void viw=(ushort value);
    [CompilerGeneratedAttribute]
public ushort vSw=();
    [CompilerGeneratedAttribute]
public void 5yw=(ushort value);
    [CompilerGeneratedAttribute]
public ushort 5iw=();
    public double 6Sw=(1iw= pREntry, bool isLeaf);
    private double 6iw=(1iw= pREntry, bool isLeaf);
    private double 6yw=(1iw= pREntry);
    public void 7Cw=(7iw= childNode);
    public void 7Sw=(int nodeIndex, int entryIndex, List`1& rTree);
}
internal class GRU=.1R8= : ValueType {
    public UInt32 1h8=;
    public ushort 1x8=;
    public ushort 2B8=;
    public ushort 2R8=;
    public ushort 2h8=;
    public UInt32 2x8=;
    public void Kh8=();
    public bool oBw=(BinaryReader r);
    public bool rhw=(BinaryWriter w);
    public virtual string ToString();
}
internal class GRU=.2Bg= : object {
    private dxo= 2Rg=;
    private Dictionary`2<string, dxo=> 2hg=;
    internal dxo= 3Bg= { get; }
    internal 2Bg=(Dictionary`2<string, string> args, Dictionary`2<string, dxo=> pj_Datums_List);
    private string 3Rg=(Dictionary`2<string, string> args);
    private void 3hg=(string datumID);
    internal dxo= 2xg=();
}
internal class GRU=.2C4= : object {
    [CompilerGeneratedAttribute]
private int WC0=;
    [CompilerGeneratedAttribute]
private List`1<Ri4=> Vy0=;
    [CompilerGeneratedAttribute]
private string 2S4=;
    public int YC0= { get; public set; }
    public List`1<Ri4=> XS0= { get; public set; }
    public string 3C4= { get; public set; }
    [CompilerGeneratedAttribute]
public int Xi0=();
    [CompilerGeneratedAttribute]
public void Xy0=(int value);
    [CompilerGeneratedAttribute]
public List`1<Ri4=> Wy0=();
    [CompilerGeneratedAttribute]
public void XC0=(List`1<Ri4=> value);
    [CompilerGeneratedAttribute]
public string 2i4=();
    [CompilerGeneratedAttribute]
public void 2y4=(string value);
}
internal abstract class GRU=.2Cc= : object {
    private int 2Sc=;
    private double 2ic=;
    private wCY= 2yc=;
    private xyY= 3Cc=;
    private string JSc=;
    public 2Cc=(xyY= eClassId);
    public abstract virtual int jxU=();
    public int jxU=(sSc=[] pasStyle, tCc=[] pasValue, int nCount);
    public void 3Sc=();
    public int 3ic=();
    public void 3yc=();
    public xyY= Xic=();
    public void 4Cc=(string pszString);
    public void 4Sc=(wCY= eUnit, double dfScale);
    public wCY= 4ic=();
    public void Nyc=(string pszStyleString);
    public string wCc=(sSc= sStyleParam, tCc= sStyleValue, Int32& bValueIsNull);
    public double zyc=(sSc= sStyleParam, tCc= sStyleValue, Int32& bValueIsNull);
    public void 4yc=(sSc= sStyleParam, tCc= sStyleValue, string pszParamString);
    public double 5Cc=(double dfValue, wCY= eInputUnit);
    public int 5Cc=(int nValue, wCY= eUnit);
}
internal class GRU=.2hs= : object {
    private static UInt32 2xs=;
    private static UInt32 3Bs=;
    private static UInt32 3Rs=;
    private static UInt32 3hs=;
    private static UInt32 3xs=;
    private static UInt32 4Bs=;
    private static UInt32 4Rs=;
    private static UInt32 4hs=;
    private static double WhY=;
    private static double uRs=;
    private static double uhs=;
    private static double 4xs=;
    private static double 5Bs=;
    private static double 5Rs=;
    private static double XBs=;
    private static double XRs=;
    private double 5hs=;
    private double 5xs=;
    private double 6Bs=;
    private double 6Rs=;
    private double 6hs=;
    private double 6xs=;
    private double 7Bs=;
    private double 7Rs=;
    private double 7hs=;
    private double 7xs=;
    internal long 8Bs=(double a, double f);
    internal void 8Rs=(Double& a, Double& f);
    public bool 8hs=(double Latitude, double Longitude, Char& Hemisphere, Double& Easting, Double& Northing);
    internal long 8xs=(double Latitude, double Longitude, Char& Hemisphere, Double& Easting, Double& Northing);
    public bool 9Bs=(char Hemisphere, double Easting, double Northing, Double& Latitude, Double& Longitude);
    internal long 9Rs=(char Hemisphere, double Easting, double Northing, Double& Latitude, Double& Longitude);
}
internal class GRU=.2SE= : object {
    private int 2iE=;
    private int 2yE=;
    private float 3CE=;
    private float 3SE=;
    private GeoImage 3iE=;
    public int 4SE= { get; public set; }
    public int 5CE= { get; public set; }
    public float 5iE= { get; }
    public float 6CE= { get; }
    public GeoImage 6iE= { get; }
    public 2SE=(int screenStartX, int screenStartY, float screenStartPositionX, float screenStartPositionY, GeoImage drawingWholeGeoImage);
    public int 3yE=();
    public void 4CE=(int value);
    public int 4iE=();
    public void 4yE=(int value);
    public float 5SE=();
    public float 5yE=();
    public GeoImage 6SE=();
}
internal class GRU=.2xk= : iBo= {
    internal double 3Bk=;
    internal double Qhk=;
    internal double fxc=;
    internal double 3Rk=;
    internal double 3hk=;
    internal double aBk=;
    internal double 3xk=;
    internal double 4Bk=;
    internal double 4Rk=;
    internal double 4hk=;
    internal double 4xk=;
    internal 2xk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.2xU= : object {
    internal DataTable 3BU=;
    internal string 3RU=;
    internal int 3hU=;
}
internal class GRU=.2yA= : ValueType {
    public bool 3CA=;
    public bool 3SA=;
    public bool 3iA=;
    public bool 3yA=;
    public bool 4CA=;
    public bool 4SA=;
    public bool 4iA=;
    public string 4yA=;
    public bool 2CA=;
    public int 5CA=;
}
internal class GRU=.2yk= : DCo= {
    public int 3Ck=;
    public int 3Sk=;
    public int 3ik=;
    public int iyg=;
    public int jCg=;
    public int 3yk=;
    public int 4Ck=;
    public int 4Sk=;
    public byte 4ik=;
    public byte 4yk=;
    public byte 5Ck=;
    public byte 5Sk=;
    public virtual int 2Sk=(6Ck= poObjBlock);
    public virtual int 2ik=(6Ck= poObjBlock);
    private int DCU=(int nGenoType);
}
internal class GRU=.3B8= : 5B8= {
    private KiA= 3R8=;
    internal KiA= 4B8= { get; internal set; }
    internal 3B8=(8B8= rh, KiA= pt, int idx);
    public virtual string ToString();
    internal KiA= 3h8=();
    internal void 3x8=(KiA= value);
    internal virtual KiA= 4R8=();
    internal virtual bool oBw=(BinaryReader r, bool isFloat);
    internal virtual bool rhw=(BinaryWriter w, bool isFloat);
    internal virtual bool uh8=(ACA= rect);
    internal virtual bool uR8=(ACA= rect);
    internal virtual bool ux8=(ACA= rect);
    internal virtual int kR8=(bool isFloat);
    internal virtual ACA= 4h8=();
    internal virtual double 4x8=();
}
internal class GRU=.3Cg= : object {
    public int OSc=;
    public string 3Sg=;
    public 3Cg=(int nRefCount, string szFontName);
}
internal class GRU=.3i4= : object {
    [CompilerGeneratedAttribute]
private int 3y4=;
    [CompilerGeneratedAttribute]
private int 4C4=;
    [CompilerGeneratedAttribute]
private byte 4S4=;
    [CompilerGeneratedAttribute]
private int 2S0=;
    [CompilerGeneratedAttribute]
private int 2i0=;
    [CompilerGeneratedAttribute]
private long 2y0=;
    [CompilerGeneratedAttribute]
private long 3C0=;
    [CompilerGeneratedAttribute]
private byte 4i4=;
    [CompilerGeneratedAttribute]
private int Ni4=;
    [CompilerGeneratedAttribute]
private int Ny4=;
    [CompilerGeneratedAttribute]
private int OC4=;
    [CompilerGeneratedAttribute]
private int OS4=;
    public int 5S4= { get; public set; }
    public int 6C4= { get; public set; }
    public byte 6y4= { get; public set; }
    public int 5S0= { get; public set; }
    public int 6C0= { get; public set; }
    public long 6y0= { get; public set; }
    public long 7i0= { get; public set; }
    public byte 7i4= { get; public set; }
    public int PC4= { get; public set; }
    public int Py4= { get; public set; }
    public int Qi4= { get; public set; }
    public int RS4= { get; public set; }
    [CompilerGeneratedAttribute]
public int 4y4=();
    [CompilerGeneratedAttribute]
public void 5C4=(int value);
    [CompilerGeneratedAttribute]
public int 5i4=();
    [CompilerGeneratedAttribute]
public void 5y4=(int value);
    [CompilerGeneratedAttribute]
public byte 6S4=();
    [CompilerGeneratedAttribute]
public void 6i4=(byte value);
    [CompilerGeneratedAttribute]
public int 4y0=();
    [CompilerGeneratedAttribute]
public void 5C0=(int value);
    [CompilerGeneratedAttribute]
public int 5i0=();
    [CompilerGeneratedAttribute]
public void 5y0=(int value);
    [CompilerGeneratedAttribute]
public long 6S0=();
    [CompilerGeneratedAttribute]
public void 6i0=(long value);
    [CompilerGeneratedAttribute]
public long 7C0=();
    [CompilerGeneratedAttribute]
public void 7S0=(long value);
    [CompilerGeneratedAttribute]
public byte 7C4=();
    [CompilerGeneratedAttribute]
public void 7S4=(byte value);
    [CompilerGeneratedAttribute]
public int Oi4=();
    [CompilerGeneratedAttribute]
public void Oy4=(int value);
    [CompilerGeneratedAttribute]
public int PS4=();
    [CompilerGeneratedAttribute]
public void Pi4=(int value);
    [CompilerGeneratedAttribute]
public int QC4=();
    [CompilerGeneratedAttribute]
public void QS4=(int value);
    [CompilerGeneratedAttribute]
public int Qy4=();
    [CompilerGeneratedAttribute]
public void RC4=(int value);
    public bool vy4=(NS4= range);
}
internal class GRU=.3ig= : QCo= {
    protected double 3yg=;
    protected short 4Cg=;
    private rig= 4Sg=;
    private static int 8CQ=;
    private static int 8SQ=;
    private static int 8iQ=;
    private static int 8yQ=;
    internal rig= 4yg= { get; }
    public int nyU= { get; public set; }
    public 3Cg= oiU= { get; public set; }
    public 3ig=(OCc= poDefnIn);
    internal rig= 4ig=();
    public virtual oCg= Hig=();
    public virtual hSg= ICg=(OCc= poNewDefn);
    public virtual int ISg=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iig=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iyg=(5yU= fp);
    public virtual int JCg=(5yU= fp);
    public virtual string Nic=();
    public int 5Cg=();
    public void 5Sg=(int nStyle);
    public int 5ig=();
    public void 5yg=(int nStyle);
    public double 6Cg=();
    public void 6Sg=(double dAngle);
    public virtual int nSU=();
    public virtual void niU=(int value);
    public virtual 3Cg= oCU=();
    public virtual void oSU=(3Cg= value);
    public virtual int oyU=();
    public virtual 3Cg= pCU=();
    public virtual string pSU=();
    public virtual void piU=(string pszName);
    public virtual void pyU=(Stream fpOut);
}
internal class GRU=.3jE= : FilterCondition {
    private string SCM=;
    internal 3jE=(string columnName, string operation, string expression);
    internal virtual bool SSM=(KeyValuePair`2<string, string> value);
    internal virtual bool SSM=(Feature feature);
    private bool 3zE=(string parameter, Double& value);
    private bool 4DE=(string inputValue, Double& filterValue);
}
internal class GRU=.3S4= : object {
    [CompilerGeneratedAttribute]
private List`1<2C4=> Vy0=;
    [CompilerGeneratedAttribute]
private List`1<2C4=> mi0=;
    [CompilerGeneratedAttribute]
private List`1<2C4=> my0=;
    [CompilerGeneratedAttribute]
private int 2S0=;
    [CompilerGeneratedAttribute]
private int 2i0=;
    [CompilerGeneratedAttribute]
private int Ni4=;
    [CompilerGeneratedAttribute]
private int Ny4=;
    [CompilerGeneratedAttribute]
private int OC4=;
    [CompilerGeneratedAttribute]
private int OS4=;
    public List`1<2C4=> XS0= { get; public set; }
    public List`1<2C4=> pC0= { get; public set; }
    public List`1<2C4=> py0= { get; public set; }
    public int 5S0= { get; public set; }
    public int 6C0= { get; public set; }
    public int PC4= { get; public set; }
    public int Py4= { get; public set; }
    public int Qi4= { get; public set; }
    public int RS4= { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<2C4=> Wy0=();
    [CompilerGeneratedAttribute]
public void XC0=(List`1<2C4=> value);
    [CompilerGeneratedAttribute]
public List`1<2C4=> oi0=();
    [CompilerGeneratedAttribute]
public void oy0=(List`1<2C4=> value);
    [CompilerGeneratedAttribute]
public List`1<2C4=> pS0=();
    [CompilerGeneratedAttribute]
public void pi0=(List`1<2C4=> value);
    [CompilerGeneratedAttribute]
public int 4y0=();
    [CompilerGeneratedAttribute]
public void 5C0=(int value);
    [CompilerGeneratedAttribute]
public int 5i0=();
    [CompilerGeneratedAttribute]
public void 5y0=(int value);
    [CompilerGeneratedAttribute]
public int Oi4=();
    [CompilerGeneratedAttribute]
public void Oy4=(int value);
    [CompilerGeneratedAttribute]
public int PS4=();
    [CompilerGeneratedAttribute]
public void Pi4=(int value);
    [CompilerGeneratedAttribute]
public int QC4=();
    [CompilerGeneratedAttribute]
public void QS4=(int value);
    [CompilerGeneratedAttribute]
public int Qy4=();
    [CompilerGeneratedAttribute]
public void RC4=(int value);
    public bool vy4=(NS4= range);
}
internal class GRU=.3SM= : object {
    public Collection`1<Feature> 3iM=(string FeatureCollectionString);
    private void 3yM=(JObject joFeature, Feature& feature);
    private Feature 4CM=(JObject joFeature);
    private PointShape 4SM=(JArray PointCoordinates);
    private LineShape 4iM=(JArray LineCoordinates);
    private PolygonShape 4yM=(JArray PolygonCoordinates);
    private MultipolygonShape 5CM=(JArray MultipolygonCoordinates);
}
internal enum GRU=.3SY= : Enum {
    public int value__;
    public static 3SY= 3iY=;
    public static 3SY= 3yY=;
    public static 3SY= 4CY=;
    public static 3SY= 4SY=;
    public static 3SY= 4iY=;
    public static 3SY= 4yY=;
    public static 3SY= 5CY=;
    public static 3SY= 5SY=;
    public static 3SY= 5iY=;
}
internal class GRU=.3xg= : object {
    private eho= 4Bg=;
    private dxo= 4Rg=;
    private Dictionary`2<string, eho=> 4hg=;
    private vhg= 4xg=;
    private Dictionary`2<string, string> 5Bg=;
    internal vhg= 5hg= { get; }
    internal 3xg=(Dictionary`2<string, string> argList, dxo= datums, vhg= pj_consts, Dictionary`2<string, eho=> pj_Ellps_List, Int32& pj_Error);
    private void 5xg=(Dictionary`2<string, string> paras, string ellpsID, Int32& pj_Error);
    internal vhg= 5Rg=();
}
internal static class GRU=.3xU= : object {
    internal static string 4BU=(string esriWkt, IFormatProvider provider);
    internal static string 4RU=(string proj4, IFormatProvider provider);
    private static void 4hU=();
}
internal class GRU=.3y8= : object {
    private BinaryReader 4C8=;
    public 3y8=(string basFile, FileAccess access);
    public Collection`1<string> ii4=();
    public 1i8= 4S8=(long offset);
    public Collection`1<1i8=> 4i8=();
    public void oR8=();
}
internal class GRU=.4iU= : object {
    public int 4yU=;
    public string 5CU=;
    public double 5SU=;
    public double 5iU=;
    public 4iU=(int nMapInfoId, string pszMapinfoName, double dfA, double dfInvFlattening);
}
internal abstract class GRU=.4TE= : object {
    protected static string 4jE=;
    protected static string 4zE=;
    protected static string 5DE=;
    protected static string 5TE=;
    protected static string 5jE=;
    protected static string 5zE=;
    protected static string 6DE=;
    protected static string 6TE=;
    protected static string 6jE=;
    protected static Dictionary`2<string, FilterCondition> 6zE=;
    public abstract virtual StyleJsonDocument jxU=(JObject jsonObject);
    protected static Dictionary`2<int, GeoColor> 7DE=(JObject jsonObject);
    protected static string 7TE=(string styleNodeFilter, string filter);
    protected static Style 7jE=(JObject propertyObject, FilterApplyMode& styleFilterApplyMode);
    protected static void 7zE=(JToken jToken, Dictionary`2<string, string> variables);
}
internal enum GRU=.4xU= : Enum {
    public int value__;
    public static 4xU= 5BU=;
    public static 4xU= 5RU=;
    public static 4xU= 5hU=;
    public static 4xU= 5xU=;
    public static 4xU= 6BU=;
    public static 4xU= 6RU=;
    public static 4xU= 6hU=;
}
internal static class GRU=.4y8= : object {
    public static 1i8= 3iM=(US8= entity);
    private static void 5C8=(1i8= featureEntity, gy8= header);
    private static void 5S8=(1i8= featureEntiye, Collection`1<cy8=> coordinates);
    private static void 5i8=(1i8= featureEntity, Collection`1<ZC8=> annotations);
}
internal abstract class GRU=.5B8= : object {
    internal 8B8= 5R8=;
    internal UInt32 zBM=;
    internal static int 5h8=;
    internal static int 5x8=;
    internal 8B8= 6h8= { get; internal set; }
    public UInt32 rxM= { get; public set; }
    public static 5B8= 7B8=(Gist_Ext_Id extId);
    internal 8B8= 6B8=();
    internal void 6R8=(8B8= value);
    public UInt32 rhM=();
    public void 6x8=(UInt32 value);
    internal UInt32 7R8=();
    internal abstract virtual ACA= 4h8=();
    internal virtual KiA= 4R8=();
    internal abstract virtual bool oBw=(BinaryReader r, bool isFloat);
    internal abstract virtual bool rhw=(BinaryWriter w, bool isFloat);
    internal abstract virtual bool uh8=(ACA= rect);
    internal abstract virtual bool uR8=(ACA= rect);
    internal abstract virtual bool ux8=(ACA= rect);
    internal abstract virtual int kR8=(bool isFloat);
    internal abstract virtual double 4x8=();
}
internal class GRU=.5Bk= : iBo= {
    internal double 5Rk=;
    internal double Yhk=;
    internal double 5hk=;
    internal double 7xg=;
    internal double 5xk=;
    internal double 8Bg=;
    internal double 6Bk=;
    internal double 6Rk=;
    internal double 6hk=;
    internal double 6xk=;
    internal double 2Rk=;
    internal double 2hk=;
    internal double 7Bk=;
    internal double 7Rk=;
    internal double 7hk=;
    internal int 8hg=;
    internal int ghk=;
    internal 5Bk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal static class GRU=.5CQ= : object {
    public static FileAttributes 5SQ=(string pszFilename);
    public static long 5iQ=(Stream fp);
    public static string 5yQ=(string pszBuffer, int nBufferSize, Stream fp, Encoding encoding);
    public static long 6CQ=(Stream fp, long nOffset, int nWhence);
    public static Stream 6SQ=(string pszFilename, FileAccess pszAccess, FileShare fileShare);
    public static void 6iQ=(Stream fp);
    public static void 6yQ=(Stream fp);
    public static int 7CQ=(Byte[] pBuffer, int nSize, int nCount, Stream fp);
    public static int 7SQ=(Byte[] pBuffer, int nSize, int nCount, Stream fp);
    public static bool 7iQ=(Stream fp);
}
internal class GRU=.5ik= : Hio= {
    public byte SCg=;
    public byte Ryg=;
    public byte 5yk=;
    public virtual int 2Sk=(6Ck= poObjBlock);
    public virtual int 2ik=(6Ck= poObjBlock);
}
internal enum GRU=.5SA= : Enum {
    public int value__;
    public static 5SA= 5iA=;
    public static 5SA= 5yA=;
    public static 5SA= 6CA=;
    public static 5SA= 6SA=;
    public static 5SA= 6iA=;
    public static 5SA= 6yA=;
    public static 5SA= 7CA=;
    public static 5SA= 4iA=;
}
internal class GRU=.5Sc= : 2Cc= {
    public sSc=[] 5ic=;
    private tCc=[] vCc=;
    public virtual int jxU=();
}
internal class GRU=.5y8= : object {
    public static Vertex 6C8=(string latlonString);
    public static string 6S8=(Vertex vertex);
    public static Vertex 6i8=(string XY18String);
    public static string 6y8=(Vertex vertex);
    public static Vertex 7C8=(string XY20String);
    public static string 7S8=(Vertex vertex);
    public static DateTime 7i8=(string YYMMDDString);
    public static string 7y8=(DateTime datetime);
    public static float 8C8=(string textAngle);
}
internal class GRU=.5yc= : object {
    public static T[] 6Cc=(T[] srcArray, int destLength);
    public static void 6Sc=(String& pszTarget, double x, double y, double z, int nDimension);
    public static void 6ic=(Char[] pszTarget);
    public static bool 6yc=(string pszInput, Ric= psField, int nOptions);
    public static void 7Cc=(String& pszStrBuf, double dfValue);
}
internal class GRU=.5yU= : object {
    private Stream 6CU=;
    private string 6SU=;
    private static int 6iU=;
    private Char[] 6yU=;
    private Char[] 7CU=;
    private string 7SU=;
    private ESg= 7iU=;
    private double 7yU=;
    private double 8CU=;
    private double 8SU=;
    private double 8iU=;
    private Encoding ER8=;
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    protected void 0x0=(bool isDispose);
    public void oR8=();
    public int FR8=(string pszFname, FileAccess pszAccess);
    public string 8yU=();
    public string 9CU=();
    public int 9SU=();
    public void 9iU=(string pszLine);
    public string 9yU=();
    public void /CU=(string pszFormat, Object[] vaList);
    public bool /SU=(string pszString);
    public void /iU=(double dfXMul, double dfYMul, double dfXTran, double dfYTran);
    public double /yU=(double dfX);
    public double ACY=(double dfY);
    public double ASY=();
    public string AiY=();
    public void AyY=(string pszDelimiter);
    public void BCY=(bool bEof);
}
internal enum GRU=.5yY= : Enum {
    public int value__;
    public static 5yY= 6CY=;
    public static 5yY= 6SY=;
    public static 5yY= 6iY=;
    public static 5yY= 6yY=;
    public static 5yY= 7CY=;
    public static 5yY= 7SY=;
    public static 5yY= 7iY=;
    public static 5yY= 7yY=;
    public static 5yY= 8CY=;
    public static 5yY= 8SY=;
    public static 5yY= 8iY=;
    public static 5yY= 8yY=;
}
internal class GRU=.6Bg= : iBo= {
    internal double 6Rg=;
    internal double fxc=;
    internal double 6hg=;
    internal double 6xg=;
    internal double 7Bg=;
    internal double 7Rg=;
    internal double 7hg=;
    internal double 7xg=;
    internal double 8Bg=;
    internal Double[] 8Rg=;
    internal int 8hg=;
    private double Yxc=;
    internal 6Bg=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal lRo= 9Rg=(lhg= lp, vhg= pjConsts);
    internal lhg= 9hg=(lRo= xy, vhg= pjConsts);
    internal void 9xg=(lhg= lp, vhg= pjConsts, SRg= factors);
    internal void /Bg=(vhg= pjConsts);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    private double PRc=(double sinphi, double e, double one_es, Int32& pj_Error);
    private double ABk=(double qs, double Te, double Tone_es, Int32& pj_Error);
}
internal class GRU=.6Ck= : ySo= {
    public static int 6Sk=;
    protected int NCk=;
    protected int 6ik=;
    protected int 6yk=;
    protected int 7Ck=;
    protected int 7Sk=;
    protected int Nyk=;
    protected int OCk=;
    protected int OSk=;
    protected int Oik=;
    protected int 7ik=;
    protected int 7yk=;
    protected int 8Ck=;
    public 6Ck=(ESg= eAccessMode);
    public virtual int CommitToFile();
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public virtual int GetBlockClass();
    public int Qyk=(bool bCompressed, Int32& nX, Int32& nY);
    public int SSk=(int nX, int nY, bool bCompressed);
    public int 8Sk=(int nXMin, int nYMin, int nXMax, int nYMax, bool bCompressed);
    public int HSg=(int nX, int nY);
    public int 8ik=(BSo= poObjHdr);
    public int 8yk=(BSo= poObjHdr);
    public void 9Ck=(int nNewBlockAddress);
    public int 9Sk=();
    public int 9ik=();
    public void mCg=(Int32& nXMin, Int32& nYMin, Int32& nXMax, Int32& nYMax);
    public void lyg=(int nXMin, int nYMin, int nXMax, int nYMax);
    public void 9SU=();
    public int 9yk=(lSk= poHeader);
    public int /Ck=();
    public int /Sk=();
    public int /ik=();
}
internal enum GRU=.6ig= : Enum {
    public int value__;
    public static 6ig= 6yg=;
    public static 6ig= 7Cg=;
    public static 6ig= 7Sg=;
    public static 6ig= 7ig=;
    public static 6ig= 7yg=;
    public static 6ig= 8Cg=;
    public static 6ig= 8Sg=;
    public static 6ig= 8ig=;
    public static 6ig= 8yg=;
    public static 6ig= 9Cg=;
    public static 6ig= 9Sg=;
    public static 6ig= 9ig=;
    public static 6ig= 9yg=;
}
internal class GRU=.6Rw= : object {
    private Byte[] 6hw=;
    private bool 6xw=;
    private bool 7Bw=;
    private bool 7Rw=;
    private bool 7hw=;
    private bool 7xw=;
    private bool 8Bw=;
    private bool 8Rw=;
    private bool 8hw=;
    public Byte[] 9Bw= { get; }
    public bool 9xw= { get; public set; }
    public bool /hw= { get; public set; }
    public bool AR0= { get; public set; }
    public bool BB0= { get; public set; }
    public bool Bx0= { get; public set; }
    public bool Ch0= { get; public set; }
    public bool DR0= { get; public set; }
    public bool EB0= { get; public set; }
    public Byte[] 8xw=();
    public bool 9Rw=();
    public void 9hw=(bool value);
    public bool /Bw=();
    public void /Rw=(bool value);
    public bool /xw=();
    public void AB0=(bool value);
    public bool Ah0=();
    public void Ax0=(bool value);
    public bool BR0=();
    public void Bh0=(bool value);
    public bool CB0=();
    public void CR0=(bool value);
    public bool Cx0=();
    public void DB0=(bool value);
    public bool Dh0=();
    public void Dx0=(bool value);
    public bool ER0=();
    public void Eh0=();
    public void Ex0=(int c);
    public void FB0=(int startChar, int endChar);
    public void FB0=(string s);
    public void FR0=(int c);
    public void Fh0=(int startChar, int endChar);
    public void Fx0=(int startChar, int endChar);
    public void GB0=(int c);
    public void GR0=(int c);
    public void Gh0=(int c);
    public bool Gx0=(byte ctype, yhw= type);
    public bool Gx0=(char c, yhw= type);
    public bool Gx0=(int c, yhw= type);
}
internal class GRU=.6So= : 7So= {
    private static int 8CQ=;
    private static int 8SQ=;
    private static int 8iQ=;
    private static int 8yQ=;
    public bool 6io=;
    public double 6yo=;
    public double 7Co=;
    public 6So=(OCc= poDefnIn);
    public virtual int HSg=(Vyk= poMapFile);
    public virtual oCg= Hig=();
    public virtual int Hyg=(Vyk= poMapFile);
    public virtual hSg= ICg=(OCc= poNewDefn);
    public virtual int ISg=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iig=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iyg=(5yU= fp);
    public virtual int JCg=(5yU= fp);
    public virtual string Nic=();
    public virtual void JSg=(Stream fsOut);
}
internal class GRU=.6xU= : object {
    internal static string 7BU=;
    internal static string 7RU=;
    internal static string 7hU=;
    internal static string 7xU=;
    internal static string 8BU=;
    internal static string 8RU=;
    internal static string 8hU=;
    internal static string 8xU=;
    internal static string 9BU=;
    internal static string 9RU=;
    internal static string 9hU=;
    internal static string 9xU=;
    internal static string /BU=;
    internal static string /RU=;
    internal static string /hU=;
    internal static string /xU=;
    internal static string ABY=;
    internal static string ARY=;
    internal static string AhY=;
    internal static string AxY=;
    internal static string BBY=;
    internal static string BRY=;
    internal static string BhY=;
    internal static string BxY=;
    internal static string CBY=;
    internal static string CRY=;
    internal static string ChY=;
    internal static string CxY=;
    internal static string DBY=;
    internal static string DRY=;
    internal static string DhY=;
    internal static string DxY=;
    internal static string EBY=;
    internal static string ERY=;
    internal static string EhY=;
    internal static string ExY=;
    internal static string FBY=;
    internal static string FRY=;
    internal static string FhY=;
    internal static string FxY=;
    internal static string GBY=;
    internal static string GRY=;
    internal static string GhY=;
    internal static string GxY=;
    internal static string HBY=;
    internal static string HRY=;
    internal static string HhY=;
    internal static string HxY=;
    internal static string IBY=;
    internal static string IRY=;
    internal static string IhY=;
    internal static string IxY=;
    internal static string JBY=;
    internal static string JRY=;
    internal static string JhY=;
    internal static string JxY=;
    internal static string KBY=;
    internal static string KRY=;
    internal static string KhY=;
    internal static string KxY=;
    internal static string LBY=;
    internal static string LRY=;
    internal static string LhY=;
    internal static string LxY=;
    internal static string MBY=;
    internal static string MRY=;
    internal static string MhY=;
    internal static string MxY=;
    internal static string NBY=;
    internal static string NRY=;
    internal static string NhY=;
    internal static string NxY=;
    internal static string OBY=;
    internal static string ORY=;
    internal static string OhY=;
    internal static string OxY=;
    internal static string PBY=;
    internal static string PRY=;
    internal static string PhY=;
    internal static string PxY=;
    internal static string QBY=;
    internal static string QRY=;
    internal static string QhY=;
    internal static string QxY=;
    internal static string RBY=;
    internal static string RRY=;
    internal static string RhY=;
    internal static string RxY=;
    internal static string SBY=;
    internal static string SRY=;
    internal static string ShY=;
    internal static string SxY=;
    internal static string TBY=;
    internal static string TRY=;
    internal static string ThY=;
    internal static string TxY=;
    internal static string UBY=;
    internal static string URY=;
    internal static string UhY=;
    internal static string UxY=;
    internal static string VBY=;
    internal static string VRY=;
    internal static string VhY=;
    internal static double VxY=;
    internal static double WBY=;
}
internal enum GRU=.6yE= : Enum {
    public int value__;
    public static 6yE= 7CE=;
    public static 6yE= 7SE=;
    public static 6yE= 7iE=;
}
internal class GRU=.7CI= : object {
    private static double 7SI=;
    public static NSM= 7iI=(GridCell[0...,0...] gridPoints, double level, double noDataValue);
    private static Collection`1<Collection`1<GridCell>> 7yI=(double level, viI= functionGrid);
    private static Collection`1<Collection`1<GridCell>> 8CI=(double level, viI= functionGrid);
    private static Collection`1<Collection`1<GridCell>> 8SI=(double level, viI= functionGrid);
    private static Collection`1<GridCell> 8iI=(int leftTopGridIndexX, int leftTopGridIndexY, GridCell enterPoint, KiM= enterDirection, viI= functionGrid);
}
internal class GRU=.7Cs= : object {
    private Byte[] uBw=;
    private ulong RiA=;
    private ulong 7Ss=;
    [CompilerGeneratedAttribute]
private int 7is=;
    [CompilerGeneratedAttribute]
private ulong 7ys=;
    [CompilerGeneratedAttribute]
private vys= 8Cs=;
    public int 8ys= { get; private set; }
    public ulong pxM= { get; private set; }
    public vys= 9ys= { get; private set; }
    public 7Cs=(Byte[] tileBuffer);
    [CompilerGeneratedAttribute]
public int 8Ss=();
    [CompilerGeneratedAttribute]
private void 8is=(int value);
    [CompilerGeneratedAttribute]
public ulong phM=();
    [CompilerGeneratedAttribute]
private void 9Cs=(ulong value);
    [CompilerGeneratedAttribute]
public vys= 9Ss=();
    [CompilerGeneratedAttribute]
private void 9is=(vys= value);
    public long /Cs=();
    public Byte[] /Ss=();
    public List`1<UInt32> /is=();
    public double /ys=();
    public float ACw=();
    public string ASw=(ulong length);
    public bool Aiw=();
    public ulong Ayw=();
    private void BCw=(ulong skip);
}
internal class GRU=.7h8= : object {
    public double 0x8=;
    public 5B8= 7x8=;
    public 7h8=(double minDist, 5B8= record);
    public sealed virtual int CompareTo(object rhs);
}
internal class GRU=.7iw= : object {
    private int 7yw=;
    private int 8Cw=;
    private int 8Sw=;
    private double 8iw=;
    private double 8yw=;
    private double 9Cw=;
    private double vRk=;
    private 1iw= 9Sw=;
    private 1iw= 9iw=;
    private double 9yw=;
    [CompilerGeneratedAttribute]
private UCw= yCM=;
    [CompilerGeneratedAttribute]
private RectangleShape /Cw=;
    [CompilerGeneratedAttribute]
private int /Sw=;
    [CompilerGeneratedAttribute]
private int /iw=;
    [CompilerGeneratedAttribute]
private bool /yw=;
    [CompilerGeneratedAttribute]
private int AC0=;
    [CompilerGeneratedAttribute]
private List`1<1iw=> AS0=;
    [CompilerGeneratedAttribute]
private List`1<1iw=> Ai0=;
    [CompilerGeneratedAttribute]
private int Ay0=;
    [CompilerGeneratedAttribute]
private int BC0=;
    public UCw= wiw= { get; private set; }
    public RectangleShape By0= { get; public set; }
    public int Ci0= { get; private set; }
    public int DS0= { get; private set; }
    public bool EC0= { get; private set; }
    public int Ey0= { get; private set; }
    public List`1<1iw=> Fi0= { get; private set; }
    public List`1<1iw=> GS0= { get; public set; }
    public int HC0= { get; private set; }
    public int Hy0= { get; public set; }
    public 7iw=(UCw= nType, int nMax, int nMin, int depth, double extentWidthLimitation, int accuracy);
    [CompilerGeneratedAttribute]
private void wSw=(UCw= value);
    [CompilerGeneratedAttribute]
public UCw= wCw=();
    [CompilerGeneratedAttribute]
public RectangleShape BS0=();
    [CompilerGeneratedAttribute]
public void Bi0=(RectangleShape value);
    [CompilerGeneratedAttribute]
private void CS0=(int value);
    [CompilerGeneratedAttribute]
public int CC0=();
    [CompilerGeneratedAttribute]
private void DC0=(int value);
    [CompilerGeneratedAttribute]
public int Cy0=();
    [CompilerGeneratedAttribute]
private void Dy0=(bool value);
    [CompilerGeneratedAttribute]
public bool Di0=();
    [CompilerGeneratedAttribute]
private void Ei0=(int value);
    [CompilerGeneratedAttribute]
public int ES0=();
    [CompilerGeneratedAttribute]
private void FS0=(List`1<1iw=> value);
    [CompilerGeneratedAttribute]
public List`1<1iw=> FC0=();
    [CompilerGeneratedAttribute]
public List`1<1iw=> Fy0=();
    [CompilerGeneratedAttribute]
public void GC0=(List`1<1iw=> value);
    [CompilerGeneratedAttribute]
private void Gy0=(int value);
    [CompilerGeneratedAttribute]
public int Gi0=();
    [CompilerGeneratedAttribute]
public void Hi0=(int value);
    [CompilerGeneratedAttribute]
public int HS0=();
    public void ZCI=(1iw= value);
    public bool IC0=(1iw= value);
    public 7iw= IS0=();
    public void bx8=(1iw= DesEntry, List`1& RTree, bool isLeaf);
    public 1iw= Ii0=(1iw= DesEntry, bool isLeaf);
    public RectangleShape Iy0=();
    public void JC0=(int NodeIndex, int EntryIndex);
    public void JS0=(int index, List`1& RTree);
    private void tR8=();
    private void Ji0=(List`1<1iw=> TempAllEntrys, bool isLeaf);
    private 1iw= xB8=(List`1<1iw=> SelectEntrys, bool isLeaf);
}
internal class GRU=.7SA= : ValueType {
    public string 7iA=;
    public string 7yA=;
    public string 8CA=;
}
internal class GRU=.7Sc= : object {
    private string tSc=;
    private 7Sc=[] 7ic=;
    private 7Sc= 7yc=;
    private int 8Cc=;
    public 7Sc=[] 8yc= { get; public set; }
    public 7Sc=(string pszValueIn);
    public 7Sc=[] 8Sc=();
    public void 8ic=(7Sc=[] value);
    private int Hxc=();
    public int 9Cc=();
    public 7Sc= 7R8=(int iChild);
    public 7Sc= Gxc=(string pszName);
    public void 9Sc=(7Sc= poNew, int iChild);
    public void 9ic=(7Sc= poNew);
    public int HBc=(string pszValue);
    public void 9yc=(int iChild);
    public string /Cc=();
    public void /Sc=(string pszNewValue);
    public 7Sc= Hhc=();
    public piY= aSc=(String& ppszResult);
}
internal class GRU=.7So= : hSg= {
    private bool HSo=;
    private bool Nio=;
    private double GSg=;
    private double Gig=;
    private sig= 7io=;
    private nCg= 7yo=;
    public Oyo= qyU= { get; public set; }
    public NSg= iyU= { get; public set; }
    public int riU= { get; public set; }
    public int jiU= { get; public set; }
    public 7So=(OCc= poDefnIn);
    private int 8Co=(Tik=[]& ppasSecHdrs, Vyk= poMAPFile, bool bFlag);
    private int 8So=(mic= poPolygon, Tik=[]& pasSecHdrs, Vyk= poMapFile, Int32& iLastRing);
    public virtual oCg= Hig=();
    public virtual int Hyg=(Vyk= poMapFile);
    public virtual hSg= ICg=(OCc= poNewDefn);
    public int 8io=();
    public fic= 8yo=(int nRequestedRingIndex);
    public virtual int ISg=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iig=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iyg=(5yU= fp);
    public virtual int JCg=(5yU= fp);
    public virtual string Nic=();
    public virtual void JSg=(Stream fsOut);
    public int OSo=(Double& dX, Double& dY);
    public void Oio=(double dX, double dY);
    public virtual int jyU=();
    public virtual NSg= kCU=();
    public virtual int kSU=();
    public virtual int kiU=();
    public virtual byte kyU=();
    public virtual byte lCU=();
    public virtual void lSU=(int clr);
    public virtual void liU=(int clr);
    public virtual void lyU=(byte val);
    public virtual void mCU=(byte val);
    public virtual string mSU=();
    public virtual void miU=(string pszStyleString);
    public virtual void myU=(Stream fpOut);
    public virtual int ryU=();
    public virtual Oyo= sCU=();
    public virtual byte sSU=();
    public virtual double siU=();
    public virtual int syU=();
    public virtual byte tCU=();
    public virtual int tSU=();
    public virtual string tiU=();
    public virtual void tyU=(byte val);
    public virtual void uCU=(double val);
    public virtual void uSU=(int val);
    public virtual void uiU=(byte val);
    public virtual void uyU=(int clr);
    public virtual void vCU=(string pszStyleString);
    public virtual void vSU=(Stream fpOut);
    public sealed virtual void qiU=(Oyo= value);
    public sealed virtual Oyo= qSU=();
    public sealed virtual void iiU=(NSg= value);
    public sealed virtual NSg= iSU=();
    public sealed virtual int rCU=();
    public sealed virtual void rSU=(int value);
    public sealed virtual int jCU=();
    public sealed virtual void jSU=(int value);
}
internal class GRU=.7xk= : iBo= {
    internal int HRk=;
    internal int Hhk=;
    internal 7xk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.7y0= : object {
    [CompilerGeneratedAttribute]
private UInt32 8C0=;
    [CompilerGeneratedAttribute]
private UInt32 8S0=;
    [CompilerGeneratedAttribute]
private List`1<string> 8i0=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, int> 8y0=;
    public UInt32 9i0= { get; private set; }
    public UInt32 /S0= { get; private set; }
    public List`1<string> AC4= { get; public set; }
    public Dictionary`2<string, int> Ay4= { get; private set; }
    [CompilerGeneratedAttribute]
public UInt32 9C0=();
    [CompilerGeneratedAttribute]
private void 9S0=(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 9y0=();
    [CompilerGeneratedAttribute]
private void /C0=(UInt32 value);
    [CompilerGeneratedAttribute]
public void /y0=(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> /i0=();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, int> AS4=();
    [CompilerGeneratedAttribute]
private void Ai4=(Dictionary`2<string, int> value);
    public void BC4=(List`1<string> lbls, Encoding encoding);
    private void BS4=(List`1<string> lbls, Encoding encoding);
}
internal class GRU=.7y4= : object {
    private bi4= 8C4=;
    private Ai8= wS4=;
    private CC8= 8S4=;
    private wC4= 8i4=;
    private 1i4= wi4=;
    private ti4= 8y4=;
    private sy4= wy4=;
    private Stream hC4=;
    private double 9yw=;
    private string zCw=;
    [CompilerGeneratedAttribute]
private int AC0=;
    public Ai8= 9S4= { get; }
    public CC8= 9y4= { get; }
    public wC4= /S4= { get; }
    public int Ey0= { get; public set; }
    public 7y4=(bi4= info, Stream stream, string password, double extentWidthLimitation);
    public Ai8= 9C4=();
    public CC8= 9i4=();
    public wC4= /C4=();
    [CompilerGeneratedAttribute]
public int ES0=();
    [CompilerGeneratedAttribute]
public void Ei0=(int value);
    public void /i4=(bool isEncrypted);
    public void /y4=();
    public void AC8=(Encoding encoding);
    public List`1<Feature> AS8=(NS4= range, int index, Dictionary`2<string, int> returningColumns, yyw= encryptor);
    public List`1<Feature> AS8=(IEnumerable`1<string> featureIds, Dictionary`2<string, int> returningColumns, yyw= encryptor);
}
internal enum GRU=.7yQ= : Enum {
    public int value__;
    public static 7yQ= 8CQ=;
    public static 7yQ= 8SQ=;
    public static 7yQ= 8iQ=;
    public static 7yQ= 8yQ=;
}
internal class GRU=.8B8= : ValueType {
    public ushort 8R8=;
    public ushort 8h8=;
    public UInt32 8x8=;
    public static int kR8=();
    public bool oBw=(BinaryReader r);
    public bool rhw=(BinaryWriter w);
    public virtual string ToString();
}
internal class GRU=.8Bk= : iBo= {
    internal double Ahk=;
    internal double Axk=;
    internal int CRk=;
    internal 8Bk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.8DE= : 4TE= {
    private static string 8TE=;
    private static string 8jE=;
    private static string 8zE=;
    public virtual StyleJsonDocument jxU=(JObject jsonObject);
    protected static List`1<JToken> 9DE=(JObject jsonObject);
    protected static List`1<ValueTuple`2<int, JObject>> 9TE=(JObject jObject);
}
internal class GRU=.8hk= : iBo= {
    private double 8xk=;
    private Double[] 8Rg=;
    internal 8hk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= DRk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lhg= Chk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.8Rk= : iBo= {
    internal double fxc=;
    internal double Rxk=;
    internal double SBk=;
    internal double SRk=;
    internal double Shk=;
    internal double Sxk=;
    internal 8Rk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private int TBk=(vhg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class GRU=.8yI= : object {
    private int lho=;
    private int lxo=;
    public int 9iI= { get; public set; }
    public int /SI= { get; public set; }
    public 8yI=(int x, int y);
    public int 9CI=();
    public void 9SI=(int value);
    public int 9yI=();
    public void /CI=(int value);
}
internal class GRU=.9B8= : ValueType {
    public UInt32 9R8=;
    public ushort 9h8=;
    public ushort 2x8=;
    public bool oBw=(BinaryReader r);
    public bool rhw=(BinaryWriter w);
    public virtual string ToString();
}
internal class GRU=.9Bk= : iBo= {
    internal double shc=;
    internal double sxc=;
    internal double PRk=;
    internal double Phk=;
    internal 9Bk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.9Co= : ByU= {
    private xSg= 9So=;
    private string 9io=;
    private int 9yo=;
    private xSg= /Co=;
    private string /So=;
    private int /io=;
    private BCk= /yo=;
    private int ACs=;
    private Int32[] ASs=;
    private Int32[] Ais=;
    private OCc= GiY=;
    private void Ays=();
    private Byte[] BCs=(hSg= poFeature, int nFieldNo, uig= eType, int nIndexNo);
    public int Kh8=(string pszViewName, xSg= poMainTable, xSg= poRelTable, string pszMainFieldName, string pszRelFieldName, List`1<string> papszSelectedFields);
    public int BSs=();
    public OCc= Bis=();
    public uig= Bys=(int nFieldId);
    public hSg= zCE=(int nFeatureId);
    public int CCs=(hSg= poFeature, int nFeatureIds);
    public int CSs=(OCc= poFeatureDefn);
    public int Cis=(string pszName, uig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public int Cys=(int nFieldId);
    public bool DCs=(int nFieldId);
    public bool DSs=(int nFieldId);
    public string Dis=();
    public string Dys=();
}
internal enum GRU=.9CQ= : Enum {
    public int value__;
    public static 9CQ= 9SQ=;
    public static 9CQ= 9iQ=;
    public static 9CQ= 9yQ=;
    public static 9CQ= /CQ=;
    public static 9CQ= /SQ=;
    public static 9CQ= /iQ=;
    public static 9CQ= /yQ=;
    public static 9CQ= ACU=;
    public static 9CQ= ASU=;
}
internal enum GRU=.9CY= : Enum {
    public int value__;
    public static 9CY= 9SY=;
    public static 9CY= 9iY=;
    public static 9CY= 9yY=;
    public static 9CY= /CY=;
    public static 9CY= /SY=;
    public static 9CY= /iY=;
    public static 9CY= /yY=;
    public static 9CY= ACc=;
    public static 9CY= ASc=;
    public static 9CY= Aic=;
    public static 9CY= Ayc=;
    public static 9CY= BCc=;
    public static 9CY= BSc=;
    public static 9CY= Bic=;
    public static 9CY= Byc=;
    public static 9CY= CCc=;
    public static 9CY= CSc=;
    public static 9CY= Cic=;
    public static 9CY= Cyc=;
    public static 9CY= DCc=;
    public static 9CY= DSc=;
}
internal class GRU=.9hk= : iBo= {
    internal double PRk=;
    internal 9hk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.9hs= : object {
    internal static UInt32 9xs=;
    internal static UInt32 /Bs=;
    internal static UInt32 /Rs=;
    internal static UInt32 /hs=;
    internal static UInt32 /xs=;
    internal static UInt32 ABw=;
    internal static UInt32 ARw=;
    internal static UInt32 Ahw=;
    internal static UInt32 Axw=;
    internal static UInt32 BBw=;
    private static double WhY=;
    private static double BRw=;
    private static double uhs=;
    private static double VRs=;
    private static double Vhs=;
    private static double Vxs=;
    private static double WBs=;
    private double Bhw=;
    private double Bxw=;
    private long CBw=;
    public 9hs=(long _override);
    public bool CRw=(long _override);
    internal long Chw=(double a, double f, long _override);
    internal void Cxw=(Double& a, Double& f, Int64& _override);
    internal long DBw=(double Latitude, double Longitude, Int32& Zone, Char& Hemisphere, Double& Easting, Double& Northing);
    internal long DRw=(int Zone, char Hemisphere, double Easting, double Northing, Double& Latitude, Double& Longitude);
}
internal class GRU=.9jE= : 4TE= {
    private static string 8TE=;
    private static string 8jE=;
    public virtual StyleJsonDocument jxU=(JObject jsonObject);
    protected static List`1<JToken> 9DE=(JObject jsonObject);
    protected static List`1<ValueTuple`2<int, JObject>> 9TE=(JObject jObject);
}
internal class GRU=.9Rk= : iBo= {
    internal 9Rk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.9x8= : 5B8= {
    protected ACA= /B8=;
    public ACA= /x8= { get; public set; }
    public 9x8=(8B8= rh, ACA= rt, int idx);
    public ACA= /R8=();
    public void /h8=(ACA= value);
    internal virtual bool oBw=(BinaryReader r, bool isFloat);
    internal virtual bool rhw=(BinaryWriter w, bool isFloat);
    internal virtual bool uh8=(ACA= rect);
    internal virtual bool uR8=(ACA= rect);
    internal virtual bool ux8=(ACA= rect);
    internal virtual int kR8=(bool isFloat);
    internal virtual ACA= 4h8=();
    internal virtual double 4x8=();
    public virtual string ToString();
}
internal class GRU=.9xk= : iBo= {
    internal double PRk=;
    internal 9xk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.9zE= : FilterCondition {
    private static string cyM=;
    private static string dCM=;
    private static string dSM=;
    private static char diM=;
    [CompilerGeneratedAttribute]
private Regex dyM=;
    [CompilerGeneratedAttribute]
private String[] eCM=;
    [CompilerGeneratedAttribute]
private String[] eSM=;
    public Regex fCM= { get; public set; }
    public String[] fyM= { get; public set; }
    public String[] giM= { get; public set; }
    internal 9zE=(string columnName, string operation, string expression);
    [CompilerGeneratedAttribute]
public Regex eiM=();
    [CompilerGeneratedAttribute]
public void eyM=(Regex value);
    [CompilerGeneratedAttribute]
public String[] fSM=();
    [CompilerGeneratedAttribute]
public void fiM=(String[] value);
    [CompilerGeneratedAttribute]
public String[] gCM=();
    [CompilerGeneratedAttribute]
public void gSM=(String[] value);
    internal virtual bool SSM=(KeyValuePair`2<string, string> v);
    internal virtual bool SSM=(Feature feature);
}
internal class GRU=.AB4= : object {
    [ObfuscationAttribute]
private int baseUriIndex;
    private static int AR4=;
    private static string uhQ=;
    private Timer uxQ=;
    [ObfuscationAttribute]
private Collection`1<Uri> baseUris;
    private bool Ah4=;
    [CompilerGeneratedAttribute]
private string Ax4=;
    [CompilerGeneratedAttribute]
private string BB4=;
    [CompilerGeneratedAttribute]
private double BR4=;
    [CompilerGeneratedAttribute]
private IWebProxy Bh4=;
    [CompilerGeneratedAttribute]
private string Bx4=;
    public Collection`1<Uri> CR4= { get; }
    public string DB4= { get; public set; }
    public string Dx4= { get; public set; }
    public double Eh4= { get; public set; }
    public IWebProxy FR4= { get; public set; }
    public string GB4= { get; public set; }
    public AB4=(string clientId, string clientSecret);
    [AsyncStateMachineAttribute("GRU=.AB4=/KD8=")]
public Task GR4=();
    public Collection`1<Uri> CB4=();
    [CompilerGeneratedAttribute]
public string Ch4=();
    [CompilerGeneratedAttribute]
public void Cx4=(string value);
    [CompilerGeneratedAttribute]
public string DR4=();
    [CompilerGeneratedAttribute]
public void Dh4=(string value);
    [CompilerGeneratedAttribute]
public double EB4=();
    [CompilerGeneratedAttribute]
public void ER4=(double value);
    [CompilerGeneratedAttribute]
public IWebProxy Ex4=();
    [CompilerGeneratedAttribute]
public void FB4=(IWebProxy value);
    [CompilerGeneratedAttribute]
public string Fh4=();
    [CompilerGeneratedAttribute]
public void Fx4=(string value);
    [AsyncStateMachineAttribute("GRU=.AB4=/Iz8=")]
public Task`1<HttpRequestMessage> Gh4=(string apiPath, HttpMethod method);
    private HttpRequestMessage Gx4=(string apiPath, StringContent content);
    [AsyncStateMachineAttribute("GRU=.AB4=/JD8=")]
public Task`1<string> HB4=();
    public virtual void 0x0=();
    private string HR4=();
    [AsyncStateMachineAttribute("GRU=.AB4=/KT8=")]
private void Hh4=();
    [CompilerGeneratedAttribute]
private void Hx4=(object _);
}
internal class GRU=.aBo= : iBo= {
    internal double shc=;
    internal double sxc=;
    internal double tRc=;
    internal aBo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private vhg= tRk=(vhg= pjConsts, double p, Int32& pj_Error);
}
internal class GRU=.ABo= : iBo= {
    internal double shc=;
    internal double sxc=;
    internal double PRk=;
    internal double Phk=;
    internal double FBg=;
    internal ABo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.aC0= : object {
    private List`1<HC4=> aS0=;
    private int ai0=;
    private int ay0=;
    private double 9yw=;
    [CompilerGeneratedAttribute]
private List`1<myw=> Vy0=;
    [CompilerGeneratedAttribute]
private byte bC0=;
    [CompilerGeneratedAttribute]
private int WC0=;
    [CompilerGeneratedAttribute]
private short WS0=;
    [CompilerGeneratedAttribute]
private short Wi0=;
    [CompilerGeneratedAttribute]
private int bS0=;
    [CompilerGeneratedAttribute]
private byte bi0=;
    [CompilerGeneratedAttribute]
private rSw= by0=;
    [CompilerGeneratedAttribute]
private string kCw=;
    [CompilerGeneratedAttribute]
private ushort kSw=;
    public List`1<myw=> XS0= { get; public set; }
    public byte ci0= { get; private set; }
    public int YC0= { get; private set; }
    public short Yy0= { get; private set; }
    public short Zi0= { get; private set; }
    public int dS0= { get; private set; }
    public byte eC0= { get; private set; }
    public rSw= ey0= { get; private set; }
    public string lyw= { get; public set; }
    public ushort miw= { get; public set; }
    public aC0=(double extentWidthLimitation);
    [CompilerGeneratedAttribute]
public void XC0=(List`1<myw=> value);
    [CompilerGeneratedAttribute]
public List`1<myw=> Wy0=();
    [CompilerGeneratedAttribute]
private void cS0=(byte value);
    [CompilerGeneratedAttribute]
public byte cC0=();
    [CompilerGeneratedAttribute]
private void Xy0=(int value);
    [CompilerGeneratedAttribute]
public int Xi0=();
    [CompilerGeneratedAttribute]
private void Yi0=(short value);
    [CompilerGeneratedAttribute]
public short YS0=();
    [CompilerGeneratedAttribute]
private void ZS0=(short value);
    [CompilerGeneratedAttribute]
public short ZC0=();
    [CompilerGeneratedAttribute]
private void dC0=(int value);
    [CompilerGeneratedAttribute]
public int cy0=();
    [CompilerGeneratedAttribute]
private void dy0=(byte value);
    [CompilerGeneratedAttribute]
public byte di0=();
    [CompilerGeneratedAttribute]
private void ei0=(rSw= value);
    [CompilerGeneratedAttribute]
public rSw= eS0=();
    [CompilerGeneratedAttribute]
public void liw=(string value);
    [CompilerGeneratedAttribute]
public string lSw=();
    [CompilerGeneratedAttribute]
public ushort mCw=();
    [CompilerGeneratedAttribute]
public void mSw=(ushort value);
    public void fC0=(double LoCenter, double LaCenter, byte BitsPerCoord, Dictionary`2<string, int> lblDictionary);
    private void fS0=();
    private void fi0=();
}
internal class GRU=.ACA= : ValueType {
    public KiA= ASA=;
    public KiA= AiA=;
    public ACA=(double x1, double y1, double x2, double y2);
    public double AyA=(KiA= p);
    public void BCA=();
    public static int kR8=(bool isFloat);
    public bool oBw=(BinaryReader r, bool isFloat);
    public bool rhw=(BinaryWriter w, bool isFloat);
    public bool uR8=(ACA= testRect);
    public bool uR8=(KiA= testPoint);
    public bool uh8=(ACA= testRect);
    public bool ux8=(ACA= testRect);
    public double BSA=();
    public double BiA=();
    public double 4x8=();
    public bool ByA=(ACA= testRt);
    public DrawingRectangleF CCA=();
    public ACA= CSA=(ACA= rt);
    public double CiA=(ACA= rt);
    public virtual string ToString();
}
internal class GRU=.ahk= : iBo= {
    internal double axk=;
    internal double bBk=;
    internal double bRk=;
    internal double bhk=;
    internal double bxk=;
    internal double cBk=;
    internal double cRk=;
    internal double chk=;
    internal double lRc=;
    internal double cxk=;
    internal double dBk=;
    internal double dRk=;
    internal Double[] 8Rg=;
    internal int CRk=;
    internal ahk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    internal int TBk=(vhg= pjConsts, Double[] del, Double[] sig, Int32& pj_Error);
    private lRo= dhk=(lhg= lp, vhg= pjConsts, Double[] yc, Int32& pj_Error);
}
internal class GRU=.aho= : iBo= {
    internal double shc=;
    internal double sxc=;
    internal double PRk=;
    internal double Phk=;
    internal aho=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Ai8= : object {
    private List`1<3i4=> Ay8=;
    private CC8= 8S4=;
    private Stream hC4=;
    public List`1<3i4=> BS8= { get; }
    public Ai8=(CC8= header, Stream stream);
    public List`1<3i4=> BC8=();
    public void Bi8=();
    private void By8=();
}
internal class GRU=.AiU= : MulticastDelegate {
    public AiU=(object object, IntPtr method);
    public virtual void Invoke(miQ= errEnum, int tempInt, string errorInfo);
    public virtual IAsyncResult BeginInvoke(miQ= errEnum, int tempInt, string errorInfo, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class GRU=.aRk= : iBo= {
    internal aRk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.ARk= : iBo= {
    internal double Ahk=;
    internal double Axk=;
    internal Double[] 8Rg=;
    internal double BBk=;
    internal double BRk=;
    internal double Bhk=;
    internal double Bxk=;
    internal double CBk=;
    internal int CRk=;
    private static double Yxc=;
    internal ARk=(string id, string desc);
    private static ARk=();
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    private lhg= Chk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lhg= Cxk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lRo= DRk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= Dhk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.aRo= : iBo= {
    internal double shc=;
    internal double sxc=;
    internal double tRc=;
    internal aRo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private vhg= tRk=(vhg= pjConsts, double p, Int32& pj_Error);
}
internal class GRU=.ARo= : ValueType {
    internal float Aho=;
    internal float Shk=;
    internal float Sxk=;
    internal float oRk=;
    internal ARo=(float c0, float c1, float c2, float c3);
}
internal static class GRU=.ATI= : object {
    internal static string AjI=;
    internal static string AzI=;
    internal static string BDI=;
    internal static string BTI=;
    internal static string BjI=;
    internal static string BzI=;
    internal static string CDI=;
    internal static string CTI=;
    internal static string CjI=;
    internal static string CzI=;
    internal static String[] DDI=;
    internal static String[] DTI=;
    internal static String[] DjI=;
    internal static String[] DzI=;
    private static ATI=();
}
internal class GRU=.axo= : iBo= {
    internal axo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Axo= : iBo= {
    internal ARo=[] BBo=;
    internal ARo=[] BRo=;
    internal Axo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.ays= : ValueType {
    public double lho=;
    public double lxo=;
}
internal enum GRU=.AyU= : Enum {
    public int value__;
    public static AyU= BCU=;
    public static AyU= BSU=;
    public static AyU= BiU=;
}
internal class GRU=.bBo= : iBo= {
    internal double FRk=;
    internal bBo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.BCk= : ByU= {
    private string 7SU=;
    private Stream Vyg=;
    private ESg= 7iU=;
    private Kig= BSk=;
    private int Bik=;
    private ESk=[] Byk=;
    private Byte[][] CCk=;
    private static int CSk=;
    private int Cik=(int nIndexNumber);
    private int Cyk=();
    private int Px8=();
    public int FR8=(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public int oR8=();
    public int DCk=(int nIndexNumber, uig= eType);
    public Byte[] DSk=(int nIndexNumber, int nValue);
    public Byte[] DSk=(int nIndexNumber, string pszStr);
    public Byte[] DSk=(int nIndexNumber, double dValue);
    public int Dik=(int nIndexNumber, Byte[] pKeyValue);
    public int Dyk=(uig= eType, int nFieldSize);
    public int ECk=(int nIndexNumber, Byte[] pKeyValue, int nRecordNo);
    public sealed virtual void Dispose();
}
internal class GRU=.bCs= : fCU= {
    private string 7SU=;
    private ESg= 7iU=;
    private List`1<string> xig=;
    private string bSs=;
    private List`1<string> bis=;
    private List`1<xSg=> bys=;
    private int cCs=;
    private int cSs=;
    private List`1<string> cis=;
    private List`1<string> cys=;
    private 9Co= dCs=;
    private bool dSs=;
    private int GCs=(string pszFname, bool bTestOpenNoError);
    private int dis=(string pszFname);
    private int dys=(string pszDatasetPath, bool bTestOpenNoError);
    private int 0yg=();
    public virtual int Close();
    public virtual int GetFeatureCount(bool bForce);
    public virtual void ResetReading();
    public virtual int Open(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public virtual int SetQuickSpatialIndexMode(bool bQuickSpatialIndexMode);
    public virtual int GetNextFeatureId(int nPrevId);
    public virtual hSg= GetFeatureRef(int nFeatureId);
    public virtual int SetFeature(hSg= poFeature, int nFeatureId);
    public virtual OCc= GetLayerDefn();
    public virtual int SetFeatureDefn(OCc= poFeatureDefn, List`1<uig=> paeMapInfoNativeFieldTypes);
    public virtual uig= GetNativeFieldType(int nFieldId);
    public virtual int AddFieldNative(string pszName, uig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public virtual int SetFieldIndexed(int nFieldId);
    public virtual bool IsFieldIndexed(int nFieldId);
    public virtual bool IsFieldUnique(int nFieldId);
    public virtual int GetBounds(Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax, bool bForce);
    public virtual piY= GetExtent(Gyc= psExtent, bool bForce);
    public virtual int GetFeatureCountByType(Int32& numPoints, Int32& numLines, Int32& numRegions, Int32& numTexts, bool bForce);
    public virtual pSc= GetSpatialRef();
    public virtual int SetSpatialRef(pSc= poSpatialRef);
    public virtual int SetBounds(double dXMin, double dYMin, double dXMax, double dYMax);
    public virtual bool TestCapability(string pszCap);
}
internal class GRU=.bh8= : sR8= {
    public bh8=(cB8= page);
    internal virtual bool bx8=(5B8= insertRec, sR8=[]& nodeList);
}
internal class GRU=.bho= : iBo= {
    internal double FRk=;
    internal int CRk=;
    internal bho=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Bho= : ValueType {
    internal int Bxo=;
    internal double yBg=;
    internal double CBo=;
    internal Double[] oBk=;
    public Bho=(int nb, double es, double E, Double[] b);
}
internal class GRU=.bi4= : object {
    [CompilerGeneratedAttribute]
private string tC0=;
    [CompilerGeneratedAttribute]
private int by4=;
    [CompilerGeneratedAttribute]
private int cC4=;
    [CompilerGeneratedAttribute]
private int WC0=;
    public string vC0= { get; public set; }
    public int cy4= { get; public set; }
    public int di4= { get; public set; }
    public int YC0= { get; public set; }
    [CompilerGeneratedAttribute]
public string ui0=();
    [CompilerGeneratedAttribute]
public void uy0=(string value);
    [CompilerGeneratedAttribute]
public int cS4=();
    [CompilerGeneratedAttribute]
public void ci4=(int value);
    [CompilerGeneratedAttribute]
public int dC4=();
    [CompilerGeneratedAttribute]
public void dS4=(int value);
    [CompilerGeneratedAttribute]
public int Xi0=();
    [CompilerGeneratedAttribute]
public void Xy0=(int value);
}
internal class GRU=.Bi4= : object {
    private double 9yw=;
    private Encoding ER8=;
    [CompilerGeneratedAttribute]
private List`1<string> By4=;
    [CompilerGeneratedAttribute]
private FeatureLayer CC4=;
    [CompilerGeneratedAttribute]
private int CS4=;
    [CompilerGeneratedAttribute]
private Collection`1<string> Ci4=;
    public List`1<string> DS4= { get; public set; }
    public FeatureLayer EC4= { get; public set; }
    public int Ey4= { get; private set; }
    public Collection`1<string> Fi4= { get; private set; }
    public double GC4= { get; }
    public Encoding Gi4= { get; }
    public Bi4=(FeatureLayer featureLayer, IEnumerable`1<string> columnNames, Uiw= accuracy, Collection`1<string> ids, double extentWidthLimitation, Encoding encoding);
    [CompilerGeneratedAttribute]
public List`1<string> Cy4=();
    [CompilerGeneratedAttribute]
public void DC4=(List`1<string> value);
    [CompilerGeneratedAttribute]
public FeatureLayer Di4=();
    [CompilerGeneratedAttribute]
public void Dy4=(FeatureLayer value);
    [CompilerGeneratedAttribute]
public int ES4=();
    [CompilerGeneratedAttribute]
private void Ei4=(int value);
    [CompilerGeneratedAttribute]
public Collection`1<string> FC4=();
    [CompilerGeneratedAttribute]
private void FS4=(Collection`1<string> value);
    public double Fy4=();
    public Encoding GS4=();
    private static int Gy4=(Uiw= accuracy);
}
internal class GRU=.Biw= : ValueType {
    [CompilerGeneratedAttribute]
private int Byw=;
    [CompilerGeneratedAttribute]
private int CCw=;
    [CompilerGeneratedAttribute]
private int CSw=;
    [CompilerGeneratedAttribute]
private int Ciw=;
    public int DSw= { get; public set; }
    public int ECw= { get; public set; }
    public int Eyw= { get; public set; }
    public int Fiw= { get; public set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int Cyw=();
    [CompilerGeneratedAttribute]
public void DCw=(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int Diw=();
    [CompilerGeneratedAttribute]
public void Dyw=(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int ESw=();
    [CompilerGeneratedAttribute]
public void Eiw=(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int FCw=();
    [CompilerGeneratedAttribute]
public void FSw=(int value);
    public virtual string ToString();
}
internal class GRU=.bRo= : iBo= {
    internal double FRk=;
    internal bRo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.BSo= : GSU= {
    public byte Bio=;
    public int Byo=;
    public int Nyk=;
    public int OCk=;
    public int OSk=;
    public int Oik=;
    public static BSo= CCo=(byte nNewObjType, int nId);
    public static BSo= CSo=(6Ck= poObjBlock, lSk= poHeader);
    public bool Cio=();
    public int Cyo=(6Ck= poObjBlock);
    public void lyg=(int nMinX, int nMinY, int nMaxX, int nMaxY);
    public virtual int 2Sk=(6Ck= poObjBlock);
    public virtual int 2ik=(6Ck= poObjBlock);
}
internal class GRU=.BSw= : ValueType {
    [CompilerGeneratedAttribute]
private int Dhw=;
    [CompilerGeneratedAttribute]
private int Dxw=;
    public int 9iI= { get; public set; }
    public int /SI= { get; public set; }
    public BSw=(int x, int y);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int 9CI=();
    [CompilerGeneratedAttribute]
public void 9SI=(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int 9yI=();
    [CompilerGeneratedAttribute]
public void /CI=(int value);
    public virtual bool Equals(object obj);
    private bool khU=(BSw= pointI);
    public static bool 2hM=(BSw= a, BSw= b);
    public static bool 2xM=(BSw= a, BSw= b);
    public virtual int GetHashCode();
}
internal class GRU=.BSY= : fCU= {
    private string 7SU=;
    private ESg= 7iU=;
    private int BiY=;
    private string 6SU=;
    private string ByY=;
    private string CCY=;
    private string CSY=;
    private List`1<uig=> CiY=;
    private List`1<bool> CyY=;
    private List`1<bool> DCY=;
    private double 7yU=;
    private double 8CU=;
    private double 8SU=;
    private double 8iU=;
    private double DSY=;
    private double DiY=;
    private double DyY=;
    private double ECY=;
    private int ESY=;
    private Gyc= EiY=;
    private int EyY=;
    private int FCY=;
    private int FSY=;
    private int FiY=;
    private int FyY=;
    private 5yU= GCY=;
    private 5yU= GSY=;
    private OCc= GiY=;
    private pSc= GyY=;
    private int HCY=;
    private int HSY=;
    private bool HiY=;
    private bool HyY=;
    private int ICY=();
    private void ISY=();
    private int IiY=(string pszLine);
    private int IyY=(int nFeatureId);
    private int JCY=();
    private int JSY=();
    private void JiY=(double dfX, double dfY);
    public virtual int Close();
    public virtual 1ig= GetFileClass();
    public virtual int Open(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public virtual string GetTableName();
    public virtual bool TestCapability(string pszCap);
    public virtual int GetFeatureCount(bool bForce);
    public virtual void ResetReading();
    public virtual piY= GetExtent(Gyc= psExtent, bool bForce);
    public virtual int GetNextFeatureId(int nPrevId);
    public virtual hSg= GetFeatureRef(int nFeatureId);
    public virtual OCc= GetLayerDefn();
    public virtual uig= GetNativeFieldType(int nFieldId);
    public virtual int GetBounds(Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax, bool bForce);
    public virtual pSc= GetSpatialRef();
    public virtual int GetFeatureCountByType(Int32& numPoints, Int32& numLines, Int32& numRegions, Int32& numTexts, bool bForce);
    public virtual bool IsFieldIndexed(int nFieldId);
    public virtual bool IsFieldUnique(int nFieldId);
    public virtual int SetBounds(double dXMin, double dYMin, double dXMax, double dYMax);
    public virtual int SetFeatureDefn(OCc= poFeatureDefn, List`1<uig=> paeMapInfoNativeFieldTypes);
    public virtual int AddFieldNative(string pszName, uig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public virtual int SetSpatialRef(pSc= poSpatialRef);
    public virtual int SetFeature(hSg= poFeature, int nFeatureId);
    public virtual int SetFieldIndexed(int nFieldId);
    public virtual int GetProjInfo(hCo= poPI);
    public virtual int SetProjInfo(hCo= poPI);
    public virtual int SetMIFCoordSys(string pszMIFCoordSys);
    public void 0x0=();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class GRU=.bxo= : object {
    private iBo= cBo=;
    private Dictionary`2<string, string> cRo=;
    internal iBo= cxo= { get; }
    internal bxo=(Dictionary`2<string, string> proj_List);
    private string dBo=(Dictionary`2<string, string> args);
    internal void dRo=(Dictionary`2<string, string> args);
    internal iBo= cho=();
    private bool dho=(string projID);
}
internal class GRU=.ByU= : GSU= {
    public static ySo= CCU=(Stream fsSrc, int nOffset, int nSize, bool bHardBlockSize, ESg= eAccessMode);
    public static int CSU=(Char[] charArray);
    public static Char[] CiU=(Char[] szCharSet, Char[] szCharSetToBeFound);
    public static int CyU=(Char[] numCharArray);
    public static int DCU=(int nGeomType);
    public static bool DSU=(int numSegments, int umVerticesTotal);
    public static int DiU=(double dX);
    public static byte DyU=(int color);
    public static byte ECU=(int color);
    public static byte ESU=(int color);
    public static bool EiU=(string charArray1, string charArray2, int count);
    public static bool EyU=(string charArray1, string charArray2);
    public static T[] FCU=(T[] srcArray, int destLength);
    public static void FSU=(Double& min, Double& max);
    public static void FSU=(Int32& min, Int32& max);
    public static string FiU=(uig= type);
    public static qyY= FyU=(int x);
    public static bool GCU=(T[] src, int indexSrc, T[] dest, int indexDest, int count);
}
internal class GRU=.cB8= : rR8= {
    public cB8=(RtreeFile rtFile, UInt32 pageNo, Gist_Ext_Id extId);
    public cB8=(RtreeFile rtFile, Gist_Ext_Id extId);
    internal virtual 5B8= cR8=();
    internal virtual int ch8=();
    internal virtual bool cx8=(kB8= ent, int idx);
}
internal class GRU=.CC8= : object {
    private int eC4=;
    private int ei4=;
    private int eS4=;
    private int ey4=;
    private byte 7yw=;
    private ushort CS8=;
    public int zC0= { get; }
    public int zy0= { get; }
    public int 0i0= { get; }
    public int 1S0= { get; }
    public byte jC0= { get; }
    public ushort Hy0= { get; }
    public int yi0=();
    public int zS0=();
    public int 0C0=();
    public int 0y0=();
    public byte ii0=();
    public ushort HS0=();
    public void oBw=(Stream stream, int treOffset);
}
internal class GRU=.cCc= : Yyc= {
    private int cSc=;
    private Yyc=[] cic=;
    public virtual string ayc=();
    public virtual qyY= aic=();
    public virtual Yyc= Zic=();
    public virtual piY= aSc=(String& ppszDstText);
    public virtual void Zyc=(Gyc= psEnvelope);
    public int cyc=();
    public Yyc= dCc=(int i);
    public virtual piY= dSc=(Yyc= poNewGeom);
    public virtual piY= dic=(Yyc= poNewGeom);
    public virtual piY= dyc=(int iGeom, int bDelete);
}
internal class GRU=.Ci8= : object {
    private iCw= Cy8=;
    private string Ky4=;
    public Ci8=(string tGeoFilePathName);
    public void Px8=(List`1<si0=> shifterTGeoFATs, Bi4= tGeoParameters, double extentWidthLimitation, TinyGeoFileType type);
    private void DC8=(si0= shifterTGeoFAT, int startPart, Encoding encoding);
    public void DS8=(string rgnTempPath);
    public void Di8=(string treTempPath);
    public void Dy8=(string lblTempPath);
    public void oR8=();
}
internal enum GRU=.ciY= : Enum {
    public int value__;
    public static ciY= cyY=;
    public static ciY= dCY=;
    public static ciY= dSY=;
    public static ciY= diY=;
    public static ciY= dyY=;
    public static ciY= eCY=;
    public static ciY= eSY=;
    public static ciY= eiY=;
    public static ciY= eyY=;
    public static ciY= fCY=;
    public static ciY= fSY=;
    public static ciY= fiY=;
}
internal class GRU=.CRo= : iBo= {
    internal double Cho=;
    internal double Cxo=;
    internal double DBo=;
    internal double DRo=;
    internal double Dho=;
    internal double Dxo=;
    internal double EBo=;
    internal double ERo=;
    internal double Eho=;
    internal double Exo=;
    internal double FBo=;
    internal double FRo=;
    internal double Fho=;
    internal double Fxo=;
    internal double GBo=;
    internal double lBc=;
    internal double lRc=;
    internal double lhc=;
    internal double lxc=;
    internal double mBc=;
    internal double GRo=;
    internal double Gho=;
    internal double Gxo=;
    internal double qhc=;
    internal double HBo=;
    internal double HRo=;
    internal double Hho=;
    internal double qxc=;
    internal double Hxo=;
    internal double IBo=;
    internal double IRo=;
    internal double Iho=;
    internal double Ixo=;
    internal double JBo=;
    internal Bho= 8Rg=;
    private int cBc=;
    internal CRo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private Bho= JRo=(double es);
    private double Jho=(double phi, double sphi, double cphi, Bho= b, Int32& pj_Error);
    private double Jxo=(double dist, Bho= b, Int32& pj_Error);
}
internal class GRU=.cSM= : FilterCondition {
    private bool ciM=;
    private static string cyM=;
    private static string dCM=;
    private static string dSM=;
    private static char diM=;
    [CompilerGeneratedAttribute]
private Regex dyM=;
    [CompilerGeneratedAttribute]
private String[] eCM=;
    [CompilerGeneratedAttribute]
private String[] eSM=;
    public Regex fCM= { get; public set; }
    public String[] fyM= { get; public set; }
    public String[] giM= { get; public set; }
    internal cSM=(string columnName, string operation, string expression);
    [CompilerGeneratedAttribute]
public Regex eiM=();
    [CompilerGeneratedAttribute]
public void eyM=(Regex value);
    [CompilerGeneratedAttribute]
public String[] fSM=();
    [CompilerGeneratedAttribute]
public void fiM=(String[] value);
    [CompilerGeneratedAttribute]
public String[] gCM=();
    [CompilerGeneratedAttribute]
public void gSM=(String[] value);
    internal virtual bool SSM=(KeyValuePair`2<string, string> v);
    internal virtual bool SSM=(Feature feature);
}
internal class GRU=.cy8= : object {
    private string ZS8=;
    private string dC8=;
    private string dS8=;
    private string di8=;
    private string dy8=;
    private string eC8=;
    private string eS8=;
    private string ei8=;
    public bool fC8= { get; }
    public string fy8= { get; public set; }
    public string gi8= { get; public set; }
    public bool ey8=();
    public string fS8=();
    public void fi8=(string value);
    public string gC8=();
    public void gS8=(string value);
    public void oBw=(BinaryReader reader);
}
internal class GRU=.dB8= : RTPage {
    protected 1R8= dR8=;
    protected 9B8= dh8=;
    protected int dx8=;
    protected static int eB8=;
    protected static string eR8=;
    public 1R8= fB8= { get; public set; }
    public dB8=(RtreeFile rtFile, UInt32 pageNo, Gist_Ext_Id extId);
    public dB8=(RtreeFile rtFile, Gist_Ext_Id extId);
    internal virtual bool fR8=(5B8= rec);
    internal virtual void fh8=(int idx);
    public virtual bool fx8=();
    public 1R8= eh8=();
    public void ex8=(1R8= value);
    internal ushort gB8=();
    internal void gR8=(ushort level);
    internal void gh8=(UInt32 pageNo);
    internal void gx8=();
    public int hB8=();
    public bool hR8=();
    public bool hh8=();
    public bool hx8=();
    public bool iB8=();
    public virtual 5B8= iR8=();
    public virtual 5B8= ih8=();
    public bool ix8=();
    public virtual 5B8= jB8=(int idx);
    internal virtual int ch8=();
    public virtual string jR8=();
    public virtual ACA= jh8=();
    public UInt32 jx8=();
    internal virtual bool cx8=(kB8= ent, int idx);
}
[DefaultMemberAttribute("Item")]
internal class GRU=.dCE= : sCE= {
    private static giE= UiE=;
    private diE= VSE=;
    public diE= ZSE= { get; }
    public string whw= { get; public set; }
    public dCE=(diE= headerRecord);
    public dCE=(diE= headerRecord, String[] values);
    public dCE=(diE= headerRecord, bool readOnly, String[] values);
    public dCE=(diE= headerRecord, IEnumerable`1<string> values);
    public dCE=(diE= headerRecord, bool readOnly, IEnumerable`1<string> values);
    internal dCE=(diE= headerRecord, IList`1<string> values);
    private static dCE=();
    public diE= YyE=();
    public string wBw=(string columnName);
    public void wRw=(string columnName, string value);
    public string dSE=(string columnName);
    public sealed virtual bool Equals(dCE= other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class GRU=.DCo= : BSo= {
    public int DSo=;
    public int Dio=;
}
internal class GRU=.diA= : object {
    private static double dyA=;
    private static int eCA=;
    private static int eSA=;
    private static int eiA=;
    private static int eyA=;
    private static int fCA=;
    private static float fSA=;
    private static float fiA=;
    private static float fyA=;
    private static int gCA=;
    private static int gSA=;
    private static double WhY=;
    private static double giA=;
    private static double gyA=;
    private Double[] hCA=;
    private Double[] hSA=;
    private Double[] hiA=;
    private Double[] hyA=;
    private Int32[] iCA=;
    private Int32[] iSA=;
    private Int32[] iiA=;
    private Int32[] iyA=;
    private String[] jCA=;
    private Single[] jSA=;
    private Single[] jiA=;
    private Single[] jyA=;
    private Single[] kCA=;
    private Single[] kSA=;
    private int kiA=;
    private int kyA=;
    private int lCA=;
    private int lSA=;
    private int liA=;
    private int lyA=;
    private float mCA=;
    private float mSA=;
    private float miA=;
    private float myA=;
    private float nCA=;
    private double nSA=;
    private double niA=;
    private double nyA=;
    private double oCA=;
    private double BBo=;
    private double BRo=;
    private double oSA=;
    private double FBg=;
    private double gBc=;
    private double oiA=;
    private double oyA=;
    private double pCA=;
    private double pSA=;
    private double piA=;
    private double pyA=;
    private double qCA=;
    private double qSA=;
    private double qiA=;
    private double qyA=;
    private double rCA=;
    private double rSA=;
    private double riA=;
    private double ryA=;
    private double sCA=;
    private double sSA=;
    private double siA=;
    private double syA=;
    private 2yA= tCA=;
    public double tyA= { get; public set; }
    public double uiA= { get; public set; }
    public double vCA= { get; }
    public float vyA= { get; public set; }
    public double tSA=();
    public void tiA=(double value);
    public double uCA=();
    public void uSA=(double value);
    public double uyA=();
    public float vSA=();
    public void viA=(float value);
    private void wCA=(2yA= Msg, string Caller);
    private void wSA=(Stream magneticFieldStream);
    private static double wiA=(DateTime myDate);
    public void wyA=(string magneticFieldFilePathName, DateTime thisDate, double Lat, double Lon, float Elevation, ySA=& Result);
    public void wyA=(Stream magneticFieldStream, DateTime thisDate, double Lat, double Lon, float Elevation, ySA=& Result);
    private int xCA=(Stream magneticFieldStream, int iflag, long StartRec, int nMax_of_GH, int GH);
    private int xSA=(double mYear, double dTe1, int nMax1, int nMax2, int GH);
    private int xiA=(double mYear, double dte1, int nmax1, double dte2, int nmax2, int gh);
    private int xyA=(int IDGDC, double fLat, double fLon, float Elev, int nMax, int gh, int iExt, float Ext1, float Ext2, float Ext3);
    private int yCA=(int GH);
}
internal enum GRU=.Dic= : Enum {
    public int value__;
    public static Dic= Dyc=;
    public static Dic= ECc=;
    public static Dic= ESc=;
    public static Dic= Eic=;
    public static Dic= Eyc=;
    public static Dic= FCc=;
    public static Dic= FSc=;
    public static Dic= Fic=;
}
[DefaultMemberAttribute("Item")]
internal class GRU=.diE= : sCE= {
    private static giE= UiE=;
    private IDictionary`2<string, int> dyE=;
    public int whw= { get; }
    public string Item { get; public set; }
    public diE=(String[] columnNames);
    public diE=(bool readOnly, String[] columnNames);
    public diE=(IEnumerable`1<string> columnNames);
    public diE=(bool readOnly, IEnumerable`1<string> columnNames);
    internal diE=(IList`1<string> columnNames);
    private static diE=();
    public int wBw=(string columnName);
    public Nullable`1<int> eCE=(string columnName);
    public virtual string get_Item(int index);
    public virtual void set_Item(int index, string value);
    public virtual void Add(string value);
    public virtual void Insert(int index, string value);
    public virtual void Clear();
    public virtual bool Remove(string value);
    public virtual void RemoveAt(int index);
    private void eSE=(int startIndex, bool checkForDuplicates);
}
internal enum GRU=.DSg= : Enum {
    public int value__;
    public static DSg= Dig=;
    public static DSg= Dyg=;
    public static DSg= ECg=;
}
internal class GRU=.DTA= : object {
    private String[] DjA=;
    private int DzA=;
    public DTA=(TextReader reader, Char[] delimiter);
    public string EDA=();
}
internal class GRU=.dxk= : iBo= {
    internal double shc=;
    internal double sxc=;
    internal double tRc=;
    internal int Txk=;
    internal dxk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.dxo= : object {
    internal string eBo=;
    internal string eRo=;
    internal dxo=(string id, string defn, string ellipse_id);
}
internal class GRU=.dy4= : object {
    private double xS0=;
    private double eC4=;
    private double eS4=;
    private double ei4=;
    private double ey4=;
    private long fC4=;
    private long fS4=;
    private long fi4=;
    private long fy4=;
    private string Ky4=;
    private List`1<tiw=> gC4=;
    private List`1<7y4=> gS4=;
    private pi4= gi4=;
    private oi4= gy4=;
    private Stream hC4=;
    private BinaryReader hS4=;
    private double 9yw=;
    private string zCw=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Dh8=;
    public dy4=(string tGeoFilePathName);
    [CompilerGeneratedAttribute]
public void nR8=(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void nh8=(EventHandler`1<StreamLoadingEventArgs> value);
    public void FR8=(bool isEncrypted, string password);
    public TinyGeoFileType hi4=();
    private String[] hy4=(bool isEncrypted);
    public void iC4=(bool isEncrypted);
    private void iS4=();
    public RectangleShape qBo=();
    public Collection`1<FeatureSourceColumn> ii4=();
    public void iy4=(string targetFile);
    public void lxQ=(string targetFile);
    private void jC4=(string targetFile);
    private void jS4=(string targetFile);
    private void ji4=(string targetFile);
    private void jy4=(string targetFile);
    private void kC4=(string targetFile);
    private void kS4=(string targetFile);
    private void ki4=(string targetFile);
    private void ky4=(string targetFile);
    private void lC4=(string targetFile);
    private void lS4=(string targetFile, TSw= encryptMode);
    private List`1<tiw=> li4=(tiw= node);
    private List`1<tiw=> ly4=(RectangleShape box, tiw= node);
    public void mC4=();
    public List`1<Feature> mS4=(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    public List`1<Feature> mS4=(RectangleShape box, IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    public List`1<Feature> mS4=(RectangleShape box, IEnumerable`1<string> returningColumnNames);
    private NS4= mi4=(RectangleShape rect);
    private Dictionary`2<string, int> my4=(IEnumerable`1<string> returningColumnNames);
    public void oB8=(StreamLoadingEventArgs e);
    private void nC4=(List`1<7iw=> rtree);
    public String[] nS4=(bool isEncrypted);
    public void ni4=();
    public void ny4=(Int32[] select, bool isEncrypted);
    public void ny4=(bool isEncrypted);
    private void oC4=(bool isEncrypted);
    public List`1<Feature> oS4=(NS4= range, List`1<tiw=> queryIndeces, Dictionary`2<string, int> returningColumns, int startIndex, int takeCount);
    public List`1<Feature> oS4=(IEnumerable`1<string> ids, Dictionary`2<string, int> returningColumns);
    public void oR8=();
}
internal class GRU=.Dyo= : BSo= {
    public int ECo=;
    public int ESo=;
    public int Eio=;
    public int Eyo=;
    public byte 2Ck=;
    public virtual int 2Sk=(6Ck= poObjBlock);
    public virtual int 2ik=(6Ck= poObjBlock);
}
internal class GRU=.DzE= : object {
    public sealed virtual int Compare(FeatureLabelingCandidate x, FeatureLabelingCandidate y);
}
internal class GRU=.eBk= : iBo= {
    internal double shc=;
    internal double sxc=;
    internal double PRk=;
    internal double Phk=;
    internal eBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.EBk= : iBo= {
    internal double ERk=;
    internal double Ahk=;
    internal double Axk=;
    internal double Ehk=;
    internal int CRk=;
    internal int Exk=;
    internal EBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.EBs= : object {
    private static EBs= ERs=;
    private GeoJsonSerializeStrategy Ehs=;
    public static EBs= FBs= { get; }
    public GeoJsonSerializeStrategy Fxs= { get; public set; }
    public static EBs= Exs=();
    public GeoJsonSerializeStrategy FRs=();
    public void Fhs=(GeoJsonSerializeStrategy value);
    public string GBs=(XElement xElement);
    public string GRs=(object obj);
    public XElement Ghs=(object obj);
    public XElement Gxs=(string json);
    public XElement Gxs=(string json, Encoding encoding);
    public T HBs=(XElement xElement);
    public T HRs=(string json, Encoding encoding);
    private static string Hhs=(XElement element);
    private static XAttribute Hxs=(GeoJsonType type);
    private object IBs=(object obj);
    private IEnumerable`1<XElement> IRs=(object obj);
    private static string Ihs=(PropertyInfo property);
    private IEnumerable`1<XElement> Ixs=(T obj);
    private GeoJsonType JBs=(object obj);
    [CompilerGeneratedAttribute]
private XElement JRs=(object o);
}
internal class GRU=.EC8= : object {
    private iCw= ES8=;
    private int Ei8=;
    private int zRM=;
    public EC8=(string outPut);
    public void Dy8=(7y0= lblPara, Encoding encoding);
    public void oR8=();
    public void Ey8=();
}
internal abstract class GRU=.eCc= : object {
    protected bool eSc=;
    protected Yyc= eic=;
    protected Gyc= eyc=;
    protected bool fCc=(Yyc= poGeometry);
    protected bool fSc=(Yyc= poFilter);
    public virtual void SetSpatialFilter(Yyc= poGeomIn);
    public abstract virtual void ResetReading();
    public virtual ICc= GetNextFeature();
    public virtual ICc= GetFeature(long nFID);
    public virtual piY= CreateFeature(ICc= poFeature);
    public abstract virtual OCc= GetLayerDefn();
    public virtual pSc= GetSpatialRef();
    public virtual int GetFeatureCount(bool bForce);
    public virtual piY= GetExtent(Gyc= psExtent, bool bForce);
    public abstract virtual bool TestCapability(string pszCap);
}
internal enum GRU=.eCs= : Enum {
    public byte value__;
    public static eCs= QSU=;
    public static eCs= QiU=;
    public static eCs= QyU=;
    public static eCs= RCU=;
    public static eCs= RSU=;
    public static eCs= RiU=;
    public static eCs= RyU=;
    public static eCs= SCU=;
    public static eCs= SSU=;
    public static eCs= SiU=;
    public static eCs= SyU=;
    public static eCs= TCU=;
    public static eCs= TSU=;
    public static eCs= TiU=;
    public static eCs= TyU=;
    public static eCs= UCU=;
    public static eCs= USU=;
    public static eCs= UiU=;
    public static eCs= UyU=;
    public static eCs= VCU=;
    public static eCs= VSU=;
    public static eCs= ViU=;
    public static eCs= VyU=;
    public static eCs= WCU=;
    public static eCs= WSU=;
    public static eCs= WiU=;
    public static eCs= WyU=;
    public static eCs= XCU=;
    public static eCs= XSU=;
    public static eCs= XiU=;
    public static eCs= XyU=;
    public static eCs= YCU=;
    public static eCs= YSU=;
    public static eCs= YiU=;
    public static eCs= YyU=;
    public static eCs= ZCU=;
    public static eCs= ZSU=;
    public static eCs= ZiU=;
    public static eCs= ZyU=;
    public static eCs= aCU=;
    public static eCs= aSU=;
    public static eCs= aiU=;
    public static eCs= ayU=;
}
internal class GRU=.ECs= : fCU= {
    private string 7SU=;
    private string ESs=;
    private OCc= Eis=;
    private xSg= Eys=;
    private int FCs=;
    private int FSs=;
    private xSg= Fis=;
    private bool Fys=;
    private int GCs=(string pszFname, bool bTestOpenNoError);
    private int GSs=(hSg= poIndexFeature, bool bTestOpenNoError);
    private int GSs=(int nTableId, bool bTestOpenNoError);
    private int Gis=(bool bTestOpenNoError);
    private int Gys=(int nTableId, int nBaseFeatureId);
    private int HCs=(int nEncodedFeatureId);
    private int HSs=(int nEncodedFeatureId);
    public virtual int Close();
    public virtual 1ig= GetFileClass();
    public virtual int Open(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public virtual string GetTableName();
    public virtual void SetSpatialFilter(Yyc= poGeomIn);
    public virtual void ResetReading();
    public virtual bool TestCapability(string pszCap);
    public virtual int GetFeatureCount(bool bForce);
    public virtual piY= GetExtent(Gyc= psExtent, bool bForce);
    public virtual int GetNextFeatureId(int nPrevId);
    public virtual hSg= GetFeatureRef(int nFeatureId);
    public virtual OCc= GetLayerDefn();
    public virtual uig= GetNativeFieldType(int nFieldId);
    public virtual int GetBounds(Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax, bool bForce);
    public virtual pSc= GetSpatialRef();
    public virtual int GetFeatureCountByType(Int32& numPoints, Int32& numLines, Int32& numRegions, Int32& numTexts, bool bForce);
    public virtual bool IsFieldIndexed(int nFieldId);
    public virtual bool IsFieldUnique(int nFieldId);
    public virtual int SetBounds(double dXMin, double dYMin, double dXMax, double dYMax);
    public virtual int SetFeatureDefn(OCc= poFeatureDefn, List`1<uig=> paeMapInfoNativeFieldTypes);
    public virtual int AddFieldNative(string pszName, uig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public virtual int SetSpatialRef(pSc= poSpatialRef);
    public virtual int SetFeature(hSg= poFeature, int nFeatureId);
    public virtual int SetFieldIndexed(int nFieldId);
    public virtual int GetProjInfo(hCo= poPI);
    public virtual int SetProjInfo(hCo= poPI);
    public virtual int SetMIFCoordSys(string pszMIFCoordSys);
}
internal class GRU=.EDE= : object {
    private double ETE=;
    private double EjE=;
    private PointShape EzE=;
    public PointShape FTE= { get; }
    public double FzE= { get; }
    public double GTE= { get; }
    public EDE=(PointShape midLinePoint, double lineSegmentLength, double angle);
    public PointShape FDE=();
    public double FjE=();
    public double GDE=();
}
internal static class GRU=.EDI= : object {
    internal static String[] ETI=;
    internal static String[] EjI=;
    private static EDI=();
}
internal static class GRU=.EDM= : object {
    [CompilerGeneratedAttribute]
private static string ETM=;
    private static NzM= EjM=;
    private static NzM= EzM=;
    private static NzM= FDM=;
    private static string FTM=;
    private static string FjM=;
    private static string qDA=;
    internal static string FzM=;
    private static string GDM=;
    private static Guid[] GTM=;
    private static NzM= GjM=;
    private static object GzM=;
    private static Nullable`1<bool> HDM=;
    private static Nullable`1<bool> HTM=;
    public static string IDM= { get; public set; }
    public static NzM= IjM= { get; }
    private static EDM=();
    [CompilerGeneratedAttribute]
public static string HjM=();
    [CompilerGeneratedAttribute]
public static void HzM=(string value);
    public static void IzM=(Dictionary`2<string, Collection`1<string>> licenseContents);
    public static NzM= ITM=();
    private static NzM= JDM=();
    internal static bool JTM=();
    private static NzM= JjM=(bool needToShowProductCenter);
    private static void JzM=(string uri);
    private static NzM= KDM=();
    private static string KTM=(JxQ= currentNode);
    internal static Guid KjM=();
    private static Guid KzM=();
    private static Guid LDM=();
    private static bool LTM=(Guid productId);
    [IteratorStateMachineAttribute("GRU=.EDM=/tUA=")]
private static IEnumerable`1<string> LjM=();
    internal static JxQ= LzM=(Assembly assembly);
    internal static JxQ= MDM=(Assembly assembly);
    public static bool MTM=();
    public static bool MjM=();
    internal static JxQ= LzM=(Guid productId);
    private static JxQ= MzM=(Guid productId);
    private static int NDM=(JxQ= productNode);
    private static Guid NTM=();
    private static Guid NjM=(Assembly assembly);
}
internal class GRU=.ehk= : iBo= {
    internal double exk=;
    internal double fBk=;
    internal double fRk=;
    internal double PRk=;
    internal double ERg=;
    internal double fhk=;
    internal double fxk=;
    internal double gBk=;
    internal double gRk=;
    internal int ghk=;
    internal ehk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.eho= : object {
    internal string exo=;
    internal string fBo=;
    internal eho=(string id, string major, string ell, string name);
}
internal static class GRU=.eiE= : object {
    [DebuggerHiddenAttribute]
public static void eyE=(T arg, string argName);
    [DebuggerHiddenAttribute]
public static void eyE=(Nullable`1<T> arg, string argName);
    [DebuggerHiddenAttribute]
public static void fCE=(T arg, string argName);
    [DebuggerHiddenAttribute]
public static void eyE=(IEnumerable`1<T> arg, string argName, bool assertContentsNotNull);
    [DebuggerHiddenAttribute]
public static void fSE=(string arg, string argName);
    [DebuggerHiddenAttribute]
public static void fSE=(IEnumerable arg, string argName);
    [DebuggerHiddenAttribute]
public static void fSE=(ICollection arg, string argName);
    [DebuggerHiddenAttribute]
public static void fiE=(string arg, string argName);
    [DebuggerHiddenAttribute]
public static void fyE=(TEnum enumValue, string argName);
    [DebuggerHiddenAttribute]
public static void fyE=(TEnum enumValue, string argName, TEnum[] validValues);
    private static bool gCE=(string arg);
    private static IEnumerable`1<T> gSE=();
}
internal class GRU=.eRk= : iBo= {
    internal double shc=;
    internal eRk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal enum GRU=.ESg= : Enum {
    public int value__;
    public static ESg= Eig=;
    public static ESg= Eyg=;
    public static ESg= FCg=;
}
internal class GRU=.ESk= : ByU= {
    private Stream Vyg=;
    private ESg= 7iU=;
    private ESk= Eik=;
    private ESk= Eyk=;
    private Kig= FCk=;
    private int FSk=;
    private int Fik=;
    private uig= Fyk=;
    private bool GCk=;
    private int GSk=;
    private int Gik=;
    private ySo= Gyk=;
    private int HCk=;
    private int HSk=;
    private int Hik=;
    public ESk=(ESg= eAccessMode);
    private int Hyk=(int nNewNodePtr);
    private int ICk=(int nEntryNo, Byte[] pKeyValue);
    private int ISk=(Byte[] pKeyValue, int nEntryNo);
    private int Iik=(Byte[] pKeyValue, int nRecordNo, bool bInsertAfterCurChild, bool bMakeNewEntryCurChild);
    private int Iyk=(int numEntries, Byte[] pBuf, int nCurIndexEntry, ESk= poCurChild);
    public int JCk=(Stream fs, int nBlockPtr, int nKeyLength, int nSubTreeDepth, bool bUnique, Kig= poBlockMgr, ESk= poParentNode, int nPrevNodePtr, int nNextNodePtr);
    public int JSk=(uig= eType);
    public int Jik=();
    public int Jyk=();
    public int KCk=();
    public int KSk=();
    public int Kik=();
    public int Dik=(Byte[] pKeyValue);
    public int Kyk=();
    public int ECk=(Byte[] pKeyValue, int nRecordNo, bool bAddInThisNodeOnly, bool bInsertAfterCurChild, bool bMakeNewEntryCurChild);
    public int bx8=();
    public int LCk=();
    public Byte[] LSk=();
    public int Lik=(Byte[] pKeyValue, int nRecordNo);
    public int Lyk=(Byte[] pKeyValue1, int nRecordNo1, Byte[] pKeyValue2, int nRecordNo2, int nNewCurChildNo);
    public int MCk=(int nPrevNodePtr);
    public int MSk=(int nNextNodePtr);
}
internal enum GRU=.eSs= : Enum {
    public int value__;
    public static eSs= riQ=;
    public static eSs= eis=;
    public static eSs= rSQ=;
}
internal class GRU=.Exc= : object {
    internal static String[] FBc=;
    internal static String[] FRc=;
    internal static String[] Fhc=;
    internal static List`1<String[]> Fxc=;
    internal List`1<Exc=> GBc=;
    internal Exc= GRc=;
    internal string Ghc=;
    internal Exc=(string nodeValue);
    private static Exc=();
    internal Exc= Gxc=(string nodeName);
    internal int HBc=(string nodeValue);
    internal void HRc=();
    internal Exc= Hhc=();
    private bool Hxc=();
    internal string qBY=();
    internal void IBc=(Char[] wktCharArray, Int32& processedIndex);
    internal void IRc=(string node, String[] mappingTable, int srcIndex, int dstIndex, int stepSize);
    internal void IRc=(string node, String[] mappingTable, int srcIndex, int dstIndex, int stepSize, bool childOfHit);
    internal void Ihc=(string nodeValue);
    internal void 8BY=();
    private int Ixc=(String[] list, string target);
}
internal class GRU=.exs= : object {
    internal static UInt32 fBs=;
    internal static UInt32 fRs=;
    internal static UInt32 fhs=;
    internal static UInt32 fxs=;
    internal static UInt32 gBs=;
    internal static UInt32 gRs=;
    internal static UInt32 ghs=;
    internal static UInt32 gxs=;
    internal static UInt32 hBs=;
    internal static UInt32 hRs=;
    private static double WhY=;
    private static double Wxc=;
    private static double hhs=;
    private static double hxs=;
    private double iBs=;
    private double iRs=;
    private double yBg=;
    private double ihs=;
    private double ixs=;
    private double jBs=;
    private double jRs=;
    private double jhs=;
    private double jxs=;
    private double kBs=;
    private double kRs=;
    private double khs=;
    private double kxs=;
    private double lBs=;
    private double lRs=;
    private double lhs=;
    public exs=(double Latitude_of_True_Scale, double Longitude_Down_from_Pole, double False_Easting, double False_Northing);
    private double lxs=(double EsSin);
    public bool mBs=(double Latitude_of_True_Scale, double Longitude_Down_from_Pole, double False_Easting, double False_Northing);
    internal long mRs=(double a, double f, double Latitude_of_True_Scale, double Longitude_Down_from_Pole, double False_Easting, double False_Northing);
    internal long mhs=(double a, double f, double Latitude_of_True_Scale, double Longitude_Down_from_Pole, double False_Easting, double False_Northing);
    public void mxs=(Double& Latitude_of_True_Scale, Double& Longitude_Down_from_Pole, Double& False_Easting, Double& False_Northing);
    internal void nBs=(Double& a, Double& f, Double& Latitude_of_True_Scale, Double& Longitude_Down_from_Pole, Double& False_Easting, Double& False_Northing);
    public bool nRs=(double Latitude, double Longitude, Double& Easting, Double& Northing);
    internal long nhs=(double Latitude, double Longitude, Double& Easting, Double& Northing);
    public bool nxs=(double Easting, double Northing, Double& Latitude, Double& Longitude);
    internal long oBs=(double Easting, double Northing, Double& Latitude, Double& Longitude);
}
internal enum GRU=.exw= : Enum {
    public int value__;
    public static exw= fBw=;
    public static exw= fRw=;
    public static exw= fhw=;
    public static exw= fxw=;
}
internal class GRU=.EyI= : ValueType {
    private double FCI=;
    private double FSI=;
    private double FiI=;
    private double FyI=;
    public double GiI= { get; public set; }
    public double HSI= { get; public set; }
    public double ICI= { get; public set; }
    public double IyI= { get; public set; }
    public EyI=(double maxLat, double minLat, double maxLong, double minLong);
    public double GCI=();
    public void GSI=(double value);
    public double GyI=();
    public void HCI=(double value);
    public double HiI=();
    public void HyI=(double value);
    public double ISI=();
    public void IiI=(double value);
}
internal enum GRU=.eys= : Enum {
    public int value__;
    public static eys= lSE=;
    public static eys= fCs=;
}
internal static class GRU=.EzI= : object {
    internal static string CTI=;
    internal static string CjI=;
    internal static String[] FDI=;
    internal static string FTI=;
    internal static String[] FjI=;
    private static EzI=();
}
internal class GRU=.FBk= : iBo= {
    internal double FRk=;
    internal int CRk=;
    internal FBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.FC8= : object {
    private iCw= FS8=;
    private iCw= Fi8=;
    private UInt32 Fy8=;
    private int zRM=;
    private int Ei8=;
    private bool GC8=;
    private bool GS8=;
    private bool Gi8=;
    private MemoryStream Gy8=;
    [CompilerGeneratedAttribute]
private List`1<int> HC8=;
    [CompilerGeneratedAttribute]
private List`1<byte> HS8=;
    public List`1<int> IC8= { get; private set; }
    public List`1<byte> Iy8= { get; private set; }
    public FC8=(string output);
    [CompilerGeneratedAttribute]
private void Hy8=(List`1<int> value);
    [CompilerGeneratedAttribute]
public List`1<int> Hi8=();
    [CompilerGeneratedAttribute]
private void Ii8=(List`1<byte> value);
    [CompilerGeneratedAttribute]
public List`1<byte> IS8=();
    public void Px8=();
    public void JC8=();
    public void JS8=(VS0= rgnPoint);
    public void Ji8=(fy0= rgnLine);
    public void Jy8=(aC0= rgnGon);
    public void KC8=();
    public void oR8=();
    public void Ey8=();
}
internal class GRU=.fCI= : object {
    private Quadtree`1<object> fSI=;
    private List`1<int> zBM=;
    public void fiI=(double x, double y, int value);
    public void fyI=(double xMin, double xMax, double yMin, double yMax);
    public void gCI=();
    public List`1<int> gSI=();
    public fCI= Hhc=();
}
internal class GRU=.FCo= : DCo= {
    public int FSo=;
    public int iyg=;
    public int jCg=;
    public byte Fio=;
    public int Fyo=;
    public int GCo=;
    public virtual int 2Sk=(6Ck= poObjBlock);
    public virtual int 2ik=(6Ck= poObjBlock);
}
internal abstract class GRU=.fCU= : eCc= {
    protected int fSU=;
    protected hSg= fiU=;
    protected bool fyU=;
    protected string gCU=;
    public Encoding gSU=;
    public virtual 1ig= GetFileClass();
    public abstract virtual int Open(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public abstract virtual int Close();
    public virtual int SetQuickSpatialIndexMode(bool bQuickSpatialIndexMode);
    public virtual string GetTableName();
    public static fCU= giU=(string pszFname, bool bTestOpenNoError, Encoding encoding);
    public virtual int GetFeatureCount(bool bForce);
    public virtual ICc= GetNextFeature();
    public virtual ICc= GetFeature(long nFeatureId);
    public virtual piY= CreateFeature(ICc= poFeature);
    public abstract virtual piY= GetExtent(Gyc= psExtent, bool bForce);
    public abstract virtual int GetNextFeatureId(int nPrevId);
    public abstract virtual hSg= GetFeatureRef(int nFeatureId);
    public abstract virtual uig= GetNativeFieldType(int nFieldId);
    public abstract virtual int GetBounds(Double& dXMin, Double& dYMin, Double& dXMax, Double& YMax, bool bForce);
    public abstract virtual pSc= GetSpatialRef();
    public abstract virtual int GetFeatureCountByType(Int32& numPoints, Int32& numLines, Int32& numRegions, Int32& numTexts, bool bForce);
    public abstract virtual bool IsFieldIndexed(int nFieldId);
    public abstract virtual bool IsFieldUnique(int nFieldId);
    public abstract virtual int SetBounds(double dXMin, double dYMin, double dXMax, double dYMax);
    public virtual int SetFeatureDefn(OCc= poFeatureDefn, List`1<uig=> paeMapInfoNativeFieldTypes);
    public abstract virtual int AddFieldNative(string pszName, uig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public abstract virtual int SetSpatialRef(pSc= poSpatialRef);
    public abstract virtual int SetFeature(hSg= poFeature, int nFeatureId);
    public abstract virtual int SetFieldIndexed(int nFieldId);
    public virtual int GetProjInfo(hCo= poPI);
    public virtual int SetProjInfo(hCo= poPI);
    public virtual int SetMIFCoordSys(string pszMIFCoordSys);
}
internal class GRU=.Fhk= : iBo= {
    internal Thc=[] Fxk=;
    internal double GBk=;
    internal double GRk=;
    internal int fxc=;
    internal Fhk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private Thc= Ghk=(Thc= z, Thc=[] C, int n, Thc= der);
    private Thc= Gxk=(Thc= z, Thc=[] C, int n);
}
internal class GRU=.fic= : gyc= {
    public fic=(fic= poSrcRing);
    public virtual int fyc=(int b3D);
    public virtual string ayc=();
    public virtual Yyc= Zic=();
    public virtual int gCc=();
    public virtual void gSc=();
    public virtual double gic=();
}
internal class GRU=.fRo= : object {
    internal string fho=;
    internal string fxo=;
    internal string gBo=;
    internal long gRo=;
    internal URc= gho=;
    internal List`1<fRo=> gxo=;
}
internal class GRU=.FSg= : hSg= {
    private double Fig=;
    private double Fyg=;
    private static int 8CQ=;
    private static int 8SQ=;
    private static int 8iQ=;
    private static int 8yQ=;
    private sig= GCg=;
    public double GSg=;
    public double Gig=;
    public double Gyg=;
    public double HCg=;
    public Oyo= qyU= { get; public set; }
    public int riU= { get; public set; }
    public FSg=(OCc= poDefnIn);
    public virtual int HSg=(Vyk= poMapFile);
    public virtual oCg= Hig=();
    public virtual int Hyg=(Vyk= poMapFile);
    public virtual hSg= ICg=(OCc= poNewDefn);
    public virtual int ISg=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iig=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iyg=(5yU= fp);
    public virtual int JCg=(5yU= fp);
    public virtual string Nic=();
    public virtual void JSg=(Stream fsOut);
    public double Jig=();
    public double Jyg=();
    public void KCg=(double dAngle);
    public void KSg=(double dAngle);
    public virtual int ryU=();
    public virtual Oyo= sCU=();
    public virtual byte sSU=();
    public virtual double siU=();
    public virtual int syU=();
    public virtual byte tCU=();
    public virtual int tSU=();
    public virtual string tiU=();
    public sealed virtual Oyo= qSU=();
    public sealed virtual void qiU=(Oyo= value);
    public virtual int rCU=();
    public virtual void rSU=(int value);
    public virtual void tyU=(byte val);
    public virtual void uCU=(double val);
    public virtual void uSU=(int val);
    public virtual void uiU=(byte val);
    public virtual void uyU=(int clr);
    public virtual void vCU=(string pszStyleString);
    public virtual void vSU=(Stream fpOut);
}
internal class GRU=.fy0= : object {
    private List`1<HC4=> aS0=;
    private int ai0=;
    private int ay0=;
    private double 9yw=;
    [CompilerGeneratedAttribute]
private List`1<myw=> Vy0=;
    [CompilerGeneratedAttribute]
private byte gC0=;
    [CompilerGeneratedAttribute]
private int WC0=;
    [CompilerGeneratedAttribute]
private short WS0=;
    [CompilerGeneratedAttribute]
private short Wi0=;
    [CompilerGeneratedAttribute]
private int bS0=;
    [CompilerGeneratedAttribute]
private byte bi0=;
    [CompilerGeneratedAttribute]
private rSw= by0=;
    [CompilerGeneratedAttribute]
private string kCw=;
    [CompilerGeneratedAttribute]
private ushort kSw=;
    public List`1<myw=> XS0= { get; public set; }
    public byte gy0= { get; private set; }
    public int YC0= { get; private set; }
    public short Yy0= { get; private set; }
    public short Zi0= { get; private set; }
    public int dS0= { get; private set; }
    public byte eC0= { get; private set; }
    public rSw= ey0= { get; private set; }
    public string lyw= { get; public set; }
    public ushort miw= { get; public set; }
    public fy0=(double extentWidthLimitation);
    [CompilerGeneratedAttribute]
public void XC0=(List`1<myw=> value);
    [CompilerGeneratedAttribute]
public List`1<myw=> Wy0=();
    [CompilerGeneratedAttribute]
private void gi0=(byte value);
    [CompilerGeneratedAttribute]
public byte gS0=();
    [CompilerGeneratedAttribute]
private void Xy0=(int value);
    [CompilerGeneratedAttribute]
public int Xi0=();
    [CompilerGeneratedAttribute]
private void Yi0=(short value);
    [CompilerGeneratedAttribute]
public short YS0=();
    [CompilerGeneratedAttribute]
private void ZS0=(short value);
    [CompilerGeneratedAttribute]
public short ZC0=();
    [CompilerGeneratedAttribute]
private void dC0=(int value);
    [CompilerGeneratedAttribute]
public int cy0=();
    [CompilerGeneratedAttribute]
private void dy0=(byte value);
    [CompilerGeneratedAttribute]
public byte di0=();
    [CompilerGeneratedAttribute]
private void ei0=(rSw= value);
    [CompilerGeneratedAttribute]
public rSw= eS0=();
    [CompilerGeneratedAttribute]
public string lSw=();
    [CompilerGeneratedAttribute]
public void liw=(string value);
    [CompilerGeneratedAttribute]
public ushort mCw=();
    [CompilerGeneratedAttribute]
public void mSw=(ushort value);
    public void fC0=(double LoCenter, double LaCenter, byte BitsPerCoord, Dictionary`2<string, int> lblDictionary);
    private void fS0=();
    private void fi0=();
}
internal enum GRU=.Fyc= : Enum {
    public int value__;
    public static Fyc= GCc=;
    public static Fyc= GSc=;
    public static Fyc= Gic=;
}
internal static class GRU=.Fyw= : object {
    public static Byte[] GCw=(Byte[] bytes);
    public static Byte[] GSw=(Byte[] bytes);
    internal static Byte[] Giw=(Uri styleJsonUri);
    internal static Collection`1<Feature> Gyw=(Collection`1<VectorTile> vectorTiles, List`1<string> pbfLayerNames);
    private static Byte[] HCw=(Uri styleJsonUri, Int32& count);
    private static BSw=[] HSw=(BSw=[] points, int simplificationFactor);
    internal static double Hiw=(ZoomLevelSet zoomLevelSet, int zoomLevel);
    internal static RectangleShape Hyw=(long tileX, long tileY, int zoomLevel, int tileSize);
    internal static BSw= ICw=(double pointX, double pointY, int zoomLevel, int tileSize, RectangleShape tileBoundingBox);
    internal static List`1<string> ISw=(Collection`1<string> sourceString, int startIndex, int count);
    private static void Iiw=(BSw=[] input, Biw= tileScreenBoundingBox, List`1<int> clippedPoints, List`1<int> parts);
    private static List`1<BSw=> Iyw=(BSw=[] inputPoints, Biw= tileScreenBoundingBox);
    private static void JCw=(BSw=[] points, int firstPoint, int lastPoint, double tolerance, List`1<int> pointIndexsToKeep);
    private static double JSw=(BSw=& a, BSw=& b, BSw=& c);
    private static double Jiw=(BSw=& a, BSw=& b, BSw=& c);
    private static double Jyw=(BSw=& a, BSw=& b);
    private static double KCw=(BSw=& a, BSw=& b, BSw=& c);
    private static BSw=[] KSw=(BSw=[] inputPoints, double tolerance);
    private static bool Kiw=(IList`1<BSw=> points, int numPoints);
    private static SkA= Kyw=(double x, double y, Biw=& tileScreenBoundingBox);
    private static bool LCw=(Double& x0, Double& y0, Double& x1, Double& y1, Biw=& tileScreenBoundingBox, TEA=& clipState);
}
internal static class GRU=.fyY= : object {
    public static List`1<0CU=> gCY=;
    public static List`1<0CU=> gSY=;
    private static fyY=();
    public static void giY=();
    private static void gyY=();
    private static void hCY=(Stream deCompressedStream);
    private static 0CU= hSY=(string wholeData);
    public static bool hiY=(double a, double b);
    private static byte hyY=(string byteStr);
    public static bool iCY=(hCo= psCS, Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax);
    public static int iSY=(string pszFname);
    public static int iSY=(string pszFname, Encoding encoding);
    public static void iiY=();
}
internal static class GRU=.FzI= : object {
    internal static string GDI=;
    internal static string GTI=;
    internal static string GjI=;
    internal static string GzI=;
    internal static string HDI=;
    internal static string AzI=;
    internal static string BDI=;
    internal static string HTI=;
    internal static string HjI=;
    internal static string HzI=;
    internal static string IDI=;
    internal static string ITI=;
    internal static string IjI=;
    internal static string BjI=;
    internal static string IzI=;
    internal static string JDI=;
    internal static string JTI=;
    internal static string JjI=;
    internal static string CTI=;
    internal static string CjI=;
    internal static String[] JzI=;
    internal static String[] DTI=;
    internal static string KDI=;
    internal static String[] KTI=;
    internal static string KjI=;
    internal static string KzI=;
    internal static string LDI=;
    private static FzI=();
}
internal class GRU=.gBg= : object {
    private Dictionary`2<string, eho=> gRg=;
    private Dictionary`2<string, dxo=> ghg=;
    private Dictionary`2<string, hho=> gxg=;
    private Dictionary`2<string, hBo=> hBg=;
    private Dictionary`2<string, string> hRg=;
    private int hhg=;
    private void hxg=();
    private void iBg=();
    private void iRg=();
    private void ihg=();
    private void ixg=();
    internal iBo= jBg=(string args);
    internal int YRg=(iBo= srcdefn, iBo= dstdefn, long point_count, int point_offset, ixo=[] uvList, Double[] z);
    private void jRg=(2Bg= datum, jho= unitObj, lxg= meridian, iBo= projObj, Dictionary`2<string, string> argList);
    private void jhg=(dxo= pjDatum, Dictionary`2<string, string> args, iBo= projObj);
    private void jxg=(iBo= projObj, string projName);
    private void kBg=(Stream stream, string keyField, iBo= projObj);
    private bool kRg=(string lineStr);
    private void khg=(hho= pjUnit, Dictionary`2<string, string> args, iBo= projObj);
    private double kxg=(hBo= meri);
    private double lBg=(string meriDefn, Int32& pj_Error);
}
internal static class GRU=.GBU= : object {
    public static string FxU=(IEnumerable`1<string> source, string delimiter);
}
internal class GRU=.gCg= : object {
    public static int gSg=(double x0, double x, double x1);
    public static void gig=(double a, double b, double t);
    public static fic= gyg=(mic= poly, int i);
}
internal class GRU=.GCM= : object {
    private GridCell GSM=;
    private GridCell GiM=;
    private GridCell GyM=;
    private GridCell HCM=;
    public GridCell HyM= { get; public set; }
    public GridCell IiM= { get; public set; }
    public GridCell JSM= { get; public set; }
    public GridCell KCM= { get; public set; }
    public GCM=(GridCell leftBottom, GridCell bottomRight, GridCell rightTop, GridCell topLeft);
    public GridCell HSM=();
    public void HiM=(GridCell value);
    public GridCell ICM=();
    public void ISM=(GridCell value);
    public GridCell IyM=();
    public void JCM=(GridCell value);
    public GridCell JiM=();
    public void JyM=(GridCell value);
    public MCM= KSM=();
}
internal class GRU=.gCo= : 7So= {
    private bool Nio=;
    private double GSg=;
    private double Gig=;
    private bool gSo=;
    private sig= GCg=;
    private static int 8CQ=;
    private static int 8SQ=;
    private static int 8iQ=;
    private static int 8yQ=;
    public bool HSo=;
    public Oyo= qyU= { get; public set; }
    public int riU= { get; public set; }
    public gCo=(OCc= poDefnIn);
    public virtual oCg= Hig=();
    public virtual int Hyg=(Vyk= poMapFile);
    public virtual hSg= ICg=(OCc= poNewDefn);
    public int gio=();
    public gyc= gyo=(int nPartIndex);
    public virtual int ISg=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iig=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iyg=(5yU= fp);
    public virtual int JCg=(5yU= fp);
    public virtual string Nic=();
    public virtual void JSg=(Stream fsOut);
    public int OSo=(Double& dX, Double& dY);
    public void Oio=(double dX, double dY);
    public virtual int ryU=();
    public virtual Oyo= sCU=();
    public virtual byte sSU=();
    public virtual double siU=();
    public virtual int syU=();
    public virtual byte tCU=();
    public virtual int tSU=();
    public virtual string tiU=();
    public sealed virtual Oyo= qSU=();
    public sealed virtual void qiU=(Oyo= value);
    public sealed virtual int rCU=();
    public sealed virtual void rSU=(int value);
    public virtual void tyU=(byte val);
    public virtual void uCU=(double val);
    public virtual void uSU=(int val);
    public virtual void uiU=(byte val);
    public virtual void uyU=(int clr);
    public virtual void vCU=(string pszStyleString);
    public virtual void vSU=(Stream fpOut);
}
internal class GRU=.giE= : object {
    private static string gyE=;
    private static IDictionary`2<3T8=, XDocument> hCE=;
    private static object hSE=;
    private Type hiE=;
    private string hyE=;
    public giE=(Type forType);
    public giE=(Type forType, string resourceName);
    private giE=(Type forType, string resourceName, int dummy);
    private static giE=();
    [DebuggerHiddenAttribute]
public Exception iCE=(string exceptionKey, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public Exception iCE=(string exceptionKey, Exception innerException, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public Exception iCE=(string exceptionKey, Object[] constructorArgs, Exception innerException);
    [DebuggerHiddenAttribute]
public Exception iCE=(string exceptionKey, Object[] constructorArgs, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public Exception iCE=(string exceptionKey, Object[] constructorArgs, Exception innerException, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public void iSE=(bool condition, string exceptionKey, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public void iSE=(bool condition, string exceptionKey, Exception innerException, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public void iSE=(bool condition, string exceptionKey, Object[] constructorArgs, Exception innerException);
    [DebuggerHiddenAttribute]
public void iSE=(bool condition, string exceptionKey, Object[] constructorArgs, Object[] messageArgs);
    [DebuggerHiddenAttribute]
public void iSE=(bool condition, string exceptionKey, Object[] constructorArgs, Exception innerException, Object[] messageArgs);
    [DebuggerHiddenAttribute]
private static XDocument iiE=(Assembly assembly, string resourceName);
    private static int iyE=(Object[] arguments, ParameterInfo[] parameters);
    private static int jCE=(object argument, ParameterInfo parameter);
}
internal class GRU=.Gio= : DCo= {
    public int Gyo=;
    public int Fyo=;
    public int GCo=;
    public int iyg=;
    public int jCg=;
    public byte 2Ck=;
    public byte HCo=;
    public bool HSo=;
    public virtual int 2Sk=(6Ck= poObjBlock);
    public virtual int 2ik=(6Ck= poObjBlock);
}
internal class GRU=.GSo= : BSo= {
    public virtual int 2Sk=(6Ck= poObjBlock);
    public virtual int 2ik=(6Ck= poObjBlock);
}
internal class GRU=.GSU= : object {
    public static int GiU=;
    public static int GyU=;
    public static int HCU=;
    public static int HSU=;
    public static double WhY=;
    public static 3Cg= HiU=;
    public static NSg= HyU=;
    public static Oyo= ICU=;
    public static His= ISU=;
    public static int IiU=;
    public static int IyU=;
    public static int JCU=;
    public static int JSU=;
    public static int JiU=;
    public static int JyU=;
    public static int KCU=;
    public static int KSU=;
    public static int KiU=;
    public static int KyU=;
    public static int LCU=;
    public static int LSU=;
    public static int LiU=;
    public static int LyU=;
    public static int MCU=;
    public static int MSU=;
    public static int MiU=;
    public static int MyU=;
    public static int NCU=;
    public static int NSU=;
    public static int NiU=;
    public static int NyU=;
    public static int OCU=;
    public static int OSU=;
    public static int OiU=;
    public static int OyU=;
    public static int PCU=;
    public static int PSU=;
    public static int PiU=;
    public static int PyU=;
    public static int QCU=;
    public static int QSU=;
    public static int QiU=;
    public static int QyU=;
    public static int RCU=;
    public static int RSU=;
    public static int RiU=;
    public static int RyU=;
    public static int SCU=;
    public static int SSU=;
    public static int SiU=;
    public static int SyU=;
    public static int TCU=;
    public static int TSU=;
    public static int TiU=;
    public static int TyU=;
    public static int UCU=;
    public static int USU=;
    public static int UiU=;
    public static int UyU=;
    public static int VCU=;
    public static int VSU=;
    public static int ViU=;
    public static int VyU=;
    public static int WCU=;
    public static int WSU=;
    public static int WiU=;
    public static int WyU=;
    public static int XCU=;
    public static int XSU=;
    public static int XiU=;
    public static int XyU=;
    public static int YCU=;
    public static int YSU=;
    public static int YiU=;
    public static int YyU=;
    public static int ZCU=;
    public static int ZSU=;
    public static int ZiU=;
    public static int ZyU=;
    public static int aCU=;
    public static int aSU=;
    public static int aiU=;
    public static int ayU=;
    public static int bCU=;
    public static int bSU=;
    public static int biU=;
    public static int byU=;
    public static int cCU=;
    public static int cSU=;
    public static int ciU=;
    public static int cyU=;
    public static int dCU=;
    public static int dSU=;
    public static int diU=;
    public static int dyU=;
    public static int eCU=;
    public static int eSU=;
    public Byte[] eiU=;
    public static double eyU=;
    private static GSU=();
}
internal class GRU=.gxk= : iBo= {
    internal double hBk=;
    internal double hRk=;
    internal double hhk=;
    internal double hxk=;
    internal double iBk=;
    internal double MBk=;
    internal double 6xg=;
    internal double iRk=;
    internal Double[] MRk=;
    internal int CRk=;
    internal gxk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= DRk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lhg= Chk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.gy8= : object {
    private string ZS8=;
    private string hC8=;
    private string hS8=;
    private Dictionary`2<string, string> hi8=;
    private string hy8=;
    private string iC8=;
    private string iS8=;
    private string ii8=;
    private string iy8=;
    private string jC8=;
    private Dictionary`2<string, string> jS8=;
    public Dictionary`2<string, string> jy8= { get; }
    public string ki8= { get; public set; }
    public string lS8= { get; public set; }
    public Dictionary`2<string, string> ly8= { get; }
    public string mi8= { get; public set; }
    public string nS8= { get; public set; }
    public string oC8= { get; public set; }
    public string oy8= { get; public set; }
    public string pi8= { get; public set; }
    public string qS8= { get; public set; }
    public Dictionary`2<string, string> ji8=();
    public string kC8=();
    public void kS8=(string value);
    public string ky8=();
    public void lC8=(string value);
    public Dictionary`2<string, string> li8=();
    public string mC8=();
    public void mS8=(string value);
    public string my8=();
    public void nC8=(string value);
    public string ni8=();
    public void ny8=(string value);
    public string oS8=();
    public void oi8=(string value);
    public string pC8=();
    public void pS8=(string value);
    public string py8=();
    public void qC8=(string value);
    public void oBw=(BinaryReader reader);
    private void qi8=(string NameFormatType, BinaryReader reader);
    private void qy8=(BinaryReader reader);
    private void rC8=(BinaryReader reader);
    private void rS8=(BinaryReader reader);
    private void ri8=(BinaryReader reader);
    private void ry8=(BinaryReader reader);
    private void sC8=(BinaryReader reader);
    private void sS8=(BinaryReader reader);
    private bool si8=(string col);
}
internal class GRU=.gyc= : oiY= {
    protected int hCc=;
    protected pCc=[] hSc=;
    protected Double[] hic=;
    protected void hyc=();
    protected void iCc=();
    public virtual piY= aSc=(String& ppszDstText);
    public virtual Yyc= Zic=();
    public virtual void Zyc=(Gyc= psEnvelope);
    public virtual void oyY=(lSc= poPoint);
    public virtual void pCY=(lSc= poPoint);
    public int iSc=();
    public void iic=(int i, lSc= poPoint);
    public double iyc=(int i);
    public double jCc=(int i);
    public double jSc=(int iVertex);
    public virtual void bCc=(int nNewDimension);
    public void jic=(int nNewPointCount);
    public void jyc=(int iPoint, double xIn, double yIn);
    public void jyc=(int iPoint, double xIn, double yIn, double zIn);
    public void kCc=(int nPointsIn, pCc=[] paoPointsIn, Double[] padfZ);
    public void kCc=(int nPointsIn, Double[] padfX, int indexX, Double[] padfY, int indexY, Double[] padfZ, int indexZ);
    public void kSc=(double x, double y);
    public virtual qyY= aic=();
    public virtual string ayc=();
}
internal class GRU=.Gyc= : object {
    public double HCc=;
    public double HSc=;
    public double Hic=;
    public double Hyc=;
}
[ExtensionAttribute]
internal static class GRU=.gyQ= : object {
    [ExtensionAttribute]
public static void pRo=(ProjectionConverter projection, Feature feature);
}
internal enum GRU=.gyU= : Enum {
    public int value__;
    public static gyU= hCU=;
    public static gyU= hSU=;
    public static gyU= hiU=;
    public static gyU= hyU=;
}
internal abstract class GRU=.HB0= : object {
    private static NumberFormatInfo HR0=;
    protected int 1Bw=;
    protected object Hh0=;
    private bool Hx0=;
    private string IB0=;
    public int Ih0= { get; }
    public object JB0= { get; }
    public bool Jx0= { get; public set; }
    public string Kh0= { get; public set; }
    public string LB0= { get; }
    public HB0=(int line);
    private static HB0=();
    public int IR0=();
    public object Ix0=();
    public bool JR0=();
    public void Jh0=(bool value);
    public string KB0=();
    public void KR0=(string value);
    public virtual bool Equals(object other);
    public bool khU=(string s);
    public bool khU=(char c);
    public static bool 2hM=(HB0= t, object o);
    public static bool 2xM=(HB0= t, object o);
    public static bool 2hM=(HB0= t, char c);
    public static bool 2xM=(HB0= t, char c);
    public static bool 2hM=(HB0= t, string s);
    public static bool 2xM=(HB0= t, string s);
    public virtual int GetHashCode();
    public virtual string Kx0=();
    public object LR0=(Type t);
}
internal class GRU=.HBk= : iBo= {
    internal int HRk=;
    internal int Hhk=;
    internal HBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.hBo= : object {
    internal string hRo=;
    internal hBo=(string id, string defn);
}
internal class GRU=.hC0= : object {
    private int hS0=;
    [CompilerGeneratedAttribute]
private int BC0=;
    [CompilerGeneratedAttribute]
private byte hi0=;
    [CompilerGeneratedAttribute]
private List`1<List`1<mC0=>> hy0=;
    [CompilerGeneratedAttribute]
private List`1<List`1<string>> iC0=;
    [CompilerGeneratedAttribute]
private List`1<RectangleShape> iS0=;
    public int Hy0= { get; private set; }
    public byte jC0= { get; private set; }
    public List`1<List`1<mC0=>> jy0= { get; private set; }
    public List`1<List`1<string>> ki0= { get; private set; }
    public List`1<RectangleShape> lS0= { get; private set; }
    public hC0=(int treParameter);
    [CompilerGeneratedAttribute]
private void Hi0=(int value);
    [CompilerGeneratedAttribute]
public int HS0=();
    [CompilerGeneratedAttribute]
private void iy0=(byte value);
    [CompilerGeneratedAttribute]
public byte ii0=();
    [CompilerGeneratedAttribute]
private void ji0=(List`1<List`1<mC0=>> value);
    [CompilerGeneratedAttribute]
public List`1<List`1<mC0=>> jS0=();
    [CompilerGeneratedAttribute]
private void kS0=(List`1<List`1<string>> value);
    [CompilerGeneratedAttribute]
public List`1<List`1<string>> kC0=();
    [CompilerGeneratedAttribute]
private void lC0=(List`1<RectangleShape> value);
    [CompilerGeneratedAttribute]
public List`1<RectangleShape> ky0=();
    public void fC0=(Jy0= RTree, int accuracy);
    private void li0=(7iw= rNode, int accuracy, Jy0= RTree);
    private void ly0=(7iw= rNode, List`1<7iw=> list, Jy0= rRtee);
    private void ly0=(7iw= rNode, List`1<1iw=> list);
}
internal class GRU=.HC4= : object {
    [CompilerGeneratedAttribute]
private int Dhw=;
    [CompilerGeneratedAttribute]
private int Dxw=;
    public int 9iI= { get; private set; }
    public int /SI= { get; private set; }
    public HC4=(int inputX, int inputY);
    [CompilerGeneratedAttribute]
private void 9SI=(int value);
    [CompilerGeneratedAttribute]
public int 9CI=();
    [CompilerGeneratedAttribute]
private void /CI=(int value);
    [CompilerGeneratedAttribute]
public int 9yI=();
    public int HS4=();
    public int Hi4=();
}
internal class GRU=.hCg= : 7So= {
    private static int 8CQ=;
    private static int 8SQ=;
    private static int 8iQ=;
    private static int 8yQ=;
    public double GSg=;
    public double Gig=;
    public double Gyg=;
    public double HCg=;
    public hCg=(OCc= poDefnIn);
    public virtual int HSg=(Vyk= poMapFile);
    public virtual oCg= Hig=();
    public virtual int Hyg=(Vyk= poMapFile);
    public virtual hSg= ICg=(OCc= poNewDefn);
    public virtual int ISg=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iig=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iyg=(5yU= fp);
    public virtual int JCg=(5yU= fp);
    public virtual string Nic=();
    public virtual void JSg=(Stream fsOut);
}
internal class GRU=.hCo= : object {
    private byte hSo=;
    private byte hio=;
    private byte hyo=;
    private Double[] iCo=;
    private short iSo=;
    private double iio=;
    private double iyo=;
    private double jCo=;
    private Double[] jSo=;
    private byte jio=;
    private byte jyo=;
    private double kCo=;
    private double kSo=;
    private double kio=;
    private double kyo=;
    private double lCo=;
    private double lSo=;
    public byte mCo= { get; public set; }
    public byte myo= { get; public set; }
    public byte nio= { get; public set; }
    public Double[] oSo= { get; public set; }
    public short pCo= { get; public set; }
    public double pyo= { get; public set; }
    public double qio= { get; public set; }
    public double rSo= { get; public set; }
    public Double[] sCo= { get; public set; }
    public byte syo= { get; public set; }
    public byte tio= { get; public set; }
    public double uSo= { get; public set; }
    public double vCo= { get; public set; }
    public double vyo= { get; public set; }
    public double wio= { get; public set; }
    public double xSo= { get; public set; }
    public double yCo= { get; public set; }
    public hCo=(byte nProjId, byte nEllipsoidId, byte nUnitsId, Double[] adProjParams, short nDatumId, double dDatumShiftX, double dDatumShiftY, double dDatumShiftZ, Double[] adDatumParams);
    public byte lio=();
    public void lyo=(byte value);
    public byte mSo=();
    public void mio=(byte value);
    public byte nCo=();
    public void nSo=(byte value);
    public Double[] nyo=();
    public void oCo=(Double[] value);
    public short oio=();
    public void oyo=(short value);
    public double pSo=();
    public void pio=(double value);
    public double qCo=();
    public void qSo=(double value);
    public double qyo=();
    public void rCo=(double value);
    public Double[] rio=();
    public void ryo=(Double[] value);
    public byte sSo=();
    public void sio=(byte value);
    public byte tCo=();
    public void tSo=(byte value);
    public double tyo=();
    public void uCo=(double value);
    public double uio=();
    public void uyo=(double value);
    public double vSo=();
    public void vio=(double value);
    public double wCo=();
    public void wSo=(double value);
    public double wyo=();
    public void xCo=(double value);
    public double xio=();
    public void xyo=(double value);
    internal void Lyg=();
}
internal enum GRU=.hCw= : Enum {
    public byte value__;
    public static hCw= hSw=;
    public static hCw= LiA=;
    public static hCw= hiw=;
    public static hCw= hyw=;
}
internal class GRU=.hho= : object {
    internal string hxo=;
    internal hho=(string id, string to_meter, string name);
}
internal class GRU=.Hio= : BSo= {
    public int Hyo=;
    public int ICo=;
    public byte Fio=;
    public virtual int 2Sk=(6Ck= poObjBlock);
    public virtual int 2ik=(6Ck= poObjBlock);
}
internal class GRU=.hiQ= : ValueType {
    public long hyQ=;
    public float iCQ=;
    public float iSQ=;
    public float iiQ=;
    public float iyQ=;
    public hiQ=(Byte[] buffer);
}
internal class GRU=.His= : object {
    public int OSc=;
    public short Hys=;
    public short ICs=;
    public byte ISs=;
    public int Pyo=;
    public His=(int nRefCount, short nSymbolNo, short nPointSize, byte _nUnknownValue_, int rgbColor);
}
internal class GRU=.hSg= : ICc= {
    protected int hig=;
    protected double DSY=;
    protected double DiY=;
    protected double DyY=;
    protected double ECY=;
    protected int hyg=;
    protected int iCg=;
    protected int iSg=;
    protected int iig=;
    protected int iyg=;
    protected int jCg=;
    public hSg=(OCc= poDefnIn);
    protected void jSg=(hSg= poDestFeature);
    public virtual int HSg=(Vyk= poMapFile);
    public static hSg= jig=(int nMapInfoType, OCc= poDefn);
    public virtual hSg= ICg=(OCc= poNewDefn);
    public virtual oCg= Hig=();
    public virtual int jyg=();
    public virtual int Hyg=(Vyk= poMapFile);
    public void kCg=(bool bDeleted);
    public virtual int kSg=(Vig= poDATFile);
    public virtual int ISg=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordDataOnly, Mik=& ppoCoordBlock);
    public virtual int kig=(Vig= poDATFile, BCk= poINDFile, Int32[] panIndexNo);
    public virtual int Iig=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordDataOnly, Mik=& ppoCoordBlock);
    public bool kyg=(Vyk= poMapFile);
    public void lCg=(int nMapInfoType, bool bCompr, int nComprOrgX, int nComprOrgY, int nXMin, int nYMin, int nXMax, int nYMax);
    public virtual int lSg=(5yU= fp);
    public virtual int Iyg=(5yU= fp);
    public virtual int lig=(5yU= fp);
    public virtual int JCg=(5yU= fp);
    public void lyg=(double dXMin, double dYMin, double dXMax, double dYMax);
    public void mCg=(Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax);
    public void mSg=(int nXMin, int nYMin, int nXMax, int nYMax);
    public void mig=(Int32& nXMin, Int32& nYMin, Int32& nXMax, Int32& nYMax);
    public virtual void myg=(Stream fsOut);
    public virtual void JSg=(Stream fsOut);
}
internal class GRU=.Hxk= : iBo= {
    internal Hxk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Hy4= : object {
    private Ci8= IC4=;
    private List`1<FC8=> IS4=;
    private List`1<KS8=> Ii4=;
    private List`1<EC8=> Iy4=;
    private Ty4= JC4=;
    private hC0= JS4=;
    private Jy0= Ji4=;
    private 7y0= Jy4=;
    private string KC4=;
    private string KS4=;
    private string Ki4=;
    private string Ky4=;
    private int LC4=;
    private Bi4= LS4=;
    private SC0= Li4=;
    private double 9yw=;
    private TinyGeoFileType Ly4=;
    public Hy4=(Bi4= tGeoParameters, string tGeoFilePathName);
    public void MC4=();
    public void MS4=(int count);
    public void Mi4=();
    public void My4=(int count);
    public void NC4=();
}
internal static class GRU=.hyM= : object {
    public static string iCM=(string metarText);
    private static void iSM=(string text, StringBuilder resultStrBuffer);
    private static bool iiM=(char ch);
    private static void iyM=(string token, StringBuilder resultStrBuffer);
    private static string jCM=(string text, StringBuilder resultStrBuffer);
}
internal class GRU=.IBk= : iBo= {
    internal int HRk=;
    internal int Hhk=;
    internal IBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal abstract class GRU=.iBo= : object {
    internal vhg= iRo=;
    internal string dxQ=;
    internal string iho=;
    internal abstract virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal abstract virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal abstract virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    internal abstract virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
}
internal class GRU=.iBw= : object {
    private Dictionary`2<KeyValuePair`2<string, string>, IEnumerable`1<Feature>> iRw=;
    public Dictionary`2<KeyValuePair`2<string, string>, IEnumerable`1<Feature>> ixw= { get; }
    public iBw=(IEnumerable`1<Feature> features, string columnName);
    public Dictionary`2<KeyValuePair`2<string, string>, IEnumerable`1<Feature>> ihw=();
    public sealed virtual IEnumerator`1<Feature> GetEnumerator();
    [IteratorStateMachineAttribute("GRU=.iBw=/2D4=")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class GRU=.ICc= : ByU= {
    private long ISc=;
    private OCc= Iic=;
    private Yyc= Iyc=;
    private List`1<Ric=> JCc=;
    protected string JSc=;
    protected string Jic=;
    public ICc=(OCc= poDefnIn);
    public OCc= Jyc=();
    public piY= KCc=(Yyc= poGeomIn);
    public piY= KSc=(Yyc= poGeomIn);
    public Yyc= Kic=();
    public ICc= Hhc=();
    public int Kyc=();
    public Vyc= LCc=(int iField);
    public int LSc=(string pszName);
    public bool Lic=(int iField);
    public Ric= Lyc=(int i);
    public int MCc=(int iField);
    public double MSc=(int iField);
    public string Mic=(int iField);
    public string Mic=(string pszFName);
    public void Myc=(int iField, int nValue);
    public void Myc=(int iField, double dfValue);
    public void Myc=(int iField, string pszValue);
    public void Myc=(int iField, Ric= puValue);
    public long NCc=();
    public virtual piY= NSc=(long nFID);
    public virtual string Nic=();
    public virtual void Nyc=(string pszString);
}
internal interface GRU=.iCU= {
    public NSg= iyU= { get; public set; }
    public int jiU= { get; public set; }
    public abstract virtual int jyU=();
    public abstract virtual NSg= kCU=();
    public abstract virtual int kSU=();
    public abstract virtual int kiU=();
    public abstract virtual byte kyU=();
    public abstract virtual byte lCU=();
    public abstract virtual void lSU=(int clr);
    public abstract virtual void liU=(int clr);
    public abstract virtual void lyU=(byte val);
    public abstract virtual void mCU=(byte val);
    public abstract virtual string mSU=();
    public abstract virtual void miU=(string pszStyleString);
    public abstract virtual void myU=(Stream fpOut);
    public abstract virtual NSg= iSU=();
    public abstract virtual void iiU=(NSg= value);
    public abstract virtual int jCU=();
    public abstract virtual void jSU=(int value);
}
internal class GRU=.iCw= : BinaryWriter {
    public iCw=(Stream output);
    public void iSw=(byte Value, int length);
}
internal class GRU=.ihk= : iBo= {
    internal double ixk=;
    internal double jBk=;
    internal double KRk=;
    internal ihk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.iiI= : ValueType {
    public byte iyI=;
    public int BBo=;
    public int BRo=;
    public iiI=(int x, int y, byte intensity);
}
internal enum GRU=.Iis= : Enum {
    public int value__;
    public static Iis= Iys=;
    public static Iis= JCs=;
    public static Iis= JSs=;
}
internal static class GRU=.iiw= : object {
    public static MultilineShape iyw=(LineShape lineShap, double ratio);
    public static MultilineShape iyw=(MultilineShape multiLineShape, double ratio);
    private static List`1<qCw=> jCw=(List`1<qCw=> points, double ratio);
    private static void jSw=(List`1<qCw=> value);
}
internal class GRU=.iR4= : EventArgs {
    private bool ih4=;
    internal bool jR4= { get; internal set; }
    internal bool ix4=();
    internal void jB4=(bool value);
}
internal class GRU=.IRk= : iBo= {
    internal int Ihk=;
    internal IRk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.ISo= : BSo= {
    public int Iio=;
    public int Iyo=;
    public byte 2Ck=;
    public byte HCo=;
    public virtual int 2Sk=(6Ck= poObjBlock);
    public virtual int 2ik=(6Ck= poObjBlock);
}
internal class GRU=.Ixk= : iBo= {
    internal Ixk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.ixo= : ValueType {
    internal double jBo=;
    internal double jRo=;
}
internal class GRU=.iyY= : object {
    public static double jCY=(List`1<string> papszFields, int iField, double dfDefault);
    public static pSc= jSY=(string pszCoordSys);
    public static string jiY=(pSc= poSR);
    public static bool jyY=(string pszCoordSys, Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax);
}
internal class GRU=.JBc= : ValueType {
    internal string JRc=;
    internal string Jhc=;
    internal int Jxc=;
    internal int KBc=;
}
internal class GRU=.JBk= : iBo= {
    internal double 7xg=;
    internal double JRk=;
    internal double Jhk=;
    internal double BBk=;
    internal Double[] 8Rg=;
    internal JBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= DRk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lhg= Chk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.JCo= : DCo= {
    public short JSo=;
    public int BCo=;
    public short 4Cg=;
    public byte Jio=;
    public byte Jyo=;
    public byte KCo=;
    public byte KSo=;
    public byte Kio=;
    public byte Kyo=;
    public int LCo=;
    public int LSo=;
    public int Lio=;
    public byte 5yk=;
    public byte 2Ck=;
    public virtual int 2Sk=(6Ck= poObjBlock);
    public virtual int 2ik=(6Ck= poObjBlock);
}
internal class GRU=.jCQ= : ValueType {
    public long hyQ=;
    public int iCQ=;
    public int iSQ=;
    public int iiQ=;
    public int iyQ=;
    public jCQ=(Byte[] buffer);
}
internal class GRU=.jhk= : iBo= {
    internal jhk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.jho= : object {
    internal hho= jxo=;
    internal Dictionary`2<string, hho=> kBo=;
    internal hho= kho= { get; }
    internal jho=(Dictionary`2<string, string> args, Dictionary`2<string, hho=> pj_Units_List);
    private string kxo=(Dictionary`2<string, string> args);
    private void lBo=(string unitID);
    internal hho= kRo=();
}
internal class GRU=.Jhs= : object {
    public static double Jxs=(double rad);
    public static double KBs=(double degree);
    public static float KRs=(Byte[] bs, int startIndex);
}
[ExtensionAttribute]
internal static class GRU=.jiE= : object {
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void jyE=(EventHandler handler, object sender);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void jyE=(EventHandler`1<T> handler, object sender, T e);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void jyE=(EventHandler`1<T> handler, object sender, Func`1<T> createEventArguments);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void jyE=(Delegate handler, object sender, EventArgs e);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void kCE=(EventHandler handler, object sender, AsyncCallback callback, object asyncState);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void kCE=(EventHandler`1<T> handler, object sender, T e, AsyncCallback callback, object asyncState);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void kCE=(EventHandler`1<T> handler, object sender, Func`1<T> createEventArguments, AsyncCallback callback, object asyncState);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void kCE=(Delegate handler, object sender, EventArgs e, AsyncCallback callback, object asyncState);
}
internal class GRU=.Jis= : hSg= {
    protected Char[] Jys=;
    protected double 3yg=;
    protected double KCs=;
    protected double KSs=;
    protected double Kis=;
    protected double Kys=;
    protected bool LCs=;
    protected int LSs=;
    protected int Lis=;
    protected short JSo=;
    protected short 4Cg=;
    private rig= SSg=;
    private sig= GCg=;
    private static 3Cg= sSg=;
    private static int 8CQ=;
    private static int 8SQ=;
    private static int 8iQ=;
    private static int 8yQ=;
    public Oyo= qyU= { get; public set; }
    public int riU= { get; public set; }
    public int nyU= { get; public set; }
    public 3Cg= oiU= { get; public set; }
    public Jis=(OCc= poDefnIn);
    private static Jis=();
    protected string Lys=();
    public virtual int HSg=(Vyk= poMapFile);
    public virtual oCg= Hig=();
    public virtual int Hyg=(Vyk= poMapFile);
    public virtual hSg= ICg=(OCc= poNewDefn);
    public virtual int ISg=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iig=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iyg=(5yU= fp);
    public virtual int JCg=(5yU= fp);
    public virtual string Nic=();
    public virtual void JSg=(Stream fsOut);
    public Char[] MCs=();
    public double MSs=();
    public double Mis=();
    public double Mys=();
    public int NCs=();
    public int NSs=();
    public void Nis=(Double& dX, Double& dY);
    public Rys= Nys=();
    public Tys= OCs=();
    public Sys= OSs=();
    public bool Ois=(6ig= eStyleToQuery);
    public void Oys=(Char[] pszNewStr);
    public void PCs=(double dAngle);
    public void PSs=(double dHeight);
    public void Pis=(double dWidth);
    public void Pys=(int rgbColor);
    public void QCs=(int rgbColor);
    public void QSs=(double dX, double dY);
    public void Qis=(Rys= eJustification);
    public void Qys=(Tys= eSpacing);
    public void RCs=(Sys= eLineType);
    public void RSs=(6ig= eStyleToToggle, bool bStyleOn);
    public int 5Cg=();
    public void 5Sg=(int nStyle, bool bBGColorSet);
    public bool Ris=();
    public int 5ig=();
    public void 5yg=(int nStyle);
    public virtual int ryU=();
    public virtual Oyo= sCU=();
    public virtual byte sSU=();
    public virtual double siU=();
    public virtual int syU=();
    public virtual byte tCU=();
    public virtual int tSU=();
    public virtual string tiU=();
    public sealed virtual Oyo= qSU=();
    public sealed virtual void qiU=(Oyo= value);
    public virtual int rCU=();
    public virtual void rSU=(int value);
    public virtual void tyU=(byte val);
    public virtual void uCU=(double val);
    public virtual void uSU=(int val);
    public virtual void uiU=(byte val);
    public virtual void uyU=(int clr);
    public virtual void vCU=(string pszStyleString);
    public virtual void vSU=(Stream fpOut);
    public virtual int nSU=();
    public virtual void niU=(int value);
    public virtual 3Cg= oCU=();
    public virtual void oSU=(3Cg= value);
    public virtual int oyU=();
    public virtual 3Cg= pCU=();
    public virtual string pSU=();
    public virtual void piU=(string pszName);
    public virtual void pyU=(Stream fpOut);
}
internal class GRU=.jiw= : object {
    [CompilerGeneratedAttribute]
private int jyw=;
    [CompilerGeneratedAttribute]
private string kCw=;
    [CompilerGeneratedAttribute]
private ushort kSw=;
    public int lCw= { get; private set; }
    public string lyw= { get; public set; }
    public ushort miw= { get; public set; }
    public jiw=(int index, string lable, ushort fclass);
    [CompilerGeneratedAttribute]
private void kyw=(int value);
    [CompilerGeneratedAttribute]
public int kiw=();
    [CompilerGeneratedAttribute]
public string lSw=();
    [CompilerGeneratedAttribute]
public void liw=(string value);
    [CompilerGeneratedAttribute]
public ushort mCw=();
    [CompilerGeneratedAttribute]
public void mSw=(ushort value);
}
internal class GRU=.jRk= : iBo= {
    internal jRk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
[ExtensionAttribute]
internal static class GRU=.jSE= : object {
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void eyE=(T arg, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void eyE=(Nullable`1<T> arg, string argName);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void fCE=(T arg, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void eyE=(IEnumerable`1<T> arg, string argName, bool assertContentsNotNull);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void fSE=(string arg, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void fSE=(IEnumerable arg, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void fSE=(ICollection arg, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void fiE=(string arg, string argName);
    [DebuggerHiddenAttribute]
[ExtensionAttribute]
public static void fyE=(TEnum enumValue, string argName);
    [ExtensionAttribute]
[DebuggerHiddenAttribute]
public static void fyE=(TEnum enumValue, string argName, TEnum[] validValues);
}
[ExtensionAttribute]
internal static class GRU=.jSM= : object {
    [ExtensionAttribute]
public static string jiM=(string input, int startIndex, int length);
    public static int jyM=(string input);
}
internal class GRU=.jSQ= : object {
    private short jiQ=;
    public short jyQ=;
    public hiQ=[] kCQ=;
    public float iCQ=;
    public float iSQ=;
    public float iiQ=;
    public float iyQ=;
    public jSQ=(Byte[] buffer);
}
internal class GRU=.jxk= : iBo= {
    internal jxk=(string id, string desc);
    private void 8xg=();
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Jxk= : iBo= {
    internal double KBk=;
    internal double fxc=;
    internal double uxg=;
    internal double KRk=;
    internal double 6hg=;
    internal double Txc=;
    internal double 6xg=;
    internal double Khk=;
    internal double Kxk=;
    internal double LBk=;
    internal Double[] 8Rg=;
    internal Jxk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= DRk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lhg= Chk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Jy0= : object {
    private double 9yw=;
    private int 7yw=;
    private int 8Sw=;
    public List`1<7iw=> KC0=;
    [CompilerGeneratedAttribute]
private int KS0=;
    [CompilerGeneratedAttribute]
private int Ay0=;
    [CompilerGeneratedAttribute]
private int Ki0=;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, List`1<int>> Ky0=;
    public int Li0= { get; private set; }
    public int HC0= { get; private set; }
    public int MS0= { get; public set; }
    public Dictionary`2<int, List`1<int>> NC0= { get; private set; }
    public Jy0=(int nMax, int nMin, int accuray, double extentWidthLimitation);
    [CompilerGeneratedAttribute]
private void LS0=(int value);
    [CompilerGeneratedAttribute]
public int LC0=();
    [CompilerGeneratedAttribute]
private void Gy0=(int value);
    [CompilerGeneratedAttribute]
public int Gi0=();
    [CompilerGeneratedAttribute]
public void MC0=(int value);
    [CompilerGeneratedAttribute]
public int Ly0=();
    [CompilerGeneratedAttribute]
private void My0=(Dictionary`2<int, List`1<int>> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<int, List`1<int>> Mi0=();
    public void NS0=(int max);
    public void Ni0=();
    public void Ny0=();
    public int OC0=(7iw= rNode);
    public void OS0=();
    public void fiI=(Oy0= Info);
    public void fiI=(1iw= ceaterEntry);
    private int Oi0=(1iw= DesEntry);
    private bool xx8=(int OriginalNode, bool DoSplit);
}
internal class GRU=.JyY= : object {
    public static int KCY=;
    public static JyY= KSY=;
    private static JyY=();
    public int KiY=();
    public int KyY=();
    public fCU= LCY=(string pszFilename, Encoding encoding);
    public void LSY=(fCU= handle);
    public fCU= LiY=(string filename, string mif_or_tab, string mif_projection, double north, double south, double east, double west, Encoding encoding);
    public int LyY=(fCU= dataset);
    public int MCY=(fCU= dataset, string field_name, uig= field_type, int width, int precision, bool indexed, bool unique);
    public void MSY=(hSg= feature);
    public int MiY=(fCU= handle, int last_feature_id);
    public hSg= MyY=(fCU= handle, int feature_id);
    public bool NCY=(fCU= handle, hSg= feature);
    public hSg= NSY=(fCU= handle, int feature_type);
    public void NiY=(hSg= feature, int field_index, string field_value);
    public void NyY=(hSg= feature, int part, int vertex_count, Double[] x, Double[] y);
    public void OCY=(hSg= feature, double center_x, double center_y, double x_radius, double y_radius, double start_angle, double end_angle);
    public void OSY=(hSg= feature, String& text);
    public string OiY=(hSg= feature);
    public int OyY=(hSg= feature, String& text, int l);
    public void PCY=(hSg= feature, double angle, double height, double width, int fg_color, int bg_color, int justification, int spacing, int linetype);
    public void PSY=(hCo= projInfo, Int32& nProjId, Int32& nEllipsoidId, Int32& nUnitsId, Double[] adProjParams);
    public double PiY=(hSg= feature);
    public double PyY=(hSg= feature);
    public double QCY=(hSg= feature);
    public int QSY=(hSg= feature);
    public int QiY=(hSg= feature);
    public int QyY=(hSg= feature);
    public int RCY=(hSg= feature);
    public int RSY=(hSg= feature);
    public void RiY=(hSg= feature, string fontname);
    public string RyY=(hSg= feature);
    public void SCY=(hSg= feature, int fg_color, int bg_color, int pattern, int transparent);
    public int SSY=(hSg= feature);
    public int SiY=(hSg= feature);
    public int SyY=(hSg= feature);
    public int TCY=(hSg= feature);
    public void TSY=(hSg= feature, int width, int pattern, int color);
    public int TiY=(hSg= feature);
    public int TyY=(hSg= feature);
    public int UCY=(hSg= feature);
    public void USY=(hSg= feature, int symbol_no, int symbol_size, int symbol_color);
    public int UiY=(hSg= feature);
    public int UyY=(hSg= feature);
    public int VCY=(hSg= feature);
    public int VSY=(hSg= feature);
    public double ViY=(hSg= feature, int part, int vertex);
    public int VyY=(fCU= handle);
    public int WCY=(fCU= handle);
    public int WSY=(fCU= handle, int field);
    public string WiY=(fCU= handle, int field);
    public int WyY=(fCU= handle, int field);
    public int XCY=(fCU= handle, int field);
    public string XSY=(fCU= dataset);
    public string XiY=(fCU= dataset);
    public void XyY=(hCo= projInfo, int nProjId, int nEllipsoidId, int nUnitsId, Double[] adProjParams);
    public void YCY=(hCo= projInfo, Double& dDatumShiftX, Double& dDatumShiftY, Double& dDatumShiftZ, Double[]& adDatumParams);
    public void YSY=(hCo= projInfo, double dDatumShiftX, double dDatumShiftY, double dDatumShiftZ, Double[] adDatumParams);
    public int YiY=(hCo= projInfo, Int32& nAffineUnits, Double[]& adAffineParams);
    public void YyY=(hCo= projInfo, int nAffineUnits, Double[] adAffineParams);
    public int ZCY=(fCU= dataset, String& coordsys, int length);
    public int ZSY=(fCU= dataset, String& coordsys, int length);
    public int ZiY=(string filename);
    public int ZyY=(hSg= feature, hSg= region, int make_copy);
    public int aCY=(hSg= feature, hSg= polyline, int make_copy);
    public int aSY=(hSg= feature, hSg= multipoint, int make_copy);
    public string aiY=(hSg= feature, int field);
    public bool ayY=(fCU= handle, int field);
    public bool bCY=(fCU= handle, int field);
    public int bSY=(hSg= feature, int field, String& value, int l);
    public double biY=(hSg= feature, int field);
    public hCo= byY=(fCU= dataset);
    public int cCY=(fCU= dataset, hCo= projinfo);
    public string cSY=(fCU= file, int columnNum, int recordNum);
}
internal class GRU=.kB8= : 9x8= {
    internal kB8=(8B8= rh, ACA= rt);
    public virtual string ToString();
    internal virtual int kR8=(bool isFloat);
    internal virtual bool oBw=(BinaryReader r, bool isFloat);
    internal virtual bool rhw=(BinaryWriter w, bool isFloat);
}
internal class GRU=.kBk= : iBo= {
    internal kBk=(string id, string desc);
    private void 8xg=();
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.KBo= : iBo= {
    internal double 7xg=;
    internal double KRo=;
    internal double Kho=;
    internal int CRk=;
    internal KBo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.kCY= : object {
    public static double WhY=;
    public static LkA=[] kSY=;
    private static kCY=();
    public static int kiY=(gyc= poLine, int numPoints, double dCenterX, double dCenterY, double dXRadius, double dYRadius, double dStartAngle, double dEndAngle);
    public static int kyY=(gyc= poRing);
    public static bool lCY=(String& pszFname);
    public static string lSY=(string pszFname);
    public static List`1<string> liY=(string pszFname, Encoding encoding);
    public static string lyY=(String& pszString, bool bSrcIsConst);
    public static string mCY=(string pszString);
    public static string mSY=(string pszSrcName);
    public static string miY=(int nId);
    public static int myY=(string pszName);
    public static bool jyY=(string pszCoordSys, Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax);
    public static int nCY=(string pszCoordSys, hCo= psProj);
}
internal class GRU=.khk= : iBo= {
    internal Double[] 8Rg=;
    internal double kxk=;
    internal double lBk=;
    internal double lRk=;
    internal double ERg=;
    internal khk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private static double lhk=(double S, double C);
    private static double lxk=(double S, double C);
}
internal class GRU=.Khs= : object {
    private static UInt32 Kxs=;
    private static UInt32 LBs=;
    private static UInt32 LRs=;
    private static UInt32 Lhs=;
    private static UInt32 Lxs=;
    private static UInt32 MBs=;
    private static UInt32 MRs=;
    private static UInt32 Mhs=;
    private static UInt32 Mxs=;
    private static UInt32 NBs=;
    private static UInt32 NRs=;
    private static double 0hc=;
    private static double 0xc=;
    private static int Nhs=;
    private static int Nxs=;
    private static int OBs=;
    private static int ORs=;
    private static int Ohs=;
    private static int Oxs=;
    private static int PBs=;
    private static int PRs=;
    private static int Phs=;
    private static int Pxs=;
    private static int QBs=;
    private static int QRs=;
    private static int Qhs=;
    private static int Qxs=;
    private static int RBs=;
    private static int RRs=;
    private static int Rhs=;
    private static int Rxs=;
    private static int SBs=;
    private static int SRs=;
    private static int Shs=;
    private static int Sxs=;
    private static int TBs=;
    private static int TRs=;
    private static int Ths=;
    private static int Txs=;
    private static int UBs=;
    private static double URs=;
    private static double Uhs=;
    private static bool Uxs=;
    private static bool VBs=;
    private static double WhY=;
    private static double Wxc=;
    private static double VRs=;
    private static double Vhs=;
    private static double Vxs=;
    private static double WBs=;
    private static double WRs=;
    private static double Whs=;
    private static double Wxs=;
    private static double XBs=;
    private static double XRs=;
    private double Xhs=;
    private double Xxs=;
    private double YBs=;
    private string YRs=;
    private static string Yhs=;
    private static string Yxs=;
    private static string ZBs=;
    private static string ZRs=;
    internal static xj4=[] Zhs=;
    private static yz4=[] Zxs=;
    private static Khs=();
    public bool aBs=(string mgrs, Double& Latitude, Double& Longitude);
    public bool aRs=(double Latitude, double Longitude, String& mgrs);
    private long ahs=(int letter, Double& min_northing);
    private long axs=(long letter, Double& north, Double& south);
    private long bBs=(double latitude, Int32& letter);
    private long bRs=(string MGRS, Boolean& zone_exists);
    private long bhs=(double _value);
    private long bxs=(String& MGRS, int Zone, Int32[] Letters, double Easting, double Northing, int Precision);
    private long cBs=(string MGRS, Int32& Zone, Int32[]& Letters, Double& Easting, Double& Northing, Int32& Precision);
    private void cRs=(int zone, Int32& ltr2_low_value, Int32& ltr2_high_value, Double& false_northing);
    internal long chs=(int Zone, double Latitude, double Easting, double Northing, int Precision, String& MGRS);
    public long cxs=(double a, double f, string Ellipsoid_Code);
    private void dBs=(Double& a, Double& f, String& Ellipsoid_Code);
    internal long dRs=(double Latitude, double Longitude, int Precision, String& MGRS);
    internal long dhs=(string MGRS, Double& Latitude, Double& Longitude);
    internal long dxs=(int Zone, char Hemisphere, double Easting, double Northing, int Precision, String& MGRS);
    internal long eBs=(string MGRS, Int32& Zone, Char& Hemisphere, Double& Easting, Double& Northing);
    internal long eRs=(char Hemisphere, double Easting, double Northing, int Precision, String& MGRS);
    internal long ehs=(string MGRS, Char& Hemisphere, Double& Easting, Double& Northing);
}
internal class GRU=.khw= : BinaryWriter {
    public khw=(Stream output);
    public khw=(Stream output, Encoding encoding);
    public virtual void Write(short value);
    public virtual void Write(ushort value);
    public virtual void Write(int value);
    public virtual void Write(UInt32 value);
    public virtual void Write(long value);
    public virtual void Write(ulong value);
    public virtual void Write(float value);
    public virtual void Write(double value);
}
internal class GRU=.KiA= : ValueType {
    public double BBo=;
    public double BRo=;
    private static int KyA=;
    public KiA=(double x, double y);
    public bool ByA=(KiA= pt);
    public static int kR8=(bool isFloat);
    public bool oBw=(BinaryReader r, bool isFloat);
    public bool rhw=(BinaryWriter w, bool isFloat);
    public virtual string ToString();
}
internal class GRU=.kic= : cCc= {
    public virtual string ayc=();
    public virtual qyY= aic=();
    public virtual Yyc= Zic=();
    public virtual piY= aSc=(String& ppszDstText);
    public virtual piY= dic=(Yyc= poNewGeom);
}
internal class GRU=.Kig= : object {
    protected int Kyg=;
    protected int LCg=;
    protected Myg= LSg=;
    public int Lig=();
    public void Lyg=();
    public void MCg=(int nBlockPtr);
    public int MSg=();
    public int Mig=();
}
internal enum GRU=.KiM= : Enum {
    public int value__;
    public static KiM= KyM=;
    public static KiM= LCM=;
    public static KiM= LSM=;
    public static KiM= LiM=;
    public static KiM= LyM=;
}
internal static class GRU=.kiQ= : object {
    public static List`1 modreq(System.Runtime.CompilerServices.IsVolatile) kyQ=;
    public static Boolean modreq(System.Runtime.CompilerServices.IsVolatile) lCQ=;
    public static string lSQ=(string pszBuffer, int nBufferSize, Stream fp, Encoding encoding);
    public static string liQ=(int nRequiredSize);
    public static string lyQ=(Stream fp, Encoding encoding);
    public static long mCQ=(string pszString, int nMaxLength);
    public static string mSQ=(string pszKey, string pszDefault);
}
internal class GRU=.KRc= : object {
    private string Khc=;
    private string Kxc=;
    private XmlDocument LBc=;
    private XmlNodeList LRc=;
    internal XmlNodeList Lxc= { get; }
    internal KRc=(string baseInfoFile, string xmlPath);
    internal XmlNodeList Lhc=();
    private bool MBc=();
    internal XmlNode MRc=(string xmlKeyField, string xmlKeyWord);
}
internal class GRU=.kRk= : iBo= {
    internal double 7xg=;
    internal double 8Bg=;
    internal double fxc=;
    internal double 7hg=;
    internal double 7Rg=;
    internal double 6hg=;
    internal int 8hg=;
    internal kRk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.kRw= : BinaryReader {
    public kRw=(Stream stream);
    public kRw=(Stream input, Encoding encoding);
    public virtual short ReadInt16();
    public virtual ushort ReadUInt16();
    public virtual int ReadInt32();
    public virtual UInt32 ReadUInt32();
    public virtual long ReadInt64();
    public virtual ulong ReadUInt64();
    public virtual float ReadSingle();
    public virtual double ReadDouble();
}
internal class GRU=.KS8= : object {
    private iCw= Cy8=;
    private int zRM=;
    private int Ei8=;
    public KS8=(string path);
    public void oR8=();
    public void Ey8=();
    public void Px8=(xC0= HeaderPrama, int count, byte accuray);
    public void Ki8=(1i0= SubdivisionPrama);
    public void Ky8=();
}
internal static class GRU=.kSE= : object {
    public static char kiE=;
    public static char kyE=;
    public static char lCE=;
    public static char lSE=;
    public static char liE=;
    public static char lyE=;
    public static Encoding mCE=;
    private static kSE=();
}
internal class GRU=.kSI= : object {
    [CompilerGeneratedAttribute]
private long kiI=;
    [CompilerGeneratedAttribute]
private long kyI=;
    [CompilerGeneratedAttribute]
private GridCell[0...,0...] lCI=;
    [CompilerGeneratedAttribute]
private GridInterpolationModel lSI=;
    [CompilerGeneratedAttribute]
private RectangleShape liI=;
    [CompilerGeneratedAttribute]
private GridDefinition lyI=;
    [CompilerGeneratedAttribute]
private ManualResetEvent mCI=;
    public long myI= { get; public set; }
    public long niI= { get; public set; }
    public GridCell[0...,0...] oSI= { get; public set; }
    public GridInterpolationModel pCI= { get; public set; }
    public RectangleShape pyI= { get; public set; }
    public GridDefinition qiI= { get; public set; }
    public ManualResetEvent rSI= { get; public set; }
    public kSI=(long x, long y, RectangleShape cellExtent, GridCell[0...,0...] cells, GridInterpolationModel model, GridDefinition definition, ManualResetEvent finished);
    [CompilerGeneratedAttribute]
public long mSI=();
    [CompilerGeneratedAttribute]
public void miI=(long value);
    [CompilerGeneratedAttribute]
public long nCI=();
    [CompilerGeneratedAttribute]
public void nSI=(long value);
    [CompilerGeneratedAttribute]
public GridCell[0...,0...] nyI=();
    [CompilerGeneratedAttribute]
public void oCI=(GridCell[0...,0...] value);
    [CompilerGeneratedAttribute]
public GridInterpolationModel oiI=();
    [CompilerGeneratedAttribute]
public void oyI=(GridInterpolationModel value);
    [CompilerGeneratedAttribute]
public RectangleShape pSI=();
    [CompilerGeneratedAttribute]
public void piI=(RectangleShape value);
    [CompilerGeneratedAttribute]
public GridDefinition qCI=();
    [CompilerGeneratedAttribute]
public void qSI=(GridDefinition value);
    [CompilerGeneratedAttribute]
public ManualResetEvent qyI=();
    [CompilerGeneratedAttribute]
public void rCI=(ManualResetEvent value);
}
internal class GRU=.kSQ= : object {
    private short jiQ=;
    public short jyQ=;
    public jCQ=[] kCQ=;
    public int iCQ=;
    public int iSQ=;
    public int iiQ=;
    public int iyQ=;
    public kSQ=(Byte[] buffer);
}
[ExtensionAttribute]
internal static class GRU=.KTA= : object {
    [ExtensionAttribute]
internal static void oR8=(XmlReader reader);
}
internal class GRU=.Kxo= : iBo= {
    internal Double[] 8Rg=;
    internal double Qhk=;
    internal double fxc=;
    internal double shc=;
    internal double sxc=;
    internal Kxo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= DRk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lhg= Chk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
}
internal static class GRU=.kxw= : object {
    public static WkbShapeType lBw=(Byte[] wkb, int startIndex);
    internal static byte lRw=(WkbByteOrder byteOrder);
    internal static WkbByteOrder lhw=(byte content);
    internal static WellKnownType lxw=(Byte[] wkb);
    internal static RectangleShape mBw=(Byte[] wkb);
    private static RectangleShape mRw=(Byte[] wkb);
    private static RectangleShape mhw=(Byte[] wkb);
    private static RectangleShape mxw=(Byte[] wkb);
    private static RectangleShape nBw=(Byte[] wkb);
    private static RectangleShape nRw=(Byte[] wkb);
    private static RectangleShape nhw=(Byte[] wkb);
}
internal class GRU=.kyc= : cCc= {
    public virtual string ayc=();
    public virtual qyY= aic=();
    public virtual Yyc= Zic=();
    public virtual piY= aSc=(String& ppszDstText);
    public virtual piY= dic=(Yyc= poNewGeom);
}
internal class GRU=.LBo= : iBo= {
    internal double LRo=;
    internal double 6hg=;
    internal double Lho=;
    internal double Lxo=;
    internal double MBo=;
    internal double MRo=;
    internal LBo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal enum GRU=.LCA= : Enum {
    public int value__;
    public static LCA= LSA=;
    public static LCA= LiA=;
}
internal class GRU=.lCc= : cCc= {
    public virtual string ayc=();
    public virtual qyY= aic=();
    public virtual Yyc= Zic=();
    public virtual piY= aSc=(String& ppszDstText);
    public virtual piY= dic=(Yyc= poNewGeom);
}
internal class GRU=.Lh0= : HB0= {
    public string LB0= { get; }
    public Lh0=(int line);
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual string Kx0=();
    public virtual int GetHashCode();
}
internal class GRU=.lhg= : ValueType {
    internal double Txg=;
    internal double UBg=;
}
internal class GRU=.lRg= : ValueType {
    internal int Txg=;
    internal int UBg=;
}
internal class GRU=.LRk= : iBo= {
    internal double Lhk=;
    internal LRk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.lRo= : object {
    internal double lho=;
    internal double lxo=;
}
internal class GRU=.lSc= : Yyc= {
    private double lho=;
    private double lxo=;
    private double lic=;
    public lSc=(double xIn, double yIn);
    public lSc=(double xIn, double yIn, double zIn);
    public virtual piY= aSc=(String& ppszDstText);
    public virtual Yyc= Zic=();
    public virtual void Zyc=(Gyc= psEnvelope);
    public double iyc=();
    public double jCc=();
    public double jSc=();
    public virtual void bCc=(int nNewDimension);
    public void lyc=(double xIn);
    public void mCc=(double yIn);
    public void mSc=(double zIn);
    public virtual string ayc=();
    public virtual qyY= aic=();
}
internal class GRU=.lSk= : ySo= {
    protected hCo= lik=;
    public short lyk=;
    public double mCk=;
    public int hyg=;
    public int iCg=;
    public int iSg=;
    public int iig=;
    public bool mSk=;
    public int mik=;
    public int myk=;
    public int nCk=;
    public int nSk=;
    public int nik=;
    public int nyk=;
    public int oCk=;
    public int oSk=;
    public byte oik=;
    public byte oyk=;
    public byte pCk=;
    public byte pSk=;
    public byte pik=;
    public byte pyk=;
    public byte qCk=;
    public byte qSk=;
    public byte qik=;
    public byte qyk=;
    public short rCk=;
    public double rSk=;
    public double rik=;
    public double ryk=;
    public double sCk=;
    public lSk=(ESg= eAccessMode);
    public virtual int CommitToFile();
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public virtual int GetBlockClass();
    public int dSk=(int nX, int nY, Double& dX, Double& dY);
    public int dik=(double dX, double dY, Int32& nX, Int32& nY, bool bIgnoreOverflow);
    public int dyk=(int nX, int nY, Double& dX, Double& dY);
    public int eCk=(double dX, double dY, Int32& nX, Int32& nY);
    public int fCk=(double dXMin, double dYMin, double dXMax, double dYMax);
    public int sSk=(int nObjType);
    public bool sik=(int nObjType);
    public int syk=(hCo= psProjInfo);
    public int tCk=(hCo= psProjInfo);
}
internal static class GRU=.LTI= : object {
    public static Feature LjI=(PointShape centerPoint, double resolutionX, double resolutionY, float halfRadius);
    public static Feature LzI=(PointShape centerPoint, double resolutionX, double resolutionY, float halfRadius);
    public static Feature MDI=(PointShape centerPoint, double resolutionX, double resolutionY, float halfRadius);
    public static Feature MTI=(PointShape centerPoint, double resolutionX, double resolutionY, float halfRadius);
    public static LineShape MjI=(PointShape centerPoint, double resolutionX, double radius);
    public static LineShape MzI=(PointShape centerPoint, double resolutionX, double radius);
    public static LineShape NDI=(PointShape centerPoint, double resolutionX, double radius);
    public static LineShape NTI=(PointShape centerPoint, double resolutionX, double radius);
    public static RectangleShape NjI=(PointShape centerPoint, double resolutionX, double resolutionY, double radius);
    public static RectangleShape NzI=(PointShape centerPoint, double resolutionX, double resolutionY, float radius);
    public static LineShape ODI=(RectangleShape bigRectangleShape);
    public static LineShape OTI=(RectangleShape bigRectangleShape);
    public static LineShape OjI=(RectangleShape bigRectangleShape, RectangleShape smallRectangleShape);
    public static LineShape OzI=(RectangleShape bigRectangleShape, RectangleShape smallRectangleShape);
    public static LineShape PDI=(PointShape centerPoint, double resolutionY, float radius, float halfRadius);
    public static LineShape PTI=(PointShape centerPoint, double resolutionY, float radius, float halfRadius);
    public static LineShape PjI=(PointShape centerPoint, double resolutionX, float radius, float halfRadius);
    public static LineShape PzI=(PointShape centerPoint, double resolutionX, float radius, float halfRadius);
    public static LineShape QDI=(RectangleShape bigRectangleShape, RectangleShape smallRectangleShape);
    public static LineShape QTI=(RectangleShape bigRectangleShape, RectangleShape smallRectangleShape);
    public static Feature QjI=(double resolutionX, double resolutionY, float radius, RectangleShape biggerRectangleShape);
    public static Feature QzI=(double resolutionX, double resolutionY, float radius, RectangleShape smallRectangleShape);
    public static Feature RDI=(double resolutionX, double resolutionY, float radius, RectangleShape smallRectangleShape);
    public static Feature RTI=(double resolutionX, double resolutionY, float radius, RectangleShape smallRectangleShape);
    public static Feature RjI=(PointShape topPoint, double resolutionX, double resolutionY, float radius);
    public static Feature RzI=(PointShape topPoint, double resolutionX, double resolutionY, float radius);
}
internal class GRU=.Lx0= : HB0= {
    public string LB0= { get; }
    public Lx0=(int line);
    public virtual string ToString();
    public virtual bool Equals(object other);
    public virtual string Kx0=();
    public virtual int GetHashCode();
}
internal class GRU=.lxg= : object {
    private hBo= mBg=;
    private Dictionary`2<string, hBo=> mRg=;
    internal hBo= mxg= { get; }
    internal lxg=(Dictionary`2<string, string> args, Dictionary`2<string, hBo=> meridiansList, Int32& pj_Error);
    private static string nBg=(Dictionary`2<string, string> args);
    private void nRg=(string id, Int32& pj_Error);
    internal hBo= mhg=();
}
internal class GRU=.Lxk= : iBo= {
    internal double MBk=;
    internal Double[] MRk=;
    internal Lxk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lhg= Chk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= DRk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.lxU= : object {
    private GeoColor mBU=;
    private GeoColor mRU=;
    public GeoColor nBU= { get; public set; }
    public GeoColor nxU= { get; public set; }
    public GeoColor mhU=();
    public void mxU=(GeoColor value);
    public GeoColor nRU=();
    public void nhU=(GeoColor value);
}
internal class GRU=.Lyo= : ySo= {
    public static int MCo=;
    public Encoding ER8=;
    protected int NCk=;
    protected int MSo=;
    protected int Nik=;
    protected Kig= FCk=;
    public Lyo=(ESg= eAccessMode);
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public virtual int CommitToFile();
    public virtual int GetBlockClass();
    public void QSk=(Kig= poBlockManager);
    public virtual int ReadBytes(int numBytes, Byte[] pabyDstBuf);
    public virtual int WriteBytes(int nBytesToWrite, Byte[] pBuf);
    public void Mio=(int nNextCoordBlockAddress);
    public bool Myo=();
    public int Sik=();
    public int NCo=(int nToolType);
}
internal static class GRU=.LzA= : object {
    internal static GeoImage MDA=(int tileWidth, int tileHeight, RowColumnRange rowColumnRange, List`1<CloudRasterTileInfo> cloudTileInfos);
    internal static ValueTuple`2<GeoImage, RectangleShape> MDA=(int tileWidth, int tileHeight, RowColumnRange rowColumnRange, long widthInMatrix, double widthInWorld, Dictionary`2<ValueTuple`2<long, long>, CloudRasterTileInfo> cloudTileInfos, WrappingMode wrappingMode);
    private static void MTA=(int tileWidth, int tileHeight, RowColumnRange rowColumnRange, long widthInMatrix, double widthInWorld, Dictionary`2<ValueTuple`2<long, long>, CloudRasterTileInfo> cloudTileInfos, WrappingMode wrappingMode, long i, long j, GeoImage cloudImage, List`1<RectangleShape> boxes);
    [AsyncStateMachineAttribute("GRU=.LzA=/eUA=")]
internal static Task MjA=(RasterTileCache projectedTileCache, GeoImage cloudImage, RectangleShape cloudImageExtent, TileMatrix canvasTileMatrix, int zoomIndex, CancellationToken cancellationToken);
    private static List`1<RasterTile> MzA=(GeoImage geoImage, RectangleShape imageExtent, TileMatrix tileMatrix, int zoomLevel);
}
internal abstract class GRU=.MB0= : HB0= {
    public string LB0= { get; }
    public MB0=(string s);
    public MB0=(string s, int line);
    public virtual string ToString();
    public virtual string Kx0=();
    public virtual int GetHashCode();
}
internal class GRU=.mB8= : object {
    internal static bool mR8=(Double& left, Double& bottom, Double& right, Double& top);
    internal static void fh4=(Double& a, Double& b);
}
internal class GRU=.mBk= : iBo= {
    internal double 6Rg=;
    internal double fxc=;
    internal double 6hg=;
    internal double 6xg=;
    internal double 7Bg=;
    internal double 7Rg=;
    internal double 7hg=;
    internal double 7xg=;
    internal double 8Bg=;
    internal Double[] 8Rg=;
    internal int 8hg=;
    private double Yxc=;
    internal mBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal lRo= 9Rg=(lhg= lp, vhg= pjConsts);
    internal lhg= 9hg=(lRo= xy, vhg= pjConsts);
    internal void 9xg=(lhg= lp, vhg= pjConsts, SRg= factors);
    internal void /Bg=(vhg= pjConsts);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    private double PRc=(double sinphi, double e, double one_es, Int32& pj_Error);
    private double ABk=(double qs, double Te, double Tone_es, Int32& pj_Error);
}
internal class GRU=.mC0= : object {
    [CompilerGeneratedAttribute]
private byte hi0=;
    [CompilerGeneratedAttribute]
private List`1<jiw=> mS0=;
    [CompilerGeneratedAttribute]
private List`1<jiw=> mi0=;
    [CompilerGeneratedAttribute]
private List`1<jiw=> my0=;
    [CompilerGeneratedAttribute]
private double nC0=;
    [CompilerGeneratedAttribute]
private double nS0=;
    [CompilerGeneratedAttribute]
private RectangleShape ni0=;
    public byte jC0= { get; private set; }
    public List`1<jiw=> oS0= { get; private set; }
    public List`1<jiw=> pC0= { get; private set; }
    public List`1<jiw=> py0= { get; private set; }
    public double qi0= { get; private set; }
    public double rS0= { get; private set; }
    public RectangleShape sC0= { get; private set; }
    public mC0=(byte accuracy);
    [CompilerGeneratedAttribute]
private void iy0=(byte value);
    [CompilerGeneratedAttribute]
public byte ii0=();
    [CompilerGeneratedAttribute]
private void oC0=(List`1<jiw=> value);
    [CompilerGeneratedAttribute]
public List`1<jiw=> ny0=();
    [CompilerGeneratedAttribute]
private void oy0=(List`1<jiw=> value);
    [CompilerGeneratedAttribute]
public List`1<jiw=> oi0=();
    [CompilerGeneratedAttribute]
private void pi0=(List`1<jiw=> value);
    [CompilerGeneratedAttribute]
public List`1<jiw=> pS0=();
    [CompilerGeneratedAttribute]
private void qS0=(double value);
    [CompilerGeneratedAttribute]
public double qC0=();
    [CompilerGeneratedAttribute]
private void rC0=(double value);
    [CompilerGeneratedAttribute]
public double qy0=();
    [CompilerGeneratedAttribute]
private void ry0=(RectangleShape value);
    [CompilerGeneratedAttribute]
public RectangleShape ri0=();
    public void fC0=(7iw= RTreeLeaf, RectangleShape Box, List`1<string> lblDatas, bool addLblDatas);
    private void sS0=(RectangleShape box);
}
internal class GRU=.MCM= : object {
    private double MSM=;
    private double MiM=;
    private double MyM=;
    private double NCM=;
    public double KCM= { get; public set; }
    public double JSM= { get; public set; }
    public double IiM= { get; public set; }
    public double HyM= { get; public set; }
    public void JyM=(double value);
    public double JiM=();
    public void JCM=(double value);
    public double IyM=();
    public void ISM=(double value);
    public double ICM=();
    public void HiM=(double value);
    public double HSM=();
}
internal class GRU=.Mh0= : MB0= {
    public Mh0=(string s);
    public Mh0=(string s, int line);
}
internal static class GRU=.Mhc= : object {
    private static double Mxc=;
    private static Mhc=();
    internal static double NBc=(double lon, Int32& pj_Error);
    internal static double NRc=(double phi, double sphi, double cphi, Double[] en);
    internal static double Nhc=(double v, Int32& pj_Error);
    internal static double Nxc=(double arg, double es, Double[] en, Int32& pj_Error);
    internal static Double[] OBc=(double es);
    internal static Double[] ORc=(double es);
    internal static double Ohc=(double beta, Double[] APA, Int32& pj_Error);
    internal static double Oxc=(double n, double d, Int32& pj_Error);
    internal static double PBc=(double v, Int32& pj_Error);
    internal static double PRc=(double sinphi, double e, double one_es, Int32& pj_Error);
    internal static double Phc=(double v, Int32& pj_Error);
    internal static double Pxc=(double sinphi, double cosphi, double es, Int32& pj_Error);
    internal static double QBc=(double phi, double sinphi, double e, Int32& pj_Error);
    internal static double QRc=(double ts, double e, Int32& pj_Error);
    internal static uhg= Qhc=(Dictionary`2<string, string> paras, string param, Int32& pj_Error);
    internal static double Qxc=(string p, Int32& pj_Error);
    internal static double RBc=(string handleStr, String& tempStr);
    internal static string RRc=(string lineStr);
    internal static Stream Rhc=(string filePath, FileAccess readWriteMode);
    internal static bool Rxc=();
    internal static void SBc=(Byte[] data, int offsetIndex, int wordSize, int wordCount);
    internal static string SRc=(Byte[] characters, int index, int count);
    internal static int Shc=(Byte[] byteArray, int index, int count, Int32& pj_Error);
    internal static double Sxc=(Byte[] byteArray, int index, int count);
    internal static void TBc=(double x, Int32& pj_Error);
    internal static string TRc=(string param);
}
internal class GRU=.mhk= : iBo= {
    internal mhk=(string id, string desc);
    private void 8xg=();
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Mhk= : iBo= {
    internal lRo= Mxk=;
    internal double NBk=;
    internal double NRk=;
    internal double Nhk=;
    internal Mhk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Mho= : iBo= {
    internal double Mxo=;
    internal double NBo=;
    internal double NRo=;
    internal double Nho=;
    internal int CRk=;
    internal Mho=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private double Nxo=(double phit, double sinphi, double eccen, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= DRk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lhg= Chk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.mic= : Yyc= {
    private int myc=;
    private fic=[] nCc=;
    public virtual string ayc=();
    public virtual qyY= aic=();
    public virtual Yyc= Zic=();
    public virtual piY= aSc=(String& ppszDstText);
    public virtual void Zyc=(Gyc= psEnvelope);
    public virtual void bCc=(int nNewDimension);
    public void nSc=(fic= poNewRing);
    public void nic=(fic= poNewRing);
    public fic= nyc=();
    public int oCc=();
    public fic= oSc=(int iRing);
}
internal class GRU=.Mik= : ySo= {
    private static int Myk=;
    protected int NCk=;
    protected int NSk=;
    protected int Nik=;
    protected int iyg=;
    protected int jCg=;
    protected int Nyk=;
    protected int OCk=;
    protected int OSk=;
    protected int Oik=;
    protected Kig= FCk=;
    protected int Oyk=;
    protected int PCk=;
    protected int PSk=;
    protected int Pik=;
    protected int Pyk=;
    protected int QCk=;
    public Mik=(ESg= eAccessMode);
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public virtual int CommitToFile();
    public virtual int GetBlockClass();
    public void QSk=(Kig= poBlockManager);
    public virtual int ReadBytes(int numBytes, Byte[] pabyDstBuf);
    public virtual int WriteBytes(int nBytesToWrite, Byte[] pabySrcBuf);
    public void Qik=(int nX, int nY);
    public int Qyk=(bool bCompressed, Int32& nX, Int32& nY);
    public int RCk=(bool bCompressed, int numCoordPairs, Int32[] panXY);
    public int RSk=(bool bCompressed, int nVersion, int numSections, Tik=[] pasHdrs, Int32& numVerticesTotal);
    public int Rik=(int nVersion, int numSections, Tik=[] pasHdrs, bool bCompressed);
    public void Ryk=(int nNextCoordBlockAddress);
    public int SCk=();
    public int SSk=(int nX, int nY, bool bCompressed);
    public int Sik=();
    public void Syk=();
    public void TCk=();
    public int TSk=();
}
internal enum GRU=.miQ= : Enum {
    public int value__;
    public static miQ= myQ=;
    public static miQ= nCQ=;
    public static miQ= nSQ=;
    public static miQ= niQ=;
    public static miQ= nyQ=;
    public static miQ= oCQ=;
    public static miQ= oSQ=;
}
internal class GRU=.MR0= : MB0= {
    public MR0=(string s);
    public MR0=(string s, int line);
}
internal class GRU=.mRk= : iBo= {
    internal Thc=[] Fxk=;
    internal double GBk=;
    internal double GRk=;
    internal int fxc=;
    internal mRk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private Thc= Ghk=(Thc= z, Thc=[] C, int n, Thc= der);
    private Thc= Gxk=(Thc= z, Thc=[] C, int n);
}
internal class GRU=.mSE= : object {
    public static int miE=;
    private static giE= UiE=;
    private TextReader myE=;
    private Char[] uBw=;
    private 5D8= nCE=;
    private 6D8= nSE=;
    private int niE=;
    private int nyE=;
    private int oCE=;
    private int oSE=;
    private bool oiE=;
    private bool oyE=;
    private char pCE=;
    private Nullable`1<char> pSE=;
    public TextReader 3Rw= { get; }
    public bool WSE= { get; public set; }
    public bool XCE= { get; public set; }
    public char XyE= { get; public set; }
    public Nullable`1<char> YiE= { get; public set; }
    public bool aSE= { get; }
    private bool pyE= { get; }
    public mSE=(TextReader reader);
    private static mSE=();
    public TextReader 2xw=();
    public bool VyE=();
    public void WCE=(bool value);
    public bool WiE=();
    public void WyE=(bool value);
    public char XSE=();
    public void XiE=(char value);
    public Nullable`1<char> YCE=();
    public void YSE=(Nullable`1<char> value);
    public bool aCE=();
    private bool piE=();
    public int biE=(int skip);
    public int qCE=(diE= headerRecord, dCE=[] buffer, int offset, int count);
    private static bool qSE=(char ch);
    private void qiE=();
    private bool qyE=(char ch);
    private bool rCE=();
    private bool rSE=();
}
internal static class GRU=.mSs= : object {
    internal static void mis=(bool isEditable);
    internal static void mys=(bool isOpen);
    internal static void nCs=(bool isInTransaction);
    internal static void nSs=(bool isInTransaction);
    internal static void nis=(int value);
    internal static void nys=(string contractId);
    internal static void oCs=(int symbolNumber, string parameterName);
}
internal class GRU=.Mx0= : MB0= {
    public Mx0=(string s);
    public Mx0=(string s, int line);
}
internal class GRU=.mxk= : iBo= {
    internal mxk=(string id, string desc);
    private void 8xg=();
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Myg= : object {
    public int NCg=;
    public Myg= yCQ=;
}
internal class GRU=.myw= : object {
    [CompilerGeneratedAttribute]
private Vertex nCw=;
    [CompilerGeneratedAttribute]
private string kCw=;
    [CompilerGeneratedAttribute]
private List`1<int> nSw=;
    [CompilerGeneratedAttribute]
private bool niw=;
    public Vertex oSw= { get; public set; }
    public string lyw= { get; public set; }
    public List`1<int> pCw= { get; public set; }
    public bool pyw= { get; public set; }
    [CompilerGeneratedAttribute]
public Vertex nyw=();
    [CompilerGeneratedAttribute]
public void oCw=(Vertex value);
    [CompilerGeneratedAttribute]
public string lSw=();
    [CompilerGeneratedAttribute]
public void liw=(string value);
    [CompilerGeneratedAttribute]
public List`1<int> oiw=();
    [CompilerGeneratedAttribute]
public void oyw=(List`1<int> value);
    [CompilerGeneratedAttribute]
public void piw=(bool value);
    [CompilerGeneratedAttribute]
public bool pSw=();
    public virtual string ToString();
}
internal class GRU=.mzE= : ValueType {
    internal int lho=;
    internal int lxo=;
    public mzE=(int x, int y);
}
internal class GRU=.NB0= : MB0= {
    public NB0=(string s);
    public NB0=(string s, int line);
}
internal class GRU=.nBk= : iBo= {
    internal double 7xg=;
    internal double FRk=;
    internal double nRk=;
    internal nBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.nCg= : object {
    protected int nSg=;
    protected NSg= nig=;
    private static NSg= nyg=;
    public NSg= iyU= { get; public set; }
    public int jiU= { get; public set; }
    public virtual int jyU=();
    public virtual NSg= kCU=();
    public virtual int kSU=();
    public virtual int kiU=();
    public virtual byte kyU=();
    public virtual byte lCU=();
    public virtual void lSU=(int clr);
    public virtual void liU=(int clr);
    public virtual void lyU=(byte val);
    public virtual void mCU=(byte val);
    public virtual string mSU=();
    public virtual void miU=(string pszStyleString);
    public virtual void myU=(Stream fpOut);
    public sealed virtual NSg= iSU=();
    public sealed virtual void iiU=(NSg= value);
    public sealed virtual int jCU=();
    public sealed virtual void jSU=(int value);
}
internal interface GRU=.nCU= {
    public int nyU= { get; public set; }
    public 3Cg= oiU= { get; public set; }
    public abstract virtual int nSU=();
    public abstract virtual void niU=(int value);
    public abstract virtual 3Cg= oCU=();
    public abstract virtual void oSU=(3Cg= value);
    public abstract virtual int oyU=();
    public abstract virtual 3Cg= pCU=();
    public abstract virtual string pSU=();
    public abstract virtual void piU=(string pszName);
    public abstract virtual void pyU=(Stream fpOut);
}
internal class GRU=.NDA= : object {
    public static string NTA=;
    public static string NjA=;
    public static string NzA=;
    public static string ODA=;
    public static string OTA=;
    public static string OjA=;
    public static string OzA=;
    public static string PDA=;
    public static string PTA=;
    public static string PjA=;
    public static string PzA=;
    public static string QDA=;
    public static string QTA=;
    public static string QjA=;
    public static string QzA=;
    public static string RDA=;
    public static string RTA=;
    public static string RjA=;
    public static string RzA=;
    public static string SDA=;
    public static string STA=;
    public static string SjA=;
    public static string SzA=;
    public static string TDA=;
    public static string TTA=;
    public static string TjA=;
    public static string TzA=;
    public static string UDA=;
    public static string UTA=;
    public static string UjA=;
    public static string UzA=;
    public static string VDA=;
    public static string VTA=;
    public static string VjA=;
    public static string VzA=;
    public static string WDA=;
    public static string WTA=;
    public static string WjA=;
    public static string WzA=;
    public static string XDA=;
    public static string XTA=;
    public static string XjA=;
    public static string XzA=;
    public static string YDA=;
    public static string YTA=;
    public static string YjA=;
    public static string YzA=;
    public static string ZDA=;
    public static string ZTA=;
    public static string ZjA=;
    public static string ZzA=;
    public static string aDA=;
    public static string aTA=;
    public static string ajA=;
    public static string azA=;
    public static string bDA=;
    public static string bTA=;
    public static string bjA=;
    public static string bzA=;
    public static string cDA=;
    public static string cTA=;
    public static string cjA=;
    public static string czA=;
    public static string dDA=;
    public static string dTA=;
    public static string djA=;
    public static string dzA=;
    public static string eDA=;
    public static string eTA=;
    public static string ejA=;
    public static string ezA=;
    public static string fDA=;
    public static string fTA=;
    public static string fjA=;
    public static string fzA=;
    public static string gDA=;
    public static string gTA=;
    public static string gjA=;
    public static string gzA=;
    public static string hDA=;
    public static string hTA=;
    public static string hjA=;
    public static string hzA=;
    public static string iDA=;
    public static string iTA=;
    public static string ijA=;
    public static string izA=;
    public static string jDA=;
    public static string jTA=;
    public static string jjA=;
    public static string jzA=;
    public static string kDA=;
    public static string kTA=;
    public static string kjA=;
    public static string kzA=;
    public static string lDA=;
    public static string lTA=;
    public static string ljA=;
    public static string lzA=;
    public static string mDA=;
    public static string mTA=;
    public static string mjA=;
    public static string mzA=;
    public static string nDA=;
    public static string uCs=;
    public static string nTA=;
    public static string njA=;
    public static string nzA=;
    public static string oDA=;
    public static string oTA=;
    public static string ojA=;
    public static string ozA=;
    public static string pDA=;
    public static string pTA=;
    public static string pjA=;
    public static string pzA=;
    public static string qDA=;
    public static string qTA=;
    public static string qjA=;
    public static string qzA=;
    public static string rDA=;
    public static string rTA=;
    public static string rjA=;
    public static string rzA=;
    public static string sDA=;
    public static string sTA=;
    public static string sjA=;
    public static string szA=;
    public static string tDA=;
    public static string tTA=;
    public static string tjA=;
    public static string tzA=;
    public static string uDA=;
    public static string uTA=;
    public static string ujA=;
    public static string uzA=;
    public static string vDA=;
    public static string vTA=;
    public static string vjA=;
    public static string vzA=;
    public static string wDA=;
    public static string wTA=;
    private static Assembly wjA=;
    public static string xDA= { get; }
    public static string xjA= { get; }
    public static string yDA= { get; }
    public static string yjA= { get; }
    public static string zDA= { get; }
    public static string zjA= { get; }
    public static Byte[] 0DA= { get; }
    public static Byte[] 0jA= { get; }
    public static Byte[] 1DA= { get; }
    public static Byte[] 1jA= { get; }
    public static Byte[] 2DA= { get; }
    public static Byte[] 2jA= { get; }
    public static Byte[] 3DA= { get; }
    public static Byte[] 3jA= { get; }
    public static Byte[] 4DA= { get; }
    public static Byte[] 4jA= { get; }
    public static Byte[] 5DA= { get; }
    public static Byte[] 5jA= { get; }
    public static Byte[] 6DA= { get; }
    public static Byte[] 6jA= { get; }
    public static Byte[] 7DA= { get; }
    public static Byte[] 7jA= { get; }
    public static Byte[] 8DA= { get; }
    public static Byte[] 8jA= { get; }
    private static NDA=();
    public static string wzA=();
    public static string xTA=();
    public static string xzA=();
    public static string yTA=();
    public static string yzA=();
    public static string zTA=();
    public static Byte[] zzA=();
    public static Byte[] 0TA=();
    public static Byte[] 0zA=();
    public static Byte[] 1TA=();
    public static Byte[] 1zA=();
    public static Byte[] 2TA=();
    public static Byte[] 2zA=();
    public static Byte[] 3TA=();
    public static Byte[] 3zA=();
    public static Byte[] 4TA=();
    public static Byte[] 4zA=();
    public static Byte[] 5TA=();
    public static Byte[] 5zA=();
    public static Byte[] 6TA=();
    public static Byte[] 6zA=();
    public static Byte[] 7TA=();
    public static Byte[] 7zA=();
    public static Byte[] 8TA=();
    public static Byte[] 6xM=(string resourceName);
    public static string ASw=(string resourceName);
    public static Byte[] 8zA=(Stream stream);
}
internal class GRU=.Nh0= : HB0= {
    public string LB0= { get; }
    public Nh0=(string s);
    public Nh0=(float f);
    public Nh0=(double d);
    public Nh0=(string s, int line);
    public Nh0=(double f, int line);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual string Kx0=();
    public virtual bool Equals(object other);
}
internal class GRU=.nhg= : object {
    internal static double WhY=;
    internal static double nxg=(double d);
    internal static double oBg=(double x, double y);
    internal static double oRg=(double d, Int32& pj_Error);
    internal static double ohg=(double d, Int32& pj_Error);
    internal static double oxg=(double d, Int32& pj_Error);
    internal static double pBg=(double d, Int32& pj_Error);
    internal static double pRg=(double d, Int32& pj_Error);
    internal static double phg=(double d, Int32& pj_Error);
    internal static double pxg=(double y, double x, Int32& pj_Error);
    internal static double qBg=(double d, Int32& pj_Error);
    internal static double qRg=(double d, Int32& pj_Error);
    internal static double qhg=(double d, Int32& pj_Error);
    internal static double qxg=(double x, double y, Int32& pj_Error);
    internal static double rBg=(double d, Int32& pj_Error);
    internal static double rRg=(double d, Int32& pj_Error);
    internal static double rhg=(double d, Int32& pj_Error);
}
internal class GRU=.nhk= : iBo= {
    internal double Kxk=;
    internal double nxk=;
    internal double oBk=;
    internal double Shk=;
    internal double oRk=;
    internal double ohk=;
    internal double uxg=;
    internal double oxk=;
    internal double Zxk=;
    internal double pBk=;
    internal double pRk=;
    internal double phk=;
    internal double pxk=;
    internal double qBk=;
    internal double qRk=;
    internal nhk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private void qhk=(double lam, double mult, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.NR0= : HB0= {
    public string LB0= { get; }
    public NR0=(string s, int line);
    public NR0=(char c);
    public NR0=(char c, int line);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual string Kx0=();
    public virtual bool Equals(object other);
}
internal class GRU=.NS4= : ValueType {
    [CompilerGeneratedAttribute]
private int Ni4=;
    [CompilerGeneratedAttribute]
private int Ny4=;
    [CompilerGeneratedAttribute]
private int OC4=;
    [CompilerGeneratedAttribute]
private int OS4=;
    public int PC4= { get; public set; }
    public int Py4= { get; public set; }
    public int Qi4= { get; public set; }
    public int RS4= { get; public set; }
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int Oi4=();
    [CompilerGeneratedAttribute]
public void Oy4=(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int PS4=();
    [CompilerGeneratedAttribute]
public void Pi4=(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int QC4=();
    [CompilerGeneratedAttribute]
public void QS4=(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int Qy4=();
    [CompilerGeneratedAttribute]
public void RC4=(int value);
}
internal class GRU=.NSg= : object {
    public int OSc=;
    public byte Nig=;
    public byte Nyg=;
    public int OCg=;
    public int OSg=;
    public NSg=(int nRefCount, byte nFillPattern, byte bTransparentFill, int rgbFGColor, int rgbBGColor);
}
internal class GRU=.NSM= : object {
    private List`1<Collection`1<GridCell>> NiM=;
    private double NyM=;
    public List`1<Collection`1<GridCell>> OSM= { get; }
    public double PCM= { get; public set; }
    public List`1<Collection`1<GridCell>> OCM=();
    public void OyM=(double value);
    public double OiM=();
}
internal class GRU=.NSo= : QCo= {
    private bool Nio=;
    private double GSg=;
    private double Gig=;
    private static int 8CQ=;
    private static int 8SQ=;
    private static int 8iQ=;
    private static int 8yQ=;
    public NSo=(OCc= poDefnIn);
    public virtual oCg= Hig=();
    public virtual int Hyg=(Vyk= poMapFile);
    public virtual hSg= ICg=(OCc= poNewDefn);
    public int Nyo=(int i, Double& dX, Double& dY);
    public int OCo=();
    public int OSo=(Double& dX, Double& dY);
    public void Oio=(double dX, double dY);
    public virtual int ISg=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iig=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iyg=(5yU= fp);
    public virtual int JCg=(5yU= fp);
    public virtual void JSg=(Stream fsOut);
}
internal class GRU=.nSY= : object {
    public int niY=;
    public piY= nyY=(mic= poPoly, lSc= poLabelPoint);
    private bool oCY=(lSc= poPoint, mic= poPoly);
    private bool oSY=(lSc= poPoint, gyc= poRing);
}
internal class GRU=.Nx0= : HB0= {
    public string LB0= { get; }
    public Nx0=(int i);
    public Nx0=(long i);
    public Nx0=(string s);
    public Nx0=(string s, int line);
    public Nx0=(int i, int line);
    public Nx0=(long l, int line);
    public static Nx0= OB0=(string s, int lineNumber);
    private void jxU=(string s);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual string Kx0=();
    public virtual bool Equals(object other);
}
internal class GRU=.Nxk= : iBo= {
    internal Nxk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.nxw= : object {
    public BaseShape oBw=(Byte[] data);
    public static WkbShapeType lBw=(Byte[] wkb, int startIndex);
    public virtual BaseShape oBw=(Stream stream);
    protected BaseShape oBw=(BinaryReader reader);
    protected WkbByteOrder oRw=(BinaryReader reader);
    protected Vertex ohw=(BinaryReader reader);
    protected RingShape oxw=(BinaryReader reader);
    protected PointShape pBw=(BinaryReader reader);
    protected LineShape pRw=(BinaryReader reader);
    protected PolygonShape phw=(BinaryReader reader);
    protected MultipointShape pxw=(BinaryReader reader);
    protected MultilineShape qBw=(BinaryReader reader);
    protected MultipolygonShape qRw=(BinaryReader reader);
    protected GeometryCollectionShape qhw=(BinaryReader reader);
}
internal class GRU=.Ny8= : object {
    private float OC8=;
    private float OS8=;
    private int Oi8=;
    public float PS8= { get; public set; }
    public float QC8= { get; public set; }
    public int Qy8= { get; public set; }
    public float Oy8=();
    public void PC8=(float value);
    public float Pi8=();
    public void Py8=(float value);
    public int QS8=();
    public void Qi8=(int value);
}
internal class GRU=.NzM= : object {
    private string NxQ=;
    private Exception ODM=;
    private bool OTM=;
    private ThinkGeoLicenseStatus NhQ=;
    private static int OjM=;
    private bool OzM=;
    private double PDM=;
    private int PTM=;
    [CompilerGeneratedAttribute]
private DateTime PjM=;
    [CompilerGeneratedAttribute]
private DateTime PzM=;
    public bool QTM= { get; }
    public string YhQ= { get; public set; }
    public Exception RDM= { get; public set; }
    public bool RzM= { get; public set; }
    internal ThinkGeoLicenseStatus XxQ= { get; internal set; }
    internal bool STM= { get; }
    internal DateTime TDM= { get; internal set; }
    private DateTime TzM= { get; private set; }
    internal double UjM= { get; internal set; }
    public bool QDM=();
    public string YBQ=();
    public void YRQ=(string value);
    public Exception QjM=();
    public void QzM=(Exception value);
    public bool RTM=();
    public void RjM=(bool value);
    internal ThinkGeoLicenseStatus XRQ=();
    internal void XhQ=(ThinkGeoLicenseStatus value);
    internal bool SDM=();
    [CompilerGeneratedAttribute]
internal DateTime SjM=();
    [CompilerGeneratedAttribute]
internal void SzM=(DateTime value);
    [CompilerGeneratedAttribute]
private DateTime TTM=();
    [CompilerGeneratedAttribute]
private void TjM=(DateTime value);
    internal double UDM=();
    internal void UTM=(double value);
    private bool UzM=();
}
internal class GRU=.OBk= : iBo= {
    internal OBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.OBo= : ValueType {
    internal double ERg=;
    internal double LRo=;
    internal double yRg=;
    internal double ORo=;
}
internal class GRU=.OCc= : object {
    private int OSc=;
    private int Oic=;
    private List`1<Vyc=> Oyc=;
    private qyY= PCc=;
    private string PSc=;
    public OCc=(string pszName);
    public string Pic=();
    public int Kyc=();
    public Vyc= Pyc=(int iField);
    public int LSc=(string pszFieldName);
    public void QCc=(Vyc= poNewDefn);
    public qyY= QSc=();
    public void Qic=(qyY= eNewType);
    public int Qyc=();
    public int RCc=();
    public void RSc=();
}
internal enum GRU=.oCg= : Enum {
    public int value__;
    public static oCg= oSg=;
    public static oCg= oig=;
    public static oCg= oyg=;
    public static oCg= pCg=;
    public static oCg= pSg=;
    public static oCg= pig=;
    public static oCg= pyg=;
    public static oCg= qCg=;
    public static oCg= qSg=;
    public static oCg= qig=;
    public static oCg= qyg=;
    public static oCg= rCg=;
    public static oCg= rSg=;
}
internal class GRU=.Ohk= : iBo= {
    internal Ohk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Oho= : iBo= {
    internal int cBc=;
    internal Double[] Oxo=;
    internal double PBo=;
    internal double PRo=;
    internal double Pho=;
    internal OBo=[] 8Rg=;
    internal Oho=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private double Pxo=(double esinp, double exp, Int32& pj_Error);
    private OBo= QBo=(double e, double phi0, Double[] chi, Double[] rc, Int32& pj_Error);
    private lhg= QRo=(lhg= slp, OBo=[] en, Int32& pj_Error);
    private lhg= Qho=(lhg= elp, OBo=[] en, Int32& pj_Error);
}
internal class GRU=.oi4= : object {
    private List`1<bi4=> oy4=;
    private yyw= zSw=;
    public List`1<bi4=> pS4= { get; }
    public List`1<bi4=> pC4=();
    public void oBw=(Stream stream, int endOffset, bool isEncrypted, Encoding encoding, int columnNameBlockCount, string password);
}
internal class GRU=.oic= : object {
    public static void oyc=(String& destString, int index, string srcString);
    public static void GCU=(T[] dest, int indexDest, T[] src, int indexSrc, int count);
    public static T[] FCU=(T[] srcArray, int destLength);
    public static int CSU=(String& stringDst, int index);
    public static int CSU=(string charArray);
    public static string CiU=(string strOgr, string strSub);
    public static bool EiU=(string string1, string string2, int count);
    public static bool EyU=(string string1, string string2);
}
internal class GRU=.Oig= : hSg= {
    private 7So= Oyg=;
    private gCo= PCg=;
    private NSo= PSg=;
    private tig= Pig=;
    private static int 8CQ=;
    private static int 8SQ=;
    private static int 8iQ=;
    private static int 8yQ=;
    public int wSU= { get; public set; }
    public His= xCU= { get; public set; }
    public Oig=(OCc= poDefnIn);
    private void Pyg=();
    private int QCg=(Mik= poCoordBlock, bool bComprCoord, int nComprOrgX, int nComprOrgY, Int32& pnMinX, Int32& pnMinY, Int32& pnMaxX, Int32& pnMaxY, Int32& pnLabelX, Int32& pnLabelY);
    private int QSg=(Mik= poCoordBlock, bool bComprCoord, int nMinX, int nMinY, int nMaxX, int nMaxY, int nLabelX, int nLabelY);
    private int Qig=(bool bSyncRegion, bool bSyncPline, bool bSyncMpoint);
    public virtual oCg= Hig=();
    public virtual int Hyg=(Vyk= poMapFile);
    public virtual hSg= ICg=(OCc= poNewDefn);
    public virtual int ISg=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iig=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iyg=(5yU= fp);
    public virtual int JCg=(5yU= fp);
    public virtual string Nic=();
    public virtual void JSg=(Stream fsOut);
    public int Qyg=(7So= poRegion);
    public int RCg=(gCo= poPline);
    public int RSg=(NSo= poMpoint);
    public virtual int vyU=();
    public virtual void wCU=(int value);
    public virtual His= wiU=();
    public virtual void wyU=(His= value);
    public virtual int xSU=();
    public virtual His= xiU=();
    public virtual short xyU=();
    public virtual short yCU=();
    public virtual int ySU=();
    public virtual void yiU=(short val);
    public virtual void yyU=(short val);
    public virtual void zCU=(int clr);
    public virtual string zSU=(double dfAngle);
    public virtual void ziU=(string pszStyleString);
    public virtual void zyU=(Stream fpOut);
}
internal enum GRU=.oiQ= : Enum {
    public int value__;
    public static oiQ= oyQ=;
    public static oiQ= pCQ=;
    public static oiQ= pSQ=;
    public static oiQ= piQ=;
    public static oiQ= pyQ=;
    public static oiQ= qCQ=;
    public static oiQ= qSQ=;
    public static oiQ= qiQ=;
    public static oiQ= qyQ=;
    public static oiQ= rCQ=;
    public static oiQ= rSQ=;
    public static oiQ= riQ=;
}
internal abstract class GRU=.oiY= : Yyc= {
    public abstract virtual void oyY=(lSc= ogrPoint);
    public abstract virtual void pCY=(lSc= ogrPoint);
    public virtual int pSY=();
}
internal enum GRU=.OR0= : Enum {
    public int value__;
    public static OR0= Oh0=;
    public static OR0= Ox0=;
    public static OR0= PB0=;
    public static OR0= PR0=;
}
internal class GRU=.ORk= : iBo= {
    internal ORk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.oRs= : object {
    protected long ohs=;
    public virtual long oxs=();
}
internal static class GRU=.OSI= : object {
    public static string OiI=(string degreesMinutesSeconds);
}
internal class GRU=.Oxk= : iBo= {
    internal lRo= Mxk=;
    internal double NBk=;
    internal double NRk=;
    internal double Nhk=;
    internal Oxk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Oy0= : object {
    [CompilerGeneratedAttribute]
private ushort PC0=;
    [CompilerGeneratedAttribute]
private string PS0=;
    [CompilerGeneratedAttribute]
private WellKnownType yCM=;
    [CompilerGeneratedAttribute]
private RectangleShape Pi0=;
    [CompilerGeneratedAttribute]
private int jyw=;
    public ushort QS0= { get; private set; }
    public string RC0= { get; public set; }
    public WellKnownType wiw= { get; private set; }
    public RectangleShape Ry0= { get; public set; }
    public int lCw= { get; private set; }
    public Oy0=(RectangleShape box);
    public Oy0=(RectangleShape box, WellKnownType objType, int objIndex, string lable, ushort fclass);
    [CompilerGeneratedAttribute]
private void QC0=(ushort value);
    [CompilerGeneratedAttribute]
public ushort Py0=();
    [CompilerGeneratedAttribute]
public void Qy0=(string value);
    [CompilerGeneratedAttribute]
public string Qi0=();
    [CompilerGeneratedAttribute]
private void wSw=(WellKnownType value);
    [CompilerGeneratedAttribute]
public WellKnownType wCw=();
    [CompilerGeneratedAttribute]
public void Ri0=(RectangleShape value);
    [CompilerGeneratedAttribute]
public RectangleShape RS0=();
    [CompilerGeneratedAttribute]
private void kyw=(int value);
    [CompilerGeneratedAttribute]
public int kiw=();
}
internal enum GRU=.OyI= : Enum {
    public int value__;
    public static OyI= PCI=;
    public static OyI= PSI=;
}
internal class GRU=.Oyo= : object {
    public int OSc=;
    public byte PCo=;
    public byte PSo=;
    public int Pio=;
    public int Pyo=;
    public Oyo=(int nRefCount, byte nPixelWidth, byte nLinePattern, int nPointWidth, int rgbColor);
}
internal class GRU=.PBk= : iBo= {
    internal double shc=;
    internal double sxc=;
    internal double PRk=;
    internal double Phk=;
    internal PBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.pBs= : object {
    private double pRs=;
    private double phs=;
    public double qRs= { get; public set; }
    public double rBs= { get; public set; }
    public pBs=(double easting, double northing);
    public double pxs=();
    public void qBs=(double value);
    public double qhs=();
    public void qxs=(double value);
    public virtual string ToString();
}
internal class GRU=.pCc= : object {
    public double lho=;
    public double lxo=;
}
internal class GRU=.Ph0= : object {
    private int Px0=;
    public BaseShape oBw=(string wellKnownText);
    public BaseShape oBw=(TextReader reader);
    private Vertex[] QB0=(IList tokens, bool skipExtraParenthesis);
    private Vertex QR0=(IList tokens, bool skipExtraParenthesis);
    private bool Qh0=(IList tokens, string stringValue);
    private bool Qx0=(IList tokens);
    private double RB0=(IList tokens);
    private string RR0=(IList tokens);
    private string Rh0=(IList tokens);
    private string Rx0=(IList tokens);
    private string SB0=(IList tokens);
    private BaseShape SR0=(IList tokens);
    private PointShape Sh0=(IList tokens);
    private LineShape Sx0=(IList tokens);
    private RingShape TB0=(IList tokens);
    private MultipointShape TR0=(IList tokens);
    private IEnumerable`1<PointShape> Th0=(Vertex[] coordinates);
    private PolygonShape Tx0=(IList tokens);
    private MultilineShape UB0=(IList tokens);
    private MultipolygonShape UR0=(IList tokens);
    private GeometryCollectionShape Uh0=(IList tokens);
}
internal class GRU=.pi4= : object {
    private List`1<string> py4=;
    private int qC4=;
    private int qS4=;
    private double 9yw=;
    private Encoding ER8=;
    private int qi4=;
    private TinyGeoFileType Ly4=;
    public List`1<string> rC4= { get; }
    public int ri4= { get; }
    public int sC4= { get; }
    public double GC4= { get; }
    public int si4= { get; }
    public Encoding Gi4= { get; }
    public TinyGeoFileType Xy4= { get; }
    public List`1<string> qy4=();
    public int rS4=();
    public int ry4=();
    public double Fy4=();
    public int sS4=();
    public Encoding GS4=();
    public TinyGeoFileType Xi4=();
    public void oBw=(Stream stream, bool isEncrypted, string password);
}
internal enum GRU=.piY= : Enum {
    public int value__;
    public static piY= pyY=;
    public static piY= JyU=;
    public static piY= KCU=;
    public static piY= KSU=;
    public static piY= KiU=;
    public static piY= KyU=;
    public static piY= LCU=;
    public static piY= LSU=;
    public static piY= LiU=;
}
internal class GRU=.pSc= : object {
    private double pic=;
    private double pyc=;
    private double qCc=;
    private 7Sc= qSc=;
    private int OSc=;
    private int qic=;
    private void 7xY=();
    public int Qyc=();
    public int RCc=();
    public pSc= Hhc=();
    public piY= vBY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    public piY= wBY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public piY= wRY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public piY= wxY=(double dfStdP1, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public piY= xBY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public piY= xRY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public piY= qyc=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public piY= rCc=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public piY= yRY=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public piY= zhY=(double dfCenterLat, double dfCenterLong, double dfAzimuth, double dfRectToSkew, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    public piY= 0RY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public piY= 0hY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public piY= 1BY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public piY= 1RY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public piY= 1hY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    public piY= 2BY=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public piY= 2RY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public piY= 3BY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public piY= 3hY=(double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public piY= 3xY=(double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    public piY= 4BY=(double dfOriginLat, double dfCMeridian, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    public piY= 4RY=(double dfLatitudeOfOrigin, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    public piY= rSc=(string pszVariantName, double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    public piY= aSc=(String& ppszResult);
    public static int 7RY=(string pszParameterName);
    public piY= 7BY=(double dfDX, double dfDY, double dfDZ, double dfEX, double dfEY, double dfEZ, double dfPPM);
    public 7Sc= MyA=();
    public void ric=(7Sc= poNewRoot);
    public 7Sc= phY=(string pszNodePath);
    public string pxY=(string pszNodeName, int iAttr);
    public piY= qhY=(string pszNodePath, string pszNewNodeValue);
    public piY= rRY=(string pszUnitsName, double dfInMeters);
    public double rhY=(String& ppszName);
    public double rBY=(String& ppszName);
    public double rxY=(String& ppszName);
    public void ZxU=();
    public piY= sBY=(string pszGeogName, string pszDatumName, string pszSpheroidName, double dfSemiMajor, double dfInvFlattening, string pszPMName, double dfPMOffset, string pszAngularUnits, double dfConvertToRadians);
    public piY= txY=(string pszParmName, double dfValue);
    public double uRY=(string pszName, double dfDefaultValue, piY=& pnErr);
    public double uRY=(string pszName, double dfDefaultValue);
    public piY= uxY=(string pszName, double dfValue);
    public static int 7hY=(string pszParameterName);
    public piY= ryc=(string pszName);
    public piY= thY=(string pszProjection);
}
internal static class GRU=.PSM= : object {
    public static double PiM=(MCM= rectangle);
    public static double PyM=(MCM= rectangle);
    public static double QCM=(MCM= rectangle);
    public static double QSM=(MCM= rectangle);
    public static double QiM=(MCM= rectangle);
    public static MCM= QyM=(MCM= rectangle);
    public static MCM= RCM=(MCM= rectangle);
    public static MCM= RSM=(MCM= rectangle);
    public static MCM= RiM=(MCM= rectangle);
}
internal enum GRU=.pSs= : Enum {
    public int value__;
    public static pSs= pis=;
    public static pSs= pys=;
    public static pSs= qCs=;
}
internal class GRU=.px8= : sR8= {
    public px8=(rR8= page);
    internal virtual int qB8=(ArrayList& al);
    internal virtual int qB8=(ArrayList& al, double resolution, int simplifyPixelBufferSize, Collection`1<RectangleShape> smallBoxes);
    internal virtual int vx4=(ACA= rt, ArrayList& al);
    internal virtual int qR8=(ACA= rt, ArrayList& al);
    internal virtual int qh8=(ACA= rt, ArrayList& al);
    internal virtual int qh8=(ACA= rt, ArrayList& al, double resolution, int simplifyPixelBufferSize, Collection`1<RectangleShape> smallBoxes);
    internal virtual bool fR8=(5B8= rec, sR8=[]& nodeList);
    internal virtual bool bx8=(5B8= insertRec, sR8=[]& nodeList);
    internal virtual bool qx8=(5B8= delRec, Int32& idx, px8=& leafToDel);
    internal virtual void rB8=(5B8= delRec, Collection`1<LeafRecordWrapper> leaves, IdsEngine idsEngine);
}
internal class GRU=.Pxk= : iBo= {
    internal Pxk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.QBk= : iBo= {
    internal QBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.QCo= : 7So= {
    private static int 8CQ=;
    private static int 8SQ=;
    private static int 8iQ=;
    private static int 8yQ=;
    private tig= QSo=;
    public tig= Qyo= { get; }
    public int wSU= { get; public set; }
    public His= xCU= { get; public set; }
    public QCo=(OCc= poDefnIn);
    public tig= Qio=();
    public virtual oCg= Hig=();
    public virtual int Hyg=(Vyk= poMapFile);
    public virtual hSg= ICg=(OCc= poNewDefn);
    public double RCo=();
    public double RSo=();
    public virtual int ISg=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iig=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iyg=(5yU= fp);
    public virtual int JCg=(5yU= fp);
    public virtual string Nic=();
    public virtual void JSg=(Stream fsOut);
    public virtual int vyU=();
    public virtual void wCU=(int value);
    public virtual His= wiU=();
    public virtual void wyU=(His= value);
    public virtual int xSU=();
    public virtual His= xiU=();
    public virtual short xyU=();
    public virtual short yCU=();
    public virtual int ySU=();
    public virtual void yiU=(short val);
    public virtual void yyU=(short val);
    public virtual void zCU=(int clr);
    public virtual string zSU=(double dfAngle);
    public virtual void ziU=(string pszStyleString);
    public virtual void zyU=(Stream fpOut);
}
internal interface GRU=.qCU= {
    public Oyo= qyU= { get; public set; }
    public int riU= { get; public set; }
    public abstract virtual int ryU=();
    public abstract virtual Oyo= sCU=();
    public abstract virtual byte sSU=();
    public abstract virtual double siU=();
    public abstract virtual int syU=();
    public abstract virtual byte tCU=();
    public abstract virtual int tSU=();
    public abstract virtual string tiU=();
    public abstract virtual Oyo= qSU=();
    public abstract virtual void qiU=(Oyo= value);
    public abstract virtual void rSU=(int value);
    public abstract virtual int rCU=();
    public abstract virtual void tyU=(byte val);
    public abstract virtual void uCU=(double val);
    public abstract virtual void uSU=(int val);
    public abstract virtual void uiU=(byte val);
    public abstract virtual void uyU=(int clr);
    public abstract virtual void vCU=(string pszStyleString);
    public abstract virtual void vSU=(Stream fpOut);
}
internal class GRU=.qCw= : object {
    [CompilerGeneratedAttribute]
private bool qSw=;
    [CompilerGeneratedAttribute]
private Vertex nCw=;
    public bool rCw= { get; public set; }
    public Vertex oSw= { get; public set; }
    public qCw=(double x, double y);
    public qCw=(Vertex vertex);
    [CompilerGeneratedAttribute]
public void qyw=(bool value);
    [CompilerGeneratedAttribute]
public bool qiw=();
    [CompilerGeneratedAttribute]
public Vertex nyw=();
    [CompilerGeneratedAttribute]
public void oCw=(Vertex value);
}
internal enum GRU=.qCY= : Enum {
    public int value__;
    public static qCY= qSY=;
    public static qCY= qiY=;
}
internal class GRU=.QRg= : object {
    internal iBo= Qhg=(string projID, string desc, Dictionary`2<string, string> pj_List);
}
internal class GRU=.QRk= : iBo= {
    internal Double[] 8Rg=;
    internal double Qhk=;
    internal double fxc=;
    internal double shc=;
    internal double sxc=;
    internal QRk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal static class GRU=.QRU= : object {
    public static SKBitmap QhU=(Stream stream);
    public static SKBitmap QhU=(Byte[] bytes);
    public static SKBitmap QhU=(string pathFilename);
    public static SKBitmap QhU=(int width, int height);
    public static SKBitmap QhU=(int width, int height, GeoColorType colorType, GeoAlphaType alphaType);
    public static int QxU=(object image);
    public static int RBU=(object image);
    public static void RRU=(object image, float opacityFactor);
    public static Stream RhU=(object image, GeoImageFormat imageFormat, int quality);
    public static Byte[] RxU=(object image, GeoImageFormat imageFormat, int quality);
    public static void SBU=(object image, string fileName, GeoImageFormat imageFormat, int quality);
    public static void SBU=(object image, Stream stream, GeoImageFormat imageFormat, int quality);
    public static SKBitmap SRU=(object image, int width, int height);
    public static SKBitmap ShU=(object image, DrawingRectangle srcRect, bool extendCanvasIfCutRectLargerThanImage);
    public static void SxU=(object destImage, GeoImage srcImage, float pointX, float pointY);
    public static GeoImage PRU=(GeoImage image, bool isGrayscale, bool isNegative, float transparency, float redTranslation, float greenTranslation, float blueTranslation);
    public static GeoImage PhU=(GeoImage image, Dictionary`2<GeoColor, GeoColor> colorMappings);
    public static void TBU=(object image, GeoColor[] pixels);
    public static IntPtr TRU=(object image);
    private static SKData ThU=(SKBitmap bitmap, GeoImageFormat imageFormat, int quality);
    private static SKEncodedImageFormat TxU=(GeoImageFormat imageFormat);
    private static Single[][] UBU=(bool isGrayscale, bool isNegative, float transparency, float redTranslation, float greenTranslation, float blueTranslation);
    private static Single[][] URU=(float transparency);
    private static Single[][] UhU=(float transparency);
    private static Single[][] UxU=(float redTranslation, float greenTranslation, float blueTranslation, float transparency);
}
internal enum GRU=.qSs= : Enum {
    public int value__;
    public static qSs= BBs=;
    public static qSs= qis=;
    public static qSs= qys=;
    public static qSs= rCs=;
    public static qSs= rSs=;
}
internal enum GRU=.Qxg= : Enum {
    public int value__;
    public static Qxg= RBg=;
    public static Qxg= RRg=;
    public static Qxg= Rhg=;
    public static Qxg= Rxg=;
    public static Qxg= SBg=;
}
internal class GRU=.qxk= : iBo= {
    internal qxk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Qxk= : iBo= {
    internal double RBk=;
    internal Qxk=(string id, string desc);
    private void 8xg=();
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Qxo= : iBo= {
    internal double Lhk=;
    internal Qxo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.qxw= : object {
    protected static int rBw=;
    protected WkbByteOrder rRw=;
    public qxw=(WkbByteOrder encodingType);
    public virtual Byte[] rhw=(BaseShape geometry);
    public virtual void rhw=(BaseShape geometry, Stream stream);
    protected void rhw=(BaseShape geometry, BinaryWriter writer);
    protected void rxw=(BinaryWriter writer);
    protected void rhw=(Vertex coordinate, BinaryWriter writer);
    protected void rhw=(PointShape point, BinaryWriter writer);
    protected void rhw=(LineShape lineString, BinaryWriter writer);
    protected void rhw=(RingShape ring, BinaryWriter writer);
    protected void rhw=(PolygonShape polygon, BinaryWriter writer);
    protected void rhw=(MultipointShape multiPoint, BinaryWriter writer);
    protected void rhw=(MultilineShape multiLineString, BinaryWriter writer);
    protected void rhw=(MultipolygonShape multiPolygon, BinaryWriter writer);
    protected void rhw=(GeometryCollectionShape geomCollection, BinaryWriter writer);
    protected Byte[] 6xM=(BaseShape geometry);
    protected virtual int sBw=(BaseShape geometry);
    protected int sBw=(GeometryCollectionShape geometry);
    protected int sBw=(MultipolygonShape geometry);
    protected int sBw=(MultilineShape geometry);
    protected int sBw=(MultipointShape geometry);
    protected int sBw=(PolygonShape geometry);
    protected int sBw=(LineShape geometry);
    protected int sBw=(PointShape geometry);
    private static int sRw=(PolygonShape polygon);
    [CompilerGeneratedAttribute]
private int shw=(BaseShape geom);
    [CompilerGeneratedAttribute]
private int sxw=(PolygonShape geom);
    [CompilerGeneratedAttribute]
private int tBw=(LineShape geom);
    [CompilerGeneratedAttribute]
private int tRw=(PointShape geom);
}
internal enum GRU=.qyY= : Enum {
    public UInt32 value__;
    public static qyY= rCY=;
    public static qyY= rSY=;
    public static qyY= riY=;
    public static qyY= ryY=;
    public static qyY= sCY=;
    public static qyY= sSY=;
    public static qyY= siY=;
    public static qyY= syY=;
    public static qyY= tCY=;
    public static qyY= tSY=;
    public static qyY= tiY=;
    public static qyY= tyY=;
    public static qyY= uCY=;
    public static qyY= uSY=;
    public static qyY= uiY=;
    public static qyY= uyY=;
    public static qyY= vCY=;
}
internal class GRU=.rBk= : iBo= {
    internal rBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.RBo= : iBo= {
    internal double RRo=;
    internal RBo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.RC8= : object {
    [CompilerGeneratedAttribute]
private string RS8=;
    [CompilerGeneratedAttribute]
private PointShape Ri8=;
    [CompilerGeneratedAttribute]
private Ny8= Ry8=;
    public string Si8= { get; public set; }
    public PointShape TS8= { get; public set; }
    public Ny8= UC8= { get; public set; }
    [CompilerGeneratedAttribute]
public string SC8=();
    [CompilerGeneratedAttribute]
public void SS8=(string value);
    [CompilerGeneratedAttribute]
public PointShape Sy8=();
    [CompilerGeneratedAttribute]
public void TC8=(PointShape value);
    [CompilerGeneratedAttribute]
public Ny8= Ti8=();
    [CompilerGeneratedAttribute]
public void Ty8=(Ny8= value);
}
internal class GRU=.RCA= : ValueType {
    public ushort RSA=;
    public ushort RiA=;
    public bool oBw=(BinaryReader r);
    public bool rhw=(BinaryWriter w);
    public virtual string ToString();
}
internal class GRU=.rhk= : iBo= {
    internal rhk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Rhk= : iBo= {
    internal double fxc=;
    internal double Rxk=;
    internal double SBk=;
    internal double SRk=;
    internal double Shk=;
    internal double Sxk=;
    internal Rhk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private int TBk=(vhg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class GRU=.Rho= : iBo= {
    internal double fxc=;
    internal double Rxk=;
    internal double SBk=;
    internal double SRk=;
    internal double Shk=;
    internal double Sxk=;
    internal Rho=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private int TBk=(vhg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class GRU=.Ri4= : object {
    [CompilerGeneratedAttribute]
private int Ry4=;
    [CompilerGeneratedAttribute]
private int SC4=;
    public int Sy4= { get; public set; }
    public int Ti4= { get; public set; }
    public Ri4=(int x, int y);
    [CompilerGeneratedAttribute]
public int SS4=();
    [CompilerGeneratedAttribute]
public void Si4=(int value);
    [CompilerGeneratedAttribute]
public int TC4=();
    [CompilerGeneratedAttribute]
public void TS4=(int value);
    public virtual string ToString();
}
internal class GRU=.Ric= : object {
    public bool Ryc=;
    public int zRU=;
    public double SCc=;
    public string SSc=;
    public List`1<int> Sic=;
    public List`1<double> Syc=;
    public List`1<string> TCc=;
    public List`1<byte> TSc=;
    public Tyc= Tic=;
    public object Hhc=();
}
[DefaultMemberAttribute("Item")]
internal class GRU=.riE= : object {
    private IDictionary`2<TKey, TValue> ryE=;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public riE=(IDictionary`2<TKey, TValue> underlyingDictionary);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class GRU=.rig= : object {
    protected int ryg=;
    protected 3Cg= sCg=;
    private static 3Cg= sSg=;
    public int nyU= { get; public set; }
    public 3Cg= oiU= { get; public set; }
    private static rig=();
    public virtual int oyU=();
    public virtual 3Cg= pCU=();
    public virtual string pSU=();
    public virtual void piU=(string pszName);
    public virtual void pyU=(Stream fpOut);
    public virtual int nSU=();
    public virtual void niU=(int value);
    public virtual 3Cg= oCU=();
    public virtual void oSU=(3Cg= value);
}
internal class GRU=.Rig= : QCo= {
    protected byte Ryg=;
    public byte SCg=;
    private static int 8CQ=;
    private static int 8SQ=;
    private static int 8iQ=;
    private static int 8yQ=;
    private rig= SSg=;
    public int nyU= { get; public set; }
    public 3Cg= oiU= { get; public set; }
    public Rig=(OCc= poDefnIn);
    public virtual oCg= Hig=();
    public virtual hSg= ICg=(OCc= poNewDefn);
    public virtual int ISg=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iig=(Vyk= poMapFile, BSo= poObjHdr, bool bCoordBlockDataOnly, Mik=& ppoCoordBlock);
    public virtual int Iyg=(5yU= fp);
    public virtual int JCg=(5yU= fp);
    public virtual string Nic=();
    public byte Sig=();
    public void Syg=(byte nStyle);
    public virtual int nSU=();
    public virtual void niU=(int value);
    public virtual 3Cg= oCU=();
    public virtual void oSU=(3Cg= value);
    public virtual int oyU=();
    public virtual 3Cg= pCU=();
    public virtual string pSU=();
    public virtual void piU=(string pszName);
    public virtual void pyU=(Stream fpOut);
}
internal class GRU=.Rio= : PointBaseStyle {
    private static int Ryo=;
    private static int SCo=;
    private static int SSo=;
    private static int Sio=;
    private static int Syo=;
    private static int IxU=;
    private static int JRU=;
    private static int JhU=;
    private static int JxU=;
    private static int JBU=;
    private static double TCo=;
    private static int KhU=;
    private static int KBU=;
    private static int TSo=;
    private static int Tio=;
    private static int Tyo=;
    [ObfuscationAttribute]
private int symbolNumber;
    [ObfuscationAttribute]
private GeoBrush characterBrush;
    [ObfuscationAttribute]
private GeoFont characterFont;
    [ObfuscationAttribute]
private int characterIndex;
    [ObfuscationAttribute]
private GeoImage image;
    [ObfuscationAttribute]
private double imageScale;
    [ObfuscationAttribute]
private PointType pointType;
    [ObfuscationAttribute]
private Dictionary`2<float, GeoFont> wingdingsFontCache;
    public int Uio= { get; public set; }
    public Rio=(GeoImage image, GeoFont characterFont, int characterIndex, GeoSolidBrush characterSolidBrush, PointType pointType, int symbolNumber, GeoSolidBrush symbolSolidBrush, GeoPen symbolPen, int symbolSize);
    public int UCo=();
    public void USo=(int value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void Uyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void VCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void VSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void Vio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void Vyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void WCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, int pixelOffset);
    private GeoFont WSo=();
    private void Wio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void Wyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, int pixelOffset);
    private void XCo=(PointShape point, GeoCanvas canvas);
    private int XSo=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, int pixelOffset);
    private int Xio=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private static int ORU=(Byte[] wkb, int startIndex, byte byteOrder);
    private void Xyo=(int indexOfCharacter, Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void YCo=(int indexOfCharacter, PointShape point, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void YSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen);
    private int Yio=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen);
    private void Yyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void ZCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, int pixelOffset);
    private void ZSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private int Zio=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private int Zyo=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, int pixelOffset);
    private static double OhU=(Byte[] wkb, int startIndex, byte byteOrder);
    private bool aCo=(double screenX, double screenY, float canvasWidth, float canvasHeight);
    private static void gB0=(Byte[] sourceArray, Byte[] destinateArray, long destinateIndex);
    private void aSo=(Feature feature, GeoCanvas canvas);
    private void aio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float widthScale, float heightScale);
    private void ayo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void bCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void bSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, ScreenPointF[] points);
    private void bio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, ScreenPointF[] points);
    private void byo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void cCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void cSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void cio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void cyo=(String[] pointsCollection, Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void dCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void dSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void dio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void dyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void eCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void eSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void eio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void eyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void fCo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void fSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void fio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
    private void fyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
}
internal enum GRU=.ris= : Enum {
    public int value__;
    public static ris= rys=;
    public static ris= sCs=;
    public static ris= sSs=;
    public static ris= sis=;
    public static ris= sys=;
    public static ris= tCs=;
}
internal class GRU=.rR8= : dB8= {
    private static int rh8=;
    public rR8=(RtreeFile rtFile, UInt32 pageNo, Gist_Ext_Id extId);
    public rR8=(RtreeFile rtFile, Gist_Ext_Id extId);
    internal virtual 5B8= cR8=();
    public virtual 5B8= jB8=(int idx);
    public virtual 5B8= iR8=();
    public virtual 5B8= ih8=();
    internal virtual bool fR8=(5B8= rec);
    private bool rx8=();
    internal bool sB8=(5B8= rec);
    internal virtual void fh8=(int idx);
    internal virtual int ch8=();
    public virtual ACA= jh8=();
    public virtual string jR8=();
}
internal class GRU=.rRk= : iBo= {
    internal Double[] 8Rg=;
    internal double Qhk=;
    internal double fxc=;
    internal double shc=;
    internal double sxc=;
    internal rRk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.RRk= : iBo= {
    internal double 7xg=;
    internal double 8Bg=;
    internal double fxc=;
    internal double 7hg=;
    internal double 7Rg=;
    internal double 6hg=;
    internal Double[] 8Rg=;
    internal int 8hg=;
    internal RRk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.rRs= : oRs= {
    internal static UInt32 rhs=;
    internal static UInt32 rxs=;
    internal static UInt32 sBs=;
    internal static UInt32 sRs=;
    internal static UInt32 shs=;
    internal static UInt32 sxs=;
    internal static UInt32 tBs=;
    internal static UInt32 tRs=;
    internal static UInt32 ths=;
    internal static UInt32 txs=;
    internal static UInt32 uBs=;
    internal static double WhY=;
    internal static double uRs=;
    internal static double uhs=;
    internal static double uxs=;
    internal static double vBs=;
    internal static double vRs=;
    private double vhs=;
    private double vxs=;
    private double wBs=;
    private double wRs=;
    private double whs=;
    private double wxs=;
    private double xBs=;
    private double xRs=;
    private double xhs=;
    private double xxs=;
    private double yBs=;
    private double yRs=;
    private double yhs=;
    private double yxs=;
    private double zBs=;
    private double zRs=;
    public rRs=(double originLatitude, double centralMeridian, double falseEasting, double falseNorthing, double Scale);
    private double zhs=(double Latitude);
    private double zxs=(double Latitude);
    private double 0Bs=(double Latitude);
    private double 0Rs=(double Latitude);
    public virtual long oxs=();
    public bool 0hs=(double Origin_Latitude, double Central_Meridian, double False_Easting, double False_Northing, double Scale);
    internal long 0xs=(double a, double f, double Origin_Latitude, double Central_Meridian, double False_Easting, double False_Northing, double Scale_Factor);
    public void 1Bs=(Double& Origin_Latitude, Double& Central_Meridian, Double& False_Easting, Double& False_Northing, Double& Scale_Factor);
    internal void 1Rs=(Double& a, Double& f, Double& Origin_Latitude, Double& Central_Meridian, Double& False_Easting, Double& False_Northing, Double& Scale_Factor);
    public bool 1hs=(double Latitude, double Longitude, Double& Easting, Double& Northing);
    internal long 1xs=(double Latitude, double Longitude, Double& Easting, Double& Northing);
    public bool 2Bs=(pBs= trmct, Double& Latitude, Double& Longitude);
    public bool 2Bs=(double Easting, double Northing, Double& Latitude, Double& Longitude);
    internal long 2Rs=(double Easting, double Northing, Double& Latitude, Double& Longitude);
}
internal class GRU=.rSw= : object {
    private int riw=;
    private byte ryw=;
    [CompilerGeneratedAttribute]
private List`1<byte> sCw=;
    public List`1<byte> syw= { get; private set; }
    [CompilerGeneratedAttribute]
private void siw=(List`1<byte> value);
    [CompilerGeneratedAttribute]
public List`1<byte> sSw=();
    public void tCw=(int input);
    public void tSw=();
}
internal class GRU=.rxg= : object {
    private string sBg=;
    private URc= sRg=;
    private Stream shg=;
    internal URc= tRg= { get; internal set; }
    internal rxg=(string name);
    internal rxg=(Stream fs);
    private void thg=(string name);
    internal URc= sxg=();
    internal void tBg=(URc= value);
    internal URc= txg=();
    private int uBg=(object obj);
    internal bool uRg=(URc= ct);
    public sealed virtual void Dispose();
}
internal class GRU=.rxk= : iBo= {
    internal double shc=;
    internal double sxc=;
    internal double tRc=;
    internal int Txk=;
    internal rxk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Rxo= : iBo= {
    private double SBo=;
    private double 8xk=;
    private Double[] 8Rg=;
    internal Rxo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= DRk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lhg= Chk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.ryI= : object {
    private int sCI=;
    public KiM= sSI=(MCM= destRect, KiM= enterDirection, double enterValue);
    private static int siI=(MCM= diffValueRect);
    private KiM= syI=(MCM= destRect, double enterValue);
    private KiM= tCI=(MCM= destRect, double enterValue);
    private KiM= tSI=(MCM= destRect, double enterValue);
    private KiM= tiI=(MCM= destRect, double enterValue);
    private KiM= tyI=(MCM= destRect, KiM= enterDirection, double enterValue);
    private KiM= uCI=(MCM= destRect, KiM= enterDirection, double enterValue);
    private KiM= uSI=(MCM= destRect, KiM= enterDirection, double enterValue);
    private KiM= uiI=(MCM= destRect, KiM= enterDirection, double enterValue);
    private KiM= uyI=(MCM= destRect, KiM= enterDirection, double enterValue);
    private static bool vCI=(KiM= enterDir, KiM= exitDir);
    private static KiM= vSI=(KiM= enterDirection);
}
internal class GRU=.RyM= : FilterCondition {
    private bool SCM=;
    internal RyM=(string columnName, bool operation);
    internal virtual bool SSM=(KeyValuePair`2<string, string> v);
    internal virtual bool SSM=(Feature feature);
}
internal static class GRU=.ryQ= : object {
    public static AiU= sCQ=;
    public static bool sSQ=;
    public static Stream siQ=;
    public static StackTrace syQ=;
    public static StackFrame tCQ=;
    private static ryQ=();
    public static void tSQ=(miQ= eErrClass, int nError, string pszErrorMsg);
    public static void tiQ=(miQ= eErrClass, int nError, string pszErrorMsg);
    public static AiU= tyQ=(AiU= pfnErrorHandlerNew);
    public static void uCQ=(AiU= pfnErrorHandlerNew);
    public static void uSQ=();
    public static wiQ= uiQ=();
    public static void uyQ=(miQ= eErrClass, int err_no, string fmt, Object[] valist);
    private static void vCQ=(miQ= eErrClass, int err_no, string fmt, Object[] valist);
    public static void vSQ=(string pszCategory, string pszFormat, Object[] list);
    public static void viQ=();
    public static int vyQ=();
    public static miQ= wCQ=();
    public static void wSQ=(string pszExpression, string pszFile, int iLine);
}
internal enum GRU=.Rys= : Enum {
    public int value__;
    public static Rys= SCs=;
    public static Rys= SSs=;
    public static Rys= Sis=;
}
internal class GRU=.sBk= : iBo= {
    internal sBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    private double Pxc=(double sinphi, double cosphi, double es, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= DRk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lhg= Chk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private double sRk=(double phi, double sinphi, double e, Int32& pj_Error);
    private double QRc=(double ts, double e, Int32& pj_Error);
}
internal class GRU=.SC0= : object {
    [CompilerGeneratedAttribute]
private double SS0=;
    [CompilerGeneratedAttribute]
private int Si0=;
    [CompilerGeneratedAttribute]
private int Sy0=;
    public double Ti0= { get; public set; }
    public int US0= { get; public set; }
    public int VC0= { get; public set; }
    public SC0=(double splitBaseNumber, int subdivisionBaseNumber, int rTreeMaxNode);
    [CompilerGeneratedAttribute]
public void TS0=(double value);
    [CompilerGeneratedAttribute]
public double TC0=();
    [CompilerGeneratedAttribute]
public void UC0=(int value);
    [CompilerGeneratedAttribute]
public int Ty0=();
    [CompilerGeneratedAttribute]
public void Uy0=(int value);
    [CompilerGeneratedAttribute]
public int Ui0=();
}
internal class GRU=.sCc= : object {
    public static string 7hU=;
    public static string /BU=;
    public static string 7xU=;
    public static string 8RU=;
    public static string 9RU=;
    public static string 9xU=;
    public static string BxY=;
    public static string JRY=;
    public static string DBY=;
    public static string /xU=;
    public static string KBY=;
    public static string CBY=;
    public static string DxY=;
    public static string IhY=;
    public static string IxY=;
    public static string FRY=;
    public static string JBY=;
    public static string ChY=;
    public static string CRY=;
    public static string HhY=;
    public static string PxY=;
    public static string DhY=;
    public static string FhY=;
    public static string FxY=;
    public static string GBY=;
    public static string GRY=;
    public static string AxY=;
    public static string GxY=;
    public static string /RU=;
    public static string /hU=;
    public static string BhY=;
    public static string BRY=;
    public static string MBY=;
    public static string BBY=;
    public static string ExY=;
    public static string FBY=;
    public static string ARY=;
    public static string AhY=;
    public static string EhY=;
    public static string RBY=;
    public static string RRY=;
    public static string RhY=;
    public static string RxY=;
    public static string SBY=;
    public static string SRY=;
    public static string ShY=;
    public static string SxY=;
    public static string TBY=;
    public static string TRY=;
    public static string ThY=;
    public static string TxY=;
    public static string UBY=;
    public static string URY=;
    public static string ERY=;
    public static string EBY=;
    private static sCc=();
}
[DefaultMemberAttribute("Item")]
internal abstract class GRU=.sCE= : object {
    private static char sSE=;
    private IList`1<string> nCE=;
    public string Item { get; public set; }
    public IList`1<string> syE= { get; }
    public bool IsReadOnly { get; }
    public int Count { get; }
    protected sCE=(bool readOnly, IEnumerable`1<string> values);
    internal sCE=(IList`1<string> values);
    public virtual string get_Item(int index);
    public virtual void set_Item(int index, string value);
    public IList`1<string> siE=();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual int get_Count();
    public string dSE=(int index);
    public virtual void Clear();
    public sealed virtual bool Contains(string value);
    public sealed virtual int IndexOf(string value);
    public virtual void Add(string value);
    public virtual void Insert(int index, string value);
    public virtual bool Remove(string value);
    public virtual void RemoveAt(int index);
    public sealed virtual void CopyTo(String[] array, int arrayIndex);
    public sealed virtual bool Equals(sCE= other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual string ToString();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class GRU=.shk= : iBo= {
    internal shk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.si0= : object {
    [CompilerGeneratedAttribute]
private string sy0=;
    [CompilerGeneratedAttribute]
private StringBuilder tC0=;
    [CompilerGeneratedAttribute]
private ushort tS0=;
    [CompilerGeneratedAttribute]
private int ti0=;
    public string uS0= { get; private set; }
    public StringBuilder vC0= { get; private set; }
    public ushort vy0= { get; private set; }
    public int wi0= { get; private set; }
    [CompilerGeneratedAttribute]
private void uC0=(string value);
    [CompilerGeneratedAttribute]
public string ty0=();
    [CompilerGeneratedAttribute]
private void uy0=(StringBuilder value);
    [CompilerGeneratedAttribute]
public StringBuilder ui0=();
    [CompilerGeneratedAttribute]
private void vi0=(ushort value);
    [CompilerGeneratedAttribute]
public ushort vS0=();
    [CompilerGeneratedAttribute]
public int wC0=();
    [CompilerGeneratedAttribute]
private void wS0=(int value);
    public void fC0=(StringBuilder name, string type);
    private StringBuilder wy0=(StringBuilder Name);
}
internal class GRU=.sig= : object {
    protected int syg=;
    protected Oyo= tCg=;
    private static Oyo= tSg=;
    public Oyo= qyU= { get; public set; }
    public int riU= { get; public set; }
    private static sig=();
    public virtual int ryU=();
    public virtual Oyo= sCU=();
    public virtual byte sSU=();
    public virtual double siU=();
    public virtual int syU=();
    public virtual string tiU=();
    public virtual byte tCU=();
    public virtual int tSU=();
    public virtual void tyU=(byte val);
    public virtual void uCU=(double val);
    public virtual void uSU=(int val);
    public virtual void uiU=(byte val);
    public virtual void uyU=(int clr);
    public virtual void vCU=(string pszStyleString);
    public virtual void vSU=(Stream fpOut);
    public sealed virtual Oyo= qSU=();
    public sealed virtual void qiU=(Oyo= value);
    public sealed virtual int rCU=();
    public sealed virtual void rSU=(int value);
}
internal class GRU=.sR8= : object {
    protected dB8= sh8=;
    protected int dx8=;
    internal sR8=(dB8= page);
    internal static sR8= sx8=(dB8= dtPage);
    internal Gist_Ext_Id tB8=();
    internal bool tR8=();
    public sR8= th8=(int index);
    internal ushort gB8=();
    internal void gR8=(ushort level);
    public UInt32 tx8=();
    internal void gh8=(UInt32 pageNo);
    internal 5B8= iR8=();
    internal 5B8= ih8=();
    internal bool ix8=();
    public int hB8=();
    internal int uB8=();
    internal ACA= jh8=();
    internal bool uR8=(ACA= rt);
    internal bool uh8=(ACA= rt);
    internal bool ux8=(ACA= rt);
    internal virtual int qB8=(ArrayList& al);
    internal virtual int qB8=(ArrayList& al, double resolution, int simplifyPixelBufferSize, Collection`1<RectangleShape> smallBoxes);
    internal ArrayList vB8=(KiA= p, sR8= nRoot, int nMax);
    private void vB8=(sR8= node, KiA= p, double nearest, int nMax, ArrayList& nodeStack, ArrayList& candidateStack, ArrayList& resuLbStack);
    private static void vR8=(ArrayList& nodeStack, sR8= node, KiA= p);
    private static void vh8=(ArrayList& candidateStack, ArrayList& resuLbStack, int nMax, double nearest);
    private static void vx8=(sR8= node, KiA= p, ArrayList& candidateStack);
    internal virtual int vx4=(ACA= rt, ArrayList& al);
    internal virtual int qR8=(ACA= rt, ArrayList& al);
    internal virtual int qh8=(ACA= rt, ArrayList& al);
    internal virtual int qh8=(ACA= rt, ArrayList& al, double resolution, int simplifyPixelBufferSize, Collection`1<RectangleShape> smallBoxes);
    internal string jR8=();
    public 5B8= jB8=(int idx);
    public bool wB8=();
    public bool wR8=();
    internal bool wh8=();
    internal ArrayList[] wx8=(ArrayList rectList);
    internal static void xB8=(ACA=[] rectArr, ArrayList& spRectList, ArrayList& leftRectList, ArrayList& rightRectList, ACA=& mbr1, ACA=& mbr2);
    internal static void xR8=(ArrayList& spRectList, ArrayList& rectList);
    internal static Int32[] xh8=(ACA=[] rtArr);
    internal static void xx8=(sR8= n, int index, bool bSplitted);
    internal static bool cx8=(sR8= n, kB8= ent, int index);
    internal int yB8=(ACA= rt);
    internal virtual bool fR8=(5B8= rec, sR8=[]& nodelist);
    internal bool yR8=(5B8= rec, sR8=[]& nodeList);
    internal bool yh8=(5B8= insertRec, sR8=[] nodeListIn, sR8=[]& nodeListOut);
    private UInt32 jx8=();
    internal virtual bool bx8=(5B8= rec, sR8=[]& nodeList);
    internal bool yx8=(sR8=[] a);
    internal void zB8=(sR8= node);
    internal bool zR8=(5B8= delRec);
    internal void zR8=(5B8= delRec, IEnumerable`1<string> ids, IdsEngine idsEngine);
    internal virtual bool qx8=(5B8= rec, Int32& idx, px8=& leafToDel);
    internal virtual void rB8=(5B8= rec, Collection`1<LeafRecordWrapper> leaves, IdsEngine idsEngine);
    private static void zh8=(5B8= rec, sR8= subNode, Collection`1<LeafRecordWrapper> leaves, IdsEngine idsEngine);
    private static void zx8=(5B8= rec, sR8= subNode, Collection`1<LeafRecordWrapper> leaves, IdsEngine idsEngine);
    private static bool 0B8=(5B8= rec, Int32& idx, px8=& leafToDel, sR8= subNode);
    private static bool 0R8=(5B8= rec, Int32& idx, px8=& leafToDel, sR8= subNode);
    internal void fh8=(int idx);
}
internal class GRU=.SRg= : object {
    internal double Shg=;
    internal double Sxg=;
    internal double TBg=;
    internal int TRg=;
}
internal class GRU=.SRo= : iBo= {
    internal double Sho=;
    internal double Sxo=;
    internal double TBo=;
    internal double TRo=;
    internal double Tho=;
    internal double Txo=;
    internal double UBo=;
    internal double URo=;
    internal double Uho=;
    internal double Uxo=;
    internal double VBo=;
    internal double VRo=;
    internal double Vho=;
    internal double phk=;
    internal double pRk=;
    internal double Vxo=;
    internal double Yhk=;
    internal SRo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.sSc= : object {
    public string sic=;
    public int syc=;
    public ziY= WSc=;
    public sSc=(int inParam, string pszInput, int bGeo, ziY= ogrType);
}
internal class GRU=.sxk= : iBo= {
    internal Thc=[] Fxk=;
    internal double GBk=;
    internal double GRk=;
    internal int fxc=;
    internal sxk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private Thc= Ghk=(Thc= z, Thc=[] C, int n, Thc= der);
    private Thc= Gxk=(Thc= z, Thc=[] C, int n);
}
internal class GRU=.sy4= : object {
    private BinaryReader myE=;
    private ti4= tC4=;
    private Stream hC4=;
    private Encoding ER8=;
    public sy4=(Stream stream, ti4= header, Encoding encoding);
    public string tS4=(int offset, yyw= encryptor);
}
internal enum GRU=.sy8= : Enum {
    public int value__;
    public static sy8= tC8=;
    public static sy8= tS8=;
    public static sy8= ti8=;
}
internal enum GRU=.Sys= : Enum {
    public int value__;
    public static Sys= TCs=;
    public static Sys= TSs=;
    public static Sys= Tis=;
}
internal class GRU=.tBk= : iBo= {
    internal double shc=;
    internal double sxc=;
    internal double tRc=;
    internal tBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private vhg= tRk=(vhg= pjConsts, double p, Int32& pj_Error);
}
internal class GRU=.tCc= : object {
    public string tSc=;
    public double tic=;
    public int tyc=;
    public int uCc=;
    public wCY= uSc=;
    public tCc=(string pszInput, double dValue, int eParam, int bGeo, wCY= ogrUnit);
}
internal enum GRU=.TCg= : Enum {
    public int value__;
    public static TCg= TSg=;
    public static TCg= Tig=;
    public static TCg= Tyg=;
}
internal class GRU=.Thc= : ValueType {
    internal double Txc=;
    internal double UBc=;
}
internal class GRU=.Thg= : ValueType {
    internal float Txg=;
    internal float UBg=;
}
internal class GRU=.thk= : iBo= {
    internal double fxc=;
    internal double Rxk=;
    internal double SBk=;
    internal double SRk=;
    internal double Shk=;
    internal double Sxk=;
    internal thk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private int TBk=(vhg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class GRU=.Thk= : iBo= {
    internal double shc=;
    internal double sxc=;
    internal double tRc=;
    internal int Txk=;
    internal Thk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
[DefaultMemberAttribute("Item")]
internal class GRU=.thw= : object {
    private int txw=;
    private Char[] uBw=;
    private int uRw=;
    private int uhw=;
    public int vRw= { get; public set; }
    public int vxw= { get; }
    public char whw= { get; public set; }
    public thw=(int capacity);
    public int uxw=();
    public void vBw=(int value);
    public int vhw=();
    protected void wxw=(int requestedLen);
    protected void xBw=(int requestedLength);
    protected void xRw=();
    public void xhw=(Char[] b, int len);
    public void xxw=(char c);
    public void xxw=(string s);
    public void xxw=(thw= s);
    public void yBw=(int i);
    public void yBw=(int i, int n);
    public int yRw=(char c);
    public void ZxU=();
    public char wBw=(int index);
    public void wRw=(int index, char value);
    public virtual string ToString();
}
internal class GRU=.ti4= : object {
    private int ty4=;
    private int uC4=;
    private int zRM=;
    public int YC0= { get; }
    public int 9i0= { get; }
    public int /S0= { get; }
    public int Xi0=();
    public int 9C0=();
    public int 9y0=();
    public void oBw=(Stream stream, int lblOffset, string password);
}
internal class GRU=.tig= : object {
    protected int tyg=;
    protected His= uCg=;
    private static His= uSg=;
    public int wSU= { get; public set; }
    public His= xCU= { get; public set; }
    private static tig=();
    public virtual int xSU=();
    public virtual His= xiU=();
    public virtual short xyU=();
    public virtual short yCU=();
    public virtual int ySU=();
    public virtual void yiU=(short val);
    public virtual void yyU=(short val);
    public virtual void zCU=(int clr);
    public virtual string zSU=(double dfAngle);
    public virtual void ziU=(string pszStyleString);
    public sealed virtual void zyU=(Stream fpOut);
    public virtual int vyU=();
    public virtual void wCU=(int value);
    public virtual His= wiU=();
    public virtual void wyU=(His= value);
}
internal class GRU=.Tik= : ValueType {
    public int Tyk=;
    public int UCk=;
    public int USk=;
    public int Uik=;
    public int Uyk=;
    public int VCk=;
    public int VSk=;
    public int Vik=;
}
internal class GRU=.tiw= : object {
    [CompilerGeneratedAttribute]
private int tyw=;
    [CompilerGeneratedAttribute]
private int uCw=;
    [CompilerGeneratedAttribute]
private byte yCM=;
    [CompilerGeneratedAttribute]
private List`1<uS4=> uSw=;
    public int vCw= { get; private set; }
    public int vyw= { get; private set; }
    public byte wiw= { get; private set; }
    public List`1<uS4=> xSw= { get; public set; }
    public tiw=(byte type, int subFileIndex, int subdivisionIndex);
    [CompilerGeneratedAttribute]
private void uyw=(int value);
    [CompilerGeneratedAttribute]
public int uiw=();
    [CompilerGeneratedAttribute]
private void viw=(int value);
    [CompilerGeneratedAttribute]
public int vSw=();
    [CompilerGeneratedAttribute]
private void wSw=(byte value);
    [CompilerGeneratedAttribute]
public byte wCw=();
    [CompilerGeneratedAttribute]
public void xCw=(List`1<uS4=> value);
    [CompilerGeneratedAttribute]
public List`1<uS4=> wyw=();
}
internal class GRU=.TRk= : iBo= {
    internal lRo= Mxk=;
    internal double NBk=;
    internal double NRk=;
    internal double Nhk=;
    internal TRk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
[ExtensionAttribute]
internal static class GRU=.tRU= : object {
    [ExtensionAttribute]
public static void thU=(IList`1<T> initial, IEnumerable`1<T> collection);
    [ExtensionAttribute]
public static BindingFlags txU=(BindingFlags bindingAttr, BindingFlags flag);
    [ExtensionAttribute]
public static Type uBU=(Type type);
    [ExtensionAttribute]
public static bool uRU=(Type type);
    [ExtensionAttribute]
public static MemberTypes uhU=(MemberInfo memberInfo);
    [ExtensionAttribute]
public static bool uxU=(Type type);
}
internal class GRU=.tSk= : ySo= {
    protected int tik=;
    protected 0Ck=[] tyk=;
    protected int Nyk=;
    protected int OCk=;
    protected int OSk=;
    protected int Oik=;
    protected Kig= FCk=;
    protected tSk= uCk=;
    protected int uSk=;
    protected tSk= uik=;
    public tSk=(ESg= eAccessMode);
    protected int uyk=(0Ck= psEntry);
    protected int vCk=(0Ck= psEntry);
    protected int vSk=();
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public virtual int CommitToFile();
    public virtual int GetBlockClass();
    public int vik=();
    public int KSk=();
    public 0Ck= vyk=(int iIndex);
    public int ECk=(int nXMin, int nYMin, int nXMax, int nYMax, int nBlockPtr, bool bAddInThisNodeOnly);
    public int wCk=();
    public void mCg=(Int32& nXMin, Int32& nYMin, Int32& nXMax, Int32& nYMax);
    public int KCk=();
    public void QSk=(Kig= poBlockMgr);
    public void wSk=(tSk= poParent);
    public void wik=(tSk= poChild, int nChildIndex);
    public int wyk=();
    public tSk= xCk=();
    public int bx8=(int nNewEntryXMin, int nNewEntryYMin, int nNewEntryXMax, int nNewEntryYMax);
    public int LCk=(int nNewEntryXMin, int nNewEntryYMin, int nNewEntryXMax, int nNewEntryYMax);
    public void xSk=(int nXMin, int nYMin, int nXMax, int nYMax, int nBlockPtr);
    public void xik=();
    public int Iik=(int nXMin, int nYMin, int nXMax, int nYMax, int nBlockPtr);
    public int xyk=(int nXMin, int nYMin, int nXMax, int nYMax);
    private int yCk=(int paraA, int paraB);
    private int ySk=(int paraA, int paraB);
    public int yik=(int nXMin, int nYMin, int nXMax, int nYMax);
    public int yyk=(int nBlockPtr, int nXMin, int nYMin, int nXMax, int nYMax);
    public int zCk=(int nBlockPtr, Int32& nXMin, Int32& nYMin, Int32& nXMax, Int32& nYMax);
    private static double zSk=(int x1, int y1, int x2, int y2);
    public static double zik=(int nNodeXMin, int nNodeYMin, int nNodeXMax, int nNodeYMax, int nEntryXMin, int nEntryYMin, int nEntryXMax, int nEntryYMax);
    public static int zyk=(0Ck=[] pasEntries, int numEntries, int nSrcCurChildIndex, int nNewEntryXMin, int nNewEntryYMin, int nNewEntryXMax, int nNewEntryYMax, Int32& nSeed1, Int32& nSeed2);
    public sealed virtual void Dispose();
}
internal enum GRU=.tSs= : Enum {
    public int value__;
    public static tSs= tis=;
}
internal enum GRU=.TSw= : Enum {
    public int value__;
    public static TSw= Tiw=;
    public static TSw= Tyw=;
}
internal class GRU=.txk= : iBo= {
    internal double fxc=;
    internal double Rxk=;
    internal double SBk=;
    internal double SRk=;
    internal double Shk=;
    internal double Sxk=;
    internal txk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private int TBk=(vhg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class GRU=.Ty4= : object {
    private BinaryReader UC4=;
    private BinaryReader US4=;
    private BinaryReader Ui4=;
    private BinaryReader Uy4=;
    private BinaryReader VC4=;
    private BinaryReader VS4=;
    private Jy0= Vi4=;
    private string Vy4=;
    private int WC4=;
    private double WS4=;
    private int Wi4=;
    private List`1<string> Wy4=;
    private FeatureLayer XC4=;
    private Collection`1<string> XS4=;
    private int LC4=;
    private double 9yw=;
    private TinyGeoFileType Ly4=;
    public TinyGeoFileType Xy4= { get; }
    public Ty4=(Bi4= tGeoParameters, SC0= parameter, string tGeoPath, int maxNode, double extentWidthLimitation);
    public TinyGeoFileType Xi4=();
    public Jy0= oSs=();
    public List`1<myw=> YC4=(jiw= ReadInfo);
    private static double YS4=(Vertex source, Vertex des);
    public List`1<myw=> phw=(jiw= ReadInfo);
    public myw= pBw=(jiw= ReadInfo);
    private void Yi4=();
    private static int Yy4=(IEnumerable`1<PolygonShape> polygons);
    public void ZC4=();
    private static void ZS4=(PointShape pointShape, BinaryWriter shapeWriter, BinaryWriter idxWriter);
    private PointShape Zi4=(int index);
    private static void Zy4=(LineShape lineshape, BinaryWriter shapeWriter, BinaryWriter idxWriter);
    private LineShape aC4=(int index);
    private static void aS4=(PolygonShape polygon, BinaryWriter shapeWriter, BinaryWriter idxWriter);
    private PolygonShape ai4=(int index);
    private void ay4=(List`1<Oy0=> savers);
    private static Collection`1<RectangleShape> bC4=(RectangleShape totalBoundingBox, double ratio);
    private static RectangleShape bS4=(double minX, double minY, double width, double height);
}
internal enum GRU=.ty8= : Enum {
    public int value__;
    public static ty8= uC8=;
    public static ty8= uS8=;
    public static ty8= ui8=;
    public static ty8= uy8=;
    public static ty8= vC8=;
    public static ty8= vS8=;
    public static ty8= vi8=;
}
internal class GRU=.Tyc= : object {
    public short UCc=;
    public byte USc=;
    public byte Uic=;
    public byte Uyc=;
    public byte VCc=;
    public byte VSc=;
    public byte Vic=;
    public object Hhc=();
}
internal class GRU=.TyI= : Exception {
    public TyI=(string message);
}
internal static class GRU=.TyM= : object {
    internal static Style jxU=(JsonElement typeElement, JsonElement paintElement, JsonElement layoutElement, int zoomLevel);
    private static AreaStyle UCM=(JsonElement paint, int zoomLevel);
    private static LineStyle USM=(JsonElement paint, int zoomLevel);
    private static TextStyle UiM=(JsonElement paint, JsonElement layout, int zoomLevel);
    private static string UyM=(JsonElement element, int zoomLevel);
    private static float VCM=(JsonElement element, int zoomLevel);
    private static Collection`1<float> VSM=(JsonElement element, int zoomLevel);
    private static T ViM=(JsonElement element, int zoomLevel, Func`3<JsonElement, int, T> parseMethod);
    private static T VyM=(JsonElement element, int zoomLevel, Func`3<JsonElement, int, T> parseMethod);
    public static GeoColor WCM=(JsonElement colorElement, JsonElement fillOpacityElement, int zoomLevel);
    private static string WSM=(JsonElement textFontElement);
}
internal enum GRU=.tys= : Enum {
    public int value__;
    public static tys= uCs=;
    public static tys= uSs=;
    public static tys= uis=;
    public static tys= uys=;
    public static tys= vCs=;
    public static tys= vSs=;
    public static tys= vis=;
}
internal enum GRU=.Tys= : Enum {
    public int value__;
    public static Tys= UCs=;
    public static Tys= USs=;
    public static Tys= Uis=;
}
internal class GRU=.uBk= : iBo= {
    internal double fxc=;
    internal double Rxk=;
    internal double SBk=;
    internal double SRk=;
    internal double Shk=;
    internal double Sxk=;
    internal uBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private int TBk=(vhg= pjConsts, Double[] del, Int32& pj_Error);
}
internal class GRU=.UBk= : iBo= {
    internal double fxc=;
    internal double BRk=;
    internal UBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.UCg= : object {
    public string USg=;
    public char Uig=;
    public byte Uyg=;
    public byte VCg=;
    public uig= VSg=;
}
internal class GRU=.UCI= : Exception {
}
internal class GRU=.uCM= : object {
    [CompilerGeneratedAttribute]
private string uSM=;
    [CompilerGeneratedAttribute]
private string uiM=;
    [CompilerGeneratedAttribute]
private string nyM=;
    [CompilerGeneratedAttribute]
private List`1<xSM=> uyM=;
    [CompilerGeneratedAttribute]
private wyM= vCM=;
    [CompilerGeneratedAttribute]
private string vSM=;
    [CompilerGeneratedAttribute]
private List`1<string> viM=;
    [CompilerGeneratedAttribute]
private string vyM=;
    [CompilerGeneratedAttribute]
private string wCM=;
    [JsonPropertyNameAttribute("id")]
[ObfuscationAttribute]
public string Id { get; public set; }
    [JsonPropertyNameAttribute("title")]
[ObfuscationAttribute]
public string Title { get; public set; }
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("description")]
public string Description { get; public set; }
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("links")]
public List`1<xSM=> Links { get; public set; }
    [JsonPropertyNameAttribute("extent")]
[ObfuscationAttribute]
public wyM= Extent { get; public set; }
    [JsonPropertyNameAttribute("itemType")]
[ObfuscationAttribute]
public string ItemType { get; public set; }
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("crs")]
public List`1<string> Crs { get; public set; }
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("storageCrs")]
public string StorageCrs { get; public set; }
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("storageCRS")]
public string DefaultCrs { get; public set; }
    public uCM=(string id, string title, string description, List`1<xSM=> links, wyM= extent, string itemType, List`1<string> crs, string storageCrs);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public List`1<xSM=> get_Links();
    [CompilerGeneratedAttribute]
public void set_Links(List`1<xSM=> value);
    [CompilerGeneratedAttribute]
public wyM= get_Extent();
    [CompilerGeneratedAttribute]
public void set_Extent(wyM= value);
    [CompilerGeneratedAttribute]
public string get_ItemType();
    [CompilerGeneratedAttribute]
public void set_ItemType(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Crs();
    [CompilerGeneratedAttribute]
public void set_Crs(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_StorageCrs();
    [CompilerGeneratedAttribute]
public void set_StorageCrs(string value);
    [CompilerGeneratedAttribute]
public string get_DefaultCrs();
    [CompilerGeneratedAttribute]
public void set_DefaultCrs(string value);
}
internal enum GRU=.UCw= : Enum {
    public int value__;
    public static UCw= dhY=;
    public static UCw= USw=;
}
internal class GRU=.uhg= : object {
    internal bool uxg=;
    internal double vBg=;
    internal int UBc=;
    internal string vRg=;
}
internal class GRU=.uhk= : iBo= {
    internal uhk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Uhk= : iBo= {
    internal Uhk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.uic= : 2Cc= {
    public sSc=[] uyc=;
    private tCc=[] vCc=;
    public virtual int jxU=();
    public string vSc=(Int32& bDefault);
    public string vic=(Int32& bDefault);
    public string vyc=(Int32& bDefault);
    public string wCc=(3SY= eParam, Int32& bValueIsNull);
}
internal enum GRU=.uig= : Enum {
    public int value__;
    public static uig= uyg=;
    public static uig= vCg=;
    public static uig= vSg=;
    public static uig= vig=;
    public static uig= vyg=;
    public static uig= wCg=;
    public static uig= wSg=;
    public static uig= wig=;
    public static uig= wyg=;
    public static uig= xCg=;
}
internal class GRU=.UiI= : Exception {
}
internal enum GRU=.Uiw= : Enum {
    public int value__;
    public static Uiw= Uyw=;
    public static Uiw= VCw=;
    public static Uiw= VSw=;
    public static Uiw= Viw=;
    public static Uiw= Vyw=;
    public static Uiw= WCw=;
    public static Uiw= WSw=;
    public static Uiw= Wiw=;
    public static Uiw= Wyw=;
    public static Uiw= XCw=;
    public static Uiw= XSw=;
    public static Uiw= Xiw=;
}
internal class GRU=.URc= : object {
    internal string dxQ=;
    internal lhg= Uhc=;
    internal lhg= Uxc=;
    internal lRg= VBc=;
    internal Thg=[] VRc=;
}
internal class GRU=.URg= : object {
    internal double Uhg=;
    internal double Uxg=;
    internal double VBg=;
    internal double VRg=;
    internal double Vhg=;
    internal double Vxg=;
}
internal class GRU=.uRk= : iBo= {
    internal uRk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.URk= : iBo= {
    internal URk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.uS4= : object {
    private int ui4=;
    private double uy4=;
    private double vC4=;
    private double vS4=;
    private double vi4=;
    public int 4iw= { get; }
    public uS4=(int childIndex, double xMin, double yMin, double xMax, double yMax);
    public int 4Cw=();
    public bool vy4=(RectangleShape range);
}
internal class GRU=.US8= : object {
    private long RSA=;
    private gy8= Ui8=;
    private Collection`1<cy8=> Uy8=;
    private Collection`1<ZC8=> VC8=;
    public long Vy8= { get; public set; }
    internal gy8= Wi8= { get; internal set; }
    internal Collection`1<cy8=> XS8= { get; internal set; }
    internal Collection`1<ZC8=> YC8= { get; internal set; }
    public long VS8=();
    public void Vi8=(long value);
    internal gy8= WC8=();
    internal void WS8=(gy8= value);
    internal Collection`1<cy8=> Wy8=();
    internal void XC8=(Collection`1<cy8=> value);
    internal Collection`1<ZC8=> Xi8=();
    internal void Xy8=(Collection`1<ZC8=> value);
}
internal class GRU=.USE= : object {
    private static giE= UiE=;
    private mSE= UyE=;
    private bool VCE=;
    private dCE=[] uBw=;
    private diE= VSE=;
    private long ViE=;
    private bool Ah4=;
    public bool WSE= { get; public set; }
    public bool XCE= { get; public set; }
    public char XyE= { get; public set; }
    public Nullable`1<char> YiE= { get; public set; }
    public diE= ZSE= { get; public set; }
    public long ZyE= { get; }
    public bool aSE= { get; }
    public IEnumerable`1<dCE=> ayE= { get; }
    public USE=(string pathFilename);
    public USE=(string pathFilename, Encoding encoding);
    public USE=(Stream stream);
    public USE=(Stream stream, Encoding encoding);
    public USE=(Stream stream, Encoding encoding, bool leaveOpen);
    public USE=(TextReader textReader);
    public USE=(TextReader textReader, bool leaveOpen);
    private static USE=();
    public bool VyE=();
    public void WCE=(bool value);
    public bool WiE=();
    public void WyE=(bool value);
    public char XSE=();
    public void XiE=(char value);
    public Nullable`1<char> YCE=();
    public void YSE=(Nullable`1<char> value);
    public diE= YyE=();
    public void ZCE=(diE= value);
    public long ZiE=();
    public bool aCE=();
    public static USE= bCE=(string csv);
    [IteratorStateMachineAttribute("GRU=.USE=/zz8=")]
public IEnumerable`1<dCE=> aiE=();
    public bool bSE=();
    public bool bSE=(bool incrementRecordNumber);
    public int biE=(int count);
    public int biE=(int count, bool incrementRecordNumber);
    public diE= byE=();
    public dCE= cCE=();
    public int cSE=(dCE=[] buffer, int offset, int count);
    public void oR8=();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void ciE=();
    private void cyE=();
}
internal class GRU=.USI= : Exception {
}
internal class GRU=.Ux0= : object {
    public virtual string rhw=(BaseShape geometry);
    public virtual void rhw=(BaseShape geometry, StringBuilder writer);
    private void VB0=(BaseShape geometry, StringBuilder writer);
    private void VR0=(Vertex coordinate, StringBuilder writer);
    private void VR0=(PointShape coordinate, StringBuilder writer);
    private void Vh0=(LineShape lineString, StringBuilder writer);
    private void Vx0=(RingShape linearRing, StringBuilder writer);
    private void WB0=(PolygonShape polygon, StringBuilder writer);
    private void WR0=(MultipointShape multipoint, StringBuilder writer);
    private void Wh0=(MultilineShape multiLineString, StringBuilder writer);
    private void Wx0=(MultipolygonShape multiPolygon, StringBuilder writer);
    private void XB0=(GeometryCollectionShape geometryCollection, StringBuilder writer);
    private void XR0=(Vertex coordinate, StringBuilder writer);
    private void XR0=(PointShape coordinate, StringBuilder writer);
    private void Xh0=(Vertex coordinate, StringBuilder writer);
    private void Xh0=(PointShape coordinate, StringBuilder writer);
    private void Xx0=(LineShape lineString, StringBuilder writer);
    private void Xx0=(RingShape lineString, StringBuilder writer);
    private void YB0=(PolygonShape polygon, StringBuilder writer);
    private void YR0=(MultipointShape multiPoint, StringBuilder writer);
    private void Yh0=(MultilineShape multiLineString, StringBuilder writer);
    private void Yx0=(MultipolygonShape multiPolygon, StringBuilder writer);
    private void ZB0=(GeometryCollectionShape geometryCollection, StringBuilder writer);
    public static IEnumerable`1<Vertex> ZR0=(BaseShape shape);
}
internal class GRU=.uxk= : iBo= {
    internal uxk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Uxk= : iBo= {
    private double Shg=;
    private double VBk=;
    private double VRk=;
    private double Vhk=;
    private double Vxk=;
    private double WBk=;
    private double ERg=;
    internal Uxk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lhg= Chk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= DRk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.UyI= : Exception {
}
internal class GRU=.Uys= : ByU= {
    protected Oyo=[] VCs=;
    protected int VSs=;
    protected int Vis=;
    protected NSg=[] Vys=;
    protected int WCs=;
    protected int WSs=;
    protected 3Cg=[] Wis=;
    protected int Wys=;
    protected int XCs=;
    protected His=[] XSs=;
    protected int Xis=;
    protected int Xys=;
    public int YCs=(Lyo= poBlock);
    public int YSs=(Lyo= poBlock);
    public Oyo= sCU=(int nIndex);
    public int Yis=(Oyo= poNewPenDef);
    public int Yys=();
    public NSg= kCU=(int nIndex);
    public int ZCs=(NSg= poNewBrushDef);
    public int ZSs=();
    public 3Cg= pCU=(int nIndex);
    public int Zis=(3Cg= poNewFontDef);
    public int Zys=();
    public His= xiU=(int nIndex);
    public int aCs=(His= poNewSymbolDef);
    public int aSs=();
    public int ais=();
}
internal class GRU=.vBk= : iBo= {
    internal double vRk=;
    internal double Ahk=;
    internal double Axk=;
    internal double Mxk=;
    internal double vhk=;
    internal double vxk=;
    internal double wBk=;
    internal double Shg=;
    internal double wRk=;
    internal double whk=;
    internal double wxk=;
    internal double xBk=;
    internal int CRk=;
    internal int xRk=;
    internal vBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.vBU= : MulticastDelegate {
    public vBU=(object object, IntPtr method);
    public virtual TResult Invoke(T target, Object[] args);
    public virtual IAsyncResult BeginInvoke(T target, Object[] args, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
internal class GRU=.VCI= : Exception {
}
internal static class GRU=.Vhc= : object {
    internal static double Vxc=;
    internal static double WBc=;
    internal static double WRc=;
    internal static double Whc=;
    internal static double Wxc=;
    internal static double XBc=;
    internal static double XRc=;
    internal static double VxY=;
    internal static double Xhc=;
    internal static double Xxc=;
    internal static double YBc=;
    internal static double YRc=;
    internal static double Yhc=;
    internal static double Yxc=;
    internal static double ZBc=;
    internal static double ZRc=;
    internal static double Zhc=;
    internal static double Zxc=;
    internal static double aBc=;
    internal static double aRc=;
    internal static double ahc=;
    internal static double axc=;
    internal static double bBc=;
    internal static double bRc=;
    internal static double bhc=;
    internal static double bxc=;
    internal static int cBc=;
    internal static int cRc=;
    internal static int chc=;
    internal static int cxc=;
    internal static int dBc=;
    internal static int dRc=;
    internal static int dhc=;
    internal static int dxc=;
    internal static int eBc=;
    internal static double eRc=;
    internal static double ehc=;
    internal static double WhY=;
    internal static double exc=;
    internal static double fBc=;
    internal static double fRc=;
    internal static double fhc=;
    internal static double fxc=;
    internal static double gBc=;
    internal static double gRc=;
    internal static double ghc=;
    internal static double gxc=;
    internal static double hBc=;
    internal static double hRc=;
    internal static double hhc=;
    internal static double hxc=;
    internal static double iBc=;
    internal static double iRc=;
    internal static double ihc=;
    internal static double ixc=;
    internal static double jBc=;
    internal static double jRc=;
    internal static double jhc=;
    internal static int jxc=;
    internal static double kBc=;
    internal static double kRc=;
    internal static double khc=;
    internal static double kxc=;
    internal static double lBc=;
    internal static double lRc=;
    internal static double lhc=;
    internal static double lxc=;
    internal static double mBc=;
    internal static int mRc=;
    internal static double mhc=;
    internal static double mxc=;
    internal static double nBc=;
    internal static double nRc=;
    internal static double nhc=;
    internal static double nxc=;
    internal static double oBc=;
    internal static double oRc=;
    internal static double ohc=;
    internal static double oxc=;
    internal static double pBc=;
    internal static double pRc=;
    internal static double phc=;
    internal static double pxc=;
    internal static double qBc=;
    internal static double qRc=;
    internal static double qhc=;
    internal static double qxc=;
    internal static double rBc=;
    internal static double rRc=;
    internal static double rhc=;
    internal static double rxc=;
    internal static double sBc=;
    internal static double sRc=;
    internal static double shc=;
    internal static double sxc=;
    internal static double tBc=;
    internal static double tRc=;
    internal static double thc=;
    internal static int txc=;
    internal static double uBc=;
    internal static double uRc=;
    internal static double uhc=;
    internal static double uxc=;
    internal static double vBc=;
    internal static double vRc=;
    internal static double vhc=;
    internal static double vxc=;
    internal static double wBc=;
    internal static double wRc=;
    internal static double whc=;
    internal static double wxc=;
    internal static double xBc=;
    internal static int xRc=;
    internal static int xhc=;
    internal static double xxc=;
    internal static double yBc=;
    internal static double yRc=;
    internal static double yhc=;
    internal static double yxc=;
    internal static double zBc=;
    internal static double zRc=;
    internal static double zhc=;
    internal static double zxc=;
    internal static double 0Bc=;
    internal static double 0Rc=;
    internal static double 0hc=;
    internal static double 0xc=;
    internal static double 1Bc=;
    internal static double 1Rc=;
    internal static double 1hc=;
    internal static double 1xc=;
    internal static double 2Bc=;
    internal static double 2Rc=;
    internal static double 2hc=;
    internal static double 2xc=;
    internal static double 3Bc=;
    internal static double 3Rc=;
    internal static double 3hc=;
    internal static double 3xc=;
    internal static byte 4Bc=;
    internal static byte 4Rc=;
    internal static byte 4hc=;
    internal static byte 4xc=;
    internal static int 5Bc=;
    internal static int 5Rc=;
    internal static double 5hc=;
    internal static double 5xc=;
    internal static double 6Bc=;
    internal static double 6Rc=;
    internal static double 6hc=;
    internal static int 6xc=;
    internal static double 7Bc=;
    internal static double 7Rc=;
    internal static double 7hc=;
    internal static double 7xc=;
    internal static double 8Bc=;
    internal static double 8Rc=;
    internal static double 8hc=;
    internal static double 8xc=;
    internal static double 9Bc=;
    internal static double 9Rc=;
    internal static double 9hc=;
    internal static double 9xc=;
    internal static int /Bc=;
    internal static double /Rc=;
    internal static double /hc=;
    internal static double /xc=;
    internal static double ABg=;
    internal static double ARg=;
    internal static double Ahg=;
    internal static double Axg=;
    internal static int BBg=;
    internal static double BRg=;
    internal static double Bhg=;
    internal static int Bxg=;
    internal static int CBg=;
    internal static int CRg=;
    internal static double Chg=;
    internal static double Cxg=;
    internal static double DBg=;
    internal static double DRg=;
    internal static double Dhg=;
    internal static int Dxg=;
    internal static double EBg=;
    internal static double ERg=;
    internal static double Ehg=;
    internal static double Exg=;
    internal static double FBg=;
    internal static double FRg=;
    internal static double Fhg=;
    internal static int Fxg=;
    internal static double GBg=;
    internal static int GRg=;
    internal static double Ghg=;
    internal static double Gxg=;
    internal static double HBg=;
    internal static double HRg=;
    internal static double Hhg=;
    internal static double Hxg=;
    internal static double IBg=;
    internal static double IRg=;
    internal static double Ihg=;
    internal static double Ixg=;
    internal static double JBg=;
    internal static double JRg=;
    internal static double Jhg=;
    internal static double Jxg=;
    internal static double KBg=;
    internal static double KRg=;
    internal static double Khg=;
    internal static double Kxg=;
    internal static double LBg=;
    internal static double LRg=;
    internal static double Lhg=;
    internal static double Lxg=;
    internal static double MBg=;
    internal static double MRg=;
    internal static double Mhg=;
    internal static double Mxg=;
    internal static long NBg=;
    internal static long NRg=;
    internal static long Nhg=;
    internal static long Nxg=;
    internal static double Mxc=;
    internal static double OBg=;
    internal static double ORg=;
    internal static int Ohg=;
    internal static double Oxg=;
    internal static double PBg=;
    internal static double PRg=;
    internal static string Phg=;
    internal static double Pxg=;
    internal static double QBg=;
    private static Vhc=();
}
internal class GRU=.vhg= : object {
    internal string vxg=;
    internal Dictionary`2<string, string> wBg=;
    internal bool wRg=;
    internal int whg=;
    internal bool wxg=;
    internal bool xBg=;
    internal double xRg=;
    internal double xhg=;
    internal double xxg=;
    internal double yBg=;
    internal double yRg=;
    internal double yhg=;
    internal double yxg=;
    internal double zBg=;
    internal double zRg=;
    internal double zhg=;
    internal double zxg=;
    internal double 0Bg=;
    internal double 0Rg=;
    internal double 0hg=;
    internal double 0xg=;
    internal Qxg= 1Bg=;
    internal Double[] 1Rg=;
    internal double 1hg=;
    internal double 1xg=;
}
internal class GRU=.Vig= : ByU= {
    public Encoding ER8=;
    private string 7SU=;
    private Stream Vyg=;
    private ESg= 7iU=;
    private Iis= WCg=;
    private ySo= WSg=;
    private int Wig=;
    private UCg=[] Wyg=;
    private ySo= XCg=;
    private int Kyg=;
    private int XSg=;
    private int Xig=;
    private bool Xyg=;
    private int YCg=;
    private int YSg=;
    private bool Yig=;
    private string Yyg=;
    private static int Dyg=;
    private static int ECg=;
    private static int Dig=;
    public string cSY=(int columnNum, int recordNum);
    private int ZCg=();
    private int Px8=();
    public int FR8=(string pszFname, FileAccess pszAccess, Iis= eTableType);
    public int oR8=();
    public int ZSg=();
    public uig= Gh8=(int nFieldId);
    public int Zig=(int nFieldId);
    public int Zyg=(int nFieldId);
    public int aCg=(int iField, string pszName, uig= eType, int nWidth, int nPrecision);
    public int aSg=(string pszName, uig= eType, int nWidth, int nPrecision);
    public int aig=();
    public ySo= ayg=(int nRecordId);
    public bool bCg=();
    public int bSg=();
    public string big=(int nWidth);
    public int byg=(int nWidth);
    public short cCg=(int nWidth);
    public double cSg=(int nWidth);
    public double cig=(int nWidth);
    public string cyg=(int nWidth);
    public string dCg=(int nWidth);
    public string dSg=(int nWidth);
    public string dig=(int nWidth);
    public int dyg=(string pszStr, int nWidth, BCk= poINDFile, int nIndexNo);
    public int eCg=(int nValue, BCk= poINDFile, int nIndexNo);
    public int eSg=(short nValue, BCk= poINDFile, int nIndexNo);
    public int eig=(float dValue, BCk= poINDFile, int nIndexNo);
    public int eyg=(double dValue, int nWidth, int nPrecision, BCk= poINDFile, int nIndexNo);
    public int fCg=(string pszValue, BCk= poINDFile, int nIndexNo);
    public int fSg=(string pszValue, BCk= poINDFile, int nIndexNo);
    public int fig=(string pszValue, BCk= poINDFile, int nIndexNo);
    public int fyg=(string pszValue, BCk= poINDFile, int nIndexNo);
    public sealed virtual void Dispose();
}
internal class GRU=.viI= : object {
    private static double vyI=;
    public Boolean[0...,0...] wCI=;
    public Boolean[0...,0...] wSI=;
    public Boolean[0...,0...] wiI=;
    public Boolean[0...,0...] wyI=;
    private GridCell[0...,0...] xCI=;
    [CompilerGeneratedAttribute]
private int xSI=;
    [CompilerGeneratedAttribute]
private int xiI=;
    [CompilerGeneratedAttribute]
private bool xyI=;
    public int yiI= { get; private set; }
    public int zSI= { get; private set; }
    public bool 0CI= { get; private set; }
    public viI=(GridCell[0...,0...] grid, double noDataValue);
    [CompilerGeneratedAttribute]
public int yCI=();
    [CompilerGeneratedAttribute]
private void ySI=(int value);
    [CompilerGeneratedAttribute]
public int yyI=();
    [CompilerGeneratedAttribute]
private void zCI=(int value);
    [CompilerGeneratedAttribute]
public bool ziI=();
    [CompilerGeneratedAttribute]
private void zyI=(bool value);
    public void 0SI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    public void 0iI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    public bool 0yI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex, double isoValue, KiM= enterDirection);
    public bool 1CI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex, double isoValue, KiM= enterDirection);
    public bool 1SI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex, double isoValue, KiM= enterDirection);
    public bool 1iI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex, double isoValue, KiM= enterDirection);
    public bool 1yI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    public bool 2CI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    public GridCell 2SI=(double isoValue, 8yI= enterIndex1, 8yI= enterIndex2, GridCell previousCell);
    public GridCell 2SI=(double isoValue, int pointIndexX1, int pointIndexY1, int pointIndexX2, int pointIndexY2);
    public GridCell 2iI=(int rowIndex, int columnIndex);
    public /iI= 2yI=(int leftTopIndexX, int leftTopIndexY);
    private void 3CI=(GridCell[0...,0...] grid);
    private void 3CI=(GridCell[0...,0...] grid, double noDataValue);
    private bool 3SI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    private bool 3iI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    private bool 3yI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    private bool 4CI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    private bool 4SI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex, KiM= enterDirection);
    private bool 4iI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex, KiM= enterDirection);
    private void 4yI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    private void 5CI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    private void 5SI=(int lowwerColumnIndex, int upperColumnIndex, int rowIndex);
    private void 5iI=(int lowwerRowIndex, int upperRowIndex, int ColumnIndex);
    private static bool 5yI=(double isoValue1, double isoValue2, double destIsoValue);
}
[DefaultMemberAttribute("Item")]
internal class GRU=.ViI= : object {
    private Double[0...,0...] VyI=;
    public double whw= { get; public set; }
    public int WiI= { get; public set; }
    public int XSI= { get; public set; }
    public Double[0...,0...] XyI= { get; }
    public ViI=(int noRows, int noCols);
    public ViI=(Double[0...,0...] Mat);
    public double wBw=(int Row, int Col);
    public void wRw=(int Row, int Col, double value);
    public int WCI=();
    public void WSI=(int value);
    public int WyI=();
    public void XCI=(int value);
    public Double[0...,0...] XiI=();
    private static void YCI=(Double[] Mat, Int32& Row);
    private static void YCI=(Double[0...,0...] Mat, Int32& Row, Int32& Col);
    public static Double[0...,0...] YSI=(Double[] Mat);
    public static Double[] YiI=(Double[0...,0...] Mat);
    public static Double[0...,0...] YyI=(int n);
    public static Double[0...,0...] ZCI=(Double[0...,0...] Mat1, Double[0...,0...] Mat2);
    public static ViI= ZCI=(ViI= Mat1, ViI= Mat2);
    public static ViI= zxM=(ViI= Mat1, ViI= Mat2);
    public static Double[0...,0...] ZSI=(Double[0...,0...] Mat1, Double[0...,0...] Mat2);
    public static ViI= ZSI=(ViI= Mat1, ViI= Mat2);
    public static ViI= 0RM=(ViI= Mat1, ViI= Mat2);
    public static Double[0...,0...] ZiI=(Double[0...,0...] Mat1, Double[0...,0...] Mat2);
    public static ViI= ZiI=(ViI= Mat1, ViI= Mat2);
    public static ViI= 0xM=(ViI= Mat1, ViI= Mat2);
    public static double ZyI=(Double[0...,0...] Mat);
    public static double ZyI=(ViI= Mat);
    public static Double[0...,0...] aCI=(Double[0...,0...] Mat);
    public static ViI= aCI=(ViI= Mat);
    public static Double[0...,0...] aSI=(Double[0...,0...] Mat);
    public static ViI= aSI=(ViI= Mat);
    public static void aiI=(Double[0...,0...] Mat_, Double[0...,0...]& S_, Double[0...,0...]& U_, Double[0...,0...]& V_);
    private static double ayI=(double a);
    private static double bCI=(double a, double b);
    private static double bSI=(double a, double b);
    public static void aiI=(ViI= Mat, ViI=& S, ViI=& U, ViI=& V);
    public static void biI=(Double[0...,0...] Mat, Double[0...,0...]& L, Double[0...,0...]& U, Double[0...,0...]& P);
    private static void byI=(Double[0...,0...] Mat, int Row, int toRow);
    public static void biI=(ViI= Mat, ViI=& L, ViI=& U, ViI=& P);
    public static Double[0...,0...] cCI=(Double[0...,0...] MatA, Double[0...,0...] MatB);
    public static ViI= cCI=(ViI= MatA, ViI= MatB);
    public static int cSI=(Double[0...,0...] Mat);
    public static int cSI=(ViI= Mat);
    public static Double[0...,0...] ciI=(Double[0...,0...] Mat);
    public static ViI= ciI=(ViI= Mat);
    public static void cyI=(Double[0...,0...] Mat, Double[0...,0...]& d, Double[0...,0...]& v);
    private static void dCI=(double g, double h, double s, double tau, Double[0...,0...] a, int i, int j, int k, int l);
    public static void cyI=(ViI= Mat, ViI=& d, ViI=& v);
    public static Double[0...,0...] dSI=(double Value, Double[0...,0...] Mat);
    public static ViI= dSI=(double Value, ViI= Mat);
    public static ViI= 0xM=(ViI= Mat, double Value);
    public static ViI= 0xM=(double Value, ViI= Mat);
    public static Double[0...,0...] diI=(double Value, Double[0...,0...] Mat);
    public static ViI= diI=(double Value, ViI= Mat);
    public static ViI= 4hM=(ViI= Mat, double Value);
    public static Double[] dyI=(Double[] V1, Double[] V2);
    public static Double[0...,0...] dyI=(Double[0...,0...] V1, Double[0...,0...] V2);
    public static ViI= dyI=(ViI= V1, ViI= V2);
    public static double eCI=(Double[] V1, Double[] V2);
    public static double eCI=(Double[0...,0...] V1, Double[0...,0...] V2);
    public static double eCI=(ViI= V1, ViI= V2);
    public static double eSI=(Double[] V);
    public static double eSI=(Double[0...,0...] V);
    public static double eSI=(ViI= V);
    public static bool eiI=(Double[0...,0...] Mat1, Double[0...,0...] Mat2);
    public static bool eiI=(ViI= Mat1, ViI= Mat2);
    public static bool 2hM=(ViI= Mat1, ViI= Mat2);
    public static bool 2xM=(ViI= Mat1, ViI= Mat2);
    public virtual bool Equals(object obj);
    public static string eyI=(Double[0...,0...] Mat);
    public static string eyI=(ViI= Mat);
    public virtual string ToString();
    public virtual int GetHashCode();
}
internal interface GRU=.viU= {
    public int wSU= { get; public set; }
    public His= xCU= { get; public set; }
    public abstract virtual int vyU=();
    public abstract virtual void wCU=(int value);
    public abstract virtual His= wiU=();
    public abstract virtual void wyU=(His= value);
    public abstract virtual int xSU=();
    public abstract virtual His= xiU=();
    public abstract virtual short xyU=();
    public abstract virtual short yCU=();
    public abstract virtual int ySU=();
    public abstract virtual void yiU=(short val);
    public abstract virtual void yyU=(short val);
    public abstract virtual void zCU=(int clr);
    public abstract virtual string zSU=(double dfAngle);
    public abstract virtual void ziU=(string pszStyleString);
    public abstract virtual void zyU=(Stream fpOut);
}
internal enum GRU=.viY= : Enum {
    public int value__;
    public static viY= vyY=;
}
internal class GRU=.vRU= : MulticastDelegate {
    public vRU=(object object, IntPtr method);
    public virtual object Invoke(Object[] args);
    public virtual IAsyncResult BeginInvoke(Object[] args, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class GRU=.VS0= : object {
    private int Vi0=;
    private double 9yw=;
    [CompilerGeneratedAttribute]
private List`1<myw=> Vy0=;
    [CompilerGeneratedAttribute]
private int WC0=;
    [CompilerGeneratedAttribute]
private short WS0=;
    [CompilerGeneratedAttribute]
private short Wi0=;
    public List`1<myw=> XS0= { get; public set; }
    public int YC0= { get; private set; }
    public short Yy0= { get; private set; }
    public short Zi0= { get; private set; }
    public VS0=(double extentWidthLimitation);
    [CompilerGeneratedAttribute]
public void XC0=(List`1<myw=> value);
    [CompilerGeneratedAttribute]
public List`1<myw=> Wy0=();
    [CompilerGeneratedAttribute]
private void Xy0=(int value);
    [CompilerGeneratedAttribute]
public int Xi0=();
    [CompilerGeneratedAttribute]
private void Yi0=(short value);
    [CompilerGeneratedAttribute]
public short YS0=();
    [CompilerGeneratedAttribute]
private void ZS0=(short value);
    [CompilerGeneratedAttribute]
public short ZC0=();
    public bool Zy0=(double LoCenter, double LaCenter, int BitsPerCoord, Dictionary`2<string, int> lableDictnory);
}
internal class GRU=.VSI= : Exception {
}
internal enum GRU=.vSY= : Enum {
    public int value__;
    public static vSY= MSU=;
    public static vSY= MiU=;
    public static vSY= MyU=;
    public static vSY= NCU=;
    public static vSY= NSU=;
    public static vSY= NiU=;
    public static vSY= NyU=;
    public static vSY= OCU=;
    public static vSY= OSU=;
    public static vSY= OiU=;
    public static vSY= OyU=;
    public static vSY= PCU=;
}
internal enum GRU=.vy8= : Enum {
    public int value__;
    public static vy8= uC8=;
    public static vy8= uS8=;
    public static vy8= wC8=;
    public static vy8= wS8=;
    public static vy8= wi8=;
}
internal class GRU=.Vyc= : object {
    private string WCc=;
    private vSY= WSc=;
    private int Wic=;
    private int Wyc=;
    public Vyc=(string pszNameIn, vSY= eTypeIn);
    private void 4Bw=(string pszNameIn, vSY= eTypeIn);
    public void XCc=(string pszNameIn);
    public string XSc=();
    public vSY= Xic=();
    public static string Xyc=(vSY= eType);
    public int RBU=();
    public void YCc=(int nWidthIn);
    public int YSc=();
    public void Yic=(int nPrecisionIn);
}
internal class GRU=.Vyk= : ByU= {
    private static int Dyg=;
    private static int ECg=;
    private static int Dig=;
    public Encoding ER8=;
    private int WCk=;
    private Stream Vyg=;
    private ESg= 7iU=;
    private Kig= BSk=;
    private lSk= WSk=;
    private tSk= Wik=;
    private bool Wyk=;
    private /yg= XCk=;
    private 6Ck= XSk=;
    private int Xik=;
    private int Xyk=;
    private int YCk=;
    private Mik= YSk=;
    private Uys= Yik=;
    private ays= Yyk=;
    private ays= ZCk=;
    private int ZSk=;
    private int Zik=;
    private int Zyk=;
    private int aCk=;
    private tSk= aSk=;
    private int aik=(bool bDeleteObjects);
    private int ayk=(int nBlockPtr);
    private 6Ck= bCk=(BSo= poObjHdrToAdd, int nSizeOfObjToAdd);
    private int bSk=(BSo= poObjHdr, Mik= poSrcCoordBlock, 6Ck= poDstObjBlock, Mik= ppoDstCoordBlock);
    private int bik=(int nObjType, 6Ck= poObjBlock, Mik=& ppoCoordBlock);
    private int byk=();
    private int cCk=();
    private int cSk=();
    private int cik=(int bFirstObject);
    private ySo= cyk=(int nFileOffset);
    public int FR8=(string pszFname, FileAccess pszAccess, bool bNoErrorMsg);
    public int oR8=();
    public int dCk=(bool bQuickSpatialIndexMode);
    public int dSk=(int nX, int nY, Double& dX, Double& dY);
    public int dik=(double dX, double dY, Int32& nX, Int32& nY, bool bIgnoreOverflow);
    public int dyk=(int nX, int nY, Double& dX, Double& dY);
    public int eCk=(double dX, double dY, Int32& nX, Int32& nY);
    public void eSk=(ays= sMin, ays= sMax);
    public void eik=(ays=& sMin, ays=& sMax);
    public void eyk=();
    public int fCk=(double dXMin, double dYMin, double dXMax, double dYMax);
    public int fSk=(int nObjId);
    public void fik=(byte nObjType);
    public int fyk=(BSo= poObjHdr);
    public int gCk=(BSo= poObjHdr);
    public int gSk=(BSo= poObjHdr);
    public int gik=(BSo= poObjHdr);
    public void gyk=();
    public int hCk=(int nPrevId);
    public int hSk=();
    public int hik=();
    public 6Ck= hyk=();
    public Mik= iCk=();
    public Mik= iSk=(int nFileOffset);
    public lSk= iik=();
    public ySo= iyk=(int nFileOffset);
    public int jCk=(int nPenIndex, Oyo= psDef);
    public int jSk=(int nBrushIndex, NSg= psDef);
    public int jik=(int nFontIndex, 3Cg= psDef);
    public int jyk=(int nSymbolIndex, His= psDef);
    public int kCk=(Oyo= psDef);
    public int kSk=(NSg= psDef);
    public int kik=(3Cg= psDef);
    public int kyk=(His= psDef);
    public int lCk=();
    public sealed virtual void Dispose();
}
internal enum GRU=.vys= : Enum {
    public int value__;
    public static vys= wCs=;
    public static vys= wSs=;
    public static vys= wis=;
    public static vys= wys=;
    public static vys= xCs=;
}
internal class GRU=.WBg= : object {
    private Int32[] WRg=;
    private int Whg=;
    private List`1<fRo=> Wxg=;
    private string XBg=;
    private List`1<fRo=> XRg=;
    private double Xhg=;
    private double Xxg=;
    private bool YBg=(Double[] height, bool z_is_temp, Int32& pj_Error);
    internal int YRg=(iBo= srcdefn, iBo= dstdefn, long point_count, int point_offset, Double[] height, ixo=[] uvList, Int32& pj_Error);
    internal static Dictionary`2<string, string> Yhg=(String[] args);
    internal static void Yxg=(Dictionary`2<string, string> paras, string arg);
    internal int ZBg=(iBo= srcdefn, iBo= dstdefn, long point_count, int point_offset, ixo=[] uvList, Double[] height, Int32& pj_Error);
    internal int ZRg=(double a, double es, long point_count, int point_offset, ixo=[] uvList, Double[] height, Int32& pj_Error);
    private long Zhg=(URg= gi, double a, double b);
    private void Zxg=(URg= gi, double x, double y, double z, ixo=[] uv, Double[] height, long io, Int32& pj_Error);
    private lhg= aBg=(lRo= xy, iBo= p, Int32& pj_Error);
    private lRo= aRg=(double phi, double lambda, double lambda0);
    private double ahg=(double phi);
    private lhg= axg=(double x, double y, double cmeridian);
    private double bBg=(double y);
    private double bRg=(int zone);
    private double bhg=(double deg);
    private double bxg=(double rad);
    private int cBg=(double lat, double lon, int zone, lRo=& xy);
    private lRo= cRg=(lhg= geodetic_loc, iBo= dstdefn, Int32& pj_Error);
    private int chg=(iBo= dstdefn, long point_count, int point_offset, ixo=[] list, Double[] height, Int32& pj_Error);
    private int cxg=(iBo= srcdefn, long point_count, int point_offset, ixo=[] list, Double[] height, Int32& pj_Error);
    internal int dBg=(double src_a, double src_es, long point_count, int point_offset, ixo=[] list, Double[] height, Int32& pj_Error);
    private bool dRg=(URg= gi, ixo=[] projUV, Double[] height, long io, Int32& pj_Error);
    private int dhg=(string nadgrids, int inverse, long point_count, int point_offset, ixo=[] uvList, Double[] height, Int32& pj_Error);
    private lhg= dxg=(lhg= input, int inverse, URc= ct, Int32& pj_Error);
    private lhg= eBg=(lhg= tb, URc= ct);
    private bool eRg=(fRo= gi, Int32& pj_Error);
    private List`1<fRo=> ehg=(string nadgrids, Int32& grid_count, Int32& pj_Error);
    private bool exg=(iBo= srcdefn, iBo= dstdefn, Int32& pj_Error);
    private int fBg=(string gridName, Int32& pj_Error);
    private void fRg=(string gridName, List`1<fRo=> giList, Int32& pj_Error);
    private void fhg=(Stream fs, fRo= gi, List`1<fRo=> giList, Int32& pj_Error);
    private void fxg=(Stream fs, fRo= gi, Int32& pj_Error);
}
internal class GRU=.WBo= : iBo= {
    internal double vRk=;
    internal double Ahk=;
    internal double Axk=;
    internal double Mxk=;
    internal double vhk=;
    internal double vxk=;
    internal double wBk=;
    internal double Shg=;
    internal double wRk=;
    internal double whk=;
    internal double wxk=;
    internal double xBk=;
    internal int CRk=;
    internal int xRk=;
    internal WBo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.wC4= : object {
    private BinaryReader myE=;
    private Ai8= wS4=;
    private 1i4= wi4=;
    private sy4= wy4=;
    private double xS0=;
    public wC4=(Stream stream, Ai8= trebody, 1i4= header, sy4= lblBody, double extentWidthLimitation);
    private List`1<Feature> xC4=(3S4= subdivision, IEnumerable`1<string> recordIndexes, Dictionary`2<string, int> returningColumns, yyw= encryptor);
    private List`1<Feature> xC4=(3S4= subdivision, NS4= range, Dictionary`2<string, int> returningColumns, yyw= encryptor);
    private Byte[] xS4=(Ri4= point, int latitutde, int longitude);
    private Byte[] xi4=(List`1<Ri4=> points, int latitutde, int longitude);
    private Byte[] xy4=(List`1<Ri4=> points, int latitutde, int longitude);
    private void yC4=(List`1<Ri4=> points, Int32& latitutde, Int32& longitude, Byte[] wkb, int startPosition);
    private static void yS4=(double latitutde, double longitude, Byte[] wkb, int startPosition, int i);
    private string yi4=(int offset, yyw= encryptor);
    public void yy4=(int index, BinaryWriter bw, string password, TSw= encryptMode);
    private void zC4=(3i4= subDefine, int nextSubAbsSubOffset, BinaryWriter bw, string password, TSw= encryptMode);
    private void yy4=(hCw= shapeType, int nextSubAbsSubOffset, int rgnEndOffset, BinaryWriter bw, string password, TSw= encryptMode);
    private void zS4=(BinaryWriter bw, yyw= encryptor);
    private void zi4=(BinaryWriter bw, yyw= encryptor);
    private void zy4=(BinaryWriter bw, yyw= encryptor);
    private void 0C4=(BinaryWriter bw, yyw= encryptor);
    private void 0S4=(BinaryWriter bw, yyw= encryptor);
    private void 0i4=(BinaryWriter bw, yyw= encryptor);
    private static Byte[] iy4=(Byte[] inputBytes, yyw= encryptor);
    private static Byte[] lxQ=(Byte[] inputBytes, yyw= encryptor);
    private Byte[] 6xM=(int bitstreamLength);
    public List`1<Feature> 0y4=(NS4= range, int subdivisionIndex, Dictionary`2<string, int> returningColumns, yyw= encryptor);
    public List`1<Feature> 0y4=(IEnumerable`1<string> featureIds, Dictionary`2<string, int> returningColumns, yyw= encryptor);
    private 3S4= 1C4=(3i4= subDefine, int nextSubAbsSubOffset, yyw= encryptor);
    private void 1C4=(hCw= shapeType, 3S4= subdivision, int nextSubAbsSubOffset, int rgnEndOffset, byte shfitBits, yyw= encryptor);
    private static void 1S4=(byte bitstreamInfo, Byte[] bitstream, byte shiftbits, List`1<Ri4=> points);
}
internal enum GRU=.wCY= : Enum {
    public int value__;
    public static wCY= wSY=;
    public static wCY= wiY=;
    public static wCY= wyY=;
    public static wCY= xCY=;
    public static wCY= xSY=;
    public static wCY= xiY=;
}
internal class GRU=.Whk= : iBo= {
    internal double Ahk=;
    internal double Axk=;
    internal int CRk=;
    internal Whk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Who= : iBo= {
    internal double Qhk=;
    internal double Wxo=;
    internal double XBo=;
    internal double fxc=;
    internal Who=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.wiQ= : object {
    public static int oCQ=;
    public int wyQ=;
    public miQ= xCQ=;
    public xyQ= xSQ=;
    public StringBuilder xiQ=;
    private static wiQ=();
}
internal class GRU=.WRk= : iBo= {
    internal WRk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.WRo= : iBo= {
    internal double Mxo=;
    internal double NBo=;
    internal double NRo=;
    internal double Nho=;
    internal int CRk=;
    internal WRo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private double Nxo=(double phit, double sinphi, double eccen, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= DRk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lhg= Chk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.WRY= : object {
    private static double WhY=;
    private static int WxY=;
    private static int XBY=;
    private static int XRY=;
    private static int XhY=;
    private static int XxY=;
    private static int YBY=;
    private static int YRY=;
    private static int YhY=;
    private static int YxY=;
    private static int ZBY=;
    private static int ZRY=;
    private static int ZhY=;
    private static int ZxY=;
    private static int aBY=;
    private static int aRY=;
    private static int ahY=;
    private static int axY=;
    private static int bBY=;
    private static int bRY=;
    private static int bhY=;
    private static int bxY=;
    private static int cBY=;
    private static int cRY=;
    private static int chY=;
    private static int cxY=;
    private static int dBY=;
    private static String[] dRY=;
    internal Exc= dhY=;
    private bool dxY=;
    private double eBY=;
    private double eRY=;
    private double ehY=;
    private IFormatProvider exY=;
    internal static String[] fBY=;
    internal static String[] fRY=;
    internal static String[] fhY=;
    internal static String[] fxY=;
    internal static String[] gBY=;
    internal static String[] gRY=;
    internal static String[] ghY=;
    internal static String[] gxY=;
    internal static String[] hBY=;
    internal static String[] hRY=;
    internal static String[] hhY=;
    internal static String[] hxY=;
    internal static String[] iBY=;
    internal static String[] iRY=;
    internal static String[] ihY=;
    internal static String[] ixY=;
    internal static String[] jBY=;
    private static string jRY=;
    private static String[] jhY=;
    private static object jxY=;
    private static List`1<JBc=> kBY=;
    internal static String[] khY= { get; }
    internal static List`1<JBc=> lBY= { get; }
    internal WRY=(IFormatProvider inputProvider);
    private static WRY=();
    private static void lRY=(String& datum);
    private static double lhY=(string angleValue, int uomAngle, IFormatProvider provider);
    private static bool lxY=(int nUOMAngleCode, String& ppszUOMName, Double& pdfInDegrees, IFormatProvider provider);
    private static bool mBY=(int uomLengthCode, String& uomName, Double& inMeters, IFormatProvider provider);
    internal static bool mRY=(int geogCS, Double[] padTransform, IFormatProvider provider);
    private static bool mhY=(int pmCode, String& name, Double& offset, IFormatProvider provider);
    internal static bool mxY=(int code, String& refName, Int32& refDatum, String& refDatumName, Int32& refPM, Int32& refEllipsoid, Int32& refUOMAngle, Int32& refCoordSysCode, IFormatProvider provider);
    private static void nBY=(int code, String& ellipseName, Double& semiMajor, Double& invFlattening, IFormatProvider provider);
    private static bool nRY=(int pcsCode, Int32& projMethod, Int32[] parmIds, Double[] projParms, IFormatProvider provider);
    internal static bool nhY=(int pcsCode, String& epsgName, Int32& uomLengthCode, Int32& uomAngleCode, Int32& geogCS, Int32& pnTRFCode, Int32& pnCoordSysCode, IFormatProvider provider);
    private static void nxY=(WRY= srs, string targetKey, int cooridSysCode, IFormatProvider provider);
    private static double oBY=(Double[] padfProjParms, Int32[] panParmIds, int nTargetId, double dfFromGreenwich);
    internal static void oRY=(WRY= srs, int geogCS, IFormatProvider provider);
    internal static void ohY=(WRY= srs, int pcsCode, IFormatProvider provider);
    private bool oxY=(int code, IFormatProvider provider);
    private bool pBY=(int code, IFormatProvider provider);
    private bool pRY=(string fileName, int code);
    private void ZxU=();
    internal Exc= phY=(string nodePath);
    private string pxY=(string nodeName);
    private string pxY=(string nodeName, int valueIndex);
    internal string qBY=();
    internal void qRY=(string wkt);
    private void qhY=(string nodePath, string nodeValue);
    private void qxY=(string name, double inRadians);
    private double rBY=(String& parameterName);
    private void rRY=(string unitName, double inMeter);
    private double rhY=();
    private double rhY=(String& parameterName);
    private double rxY=();
    private double rxY=(String& parameterName);
    internal void sBY=(string geogName, string datumName, string spheroidName, double semiMajor, double invFlattening, string pmName, double pmOffset);
    internal void sBY=(string geogName, string datumName, string spheroidName, double semiMajor, double invFlattening, string pmName, double pmOffset, string angularUnits, double convertToRadians);
    private void sRY=(string nameValue, IFormatProvider provider);
    private void shY=(WRY= other);
    private double sxY=();
    private double tBY=();
    private double tRY=();
    private void thY=(string projection);
    private void txY=(string parmName, double defaultValue);
    private int uBY=(string parameterName);
    private int uBY=(string parameterName, Exc= projCSnode);
    private double uRY=(string parameterName, double defaultValue);
    private double uRY=(string parameterName, double defaultValue, Boolean& isSucceed);
    private double uhY=(string parameterName, double defaultValue);
    private void uxY=(string name, double value);
    private void vBY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void vRY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void vhY=(double dfLat1, double dfLong1, double dfLat2, double dfLong2, double dfFalseEasting, double dfFalseNorthing);
    private void vxY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void wBY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void wRY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void whY=(double stdP1, double centralMeridian, double falseEasting, double falseNorthing);
    private void wxY=(double dfStdP1, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void xBY=(double centerLat, double centerLong, double falseEasting, double falseNorthing);
    private void xRY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void xhY=(int nVariation, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void xxY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void yBY=(double dfCenterLat, double dfCenterLong, double dfStdParallel1, double dfFalseEasting, double dfFalseNorthing);
    private void yRY=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void yhY=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void yxY=(double dfCentralMeridian, double dfSatelliteHeight, double dfFalseEasting, double dfFalseNorthing);
    private void zBY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void zRY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void zhY=(double dfCenterLat, double dfCenterLong, double dfAzimuth, double dfRectToSkew, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void zxY=(double dfLat1, double dfLat2, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 0BY=(double dfCenterLat, double dfCenterLong, double dfAzimuth, double dfPseudoStdParallel1, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void 0RY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 0hY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 0xY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void 1BY=(double dfStdP1, double dfStdP2, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 1RY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 1hY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void 1xY=(double dfStdP1, double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 2BY=(double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void 2RY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 2hY=(double dfOriginLat, double dfCMeridian, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void 2xY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 3BY=(double dfCenterLat, double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 3RY=(double dfCenterLat, double dfCenterLong, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void 3hY=(double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 3xY=(double dfCenterLong, double dfFalseEasting, double dfFalseNorthing);
    private void 4BY=(double dfOriginLat, double dfCMeridian, double dfScale, double dfFalseEasting, double dfFalseNorthing);
    private void 4RY=(double dfLatitudeOfOrigin, double dfCentralMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void 4hY=(double dfCMeridian, double dfFalseEasting, double dfFalseNorthing);
    private void 4xY=(int nZone, int isNorth);
    private int 5BY=(Boolean& isNorth);
    private void 5RY=(int nVariation, double dfCenterLat, double dfFalseEasting, double dfFalseNorthing);
    internal void 5hY=(string targetKey, string authority, int code);
    private string 5xY=(string targetKey);
    private string 6BY=(string targetKey);
    private bool 6RY=();
    private bool 6hY=();
    private bool 6xY=();
    private void 7BY=(double x, double y, double z);
    private void 7BY=(double x, double y, double z, double eX, double eY, double eZ, double ppm);
    private bool 7RY=(string parameterName);
    private static bool 7hY=(string parameterName);
    private void 7xY=();
    private void 8BY=();
    private string 8RY=(string targetKey, string extensionName, string defaultValue);
    private void 8hY=(string targetKey, string name, string value);
    internal void 8xY=(string targetKey, string xAxisName, 4xU= xAxisOrientation, string yAxisName, 4xU= yAxisOrientation);
    private void 9BY=();
    private void 9RY=();
    private void 9RY=(Exc= currentNode);
    private void 9hY=();
    private static double 9xY=(string valueString, IFormatProvider provider);
    private static int /BY=(string valueString, IFormatProvider provider);
    private static void /RY=(String& name);
    private static void /hY=();
    private static string /xY=(string name);
    internal void ABc=();
    internal void ARc=(string wkt);
    private void Ahc=();
    private static void Axc=(WRY= ogr, string keyName, string newName);
    private static int BBc=(WRY= ogr, string name, string keyName, String[] mappingTable);
    private static int BRc=(WRY= ogr, string name1, string name2, String[] mappingTable, int tableStepSize, String[] keyNames, int keys);
    private static int Bhc=(WRY= ogr, string projCSName, String[] mappingTable);
    private static int Bxc=(WRY= ogr, string projCSName, String[] mappingTable);
    private static int CBc=(WRY= ogr, string projectionName, String[] mappingTable);
    private static int CRc=(WRY= ogr, string projectionName, String[] mappingTable);
    private static int Chc=(WRY= ogr, string geogcsName);
    internal static String[] kRY=();
    internal static List`1<JBc=> kxY=();
    private static string Cxc=(string datunName, int epsgDatum);
    private String[] DBc=(string proj4String);
    private static double DRc=(String[] source, string field, double defaultValue, IFormatProvider provider);
    private static string Dhc=(string value, string field);
    internal void Dxc=(string proj4String);
    internal string EBc=();
    private static string ERc=(String[] source, string name);
    private static double Ehc=(string value, IFormatProvider provider);
}
internal class GRU=.wSc= : 2Cc= {
    public sSc=[] wic=;
    private tCc=[] vCc=;
    public virtual int jxU=();
}
internal class GRU=.wSM= : object {
    [CompilerGeneratedAttribute]
private List`1<xSM=> uyM=;
    [CompilerGeneratedAttribute]
private List`1<uCM=> wiM=;
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("links")]
public List`1<xSM=> Links { get; public set; }
    [JsonPropertyNameAttribute("collections")]
[ObfuscationAttribute]
public List`1<uCM=> Collections { get; public set; }
    public wSM=(List`1<xSM=> links, List`1<uCM=> collections);
    [CompilerGeneratedAttribute]
public List`1<xSM=> get_Links();
    [CompilerGeneratedAttribute]
public void set_Links(List`1<xSM=> value);
    [CompilerGeneratedAttribute]
public List`1<uCM=> get_Collections();
    [CompilerGeneratedAttribute]
public void set_Collections(List`1<uCM=> value);
}
internal class GRU=.Wxk= : iBo= {
    internal Double[] 8Rg=;
    internal double Qhk=;
    internal double fxc=;
    internal double shc=;
    internal double sxc=;
    internal Wxk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal enum GRU=.wy8= : Enum {
    public int value__;
    public static wy8= uC8=;
    public static wy8= uS8=;
    public static wy8= xC8=;
    public static wy8= uy8=;
    public static wy8= vC8=;
    public static wy8= vS8=;
    public static wy8= xS8=;
}
internal class GRU=.wyc= : object {
    private 0yc= xCc=;
    private string xSc=;
    public wyc=(0yc= poDataSetStyleTable);
    public bool xic=(string pszStyleString);
    public string xyc=(string pszStyleName);
    public int yCc=(string pszStyleString);
    public 2Cc= ySc=(int hPartId, string pszStyleString);
    public 2Cc= yic=(string pszStyleString);
}
internal class GRU=.wyM= : object {
    [CompilerGeneratedAttribute]
private ySM= xCM=;
    [JsonPropertyNameAttribute("spatial")]
[ObfuscationAttribute]
public ySM= Spatial { get; public set; }
    public wyM=(ySM= spatial);
    [CompilerGeneratedAttribute]
public ySM= get_Spatial();
    [CompilerGeneratedAttribute]
public void set_Spatial(ySM= value);
}
internal class GRU=.XBk= : iBo= {
    internal iBo= XRk=;
    internal iBo= Xhk=;
    internal XBk=(string id, string desc);
    internal void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
}
internal class GRU=.XBU= : object {
    private static ConcurrentDictionary`2<GeoFont, SKTypeface> XRU=;
    private SKBitmap XhU=;
    private SKCanvas XxU=;
    private bool YBU=;
    private bool YRU=;
    private float YhU=;
    [CompilerGeneratedAttribute]
private SKFilterQuality YxU=;
    public SKFilterQuality ZhU= { get; public set; }
    public XBU=(GeoImage image);
    private static XBU=();
    [CompilerGeneratedAttribute]
public SKFilterQuality ZBU=();
    [CompilerGeneratedAttribute]
public void ZRU=(SKFilterQuality value);
    public void ZxU=(GeoColor color);
    public void aBU=();
    public void aRU=(float dx, float dy);
    public void ahU=(float angle);
    public void SBU=();
    public void axU=();
    public void WRU=(GeoImage image, int srcX, int srcY, int srcWidth, int srcHeight, lxU=[] colors);
    public void SxU=(GeoImage image, float x, float y);
    public void SxU=(GeoImage image, DrawingRectangleF destRect, DrawingRectangleF srcRect);
    public void SxU=(GeoImage image, float x, float y, float width, float height);
    public void bBU=(GeoImage image, float x, float y, float width, float height);
    public void bBU=(GeoImage image, float x, float y, float width, float height, float canvasWidth, float canvasHeight);
    public void SxU=(GeoImage image, DrawingRectangle destRect, DrawingRectangle srcRect, Single[][] colorMatrix);
    public void bRU=(GeoImage image, int x, int y, float canvasWidth, float canvasHeight);
    public void bhU=(IEnumerable`1<ScreenPointF[]> screenPoints, GeoPen outlinePen, GeoBrush fillBrush, PenBrushDrawingOrder penBrushDrawingOrder);
    public void bxU=(ScreenPointF screenPoint, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, PenBrushDrawingOrder penBrushDrawingOrder);
    public void NBU=(IEnumerable`1<ScreenPointF> screenPoints, GeoPen linePen);
    public void cBU=(GeoPen pen, float x, float y, float width, float height, float startAngle, float sweepAngle);
    public void WhU=(ScreenPointF centerPoint, int radius, Single[] positions, GeoColor[] colors);
    public void cRU=(string text, GeoFont font, GeoBrush brush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingTextAlignment drawingTextAlignment);
    private SKTypeface chU=(string text, SKTypeface sKTypeface);
    private ValueTuple`2<SKTypeface, string> cxU=(string text);
    internal float OxU=(GeoFont font, DrawingTextBaseline textBaseline, string text);
    public void cRU=(string text, GeoFont font, GeoBrush brush, GeoPen haloPen, ScreenPointF point, DrawingTextAlignment drawingTextAlignment);
    public DrawingRectangleF dBU=(string text, GeoFont font);
    private SKPaint dRU=();
    private SKColor dhU=(GeoColor geoColor);
    private SKRect dxU=(DrawingRectangle rect);
    private SKRect dxU=(DrawingRectangleF rect);
    private SKRectI eBU=(DrawingRectangle rect);
    private SKPaint eRU=(GeoBrush geoBrush, SKPoint[] points);
    private SKPaint ehU=(GeoPen geoPen);
    private SKPaint exU=(GeoFont font, GeoBrush brush, IEnumerable`1<ScreenPointF> points);
    private static SKTypeface fBU=(GeoFont font);
    private SKPaint exU=(GeoFont font, GeoBrush brush, DrawingTextAlignment align, IEnumerable`1<ScreenPointF> points);
    private static SKFontStyle fRU=(DrawingFontStyles style);
    private void fhU=(GeoBrush geoBrush, SKPaint paint, IEnumerable`1<ScreenPointF> points);
    private void fxU=(string text, SKPaint paint, GeoFont geoFont);
    private SKShader gBU=(GeoHatchStyle hatchStyle, GeoColor foreColor, GeoColor backColor);
    private static void gRU=(float startX, float startY, float endX, float endY, SKPaint linePaint, SKCanvas canvas, DrawingLineCap drawingLineCap);
    private static SKPoint ghU=(float x, float y, double rotateRadian, float dx, float dy);
    private static double gxU=(float startX, float startY, float endX, float endY);
    public sealed virtual void Dispose();
}
internal class GRU=.xC0= : object {
    private double xS0=;
    [CompilerGeneratedAttribute]
private int xi0=;
    [CompilerGeneratedAttribute]
private int xy0=;
    [CompilerGeneratedAttribute]
private int yC0=;
    [CompilerGeneratedAttribute]
private int yS0=;
    public int zC0= { get; private set; }
    public int zy0= { get; private set; }
    public int 0i0= { get; private set; }
    public int 1S0= { get; private set; }
    public xC0=(double extentWidthLimitation);
    [CompilerGeneratedAttribute]
private void yy0=(int value);
    [CompilerGeneratedAttribute]
public int yi0=();
    [CompilerGeneratedAttribute]
private void zi0=(int value);
    [CompilerGeneratedAttribute]
public int zS0=();
    [CompilerGeneratedAttribute]
private void 0S0=(int value);
    [CompilerGeneratedAttribute]
public int 0C0=();
    [CompilerGeneratedAttribute]
private void 1C0=(int value);
    [CompilerGeneratedAttribute]
public int 0y0=();
    public void fC0=(RectangleShape Frontier);
}
internal class GRU=.xhk= : iBo= {
    internal Thc=[] xxk=;
    internal Double[] yBk=;
    internal Double[] yRk=;
    internal xhk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private Thc= Ghk=(Thc= z, Thc=[] C, int n, Thc=& der);
    private Thc= Gxk=(Thc= z, Thc=[] df, int n);
}
internal class GRU=.Xho= : iBo= {
    private double SBo=;
    private double 8xk=;
    private Double[] 8Rg=;
    internal Xho=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= DRk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lhg= Chk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
}
internal enum GRU=.xi8= : Enum {
    public int value__;
    public static xi8= uC8=;
    public static xi8= uS8=;
    public static xi8= wC8=;
    public static xi8= xy8=;
    public static xi8= wi8=;
}
internal static class GRU=.xiw= : object {
    public static int xyw=(double realValue, int accuracy, double extentWidthLimitation);
    public static short yCw=(double realValue, int accuracy, double extentWidthLimitation);
    public static ushort ySw=(double realValue, int accuracy, double extentWidthLimitation);
    public static int yiw=(double realValue, int accuracy, double extentWidthLimitation);
}
internal class GRU=.XRo= : iBo= {
    internal double fxc=;
    internal double sxc=;
    internal XRo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.xSg= : fCU= {
    private string 7SU=;
    private ESg= 7iU=;
    private List`1<string> xig=;
    private int BiY=;
    private Int32[] xyg=;
    private Iis= WCg=;
    private Vig= yCg=;
    private Vyk= ySg=;
    private BCk= yig=;
    private OCc= GiY=;
    private pSc= GyY=;
    private bool yyg=;
    private int zCg=;
    [CompilerGeneratedAttribute]
private object zSg=;
    public object 0Cg= { get; private set; }
    [CompilerGeneratedAttribute]
public object zig=();
    [CompilerGeneratedAttribute]
private void zyg=(object value);
    public virtual int Close();
    private int 0Sg=(bool bTestOpenNoError);
    private int 0ig=();
    private int 0yg=();
    public virtual 1ig= GetFileClass();
    public virtual int Open(string pszFname, FileAccess pszAccess, bool bTestOpenNoError);
    public string cSY=(int columnNum, int recordNum);
    public virtual int SetQuickSpatialIndexMode(bool bQuickSpatialIndexMode);
    public virtual string GetTableName();
    public virtual void ResetReading();
    public virtual bool TestCapability(string pszCap);
    public virtual int GetFeatureCount(bool bForce);
    public virtual piY= GetExtent(Gyc= psExtent, bool bForce);
    public virtual int GetNextFeatureId(int nPrevId);
    public virtual hSg= GetFeatureRef(int nFeatureId);
    public virtual OCc= GetLayerDefn();
    public virtual uig= GetNativeFieldType(int nFieldId);
    public virtual int GetBounds(Double& dXMin, Double& dYMin, Double& dXMax, Double& dYMax, bool bForce);
    public virtual pSc= GetSpatialRef();
    public virtual int GetFeatureCountByType(Int32& numPoints, Int32& numLines, Int32& numRegions, Int32& numTexts, bool bForce);
    public virtual bool IsFieldIndexed(int nFieldId);
    public virtual bool IsFieldUnique(int nFieldId);
    public virtual int SetBounds(double dXMin, double dYMin, double dXMax, double dYMax);
    public virtual int SetFeatureDefn(OCc= poFeatureDefn, List`1<uig=> paeMapInfoNativeFieldTypes);
    public virtual int AddFieldNative(string pszName, uig= eMapInfoType, int nWidth, int nPrecision, bool bIndexed, bool bUnique);
    public virtual int SetSpatialRef(pSc= poSpatialRef);
    public virtual int SetFeature(hSg= poFeature, int nFeatureId);
    public virtual int SetFieldIndexed(int nFieldId);
    public virtual int GetProjInfo(hCo= poPI);
    public virtual int SetProjInfo(hCo= poPI);
    public virtual int SetMIFCoordSys(string pszMIFCoordSys);
    public int 1Cg=(int nFieldId);
    public BCk= 1Sg=();
    public void 0x0=();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal class GRU=.xSM= : object {
    [CompilerGeneratedAttribute]
private string xiM=;
    [CompilerGeneratedAttribute]
private string xyM=;
    [CompilerGeneratedAttribute]
private string yCM=;
    [CompilerGeneratedAttribute]
private string uiM=;
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("href")]
public string Href { get; public set; }
    [JsonPropertyNameAttribute("rel")]
[ObfuscationAttribute]
public string Rel { get; public set; }
    [JsonPropertyNameAttribute("type")]
[ObfuscationAttribute]
public string Type { get; public set; }
    [JsonPropertyNameAttribute("title")]
[ObfuscationAttribute]
public string Title { get; public set; }
    public xSM=(string href, string rel, string type, string title);
    [CompilerGeneratedAttribute]
public string get_Href();
    [CompilerGeneratedAttribute]
public void set_Href(string value);
    [CompilerGeneratedAttribute]
public string get_Rel();
    [CompilerGeneratedAttribute]
public void set_Rel(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
}
internal class GRU=.xSs= : object {
    private 7Cs= myE=;
    [CompilerGeneratedAttribute]
private ulong uSM=;
    [CompilerGeneratedAttribute]
private WellKnownType xis=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> xys=;
    [CompilerGeneratedAttribute]
private List`1<UInt32> yCs=;
    [CompilerGeneratedAttribute]
private List`1<int> ySs=;
    public ulong fxQ= { get; public set; }
    public WellKnownType zCs= { get; public set; }
    public Dictionary`2<string, string> zis= { get; }
    private List`1<UInt32> 0Ss= { get; private set; }
    private List`1<int> 1Cs= { get; private set; }
    public xSs=(Byte[] data, List`1<string> keys, List`1<object> values);
    [CompilerGeneratedAttribute]
public ulong fRQ=();
    [CompilerGeneratedAttribute]
public void fhQ=(ulong value);
    [CompilerGeneratedAttribute]
public WellKnownType yis=();
    [CompilerGeneratedAttribute]
public void yys=(WellKnownType value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> zSs=();
    [CompilerGeneratedAttribute]
private List`1<UInt32> zys=();
    [CompilerGeneratedAttribute]
private void 0Cs=(List`1<UInt32> value);
    [CompilerGeneratedAttribute]
private List`1<int> 0is=();
    [CompilerGeneratedAttribute]
private void 0ys=(List`1<int> value);
    private List`1<List`1<Vertex>> 1Ss=(float scale);
    public Feature 1is=(RectangleShape vectorTileWorldExtent, ulong extent);
    private void 1ys=(List`1<string> keys, List`1<object> values);
    private void 2Cs=(List`1<string> keys, List`1<object> values);
    private Vertex 2Ss=(long x, long y);
    private List`1<List`1<Vertex>> 2is=(List`1<List`1<Vertex>> geometries, RectangleShape vectorTileWorldExtent, ulong vectorTileRelativeExtent);
    private BaseShape 2ys=(List`1<List`1<Vertex>> geometries, WellKnownType shapeType);
    private BaseShape 3Cs=(List`1<List`1<Vertex>> geometries);
    private BaseShape 3Ss=(List`1<List`1<Vertex>> geometries);
    private BaseShape 3is=(List`1<List`1<Vertex>> geometries);
}
internal class GRU=.Xxk= : iBo= {
    internal Thc=[] Fxk=;
    internal double GBk=;
    internal double GRk=;
    internal int fxc=;
    internal Xxk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private Thc= Ghk=(Thc= z, Thc=[] C, int n, Thc= der);
    private Thc= Gxk=(Thc= z, Thc=[] C, int n);
}
internal class GRU=.xxo= : XmlGeoSerializationFormatter {
    protected virtual GeoObjectModel LoadCore(Stream stream);
    private static void yBo=(XElement xElement, Dictionary`2<string, PointType> correctStyleTypes);
    private static bool yRo=(XElement xelement, string styleName, PointType pointType);
    private static XElement yho=(XElement contentXml);
    private static XElement yxo=(XElement layerElement);
}
internal class GRU=.Xxo= : iBo= {
    internal Xxo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.xyQ= : object {
    public xyQ= yCQ=;
    public AiU= ySQ=;
}
internal class GRU=.Xyw= : ValueType {
    public static double YCw=;
    public static double YSw=;
    public static double Yiw=;
    public static double Yyw=;
    public static double ZCw=;
    public static double ZSw=;
    public static double Ziw=;
    public static double Zyw=;
    public static double aCw=;
    public static double aSw=;
    public static double aiw=;
    public static double ayw=;
    public static double bCw=;
    public static double bSw=;
    public static double biw=;
    public static double byw=;
    public static double cCw=;
    public static double cSw=;
    public static double ciw=;
    public static double cyw=;
    public static double dCw=;
    public static double dSw=;
    public static double diw=;
    public static double dyw=;
    public static double eCw=;
    public static double eSw=;
    public static double eiw=;
    public static double eyw=;
    public static double fCw=;
    public static double fSw=;
    public static double fiw=;
    public static double fyw=;
    public static double gCw=;
    public static double gSw=;
    public static double giw=;
    public static double gyw=;
    private static Xyw=();
}
internal enum GRU=.xyY= : Enum {
    public int value__;
    public static xyY= yCY=;
    public static xyY= ySY=;
    public static xyY= yiY=;
    public static xyY= yyY=;
    public static xyY= zCY=;
    public static xyY= zSY=;
}
internal class GRU=.YBk= : iBo= {
    internal Thc=[] Fxk=;
    internal double GBk=;
    internal double GRk=;
    internal int fxc=;
    internal YBk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lhg= DBk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lRo= Dxk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private Thc= Ghk=(Thc= z, Thc=[] C, int n, Thc= der);
    private Thc= Gxk=(Thc= z, Thc=[] C, int n);
}
internal class GRU=.YBo= : iBo= {
    internal int YRo=;
    internal YBo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal enum GRU=.yC8= : Enum {
    public int value__;
    public static yC8= uC8=;
    public static yC8= uS8=;
    public static yC8= yS8=;
}
internal class GRU=.yhk= : iBo= {
    internal iBo= yxk=;
    internal double zBk=;
    internal double zRk=;
    internal double zhk=;
    internal double zxk=;
    internal yhk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= 0Bk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lRo= 0Rk=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private lhg= 0hk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    private lhg= 0xk=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Yho= : iBo= {
    internal int YRo=;
    internal Yho=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal enum GRU=.yhU= : Enum {
    public int value__;
    public static yhU= yxU=;
    public static yhU= zBU=;
    public static yhU= zRU=;
}
[FlagsAttribute]
internal enum GRU=.yhw= : Enum {
    public byte value__;
    public static yhw= yxw=;
    public static yhw= zBw=;
    public static yhw= zRw=;
    public static yhw= zhw=;
    public static yhw= zxw=;
    public static yhw= 0Bw=;
    public static yhw= 0Rw=;
}
internal enum GRU=.yi8= : Enum {
    public int value__;
    public static yi8= yy8=;
}
internal enum GRU=.yiQ= : Enum {
    public int value__;
    public static yiQ= yyQ=;
    public static yiQ= zCQ=;
    public static yiQ= zSQ=;
    public static yiQ= ziQ=;
    public static yiQ= zyQ=;
}
internal class GRU=.YRk= : iBo= {
    internal double Yhk=;
    internal double Yxk=;
    internal double 6hg=;
    internal double BRk=;
    internal double 7Bg=;
    internal double ZBk=;
    internal double ZRk=;
    internal YRk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.YS8= : object {
    public static US8= jxU=(BinaryReader br);
    private static gy8= Cyk=(BinaryReader br);
    private static ZC8= Yi8=(BinaryReader br);
    private static cy8= ohw=(BinaryReader br);
    public static DataType Xic=(BinaryReader br);
}
internal class GRU=.ySA= : ValueType {
    public double yiA=;
    public string yyA=;
    public string zCA=;
    public string zSA=;
    public 7SA= ziA=;
    public 7SA= zyA=;
    public string 0CA=;
    public string 0SA=;
    public string 0iA=;
    public string 0yA=;
    public string 1CA=;
    public string 1SA=;
    public string 1iA=;
    public string 1yA=;
    public bool 2CA=;
    public string 2SA=;
    public int 2iA=;
}
internal class GRU=.ySM= : object {
    [CompilerGeneratedAttribute]
private List`1<List`1<double>> yiM=;
    [CompilerGeneratedAttribute]
private string viM=;
    [JsonPropertyNameAttribute("bbox")]
[ObfuscationAttribute]
public List`1<List`1<double>> Bbox { get; public set; }
    [ObfuscationAttribute]
[JsonPropertyNameAttribute("crs")]
public string Crs { get; public set; }
    public ySM=(List`1<List`1<double>> bbox, string crs);
    [CompilerGeneratedAttribute]
public List`1<List`1<double>> get_Bbox();
    [CompilerGeneratedAttribute]
public void set_Bbox(List`1<List`1<double>> value);
    [CompilerGeneratedAttribute]
public string get_Crs();
    [CompilerGeneratedAttribute]
public void set_Crs(string value);
}
internal class GRU=.ySo= : ByU= {
    protected Stream Vyg=;
    protected ESg= yio=;
    protected int yyo=;
    protected Byte[] zCo=;
    protected int Kyg=;
    protected int zSo=;
    protected bool zio=;
    protected int zyo=;
    protected int 0Co=;
    protected int 0So=;
    protected bool 0io=;
    public ySo=(ESg= eAccessMode, bool bHardBlockSize);
    public virtual int ReadFromFile(Stream fsSrc, int nOffset, int nSize);
    public virtual int CommitToFile();
    public int 0yo=(int nNextBlockPtr);
    public virtual int InitBlockFromData(Byte[] pabyBuf, int nBlockSize, int nSizeUsed, bool bMakeCopy, Stream fsSrc, int nOffset);
    public virtual int InitNewBlock(Stream fsSrc, int nBlockSize, int nFileOffset);
    public int 1Co=();
    public virtual int GetBlockClass();
    public int 1So=();
    public int 1io=(int nOffset);
    public int 1yo=(int nOffset);
    public int 2Co=(int nOffset, bool bForceReadFromFile, bool bOffsetIsEndOfData);
    public void 2So=(int nOffset);
    public int 2io=();
    public int 2yo=();
    public int 3Co=();
    public virtual int ReadBytes(int numBytes, Byte[] pabyDstBuf);
    public byte 3So=();
    public short 3io=();
    public int 3yo=();
    public double 4Co=();
    public virtual int WriteBytes(int nBytesToWrite, Byte[] pabySrcBuf);
    public int 4So=(byte byValue);
    public int 4io=(short n16Value);
    public int 4yo=(int n32Value);
    public int 5Co=(double dValue);
    public int 5So=(int nBytesToWrite);
    public Byte[] 5io=();
    public int 5yo=();
    public Byte[] 6Co=();
}
internal class GRU=.Yxo= : iBo= {
    internal Yxo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Yy8= : object {
}
internal class GRU=.yyc= : 2Cc= {
    public sSc=[] zCc=;
    private tCc=[] vCc=;
    public virtual int jxU=();
    public string zSc=(Int32& bDefault);
    public double BSA=(Int32& bDefault);
    public string zic=(Int32& bDefault);
    public string vyc=(Int32& bDefault);
    public string wCc=(0yY= eParam, Int32& bValueIsNull);
    public double zyc=(0yY= eParam, Int32& bValueIsNull);
}
internal abstract class GRU=.Yyc= : object {
    private pSc= ZCc=;
    protected int ZSc=;
    public abstract virtual Yyc= Zic=();
    public abstract virtual void Zyc=(Gyc= psEnvelope);
    public virtual int aCc=();
    public abstract virtual piY= aSc=(String& ppszDstText);
    public abstract virtual qyY= aic=();
    public abstract virtual string ayc=();
    public virtual void bCc=(int nNewDimension);
    public void bSc=(pSc= poSR);
    public pSc= bic=();
    public virtual int byc=(Yyc= poOtherGeom);
}
internal class GRU=.yyM= : object {
    [CompilerGeneratedAttribute]
private string yCM=;
    [CompilerGeneratedAttribute]
private JsonElement zCM=;
    [CompilerGeneratedAttribute]
private DateTime zSM=;
    [CompilerGeneratedAttribute]
private List`1<xSM=> uyM=;
    [CompilerGeneratedAttribute]
private int ziM=;
    [JsonPropertyNameAttribute("type")]
[ObfuscationAttribute]
public string Type { get; public set; }
    [JsonPropertyNameAttribute("features")]
[ObfuscationAttribute]
public JsonElement Features { get; public set; }
    [JsonPropertyNameAttribute("timeStamp")]
[ObfuscationAttribute]
public DateTime TimeStamp { get; public set; }
    [JsonPropertyNameAttribute("links")]
[ObfuscationAttribute]
public List`1<xSM=> Links { get; public set; }
    [JsonPropertyNameAttribute("numberReturned")]
[ObfuscationAttribute]
public int NumberReturned { get; public set; }
    public yyM=(string type, JsonElement features, DateTime timeStamp, List`1<xSM=> links, int numberReturned);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public JsonElement get_Features();
    [CompilerGeneratedAttribute]
public void set_Features(JsonElement value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeStamp();
    [CompilerGeneratedAttribute]
public void set_TimeStamp(DateTime value);
    [CompilerGeneratedAttribute]
public List`1<xSM=> get_Links();
    [CompilerGeneratedAttribute]
public void set_Links(List`1<xSM=> value);
    [CompilerGeneratedAttribute]
public int get_NumberReturned();
    [CompilerGeneratedAttribute]
public void set_NumberReturned(int value);
}
internal class GRU=.yyw= : object {
    private string zCw=;
    private ICryptoTransform zSw=;
    private ICryptoTransform ziw=;
    public string 0Cw= { get; }
    public yyw=(string password);
    public string zyw=();
    private void 0Sw=(string password);
    public Byte[] 0iw=(Byte[] inputBytes);
    public Byte[] 0yw=(Byte[] inputBytes, int offSet, int count);
    public ICryptoTransform 1Cw=(string password, int cipherMode, Byte[] providerIV, int paddingMode);
    public ICryptoTransform 1Sw=(string password, int cipherMode, Byte[] providerIV, int paddingMode);
}
internal class GRU=.ZBo= : iBo= {
    internal double fxc=;
    internal double Rxk=;
    internal double SBk=;
    internal double SRk=;
    internal double Shk=;
    internal double Sxk=;
    internal ZBo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
    private int TBk=(vhg= pjConsts, Double[] del, Int32& pj_Error);
}
internal enum GRU=.zC8= : Enum {
    public int value__;
    public static zC8= uC8=;
    public static zC8= uS8=;
    public static zC8= zS8=;
    public static zC8= zi8=;
    public static zC8= zy8=;
    public static zC8= 0C8=;
    public static zC8= 0S8=;
    public static zC8= ui8=;
    public static zC8= uy8=;
    public static zC8= 0i8=;
    public static zC8= 0y8=;
    public static zC8= 1C8=;
    public static zC8= 1S8=;
}
internal class GRU=.ZC8= : object {
    private string ZS8=;
    private string Zi8=;
    private string Zy8=;
    private string OC8=;
    private string OS8=;
    private string Oi8=;
    private string aC8=;
    private string aS8=;
    public string bC8= { get; public set; }
    public string by8= { get; public set; }
    public string PS8= { get; public set; }
    public string QC8= { get; public set; }
    public string Qy8= { get; public set; }
    public string 3C4= { get; public set; }
    public string ci8= { get; public set; }
    public string ai8=();
    public void ay8=(string value);
    public string bS8=();
    public void bi8=(string value);
    public string Oy8=();
    public void PC8=(string value);
    public string Pi8=();
    public void Py8=(string value);
    public string QS8=();
    public void Qi8=(string value);
    public string 2i4=();
    public void 2y4=(string value);
    public string cC8=();
    public void cS8=(string value);
    public void oBw=(BinaryReader reader);
}
internal class GRU=.Zhk= : iBo= {
    internal double Zxk=;
    internal double Qhk=;
    internal double aBk=;
    internal Zhk=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.Zho= : iBo= {
    internal Zho=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
internal class GRU=.zhU= : object {
    internal static string zxU=;
    private static Dictionary`2<string, 2xU=> 0BU=;
    internal static String[] 0RU=(string fileName, string keyFieldName, string value, yhU= criteria, IFormatProvider provider);
    internal static int 0hU=(string fileName, string keyFieldName);
    internal static string 0xU=(string baseName);
    internal static string 1BU=(string fileName, string keyFieldName, string keyFieldValue, yhU= criteria, string targetField, IFormatProvider provider);
    internal static String[] 1RU=(string fileName);
    private static string 1hU=(string baseName);
    internal static String[] 1xU=(string csvFileName, String[] columnNames);
    private static List`1<string> 2BU=(string recordLine);
    private static 2xU= 2RU=(string fileName);
    private static DataTable 2hU=(string fileName);
}
internal enum GRU=.ziY= : Enum {
    public int value__;
    public static ziY= zyY=;
    public static ziY= 0CY=;
    public static ziY= 0SY=;
    public static ziY= 0iY=;
}
internal class GRU=.ZRo= : iBo= {
    internal double fxc=;
    internal double sxc=;
    internal ZRo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
[ExtensionAttribute]
internal static class GRU=.Zx0= : object {
    [ExtensionAttribute]
internal static T aB0=(JObject jObject, string key, Func`2<string, T> converter);
    [ExtensionAttribute]
internal static T aB0=(JObject jObject, String[] keys, Func`2<String[], T> converter);
    [ExtensionAttribute]
internal static Nullable`1<T> aR0=(string s);
    [ExtensionAttribute]
internal static bool ah0=(GeoBrush geoBrush);
    [ExtensionAttribute]
internal static bool ah0=(GeoPen geoPen);
    [AsyncStateMachineAttribute("GRU=.Zx0=/7T4=")]
[ExtensionAttribute]
public static Task`1<WebResponse> ax0=(WebRequest request, CancellationToken cancellationToken);
}
internal class GRU=.Zxo= : iBo= {
    internal double shc=;
    internal Zxo=(string id, string desc);
    private void 8xg=();
    internal virtual vhg= 9Bg=(vhg= pjConsts, Int32& pj_Error);
    internal virtual void /xg=(lhg= lp, vhg= pjConsts, SRg= fac, Int32& pj_Error);
    internal virtual lhg= /Rg=(lRo= xy, vhg= pjConsts, Int32& pj_Error);
    internal virtual lRo= /hg=(lhg= lp, vhg= pjConsts, Int32& pj_Error);
}
[CompilerGeneratedAttribute]
internal class iD0= : object {
    internal static long iT0=;
    internal static dEE= ij0=;
    internal static dkE= iz0=;
    internal static dEE= jD0=;
    internal static hEE= jT0=;
    internal static long jj0=;
    internal static fEE= jz0=;
    internal static cEE= kD0=;
    internal static jkE= kT0=;
    internal static dEE= kj0=;
    internal static dEE= kz0=;
    internal static eUE= lD0=;
    internal static fEE= lT0=;
    internal static dEE= lj0=;
    internal static hUE= lz0=;
    internal static ikE= mD0=;
    internal static dUE= mT0=;
    internal static dEE= mj0=;
    internal static iEE= mz0=;
    internal static hUE= nD0=;
    internal static hUE= nT0=;
    internal static g0E= nj0=;
    internal static dEE= nz0=;
    internal static cUE= oD0=;
    internal static e0E= oT0=;
    internal static hUE= oj0=;
    internal static g0E= oz0=;
    internal static dEE= pD0=;
    internal static gEE= pT0=;
    internal static h0E= pj0=;
    internal static gUE= pz0=;
    internal static gUE= qD0=;
    internal static hkE= qT0=;
    internal static dEE= qj0=;
    internal static f0E= qz0=;
    internal static hUE= rD0=;
    internal static hUE= rT0=;
    internal static iUE= rj0=;
    internal static i0E= rz0=;
    internal static jEE= sD0=;
    internal static ckE= sT0=;
    internal static cUE= sj0=;
    internal static fkE= sz0=;
    internal static gEE= tD0=;
    internal static dUE= tT0=;
    internal static iUE= tj0=;
    internal static dEE= tz0=;
    internal static c0E= uD0=;
    internal static cUE= uT0=;
    internal static gEE= uj0=;
    internal static ckE= uz0=;
    internal static fUE= vD0=;
    internal static ckE= vT0=;
    internal static dUE= vj0=;
    internal static hUE= vz0=;
    internal static dEE= wD0=;
    internal static eEE= wT0=;
    internal static fkE= wj0=;
    internal static c0E= wz0=;
    internal static dEE= xD0=;
    internal static dEE= xT0=;
    internal static jUE= xj0=;
    internal static eUE= xz0=;
    internal static d0E= yD0=;
    internal static fEE= yT0=;
    internal static dUE= yj0=;
    internal static dEE= yz0=;
    internal static ckE= zD0=;
    internal static e0E= zT0=;
    internal static d0E= zj0=;
    internal static gkE= zz0=;
    internal static ckE= 0D0=;
    internal static dEE= 0T0=;
    internal static e0E= 0j0=;
    internal static dEE= 0z0=;
    internal static f0E= 1D0=;
    internal static gEE= 1T0=;
    internal static ekE= 1j0=;
    internal static ckE= 1z0=;
    internal static UInt32 2D0=(string s);
}
[CompilerGeneratedAttribute]
internal class oRM= : object {
    [DebuggerBrowsableAttribute("0")]
private <Name>j__TPar ohM=;
    [DebuggerBrowsableAttribute("0")]
private <Value>j__TPar oxM=;
    public <Name>j__TPar pRM= { get; }
    public <Value>j__TPar pxM= { get; }
    [DebuggerHiddenAttribute]
public oRM=(<Name>j__TPar Name, <Value>j__TPar Value);
    public <Name>j__TPar pBM=();
    public <Value>j__TPar phM=();
    [DebuggerHiddenAttribute]
public virtual bool Equals(object value);
    [DebuggerHiddenAttribute]
public virtual int GetHashCode();
    [DebuggerHiddenAttribute]
public virtual string ToString();
}
[CompilerGeneratedAttribute]
internal class qBM= : object {
    [DebuggerBrowsableAttribute("0")]
private <Memebers>j__TPar qRM=;
    public <Memebers>j__TPar qxM= { get; }
    [DebuggerHiddenAttribute]
public qBM=(<Memebers>j__TPar Memebers);
    public <Memebers>j__TPar qhM=();
    [DebuggerHiddenAttribute]
public virtual bool Equals(object value);
    [DebuggerHiddenAttribute]
public virtual int GetHashCode();
    [DebuggerHiddenAttribute]
public virtual string ToString();
}
[CompilerGeneratedAttribute]
internal class rBM= : object {
    [DebuggerBrowsableAttribute("0")]
private <Data>j__TPar rRM=;
    public <Data>j__TPar rxM= { get; }
    [DebuggerHiddenAttribute]
public rBM=(<Data>j__TPar Data);
    public <Data>j__TPar rhM=();
    [DebuggerHiddenAttribute]
public virtual bool Equals(object value);
    [DebuggerHiddenAttribute]
public virtual int GetHashCode();
    [DebuggerHiddenAttribute]
public virtual string ToString();
}
[CompilerGeneratedAttribute]
internal class sBM= : object {
    [DebuggerBrowsableAttribute("0")]
private <access_token>j__TPar sRM=;
    [DebuggerBrowsableAttribute("0")]
private <expires_in>j__TPar shM=;
    [DebuggerBrowsableAttribute("0")]
private <token_type>j__TPar sxM=;
    public <access_token>j__TPar tRM= { get; }
    public <expires_in>j__TPar txM= { get; }
    public <token_type>j__TPar uRM= { get; }
    [DebuggerHiddenAttribute]
public sBM=(<access_token>j__TPar access_token, <expires_in>j__TPar expires_in, <token_type>j__TPar token_type);
    public <access_token>j__TPar tBM=();
    public <expires_in>j__TPar thM=();
    public <token_type>j__TPar uBM=();
    [DebuggerHiddenAttribute]
public virtual bool Equals(object value);
    [DebuggerHiddenAttribute]
public virtual int GetHashCode();
    [DebuggerHiddenAttribute]
public virtual string ToString();
}
public class SecureTeam.Attributes.ObfuscatedByAgileDotNetAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTimestampAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string yBM=;
    public string Timestamp { get; }
    public AssemblyTimestampAttribute(string timestamp);
    [CompilerGeneratedAttribute]
public string get_Timestamp();
}
public class ThinkGeo.Core.AddedGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    [ObfuscationAttribute]
private string key;
    public object Item { get; public set; }
    public string Key { get; public set; }
    public AddedGeoCollectionEventArgs(object item);
    public AddedGeoCollectionEventArgs(object item, string key);
    public object get_Item();
    public void set_Item(object value);
    public string get_Key();
    public void set_Key(string value);
}
public class ThinkGeo.Core.AddingGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    public object Item { get; public set; }
    public AddingGeoCollectionEventArgs(object item);
    public object get_Item();
    public void set_Item(object value);
}
public abstract class ThinkGeo.Core.AdornmentLayer : Layer {
    [ObfuscationAttribute]
private float xOffsetInPixel;
    [ObfuscationAttribute]
private float yOffsetInPixel;
    [ObfuscationAttribute]
private AdornmentLocation location;
    [ObfuscationAttribute]
private float width;
    [ObfuscationAttribute]
private float height;
    [ObfuscationAttribute]
private AreaStyle backgroundMask;
    public float Width { get; public set; }
    public float Height { get; public set; }
    public AreaStyle BackgroundMask { get; public set; }
    public AdornmentLocation Location { get; public set; }
    public float XOffsetInPixel { get; public set; }
    public float YOffsetInPixel { get; public set; }
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public AreaStyle get_BackgroundMask();
    public void set_BackgroundMask(AreaStyle value);
    public AdornmentLocation get_Location();
    public void set_Location(AdornmentLocation value);
    public float get_XOffsetInPixel();
    public void set_XOffsetInPixel(float value);
    public float get_YOffsetInPixel();
    public void set_YOffsetInPixel(float value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    public virtual ScreenPointF GetDrawingLocation(GeoCanvas canvas, float adornmentWidth, float adornmentHeight);
}
public enum ThinkGeo.Core.AdornmentLocation : Enum {
    public int value__;
    public static AdornmentLocation UseOffsets;
    public static AdornmentLocation UpperLeft;
    public static AdornmentLocation UpperCenter;
    public static AdornmentLocation UpperRight;
    public static AdornmentLocation CenterLeft;
    public static AdornmentLocation Center;
    public static AdornmentLocation CenterRight;
    public static AdornmentLocation LowerLeft;
    public static AdornmentLocation LowerCenter;
    public static AdornmentLocation LowerRight;
}
public enum ThinkGeo.Core.AngleUnit : Enum {
    public int value__;
    public static AngleUnit Degrees;
    public static AngleUnit Radians;
    public static AngleUnit Gradians;
}
public enum ThinkGeo.Core.ApplyUntilZoomLevel : Enum {
    public int value__;
    public static ApplyUntilZoomLevel None;
    public static ApplyUntilZoomLevel Level01;
    public static ApplyUntilZoomLevel Level02;
    public static ApplyUntilZoomLevel Level03;
    public static ApplyUntilZoomLevel Level04;
    public static ApplyUntilZoomLevel Level05;
    public static ApplyUntilZoomLevel Level06;
    public static ApplyUntilZoomLevel Level07;
    public static ApplyUntilZoomLevel Level08;
    public static ApplyUntilZoomLevel Level09;
    public static ApplyUntilZoomLevel Level10;
    public static ApplyUntilZoomLevel Level11;
    public static ApplyUntilZoomLevel Level12;
    public static ApplyUntilZoomLevel Level13;
    public static ApplyUntilZoomLevel Level14;
    public static ApplyUntilZoomLevel Level15;
    public static ApplyUntilZoomLevel Level16;
    public static ApplyUntilZoomLevel Level17;
    public static ApplyUntilZoomLevel Level18;
    public static ApplyUntilZoomLevel Level19;
    public static ApplyUntilZoomLevel Level20;
}
public class ThinkGeo.Core.ArcGisServerRestAsyncLayer : WebBasedAsyncLayer {
    [ObfuscationAttribute]
private Dictionary`2<string, string> parameters;
    [ObfuscationAttribute]
private ArcGISServerRestLayerImageFormat imageFormat;
    [ObfuscationAttribute]
private bool enableImageFormat;
    [CompilerGeneratedAttribute]
private Uri 7R0=;
    public Uri ServerUri { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public ArcGISServerRestLayerImageFormat ImageFormat { get; public set; }
    public ArcGisServerRestAsyncLayer(Uri serverUri);
    public ArcGisServerRestAsyncLayer(Uri serverUri, IWebProxy webProxy);
    [CompilerGeneratedAttribute]
public Uri get_ServerUri();
    [CompilerGeneratedAttribute]
public void set_ServerUri(Uri value);
    public Dictionary`2<string, string> get_Parameters();
    public ArcGISServerRestLayerImageFormat get_ImageFormat();
    public void set_ImageFormat(ArcGISServerRestLayerImageFormat value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ArcGisServerRestAsyncLayer/CD8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private string 7h0=(Dictionary`2<string, string> tempDictionary);
}
public enum ThinkGeo.Core.ArcGISServerRestLayerImageFormat : Enum {
    public int value__;
    public static ArcGISServerRestLayerImageFormat Png;
    public static ArcGISServerRestLayerImageFormat Png8;
    public static ArcGISServerRestLayerImageFormat Png24;
    public static ArcGISServerRestLayerImageFormat Jpeg;
    public static ArcGISServerRestLayerImageFormat Gif;
}
public abstract class ThinkGeo.Core.AreaBaseShape : BaseShape {
    public double GetPerimeter(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public double GetArea(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    public static AreaBaseShape ScaleUp(AreaBaseShape targetShape, double percentage);
    public static Feature ScaleUp(Feature targetFeature, double percentage);
    public void ScaleUp(double percentage);
    public double GetArea(int shapeSrid, AreaUnit returningUnit);
    public double GetArea(string shapeProjString, AreaUnit returningUnit);
    public double GetArea(Projection shapeProjection, AreaUnit returningUnit);
    public double GetArea(int shapeSrid, AreaUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetArea(string shapeProjString, AreaUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetArea(Projection shapeProjection, AreaUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    protected virtual double GetAreaCore(Projection shapeProjection, AreaUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetPerimeter(int shapeSrid, DistanceUnit returningUnit);
    public double GetPerimeter(string shapeProjString, DistanceUnit returningUnit);
    public double GetPerimeter(Projection shapeProjection, DistanceUnit returningUnit);
    public double GetPerimeter(int shapeSrid, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetPerimeter(string shapeProjString, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetPerimeter(Projection shapeProjection, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    protected virtual double GetPerimeterCore(Projection shapeProjection, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    protected virtual void ScaleUpCore(double percentage);
    public static AreaBaseShape ScaleDown(AreaBaseShape targetShape, double percentage);
    public static Feature ScaleDown(Feature targetFeature, double percentage);
    public void ScaleDown(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    public RingShape GetConvexHull();
    protected virtual RingShape GetConvexHullCore();
    public MultipolygonShape GetIntersection(AreaBaseShape targetShape);
    public MultipolygonShape GetIntersection(Feature targetFeature);
    protected virtual MultipolygonShape GetIntersectionCore(AreaBaseShape targetShape);
    public virtual MultipolygonShape Union(AreaBaseShape targetShape);
    public MultipolygonShape Union(Feature targetFeature);
    protected virtual MultipolygonShape UnionCore(AreaBaseShape targetShape);
    public static MultipolygonShape Union(IEnumerable`1<Feature> targetFeatures);
    public static MultipolygonShape Union(IEnumerable`1<AreaBaseShape> areaShapes);
    private static MultipolygonShape zBo=(IEnumerable`1<BaseShape> areaShapes, bool isPrivate);
    private static BaseShape zRo=(IEnumerable`1<BaseShape> areaShapes, int count);
    public MultipolygonShape GetDifference(AreaBaseShape targetShape);
    public MultipolygonShape GetDifference(Feature targetFeature);
    protected virtual MultipolygonShape GetDifferenceCore(AreaBaseShape targetShape);
    public MultipolygonShape GetSymmetricalDifference(AreaBaseShape targetShape);
    public MultipolygonShape GetSymmetricalDifference(Feature targetFeature);
    protected virtual MultipolygonShape GetSymmetricalDifferenceCore(AreaBaseShape targetShape);
    public static Collection`1<MultipolygonShape> Split(AreaBaseShape areaToSplit, AreaBaseShape areaToSplitBy);
    public static Collection`1<Feature> Split(Feature areaToSplit, Feature areaToSplitBy);
    public static MultipolygonShape Simplify(AreaBaseShape targetShape, GeographyUnit targetShapeUnit, double tolerance, DistanceUnit toleranceUnit, SimplificationType simplificationType);
    public static MultipolygonShape Simplify(AreaBaseShape targetShape, double tolerance, SimplificationType simplificationType);
    public MultipolygonShape Simplify(GeographyUnit shapeUnit, double tolerance, DistanceUnit toleranceUnit, SimplificationType simplificationType);
    public MultipolygonShape Simplify(double tolerance, SimplificationType simplificationType);
    protected virtual MultipolygonShape SimplifyCore(double tolerance, SimplificationType simplificationType);
    private static void zho=(MultipolygonShape returnMultipolygon, GeometryCollection geometryCollection);
    private void SRU=(double factor);
    public static Collection`1<PolygonShape> Snap(IEnumerable`1<AreaBaseShape> shapes, GeographyUnit shapeUnit, double snappingTolerance, DistanceUnit toleranceUnit);
    private static bool zxo=(IEnumerable`1<PolygonShape> polygonShapes, double tolerance);
    private static bool 0Bo=(Collection`1<PolygonShape> polygons, double tolerance);
    private static bool 0Ro=(IEnumerable`1<PolygonShape> polygons, PolygonShape polygon, RingShape ringShape, double tolerance, STRtree`1<BaseShape> rTree, Collection`1<Vertex> checkedVertices, double squareTolerance, Boolean& noClusterTolerance);
    private static void 0ho=(string id, Vertex vertex, IList`1<BaseShape> intersectingPolys);
    private static bool 0xo=(Vertex currentVertex, PolygonShape currentPolygonShape, int currentVertexIndex, PolygonShape closestPolygonShape, PointShape closestPoint);
    private static void 1Bo=(Vertex currentVertex, RingShape currentRing, int currentVertexIndex, RingShape closestRing, PointShape closestPoint, Boolean& updateSucceed);
    private static bool 1Ro=(PolygonShape polygonShape, PolygonShape intersectingPolygon);
    private static bool 1ho=(RingShape polygonRing, RingShape intersectingRing);
    private static bool 1Bo=(IEnumerable`1<PolygonShape> polygonShapes, RingShape ringShape, double tolerance, Collection`1<Vertex> checkedVertices, Collection`1<Vertex> updatedVertices, STRtree`1<BaseShape> rTree, Boolean& noClusterTolerance);
    private static bool 1xo=(IEnumerable`1<PolygonShape> polygonShapes, RingShape ringShape, Vertex vertex, double squareTolerance, Feature feature, Collection`1<PointShape> pendingUpdatedVertex, Collection`1<KeyValuePair`2<RingShape, int>> pendingUpdatedVertexIndex);
    private static void 2Bo=(Collection`1<KeyValuePair`2<RingShape, int>> ringsCache, Vertex newVertex);
}
public class ThinkGeo.Core.AreaFilterCondition : FilterCondition {
    [ObfuscationAttribute]
private AreaUnit caculatedAreaUnit;
    private GeographyUnit vzE=;
    public AreaUnit AreaUnit { get; public set; }
    public GeographyUnit GeographyUnit { get; public set; }
    public AreaFilterCondition(AreaUnit areaUnit);
    public AreaUnit get_AreaUnit();
    public void set_AreaUnit(AreaUnit value);
    public GeographyUnit get_GeographyUnit();
    public void set_GeographyUnit(GeographyUnit value);
    internal virtual bool SSM=(Feature feature);
}
public class ThinkGeo.Core.AreaStyle : Style {
    [ObfuscationAttribute]
private Collection`1<AreaStyle> customAreaStyles;
    [ObfuscationAttribute]
private GeoBrush fillBrush;
    [ObfuscationAttribute]
private GeoPen outlinePen;
    [ObfuscationAttribute]
private PenBrushDrawingOrder penBrushDrawingOrder;
    [ObfuscationAttribute]
private float xOffsetInPixel;
    [ObfuscationAttribute]
private float yOffsetInPixel;
    [ObfuscationAttribute]
private DrawingLevel drawingLevel;
    [CompilerGeneratedAttribute]
private AreaStyle 9TA=;
    public float XOffsetInPixel { get; public set; }
    public float YOffsetInPixel { get; public set; }
    public GeoBrush FillBrush { get; public set; }
    public Collection`1<AreaStyle> CustomAreaStyles { get; }
    public GeoPen OutlinePen { get; public set; }
    public PenBrushDrawingOrder PenBrushDrawingOrder { get; public set; }
    public DrawingLevel DrawingLevel { get; public set; }
    internal AreaStyle /DA= { get; internal set; }
    internal bool ohU= { get; }
    public AreaStyle(GeoBrush fillBrush);
    public AreaStyle(GeoPen outlinePen);
    public AreaStyle(GeoPen outlinePen, GeoBrush fillBrush);
    public AreaStyle(GeoPen outlinePen, GeoBrush fillBrush, PenBrushDrawingOrder penBrushDrawingOrder);
    public float get_XOffsetInPixel();
    public void set_XOffsetInPixel(float value);
    public float get_YOffsetInPixel();
    public void set_YOffsetInPixel(float value);
    public GeoBrush get_FillBrush();
    public void set_FillBrush(GeoBrush value);
    public Collection`1<AreaStyle> get_CustomAreaStyles();
    public GeoPen get_OutlinePen();
    public void set_OutlinePen(GeoPen value);
    public PenBrushDrawingOrder get_PenBrushDrawingOrder();
    public void set_PenBrushDrawingOrder(PenBrushDrawingOrder value);
    public DrawingLevel get_DrawingLevel();
    public void set_DrawingLevel(DrawingLevel value);
    [CompilerGeneratedAttribute]
internal AreaStyle 9jA=();
    [CompilerGeneratedAttribute]
internal void 9zA=(AreaStyle value);
    internal virtual bool oBU=();
    public static AreaStyle Parse(string styleJson);
    internal static AreaStyle jxU=(JObject jObject);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor, int outlinePenWidth);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor, int outlinePenWidth, LineDashStyle borderStyle);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, float xOffsetInPixel, float yOffsetInPixel);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor, float xOffsetInPixel, float yOffsetInPixel);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor, int outlinePenWidth, float xOffsetInPixel, float yOffsetInPixel);
    public static AreaStyle CreateSimpleAreaStyle(GeoColor fillBrushColor, GeoColor outlinePenColor, int outlinePenWidth, LineDashStyle borderStyle, float xOffsetInPixel, float yOffsetInPixel);
    public static AreaStyle CreateHatchStyle(GeoHatchStyle hatchStyle, GeoColor foregroundBrushColor, GeoColor backgroundBrushColor);
    public static AreaStyle CreateHatchStyle(GeoHatchStyle hatchStyle, GeoColor foregroundBrushColor, GeoColor backgroundBrushColor, GeoColor outlinePenColor);
    public static AreaStyle CreateHatchStyle(GeoHatchStyle hatchStyle, GeoColor foregroundBrushColor, GeoColor backgroundColor, GeoColor outlinePenColor, int outlinePenWidth, LineDashStyle outlineDashStyle, float xOffsetInPixel, float yOffsetInPixel);
    public static AreaStyle CreateLinearGradientStyle(GeoColor fromColor, GeoColor toColor, float angle);
    public static AreaStyle CreateLinearGradientStyle(GeoColor fromColor, GeoColor toColor, float angle, GeoColor outlinePenColor);
    public static AreaStyle CreateHueFamilyAreaStyle(GeoColor outlinePenColor, GeoColor baseColor, int numberOfColors);
    public static AreaStyle CreateHueFamilyLinearGradientAreaStyle(GeoColor outlinePenColor, GeoColor baseColor, int numberOfColors, GeoColor fromColor, GeoColor toColor, float angle);
    public static AreaStyle CreateQualityFamilyAreaStyle(GeoColor outlinePenColor, GeoColor baseColor, int numberOfColors);
    public static AreaStyle CreateQualityFamilyLinearGradientAreaStyle(GeoColor outlinePenColor, GeoColor baseColor, int numberOfColors, GeoColor fromColor, GeoColor toColor, float angle);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void /TA=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers, IEnumerable`1<Feature> featureList);
    private GeoPen /jA=();
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    private static List`1<Feature> /zA=(RectangleShape currentExtent, IEnumerable`1<Feature> featureList);
    private static bool ADE=(AreaBaseShape currentAreaShape);
    private static GeoPen ATE=(String[] valueExpressions);
    private static GeoBrush AjE=(String[] valueExpressions);
}
public enum ThinkGeo.Core.AreaUnit : Enum {
    public int value__;
    public static AreaUnit Acres;
    public static AreaUnit SquareMeters;
    public static AreaUnit Hectares;
    public static AreaUnit SquareFeet;
    public static AreaUnit SquareKilometers;
    public static AreaUnit SquareMiles;
    public static AreaUnit SquareUsSurveyFeet;
    public static AreaUnit SquareYards;
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.ArcGisServerRestAsyncLayer instead")]
public class ThinkGeo.Core.Async.ArcGisServerRestLayer : WebBasedLayer {
    [ObfuscationAttribute]
private Dictionary`2<string, string> parameters;
    [ObfuscationAttribute]
private ArcGISServerRestLayerImageFormat imageFormat;
    [ObfuscationAttribute]
private bool enableImageFormat;
    [CompilerGeneratedAttribute]
private Uri 7R0=;
    public Uri ServerUri { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public ArcGISServerRestLayerImageFormat ImageFormat { get; public set; }
    public ArcGisServerRestLayer(Uri serverUri);
    public ArcGisServerRestLayer(Uri serverUri, IWebProxy webProxy);
    [CompilerGeneratedAttribute]
public Uri get_ServerUri();
    [CompilerGeneratedAttribute]
public void set_ServerUri(Uri value);
    public Dictionary`2<string, string> get_Parameters();
    public ArcGISServerRestLayerImageFormat get_ImageFormat();
    public void set_ImageFormat(ArcGISServerRestLayerImageFormat value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ArcGisServerRestLayer/CD8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private string 7h0=(Dictionary`2<string, string> tempDictionary);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.BingMapsAsyncLayer instead")]
public class ThinkGeo.Core.Async.BingMapsLayer : XyzTileLayer {
    private static int 9B0=;
    private static string 9R0=;
    private static string 9h0=;
    [ObfuscationAttribute]
private string applicationId;
    [ObfuscationAttribute]
private BingMapsMapType mapType;
    [ObfuscationAttribute]
private string imageUriTemplate;
    [ObfuscationAttribute]
private Collection`1<string> subDomains;
    [ObfuscationAttribute]
private GeoImage logo;
    [ObfuscationAttribute]
private bool isDirty;
    [ObfuscationAttribute]
private RequestProtocol httpRequestProtocol;
    public string ApplicationId { get; public set; }
    public BingMapsMapType MapType { get; public set; }
    public GeoImage Logo { get; }
    public RequestProtocol HttpRequestProtocol { get; public set; }
    public BingMapsLayer(string applicationId);
    public BingMapsLayer(string applicationId, BingMapsMapType mapType);
    private static BingMapsLayer();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.BingMapsLayer/Hz8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public string get_ApplicationId();
    public void set_ApplicationId(string value);
    public BingMapsMapType get_MapType();
    public void set_MapType(BingMapsMapType value);
    public GeoImage get_Logo();
    public RequestProtocol get_HttpRequestProtocol();
    public void set_HttpRequestProtocol(RequestProtocol value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.BingMapsLayer/HD8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.BingMapsLayer/HT8=")]
protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    private static string 9x0=(long tileX, long tileY, int levelOfDetail);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.BingMapsLayer/Ij8=")]
private Task /B0=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.BingMapsLayer/ID8=")]
private Task`1<XmlDocument> /R0=(string xmlPath);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task /h0=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /x0=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.GoogleMapsAsyncLayer instead")]
public class ThinkGeo.Core.Async.GoogleMapsLayer : WebBasedLayer {
    private static RectangleShape IB4=;
    [ObfuscationAttribute]
private ProjectionConverter projectionFromSphericalMercator;
    [ObfuscationAttribute]
private ProjectionConverter googleWgs84Projection;
    [ObfuscationAttribute]
private double currentRequestSphereResolution;
    [CompilerGeneratedAttribute]
private GoogleMapsPictureFormat IR4=;
    [CompilerGeneratedAttribute]
private GoogleMapsMapType Ih4=;
    [CompilerGeneratedAttribute]
private string Ix4=;
    [CompilerGeneratedAttribute]
private string Ax4=;
    [CompilerGeneratedAttribute]
private string JB4=;
    [CompilerGeneratedAttribute]
private string JR4=;
    [CompilerGeneratedAttribute]
private string Jh4=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> Jx4=;
    [CompilerGeneratedAttribute]
private Projection KB4=;
    public GoogleMapsPictureFormat PictureFormat { get; public set; }
    public GoogleMapsMapType MapType { get; public set; }
    public string Language { get; public set; }
    public string ClientId { get; public set; }
    public string PrivateKey { get; public set; }
    public string UriSigningSecret { get; public set; }
    public string ApiKey { get; public set; }
    public Dictionary`2<string, string> CustomParameters { get; }
    public Projection TargetProjection { get; public set; }
    public GoogleMapsLayer(string apiKey);
    public GoogleMapsLayer(string apiKey, string uriSigningSecret);
    private static GoogleMapsLayer();
    [CompilerGeneratedAttribute]
public GoogleMapsPictureFormat get_PictureFormat();
    [CompilerGeneratedAttribute]
public void set_PictureFormat(GoogleMapsPictureFormat value);
    [CompilerGeneratedAttribute]
public GoogleMapsMapType get_MapType();
    [CompilerGeneratedAttribute]
public void set_MapType(GoogleMapsMapType value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_PrivateKey();
    [CompilerGeneratedAttribute]
public void set_PrivateKey(string value);
    [CompilerGeneratedAttribute]
public string get_UriSigningSecret();
    [CompilerGeneratedAttribute]
public void set_UriSigningSecret(string value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_CustomParameters();
    [CompilerGeneratedAttribute]
public Projection get_TargetProjection();
    [CompilerGeneratedAttribute]
public void set_TargetProjection(Projection value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.GoogleMapsLayer/MD8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.GoogleMapsLayer/Kj8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.GoogleMapsLayer/Lz8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.GoogleMapsLayer/Kz8=")]
protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    private RectangleShape KR4=(GeoCanvas canvas);
    private string Kh4=(double latitude, double longitude, int zoomLevelNumber, double tileWidth, double tileHeight, int scaleFactor);
    private static string Kx4=(double newWidth, double newHeight, int zoomLevelNumber, double latitude, double longitude);
    private string LB4=();
    public string GetPictureFormat();
    private string LR4=(string url);
    private string LR4=(string url, string uriSigningSecret);
    private static Byte[] Lh4=(string value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /h0=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /x0=(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.HereMapsRasterTileAsyncLayer instead")]
public class ThinkGeo.Core.Async.HereMapsRasterTileLayer : XyzTileLayer {
    private static int 9B0=;
    private static string Lx4=;
    private string MB4=;
    private string MR4=;
    private string Mh4=;
    [CompilerGeneratedAttribute]
private string Jh4=;
    [CompilerGeneratedAttribute]
private HereMapsRasterType Ih4=;
    [CompilerGeneratedAttribute]
private HereMapsRasterTileFormat Mx4=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> NB4=;
    public string ApiKey { get; public set; }
    public HereMapsRasterType MapType { get; public set; }
    public HereMapsRasterTileFormat Format { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public HereMapsRasterTileLayer(string apiKey);
    public HereMapsRasterTileLayer(string apiKey, HereMapsRasterType mapType);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public HereMapsRasterType get_MapType();
    [CompilerGeneratedAttribute]
public void set_MapType(HereMapsRasterType value);
    [CompilerGeneratedAttribute]
public HereMapsRasterTileFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(HereMapsRasterTileFormat value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Parameters();
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.AsyncLayer instead")]
public abstract class ThinkGeo.Core.Async.LayerAsync : LayerBase {
    private Exception 7x0=;
    [CompilerGeneratedAttribute]
private double 8B0=;
    [CompilerGeneratedAttribute]
private double 8R0=;
    public double UpperThreshold { get; public set; }
    public double LowerThreshold { get; public set; }
    [CompilerGeneratedAttribute]
public double get_UpperThreshold();
    [CompilerGeneratedAttribute]
public void set_UpperThreshold(double value);
    [CompilerGeneratedAttribute]
public double get_LowerThreshold();
    [CompilerGeneratedAttribute]
public void set_LowerThreshold(double value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/Gj8=")]
public Task OpenAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/Gz8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/ET8=")]
public Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/Ej8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/Ez8=")]
public Task DrawAsync(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.LayerAsync/GD8=")]
private Task 8h0=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected abstract virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void 8x0=(object sender, DrawingProgressChangedEventArgs e);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.MapBoxStaticTilesAsyncLayer instead")]
public class ThinkGeo.Core.Async.MapBoxStaticTilesLayer : XyzTileLayer {
    private static int 9B0=;
    [ObfuscationAttribute]
private MapBoxStyleId styleId;
    [ObfuscationAttribute]
private string baseUrl;
    [ObfuscationAttribute]
private string apiVersion;
    [CompilerGeneratedAttribute]
private string NR4=;
    public string AccessToken { get; public set; }
    public MapBoxStyleId StyleId { get; public set; }
    public MapBoxStaticTilesLayer(string accessToken);
    public MapBoxStaticTilesLayer(string accessToken, MapBoxStyleId styleId);
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public void set_AccessToken(string value);
    public MapBoxStyleId get_StyleId();
    public void set_StyleId(MapBoxStyleId value);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    private string Nh4=();
    private void Nx4=(MapBoxStyleId id);
    private bool OB4=(string cacheId);
    private string OR4=(MapBoxStyleId id);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.OpenStreetMapAsyncLayer instead")]
public class ThinkGeo.Core.Async.OpenStreetMapLayer : XyzTileLayer {
    [ObfuscationAttribute]
private static int TILE_SIZE;
    [ObfuscationAttribute]
private static Uri[] DefaultUris;
    [ObfuscationAttribute]
private Collection`1<Uri> customServerUris;
    public Collection`1<Uri> CustomServerUris { get; }
    public OpenStreetMapLayer(string userAgent);
    public OpenStreetMapLayer(IWebProxy webProxy);
    public OpenStreetMapLayer(string userAgent, IWebProxy webProxy);
    private static OpenStreetMapLayer();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.OpenStreetMapLayer/MT8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public Collection`1<Uri> get_CustomServerUris();
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /h0=(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.ThinkGeoRasterMapsAsyncLayer instead")]
public class ThinkGeo.Core.Async.ThinkGeoCloudRasterMapsLayer : XyzTileLayer {
    private static int 9B0=;
    private AB4= Oh4=;
    private ThinkGeoCloudRasterMapsMapType Ox4=;
    public RasterTileCache TileCache { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public ProjectionConverter ProjectionConverterFromServerProjection { get; public set; }
    public ThinkGeoCloudRasterMapsMapType MapType { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public ThinkGeoCloudRasterMapsLayer(string clientId, string clientSecret);
    public ThinkGeoCloudRasterMapsLayer(string clientId, string clientSecret, ThinkGeoCloudRasterMapsMapType mapType);
    public virtual RasterTileCache get_TileCache();
    public virtual void set_TileCache(RasterTileCache value);
    public virtual RasterTileCache get_ProjectedTileCache();
    public virtual void set_ProjectedTileCache(RasterTileCache value);
    public virtual ProjectionConverter get_ProjectionConverterFromServerProjection();
    public virtual void set_ProjectionConverterFromServerProjection(ProjectionConverter value);
    public ThinkGeoCloudRasterMapsMapType get_MapType();
    public void set_MapType(ThinkGeoCloudRasterMapsMapType value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudRasterMapsLayer/Mz8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudRasterMapsLayer/Mj8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudRasterMapsLayer/ND8=")]
private void PB4=(object sender, SendingHttpRequestMessageEventArgs e);
    private void Nx4=();
    private string PR4=(string cacheIdWithSuffix);
    protected virtual int GetTileScale();
    private string Ph4=();
    private string Px4=(ThinkGeoCloudRasterMapsMapType mapType);
    private string QB4=(ThinkGeoCloudRasterMapsMapType mapType);
    private string QR4=(ThinkGeoCloudRasterMapsMapType mapType);
    private GeoImageFormat 8RY=(ThinkGeoCloudRasterMapsMapType mapType);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /h0=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /x0=(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer instead")]
public class ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer : WebBasedLayer {
    private static int Qh4=;
    [ObfuscationAttribute]
private Uri styleJsonUri;
    [ObfuscationAttribute]
private RasterTileCache bitmapTileCache;
    private ZoomLevelSet Qx4=;
    private AB4= Oh4=;
    private ThinkGeoCloudVectorMapsMapType Ox4=;
    private FileVectorTileCache RB4=;
    private ProjectionConverter RR4=;
    [CompilerGeneratedAttribute]
private bool Rh4=;
    [CompilerGeneratedAttribute]
private int Rx4=;
    private bool SB4=;
    public bool ShowDebugInfo { get; public set; }
    public int TileSize { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public ThinkGeoCloudVectorMapsMapType MapType { get; public set; }
    public FileVectorTileCache VectorTileCache { get; public set; }
    public RasterTileCache BitmapTileCache { get; public set; }
    public Uri StyleJsonUri { get; public set; }
    public ProjectionConverter ProjectionConverter { get; public set; }
    public ThinkGeoCloudVectorMapsLayer(string clientId, string clientSecret);
    public ThinkGeoCloudVectorMapsLayer(string clientId, string clientSecret, Uri styleJsonUri);
    public ThinkGeoCloudVectorMapsLayer(string clientId, string clientSecret, ThinkGeoCloudVectorMapsMapType mapType);
    [CompilerGeneratedAttribute]
public bool get_ShowDebugInfo();
    [CompilerGeneratedAttribute]
public void set_ShowDebugInfo(bool value);
    [CompilerGeneratedAttribute]
public int get_TileSize();
    [CompilerGeneratedAttribute]
public void set_TileSize(int value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    public ThinkGeoCloudVectorMapsMapType get_MapType();
    public void set_MapType(ThinkGeoCloudVectorMapsMapType value);
    public FileVectorTileCache get_VectorTileCache();
    public void set_VectorTileCache(FileVectorTileCache value);
    public RasterTileCache get_BitmapTileCache();
    public void set_BitmapTileCache(RasterTileCache value);
    public Uri get_StyleJsonUri();
    public void set_StyleJsonUri(Uri value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/MD8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/Kj8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/VD8=")]
private Task`1<Collection`1<Feature>> SR4=(int zoom, long column, long row, List`1<string> pbfLayerNames, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/VT8=")]
private Task`1<VectorTile> Sh4=(int zoom, long column, long row, CancellationToken cancellationToken);
    private void Sx4=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/UD8=")]
public Task DrawTileAsync(GeoCanvas canvas, int zoomIndex, long columnIndex, long rowIndex);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.ThinkGeoCloudVectorMapsLayer/QD8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void Nx4=(ThinkGeoCloudVectorMapsMapType mapType);
    private bool OB4=(string cacheId);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /h0=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /x0=(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.WebBasedAsyncLayer instead")]
public abstract class ThinkGeo.Core.Async.WebBasedLayer : LayerAsync {
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingHttpRequestMessageEventArgs> TB4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<ReceivedHttpResponseMessageEventArgs> TR4=;
    [CompilerGeneratedAttribute]
private HttpClient Th4=;
    [CompilerGeneratedAttribute]
private IWebProxy Bh4=;
    [CompilerGeneratedAttribute]
private int BR4=;
    [CompilerGeneratedAttribute]
private ICredentials Tx4=;
    [CompilerGeneratedAttribute]
private string UB4=;
    protected HttpClient HttpClient { get; protected set; }
    public IWebProxy WebProxy { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public ICredentials Credentials { get; public set; }
    public string UserAgent { get; public set; }
    [CompilerGeneratedAttribute]
public void add_SendingHttpRequest(EventHandler`1<SendingHttpRequestMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingHttpRequest(EventHandler`1<SendingHttpRequestMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ReceivedHttpResponse(EventHandler`1<ReceivedHttpResponseMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ReceivedHttpResponse(EventHandler`1<ReceivedHttpResponseMessageEventArgs> value);
    [CompilerGeneratedAttribute]
protected HttpClient get_HttpClient();
    [CompilerGeneratedAttribute]
protected void set_HttpClient(HttpClient value);
    [CompilerGeneratedAttribute]
public sealed virtual IWebProxy get_WebProxy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WebProxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TimeoutInSeconds();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TimeoutInSeconds(int value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WebBasedLayer/XT8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Credentials(ICredentials value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WebBasedLayer/Xj8=")]
protected Task`1<HttpResponseMessage> SendWebRequestAsync(HttpRequestMessage httpRequest, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual string get_UserAgent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UserAgent(string value);
    public Task`1<Byte[]> FetchImageAsync(HttpRequestMessage requestMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WebBasedLayer/WD8=")]
protected Task`1<Byte[]> FetchImageAsyncCore(HttpRequestMessage requestMessage, CancellationToken cancellationToken);
    public Task`1<Byte[]> DownloadImageAsync(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    protected virtual void OnSendingHttpRequestMessage(SendingHttpRequestMessageEventArgs e);
    protected virtual void OnReceivedHttpResponseMessage(ReceivedHttpResponseMessageEventArgs e);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /h0=(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.WmsAsyncLayer instead")]
public class ThinkGeo.Core.Async.WmsLayer : WebBasedLayer {
    private XmlDocument UR4=;
    [ObfuscationAttribute]
private string _crs;
    [ObfuscationAttribute]
private String[] _exceptionFormats;
    [ObfuscationAttribute]
private RectangleShape _currentExtent;
    [ObfuscationAttribute]
private WmsOnlineResource[] _wmsRequests;
    [ObfuscationAttribute]
private bool _hasParsedCapabilities;
    [ObfuscationAttribute]
private Collection`1<string> _serverCrsCollection;
    [ObfuscationAttribute]
private Collection`1<string> _serverLayerNames;
    [ObfuscationAttribute]
private Collection`1<string> _serverOutputFormats;
    [ObfuscationAttribute]
private Collection`1<string> _serverFeatureInfoFormats;
    [ObfuscationAttribute]
private Collection`1<string> _serverStyleNames;
    [ObfuscationAttribute]
private string _version;
    [ObfuscationAttribute]
private int _height;
    [ObfuscationAttribute]
private int _width;
    private WmsServerLayer Uh4=;
    private Collection`1<WmsServerLayer> Ux4=;
    [ObfuscationAttribute]
private Uri _uri;
    [ObfuscationAttribute]
private WmsAxisOrder _axisOrder;
    [ObfuscationAttribute]
private string _hrefNamespace;
    [ObfuscationAttribute]
private String[] _availableHrefNamespace;
    [ObfuscationAttribute]
private bool _fastMode;
    private static object VB4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedImageExceptionEventArgs> VR4=;
    [CompilerGeneratedAttribute]
private Collection`1<string> Vh4=;
    [CompilerGeneratedAttribute]
private Collection`1<string> Vx4=;
    [CompilerGeneratedAttribute]
private bool WB4=;
    [CompilerGeneratedAttribute]
private string WR4=;
    [CompilerGeneratedAttribute]
private string Wh4=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> NB4=;
    [CompilerGeneratedAttribute]
private TimeSpan Wx4=;
    public Collection`1<string> ActiveLayerNames { get; }
    public Collection`1<string> ActiveStyleNames { get; }
    public Uri Uri { get; public set; }
    public string Version { get; }
    public bool IsTransparent { get; public set; }
    public string OutputFormat { get; public set; }
    public string Crs { get; public set; }
    public string Exceptions { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public WmsAxisOrder AxisOrder { get; public set; }
    public bool FastMode { get; public set; }
    public TimeSpan CapabilitiesCacheTimeout { get; public set; }
    public bool HasBoundingBox { get; }
    public WmsLayer(Uri uri);
    public WmsLayer(Uri uri, IWebProxy webProxy);
    public WmsLayer(Uri uri, IWebProxy webProxy, string crs, WmsAxisOrder axisOrder, string version, bool fastMode);
    public WmsLayer(Collection`1<WmsServerLayer> flatWmsServerLayers);
    private static WmsLayer();
    [CompilerGeneratedAttribute]
public void add_RequestedImageException(EventHandler`1<RequestedImageExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedImageException(EventHandler`1<RequestedImageExceptionEventArgs> value);
    protected virtual void OnRequestedImageException(RequestedImageExceptionEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual Collection`1<string> get_ActiveLayerNames();
    [CompilerGeneratedAttribute]
public sealed virtual Collection`1<string> get_ActiveStyleNames();
    public sealed virtual Uri get_Uri();
    public sealed virtual void set_Uri(Uri value);
    public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsTransparent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsTransparent(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OutputFormat();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OutputFormat(string value);
    public sealed virtual string get_Crs();
    public sealed virtual void set_Crs(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Exceptions();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Exceptions(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Parameters();
    public sealed virtual WmsAxisOrder get_AxisOrder();
    public sealed virtual void set_AxisOrder(WmsAxisOrder value);
    public sealed virtual bool get_FastMode();
    public sealed virtual void set_FastMode(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_CapabilitiesCacheTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CapabilitiesCacheTimeout(TimeSpan value);
    public virtual bool get_HasBoundingBox();
    public Collection`1<WmsServerLayer> GetServerLayers();
    public Collection`1<string> GetServerStyleNames();
    public Collection`1<string> GetServerOutputFormats();
    public Collection`1<string> GetServerCrsCollection();
    public Collection`1<string> GetServerExceptionFormats();
    public string GetServiceVersion();
    public string GetServiceBaseUrl();
    public Collection`1<string> GetServerFeatureInfoFormats();
    public string GetServerCapabilitiesXml();
    public string GetRequestUrl(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    protected virtual string GetRequestUrlCore(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/ez8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/YT8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/Zj8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private bool rx0=();
    private static int XB4=(string texts, int fontSize);
    private static string whQ=(XmlDocument xmlDocument);
    private static string XR4=(string message, int width);
    private WmsOnlineResource Xh4=();
    private void Xx4=();
    private void YB4=(WmsServerLayer serverLayer);
    private void YR4=(WmsServerLayer serverLayer);
    private void Yh4=(WmsServerLayer serverLayer);
    private void Yx4=(WmsServerLayer layer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/fD8=")]
private Task ZB4=(string url, CancellationToken cancellationToken);
    private static void ZR4=(string requestCapabilities, XmlDocument xmlDocument);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/az8=")]
private Task`1<XmlDocument> Zh4=(string requestCapabilities);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/dz8=")]
private Task`1<XmlDocument> Zx4=(string requestCapabilities, IWebProxy proxy, ICredentials credentials, CancellationToken cancellationToken);
    private void aB4=(XmlDocument xmlDocument, XmlNamespaceManager namespaceManager);
    private static string aR4=(XmlNode node, string nodeName, XmlNamespaceManager namespaceManager);
    private void ah4=(XmlNode nodeCapability, XmlNamespaceManager namespaceManager);
    private void ax4=(XmlNode xmlRequestNode, XmlNamespaceManager namespaceManager);
    private WmsServerLayer bB4=(XmlNode xmlLayer, XmlNamespaceManager namespaceManager);
    private XmlAttribute bR4=(XmlNode xmlNode);
    private RectangleShape bh4=(XmlNode xmlLayer, XmlNamespaceManager namespaceManager);
    private void bx4=(XmlNode xnException, XmlNamespaceManager namespaceManager);
    private void cB4=(HttpRequestMessage httpRequestMessage);
    private static Collection`1<string> cR4=(IEnumerable`1<string> collection);
    private static Collection`1<WmsServerLayer> cR4=(IEnumerable`1<WmsServerLayer> collection);
    private void ch4=(string propertyName);
    protected virtual string BuildWmsGetFeatureInfoUri(ScreenPointF screenPointF, string infoFormat, int maxFeatures);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/cT8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/cj8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/cz8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, string infoFormat, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/bj8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfo(ScreenPointF screenPointF, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/dT8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, string infoFormat, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/dj8=")]
protected virtual Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsyncCore(ScreenPointF screenPointF, string infoFormat, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/Yj8=")]
protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmsLayer/eD8=")]
internal Task`1<Dictionary`2<string, Collection`1<Feature>>> cx4=(HttpRequestMessage request, CancellationToken cancellationToken);
    internal Dictionary`2<string, Collection`1<Feature>> dB4=(XmlDocument xmlDocument);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /h0=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /x0=(CancellationToken cancellationToken);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.WmtsAsyncLayer instead")]
public class ThinkGeo.Core.Async.WmtsLayer : XyzTileLayer {
    [ObfuscationAttribute]
private Collection`1<Uri> serverUris;
    [ObfuscationAttribute]
private Uri serverUri;
    [ObfuscationAttribute]
private Dictionary`2<string, WmtsTileMatrixSet> tileMatrixSets;
    [ObfuscationAttribute]
private Collection`1<WmtsServerLayer> wmtsServerLayers;
    [ObfuscationAttribute]
private string activeLayerName;
    [ObfuscationAttribute]
private string activeStyleName;
    [ObfuscationAttribute]
private WmtsSeverEncodingType wmtsSeverEncodingType;
    [ObfuscationAttribute]
private string tileMatrixSetName;
    [ObfuscationAttribute]
private Dictionary`2<string, string> parameters;
    [ObfuscationAttribute]
private string outputFormat;
    [ObfuscationAttribute]
private double lowerScale;
    [ObfuscationAttribute]
private double upperScale;
    [ObfuscationAttribute]
private XmlDocument xmlDoc;
    [ObfuscationAttribute]
private TimeSpan capabilitesCacheTimeout;
    [ObfuscationAttribute]
private double wmtsConversionFactorForMeter;
    [ObfuscationAttribute]
private Dictionary`2<string, string> dimensions;
    [ObfuscationAttribute]
private WmtsAxisOrder axisOrder;
    [ObfuscationAttribute]
private RasterTileCache projectedTileCache;
    [ObfuscationAttribute]
private bool isCacheOnly;
    [ObfuscationAttribute]
private Dictionary`2<WmtsSeverEncodingType, string> getTileEncodingTypes;
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.4. Please use ServerUri instead.")]
public Collection`1<Uri> ServerUris { get; }
    public Uri ServerUri { get; public set; }
    private Dictionary`2<string, string> dx4= { get; private set; }
    public TimeSpan CapabilitesCacheTimeout { get; public set; }
    public string ActiveLayerName { get; public set; }
    public WmtsSeverEncodingType WmtsSeverEncodingType { get; public set; }
    public Collection`1<WmtsServerLayer> WmtsServerLayers { get; public set; }
    public string ActiveStyleName { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public string OutputFormat { get; public set; }
    public double LowerScale { get; public set; }
    public double UpperScale { get; public set; }
    public string TileMatrixSetName { get; public set; }
    public WmtsAxisOrder AxisOrder { get; public set; }
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.3. Please use ProjectionConverterFromServerProjection instead. ")]
public ProjectionConverter ProjectionConverter { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public bool IsCacheOnly { get; public set; }
    public Dictionary`2<string, WmtsTileMatrixSet> TileMatrixSets { get; }
    public bool HasBoundingBox { get; }
    [ObsoleteAttribute("This constructor is obsoleted and will be removed after v14.4.")]
public WmtsLayer(IEnumerable`1<Uri> serverUris);
    [ObsoleteAttribute("This constructor is obsoleted and will be removed after v14.4.")]
public WmtsLayer(IEnumerable`1<Uri> serverUris, IWebProxy webProxy);
    [ObsoleteAttribute("This constructor is obsoleted and will be removed after v14.4.")]
public WmtsLayer(IEnumerable`1<Uri> serverUris, IWebProxy webProxy, WmtsSeverEncodingType wmtsSeverEncodingType);
    public WmtsLayer(Uri serverUri);
    public WmtsLayer(Uri serverUri, IWebProxy webProxy);
    public WmtsLayer(Uri serverUri, IWebProxy webProxy, WmtsSeverEncodingType wmtsSeverEncodingType);
    public Collection`1<Uri> get_ServerUris();
    public Uri get_ServerUri();
    public void set_ServerUri(Uri value);
    private Dictionary`2<string, string> dR4=();
    private void dh4=(Dictionary`2<string, string> value);
    public TimeSpan get_CapabilitesCacheTimeout();
    public void set_CapabilitesCacheTimeout(TimeSpan value);
    public string get_ActiveLayerName();
    public void set_ActiveLayerName(string value);
    public WmtsSeverEncodingType get_WmtsSeverEncodingType();
    public void set_WmtsSeverEncodingType(WmtsSeverEncodingType value);
    public Collection`1<WmtsServerLayer> get_WmtsServerLayers();
    public void set_WmtsServerLayers(Collection`1<WmtsServerLayer> value);
    public string get_ActiveStyleName();
    public void set_ActiveStyleName(string value);
    public Dictionary`2<string, string> get_Parameters();
    public string get_OutputFormat();
    public void set_OutputFormat(string value);
    public double get_LowerScale();
    public void set_LowerScale(double value);
    public double get_UpperScale();
    public void set_UpperScale(double value);
    public string get_TileMatrixSetName();
    public void set_TileMatrixSetName(string value);
    public WmtsAxisOrder get_AxisOrder();
    public void set_AxisOrder(WmtsAxisOrder value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    public RasterTileCache get_ProjectedTileCache();
    public void set_ProjectedTileCache(RasterTileCache value);
    public bool get_IsCacheOnly();
    public void set_IsCacheOnly(bool value);
    public Dictionary`2<string, WmtsTileMatrixSet> get_TileMatrixSets();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/b0E=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public virtual bool get_HasBoundingBox();
    public RectangleShape GetWGS84BoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    public Collection`1<Uri> GetRequestUris(RectangleShape requestExtent, int canvasWidth, int canvasHeight);
    protected virtual Collection`1<Uri> GetRequestUrisCore(RectangleShape requestExtent, int canvasWidth, int canvasHeight);
    public string GetServerCapabilitiesXml();
    public Collection`1<string> GetServerLayerNames();
    public Collection`1<string> GetServerLayerStyles();
    public Collection`1<string> GetServerTileMatrixSetNames();
    public Collection`1<WmtsSeverEncodingType> GetServerEncodingType();
    public Collection`1<string> GetLayerOutputFormats(string layerName);
    protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    private Uri 7h0=();
    private Tuple`2<string, string> eB4=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/a0E=")]
private Task eR4=(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/bkE=")]
private Task`1<bool> eh4=(string kvpUrl, CancellationToken cancellationToken);
    public bool RemoveCachedCapability();
    private string ex4=();
    private void aB4=(XmlElement element, XmlNamespaceManager namespaceManager);
    private void fB4=(XmlNode operationTileNode, XmlNamespaceManager namespaceManager);
    public ZoomLevelSet GetZoomLevelSet(string tileMatrixSetName);
    public TileMatrix GetTileMatrix(string tileMatrixSetName, double scale);
    private void fR4=(XmlNode node, XmlNamespaceManager namespaceManager);
    private void fh4=(T& left, T& top);
    private void fx4=(XmlNode node, XmlNamespaceManager namespaceManager);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/akE=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private int gB4=(double newWidth, RectangleShape newTileExtent, GeographyUnit mapUnit);
    protected virtual void DrawExceptionCore(GeoCanvas canvas, Exception e);
    private string gR4=(WmtsServerLayer serverLayer, string zoomLevel, long y, long x, string tileMatrixSetName, int resourceURLIndex);
    public string GetRequestUri(long x, long y, int zoomLevel);
    private string gh4=(string requestString);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/bEE=")]
private Task`1<CloudRasterTileInfo> gx4=(MatrixCell cell, int zoomLevelIndex, int tileSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.WmtsLayer/bUE=")]
private Task`1<RasterTile> hB4=(int zoomLevel, long x, long y, CancellationToken cancellationToken);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /h0=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool hT0=(WmtsServerLayer l);
    [CompilerGeneratedAttribute]
private bool hj0=(WmtsServerLayer l);
    [CompilerGeneratedAttribute]
private bool hz0=(WmtsServerLayer l);
}
[ObsoleteAttribute("This class is obsoleted and will be removed after v14.3, please use ThinkGeo.Core.XyzTileAsyncLayer instead")]
public abstract class ThinkGeo.Core.Async.XyzTileLayer : WebBasedLayer {
    [ObfuscationAttribute]
private RasterTileCache tileCache;
    [ObfuscationAttribute]
private RasterTileCache projectedTileCache;
    [ObfuscationAttribute]
private ProjectionConverter projectionConverterFromServerProjection;
    [ObfuscationAttribute]
private int cloudTileWidth;
    [ObfuscationAttribute]
private int cloudTileHeight;
    [ObfuscationAttribute]
private RectangleShape maxExtent;
    [ObfuscationAttribute]
private GeographyUnit cloudTileMapUnit;
    public int TileWidth { get; protected set; }
    public int TileHeight { get; protected set; }
    public GeographyUnit MapUnit { get; protected set; }
    public RectangleShape MaxExtent { get; protected set; }
    public RasterTileCache TileCache { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public ProjectionConverter ProjectionConverterFromServerProjection { get; public set; }
    public XyzTileLayer(int tileSize, GeographyUnit mapUnit, RectangleShape maxExtent);
    public int get_TileWidth();
    protected void set_TileWidth(int value);
    public int get_TileHeight();
    protected void set_TileHeight(int value);
    public GeographyUnit get_MapUnit();
    protected void set_MapUnit(GeographyUnit value);
    public RectangleShape get_MaxExtent();
    protected void set_MaxExtent(RectangleShape value);
    public virtual RasterTileCache get_TileCache();
    public virtual void set_TileCache(RasterTileCache value);
    public virtual RasterTileCache get_ProjectedTileCache();
    public virtual void set_ProjectedTileCache(RasterTileCache value);
    public virtual ProjectionConverter get_ProjectionConverterFromServerProjection();
    public virtual void set_ProjectionConverterFromServerProjection(ProjectionConverter value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.XyzTileLayer/sT8=")]
public Task`1<string> GetImageUriAsync(int zoomLevel, long x, long y, float resolutionFactor);
    protected abstract virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual int GetTileScale();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.XyzTileLayer/oT8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static Dictionary`2<ValueTuple`2<long, long>, MatrixCell> iB4=(TileMatrix tileMatrix, RectangleShape requestedExtent, WrappingMode wrapDateline);
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.XyzTileLayer/sz8=")]
private Task`1<RasterTile> hB4=(int zoomLevel, long x, long y, float resolutionFactor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.XyzTileLayer/rz8=")]
private Task`1<CloudRasterTileInfo> gx4=(MatrixCell cell, int zoomLevelIndex, float scaleFactor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.Async.XyzTileLayer/oD8=")]
public Task`1<Byte[]> DownloadImageAsync(int zoomLevelIndex, long column, long row, float scaleFactor, CancellationToken cancellationToken);
}
public abstract class ThinkGeo.Core.AsyncLayer : LayerBase {
    private Exception 7x0=;
    [CompilerGeneratedAttribute]
private double 8B0=;
    [CompilerGeneratedAttribute]
private double 8R0=;
    public double UpperThreshold { get; public set; }
    public double LowerThreshold { get; public set; }
    [CompilerGeneratedAttribute]
public double get_UpperThreshold();
    [CompilerGeneratedAttribute]
public void set_UpperThreshold(double value);
    [CompilerGeneratedAttribute]
public double get_LowerThreshold();
    [CompilerGeneratedAttribute]
public void set_LowerThreshold(double value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/Gj8=")]
public Task OpenAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/Gz8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/ET8=")]
public Task CloseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/Ej8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/Ez8=")]
public Task DrawAsync(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLayer/GD8=")]
private Task 8h0=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected abstract virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void 8x0=(object sender, DrawingProgressChangedEventArgs e);
}
public static class ThinkGeo.Core.AsyncLocker : object {
    private static ConcurrentDictionary`2<object, SemaphoreSlim> Zh0=;
    private static AsyncLocker();
    [AsyncStateMachineAttribute("ThinkGeo.Core.AsyncLocker/6T4=")]
public static Task`1<IDisposable> LockAsync(object lockObject);
}
public class ThinkGeo.Core.BackgroundLayer : Layer {
    [ObfuscationAttribute]
private GeoBrush backgroundBrush;
    public GeoBrush BackgroundBrush { get; public set; }
    public BackgroundLayer(GeoBrush backgroundBrush);
    public GeoBrush get_BackgroundBrush();
    public void set_BackgroundBrush(GeoBrush value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public enum ThinkGeo.Core.BasAnnotationTextStylingType : Enum {
    public int value__;
    public static BasAnnotationTextStylingType Default;
    public static BasAnnotationTextStylingType CustomStyling;
    public static BasAnnotationTextStylingType StandardStyling;
}
public abstract class ThinkGeo.Core.BaseShape : object {
    private static int 2Ro=;
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private object tag;
    public string Id { get; public set; }
    public object Tag { get; public set; }
    private static BaseShape();
    public string get_Id();
    public void set_Id(string value);
    public object get_Tag();
    public void set_Tag(object value);
    public static BaseShape CreateShapeFromWellKnownData(string wellKnownText);
    public void LoadFromWellKnownData(string wellKnownText);
    protected abstract virtual void LoadFromWellKnownDataCore(string wellKnownText);
    public string GetWellKnownText();
    public string GetGeoJson();
    protected virtual string GetGeoJsonCore();
    public string GetWellKnownText(RingOrder outerRingOrder);
    protected abstract virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    public static BaseShape CreateShapeFromWellKnownData(Byte[] wellKnownBinary);
    public static BaseShape CreateShapeFromGeoJson(string geoJson);
    public void LoadFromWellKnownData(Byte[] wellKnownBinary);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    public Byte[] GetWellKnownBinary();
    public Byte[] GetWellKnownBinary(WkbByteOrder byteOrder);
    public Byte[] GetWellKnownBinary(RingOrder outerRingOrder);
    public Byte[] GetWellKnownBinary(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    public RectangleShape GetBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    public WellKnownType GetWellKnownType();
    protected virtual WellKnownType GetWellKnownTypeCore();
    public BaseShape CloneDeep();
    protected virtual BaseShape CloneDeepCore();
    public static BaseShape TranslateByOffset(BaseShape targetShape, double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public static Feature TranslateByOffset(Feature targetFeature, double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public void TranslateByOffset(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public void TranslateByOffset(double xOffsetDistance, double yOffsetDistance);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public static BaseShape TranslateByDegree(BaseShape targetShape, double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public static BaseShape TranslateByDegree(Feature targetFeature, double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public void TranslateByDegree(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public void TranslateByDegree(double distance, double angleInDegrees);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public static BaseShape Rotate(BaseShape sourceBaseShape, PointShape pivotPoint, float degreeAngle);
    public static BaseShape Rotate(Feature targetFeature, PointShape pivotPoint, float degreeAngle);
    public void Rotate(PointShape pivotPoint, double degreeAngle);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    public MultilineShape GetShortestLineTo(BaseShape targetShape, GeographyUnit shapeUnit);
    public MultilineShape GetShortestLineTo(Feature targetFeature, GeographyUnit shapeUnit);
    protected virtual MultilineShape GetShortestLineToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    public PointShape GetClosestPointTo(BaseShape targetShape, GeographyUnit shapeUnit);
    public PointShape GetClosestPointTo(Feature targetFeature, GeographyUnit shapeUnit);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    public PointShape GetCenterPoint();
    protected virtual PointShape GetCenterPointCore();
    public MultipolygonShape Buffer(double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public MultipolygonShape Buffer(double distance, int quadrantSegments, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public MultipolygonShape Buffer(double distance, int quadrantSegments, BufferCapType bufferCapType, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual MultipolygonShape BufferCore(double distance, int quadrantSegments, BufferCapType bufferCapType, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private MultipolygonShape 2ho=(double distance, int quadrantSegments, BufferCapType bufferCapType);
    public double GetDistanceTo(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public double GetDistanceTo(Feature targetFeature, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public BaseShape Register(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    public BaseShape Register(Feature fromPoint, Feature toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    public ShapeValidationResult Validate(ShapeValidationMode validationMode);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    public bool IsDisjointed(BaseShape targetShape);
    public bool IsDisjointed(Feature targetFeature);
    protected virtual bool IsDisjointedCore(BaseShape targetShape);
    public bool Intersects(BaseShape targetShape);
    public bool Intersects(Feature targetFeature);
    protected virtual bool IntersectsCore(BaseShape targetShape);
    public bool Touches(BaseShape targetShape);
    public bool Touches(Feature targetFeature);
    protected virtual bool TouchesCore(BaseShape targetShape);
    public bool Crosses(BaseShape targetShape);
    public bool Crosses(Feature targetFeature);
    protected virtual bool CrossesCore(BaseShape targetShape);
    public bool IsWithin(BaseShape targetShape);
    public bool IsWithin(Feature targetFeature);
    protected virtual bool IsWithinCore(BaseShape targetShape);
    public bool Contains(BaseShape targetShape);
    public bool Contains(Feature targetFeature);
    protected virtual bool ContainsCore(BaseShape targetShape);
    public bool Overlaps(BaseShape targetShape);
    public bool Overlaps(Feature targetFeature);
    protected virtual bool OverlapsCore(BaseShape targetShape);
    public bool IsTopologicallyEqual(BaseShape targetShape);
    public bool IsTopologicallyEqual(Feature targetFeature);
    protected virtual bool IsTopologicallyEqualCore(BaseShape targetShape);
    public Feature GetFeature();
    public Feature GetFeature(IDictionary`2<string, string> columnValues);
    public MultipointShape GetCrossing(BaseShape targetShape);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public static BaseShape ScaleTo(BaseShape baseShape, double scale);
    public void ScaleTo(double scale);
    protected virtual void ScaleToCore(double scale);
    private static EndCapStyle 2xo=(BufferCapType bufferCapStyle);
    private static ByteOrder 3Bo=(WkbByteOrder wkbByteOrder);
}
public class ThinkGeo.Core.BaseShapeTypeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
public class ThinkGeo.Core.BingMapsAsyncLayer : XyzTileAsyncLayer {
    private static int 9B0=;
    private static string 9R0=;
    private static string 9h0=;
    [ObfuscationAttribute]
private string applicationId;
    [ObfuscationAttribute]
private BingMapsMapType mapType;
    [ObfuscationAttribute]
private string imageUriTemplate;
    [ObfuscationAttribute]
private Collection`1<string> subDomains;
    [ObfuscationAttribute]
private GeoImage logo;
    [ObfuscationAttribute]
private bool isDirty;
    [ObfuscationAttribute]
private RequestProtocol httpRequestProtocol;
    public string ApplicationId { get; public set; }
    public BingMapsMapType MapType { get; public set; }
    public GeoImage Logo { get; }
    public RequestProtocol HttpRequestProtocol { get; public set; }
    public BingMapsAsyncLayer(string applicationId);
    public BingMapsAsyncLayer(string applicationId, BingMapsMapType mapType);
    private static BingMapsAsyncLayer();
    [AsyncStateMachineAttribute("ThinkGeo.Core.BingMapsAsyncLayer/Hz8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public string get_ApplicationId();
    public void set_ApplicationId(string value);
    public BingMapsMapType get_MapType();
    public void set_MapType(BingMapsMapType value);
    public GeoImage get_Logo();
    public RequestProtocol get_HttpRequestProtocol();
    public void set_HttpRequestProtocol(RequestProtocol value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.BingMapsAsyncLayer/HD8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.BingMapsAsyncLayer/HT8=")]
protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    private static string 9x0=(long tileX, long tileY, int levelOfDetail);
    [AsyncStateMachineAttribute("ThinkGeo.Core.BingMapsAsyncLayer/Ij8=")]
private Task /B0=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.BingMapsAsyncLayer/ID8=")]
private Task`1<XmlDocument> /R0=(string xmlPath);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task /h0=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /x0=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public enum ThinkGeo.Core.BingMapsMapType : Enum {
    public int value__;
    public static BingMapsMapType Road;
    public static BingMapsMapType AerialWithLabels;
    public static BingMapsMapType Aerial;
    public static BingMapsMapType CanvasDark;
}
public class ThinkGeo.Core.BingMapsZoomLevelSet : ZoomLevelSet {
}
public enum ThinkGeo.Core.BreakValueInclusion : Enum {
    public int value__;
    public static BreakValueInclusion IncludeValue;
    public static BreakValueInclusion ExcludeValue;
}
public enum ThinkGeo.Core.BufferCapType : Enum {
    public int value__;
    public static BufferCapType Round;
    public static BufferCapType Square;
    public static BufferCapType Butt;
}
public enum ThinkGeo.Core.BuildIndexMode : Enum {
    public int value__;
    public static BuildIndexMode DoNotRebuild;
    public static BuildIndexMode Rebuild;
}
public class ThinkGeo.Core.BuildingAreaStyle : AreaStyle {
    private static int nzE=;
    private static int oDE=;
    private int oTE=;
    private string ojE=;
    private DistanceUnit ozE=;
    private GeoBrush pDE=;
    private GeoBrush pTE=;
    private GeoBrush pjE=;
    private BuildingShadowMode pzE=;
    internal bool ohU= { get; }
    public DistanceUnit HeightUnit { get; public set; }
    public string HeightColumnName { get; public set; }
    public GeoBrush LightSideBrush { get; public set; }
    public GeoBrush ShadowSideBrush { get; public set; }
    public GeoBrush RoofBrush { get; public set; }
    public BuildingShadowMode ShadowMode { get; public set; }
    public BuildingAreaStyle(string heightColumnName, DistanceUnit heightUnit);
    private static BuildingAreaStyle();
    internal virtual bool oBU=();
    public DistanceUnit get_HeightUnit();
    public void set_HeightUnit(DistanceUnit value);
    public string get_HeightColumnName();
    public void set_HeightColumnName(string value);
    public GeoBrush get_LightSideBrush();
    public void set_LightSideBrush(GeoBrush value);
    public GeoBrush get_ShadowSideBrush();
    public void set_ShadowSideBrush(GeoBrush value);
    public GeoBrush get_RoofBrush();
    public void set_RoofBrush(GeoBrush value);
    public BuildingShadowMode get_ShadowMode();
    public void set_ShadowMode(BuildingShadowMode value);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    [IteratorStateMachineAttribute("ThinkGeo.Core.BuildingAreaStyle/hkA=")]
private static IEnumerable`1<Feature> qDE=(Feature feature);
    private void qTE=(GeoCanvas canvas, PolygonShape buildingPolygon, double buildingHeight, int currentLevel, ScreenPointF screenOrigin);
    private ScreenPointF[] qjE=(GeoCanvas canvas, double buildingHeight, ScreenPointF[] footPrints, bool isCounterClockwise, ScreenPointF screenOrigin);
    protected virtual double GetHeightInMeters(Feature feature);
    private static void fh4=(T& a, T& b);
    private static int qzE=(double scale, List`1<double> zoomLevelScales);
    private static ScreenPointF rDE=(Vertex v, GeoCanvas canvas);
    private static double rTE=(GeoCanvas canvas);
    private ScreenPointF rjE=(ScreenPointF point, double scale, ScreenPointF origin);
    private static bool rzE=(Vertex[] vertices);
}
public class ThinkGeo.Core.BuildingIndexBasFileFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private int recordCount;
    [ObfuscationAttribute]
private long currentRecordOffset;
    [ObfuscationAttribute]
private Feature currentFeature;
    [ObfuscationAttribute]
private DateTime startProcessTime;
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private string basPathFilename;
    public int RecordCount { get; }
    public long CurrentRecordOffset { get; }
    public Feature CurrentFeature { get; }
    public DateTime StartProcessTime { get; }
    public bool Cancel { get; public set; }
    public string ShapePathFilename { get; }
    public BuildingIndexBasFileFeatureSourceEventArgs(int recordCount, long currentRecordOffset, Feature currentFeature, DateTime startProcessTime, bool cancel);
    public BuildingIndexBasFileFeatureSourceEventArgs(int recordCount, long currentRecordOffset, Feature currentFeature, DateTime startProcessTime, bool cancel, string shapePathFilename);
    public int get_RecordCount();
    public long get_CurrentRecordOffset();
    public Feature get_CurrentFeature();
    public DateTime get_StartProcessTime();
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public string get_ShapePathFilename();
}
public class ThinkGeo.Core.BuildingIndexDelimitedFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private int recordCount;
    [ObfuscationAttribute]
private int currentRecordIndex;
    [ObfuscationAttribute]
private Feature currentFeature;
    [ObfuscationAttribute]
private DateTime startProcessTime;
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private string delimitedPathFilename;
    public int RecordCount { get; }
    public int CurrentRecordIndex { get; }
    public Feature CurrentFeature { get; }
    public DateTime StartProcessTime { get; }
    public string DelimitedPathFilename { get; }
    public bool Cancel { get; public set; }
    public BuildingIndexDelimitedFeatureSourceEventArgs(int recordCount, int currentRecordIndex, Feature currentFeature, DateTime startProcessTime, string delimitedPathFilename);
    public int get_RecordCount();
    public int get_CurrentRecordIndex();
    public Feature get_CurrentFeature();
    public DateTime get_StartProcessTime();
    public string get_DelimitedPathFilename();
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.BuildingIndexShapeFileFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private long recordCount;
    [ObfuscationAttribute]
private long currentRecordIndex;
    [ObfuscationAttribute]
private Feature currentFeature;
    [ObfuscationAttribute]
private DateTime startProcessTime;
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private string shapePathFilename;
    public long RecordCount { get; }
    public long CurrentRecordIndex { get; }
    public Feature CurrentFeature { get; }
    public DateTime StartProcessTime { get; }
    public bool Cancel { get; public set; }
    public string ShapePathFilename { get; }
    public BuildingIndexShapeFileFeatureSourceEventArgs(long recordCount, long currentRecordIndex, Feature currentFeature, DateTime startProcessTime, string shapePathFilename);
    public long get_RecordCount();
    public long get_CurrentRecordIndex();
    public Feature get_CurrentFeature();
    public DateTime get_StartProcessTime();
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public string get_ShapePathFilename();
}
public enum ThinkGeo.Core.BuildingShadowMode : Enum {
    public int value__;
    public static BuildingShadowMode Perspective;
    public static BuildingShadowMode FixedDirection;
}
public enum ThinkGeo.Core.BuildRecordIdMode : Enum {
    public int value__;
    public static BuildRecordIdMode DoNotRebuild;
    public static BuildRecordIdMode Rebuild;
}
public class ThinkGeo.Core.CircularKrigingGridInterpolationModel : KrigingGridInterpolationModel {
    public CircularKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    public CircularKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points, int numberOfReferencedPoints);
    protected virtual double GetSemivarianceCore(double distance, EmpiricalFunctionCoefficients coefficients);
    protected virtual double GetSillSlopeCore(double distance, double range);
}
public class ThinkGeo.Core.ClassBreak : object {
    [ObfuscationAttribute]
private double value;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    [ObfuscationAttribute]
private LineStyle defaultLineStyle;
    [ObfuscationAttribute]
private AreaStyle defaultAreaStyle;
    [ObfuscationAttribute]
private TextStyle defaultTextStyle;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    public double Value { get; public set; }
    public AreaStyle DefaultAreaStyle { get; public set; }
    public LineStyle DefaultLineStyle { get; public set; }
    public PointStyle DefaultPointStyle { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    public ClassBreak(double value, AreaStyle areaStyle);
    public ClassBreak(double value, PointStyle pointStyle);
    public ClassBreak(double value, LineStyle lineStyle);
    public ClassBreak(double value, TextStyle textStyle);
    public ClassBreak(double value, Collection`1<Style> customStyles);
    private ClassBreak(double value, AreaStyle areaStyle, PointStyle pointStyle, LineStyle lineStyle, TextStyle textStyle, Collection`1<Style> styles);
    public double get_Value();
    public void set_Value(double value);
    public AreaStyle get_DefaultAreaStyle();
    public void set_DefaultAreaStyle(AreaStyle value);
    public LineStyle get_DefaultLineStyle();
    public void set_DefaultLineStyle(LineStyle value);
    public PointStyle get_DefaultPointStyle();
    public void set_DefaultPointStyle(PointStyle value);
    public TextStyle get_DefaultTextStyle();
    public void set_DefaultTextStyle(TextStyle value);
    public Collection`1<Style> get_CustomStyles();
}
public enum ThinkGeo.Core.ClassBreakDrawingOrder : Enum {
    public int value__;
    public static ClassBreakDrawingOrder Default;
    public static ClassBreakDrawingOrder OrderByFeatures;
    public static ClassBreakDrawingOrder OrderByClassBreak;
}
public class ThinkGeo.Core.ClassBreakStyle : Style {
    [ObfuscationAttribute]
private BreakValueInclusion breakValueInclusion;
    [ObfuscationAttribute]
private Collection`1<ClassBreak> classBreaks;
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private ClassBreakDrawingOrder drawingOrder;
    [CompilerGeneratedAttribute]
private EventHandler`1<GottenFeatureValueClassBreakStyleEventArgs> sjE=;
    public string ColumnName { get; public set; }
    public BreakValueInclusion BreakValueInclusion { get; public set; }
    public Collection`1<ClassBreak> ClassBreaks { get; }
    public ClassBreakDrawingOrder DrawingOrder { get; public set; }
    public ClassBreakStyle(string columnName);
    public ClassBreakStyle(string columnName, BreakValueInclusion breakValueInclusion);
    public ClassBreakStyle(string columnName, BreakValueInclusion breakValueInclusion, Collection`1<ClassBreak> classBreaks);
    [CompilerGeneratedAttribute]
public void add_GottenFeatureValue(EventHandler`1<GottenFeatureValueClassBreakStyleEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GottenFeatureValue(EventHandler`1<GottenFeatureValueClassBreakStyleEventArgs> value);
    protected virtual void OnGottenFeatureValue(GottenFeatureValueClassBreakStyleEventArgs e);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public BreakValueInclusion get_BreakValueInclusion();
    public void set_BreakValueInclusion(BreakValueInclusion value);
    public Collection`1<ClassBreak> get_ClassBreaks();
    public ClassBreakDrawingOrder get_DrawingOrder();
    public void set_DrawingOrder(ClassBreakDrawingOrder value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    [IteratorStateMachineAttribute("ThinkGeo.Core.ClassBreakStyle/iEA=")]
private IEnumerable`1<Style> szE=();
    private static Collection`1<ClassBreak> tDE=(Collection`1<ClassBreak> classBreaks);
    private static ClassBreak tTE=(double columnValue, BreakValueInclusion breakValueInclusion, Collection`1<ClassBreak> sortedClassBreaks);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    private static void tjE=(Collection`1<string> requiredFieldNames, Collection`1<string> fieldNames);
}
public static class ThinkGeo.Core.ClassBreakValidatorHelper : object {
    public static void CheckClassBreaksAreValid(IEnumerable`1<ClassBreak> classBreaks);
}
public class ThinkGeo.Core.ClearedItemsGeoCollectionEventArgs : EventArgs {
}
public class ThinkGeo.Core.ClearingItemsGeoCollectionEventArgs : EventArgs {
}
public class ThinkGeo.Core.ClosedFeatureSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.ClosedRasterSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.ClosingFeatureSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.ClosingRasterSourceEventArgs : EventArgs {
}
public abstract class ThinkGeo.Core.CloudClient : object {
    private string tBQ=;
    private int tRQ=;
    private IWebProxy thQ=;
    private string txQ=;
    private string uBQ=;
    private int uRQ=;
    private static string uhQ=;
    private Timer uxQ=;
    private object 9BM=;
    private SemaphoreSlim vBQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingAccessTokenEventArgs> vRQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingWebRequestEventArgs> vhQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentWebRequestEventArgs> vxQ=;
    [CompilerGeneratedAttribute]
private Collection`1<Uri> wBQ=;
    public int TimeoutInSeconds { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public Collection`1<Uri> BaseUris { get; }
    protected CloudClient(string clientId, string clientSecret);
    [CompilerGeneratedAttribute]
public void add_GettingAccessToken(EventHandler`1<GettingAccessTokenEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingAccessToken(EventHandler`1<GettingAccessTokenEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    [CompilerGeneratedAttribute]
public Collection`1<Uri> get_BaseUris();
    protected void AuthenticateWebRequest(WebRequest webRequest);
    [AsyncStateMachineAttribute("ThinkGeo.Core.CloudClient/9z0=")]
protected Task AuthenticateWebRequestAsync(WebRequest webRequest);
    protected string GetToken();
    [AsyncStateMachineAttribute("ThinkGeo.Core.CloudClient/Aj4=")]
protected Task`1<string> GetTokenAsync();
    [AsyncStateMachineAttribute("ThinkGeo.Core.CloudClient/Az4=")]
protected virtual Task`1<string> GetTokenCoreAsync();
    protected virtual string GetTokenCore();
    protected WebResponse SendWebRequest(WebRequest webRequest);
    [AsyncStateMachineAttribute("ThinkGeo.Core.CloudClient/BD4=")]
protected Task`1<WebResponse> SendWebRequestAsync(WebRequest webRequest);
    protected string GetNextCandidateBaseUri();
    protected virtual string GetNextCandidateBaseUriCore();
    protected virtual void OnGettingAccessToken(GettingAccessTokenEventArgs e);
    protected virtual void OnSendingWebRequest(SendingWebRequestEventArgs e);
    protected virtual void OnSentWebRequest(SentWebRequestEventArgs e);
    public virtual void Dispose();
    private void wRQ=(object state);
    private static string whQ=(HttpWebResponse httpWebResponse);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudDurationMinuteReader : CloudJsonConverter`1<object> {
    public virtual object ReadJson(CloudGeoJObject jObject, Type objectType);
    public virtual void WriteJson(CloudGeoJObject jObject, object value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudElevationPointResult : ValueType {
    [CompilerGeneratedAttribute]
private double <Elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private PointShape <Point>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public double Elevation { get; }
    public PointShape Point { get; }
    public ThinkGeoCloudApplicationException Exception { get; }
    public CloudElevationPointResult(double elevation, PointShape point, ThinkGeoCloudApplicationException exception);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public double get_Elevation();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public PointShape get_Point();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudElevationResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudElevationPointResult> <ElevationPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudElevationPointResult <HighestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudElevationPointResult <LowestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AverageElevation>k__BackingField;
    public Collection`1<CloudElevationPointResult> ElevationPoints { get; }
    public CloudElevationPointResult HighestElevationPoint { get; }
    public CloudElevationPointResult LowestElevationPoint { get; }
    public double AverageElevation { get; }
    public CloudElevationResult(CloudElevationPointResult highestElevationPoint, CloudElevationPointResult lowestElevationPoint, double averageElevation);
    [CompilerGeneratedAttribute]
public Collection`1<CloudElevationPointResult> get_ElevationPoints();
    [CompilerGeneratedAttribute]
public CloudElevationPointResult get_HighestElevationPoint();
    [CompilerGeneratedAttribute]
public CloudElevationPointResult get_LowestElevationPoint();
    [CompilerGeneratedAttribute]
public double get_AverageElevation();
}
[ObfuscationAttribute]
[ExtensionAttribute]
internal static class ThinkGeo.Core.CloudExtensionHelper : object {
    internal static WebRequest CreateWebRequest(string baseUri, string apiPath, string method, string parameters, string body, int timeoutInSeconds, IWebProxy webProxy);
    [AsyncStateMachineAttribute("ThinkGeo.Core.CloudExtensionHelper/lj4=")]
internal static Task`1<WebRequest> CreateWebRequestAsync(string baseUri, string apiPath, string method, string parameters, string body, int timeoutInSeconds, IWebProxy webProxy);
    [ExtensionAttribute]
internal static T ReadAnonymousObject(WebResponse response, T anonymousObject);
    [ExtensionAttribute]
internal static CloudGeoJObject ReadAnonymousObject(WebResponse response);
    [ExtensionAttribute]
internal static Byte[] ReadRaw(WebResponse response);
    [ExtensionAttribute]
internal static string ReadContentAsString(WebResponse webResponse, Encoding encoding);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudGeocodingLocation : object {
    [CompilerGeneratedAttribute]
private PointShape <LocationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private RectangleShape <BoundingBox>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseShape <Shape>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    public PointShape LocationPoint { get; public set; }
    public string LocationName { get; public set; }
    public string LocationType { get; public set; }
    public RectangleShape BoundingBox { get; public set; }
    public BaseShape Shape { get; public set; }
    public Dictionary`2<string, string> Properties { get; public set; }
    [CompilerGeneratedAttribute]
public PointShape get_LocationPoint();
    [CompilerGeneratedAttribute]
public void set_LocationPoint(PointShape value);
    [CompilerGeneratedAttribute]
public string get_LocationName();
    [CompilerGeneratedAttribute]
public void set_LocationName(string value);
    [CompilerGeneratedAttribute]
public string get_LocationType();
    [CompilerGeneratedAttribute]
public void set_LocationType(string value);
    [CompilerGeneratedAttribute]
public RectangleShape get_BoundingBox();
    [CompilerGeneratedAttribute]
public void set_BoundingBox(RectangleShape value);
    [CompilerGeneratedAttribute]
public BaseShape get_Shape();
    [CompilerGeneratedAttribute]
public void set_Shape(BaseShape value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
}
[ObfuscationAttribute]
[FlagsAttribute]
public enum ThinkGeo.Core.CloudGeocodingLocationType : Enum {
    public int value__;
    public static CloudGeocodingLocationType Default;
    public static CloudGeocodingLocationType Country;
    public static CloudGeocodingLocationType State;
    public static CloudGeocodingLocationType County;
    public static CloudGeocodingLocationType City;
    public static CloudGeocodingLocationType Street;
    public static CloudGeocodingLocationType Address;
    public static CloudGeocodingLocationType Zipcode;
    public static CloudGeocodingLocationType Locality;
    public static CloudGeocodingLocationType Town;
    public static CloudGeocodingLocationType Neighbourhood;
    public static CloudGeocodingLocationType Place;
    public static CloudGeocodingLocationType District;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudGeocodingOptions : object {
    [CompilerGeneratedAttribute]
private bool <Autocomplete>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private RectangleShape <BBox>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudGeocodingResultDetail <ResultDetail>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudGeocodingSearchMode <SearchMode>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudGeocodingLocationType <LocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Countries>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ResultProjectionInSrid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResultProjectionInProj4String>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Debug>k__BackingField;
    public bool Autocomplete { get; public set; }
    public int MaxResults { get; public set; }
    public RectangleShape BBox { get; public set; }
    public CloudGeocodingResultDetail ResultDetail { get; public set; }
    public CloudGeocodingSearchMode SearchMode { get; public set; }
    public CloudGeocodingLocationType LocationType { get; public set; }
    public IEnumerable`1<string> Countries { get; public set; }
    public IEnumerable`1<string> Language { get; public set; }
    public int ResultProjectionInSrid { get; public set; }
    public string ResultProjectionInProj4String { get; public set; }
    public bool Debug { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Autocomplete();
    [CompilerGeneratedAttribute]
public void set_Autocomplete(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxResults();
    [CompilerGeneratedAttribute]
public void set_MaxResults(int value);
    [CompilerGeneratedAttribute]
public RectangleShape get_BBox();
    [CompilerGeneratedAttribute]
public void set_BBox(RectangleShape value);
    [CompilerGeneratedAttribute]
public CloudGeocodingResultDetail get_ResultDetail();
    [CompilerGeneratedAttribute]
public void set_ResultDetail(CloudGeocodingResultDetail value);
    [CompilerGeneratedAttribute]
public CloudGeocodingSearchMode get_SearchMode();
    [CompilerGeneratedAttribute]
public void set_SearchMode(CloudGeocodingSearchMode value);
    [CompilerGeneratedAttribute]
public CloudGeocodingLocationType get_LocationType();
    [CompilerGeneratedAttribute]
public void set_LocationType(CloudGeocodingLocationType value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Countries();
    [CompilerGeneratedAttribute]
public void set_Countries(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public int get_ResultProjectionInSrid();
    [CompilerGeneratedAttribute]
public void set_ResultProjectionInSrid(int value);
    [CompilerGeneratedAttribute]
public string get_ResultProjectionInProj4String();
    [CompilerGeneratedAttribute]
public void set_ResultProjectionInProj4String(string value);
    [CompilerGeneratedAttribute]
public bool get_Debug();
    [CompilerGeneratedAttribute]
public void set_Debug(bool value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudGeocodingResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudGeocodingLocation> <Locations>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public Collection`1<CloudGeocodingLocation> Locations { get; }
    public ThinkGeoCloudApplicationException Exception { get; }
    public CloudGeocodingResult(IEnumerable`1<CloudGeocodingLocation> locations, ThinkGeoCloudApplicationException exception);
    [CompilerGeneratedAttribute]
public Collection`1<CloudGeocodingLocation> get_Locations();
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudGeocodingResultDetail : Enum {
    public int value__;
    public static CloudGeocodingResultDetail Default;
    public static CloudGeocodingResultDetail Verbose;
    public static CloudGeocodingResultDetail Standard;
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudGeocodingSearchMode : Enum {
    public int value__;
    public static CloudGeocodingSearchMode Default;
    public static CloudGeocodingSearchMode ExactMatch;
    public static CloudGeocodingSearchMode FuzzyMatch;
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudGeoJObject : object {
    [ObfuscationAttribute]
private string key;
    [ObfuscationAttribute]
private object value;
    public string Key { get; public set; }
    public object Value { get; public set; }
    public CloudGeoJObject(string key, object value);
    public string get_Key();
    public void set_Key(string value);
    public object get_Value();
    public void set_Value(object value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudGradeResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudGradeSegment> <GradeSegments>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudGradeSegment <HighestGradeSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudGradeSegment <LowestGradeSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AverageGrade>k__BackingField;
    public Collection`1<CloudGradeSegment> GradeSegments { get; }
    public CloudGradeSegment HighestGradeSegment { get; }
    public CloudGradeSegment LowestGradeSegment { get; }
    public double AverageGrade { get; }
    public CloudGradeResult(CloudGradeSegment highestGradeSegment, CloudGradeSegment lowestGradeSegment, double averageGrade);
    [CompilerGeneratedAttribute]
public Collection`1<CloudGradeSegment> get_GradeSegments();
    [CompilerGeneratedAttribute]
public CloudGradeSegment get_HighestGradeSegment();
    [CompilerGeneratedAttribute]
public CloudGradeSegment get_LowestGradeSegment();
    [CompilerGeneratedAttribute]
public double get_AverageGrade();
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudGradeSegment : ValueType {
    [CompilerGeneratedAttribute]
private double <Grade>k__BackingField;
    [CompilerGeneratedAttribute]
private LineShape <GradeLine>k__BackingField;
    [CompilerGeneratedAttribute]
private double <StartingElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <EndingElevation>k__BackingField;
    public double Grade { get; }
    public LineShape GradeLine { get; }
    public double StartingElevation { get; }
    public double EndingElevation { get; }
    public CloudGradeSegment(double grade, LineShape gradeLine, double startingElevation, double endingElevation);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_Grade();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public LineShape get_GradeLine();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public double get_StartingElevation();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public double get_EndingElevation();
}
[ObfuscationAttribute]
internal abstract class ThinkGeo.Core.CloudJsonConverter`1 : object {
    public abstract virtual T ReadJson(CloudGeoJObject jObject, Type objectType);
    public abstract virtual void WriteJson(CloudGeoJObject jObject, T value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudJsonConverterAttribute : Attribute {
    [ObfuscationAttribute]
private Type type;
    public Type Type { get; public set; }
    public CloudJsonConverterAttribute(Type type);
    public Type get_Type();
    public void set_Type(Type value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudJsonPropertyAttribute : Attribute {
    [ObfuscationAttribute]
private string name;
    public string Name { get; public set; }
    public CloudJsonPropertyAttribute(string name);
    public string get_Name();
    public void set_Name(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudJsonSerializer : object {
    [ObfuscationAttribute]
private static Regex jsonRegex;
    [ObfuscationAttribute]
private static Regex fieldNameRegex;
    [ObfuscationAttribute]
private static BindingFlags bindingFlags;
    [ObfuscationAttribute]
private Encoding encoding;
    [ObfuscationAttribute]
private CloudGeoJObject jObject;
    public Encoding Encoding { get; public set; }
    private static CloudJsonSerializer();
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public string Serialize();
    private static string SerializeCore(CloudGeoJObject jObject);
    public CloudGeoJObject Deserialize(string json);
    public CloudGeoJObject Deserialize(Stream stream);
    private CloudGeoJObject DeserializeCore(string json);
    private string GetWholevalue(MatchCollection matches, Match currentMatch, string json, string value, Int32& i);
    public static string Serialize(CloudGeoJObject jObject);
    public static string Serialize(T obj);
    private static object SerializeCore(object obj, FieldInfo fieldInfo);
    public static T Deserialize(string json, T obj);
    private static object DeserializeCore(object jObject, Type type, Type parentType, FieldInfo field);
    private static void CreateIEnumerableObject(object result, CloudGeoJObject jObject, Type type, Type parentType, FieldInfo field);
    private static object CreateNormalObject(object jObject, object result);
    private static Collection`1<MemberInfo> GetMembers(Type type);
    private static bool IsSerializable(FieldInfo field);
    private static object CreateArray(CloudGeoJObject jObject, Type type, Type parentType, FieldInfo field);
    private static void SetValue(Array results, int rank, List`1<int> indecies, Collection`1<object> values, Int32& index);
    private static object CreateSimpleObject(CloudGeoJObject jObject, Type type);
    private static object GetSimpleTypeResult(Type type, object value);
    private static bool IsSimpleType(Type type);
}
[ObfuscationAttribute]
internal static class ThinkGeo.Core.CloudJsonSerializerUtils : object {
    internal static T DeserializeObject(string json);
    internal static T DeserializeAnonymousType(string json, T anonymousObject);
    internal static string SerializeObject(T obj);
}
[ObfuscationAttribute]
[FlagsAttribute]
public enum ThinkGeo.Core.CloudLocationCategories : Enum {
    public UInt32 value__;
    public static CloudLocationCategories None;
    public static CloudLocationCategories Common;
    public static CloudLocationCategories All;
    public static CloudLocationCategories Aeroway;
    public static CloudLocationCategories Amenity;
    public static CloudLocationCategories Barrier;
    public static CloudLocationCategories Boundary;
    public static CloudLocationCategories Building;
    public static CloudLocationCategories Education;
    public static CloudLocationCategories Entertainment;
    public static CloudLocationCategories Financial;
    public static CloudLocationCategories Healthcare;
    public static CloudLocationCategories Historic;
    public static CloudLocationCategories Leisure;
    public static CloudLocationCategories Manmade;
    public static CloudLocationCategories Natural;
    public static CloudLocationCategories Rail;
    public static CloudLocationCategories Power;
    public static CloudLocationCategories Road;
    public static CloudLocationCategories Shop;
    public static CloudLocationCategories Sport;
    public static CloudLocationCategories Sustenance;
    public static CloudLocationCategories Tourism;
    public static CloudLocationCategories Transportation;
    public static CloudLocationCategories Waterway;
    public static CloudLocationCategories Intersection;
    public static CloudLocationCategories AddressPoint;
    public static CloudLocationCategories Others;
}
[ObsoleteAttribute("This class is deprecated and will be removed after v13.3. Please use ThinkGeo Cloud Layers to display ThinkGeo Maps.")]
public class ThinkGeo.Core.CloudMapClient : object {
    [ObfuscationAttribute]
private string token;
    [ObfuscationAttribute]
private int timeoutInSeconds;
    [ObfuscationAttribute]
private IWebProxy webProxy;
    [ObfuscationAttribute]
private string clientId;
    [ObfuscationAttribute]
private string clientSecret;
    [ObfuscationAttribute]
private bool isOpen;
    [ObfuscationAttribute]
private int baseUriIndex;
    private static int AR4=;
    private static string uhQ=;
    private Timer uxQ=;
    [ObfuscationAttribute]
private Collection`1<Uri> baseUris;
    private bool Ah4=;
    public bool IsOpen { get; public set; }
    public Collection`1<Uri> Uris { get; }
    public int TimeoutInSeconds { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public CloudMapClient(string clientId, string clientSecret);
    public bool get_IsOpen();
    public void set_IsOpen(bool value);
    public void Open();
    public Collection`1<Uri> get_Uris();
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    public WebRequest CreateWebRequest(string apiPath, string method, string parameters, string body, int timeoutInSeconds, IWebProxy webProxy, bool isNeedToken);
    private string ois=();
    public virtual void Dispose();
    private string HR4=();
    private void wRQ=(object state);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudMapProjection : Enum {
    public int value__;
    public static CloudMapProjection SphericalMercator;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQueryCustomQueryOptions : object {
    [CompilerGeneratedAttribute]
private string <QueryLayer>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudMapsQueryCustomQueryType <QueryType>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseShape <Shape>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Srid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Proj4String>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DistanceUnit> <DistanceUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <SearchRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DistanceUnit> <SearchRadiusUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnFeatureAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <FeatureAttributesToReturn>k__BackingField;
    public string QueryLayer { get; public set; }
    public CloudMapsQueryCustomQueryType QueryType { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudShapeWktConverter")]
[CloudJsonPropertyAttribute("wkt")]
public BaseShape Shape { get; public set; }
    public Nullable`1<int> Srid { get; public set; }
    public string Proj4String { get; public set; }
    public Nullable`1<double> Distance { get; public set; }
    public Nullable`1<DistanceUnit> DistanceUnit { get; public set; }
    public Nullable`1<double> SearchRadius { get; public set; }
    public Nullable`1<DistanceUnit> SearchRadiusUnit { get; public set; }
    public int MaxResults { get; public set; }
    public bool ReturnFeatureAttributes { get; public set; }
    public IEnumerable`1<string> FeatureAttributesToReturn { get; public set; }
    [CompilerGeneratedAttribute]
public string get_QueryLayer();
    [CompilerGeneratedAttribute]
public void set_QueryLayer(string value);
    [CompilerGeneratedAttribute]
public CloudMapsQueryCustomQueryType get_QueryType();
    [CompilerGeneratedAttribute]
public void set_QueryType(CloudMapsQueryCustomQueryType value);
    [CompilerGeneratedAttribute]
public BaseShape get_Shape();
    [CompilerGeneratedAttribute]
public void set_Shape(BaseShape value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Srid();
    [CompilerGeneratedAttribute]
public void set_Srid(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_Proj4String();
    [CompilerGeneratedAttribute]
public void set_Proj4String(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DistanceUnit> get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(Nullable`1<DistanceUnit> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_SearchRadius();
    [CompilerGeneratedAttribute]
public void set_SearchRadius(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DistanceUnit> get_SearchRadiusUnit();
    [CompilerGeneratedAttribute]
public void set_SearchRadiusUnit(Nullable`1<DistanceUnit> value);
    [CompilerGeneratedAttribute]
public int get_MaxResults();
    [CompilerGeneratedAttribute]
public void set_MaxResults(int value);
    [CompilerGeneratedAttribute]
public bool get_ReturnFeatureAttributes();
    [CompilerGeneratedAttribute]
public void set_ReturnFeatureAttributes(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_FeatureAttributesToReturn();
    [CompilerGeneratedAttribute]
public void set_FeatureAttributesToReturn(IEnumerable`1<string> value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudMapsQueryCustomQueryType : Enum {
    public int value__;
    public static CloudMapsQueryCustomQueryType Within;
    public static CloudMapsQueryCustomQueryType Containing;
    public static CloudMapsQueryCustomQueryType Intersecting;
    public static CloudMapsQueryCustomQueryType Overlapping;
    public static CloudMapsQueryCustomQueryType Touching;
    public static CloudMapsQueryCustomQueryType Nearest;
    public static CloudMapsQueryCustomQueryType WithinDistance;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQueryGetAttributesOfLayerResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<string> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public Collection`1<string> Attributes { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<string> get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(Collection`1<string> value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQueryGetLayersResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<string> <QueryLayers>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public Collection`1<string> QueryLayers { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<string> get_QueryLayers();
    [CompilerGeneratedAttribute]
public void set_QueryLayers(Collection`1<string> value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public static class ThinkGeo.Core.CloudMapsQueryLayers : object {
    public static string Countries;
    public static string States;
    public static string Roads;
    public static string Rail;
    public static string Addresses;
    public static string Cities;
    public static string LandUse;
    public static string Places;
    public static string Pois;
    public static string Transport;
    public static string Water;
    public static string Waterways;
    public static string Buildings;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQueryNearestQueryOptions : object {
    [CompilerGeneratedAttribute]
private bool <ReturnFeatureAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <FeatureAttributesToReturn>k__BackingField;
    public bool ReturnFeatureAttributes { get; public set; }
    public IEnumerable`1<string> FeatureAttributesToReturn { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ReturnFeatureAttributes();
    [CompilerGeneratedAttribute]
public void set_ReturnFeatureAttributes(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_FeatureAttributesToReturn();
    [CompilerGeneratedAttribute]
public void set_FeatureAttributesToReturn(IEnumerable`1<string> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQueryResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<Feature> <Features>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public Collection`1<Feature> Features { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<Feature> get_Features();
    [CompilerGeneratedAttribute]
public void set_Features(Collection`1<Feature> value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudMapsQuerySpatialQueryOptions : object {
    [CompilerGeneratedAttribute]
private int <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReturnFeatureAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <FeatureAttributesToReturn>k__BackingField;
    public int MaxResults { get; public set; }
    public bool ReturnFeatureAttributes { get; public set; }
    public IEnumerable`1<string> FeatureAttributesToReturn { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MaxResults();
    [CompilerGeneratedAttribute]
public void set_MaxResults(int value);
    [CompilerGeneratedAttribute]
public bool get_ReturnFeatureAttributes();
    [CompilerGeneratedAttribute]
public void set_ReturnFeatureAttributes(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_FeatureAttributesToReturn();
    [CompilerGeneratedAttribute]
public void set_FeatureAttributesToReturn(IEnumerable`1<string> value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRasterMapType : Enum {
    public int value__;
    public static CloudRasterMapType Default;
    public static CloudRasterMapType Light;
    public static CloudRasterMapType Dark;
    public static CloudRasterMapType Hybrid;
    public static CloudRasterMapType Aerial;
    public static CloudRasterMapType TransparentBackground;
}
internal class ThinkGeo.Core.CloudRasterTileInfo : object {
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private RasterTile rasterTile;
    [ObfuscationAttribute]
private Exception exception;
    public RectangleShape BoundingBox { get; public set; }
    public RasterTile RasterTile { get; public set; }
    public string TileId { get; }
    internal Exception Exception { get; internal set; }
    public CloudRasterTileInfo(RasterTile rasterTile, RectangleShape boundingBox);
    public RectangleShape get_BoundingBox();
    public void set_BoundingBox(RectangleShape value);
    public RasterTile get_RasterTile();
    public void set_RasterTile(RasterTile value);
    public string get_TileId();
    internal Exception get_Exception();
    internal void set_Exception(Exception value);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestAllTimeZoneNamesFromResponse : object {
    [CompilerGeneratedAttribute]
private Collection`1<string> <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public Collection`1<string> data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<string> get_data();
    [CompilerGeneratedAttribute]
public void set_data(Collection`1<string> value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestAllTimeZoneResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestAllTimeZoneResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestAllTimeZoneResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestAllTimeZoneResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestAllTimeZoneResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestAllTimeZoneResponseData : object {
    public CloudRequestTimeZone[] timezones;
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestColorResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestColorResponseData <Data>k__BackingField;
    public CloudRequestColorResponseData Data { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestColorResponseData get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(CloudRequestColorResponseData value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestColorResponseData : object {
    [CompilerGeneratedAttribute]
private List`1<string> <Colors>k__BackingField;
    public List`1<string> Colors { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Colors();
    [CompilerGeneratedAttribute]
public void set_Colors(List`1<string> value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestElevationResponseData <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestElevationResponseData Data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestElevationResponseData get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(CloudRequestElevationResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResponseData : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    public double elevation { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultOfMultiPointsResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultOfMultiPointsResponseDataItem[] <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultOfMultiPointsResponseLowestElevationPoint <lowestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultOfMultiPointsResponseHighestElevationPoint <highestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <averageElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestElevationResultOfMultiPointsResponseDataItem[] data { get; public set; }
    public CloudRequestElevationResultOfMultiPointsResponseLowestElevationPoint lowestElevationPoint { get; public set; }
    public CloudRequestElevationResultOfMultiPointsResponseHighestElevationPoint highestElevationPoint { get; public set; }
    public Nullable`1<double> averageElevation { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultOfMultiPointsResponseDataItem[] get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestElevationResultOfMultiPointsResponseDataItem[] value);
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultOfMultiPointsResponseLowestElevationPoint get_lowestElevationPoint();
    [CompilerGeneratedAttribute]
public void set_lowestElevationPoint(CloudRequestElevationResultOfMultiPointsResponseLowestElevationPoint value);
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultOfMultiPointsResponseHighestElevationPoint get_highestElevationPoint();
    [CompilerGeneratedAttribute]
public void set_highestElevationPoint(CloudRequestElevationResultOfMultiPointsResponseHighestElevationPoint value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_averageElevation();
    [CompilerGeneratedAttribute]
public void set_averageElevation(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultOfMultiPointsResponseDataItem : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, String[]> <errors>k__BackingField;
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    public Dictionary`2<string, String[]> errors { get; public set; }
    public double elevation { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, String[]> get_errors();
    [CompilerGeneratedAttribute]
public void set_errors(Dictionary`2<string, String[]> value);
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultOfMultiPointsResponseHighestElevationPoint : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    public double elevation { get; public set; }
    public string wellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultOfMultiPointsResponseLowestElevationPoint : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    public double elevation { get; public set; }
    public string wellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultResponseDataItem[] <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultResponseLowestElevationPoint <lowestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestElevationResultResponseHighestElevationPoint <highestElevationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private double <averageElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestElevationResultResponseDataItem[] data { get; public set; }
    public CloudRequestElevationResultResponseLowestElevationPoint lowestElevationPoint { get; public set; }
    public CloudRequestElevationResultResponseHighestElevationPoint highestElevationPoint { get; public set; }
    public double averageElevation { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultResponseDataItem[] get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestElevationResultResponseDataItem[] value);
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultResponseLowestElevationPoint get_lowestElevationPoint();
    [CompilerGeneratedAttribute]
public void set_lowestElevationPoint(CloudRequestElevationResultResponseLowestElevationPoint value);
    [CompilerGeneratedAttribute]
public CloudRequestElevationResultResponseHighestElevationPoint get_highestElevationPoint();
    [CompilerGeneratedAttribute]
public void set_highestElevationPoint(CloudRequestElevationResultResponseHighestElevationPoint value);
    [CompilerGeneratedAttribute]
public double get_averageElevation();
    [CompilerGeneratedAttribute]
public void set_averageElevation(double value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultResponseDataItem : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    public double elevation { get; public set; }
    public string wellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultResponseHighestElevationPoint : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    public double elevation { get; public set; }
    public string wellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestElevationResultResponseLowestElevationPoint : object {
    [CompilerGeneratedAttribute]
private double <elevation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    public double elevation { get; public set; }
    public string wellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public double get_elevation();
    [CompilerGeneratedAttribute]
public void set_elevation(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGeocodingResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGeocodingResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestGeocodingResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGeocodingResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestGeocodingResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGeocodingResultResponseData : object {
    [CompilerGeneratedAttribute]
private GeocodingLocationDto[] <locations>k__BackingField;
    public GeocodingLocationDto[] locations { get; public set; }
    [CompilerGeneratedAttribute]
public GeocodingLocationDto[] get_locations();
    [CompilerGeneratedAttribute]
public void set_locations(GeocodingLocationDto[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetAttributesOfLayerResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGetAttributesOfLayerResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestGetAttributesOfLayerResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGetAttributesOfLayerResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestGetAttributesOfLayerResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetAttributesOfLayerResultResponseData : object {
    [CompilerGeneratedAttribute]
private List`1<string> <attributes>k__BackingField;
    public List`1<string> attributes { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_attributes();
    [CompilerGeneratedAttribute]
public void set_attributes(List`1<string> value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetDistanceCostMatrixResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRoutingDistanceCostMatrixResult <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRoutingDistanceCostMatrixResult data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingDistanceCostMatrixResult get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRoutingDistanceCostMatrixResult value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetLayersResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGetLayersResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestGetLayersResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGetLayersResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestGetLayersResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetLayersResultResponseData : object {
    [CompilerGeneratedAttribute]
private List`1<string> <layers>k__BackingField;
    public List`1<string> layers { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_layers();
    [CompilerGeneratedAttribute]
public void set_layers(List`1<string> value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetProjectGeometryResultResponseData : object {
    [CompilerGeneratedAttribute]
private string <wkt>k__BackingField;
    public string wkt { get; public set; }
    [CompilerGeneratedAttribute]
public string get_wkt();
    [CompilerGeneratedAttribute]
public void set_wkt(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetRouteResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRoutingRouteResult <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRoutingRouteResult data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingRouteResult get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRoutingRouteResult value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetServiceAreaResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRoutingServiceAreaResult <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRoutingServiceAreaResult data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingServiceAreaResult get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRoutingServiceAreaResult value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGetTimeCostMatrixResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRoutingTimeCostMatrixResult <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRoutingTimeCostMatrixResult data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingTimeCostMatrixResult get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRoutingTimeCostMatrixResult value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGradeResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGradeResponseDataItem[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestGradeResponseLowestGradeSegment <lowestGradeSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestGradeResponseHighestGradeSegment <highestGradeSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private double <averageGrade>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestGradeResponseDataItem[] Data { get; public set; }
    public CloudRequestGradeResponseLowestGradeSegment lowestGradeSegment { get; public set; }
    public CloudRequestGradeResponseHighestGradeSegment highestGradeSegment { get; public set; }
    public double averageGrade { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGradeResponseDataItem[] get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(CloudRequestGradeResponseDataItem[] value);
    [CompilerGeneratedAttribute]
public CloudRequestGradeResponseLowestGradeSegment get_lowestGradeSegment();
    [CompilerGeneratedAttribute]
public void set_lowestGradeSegment(CloudRequestGradeResponseLowestGradeSegment value);
    [CompilerGeneratedAttribute]
public CloudRequestGradeResponseHighestGradeSegment get_highestGradeSegment();
    [CompilerGeneratedAttribute]
public void set_highestGradeSegment(CloudRequestGradeResponseHighestGradeSegment value);
    [CompilerGeneratedAttribute]
public double get_averageGrade();
    [CompilerGeneratedAttribute]
public void set_averageGrade(double value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGradeResponseDataItem : object {
    [CompilerGeneratedAttribute]
private double <grade>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    [CompilerGeneratedAttribute]
private double <startingElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <endingElevation>k__BackingField;
    public double grade { get; public set; }
    public string wellKnownText { get; public set; }
    public double startingElevation { get; public set; }
    public double endingElevation { get; public set; }
    [CompilerGeneratedAttribute]
public double get_grade();
    [CompilerGeneratedAttribute]
public void set_grade(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
    [CompilerGeneratedAttribute]
public double get_startingElevation();
    [CompilerGeneratedAttribute]
public void set_startingElevation(double value);
    [CompilerGeneratedAttribute]
public double get_endingElevation();
    [CompilerGeneratedAttribute]
public void set_endingElevation(double value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGradeResponseHighestGradeSegment : object {
    [CompilerGeneratedAttribute]
private double <grade>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    [CompilerGeneratedAttribute]
private double <startingElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <endingElevation>k__BackingField;
    public double grade { get; public set; }
    public string wellKnownText { get; public set; }
    public double startingElevation { get; public set; }
    public double endingElevation { get; public set; }
    [CompilerGeneratedAttribute]
public double get_grade();
    [CompilerGeneratedAttribute]
public void set_grade(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
    [CompilerGeneratedAttribute]
public double get_startingElevation();
    [CompilerGeneratedAttribute]
public void set_startingElevation(double value);
    [CompilerGeneratedAttribute]
public double get_endingElevation();
    [CompilerGeneratedAttribute]
public void set_endingElevation(double value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGradeResponseLowestGradeSegment : object {
    [CompilerGeneratedAttribute]
private double <grade>k__BackingField;
    [CompilerGeneratedAttribute]
private string <wellKnownText>k__BackingField;
    [CompilerGeneratedAttribute]
private double <startingElevation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <endingElevation>k__BackingField;
    public double grade { get; public set; }
    public string wellKnownText { get; public set; }
    public double startingElevation { get; public set; }
    public double endingElevation { get; public set; }
    [CompilerGeneratedAttribute]
public double get_grade();
    [CompilerGeneratedAttribute]
public void set_grade(double value);
    [CompilerGeneratedAttribute]
public string get_wellKnownText();
    [CompilerGeneratedAttribute]
public void set_wellKnownText(string value);
    [CompilerGeneratedAttribute]
public double get_startingElevation();
    [CompilerGeneratedAttribute]
public void set_startingElevation(double value);
    [CompilerGeneratedAttribute]
public double get_endingElevation();
    [CompilerGeneratedAttribute]
public void set_endingElevation(double value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGroupedColorResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGroupedColorResponseDataItem[] <Data>k__BackingField;
    public CloudRequestGroupedColorResponseDataItem[] Data { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGroupedColorResponseDataItem[] get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(CloudRequestGroupedColorResponseDataItem[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestGroupedColorResponseDataItem : object {
    [CompilerGeneratedAttribute]
private List`1<string> <Colors>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseColor>k__BackingField;
    public List`1<string> Colors { get; public set; }
    public string BaseColor { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_Colors();
    [CompilerGeneratedAttribute]
public void set_Colors(List`1<string> value);
    [CompilerGeneratedAttribute]
public string get_BaseColor();
    [CompilerGeneratedAttribute]
public void set_BaseColor(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestMultiGeocodingResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestMultiGeocodingResultResponseDataItem[] <data>k__BackingField;
    public CloudRequestMultiGeocodingResultResponseDataItem[] data { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestMultiGeocodingResultResponseDataItem[] get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestMultiGeocodingResultResponseDataItem[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestMultiGeocodingResultResponseDataItem : object {
    [CompilerGeneratedAttribute]
private GeocodingLocationDto[] <locations>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, String[]> <errors>k__BackingField;
    public GeocodingLocationDto[] locations { get; public set; }
    public Dictionary`2<string, String[]> errors { get; public set; }
    [CompilerGeneratedAttribute]
public GeocodingLocationDto[] get_locations();
    [CompilerGeneratedAttribute]
public void set_locations(GeocodingLocationDto[] value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, String[]> get_errors();
    [CompilerGeneratedAttribute]
public void set_errors(Dictionary`2<string, String[]> value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestOptimizationResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRoutingTspResult <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRoutingTspResult data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingTspResult get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRoutingTspResult value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestProjectGeometriesResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestProjectGeometriesResultResponseDataItem[] <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestProjectGeometriesResultResponseDataItem[] data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestProjectGeometriesResultResponseDataItem[] get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestProjectGeometriesResultResponseDataItem[] value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestProjectGeometriesResultResponseDataItem : object {
    [CompilerGeneratedAttribute]
private string <projectedWellKnownText>k__BackingField;
    public Dictionary`2<string, String[]> errors;
    public string projectedWellKnownText { get; public set; }
    [CompilerGeneratedAttribute]
public string get_projectedWellKnownText();
    [CompilerGeneratedAttribute]
public void set_projectedWellKnownText(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestProjectGeometryResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestGetProjectGeometryResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestGetProjectGeometryResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestGetProjectGeometryResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestGetProjectGeometryResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestQueryResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestQueryResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestQueryResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestQueryResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestQueryResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestQueryResultResponseData : object {
    [CompilerGeneratedAttribute]
private CloudRequestQueryResultResponseFeatureItem[] <features>k__BackingField;
    public CloudRequestQueryResultResponseFeatureItem[] features { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestQueryResultResponseFeatureItem[] get_features();
    [CompilerGeneratedAttribute]
public void set_features(CloudRequestQueryResultResponseFeatureItem[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestQueryResultResponseFeatureItem : object {
    [CompilerGeneratedAttribute]
private string <id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <geometry>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <attributes>k__BackingField;
    public string id { get; public set; }
    public string geometry { get; public set; }
    public Dictionary`2<string, string> attributes { get; public set; }
    [CompilerGeneratedAttribute]
public string get_id();
    [CompilerGeneratedAttribute]
public void set_id(string value);
    [CompilerGeneratedAttribute]
public string get_geometry();
    [CompilerGeneratedAttribute]
public void set_geometry(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_attributes();
    [CompilerGeneratedAttribute]
public void set_attributes(Dictionary`2<string, string> value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestResponseError : object {
    [CompilerGeneratedAttribute]
private int <code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <message>k__BackingField;
    public int code { get; public set; }
    public string message { get; public set; }
    [CompilerGeneratedAttribute]
public int get_code();
    [CompilerGeneratedAttribute]
public void set_code(int value);
    [CompilerGeneratedAttribute]
public string get_message();
    [CompilerGeneratedAttribute]
public void set_message(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultArrayResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultArrayResponseDataItem[] <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestReverseGeocoderResultArrayResponseDataItem[] data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultArrayResponseDataItem[] get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestReverseGeocoderResultArrayResponseDataItem[] value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultArrayResponseDataItem : object {
    public Dictionary`2<string, String[]> errors;
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation <bestMatchLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation[] <nearbyLocations>k__BackingField;
    public CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation bestMatchLocation { get; public set; }
    public CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation[] nearbyLocations { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation get_bestMatchLocation();
    [CompilerGeneratedAttribute]
public void set_bestMatchLocation(CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation value);
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation[] get_nearbyLocations();
    [CompilerGeneratedAttribute]
public void set_nearbyLocations(CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultArrayResponseDataMatchLocation : object {
    [CompilerGeneratedAttribute]
private ReverseGeocodingLocationDto <data>k__BackingField;
    public ReverseGeocodingLocationDto data { get; public set; }
    [CompilerGeneratedAttribute]
public ReverseGeocodingLocationDto get_data();
    [CompilerGeneratedAttribute]
public void set_data(ReverseGeocodingLocationDto value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultResponseData <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestReverseGeocoderResultResponseData data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultResponseData get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestReverseGeocoderResultResponseData value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultResponseData : object {
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultResponseDataMatchLocation <bestMatchLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestReverseGeocoderResultResponseDataMatchLocation[] <nearbyLocations>k__BackingField;
    public CloudRequestReverseGeocoderResultResponseDataMatchLocation bestMatchLocation { get; public set; }
    public CloudRequestReverseGeocoderResultResponseDataMatchLocation[] nearbyLocations { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultResponseDataMatchLocation get_bestMatchLocation();
    [CompilerGeneratedAttribute]
public void set_bestMatchLocation(CloudRequestReverseGeocoderResultResponseDataMatchLocation value);
    [CompilerGeneratedAttribute]
public CloudRequestReverseGeocoderResultResponseDataMatchLocation[] get_nearbyLocations();
    [CompilerGeneratedAttribute]
public void set_nearbyLocations(CloudRequestReverseGeocoderResultResponseDataMatchLocation[] value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestReverseGeocoderResultResponseDataMatchLocation : object {
    [CompilerGeneratedAttribute]
private ReverseGeocodingLocationDto <data>k__BackingField;
    public ReverseGeocodingLocationDto data { get; public set; }
    [CompilerGeneratedAttribute]
public ReverseGeocodingLocationDto get_data();
    [CompilerGeneratedAttribute]
public void set_data(ReverseGeocodingLocationDto value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestTimeZone : object {
    [CompilerGeneratedAttribute]
private string <timezone>k__BackingField;
    [CompilerGeneratedAttribute]
private string <countryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <countryCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <comment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <currentUtcTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <currentLocalTime>k__BackingField;
    [CompilerGeneratedAttribute]
private double <offsetSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <daylightSavingsActive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <geometry>k__BackingField;
    public string timezone { get; public set; }
    public string countryName { get; public set; }
    public string countryCode { get; public set; }
    public string comment { get; public set; }
    public string currentUtcTime { get; public set; }
    public string currentLocalTime { get; public set; }
    public double offsetSeconds { get; public set; }
    public bool daylightSavingsActive { get; public set; }
    public string geometry { get; public set; }
    [CompilerGeneratedAttribute]
public string get_timezone();
    [CompilerGeneratedAttribute]
public void set_timezone(string value);
    [CompilerGeneratedAttribute]
public string get_countryName();
    [CompilerGeneratedAttribute]
public void set_countryName(string value);
    [CompilerGeneratedAttribute]
public string get_countryCode();
    [CompilerGeneratedAttribute]
public void set_countryCode(string value);
    [CompilerGeneratedAttribute]
public string get_comment();
    [CompilerGeneratedAttribute]
public void set_comment(string value);
    [CompilerGeneratedAttribute]
public string get_currentUtcTime();
    [CompilerGeneratedAttribute]
public void set_currentUtcTime(string value);
    [CompilerGeneratedAttribute]
public string get_currentLocalTime();
    [CompilerGeneratedAttribute]
public void set_currentLocalTime(string value);
    [CompilerGeneratedAttribute]
public double get_offsetSeconds();
    [CompilerGeneratedAttribute]
public void set_offsetSeconds(double value);
    [CompilerGeneratedAttribute]
public bool get_daylightSavingsActive();
    [CompilerGeneratedAttribute]
public void set_daylightSavingsActive(bool value);
    [CompilerGeneratedAttribute]
public string get_geometry();
    [CompilerGeneratedAttribute]
public void set_geometry(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestTimeZoneResultResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestTimeZone <data>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRequestResponseError <error>k__BackingField;
    public CloudRequestTimeZone data { get; public set; }
    public CloudRequestResponseError error { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestTimeZone get_data();
    [CompilerGeneratedAttribute]
public void set_data(CloudRequestTimeZone value);
    [CompilerGeneratedAttribute]
public CloudRequestResponseError get_error();
    [CompilerGeneratedAttribute]
public void set_error(CloudRequestResponseError value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestTimeZoneResultResponseData : object {
    [CompilerGeneratedAttribute]
private string <timezone>k__BackingField;
    [CompilerGeneratedAttribute]
private string <countryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <countryCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <comment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <currentUtcTime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <currentLocalTime>k__BackingField;
    [CompilerGeneratedAttribute]
private double <offsetSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <daylightSavingsActive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <geometry>k__BackingField;
    public string timezone { get; public set; }
    public string countryName { get; public set; }
    public string countryCode { get; public set; }
    public string comment { get; public set; }
    public string currentUtcTime { get; public set; }
    public string currentLocalTime { get; public set; }
    public double offsetSeconds { get; public set; }
    public bool daylightSavingsActive { get; public set; }
    public string geometry { get; public set; }
    [CompilerGeneratedAttribute]
public string get_timezone();
    [CompilerGeneratedAttribute]
public void set_timezone(string value);
    [CompilerGeneratedAttribute]
public string get_countryName();
    [CompilerGeneratedAttribute]
public void set_countryName(string value);
    [CompilerGeneratedAttribute]
public string get_countryCode();
    [CompilerGeneratedAttribute]
public void set_countryCode(string value);
    [CompilerGeneratedAttribute]
public string get_comment();
    [CompilerGeneratedAttribute]
public void set_comment(string value);
    [CompilerGeneratedAttribute]
public string get_currentUtcTime();
    [CompilerGeneratedAttribute]
public void set_currentUtcTime(string value);
    [CompilerGeneratedAttribute]
public string get_currentLocalTime();
    [CompilerGeneratedAttribute]
public void set_currentLocalTime(string value);
    [CompilerGeneratedAttribute]
public double get_offsetSeconds();
    [CompilerGeneratedAttribute]
public void set_offsetSeconds(double value);
    [CompilerGeneratedAttribute]
public bool get_daylightSavingsActive();
    [CompilerGeneratedAttribute]
public void set_daylightSavingsActive(bool value);
    [CompilerGeneratedAttribute]
public string get_geometry();
    [CompilerGeneratedAttribute]
public void set_geometry(string value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestTokenResponse : object {
    [CompilerGeneratedAttribute]
private CloudRequestTokenResponseData <Data>k__BackingField;
    public CloudRequestTokenResponseData Data { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRequestTokenResponseData get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(CloudRequestTokenResponseData value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudRequestTokenResponseData : object {
    [CompilerGeneratedAttribute]
private string <access_token>k__BackingField;
    [CompilerGeneratedAttribute]
private int <expires_in>k__BackingField;
    [CompilerGeneratedAttribute]
private string <token_type>k__BackingField;
    public string access_token { get; public set; }
    public int expires_in { get; public set; }
    public string token_type { get; public set; }
    [CompilerGeneratedAttribute]
public string get_access_token();
    [CompilerGeneratedAttribute]
public void set_access_token(string value);
    [CompilerGeneratedAttribute]
public int get_expires_in();
    [CompilerGeneratedAttribute]
public void set_expires_in(int value);
    [CompilerGeneratedAttribute]
public string get_token_type();
    [CompilerGeneratedAttribute]
public void set_token_type(string value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudReverseGeocodingLocation : object {
    [CompilerGeneratedAttribute]
private Feature <LocationFeature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectionFromQueryFeature>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DistanceFromQueryFeature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationCategory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HouseNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Postcode>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AddressComponents>k__BackingField;
    public Feature LocationFeature { get; public set; }
    public string LocationName { get; public set; }
    public string DirectionFromQueryFeature { get; public set; }
    public double DistanceFromQueryFeature { get; public set; }
    public string LocationCategory { get; public set; }
    public string LocationType { get; public set; }
    public string Address { get; public set; }
    public string HouseNumber { get; public set; }
    public Dictionary`2<string, string> Properties { get; public set; }
    public string Postcode { get; public set; }
    public Dictionary`2<string, string> AddressComponents { get; public set; }
    [CompilerGeneratedAttribute]
public Feature get_LocationFeature();
    [CompilerGeneratedAttribute]
public void set_LocationFeature(Feature value);
    [CompilerGeneratedAttribute]
public string get_LocationName();
    [CompilerGeneratedAttribute]
public void set_LocationName(string value);
    [CompilerGeneratedAttribute]
public string get_DirectionFromQueryFeature();
    [CompilerGeneratedAttribute]
public void set_DirectionFromQueryFeature(string value);
    [CompilerGeneratedAttribute]
public double get_DistanceFromQueryFeature();
    [CompilerGeneratedAttribute]
public void set_DistanceFromQueryFeature(double value);
    [CompilerGeneratedAttribute]
public string get_LocationCategory();
    [CompilerGeneratedAttribute]
public void set_LocationCategory(string value);
    [CompilerGeneratedAttribute]
public string get_LocationType();
    [CompilerGeneratedAttribute]
public void set_LocationType(string value);
    [CompilerGeneratedAttribute]
public string get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(string value);
    [CompilerGeneratedAttribute]
public string get_HouseNumber();
    [CompilerGeneratedAttribute]
public void set_HouseNumber(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_Postcode();
    [CompilerGeneratedAttribute]
public void set_Postcode(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AddressComponents();
    [CompilerGeneratedAttribute]
public void set_AddressComponents(Dictionary`2<string, string> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudReverseGeocodingOptions : object {
    [CompilerGeneratedAttribute]
private string <Lang>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudLocationCategories <LocationCategories>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudReverseGeocodingResultDetail <ResultDetail>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <DistanceUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<string> <LocationTypes>k__BackingField;
    public string Lang { get; public set; }
    public int MaxResults { get; public set; }
    public CloudLocationCategories LocationCategories { get; public set; }
    public CloudReverseGeocodingResultDetail ResultDetail { get; public set; }
    public DistanceUnit DistanceUnit { get; public set; }
    public Collection`1<string> LocationTypes { get; }
    [CompilerGeneratedAttribute]
public string get_Lang();
    [CompilerGeneratedAttribute]
public void set_Lang(string value);
    [CompilerGeneratedAttribute]
public int get_MaxResults();
    [CompilerGeneratedAttribute]
public void set_MaxResults(int value);
    [CompilerGeneratedAttribute]
public CloudLocationCategories get_LocationCategories();
    [CompilerGeneratedAttribute]
public void set_LocationCategories(CloudLocationCategories value);
    [CompilerGeneratedAttribute]
public CloudReverseGeocodingResultDetail get_ResultDetail();
    [CompilerGeneratedAttribute]
public void set_ResultDetail(CloudReverseGeocodingResultDetail value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public Collection`1<string> get_LocationTypes();
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudReverseGeocodingResult : object {
    [CompilerGeneratedAttribute]
private Feature <QueryFeature>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudReverseGeocodingLocation <BestMatchLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudReverseGeocodingLocation> <NearbyLocations>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public Feature QueryFeature { get; }
    public CloudReverseGeocodingLocation BestMatchLocation { get; }
    public Collection`1<CloudReverseGeocodingLocation> NearbyLocations { get; }
    public ThinkGeoCloudApplicationException Exception { get; }
    public CloudReverseGeocodingResult(Feature queryFeature, CloudReverseGeocodingLocation bestMatchLocation, ThinkGeoCloudApplicationException exception);
    [CompilerGeneratedAttribute]
public Feature get_QueryFeature();
    [CompilerGeneratedAttribute]
public CloudReverseGeocodingLocation get_BestMatchLocation();
    [CompilerGeneratedAttribute]
public Collection`1<CloudReverseGeocodingLocation> get_NearbyLocations();
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudReverseGeocodingResultDetail : Enum {
    public int value__;
    public static CloudReverseGeocodingResultDetail Default;
    public static CloudReverseGeocodingResultDetail Verbose;
    public static CloudReverseGeocodingResultDetail Standard;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingDistanceCostMatrixResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Origins>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Destinations>k__BackingField;
    [CompilerGeneratedAttribute]
private Single[0...,0...] <Distances>k__BackingField;
    public Collection`1<CloudRoutingWaypoint> Origins { get; public set; }
    public Collection`1<CloudRoutingWaypoint> Destinations { get; public set; }
    public Single[0...,0...] Distances { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Origins();
    [CompilerGeneratedAttribute]
public void set_Origins(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Destinations();
    [CompilerGeneratedAttribute]
public void set_Destinations(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public Single[0...,0...] get_Distances();
    [CompilerGeneratedAttribute]
public void set_Distances(Single[0...,0...] value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetCostMatrixOptions : object {
    [CompilerGeneratedAttribute]
private float <CoordinateSnapRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <CoordinateSnapRadiusUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <DistanceUnit>k__BackingField;
    public float CoordinateSnapRadius { get; public set; }
    public DistanceUnit CoordinateSnapRadiusUnit { get; public set; }
    public DistanceUnit DistanceUnit { get; public set; }
    [CompilerGeneratedAttribute]
public float get_CoordinateSnapRadius();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadius(float value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_CoordinateSnapRadiusUnit();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadiusUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(DistanceUnit value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetDistanceCostMatrixResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingDistanceCostMatrixResult <CostMatrixResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public CloudRoutingDistanceCostMatrixResult CostMatrixResult { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingDistanceCostMatrixResult get_CostMatrixResult();
    [CompilerGeneratedAttribute]
public void set_CostMatrixResult(CloudRoutingDistanceCostMatrixResult value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetRouteOptions : object {
    [CompilerGeneratedAttribute]
private bool <TurnByTurn>k__BackingField;
    [CompilerGeneratedAttribute]
private float <CoordinateSnapRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <CoordinateSnapRadiusUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <DistanceUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<RouteType> <RouteType>k__BackingField;
    public bool TurnByTurn { get; public set; }
    public float CoordinateSnapRadius { get; public set; }
    public DistanceUnit CoordinateSnapRadiusUnit { get; public set; }
    public DistanceUnit DistanceUnit { get; public set; }
    public Nullable`1<RouteType> RouteType { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_TurnByTurn();
    [CompilerGeneratedAttribute]
public void set_TurnByTurn(bool value);
    [CompilerGeneratedAttribute]
public float get_CoordinateSnapRadius();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadius(float value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_CoordinateSnapRadiusUnit();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadiusUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public Nullable`1<RouteType> get_RouteType();
    [CompilerGeneratedAttribute]
public void set_RouteType(Nullable`1<RouteType> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetRouteResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingRouteResult <RouteResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public CloudRoutingRouteResult RouteResult { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingRouteResult get_RouteResult();
    [CompilerGeneratedAttribute]
public void set_RouteResult(CloudRoutingRouteResult value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetServiceAreaOptions : object {
    [CompilerGeneratedAttribute]
private DistanceUnit <DistanceUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private float <ContourGranularity>k__BackingField;
    [CompilerGeneratedAttribute]
private float <CoordinateSnapRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <CoordinateSnapRadiusUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private float <GridSizeInMeters>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRoutingServiceAreaSeparationType <ServiceAreaSeparationType>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRoutingServiceAreaObjectType <ServiceAreaType>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRoutingServiceAreaTravelDirection <TravelDirection>k__BackingField;
    public DistanceUnit DistanceUnit { get; public set; }
    public float ContourGranularity { get; public set; }
    public float CoordinateSnapRadius { get; public set; }
    public DistanceUnit CoordinateSnapRadiusUnit { get; public set; }
    public float GridSizeInMeters { get; public set; }
    public CloudRoutingServiceAreaSeparationType ServiceAreaSeparationType { get; public set; }
    public CloudRoutingServiceAreaObjectType ServiceAreaType { get; public set; }
    public CloudRoutingServiceAreaTravelDirection TravelDirection { get; public set; }
    [CompilerGeneratedAttribute]
public DistanceUnit get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public float get_ContourGranularity();
    [CompilerGeneratedAttribute]
public void set_ContourGranularity(float value);
    [CompilerGeneratedAttribute]
public float get_CoordinateSnapRadius();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadius(float value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_CoordinateSnapRadiusUnit();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadiusUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public float get_GridSizeInMeters();
    [CompilerGeneratedAttribute]
public void set_GridSizeInMeters(float value);
    [CompilerGeneratedAttribute]
public CloudRoutingServiceAreaSeparationType get_ServiceAreaSeparationType();
    [CompilerGeneratedAttribute]
public void set_ServiceAreaSeparationType(CloudRoutingServiceAreaSeparationType value);
    [CompilerGeneratedAttribute]
public CloudRoutingServiceAreaObjectType get_ServiceAreaType();
    [CompilerGeneratedAttribute]
public void set_ServiceAreaType(CloudRoutingServiceAreaObjectType value);
    [CompilerGeneratedAttribute]
public CloudRoutingServiceAreaTravelDirection get_TravelDirection();
    [CompilerGeneratedAttribute]
public void set_TravelDirection(CloudRoutingServiceAreaTravelDirection value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetServiceAreaResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingServiceAreaResult <ServiceAreaResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public CloudRoutingServiceAreaResult ServiceAreaResult { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingServiceAreaResult get_ServiceAreaResult();
    [CompilerGeneratedAttribute]
public void set_ServiceAreaResult(CloudRoutingServiceAreaResult value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingGetTimeCostMatrixResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingTimeCostMatrixResult <CostMatrixResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public CloudRoutingTimeCostMatrixResult CostMatrixResult { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingTimeCostMatrixResult get_CostMatrixResult();
    [CompilerGeneratedAttribute]
public void set_CostMatrixResult(CloudRoutingTimeCostMatrixResult value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingOptimizationOptions : object {
    [CompilerGeneratedAttribute]
private bool <Roundtrip>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRoutingTspFixSourceCoordinate <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudRoutingTspFixDestinationCoordinate <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TurnByTurn>k__BackingField;
    [CompilerGeneratedAttribute]
private float <CoordinateSnapRadius>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <CoordinateSnapRadiusUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private DistanceUnit <DistanceUnit>k__BackingField;
    public bool Roundtrip { get; public set; }
    public CloudRoutingTspFixSourceCoordinate Source { get; public set; }
    public CloudRoutingTspFixDestinationCoordinate Destination { get; public set; }
    public bool TurnByTurn { get; public set; }
    public float CoordinateSnapRadius { get; public set; }
    public DistanceUnit CoordinateSnapRadiusUnit { get; public set; }
    public DistanceUnit DistanceUnit { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Roundtrip();
    [CompilerGeneratedAttribute]
public void set_Roundtrip(bool value);
    [CompilerGeneratedAttribute]
public CloudRoutingTspFixSourceCoordinate get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(CloudRoutingTspFixSourceCoordinate value);
    [CompilerGeneratedAttribute]
public CloudRoutingTspFixDestinationCoordinate get_Destination();
    [CompilerGeneratedAttribute]
public void set_Destination(CloudRoutingTspFixDestinationCoordinate value);
    [CompilerGeneratedAttribute]
public bool get_TurnByTurn();
    [CompilerGeneratedAttribute]
public void set_TurnByTurn(bool value);
    [CompilerGeneratedAttribute]
public float get_CoordinateSnapRadius();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadius(float value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_CoordinateSnapRadiusUnit();
    [CompilerGeneratedAttribute]
public void set_CoordinateSnapRadiusUnit(DistanceUnit value);
    [CompilerGeneratedAttribute]
public DistanceUnit get_DistanceUnit();
    [CompilerGeneratedAttribute]
public void set_DistanceUnit(DistanceUnit value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingOptimizationResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingTspResult <TspResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ThinkGeoCloudApplicationException <Exception>k__BackingField;
    public CloudRoutingTspResult TspResult { get; public set; }
    public ThinkGeoCloudApplicationException Exception { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingTspResult get_TspResult();
    [CompilerGeneratedAttribute]
public void set_TspResult(CloudRoutingTspResult value);
    [CompilerGeneratedAttribute]
public ThinkGeoCloudApplicationException get_Exception();
    [CompilerGeneratedAttribute]
public void set_Exception(ThinkGeoCloudApplicationException value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingRoute : object {
    [CompilerGeneratedAttribute]
private double <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private LineShape <Shape>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingSegment> <Segments>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Warnings>k__BackingField;
    public double Distance { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudDurationMinuteReader")]
public TimeSpan Duration { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudShapeWktConverter")]
[CloudJsonPropertyAttribute("geometry")]
public LineShape Shape { get; public set; }
    public Collection`1<CloudRoutingSegment> Segments { get; public set; }
    public Dictionary`2<string, string> Warnings { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(double value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public LineShape get_Shape();
    [CompilerGeneratedAttribute]
public void set_Shape(LineShape value);
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingSegment> get_Segments();
    [CompilerGeneratedAttribute]
public void set_Segments(Collection`1<CloudRoutingSegment> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Warnings();
    [CompilerGeneratedAttribute]
public void set_Warnings(Dictionary`2<string, string> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingRouteResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Waypoints>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingRoute> <Routes>k__BackingField;
    public Collection`1<CloudRoutingWaypoint> Waypoints { get; public set; }
    public Collection`1<CloudRoutingRoute> Routes { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Waypoints();
    [CompilerGeneratedAttribute]
public void set_Waypoints(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingRoute> get_Routes();
    [CompilerGeneratedAttribute]
public void set_Routes(Collection`1<CloudRoutingRoute> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingSegment : object {
    [CompilerGeneratedAttribute]
private double <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Instruction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManeuverType>k__BackingField;
    [CompilerGeneratedAttribute]
private LineShape <Shape>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Ref>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsToll>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsPrivate>k__BackingField;
    [CompilerGeneratedAttribute]
private Vertex <ManeuverLocation>k__BackingField;
    public double Distance { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudDurationMinuteReader")]
public TimeSpan Duration { get; public set; }
    public string Name { get; public set; }
    public string Instruction { get; public set; }
    public string ManeuverType { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudShapeWktConverter")]
[CloudJsonPropertyAttribute("geometry")]
public LineShape Shape { get; public set; }
    public string Ref { get; public set; }
    public Nullable`1<bool> IsToll { get; public set; }
    public Nullable`1<bool> IsPrivate { get; public set; }
    public Vertex ManeuverLocation { get; public set; }
    [CompilerGeneratedAttribute]
public double get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(double value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Instruction();
    [CompilerGeneratedAttribute]
public void set_Instruction(string value);
    [CompilerGeneratedAttribute]
public string get_ManeuverType();
    [CompilerGeneratedAttribute]
public void set_ManeuverType(string value);
    [CompilerGeneratedAttribute]
public LineShape get_Shape();
    [CompilerGeneratedAttribute]
public void set_Shape(LineShape value);
    [CompilerGeneratedAttribute]
public string get_Ref();
    [CompilerGeneratedAttribute]
public void set_Ref(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsToll();
    [CompilerGeneratedAttribute]
public void set_IsToll(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsPrivate();
    [CompilerGeneratedAttribute]
public void set_IsPrivate(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Vertex get_ManeuverLocation();
    [CompilerGeneratedAttribute]
public void set_ManeuverLocation(Vertex value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRoutingServiceAreaObjectType : Enum {
    public int value__;
    public static CloudRoutingServiceAreaObjectType Polygon;
    public static CloudRoutingServiceAreaObjectType LineString;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingServiceAreaResult : object {
    [CompilerGeneratedAttribute]
private CloudRoutingWaypoint <Waypoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<BaseShape> <ServiceAreas>k__BackingField;
    public CloudRoutingWaypoint Waypoint { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudShapeWktConverter")]
public Collection`1<BaseShape> ServiceAreas { get; public set; }
    [CompilerGeneratedAttribute]
public CloudRoutingWaypoint get_Waypoint();
    [CompilerGeneratedAttribute]
public void set_Waypoint(CloudRoutingWaypoint value);
    [CompilerGeneratedAttribute]
public Collection`1<BaseShape> get_ServiceAreas();
    [CompilerGeneratedAttribute]
public void set_ServiceAreas(Collection`1<BaseShape> value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRoutingServiceAreaSeparationType : Enum {
    public int value__;
    public static CloudRoutingServiceAreaSeparationType Separated;
    public static CloudRoutingServiceAreaSeparationType Merged;
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRoutingServiceAreaTravelDirection : Enum {
    public int value__;
    public static CloudRoutingServiceAreaTravelDirection From;
    public static CloudRoutingServiceAreaTravelDirection To;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingTimeCostMatrixResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Origins>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Destinations>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan[0...,0...] <Durations>k__BackingField;
    public Collection`1<CloudRoutingWaypoint> Origins { get; public set; }
    public Collection`1<CloudRoutingWaypoint> Destinations { get; public set; }
    [CloudJsonConverterAttribute("ThinkGeo.Core.CloudDurationMinuteReader")]
public TimeSpan[0...,0...] Durations { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Origins();
    [CompilerGeneratedAttribute]
public void set_Origins(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Destinations();
    [CompilerGeneratedAttribute]
public void set_Destinations(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public TimeSpan[0...,0...] get_Durations();
    [CompilerGeneratedAttribute]
public void set_Durations(TimeSpan[0...,0...] value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRoutingTspFixDestinationCoordinate : Enum {
    public int value__;
    public static CloudRoutingTspFixDestinationCoordinate Any;
    public static CloudRoutingTspFixDestinationCoordinate Last;
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudRoutingTspFixSourceCoordinate : Enum {
    public int value__;
    public static CloudRoutingTspFixSourceCoordinate Any;
    public static CloudRoutingTspFixSourceCoordinate First;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingTspResult : object {
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingWaypoint> <Waypoints>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<int> <VisitSequences>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CloudRoutingRoute> <Routes>k__BackingField;
    public Collection`1<CloudRoutingWaypoint> Waypoints { get; public set; }
    public Collection`1<int> VisitSequences { get; public set; }
    public Collection`1<CloudRoutingRoute> Routes { get; public set; }
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingWaypoint> get_Waypoints();
    [CompilerGeneratedAttribute]
public void set_Waypoints(Collection`1<CloudRoutingWaypoint> value);
    [CompilerGeneratedAttribute]
public Collection`1<int> get_VisitSequences();
    [CompilerGeneratedAttribute]
public void set_VisitSequences(Collection`1<int> value);
    [CompilerGeneratedAttribute]
public Collection`1<CloudRoutingRoute> get_Routes();
    [CompilerGeneratedAttribute]
public void set_Routes(Collection`1<CloudRoutingRoute> value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudRoutingWaypoint : object {
    [CompilerGeneratedAttribute]
private Vertex <Coordinate>k__BackingField;
    [CompilerGeneratedAttribute]
private float <SnappedDistance>k__BackingField;
    public Vertex Coordinate { get; public set; }
    public float SnappedDistance { get; public set; }
    [CompilerGeneratedAttribute]
public Vertex get_Coordinate();
    [CompilerGeneratedAttribute]
public void set_Coordinate(Vertex value);
    [CompilerGeneratedAttribute]
public float get_SnappedDistance();
    [CompilerGeneratedAttribute]
public void set_SnappedDistance(float value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.CloudShapeWktConverter : CloudJsonConverter`1<BaseShape> {
    public virtual BaseShape ReadJson(CloudGeoJObject jObject, Type objectType);
    public virtual void WriteJson(CloudGeoJObject jObject, BaseShape value);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.CloudTileSize : Enum {
    public int value__;
    public static CloudTileSize Default;
    public static CloudTileSize Small;
    public static CloudTileSize Medium;
}
[ObfuscationAttribute]
public class ThinkGeo.Core.CloudTimeZoneResult : object {
    [CompilerGeneratedAttribute]
private string <TimeZone>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CountryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CountryCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Comment>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CurrentLocalTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CurrentUtcTime>k__BackingField;
    [CompilerGeneratedAttribute]
private double <OffsetSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DaylightSavingsActive>k__BackingField;
    [CompilerGeneratedAttribute]
private MultipolygonShape <Shape>k__BackingField;
    public string TimeZone { get; }
    public string CountryName { get; }
    public string CountryCode { get; }
    public string Comment { get; }
    public DateTime CurrentLocalTime { get; }
    public DateTime CurrentUtcTime { get; }
    public double OffsetSeconds { get; }
    public bool DaylightSavingsActive { get; }
    public MultipolygonShape Shape { get; }
    public CloudTimeZoneResult(string timezone, string countryName, string countryCode, string comment, DateTime currentLocalTime, DateTime currentUtcTime, double offsetSeconds, bool daylightSavingsActive, MultipolygonShape shape);
    [CompilerGeneratedAttribute]
public string get_TimeZone();
    [CompilerGeneratedAttribute]
public string get_CountryName();
    [CompilerGeneratedAttribute]
public string get_CountryCode();
    [CompilerGeneratedAttribute]
public string get_Comment();
    [CompilerGeneratedAttribute]
public DateTime get_CurrentLocalTime();
    [CompilerGeneratedAttribute]
public DateTime get_CurrentUtcTime();
    [CompilerGeneratedAttribute]
public double get_OffsetSeconds();
    [CompilerGeneratedAttribute]
public bool get_DaylightSavingsActive();
    [CompilerGeneratedAttribute]
public MultipolygonShape get_Shape();
}
[ObfuscationAttribute]
internal static class ThinkGeo.Core.CloudValidators : object {
    internal static void ValueInRange(string parameterName, int value, int minValue, bool includeMinValue, int maxValue, bool includeMaxValue);
    internal static void ValueInRange(string parameterName, double value, double minValue, bool includeMinValue, double maxValue, bool includeMaxValue);
    internal static void ValueInRange(string parameterName, int value, int minValue, int maxValue);
    internal static void ValueInRange(string parameterName, double value, double minValue, double maxValue);
    internal static void NotNull(object value, string paramName);
    internal static void NotNullOrEmpty(string value, string paramName);
    internal static void ItemNotNull(IEnumerable`1<T> values, string paramName);
}
public class ThinkGeo.Core.ClusterPointStyle : Style {
    [ObfuscationAttribute]
private int cellSize;
    [ObfuscationAttribute]
private TextStyle defaultTextSytle;
    [ObfuscationAttribute]
private int minimumFeaturesPerCellToCluster;
    [ObfuscationAttribute]
private bool clusterCellLinesVisible;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    [ObfuscationAttribute]
private PointStyle clusteredPointStyle;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingClusteredFeatureClusterPointStyleEventArgs> tzE=;
    public PointStyle DefaultPointStyle { get; public set; }
    public PointStyle ClusteredPointStyle { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    public int CellSize { get; public set; }
    public bool ClusterCellLinesVisible { get; public set; }
    public int MinimumFeaturesPerCellToCluster { get; public set; }
    public ClusterPointStyle(PointStyle defaultPointStyle);
    public ClusterPointStyle(PointStyle defaultPointStyle, TextStyle defaultTextStyle);
    public ClusterPointStyle(PointStyle defaultPointStyle, TextStyle defaultTextStyle, PointStyle clusteredPointStyle);
    [CompilerGeneratedAttribute]
public void add_DrawingClusteredFeature(EventHandler`1<DrawingClusteredFeatureClusterPointStyleEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingClusteredFeature(EventHandler`1<DrawingClusteredFeatureClusterPointStyleEventArgs> value);
    public PointStyle get_DefaultPointStyle();
    public void set_DefaultPointStyle(PointStyle value);
    public PointStyle get_ClusteredPointStyle();
    public void set_ClusteredPointStyle(PointStyle value);
    public TextStyle get_DefaultTextStyle();
    public void set_DefaultTextStyle(TextStyle value);
    public Collection`1<Style> get_CustomStyles();
    public int get_CellSize();
    public void set_CellSize(int value);
    public bool get_ClusterCellLinesVisible();
    public void set_ClusterCellLinesVisible(bool value);
    public int get_MinimumFeaturesPerCellToCluster();
    public void set_MinimumFeaturesPerCellToCluster(int value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual void OnDrawingClusterdFeature(DrawingClusteredFeatureClusterPointStyleEventArgs e);
    private static bool uh8=(RectangleShape bbox, PointShape point);
    private static T uDE=(object obj);
}
public class ThinkGeo.Core.CollectedMapArgumentsMapViewEventArgs : EventArgs {
    [ObfuscationAttribute]
private MapArguments mapArguments;
    public MapArguments MapArguments { get; public set; }
    public CollectedMapArgumentsMapViewEventArgs(MapArguments mapArguments);
    public MapArguments get_MapArguments();
    public void set_MapArguments(MapArguments value);
}
public class ThinkGeo.Core.ColorCloudClient : CloudClient {
    public ColorCloudClient(string clientId, string clientSecret);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInAnalogousFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/BT4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInAnalogousFamilyAsync(int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInAnalogousFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/CD4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInAnalogousFamilyAsync(GeoColor color, int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInComplementaryFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/Cj4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInComplementaryFamilyAsync(int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInComplementaryFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/Cz4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInComplementaryFamilyAsync(GeoColor color, int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInContrastingFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/DD4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInContrastingFamilyAsync(int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInContrastingFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/DT4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInContrastingFamilyAsync(GeoColor color, int numberOfColors);
    public Collection`1<GeoColor> GetColorsInHueFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/Dj4=")]
public Task`1<Collection`1<GeoColor>> GetColorsInHueFamilyAsync(int numberOfColors);
    public Collection`1<GeoColor> GetColorsInHueFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/Dz4=")]
public Task`1<Collection`1<GeoColor>> GetColorsInHueFamilyAsync(GeoColor color, int numberOfColors);
    public Collection`1<GeoColor> GetColorsInQualityFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/ED4=")]
public Task`1<Collection`1<GeoColor>> GetColorsInQualityFamilyAsync(int numberOfColors);
    public Collection`1<GeoColor> GetColorsInQualityFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/ET4=")]
public Task`1<Collection`1<GeoColor>> GetColorsInQualityFamilyAsync(GeoColor color, int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInTetradFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/Ej4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInTetradFamilyAsync(int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInTetradFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/Ez4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInTetradFamilyAsync(GeoColor color, int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInTriadFamily(int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/FD4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInTriadFamilyAsync(int numberOfColors);
    public Dictionary`2<GeoColor, Collection`1<GeoColor>> GetColorsInTriadFamily(GeoColor color, int numberOfColors);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ColorCloudClient/FT4=")]
public Task`1<Dictionary`2<GeoColor, Collection`1<GeoColor>>> GetColorsInTriadFamilyAsync(GeoColor color, int numberOfColors);
    private Collection`1<GeoColor> xBQ=(WebResponse response);
    private Dictionary`2<GeoColor, Collection`1<GeoColor>> xRQ=(WebResponse response);
    private Collection`1<GeoColor> xhQ=(List`1<string> result);
    private GeoColor xxQ=(string colorExpression);
    private string yBQ=(GeoColor color);
}
[ObfuscationAttribute]
internal enum ThinkGeo.Core.ColorType : Enum {
    public int value__;
    public static ColorType NonStandardColor;
    public static ColorType StandardColor;
    public static ColorType SimpleColor;
}
public enum ThinkGeo.Core.ColorWheelDirection : Enum {
    public int value__;
    public static ColorWheelDirection Clockwise;
    public static ColorWheelDirection CounterClockwise;
}
public class ThinkGeo.Core.CommittedTransactionEventArgs : EventArgs {
    [ObfuscationAttribute]
private TransactionBuffer transactionBuffer;
    public TransactionBuffer TransactionBuffer { get; public set; }
    public CommittedTransactionEventArgs(TransactionBuffer transactionBuffer);
    public TransactionBuffer get_TransactionBuffer();
    public void set_TransactionBuffer(TransactionBuffer value);
}
public class ThinkGeo.Core.CommittingTransactionEventArgs : EventArgs {
    [ObfuscationAttribute]
private TransactionBuffer transactionBuffer;
    [ObfuscationAttribute]
private bool cancel;
    public bool Cancel { get; public set; }
    public TransactionBuffer TransactionBuffer { get; public set; }
    public CommittingTransactionEventArgs(TransactionBuffer transactionBuffer);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public TransactionBuffer get_TransactionBuffer();
    public void set_TransactionBuffer(TransactionBuffer value);
}
public class ThinkGeo.Core.CompositeStyle : Style {
    [ObfuscationAttribute]
private ObservableCollection`1<Style> styles;
    [ObfuscationAttribute]
private Collection`1<string> filtersFromStyles;
    public ObservableCollection`1<Style> Styles { get; }
    protected Collection`1<string> FiltersCore { get; }
    public CompositeStyle(Style style);
    public CompositeStyle(IEnumerable`1<Style> styles);
    public ObservableCollection`1<Style> get_Styles();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual Collection`1<string> get_FiltersCore();
}
internal class ThinkGeo.Core.ContractResolver : object {
    private static ContractResolver _instance;
    private ThreadSafeStore`2<Type, JsonContract> _contractCache;
    internal static ContractResolver Instance { get; }
    private static ContractResolver();
    internal static ContractResolver get_Instance();
    public virtual JsonContract ResolveContract(Type type);
    private JsonContract CreateContract(Type objectType);
    private IList`1<JsonProperty> CreateConstructorParameters(ConstructorInfo constructor, JsonPropertyCollection memberProperties);
    private JsonProperty CreatePropertyFromConstructorParameter(JsonProperty matchingMemberProperty, ParameterInfo parameterInfo);
    private JsonProperty MatchProperty(JsonPropertyCollection properties, string name, Type type);
    private vRU=<object> CreateParameterizedConstructor(MethodBase method);
    private ConstructorInfo GetParameterizedConstructor(Type objectType);
    private IList`1<JsonProperty> CreateProperties(Type type);
    private JsonProperty CreateProperty(MemberInfo member);
    private static bool CanSetMemberValue(MemberInfo member, bool nonPublic, bool canSetReadOnly);
    private static bool CanReadMemberValue(MemberInfo member, bool nonPublic);
    private void SetPropertySettingsFromAttributes(JsonProperty property, object attributeProvider, string name, Type declaringType, Boolean& allowNonPublicAccess);
    private List`1<MemberInfo> GetSerializableMembers(Type objectType);
    private static List`1<MemberInfo> GetFieldsAndProperties(Type type, BindingFlags bindingAttr);
    private static bool IsOverridenGenericMember(MemberInfo memberInfo, BindingFlags bindingAttr);
    public static bool IsVirtual(PropertyInfo propertyInfo);
    private static Type GetMemberUnderlyingType(MemberInfo member);
    private static IEnumerable`1<PropertyInfo> GetProperties(Type targetType, BindingFlags bindingAttr);
    private static IEnumerable`1<FieldInfo> GetFields(Type targetType, BindingFlags bindingAttr);
    private static void GetChildPrivateFields(IList`1<MemberInfo> initialFields, Type targetType, BindingFlags bindingAttr);
}
public class ThinkGeo.Core.ControlPointSelectedEditInteractiveOverlayEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Feature phQ=;
    public Feature SelectedFeature { get; public set; }
    public ControlPointSelectedEditInteractiveOverlayEventArgs(Feature selectedFeature);
    [CompilerGeneratedAttribute]
public Feature get_SelectedFeature();
    [CompilerGeneratedAttribute]
public void set_SelectedFeature(Feature value);
}
public class ThinkGeo.Core.ControlPointSelectingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private PointShape targetPointShape;
    [ObfuscationAttribute]
private bool cancel;
    public PointShape TargetPointShape { get; public set; }
    public bool Cancel { get; public set; }
    public ControlPointSelectingEditInteractiveOverlayEventArgs(bool cancel, PointShape targetPointShape);
    public PointShape get_TargetPointShape();
    public void set_TargetPointShape(PointShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public static class ThinkGeo.Core.Conversion : object {
    [ObfuscationAttribute]
private static Dictionary`2<DistanceUnit, double> distanceDictionary;
    [ObfuscationAttribute]
private static Dictionary`2<AreaUnit, double> areaDictionary;
    private static Conversion();
    public static double ConvertMeasureUnits(double amount, DistanceUnit fromUnit, DistanceUnit toUnit);
    public static double ConvertMeasureUnits(double amount, AreaUnit fromUnit, AreaUnit toUnit);
    public static DistanceUnit ConvertGeographyUnitToDistanceUnit(GeographyUnit unit);
    internal static double 5ho=(double degrees);
    public static double ConvertAngleUnits(double angle, AngleUnit fromUnit, AngleUnit toUnit);
}
public class ThinkGeo.Core.ConvertedShapeToNtsGeometryShapeConverterEventArgs : object {
    [CompilerGeneratedAttribute]
private BaseShape 5xo=;
    [CompilerGeneratedAttribute]
private Geometry 6Bo=;
    public BaseShape FromShape { get; public set; }
    public Geometry ToGeometry { get; public set; }
    [CompilerGeneratedAttribute]
public BaseShape get_FromShape();
    [CompilerGeneratedAttribute]
public void set_FromShape(BaseShape value);
    [CompilerGeneratedAttribute]
public Geometry get_ToGeometry();
    [CompilerGeneratedAttribute]
public void set_ToGeometry(Geometry value);
}
internal class ThinkGeo.Core.CreatedMemberNodeGeoObjectModelerEventArgs : EventArgs {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private object value;
    [ObfuscationAttribute]
private Type type;
    [ObfuscationAttribute]
private object owner;
    [ObfuscationAttribute]
private GeoObjectNode node;
    public string Name { get; public set; }
    public object Value { get; public set; }
    public Type Type { get; public set; }
    public object Owner { get; public set; }
    public GeoObjectNode Node { get; public set; }
    public CreatedMemberNodeGeoObjectModelerEventArgs(string name, object value, Type type, object owner, GeoObjectNode node);
    public string get_Name();
    public void set_Name(string value);
    public object get_Value();
    public void set_Value(object value);
    public Type get_Type();
    public void set_Type(Type value);
    public object get_Owner();
    public void set_Owner(object value);
    public GeoObjectNode get_Node();
    public void set_Node(GeoObjectNode value);
}
internal class ThinkGeo.Core.CreatedMemberObjectGeoObjectModelerEventArgs : EventArgs {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private object value;
    [ObfuscationAttribute]
private Type type;
    [ObfuscationAttribute]
private object owner;
    public string Name { get; public set; }
    public object Value { get; public set; }
    public Type Type { get; public set; }
    public object Owner { get; public set; }
    public CreatedMemberObjectGeoObjectModelerEventArgs(string name, object value, Type type, object owner);
    public string get_Name();
    public void set_Name(string value);
    public object get_Value();
    public void set_Value(object value);
    public Type get_Type();
    public void set_Type(Type value);
    public object get_Owner();
    public void set_Owner(object value);
}
internal class ThinkGeo.Core.CreatingMemberNodeGeoObjectModelerEventArgs : EventArgs {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private object value;
    [ObfuscationAttribute]
private Type type;
    [ObfuscationAttribute]
private object owner;
    public string Name { get; public set; }
    public object Value { get; public set; }
    public Type Type { get; public set; }
    public object Owner { get; public set; }
    public CreatingMemberNodeGeoObjectModelerEventArgs(string name, object value, Type type, object owner);
    public string get_Name();
    public void set_Name(string value);
    public object get_Value();
    public void set_Value(object value);
    public Type get_Type();
    public void set_Type(Type value);
    public object get_Owner();
    public void set_Owner(object value);
}
internal class ThinkGeo.Core.CreatingMemberObjectGeoObjectModelerEventArgs : EventArgs {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private Type type;
    [ObfuscationAttribute]
private object owner;
    [ObfuscationAttribute]
private GeoObjectNode node;
    public string Name { get; public set; }
    public Type Type { get; public set; }
    public object Owner { get; public set; }
    public GeoObjectNode Node { get; public set; }
    public CreatingMemberObjectGeoObjectModelerEventArgs(string name, Type type, object owner, GeoObjectNode node);
    public string get_Name();
    public void set_Name(string value);
    public Type get_Type();
    public void set_Type(Type value);
    public object get_Owner();
    public void set_Owner(object value);
    public GeoObjectNode get_Node();
    public void set_Node(GeoObjectNode value);
}
public class ThinkGeo.Core.CreatingRequestGoogleMapsLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private Uri requestUri;
    public Uri RequestUri { get; public set; }
    public CreatingRequestGoogleMapsLayerEventArgs(Uri requestUri);
    public Uri get_RequestUri();
    public void set_RequestUri(Uri value);
}
public class ThinkGeo.Core.CustomColumnFetchEventArgs : EventArgs {
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private string columnValue;
    public string ColumnName { get; }
    public string Id { get; }
    public string ColumnValue { get; public set; }
    public CustomColumnFetchEventArgs(string columnName, string id);
    public string get_ColumnName();
    public string get_Id();
    public string get_ColumnValue();
    public void set_ColumnValue(string value);
}
public enum ThinkGeo.Core.DatabaseConnectionMode : Enum {
    public int value__;
    public static DatabaseConnectionMode Default;
    public static DatabaseConnectionMode AutoClose;
    public static DatabaseConnectionMode KeepOpen;
}
public class ThinkGeo.Core.DateRangeFilterCondition : FilterCondition {
    [ObfuscationAttribute]
private DateTime fromDate;
    [ObfuscationAttribute]
private DateTime toDate;
    public DateTime FromDate { get; public set; }
    public DateTime ToDate { get; public set; }
    public DateRangeFilterCondition(DateTime fromDate, DateTime toDate);
    public DateTime get_FromDate();
    public void set_FromDate(DateTime value);
    public DateTime get_ToDate();
    public void set_ToDate(DateTime value);
    internal virtual bool SSM=(Feature feature);
    private bool wDE=(Feature feature);
    private bool wTE=(DateTime currentDate, string dateString);
}
public class ThinkGeo.Core.DbfColumn : FeatureSourceColumn {
    [ObfuscationAttribute]
private DbfColumnType columnType;
    [ObfuscationAttribute]
private int length;
    [ObfuscationAttribute]
private int decimalLength;
    public DbfColumnType ColumnType { get; public set; }
    public int Length { get; public set; }
    public int DecimalLength { get; public set; }
    public DbfColumn(string columnName, DbfColumnType columnType, int length, int decimalLength);
    public DbfColumnType get_ColumnType();
    public void set_ColumnType(DbfColumnType value);
    public int get_Length();
    public void set_Length(int value);
    public int get_DecimalLength();
    public void set_DecimalLength(int value);
}
internal class ThinkGeo.Core.DbfColumnInfo : ValueType {
    [ObfuscationAttribute]
private int offset;
    [ObfuscationAttribute]
private int size;
    [ObfuscationAttribute]
private int decimals;
    [ObfuscationAttribute]
private byte byteType;
    public int Offset { get; public set; }
    public int Size { get; public set; }
    public int Decimals { get; public set; }
    public byte ByteType { get; public set; }
    public int get_Offset();
    public void set_Offset(int value);
    public int get_Size();
    public void set_Size(int value);
    public int get_Decimals();
    public void set_Decimals(int value);
    public byte get_ByteType();
    public void set_ByteType(byte value);
    public virtual bool Equals(object obj);
    private bool Equals(DbfColumnInfo dbfColumnInfo);
    public virtual int GetHashCode();
    public static DbfColumnInfo op_Addition(DbfColumnInfo dbfColumnInfo1, DbfColumnInfo dbfColumnInfo2);
    public static bool op_Equality(DbfColumnInfo dbfColumnInfo1, DbfColumnInfo dbfColumnInfo2);
    public static bool op_Inequality(DbfColumnInfo dbfColumnInfo1, DbfColumnInfo dbfColumnInfo2);
}
public enum ThinkGeo.Core.DbfColumnType : Enum {
    public int value__;
    public static DbfColumnType Null;
    public static DbfColumnType Logical;
    public static DbfColumnType Memo;
    public static DbfColumnType Date;
    public static DbfColumnType DateTime;
    public static DbfColumnType IntegerInBinary;
    public static DbfColumnType DoubleInBinary;
    public static DbfColumnType Character;
    public static DbfColumnType Float;
    public static DbfColumnType Numeric;
}
public static class ThinkGeo.Core.DecimalDegreesHelper : object {
    private static double 6Ro=;
    private static double 6ho=;
    private static double 6xo=;
    private static int 7Bo=;
    public static string GetDegreesMinutesStringFromDecimalDegreePoint(Feature point, int decimals);
    public static string GetDegreesMinutesStringFromDecimalDegreePoint(Feature point);
    public static string GetDegreesMinutesStringFromDecimalDegreePoint(PointShape pointShape);
    public static string GetDegreesMinutesStringFromDecimalDegreePoint(PointShape pointShape, int decimals);
    internal static string 7Ro=(double decimalDegreesValue);
    internal static string 7Ro=(double decimalDegreesValue, int decimals);
    public static DegreesMinutesSeconds GetDegreesMinutesSecondsFromDecimalDegree(double decimalDegreesValue);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegree(double decimalDegreesValue);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegree(double decimalDegreesValue, int decimals);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegreePoint(PointShape pointShape);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegreePoint(PointShape pointShape, int decimals);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegreePoint(Feature point, int decimalPlaces);
    public static string GetDegreesMinutesSecondsStringFromDecimalDegreePoint(Feature point);
    public static double GetDecimalDegreeFromDegreesMinutesSeconds(string degreesMinutesSeconds);
    public static double GetDecimalDegreeFromDegreesMinutesSeconds(DegreesMinutesSeconds degreesMinutesSeconds);
    public static double GetDecimalDegreeFromDegreesMinutesSeconds(int degrees, int minutes, double seconds);
    public static double GetDistanceFromDecimalDegrees(PointShape fromPoint, PointShape toPoint, DistanceUnit returningUnit);
    public static double GetDistanceFromDecimalDegrees(Feature fromPointFeature, Feature toPointFeature, DistanceUnit returningUnit);
    public static double GetDistanceFromDecimalDegrees(double fromLatitude, double fromLongitude, double toLatitude, double toLongitude, DistanceUnit returningUnit);
    public static double GetLongitudeDifferenceFromDistance(double distance, DistanceUnit distanceUnit, double latitude);
    public static double GetLatitudeDifferenceFromDistance(double distance, DistanceUnit distanceUnit);
    public static string ConvertToMgrs(double latitude, double longitude);
    public static PointShape ConvertFromMgrs(string mgrs);
    internal static double 7ho=(double fromLongitude, double fromLatitude, double distance, DistanceUnit distanceUnit, double degree);
    internal static double 7xo=(double fromLongitude, double fromLatitude, double distance, DistanceUnit distanceUnit, double degree);
    internal static MultilineShape 8Bo=(PointShape fromPoint, PointShape toPoint, int count);
    internal static double 8Ro=(double fromPointX, double fromPointY, double toPointX, double toPointY, PointShape pointShape, DistanceUnit lengthUnit);
    internal static PointShape 8ho=(double fromPointX, double fromPointY, double toPointX, double toPointY, PointShape pointShape);
    internal static double 8xo=(double degreeX, double degreeY, DistanceUnit distanceUnit);
    internal static double 9Bo=(double degreeY, DistanceUnit distanceUnit);
}
public class ThinkGeo.Core.DegreesMinutesSeconds : ValueType {
    [ObfuscationAttribute]
private int degrees;
    [ObfuscationAttribute]
private int minutes;
    [ObfuscationAttribute]
private double seconds;
    public int Degrees { get; public set; }
    public int Minutes { get; public set; }
    public double Seconds { get; public set; }
    public DegreesMinutesSeconds(int degrees, int minutes, double seconds);
    private static double 9Ro=(int degrees, int minutes, double seconds);
    public int get_Degrees();
    public void set_Degrees(int value);
    public int get_Minutes();
    public void set_Minutes(int value);
    public double get_Seconds();
    public void set_Seconds(double value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool khU=(DegreesMinutesSeconds compareObj);
    public DegreesMinutesSeconds Add(DegreesMinutesSeconds targetDegreesMinutesSeconds);
    public static DegreesMinutesSeconds op_Addition(DegreesMinutesSeconds degreesMinutesSeconds1, DegreesMinutesSeconds degreesMinutesSeconds2);
    public static bool op_Equality(DegreesMinutesSeconds degreesMinutesSeconds1, DegreesMinutesSeconds degreesMinutesSeconds2);
    public static bool op_Inequality(DegreesMinutesSeconds degreesMinutesSeconds1, DegreesMinutesSeconds degreesMinutesSeconds2);
    public virtual string ToString();
    public string GetFormattedString(int decimals);
    public string GetFormattedString(DegreesMinutesSecondsFormatType formatType);
    public string GetFormattedString(DegreesMinutesSecondsFormatType formatType, int decimals);
}
public enum ThinkGeo.Core.DegreesMinutesSecondsFormatType : Enum {
    public int value__;
    public static DegreesMinutesSecondsFormatType DegreesMinutesSeconds;
    public static DegreesMinutesSecondsFormatType DegreesMinutes;
}
public enum ThinkGeo.Core.DelimitedColumnHeaderType : Enum {
    public int value__;
    public static DelimitedColumnHeaderType FirstRowAsHeader;
    public static DelimitedColumnHeaderType NoHeader;
}
public class ThinkGeo.Core.DelimitedFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private DelimitedFeatureSource featureSource;
    public string DelimitedPathFilename { get; public set; }
    public string XColumnName { get; public set; }
    public string YColumnName { get; public set; }
    public string WellKnownTextColumnName { get; public set; }
    internal int tiE= { get; internal set; }
    internal int uSE= { get; internal set; }
    internal int vCE= { get; internal set; }
    public string Delimiter { get; public set; }
    public DelimitedSpatialColumnsType SpatialColumnType { get; public set; }
    internal DelimitedColumnHeaderType vyE= { get; internal set; }
    public Encoding Encoding { get; public set; }
    public bool RequireIndex { get; public set; }
    public bool HasBoundingBox { get; }
    public DelimitedFeatureLayer(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter);
    public DelimitedFeatureLayer(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter);
    private DelimitedFeatureLayer(string delimitedPathFilename);
    public string get_DelimitedPathFilename();
    public void set_DelimitedPathFilename(string value);
    public string get_XColumnName();
    public void set_XColumnName(string value);
    public string get_YColumnName();
    public void set_YColumnName(string value);
    public string get_WellKnownTextColumnName();
    public void set_WellKnownTextColumnName(string value);
    internal int tCE=();
    internal void tSE=(int value);
    internal int tyE=();
    internal void uCE=(int value);
    internal int uiE=();
    internal void uyE=(int value);
    public string get_Delimiter();
    public void set_Delimiter(string value);
    public DelimitedSpatialColumnsType get_SpatialColumnType();
    public void set_SpatialColumnType(DelimitedSpatialColumnsType value);
    internal DelimitedColumnHeaderType vSE=();
    internal void viE=(DelimitedColumnHeaderType value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    public virtual bool get_HasBoundingBox();
    public static void BuildIndexFile(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void BuildIndexFile(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void BuildIndexFile(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter, BuildIndexMode buildIndexMode);
    public static void CreateDelimitedFile(string delimitedPathFilename, IEnumerable`1<string> columnNames, string delimiter, OverwriteMode overwriteMode);
    public static void CreateDelimitedFile(string delimitedPathFilename, IEnumerable`1<string> columnNames, string delimiter, OverwriteMode overwriteMode, Encoding encoding);
}
public class ThinkGeo.Core.DelimitedFeatureSource : FeatureSource {
    private static int wCE=;
    [CompilerGeneratedAttribute]
private static EventHandler`1<BuildingIndexDelimitedFeatureSourceEventArgs> wSE=;
    [ObfuscationAttribute]
private string delimitedPathFilename;
    [ObfuscationAttribute]
private string xColumnName;
    [ObfuscationAttribute]
private string yColumnName;
    [ObfuscationAttribute]
private int xColumnPosition;
    [ObfuscationAttribute]
private int yColumnPosition;
    [ObfuscationAttribute]
private string wellKnownTextColumnName;
    [ObfuscationAttribute]
private int wellKnownTextColumnPosition;
    [ObfuscationAttribute]
private string delimiter;
    [ObfuscationAttribute]
private DelimitedSpatialColumnsType spatialColumnType;
    [ObfuscationAttribute]
private DelimitedColumnHeaderType columnHeaderType;
    [ObfuscationAttribute]
private Encoding encoding;
    [ObfuscationAttribute]
private bool requireIndex;
    private RtreeSpatialIndex wiE=;
    private String[] wyE=;
    private string xCE=;
    public string DelimitedPathFilename { get; public set; }
    public string XColumnName { get; public set; }
    public string YColumnName { get; public set; }
    public string WellKnownTextColumnName { get; public set; }
    internal int tiE= { get; internal set; }
    internal int uSE= { get; internal set; }
    internal int vCE= { get; internal set; }
    public string Delimiter { get; public set; }
    public DelimitedSpatialColumnsType SpatialColumnType { get; public set; }
    internal DelimitedColumnHeaderType vyE= { get; internal set; }
    public Encoding Encoding { get; public set; }
    public bool RequireIndex { get; public set; }
    public bool IsEditable { get; }
    public DelimitedFeatureSource(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter);
    public DelimitedFeatureSource(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter);
    internal DelimitedFeatureSource(string delimitedPathFilename, int xColumnPosition, int yColumnPosition, string delimiter);
    internal DelimitedFeatureSource(string delimitedPathFilename, int wellKnownTextColumnPosition, string delimiter);
    private DelimitedFeatureSource(string delimitedPathFilename, string delimiter);
    private static DelimitedFeatureSource();
    [CompilerGeneratedAttribute]
public static void add_BuildingIndex(EventHandler`1<BuildingIndexDelimitedFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_BuildingIndex(EventHandler`1<BuildingIndexDelimitedFeatureSourceEventArgs> value);
    public string get_DelimitedPathFilename();
    public void set_DelimitedPathFilename(string value);
    public string get_XColumnName();
    public void set_XColumnName(string value);
    public string get_YColumnName();
    public void set_YColumnName(string value);
    public string get_WellKnownTextColumnName();
    public void set_WellKnownTextColumnName(string value);
    internal int tCE=();
    internal void tSE=(int value);
    internal int tyE=();
    internal void uCE=(int value);
    internal int uiE=();
    internal void uyE=(int value);
    public string get_Delimiter();
    public void set_Delimiter(string value);
    public DelimitedSpatialColumnsType get_SpatialColumnType();
    public void set_SpatialColumnType(DelimitedSpatialColumnsType value);
    internal DelimitedColumnHeaderType vSE=();
    internal void viE=(DelimitedColumnHeaderType value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    protected virtual void OpenCore();
    public virtual bool get_IsEditable();
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual void CloseCore();
    protected virtual long GetCountCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    private void xSE=(Collection`1<string> deleteColumns);
    private void xiE=(List`1<string> addedColumns);
    private void xyE=(Dictionary`2<string, FeatureSourceColumn> updateColumns);
    private void yCE=();
    private void ySE=(Dictionary`2<string, Feature> addBuffer, String[] columnNames, TransactionResult transactionResult);
    private void fh8=(Collection`1<string> deleteBuffer, TransactionResult transactionResult);
    private void yiE=(Dictionary`2<string, Feature> keyValue, String[] columnNames, TransactionResult transactionResult);
    private string yyE=(Feature feature, String[] columnNames);
    private Feature zCE=(string id, dCE= csvDataRecord);
    private static Feature zCE=(string id, dCE= csvDataRecord, DelimitedSpatialColumnsType spatialColumnType, string xColumnName, string yColumnName, string wellKnownTextColumnName);
    public static void BuildIndexFile(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string delimitedPathFilename, string xColumnName, string yColumnName, string delimiter, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void BuildIndexFile(string delimitedPathFilename, string wellKnownTextColumnName, string delimiter, BuildIndexMode buildIndexMode, Encoding encoding);
    private static void zSE=(string delimitedPathFilename, string xColumnName, string yColumnName, string wellKnownTextColumnName, string delimiter, DelimitedSpatialColumnsType spatialColumnType, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void CreateDelimitedFile(string delimitedPathFilename, IEnumerable`1<string> columnNames, string delimiter, OverwriteMode overwriteMode);
    public static void CreateDelimitedFile(string delimitedPathFilename, IEnumerable`1<string> columnNames, string delimiter, OverwriteMode overwriteMode, Encoding encoding);
    protected static void OnBuildingIndex(BuildingIndexDelimitedFeatureSourceEventArgs e);
    private void ziE=();
    private USE= zyE=();
    private static USE= zyE=(string delimitedPathFilename, string delimiter, Encoding encoding);
}
public enum ThinkGeo.Core.DelimitedSpatialColumnsType : Enum {
    public int value__;
    public static DelimitedSpatialColumnsType XAndY;
    public static DelimitedSpatialColumnsType WellKnownText;
}
public enum ThinkGeo.Core.DistanceCalculationMode : Enum {
    public int value__;
    public static DistanceCalculationMode Default;
    public static DistanceCalculationMode LocalizedUtmZone;
    public static DistanceCalculationMode Haversine;
}
public enum ThinkGeo.Core.DistanceUnit : Enum {
    public int value__;
    public static DistanceUnit Meter;
    public static DistanceUnit Feet;
    public static DistanceUnit Kilometer;
    public static DistanceUnit Mile;
    public static DistanceUnit UsSurveyFeet;
    public static DistanceUnit Yard;
    public static DistanceUnit NauticalMile;
    public static DistanceUnit Inch;
    public static DistanceUnit Link;
    public static DistanceUnit Chain;
    public static DistanceUnit Pole;
    public static DistanceUnit Rod;
    public static DistanceUnit Furlong;
    public static DistanceUnit Vara;
    public static DistanceUnit Arpent;
}
public class ThinkGeo.Core.DistinctColumnValue : object {
    [ObfuscationAttribute]
private string columnValue;
    [ObfuscationAttribute]
private int columnValueCount;
    public string ColumnValue { get; public set; }
    public int ColumnValueCount { get; public set; }
    public DistinctColumnValue(string columnValue, int columnValueCount);
    public string get_ColumnValue();
    public void set_ColumnValue(string value);
    public int get_ColumnValueCount();
    public void set_ColumnValueCount(int value);
}
public class ThinkGeo.Core.DotDensityStyle : Style {
    private static int SSo=;
    private static int uTE=;
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private PointStyle customPointStyle;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    private Dictionary`2<string, Collection`1<Vertex>> ujE=;
    [ObfuscationAttribute]
private double pointToValueRatio;
    public PointStyle CustomPointStyle { get; public set; }
    public string ColumnName { get; public set; }
    public int PointSize { get; public set; }
    public GeoColor PointColor { get; public set; }
    public double PointToValueRatio { get; public set; }
    public Dictionary`2<string, Collection`1<Vertex>> CachedPoints { get; }
    public DotDensityStyle(string columnName, double pointToValueRatio, int pointSize, GeoColor pointColor);
    public DotDensityStyle(string columnName, double pointToValueRatio, PointStyle customPointStyle);
    private DotDensityStyle(string columnName, double pointToValueRatio, int pointSize, GeoColor pointColor, PointStyle customPointStyle);
    public PointStyle get_CustomPointStyle();
    public void set_CustomPointStyle(PointStyle value);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public int get_PointSize();
    public void set_PointSize(int value);
    public GeoColor get_PointColor();
    public void set_PointColor(GeoColor value);
    public double get_PointToValueRatio();
    public void set_PointToValueRatio(double value);
    public Dictionary`2<string, Collection`1<Vertex>> get_CachedPoints();
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void KzE=(double worldX, double worldY, GeoCanvas canvas, Dictionary`2<string, string> columnValues, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static Collection`1<Vertex> uzE=(Feature feature, GeoCanvas canvas, int count);
    private static double vDE=(double min, double max, double initValue, Random random);
    private static void vTE=(PolygonShape polygon, GeoCanvas canvas, Collection`1<Vertex> resultDots, int count);
    private static PolygonShape vjE=(PolygonShape polygon, GeoCanvas canvas);
    private static void gB0=(Byte[] sourceArray, Byte[] destinateArray, long destinateIndex);
    private static bool kzE=(PolygonShape polygon, double pointX, double pointY, RectangleShape boundingBox);
    private static void lDE=(Collection`1<Vertex> crossingPoints, RingShape ringShape, double pointX, double pointY, double secondLineEndPointX);
    private static Vertex lTE=(Vertex startPoint, Vertex endPoint, double secondLineStartX, double secondLineStartY, double secondLineEndPointX);
    private static bool ljE=(Collection`1<Vertex> crossingPoints, Vertex vertex);
    private static bool JTE=(double value, double start, double end);
    private static bool lzE=(Vertex vertex);
}
public class ThinkGeo.Core.DrawingAdornmentLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private AdornmentLayer adornmentLayer;
    public AdornmentLayer AdornmentLayer { get; public set; }
    public DrawingAdornmentLayerEventArgs(AdornmentLayer adornmentLayer);
    public AdornmentLayer get_AdornmentLayer();
    public void set_AdornmentLayer(AdornmentLayer value);
}
public class ThinkGeo.Core.DrawingAdornmentLayersEventArgs : EventArgs {
    [ObfuscationAttribute]
private IEnumerable`1<AdornmentLayer> adornmentLayers;
    public IEnumerable`1<AdornmentLayer> AdornmentLayers { get; public set; }
    public DrawingAdornmentLayersEventArgs(IEnumerable`1<AdornmentLayer> adornmentLayers);
    public IEnumerable`1<AdornmentLayer> get_AdornmentLayers();
    public void set_AdornmentLayers(IEnumerable`1<AdornmentLayer> value);
}
[ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
public class ThinkGeo.Core.DrawingAttributionLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private string attribution;
    [ObfuscationAttribute]
private GeoCanvas geoCanvas;
    [ObfuscationAttribute]
private bool cancel;
    public bool Cancel { get; public set; }
    public GeoCanvas GeoCanvas { get; public set; }
    public string Attribution { get; public set; }
    public DrawingAttributionLayerEventArgs(GeoCanvas canvas, string attribution);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public GeoCanvas get_GeoCanvas();
    public void set_GeoCanvas(GeoCanvas value);
    public string get_Attribution();
    public void set_Attribution(string value);
}
public class ThinkGeo.Core.DrawingClusteredFeatureClusterPointStyleEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private Feature clusteredFeature;
    [ObfuscationAttribute]
private Collection`1<Feature> clusteringFeatures;
    [ObfuscationAttribute]
private Collection`1<Style> styles;
    public bool Cancel { get; public set; }
    public Feature ClusteredFeature { get; public set; }
    public Collection`1<Feature> ClusteringFeatures { get; }
    public Collection`1<Style> Styles { get; }
    public DrawingClusteredFeatureClusterPointStyleEventArgs(Feature clusteredFeature, IEnumerable`1<Feature> clusteringFeatures, IEnumerable`1<Style> styles);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Feature get_ClusteredFeature();
    public void set_ClusteredFeature(Feature value);
    public Collection`1<Feature> get_ClusteringFeatures();
    public Collection`1<Style> get_Styles();
}
public class ThinkGeo.Core.DrawingDirectionPointEventArgs : EventArgs {
    private Feature AzE=;
    private PointShape BDE=;
    private float BTE=;
    private float BjE=;
    private bool BzE=;
    public PointShape DirectionPoint { get; public set; }
    public Feature LineFeature { get; }
    public float SymbolSize { get; public set; }
    public float RotationAngle { get; public set; }
    public bool Cancel { get; public set; }
    public DrawingDirectionPointEventArgs(Feature lineFeature, PointShape directionPoint, float symbolSize, float rotationAngle);
    public PointShape get_DirectionPoint();
    public void set_DirectionPoint(PointShape value);
    public Feature get_LineFeature();
    public float get_SymbolSize();
    public void set_SymbolSize(float value);
    public float get_RotationAngle();
    public void set_RotationAngle(float value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.DrawingExceptionLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private Exception exception;
    [ObfuscationAttribute]
private GeoCanvas canvas;
    [ObfuscationAttribute]
private bool cancel;
    public Exception Exception { get; public set; }
    public GeoCanvas Canvas { get; public set; }
    public bool Cancel { get; public set; }
    public DrawingExceptionLayerEventArgs(GeoCanvas canvas, Exception exception, bool cancel);
    public Exception get_Exception();
    public void set_Exception(Exception value);
    public GeoCanvas get_Canvas();
    public void set_Canvas(GeoCanvas value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public enum ThinkGeo.Core.DrawingExceptionMode : Enum {
    public int value__;
    public static DrawingExceptionMode Default;
    public static DrawingExceptionMode ThrowException;
    public static DrawingExceptionMode DrawException;
}
public class ThinkGeo.Core.DrawingFeaturesEventArgs : EventArgs {
    [ObfuscationAttribute]
private Collection`1<Feature> featuresToDraw;
    [ObfuscationAttribute]
private ZoomLevel drawingZoomLevel;
    [ObfuscationAttribute]
private bool cancel;
    public Collection`1<Feature> FeaturesToDraw { get; }
    public ZoomLevel DrawingZoomLevel { get; public set; }
    public bool Cancel { get; public set; }
    public DrawingFeaturesEventArgs(IEnumerable`1<Feature> featuresToDraw);
    public DrawingFeaturesEventArgs(IEnumerable`1<Feature> featuresToDraw, ZoomLevel drawingZoomLevel);
    public Collection`1<Feature> get_FeaturesToDraw();
    public ZoomLevel get_DrawingZoomLevel();
    public void set_DrawingZoomLevel(ZoomLevel value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
[FlagsAttribute]
public enum ThinkGeo.Core.DrawingFontStyles : Enum {
    public int value__;
    public static DrawingFontStyles Regular;
    public static DrawingFontStyles Bold;
    public static DrawingFontStyles Italic;
    public static DrawingFontStyles Underline;
    public static DrawingFontStyles Strikeout;
    public static DrawingFontStyles Black;
}
public enum ThinkGeo.Core.DrawingGraphicsUnit : Enum {
    public int value__;
    public static DrawingGraphicsUnit World;
    public static DrawingGraphicsUnit Display;
    public static DrawingGraphicsUnit Pixel;
    public static DrawingGraphicsUnit Point;
    public static DrawingGraphicsUnit Inch;
    public static DrawingGraphicsUnit Document;
    public static DrawingGraphicsUnit Millimeter;
}
public enum ThinkGeo.Core.DrawingLevel : Enum {
    public int value__;
    public static DrawingLevel LevelOne;
    public static DrawingLevel LevelTwo;
    public static DrawingLevel LevelThree;
    public static DrawingLevel LevelFour;
    public static DrawingLevel LabelLevel;
}
public enum ThinkGeo.Core.DrawingLineCap : Enum {
    public int value__;
    public static DrawingLineCap Round;
    public static DrawingLineCap AnchorMask;
    public static DrawingLineCap ArrowAnchor;
    public static DrawingLineCap Custom;
    public static DrawingLineCap DiamondAnchor;
    public static DrawingLineCap Flat;
    public static DrawingLineCap NoAnchor;
    public static DrawingLineCap RoundAnchor;
    public static DrawingLineCap Square;
    public static DrawingLineCap SquareAnchor;
    public static DrawingLineCap Triangle;
    public static DrawingLineCap Butt;
}
public enum ThinkGeo.Core.DrawingLineJoin : Enum {
    public int value__;
    public static DrawingLineJoin Bevel;
    public static DrawingLineJoin Miter;
    public static DrawingLineJoin MiterClipped;
    public static DrawingLineJoin Round;
}
public class ThinkGeo.Core.DrawingMargin : ValueType {
    [CompilerGeneratedAttribute]
private int CDE=;
    [CompilerGeneratedAttribute]
private int CTE=;
    [CompilerGeneratedAttribute]
private int CjE=;
    [CompilerGeneratedAttribute]
private int CzE=;
    public int Top { get; public set; }
    public int Right { get; public set; }
    public int Down { get; public set; }
    public int Left { get; public set; }
    public DrawingMargin(int top, int right, int down, int left);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Top();
    [CompilerGeneratedAttribute]
public void set_Top(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_Right();
    [CompilerGeneratedAttribute]
public void set_Right(int value);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_Down();
    [CompilerGeneratedAttribute]
public void set_Down(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Left();
    [CompilerGeneratedAttribute]
public void set_Left(int value);
}
public enum ThinkGeo.Core.DrawingPenAlignment : Enum {
    public int value__;
    public static DrawingPenAlignment Center;
    public static DrawingPenAlignment Inset;
    public static DrawingPenAlignment Left;
    public static DrawingPenAlignment Outset;
    public static DrawingPenAlignment Right;
}
public class ThinkGeo.Core.DrawingProgressChangedEventArgs : ProgressChangedEventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private int featuresToDraw;
    [ObfuscationAttribute]
private int featuresDrawn;
    public bool Cancel { get; public set; }
    public int FeaturesToDraw { get; }
    public int FeaturesDrawn { get; }
    public DrawingProgressChangedEventArgs(int progressPercentage, object userState);
    public DrawingProgressChangedEventArgs(int progressPercentage, object userState, int featuresToDraw, int featuresDrawn);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public int get_FeaturesToDraw();
    public int get_FeaturesDrawn();
}
public enum ThinkGeo.Core.DrawingQuality : Enum {
    public int value__;
    public static DrawingQuality Default;
    public static DrawingQuality HighQuality;
    public static DrawingQuality HighSpeed;
    public static DrawingQuality Medium;
}
public class ThinkGeo.Core.DrawingRectangle : ValueType {
    [ObfuscationAttribute]
private int centerX;
    [ObfuscationAttribute]
private int centerY;
    [ObfuscationAttribute]
private int width;
    [ObfuscationAttribute]
private int height;
    public int CenterX { get; }
    public int CenterY { get; }
    public int Width { get; }
    public int Height { get; }
    public int MinimumX { get; }
    public int MinimumY { get; }
    public int MaximumX { get; }
    public int MaximumY { get; }
    public DrawingRectangle(int centerX, int centerY, int width, int height);
    public DrawingRectangle(int anchorPointX, int anchorPointY, int width, int height, DrawingRectangleAnchorReference anchorReference);
    public int get_CenterX();
    public int get_CenterY();
    public int get_Width();
    public int get_Height();
    public int get_MinimumX();
    public int get_MinimumY();
    public int get_MaximumX();
    public int get_MaximumY();
    public static bool op_Equality(DrawingRectangle rectangleF1, DrawingRectangle rectangleF2);
    public static bool op_Inequality(DrawingRectangle rectangleF1, DrawingRectangle rectangleF2);
    public virtual bool Equals(object obj);
    private bool khU=(DrawingRectangle obj);
    public virtual int GetHashCode();
}
public enum ThinkGeo.Core.DrawingRectangleAnchorReference : Enum {
    public int value__;
    public static DrawingRectangleAnchorReference Center;
    public static DrawingRectangleAnchorReference UpperLeft;
    public static DrawingRectangleAnchorReference UpperRight;
    public static DrawingRectangleAnchorReference LowerLeft;
    public static DrawingRectangleAnchorReference LowerRight;
}
public class ThinkGeo.Core.DrawingRectangleF : ValueType {
    [ObfuscationAttribute]
private float centerX;
    [ObfuscationAttribute]
private float centerY;
    [ObfuscationAttribute]
private float width;
    [ObfuscationAttribute]
private float height;
    public float CenterX { get; }
    public float CenterY { get; }
    public float Width { get; }
    public float Height { get; }
    public float MinimumX { get; }
    public float MinimumY { get; }
    public float MaximumX { get; }
    public float MaximumY { get; }
    public DrawingRectangleF(float centerX, float centerY, float width, float height);
    public DrawingRectangleF(float anchorPointX, float anchorPointY, float width, float height, DrawingRectangleAnchorReference anchorReference);
    public float get_CenterX();
    public float get_CenterY();
    public float get_Width();
    public float get_Height();
    public float get_MinimumX();
    public float get_MinimumY();
    public float get_MaximumX();
    public float get_MaximumY();
    public static bool op_Equality(DrawingRectangleF rectangleF1, DrawingRectangleF rectangleF2);
    public static bool op_Inequality(DrawingRectangleF rectangleF1, DrawingRectangleF rectangleF2);
    public virtual bool Equals(object obj);
    private bool khU=(DrawingRectangleF obj);
    public virtual int GetHashCode();
}
public enum ThinkGeo.Core.DrawingTextAlignment : Enum {
    public int value__;
    public static DrawingTextAlignment Default;
    public static DrawingTextAlignment Left;
    public static DrawingTextAlignment Center;
    public static DrawingTextAlignment Right;
}
internal enum ThinkGeo.Core.DrawingTextBaseline : Enum {
    public int value__;
    public static DrawingTextBaseline Middle;
    public static DrawingTextBaseline Alphabetic;
    public static DrawingTextBaseline Top;
    public static DrawingTextBaseline Bottom;
    public static DrawingTextBaseline Hanging;
}
public enum ThinkGeo.Core.DrawingTextLetterCase : Enum {
    public int value__;
    public static DrawingTextLetterCase Default;
    public static DrawingTextLetterCase Uppercase;
    public static DrawingTextLetterCase Lowercase;
}
public class ThinkGeo.Core.DrawingWrappingFeaturesFeatureLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private Collection`1<Feature> featuresToDraw;
    public Collection`1<Feature> FeaturesToDraw { get; }
    public DrawingWrappingFeaturesFeatureLayerEventArgs(Collection`1<Feature> featuresToDraw);
    public Collection`1<Feature> get_FeaturesToDraw();
}
public class ThinkGeo.Core.DrawnAdornmentLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private AdornmentLayer adornmentLayer;
    public AdornmentLayer AdornmentLayer { get; public set; }
    public DrawnAdornmentLayerEventArgs(AdornmentLayer adornmentLayer);
    public AdornmentLayer get_AdornmentLayer();
    public void set_AdornmentLayer(AdornmentLayer value);
}
public class ThinkGeo.Core.DrawnAdornmentLayersEventArgs : EventArgs {
    [ObfuscationAttribute]
private IEnumerable`1<AdornmentLayer> adornmentLayers;
    public IEnumerable`1<AdornmentLayer> AdornmentLayers { get; public set; }
    public DrawnAdornmentLayersEventArgs(IEnumerable`1<AdornmentLayer> adornmentLayers);
    public IEnumerable`1<AdornmentLayer> get_AdornmentLayers();
    public void set_AdornmentLayers(IEnumerable`1<AdornmentLayer> value);
}
[ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
public class ThinkGeo.Core.DrawnAttributionLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private GeoCanvas geoCanvas;
    [ObfuscationAttribute]
private string attribution;
    public GeoCanvas GeoCanvas { get; public set; }
    [ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
public string Attribution { get; public set; }
    public DrawnAttributionLayerEventArgs(GeoCanvas canvas, string attribution);
    public GeoCanvas get_GeoCanvas();
    public void set_GeoCanvas(GeoCanvas value);
    public string get_Attribution();
    public void set_Attribution(string value);
}
public class ThinkGeo.Core.DrawnExceptionLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private Exception exception;
    [ObfuscationAttribute]
private GeoCanvas canvas;
    public Exception Exception { get; public set; }
    public GeoCanvas Canvas { get; public set; }
    public DrawnExceptionLayerEventArgs(GeoCanvas canvas, Exception exception);
    public Exception get_Exception();
    public void set_Exception(Exception value);
    public GeoCanvas get_Canvas();
    public void set_Canvas(GeoCanvas value);
}
public class ThinkGeo.Core.DynamicIsoLineLayer : IsoLineLayer {
    [ObfuscationAttribute]
private Dictionary`2<PointShape, double> dataPoints;
    [ObfuscationAttribute]
private GridInterpolationModel dynamicGridInterpolationModel;
    [ObfuscationAttribute]
private double noDataValue;
    [ObfuscationAttribute]
private int cellWidthInPixel;
    [ObfuscationAttribute]
private int cellHeightInPixel;
    public Dictionary`2<PointShape, double> DataPoints { get; }
    public double NoDataValue { get; public set; }
    public int CellWidthInPixel { get; public set; }
    public int CellHeightInPixel { get; public set; }
    public GridInterpolationModel DynamicGridInterpolationModel { get; public set; }
    public DynamicIsoLineLayer(IDictionary`2<PointShape, double> dataPoints);
    public DynamicIsoLineLayer(IDictionary`2<PointShape, double> dataPoints, IEnumerable`1<double> isoLineLevels);
    public DynamicIsoLineLayer(IDictionary`2<PointShape, double> dataPoints, IEnumerable`1<double> isoLineLevels, GridInterpolationModel gridInterpolationModel);
    public DynamicIsoLineLayer(IDictionary`2<PointShape, double> dataPoints, IEnumerable`1<double> isoLineLevels, GridInterpolationModel gridInterpolationModel, IsoLineType isoLineType);
    private DynamicIsoLineLayer(IDictionary`2<PointShape, double> dataPoints, IEnumerable`1<double> isoLineLevels, GridInterpolationModel gridInterpolationModel, double lowerScale, double upperScale, IsoLineType isoLineType);
    public Dictionary`2<PointShape, double> get_DataPoints();
    public double get_NoDataValue();
    public void set_NoDataValue(double value);
    public int get_CellWidthInPixel();
    public void set_CellWidthInPixel(int value);
    public int get_CellHeightInPixel();
    public void set_CellHeightInPixel(int value);
    public GridInterpolationModel get_DynamicGridInterpolationModel();
    public void set_DynamicGridInterpolationModel(GridInterpolationModel value);
    public Collection`1<Feature> GetIsoLineFeatures(RectangleShape worldExtent, double scale, GeographyUnit mapUnit);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static GridCell[0...,0...] riI=(GridDefinition gridDefinition, GridInterpolationModel dynamicGridInterpolationModel, double scale, float cellWithInDot, float cellHeightInDot, GeographyUnit mapUnit);
}
public class ThinkGeo.Core.EditEndedEditInteractiveOverlayEventArgs : EventArgs {
    private Feature pxQ=;
    public Feature EditedFeature { get; public set; }
    public EditEndedEditInteractiveOverlayEventArgs(Feature editedFeature);
    public Feature get_EditedFeature();
    public void set_EditedFeature(Feature value);
}
public class ThinkGeo.Core.EditTools : object {
    [ObfuscationAttribute]
private FeatureSource featureSource;
    public bool IsInTransaction { get; }
    public bool IsTransactionLive { get; public set; }
    public bool IsEditable { get; }
    public TransactionBuffer TransactionBuffer { get; public set; }
    public EditTools(FeatureSource featureSource);
    public bool get_IsInTransaction();
    public bool get_IsTransactionLive();
    public void set_IsTransactionLive(bool value);
    public bool get_IsEditable();
    public TransactionBuffer get_TransactionBuffer();
    public void set_TransactionBuffer(TransactionBuffer value);
    public void BeginTransaction();
    public string Add(BaseShape shape);
    public string Add(Feature feature);
    public string Add(BaseShape shape, Dictionary`2<string, string> columnValues);
    public void ScaleUp(string featureId, double percentage);
    public void ScaleDown(string featureId, double percentage);
    public void TranslateByDegree(string featureId, double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public void TranslateByOffset(string featureId, double xOffset, double yOffset, GeographyUnit shapeUnit, DistanceUnit offsetUnit);
    public void Rotate(string featureId, PointShape pivotPoint, float degreeAngle);
    public void Union(string featureId, AreaBaseShape targetShape);
    public void Union(string featureId, Feature targetAreaFeature);
    public void GetDifference(string featureId, AreaBaseShape targetShape);
    public void GetDifference(string featureId, Feature targetAreaFeature);
    public void Delete(string id);
    public void Update(BaseShape shape);
    public void Update(Feature feature);
    public void Update(BaseShape shape, Dictionary`2<string, string> columnValues);
    public void RollbackTransaction();
    public TransactionResult CommitTransaction();
}
public class ThinkGeo.Core.ElevationCloudClient : CloudClient {
    private static int yRQ=;
    public ElevationCloudClient(string clientId, string clientSecret);
    public double GetElevationOfPointInDecimalDegree(double latitude, double longitude, DistanceUnit elevationUnit);
    public double GetElevationOfPoint(double x, double y, int pointProjectionInSrid, DistanceUnit elevationUnit);
    public double GetElevationOfPoint(double x, double y, string pointProjectionInProj4String, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/MT4=")]
public Task`1<double> GetElevationOfPointInDecimalDegreeAsync(double latitude, double longitude, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/LT4=")]
public Task`1<double> GetElevationOfPointAsync(double x, double y, int pointProjectionInSrid, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Lz4=")]
public Task`1<double> GetElevationOfPointAsync(double x, double y, string pointProjectionInProj4String, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfPointsInDecimalDegree(IEnumerable`1<PointShape> points, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfPoints(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfPoints(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Oj4=")]
public Task`1<CloudElevationResult> GetElevationOfPointsInDecimalDegreeAsync(IEnumerable`1<PointShape> points, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/ND4=")]
public Task`1<CloudElevationResult> GetElevationOfPointsAsync(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Nz4=")]
public Task`1<CloudElevationResult> GetElevationOfPointsAsync(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLineInDecimalDegree(LineBaseShape line, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLine(LineBaseShape line, int lineProjectionInSrid, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLine(LineBaseShape line, string lineProjectionInProj4String, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLineInDecimalDegree(LineBaseShape line, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLine(LineBaseShape line, int lineProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfLine(LineBaseShape line, string lineProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Kj4=")]
public Task`1<CloudElevationResult> GetElevationOfLineInDecimalDegreeAsync(LineBaseShape line, int numberOfSegments, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/IT4=")]
public Task`1<CloudElevationResult> GetElevationOfLineAsync(LineBaseShape line, int lineProjectionInSrid, int numberOfSegments, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/JT4=")]
public Task`1<CloudElevationResult> GetElevationOfLineAsync(LineBaseShape line, string lineProjectionInProj4String, int numberOfSegments, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Kz4=")]
public Task`1<CloudElevationResult> GetElevationOfLineInDecimalDegreeAsync(LineBaseShape line, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Jz4=")]
public Task`1<CloudElevationResult> GetElevationOfLineAsync(LineBaseShape line, int lineProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/KD4=")]
public Task`1<CloudElevationResult> GetElevationOfLineAsync(LineBaseShape line, string lineProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLineInDecimalDegree(LineShape line, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLine(LineShape line, int lineProjectionInSrid, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLine(LineShape line, string lineProjectionInProj4String, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLineInDecimalDegree(LineShape line, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLine(LineShape line, int lineProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudGradeResult GetGradeOfLine(LineShape line, string lineProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/QD4=")]
public Task`1<CloudGradeResult> GetGradeOfLineInDecimalDegreeAsync(LineShape line, int numberOfSegments, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Oz4=")]
public Task`1<CloudGradeResult> GetGradeOfLineAsync(LineShape line, int lineProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/PD4=")]
public Task`1<CloudGradeResult> GetGradeOfLineAsync(LineShape line, string lineProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/QT4=")]
public Task`1<CloudGradeResult> GetGradeOfLineInDecimalDegreeAsync(LineShape line, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/PT4=")]
public Task`1<CloudGradeResult> GetGradeOfLineAsync(LineShape line, int lineProjectionInSrid, int numberOfSegments, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Pj4=")]
public Task`1<CloudGradeResult> GetGradeOfLineAsync(LineShape line, string lineProjectionInProj4String, int numberOfSegments, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfAreaInDecimalDegree(AreaBaseShape area, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfArea(AreaBaseShape area, int areaProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    public CloudElevationResult GetElevationOfArea(AreaBaseShape area, string areaProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/ID4=")]
public Task`1<CloudElevationResult> GetElevationOfAreaInDecimalDegreeAsync(AreaBaseShape area, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Fj4=")]
public Task`1<CloudElevationResult> GetElevationOfAreaAsync(AreaBaseShape area, int areaProjectionInSrid, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Gz4=")]
public Task`1<CloudElevationResult> GetElevationOfAreaAsync(AreaBaseShape area, string areaProjectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    private double yhQ=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/LD4=")]
private Task`1<double> yxQ=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String, DistanceUnit elevationUnit);
    private CloudElevationResult zBQ=(IEnumerable`1<PointShape> points, Nullable`1<int> projectionInSrid, string projectionInProj4String, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/OT4=")]
private Task`1<CloudElevationResult> zRQ=(IEnumerable`1<PointShape> points, Nullable`1<int> projectionInSrid, string projectionInProj4String, DistanceUnit elevationUnit);
    private CloudElevationResult zhQ=(LineBaseShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<int> numberOfSegments, Nullable`1<double> intervalDistance, Nullable`1<DistanceUnit> intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/KT4=")]
private Task`1<CloudElevationResult> zxQ=(LineBaseShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<int> numberOfSegments, Nullable`1<double> intervalDistance, Nullable`1<DistanceUnit> intervalDistanceUnit, DistanceUnit elevationUnit);
    private CloudGradeResult 0BQ=(LineShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<int> numberOfSegments, Nullable`1<double> intervalDistance, Nullable`1<DistanceUnit> intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/Pz4=")]
private Task`1<CloudGradeResult> 0RQ=(LineShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<int> numberOfSegments, Nullable`1<double> intervalDistance, Nullable`1<DistanceUnit> intervalDistanceUnit, DistanceUnit elevationUnit);
    private CloudElevationResult 0hQ=(AreaBaseShape area, Nullable`1<int> projectionInSrid, string projectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ElevationCloudClient/HT4=")]
private Task`1<CloudElevationResult> 0xQ=(AreaBaseShape area, Nullable`1<int> projectionInSrid, string projectionInProj4String, double intervalDistance, DistanceUnit intervalDistanceUnit, DistanceUnit elevationUnit);
    private static double 1BQ=(WebResponse response);
    private static CloudElevationResult 1RQ=(WebResponse response);
    private static CloudElevationResult 1hQ=(WebResponse response, IEnumerable`1<PointShape> queryPoints);
    private static CloudGradeResult 1xQ=(WebResponse response);
    private static string 2BQ=(string wkt, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<int> numberOfSegments, Nullable`1<double> intervalDistance, Nullable`1<DistanceUnit> intervalDistanceUnit, DistanceUnit elevationUnit);
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.EllipseShape : AreaBaseShape {
    private static int Jhw=;
    [ObfuscationAttribute]
private PointShape center;
    [ObfuscationAttribute]
private double width;
    [ObfuscationAttribute]
private double height;
    public double Width { get; }
    public double Height { get; }
    public PointShape Center { get; public set; }
    public EllipseShape(PointShape center, double radius);
    public EllipseShape(Feature centerPointFeature, double radius);
    public EllipseShape(PointShape center, double horizontalRadius, double verticalRadius);
    public EllipseShape(Feature centerPointFeature, double horizontalRadius, double verticalRadius);
    public EllipseShape(string wellKnownText);
    public EllipseShape(Byte[] wellKnownBinary);
    public EllipseShape(PointShape center, double radius, GeographyUnit shapeUnit, DistanceUnit unitOfRadius);
    public EllipseShape(Feature centerPointFeature, double radius, GeographyUnit shapeUnit, DistanceUnit unitOfRadius);
    public EllipseShape(PointShape center, double horizontalRadius, double verticalRadius, GeographyUnit shapeUnit, DistanceUnit unitOfRadius);
    public EllipseShape(Feature centerPointFeature, double horizontalRadius, double verticalRadius, GeographyUnit shapeUnit, DistanceUnit unitOfRadius);
    protected virtual BaseShape CloneDeepCore();
    protected virtual WellKnownType GetWellKnownTypeCore();
    public double get_Width();
    public void SetWidthByUnit(double newWidth, GeographyUnit shapeUnit, DistanceUnit unitOfWidth);
    public double GetWidthByUnit(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public double get_Height();
    public void SetHeightByUnit(double newHeight, GeographyUnit shapeUnit, DistanceUnit unitOfHeight);
    public double GetHeightByUnit(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public PointShape get_Center();
    public void set_Center(PointShape value);
    public PolygonShape ToPolygon();
    public PolygonShape ToPolygon(int vertexCountInQuarter);
    public Collection`1<PointShape> GetTangents(EllipseShape targetEllipse);
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected string GetWellKnownTextCore(int vertexCountInQuarter);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected string GetWellKnownTextCore(RingOrder outerRingOrder, int vertexCountInQuarter);
    protected Byte[] GetWellKnownBinaryCore(WkbByteOrder byteOrder, int vertexCountInQuarter);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder, int vertexCountInQuarter);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual bool ContainsCore(BaseShape targetShape);
    protected virtual bool IntersectsCore(BaseShape targetShape);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    private void Jxw=(PointShape center, double newWidth, double newHeight, GeographyUnit shapeUnit, DistanceUnit unitOfSize);
    private PolygonShape KBw=(int quaterVertexCount);
    private void SRU=(double factor);
    private void KRw=(PointShape targetPointShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private void Khw=(MultipointShape targetMultiPoint, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private void Kxw=(LineShape lineShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private void LBw=(MultilineShape multiLineShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private void LRw=(PolygonShape polygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private PointShape Lhw=(MultipolygonShape multiPolygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private void Lxw=(EllipseShape ellipseShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPoint, Double& minDistance);
    private bool MBw=(MultipointShape multiPointShape);
    private bool MRw=(LineShape lineShape);
    private bool Mhw=(MultilineShape multiLineShape);
    private bool Mxw=(RingShape ringShape);
    private bool NBw=(RectangleShape rectangleShape);
    private bool NRw=(EllipseShape ellipseShape);
    private bool Nhw=(PolygonShape polygonShape);
    private bool Nxw=(MultipolygonShape multipolygonShape);
    private bool OBw=(PointShape pointShape);
    private bool ORw=(MultipointShape multiPointShape);
    private bool Ohw=(LineShape lineShape);
    private bool Oxw=(MultilineShape multiLineShape);
    private bool PBw=(RingShape ringShape);
    private bool PRw=(RectangleShape rectangleShape);
    private bool Phw=(EllipseShape ellipseShape);
    private bool Pxw=(PolygonShape polygonShape);
    private bool QBw=(MultipolygonShape multipolygonShape);
    private Collection`1<PointShape> QRw=(EllipseShape secondEllipse);
    private bool Qhw=(PointShape pointShape);
    private bool Qhw=(double pointX, double pointY);
    private static bool Qxw=(double p, double b, double c);
    internal PointShape RBw=(PointShape pointShape);
}
public class ThinkGeo.Core.EmpiricalFunctionCoefficients : object {
    [ObfuscationAttribute]
private double range;
    [ObfuscationAttribute]
private double nugget;
    [ObfuscationAttribute]
private double sill;
    public double Range { get; public set; }
    public double Nugget { get; public set; }
    public double Sill { get; public set; }
    public EmpiricalFunctionCoefficients(double range, double sill, double nugget);
    public double get_Range();
    public void set_Range(double value);
    public double get_Nugget();
    public void set_Nugget(double value);
    public double get_Sill();
    public void set_Sill(double value);
}
public class ThinkGeo.Core.EncryptedFileRasterTileCache : FileRasterTileCache {
    public EncryptedFileRasterTileCache(string cacheDirectory);
    public EncryptedFileRasterTileCache(string cacheDirectory, string cacheId);
    protected virtual void SaveTileCore(Tile tile);
    protected virtual Tile GetTileCore(int zoom, long column, long row);
    private string xx0=(int zoom, long column, long row);
}
internal class ThinkGeo.Core.EnumInfo : object {
    public bool IsFlags;
    public UInt64[] Values;
    public String[] Names;
    public String[] ResolvedNames;
    public EnumInfo(bool isFlags, UInt64[] values, String[] names, String[] resolvedNames);
}
internal static class ThinkGeo.Core.EnumUtils : object {
    private static char EnumSeparatorChar;
    private static ThreadSafeStore`2<Type, EnumInfo> ValuesAndNamesPerEnum;
    private static EnumUtils();
    private static EnumInfo InitializeValuesAndNames(Type key);
    public static bool TryToString(Type enumType, object value, bool camelCase, String& name);
    private static ulong ToUInt64(object value);
    public static object ParseEnum(Type enumType, string value, bool disallowNumber);
    private static Nullable`1<int> MatchName(string value, String[] enumNames, String[] resolvedNames, int valueIndex, int valueSubstringLength, StringComparison comparison);
    private static Nullable`1<int> FindIndexByName(String[] enumNames, string value, int valueIndex, int valueSubstringLength, StringComparison comparison);
}
[ObfuscationAttribute]
internal static class ThinkGeo.Core.EventHelper : object {
    private static giE= exceptionHelper;
    private static EventHelper();
    [DebuggerHiddenAttribute]
public static void Raise(EventHandler handler, object sender);
    [DebuggerHiddenAttribute]
public static void Raise(EventHandler`1<T> handler, object sender, T e);
    [DebuggerHiddenAttribute]
public static void Raise(EventHandler`1<T> handler, object sender, Func`1<T> createEventArguments);
    [DebuggerHiddenAttribute]
public static void Raise(Delegate handler, object sender, EventArgs e);
    [DebuggerHiddenAttribute]
public static void BeginRaise(EventHandler handler, object sender, AsyncCallback callback, object asyncState);
    [DebuggerHiddenAttribute]
public static void BeginRaise(EventHandler`1<T> handler, object sender, T e, AsyncCallback callback, object asyncState);
    [DebuggerHiddenAttribute]
public static void BeginRaise(EventHandler`1<T> handler, object sender, Func`1<T> createEventArguments, AsyncCallback callback, object asyncState);
    [DebuggerHiddenAttribute]
public static void BeginRaise(Delegate handler, object sender, EventArgs e, AsyncCallback callback, object asyncState);
}
public class ThinkGeo.Core.ExecutingSqlStatementSqliteFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private string sqlStatement;
    [ObfuscationAttribute]
private ExecutingSqlStatementType excutingStatementType;
    [ObfuscationAttribute]
private RectangleShape featureQueryingExtent;
    public string SqlStatement { get; public set; }
    public ExecutingSqlStatementType ExcutingSqlStatementType { get; public set; }
    public RectangleShape FeatureQueryingExtent { get; }
    public ExecutingSqlStatementSqliteFeatureSourceEventArgs(string sqlStatement);
    public ExecutingSqlStatementSqliteFeatureSourceEventArgs(string sqlStatement, ExecutingSqlStatementType sqlStatementType, RectangleShape featureQueryingExtent);
    public string get_SqlStatement();
    public void set_SqlStatement(string value);
    public ExecutingSqlStatementType get_ExcutingSqlStatementType();
    public void set_ExcutingSqlStatementType(ExecutingSqlStatementType value);
    public RectangleShape get_FeatureQueryingExtent();
}
public enum ThinkGeo.Core.ExecutingSqlStatementType : Enum {
    public int value__;
    public static ExecutingSqlStatementType GetFeaturesByIds;
    public static ExecutingSqlStatementType GetFeaturesByColumnValue;
    public static ExecutingSqlStatementType GetFeaturesOutsideBoundingBox;
    public static ExecutingSqlStatementType GetSpatialDataType;
    public static ExecutingSqlStatementType GetBoundingBox;
    public static ExecutingSqlStatementType GetAllFeatures;
    public static ExecutingSqlStatementType GetCount;
    public static ExecutingSqlStatementType GetColumns;
    public static ExecutingSqlStatementType BuildIndex;
    public static ExecutingSqlStatementType ExecuteScalar;
    public static ExecutingSqlStatementType ExecuteQuery;
    public static ExecutingSqlStatementType ExecuteNonQuery;
    public static ExecutingSqlStatementType GetFirstGeometryType;
    public static ExecutingSqlStatementType MakeAllGeometriesValid;
    public static ExecutingSqlStatementType Validate;
    public static ExecutingSqlStatementType CommitTransactionEx;
    public static ExecutingSqlStatementType GetFeaturesInsideBoundingBoxEx;
    public static ExecutingSqlStatementType Unknown;
    public static ExecutingSqlStatementType ExecuteSpatialQuery;
    public static ExecutingSqlStatementType GetFeatureIds;
    public static ExecutingSqlStatementType InsertFeature;
}
public class ThinkGeo.Core.ExponentialKrigingGridInterpolationModel : KrigingGridInterpolationModel {
    public ExponentialKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    public ExponentialKrigingGridInterpolationModel(IDictionary`2<PointShape, double> dataPoints, int numberOfRefrencedPoints);
    protected virtual double GetSillSlopeCore(double distance, double range);
}
[ExtensionAttribute]
public static class ThinkGeo.Core.Extension : object {
    [ExtensionAttribute]
public static string GetGeoJson(IEnumerable`1<Feature> features);
}
public class ThinkGeo.Core.Feature : object {
    private static int 9ho=;
    private static string 9xo=;
    [ObfuscationAttribute]
private Byte[] wellKnownBinary;
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private object tag;
    [ObfuscationAttribute]
private Dictionary`2<string, string> columnValues;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    public string Id { get; public set; }
    public object Tag { get; public set; }
    public Dictionary`2<string, string> ColumnValues { get; }
    public Feature(BaseShape baseShape);
    public Feature(Byte[] wellKnownBinary);
    public Feature(Byte[] wellKnownBinary, string id);
    public Feature(string wellKnownText);
    public Feature(string wellKnownText, string id);
    public Feature(BaseShape baseShape, IDictionary`2<string, string> columnValues);
    public Feature(BaseShape baseShape, IEnumerable`1<string> columnValues);
    public Feature(string wellKnownText, string id, IDictionary`2<string, string> columnValues);
    public Feature(string wellKnownText, string id, IEnumerable`1<string> columnValues);
    public Feature(Byte[] wellKnownBinary, string id, IEnumerable`1<string> columnValues);
    private Feature(Byte[] wellKnownBinary, string id, IEnumerable`1<string> columnValues, object tag);
    public Feature(Byte[] wellKnownBinary, string id, IDictionary`2<string, string> columnValues);
    private Feature(Byte[] wellKnownBinary, string id, IDictionary`2<string, string> columnValues, object tag);
    public Feature(Vertex vertex);
    public Feature(Vertex vertex, string id);
    public Feature(Vertex vertex, string id, IEnumerable`1<string> columnValues);
    public Feature(Vertex vertex, string id, IDictionary`2<string, string> columnValues);
    public Feature(double x, double y);
    public Feature(double x, double y, string id);
    public Feature(double x, double y, string id, IEnumerable`1<string> columnValues);
    public Feature(double x, double y, string id, IDictionary`2<string, string> columnValues);
    public Byte[] GetWellKnownBinary();
    public Byte[] GetWellKnownBinary(WkbByteOrder byteOrder);
    public Byte[] GetWellKnownBinary(RingOrder outerRingOrder);
    public Byte[] GetWellKnownBinary(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    public string get_Id();
    public void set_Id(string value);
    public object get_Tag();
    public void set_Tag(object value);
    public Dictionary`2<string, string> get_ColumnValues();
    public virtual string ToString();
    public WellKnownType GetWellKnownType();
    protected virtual WellKnownType GetWellKnownTypeCore();
    public BaseShape GetShape();
    public string GetWellKnownText();
    public string GetWellKnownText(RingOrder outerRingOrder);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    public string GetGeoJson();
    protected virtual string GetGeoJsonCore();
    public static Feature CreateFeatureFromGeoJson(string geoJson);
    public static Collection`1<Feature> CreateFeaturesFromGeoJson(string geoJson);
    public static Feature CreateFeatureFromWellKnownData(Byte[] wellKnownBinary);
    public static Feature CreateFeatureFromWellKnownData(string wellKnownText);
    public RectangleShape GetBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    public Feature CloneDeep(IEnumerable`1<string> returningColumnNames);
    private Feature /Bo=(IEnumerable`1<string> returningColumnNames);
    public Feature CloneDeep(ReturningColumnsType returningColumnNamesType);
    public Feature CloneDeep();
    public static Feature Union(IEnumerable`1<Feature> targetFeatures);
    private static Byte[] zRo=(IEnumerable`1<Feature> targetFeatures, int count);
    public Feature Union(Feature targetFeature);
    public Feature Buffer(double distance, GeographyUnit featureUnit, DistanceUnit distanceUnit);
    public Feature Buffer(double distance, int quadrantSegments, GeographyUnit featureUnit, DistanceUnit distanceUnit);
    public Feature Buffer(double distance, int quadrantSegments, BufferCapType bufferCapType, GeographyUnit featureUnit, DistanceUnit distanceUnit);
    private Byte[] 2ho=(double distance, int quadrantSegments, BufferCapType bufferCapType);
    private static EndCapStyle 2xo=(BufferCapType bufferCapStyle);
    public bool Contains(Feature targetFeature);
    public bool Crosses(Feature targetFeature);
    public bool IsWithin(Feature targetFeature);
    public bool Intersects(Feature targetFeature);
    public bool IsDisjointed(Feature targetFeature);
    public bool IsTopologicallyEqual(Feature targetFeature);
    public bool Overlaps(Feature targetFeature);
    public bool Touches(Feature targetFeature);
    public Feature GetIntersection(Feature targetFeature);
    public Feature GetDifference(Feature targetFeature);
    public Feature GetConvexHull();
    public void SetWellKnownBinary(Byte[] wellKnownBinary);
    public string GetInvalidReason();
    public bool IsGeometryValid();
    protected virtual BaseShape GetShapeCore();
}
public class ThinkGeo.Core.FeatureCache : object {
    private Quadtree`1<string> vh4=;
    [ObfuscationAttribute]
private Collection`1<RectangleShape> cachedExtents;
    [ObfuscationAttribute]
private Dictionary`2<string, Feature> cachedFeatures;
    [ObfuscationAttribute]
private bool isActive;
    public bool IsActive { get; public set; }
    public bool get_IsActive();
    public void set_IsActive(bool value);
    public Collection`1<Feature> GetFeatures(RectangleShape worldExtent);
    protected virtual Collection`1<Feature> GetFeaturesCore(RectangleShape worldExtent);
    public void Clear();
    public void Add(RectangleShape worldExtent, Collection`1<Feature> features);
    protected virtual void AddCore(RectangleShape worldExtent, Collection`1<Feature> features);
    public void Open();
    protected virtual void OpenCore();
    public void Close();
    protected virtual void CloseCore();
    public bool IsExtentCached(RectangleShape worldExtent);
    private static bool vx4=(RectangleShape extent, RectangleShape targetExtent);
}
public class ThinkGeo.Core.FeatureDraggedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature draggedFeature;
    public Feature DraggedFeature { get; public set; }
    public FeatureDraggedEditInteractiveOverlayEventArgs(Feature draggedFeature);
    public Feature get_DraggedFeature();
    public void set_DraggedFeature(Feature value);
}
public class ThinkGeo.Core.FeatureDraggingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature draggingFeature;
    [ObfuscationAttribute]
private PointShape sourceControlPoint;
    [ObfuscationAttribute]
private PointShape targetControlPoint;
    [ObfuscationAttribute]
private bool cancel;
    public Feature DraggingFeature { get; public set; }
    public PointShape SourceControlPoint { get; public set; }
    public PointShape TargetControlPoint { get; public set; }
    public bool Cancel { get; public set; }
    public FeatureDraggingEditInteractiveOverlayEventArgs(Feature draggingFeature, bool cancel, PointShape sourceControlPoint, PointShape targetControlPoint);
    public Feature get_DraggingFeature();
    public void set_DraggingFeature(Feature value);
    public PointShape get_SourceControlPoint();
    public void set_SourceControlPoint(PointShape value);
    public PointShape get_TargetControlPoint();
    public void set_TargetControlPoint(PointShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.FeatureDroppedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature droppedFeature;
    public Feature DroppedFeature { get; public set; }
    public FeatureDroppedEditInteractiveOverlayEventArgs(Feature droppedFeature);
    public Feature get_DroppedFeature();
    public void set_DroppedFeature(Feature value);
}
public class ThinkGeo.Core.FeatureEditedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature editedFeature;
    [ObfuscationAttribute]
private Feature lastEditedFeature;
    public Feature EditedFeature { get; public set; }
    public Feature LastEditedFeature { get; }
    public FeatureEditedEditInteractiveOverlayEventArgs(Feature lastEditedFeature, Feature editedFeature);
    public Feature get_EditedFeature();
    public void set_EditedFeature(Feature value);
    public Feature get_LastEditedFeature();
}
public class ThinkGeo.Core.FeatureEditingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature editingFeature;
    public Feature EditingFeature { get; public set; }
    public FeatureEditingEditInteractiveOverlayEventArgs(Feature editingFeature);
    public Feature get_EditingFeature();
    public void set_EditingFeature(Feature value);
}
public class ThinkGeo.Core.FeatureLabelingCandidate : object {
    [ObfuscationAttribute]
private Feature feature;
    [ObfuscationAttribute]
private Collection`1<LabelingCandidate> labelingCandidates;
    [ObfuscationAttribute]
private LabelingCandidate basePointLabelingCandidate;
    [ObfuscationAttribute]
private string key;
    [ObfuscationAttribute]
private PositionStyle positionStyle;
    public Feature Feature { get; public set; }
    public Collection`1<LabelingCandidate> LabelingCandidates { get; public set; }
    public LabelingCandidate BasePointLabelingCandidate { get; public set; }
    public string Key { get; public set; }
    public PositionStyle PositionStyle { get; public set; }
    public Feature get_Feature();
    public void set_Feature(Feature value);
    public Collection`1<LabelingCandidate> get_LabelingCandidates();
    public void set_LabelingCandidates(Collection`1<LabelingCandidate> value);
    public LabelingCandidate get_BasePointLabelingCandidate();
    public void set_BasePointLabelingCandidate(LabelingCandidate value);
    public string get_Key();
    public void set_Key(string value);
    public PositionStyle get_PositionStyle();
    public void set_PositionStyle(PositionStyle value);
    public sealed virtual int CompareTo(FeatureLabelingCandidate other);
    public static void Sort(List`1<FeatureLabelingCandidate> featureLabelingCandidates, float canvasWidth, float canvasHeight);
    private static bool DDE=(double minX, double minY, double maxX, double maxY, float canvasWidth, float canvasHeight);
    private static bool DTE=(double minX, double minY, double maxX, double maxY, float canvasWidth, float canvasHeight);
    private static void DjE=(LabelingCandidate labelingCandidate, Double& minX, Double& minY, Double& maxX, Double& maxY);
}
public abstract class ThinkGeo.Core.FeatureLayer : Layer {
    [ObfuscationAttribute]
private float drawingMarginInPixel;
    [ObfuscationAttribute]
private EditTools editTools;
    [ObfuscationAttribute]
private QueryTools queryTools;
    [ObfuscationAttribute]
private FeatureSource featureSource;
    [ObfuscationAttribute]
private ZoomLevelSet zoomLevelSet;
    [ObfuscationAttribute]
private DrawingQuality drawingQuality;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingFeaturesEventArgs> SCA=;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingWrappingFeaturesFeatureLayerEventArgs> SSA=;
    public Projection Projection { get; }
    public EditTools EditTools { get; protected set; }
    public Collection`1<string> FeatureIdsToExclude { get; }
    public QueryTools QueryTools { get; protected set; }
    public int MaxRecordsToDraw { get; public set; }
    public FeatureSource FeatureSource { get; public set; }
    public DrawingQuality DrawingQuality { get; public set; }
    public ZoomLevelSet ZoomLevelSet { get; public set; }
    public float DrawingMarginInPixel { get; public set; }
    protected bool IsOpenCore { get; }
    [CompilerGeneratedAttribute]
public void add_DrawingFeatures(EventHandler`1<DrawingFeaturesEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingFeatures(EventHandler`1<DrawingFeaturesEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DrawingWrappingFeatures(EventHandler`1<DrawingWrappingFeaturesFeatureLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingWrappingFeatures(EventHandler`1<DrawingWrappingFeaturesFeatureLayerEventArgs> value);
    protected virtual void OnDrawingFeatures(DrawingFeaturesEventArgs e);
    [ObsoleteAttribute("This API will be removed after V13.2. Please use OnDrawingFeatures instead. e.FeaturesToDraw in DrawingFeaturesEventArgs event includes the wrapping features. ")]
protected virtual void OnDrawingWrappingFeatures(DrawingWrappingFeaturesFeatureLayerEventArgs e);
    public virtual Projection get_Projection();
    public EditTools get_EditTools();
    protected void set_EditTools(EditTools value);
    public Collection`1<string> get_FeatureIdsToExclude();
    public QueryTools get_QueryTools();
    protected void set_QueryTools(QueryTools value);
    public int get_MaxRecordsToDraw();
    public void set_MaxRecordsToDraw(int value);
    public FeatureSource get_FeatureSource();
    public void set_FeatureSource(FeatureSource value);
    public DrawingQuality get_DrawingQuality();
    public void set_DrawingQuality(DrawingQuality value);
    public ZoomLevelSet get_ZoomLevelSet();
    public void set_ZoomLevelSet(ZoomLevelSet value);
    public float get_DrawingMarginInPixel();
    public void set_DrawingMarginInPixel(float value);
    protected virtual bool get_IsOpenCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual bool IsDrawingNeededCore(double currentScale);
    protected void SetupTools();
    protected virtual void SetupToolsCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected Collection`1<Feature> GetWrappingFeaturesForDrawing(RectangleShape drawingExtent, IEnumerable`1<string> returningColumnNames, RectangleShape wrappingExtent);
    private Collection`1<Feature> SiA=(RectangleShape drawingWorldExtent, IEnumerable`1<string> returningColumnNames, RectangleShape wrappingWorldExtent, double minRatioX, double maxRatioX);
    public double GetCeiling(double d);
    private void SyA=(object sender, DrawingProgressChangedEventArgs e);
}
public class ThinkGeo.Core.FeatureResizedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature resizedFeature;
    public Feature ResizedFeature { get; public set; }
    public FeatureResizedEditInteractiveOverlayEventArgs(Feature resizedFeature);
    public Feature get_ResizedFeature();
    public void set_ResizedFeature(Feature value);
}
public class ThinkGeo.Core.FeatureResizingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature resizingFeature;
    [ObfuscationAttribute]
private PointShape sourceControlPoint;
    [ObfuscationAttribute]
private PointShape targetControlPoint;
    [ObfuscationAttribute]
private bool cancel;
    public Feature ResizingFeature { get; public set; }
    public PointShape SourceControlPoint { get; public set; }
    public PointShape TargetControlPoint { get; public set; }
    public bool Cancel { get; public set; }
    public FeatureResizingEditInteractiveOverlayEventArgs(Feature resizingFeature, bool cancel, PointShape sourceControlPoint, PointShape targetControlPoint);
    public Feature get_ResizingFeature();
    public void set_ResizingFeature(Feature value);
    public PointShape get_SourceControlPoint();
    public void set_SourceControlPoint(PointShape value);
    public PointShape get_TargetControlPoint();
    public void set_TargetControlPoint(PointShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.FeatureRotatedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature rotatedFeature;
    public Feature RotatedFeature { get; public set; }
    public FeatureRotatedEditInteractiveOverlayEventArgs(Feature rotatedFeature);
    public Feature get_RotatedFeature();
    public void set_RotatedFeature(Feature value);
}
public class ThinkGeo.Core.FeatureRotatingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature rotatingFeature;
    [ObfuscationAttribute]
private PointShape sourceControlPoint;
    [ObfuscationAttribute]
private PointShape targetControlPoint;
    [ObfuscationAttribute]
private bool cancel;
    public Feature RotatingFeature { get; public set; }
    public PointShape SourceControlPoint { get; public set; }
    public PointShape TargetControlPoint { get; public set; }
    public bool Cancel { get; public set; }
    public FeatureRotatingEditInteractiveOverlayEventArgs(Feature rotatingFeature, bool cancel, PointShape sourceControlPoint, PointShape targetControlPoint);
    public Feature get_RotatingFeature();
    public void set_RotatingFeature(Feature value);
    public PointShape get_SourceControlPoint();
    public void set_SourceControlPoint(PointShape value);
    public PointShape get_TargetControlPoint();
    public void set_TargetControlPoint(PointShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public abstract class ThinkGeo.Core.FeatureSource : object {
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private static int maximumLoopCount;
    [ObfuscationAttribute]
private static int progressDrawingRaisingFrequency;
    [ObfuscationAttribute]
private int progressDrawingRaisedCount;
    private bool oBo=;
    [ObfuscationAttribute]
private bool isInTransaction;
    [ObfuscationAttribute]
private bool isTransactionLive;
    [ObfuscationAttribute]
private TransactionBuffer transactionBuffer;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    [ObfuscationAttribute]
private Collection`1<string> featureIdsToExclude;
    [ObfuscationAttribute]
private ProjectionConverter projectionConverter;
    [ObfuscationAttribute]
private Projection projection;
    [ObfuscationAttribute]
private FeatureCache geoCache;
    [ObfuscationAttribute]
private int maxRecordsToDraw;
    [ObfuscationAttribute]
private bool canModifyColumnStructure;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingProgressChangedEventArgs> KxU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingColumnsFeatureSourceEventArgs> jh4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GottenColumnsFeatureSourceEventArgs> jx4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingFeaturesByIdsFeatureSourceEventArgs> kB4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingFeaturesForDrawingFeatureSourceEventArgs> kR4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<CustomColumnFetchEventArgs> kh4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<CommittingTransactionEventArgs> kx4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<CommittedTransactionEventArgs> lB4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<OpeningFeatureSourceEventArgs> lR4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<OpenedFeatureSourceEventArgs> lh4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClosingFeatureSourceEventArgs> lx4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClosedFeatureSourceEventArgs> mB4=;
    public string Id { get; }
    public bool CanExecuteSqlQuery { get; }
    protected bool CanExecuteSqlQueryCore { get; }
    public bool IsOpen { get; }
    public Projection Projection { get; protected set; }
    protected bool IsOpenCore { get; protected set; }
    public bool CanModifyColumnStructure { get; }
    protected bool CanModifyColumnStructureCore { get; protected set; }
    protected Collection`1<FeatureSourceColumn> FeatureSourceColumns { get; }
    public bool IsInTransaction { get; }
    public bool IsTransactionLive { get; public set; }
    public bool IsEditable { get; }
    public ProjectionConverter ProjectionConverter { get; public set; }
    public FeatureCache GeoCache { get; public set; }
    public Collection`1<string> FeatureIdsToExclude { get; }
    public TransactionBuffer TransactionBuffer { get; public set; }
    public int MaxRecordsToDraw { get; public set; }
    [CompilerGeneratedAttribute]
public void add_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GettingColumns(EventHandler`1<GettingColumnsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingColumns(EventHandler`1<GettingColumnsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GottenColumns(EventHandler`1<GottenColumnsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GottenColumns(EventHandler`1<GottenColumnsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GettingFeaturesByIds(EventHandler`1<GettingFeaturesByIdsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingFeaturesByIds(EventHandler`1<GettingFeaturesByIdsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GettingFeaturesForDrawing(EventHandler`1<GettingFeaturesForDrawingFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingFeaturesForDrawing(EventHandler`1<GettingFeaturesForDrawingFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CustomColumnFetch(EventHandler`1<CustomColumnFetchEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CustomColumnFetch(EventHandler`1<CustomColumnFetchEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CommittingTransaction(EventHandler`1<CommittingTransactionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CommittingTransaction(EventHandler`1<CommittingTransactionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CommittedTransaction(EventHandler`1<CommittedTransactionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CommittedTransaction(EventHandler`1<CommittedTransactionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OpeningFeatureSource(EventHandler`1<OpeningFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OpeningFeatureSource(EventHandler`1<OpeningFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OpenedFeatureSource(EventHandler`1<OpenedFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OpenedFeatureSource(EventHandler`1<OpenedFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClosingFeatureSource(EventHandler`1<ClosingFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClosingFeatureSource(EventHandler`1<ClosingFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClosedFeatureSource(EventHandler`1<ClosedFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClosedFeatureSource(EventHandler`1<ClosedFeatureSourceEventArgs> value);
    protected virtual void OnGettingColumns(GettingColumnsFeatureSourceEventArgs e);
    protected virtual void OnGottenColumns(GottenColumnsFeatureSourceEventArgs e);
    protected virtual void OnCustomColumnFetch(CustomColumnFetchEventArgs e);
    protected virtual void OnCommittingTransaction(CommittingTransactionEventArgs e);
    protected virtual void OnCommittedTransaction(CommittedTransactionEventArgs e);
    protected virtual void OnOpeningFeatureSource(OpeningFeatureSourceEventArgs e);
    protected virtual void OnOpenedFeatureSource(OpenedFeatureSourceEventArgs e);
    protected virtual void OnClosingFeatureSource(ClosingFeatureSourceEventArgs e);
    protected virtual void OnClosedFeatureSource(ClosedFeatureSourceEventArgs e);
    protected virtual void OnGettingFeaturesByIds(GettingFeaturesByIdsFeatureSourceEventArgs e);
    protected virtual void OnGettingFeaturesForDrawing(GettingFeaturesForDrawingFeatureSourceEventArgs e);
    public string get_Id();
    public bool get_CanExecuteSqlQuery();
    protected virtual bool get_CanExecuteSqlQueryCore();
    public bool get_IsOpen();
    public Projection get_Projection();
    protected void set_Projection(Projection value);
    protected virtual bool get_IsOpenCore();
    protected virtual void set_IsOpenCore(bool value);
    public bool get_CanModifyColumnStructure();
    protected virtual bool get_CanModifyColumnStructureCore();
    protected virtual void set_CanModifyColumnStructureCore(bool value);
    protected Collection`1<FeatureSourceColumn> get_FeatureSourceColumns();
    public bool get_IsInTransaction();
    public bool get_IsTransactionLive();
    public void set_IsTransactionLive(bool value);
    public virtual bool get_IsEditable();
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    public FeatureCache get_GeoCache();
    public void set_GeoCache(FeatureCache value);
    public Collection`1<string> get_FeatureIdsToExclude();
    public TransactionBuffer get_TransactionBuffer();
    public void set_TransactionBuffer(TransactionBuffer value);
    public int get_MaxRecordsToDraw();
    public void set_MaxRecordsToDraw(int value);
    public int ExecuteNonQuery(string sqlStatement);
    protected virtual int ExecuteNonQueryCore(string sqlStatement);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue, ReturningColumnsType returningColumnType);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    private static Collection`1<Feature> mR4=(Collection`1<Feature> features, TransactionBuffer transactionBuffer, string columnName, string columnValue);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    public object ExecuteScalar(string sqlStatement);
    protected virtual object ExecuteScalarCore(string sqlStatement);
    public DataTable ExecuteQuery(string sqlStatement);
    protected virtual DataTable ExecuteQueryCore(string sqlStatement);
    public Collection`1<FeatureSourceColumn> GetColumns();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    public void RefreshColumns();
    public long GetCount();
    protected virtual long GetCountCore();
    public RectangleShape GetBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    public FeatureSource CloneDeep();
    protected virtual FeatureSource CloneDeepCore();
    public void Open();
    protected virtual void OpenCore();
    public void Close();
    protected virtual void CloseCore();
    public void BeginTransaction();
    public string AddFeature(Feature feature);
    public string AddFeature(BaseShape shape);
    public string AddFeature(BaseShape shape, IDictionary`2<string, string> columnValues);
    public void DeleteFeature(string id);
    public void UpdateFeature(Feature feature);
    public void UpdateFeature(BaseShape shape);
    public void UpdateFeature(BaseShape shape, IDictionary`2<string, string> columnValues);
    public void RollbackTransaction();
    public TransactionResult CommitTransaction();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    public void AddColumn(FeatureSourceColumn featureSourceColumn);
    public void DeleteColumn(string columnName);
    public void UpdateColumn(string columnName, FeatureSourceColumn newFeatureSourceColumn);
    public Collection`1<Feature> GetAllFeatures(IEnumerable`1<string> returningColumnNames);
    internal Collection`1<Feature> mh4=(Collection`1<Feature> sourceFeatures, Collection`1<string> fieldNamesOutsideOfSource);
    private Collection`1<Feature> mh4=(Collection`1<Feature> sourceFeatures, Collection`1<string> fieldNamesOutsideOfSource, bool forceRaiseEvent);
    private Collection`1<Feature> mx4=(Collection`1<Feature> sourceFeatures);
    public Collection`1<Feature> GetAllFeatures(ReturningColumnsType returningColumnNamesType);
    public Collection`1<string> GetFeatureIds();
    protected virtual Collection`1<string> GetFeatureIdsCore();
    protected abstract virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesOutsideBoundingBox(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesOutsideBoundingBox(RectangleShape boundingBox, ReturningColumnsType returningColumnNamesType);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesInsideBoundingBox(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesInsideBoundingBox(RectangleShape boundingBox, ReturningColumnsType returningColumnNamesType);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<string> GetFeatureIdsInsideBoundingBox(RectangleShape boundingBox);
    protected virtual Collection`1<string> GetFeatureIdsInsideBoundingBoxCore(RectangleShape boundingBox);
    public Collection`1<Feature> GetFeaturesForDrawing(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    internal void nB4=(RectangleShape boundingBox, Collection`1<Feature> returnFeatures, bool needUpdateProjection);
    private Feature qRo=(ProjectionConverter projection, Feature feature);
    public Collection`1<Feature> GetFeaturesForDrawing(RectangleShape boundingBox, double screenWidth, double screenHeight, ReturningColumnsType returningColumnNamesType);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> SpatialQuery(BaseShape targetShape, QueryType queryType, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> SpatialQuery(BaseShape targetShape, QueryType queryType, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> SpatialQuery(Feature feature, QueryType queryType, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> SpatialQuery(Feature feature, QueryType queryType, ReturningColumnsType returningColumnNamesType);
    protected virtual Collection`1<Feature> SpatialQueryCore(BaseShape targetShape, QueryType queryType, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> nR4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> nh4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> nx4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> oB4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> oR4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> oh4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> ox4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> pB4=(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    private static bool pR4=(BaseShape targetShape, BaseShape sourceShape, QueryType queryType);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfFeatureSource, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames, double searchRadius, DistanceUnit unitOfSearchRadius);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames, double searchRadius, DistanceUnit unitOfSearchRadius);
    protected virtual Collection`1<Feature> GetFeaturesNearestToCore(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    internal static Collection`1<Feature> ph4=(Collection`1<Feature> possibleResults, BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(Feature targetFeature, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(Feature targetFeature, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, ReturningColumnsType returningColumnNamesType);
    protected virtual Collection`1<Feature> GetFeaturesWithinDistanceOfCore(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    public Feature GetFeatureById(string id, IEnumerable`1<string> returningColumnNames);
    public Feature GetFeatureById(string id, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesByIds(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesByIds(IEnumerable`1<string> ids, ReturningColumnsType returningColumnNamesType);
    public RectangleShape GetBoundingBoxById(string id);
    public RectangleShape GetBoundingBoxByIds(IEnumerable`1<string> ids);
    public void RemoveEmptyAndExcludedFeatures(Collection`1<Feature> features);
    public Collection`1<string> GetColumnNamesOutsideFeatureSource(IEnumerable`1<string> returningColumnNames);
    public Collection`1<RectangleShape> GetBoundingBoxesByIds(IEnumerable`1<string> ids);
    protected virtual RectangleShape GetBoundingBoxByIdCore(string id);
    public WellKnownType GetFirstFeaturesWellKnownType();
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected Collection`1<string> GetColumnNamesInsideFeatureSource(IEnumerable`1<string> returningColumnNames);
    protected Collection`1<string> GetReturningColumnNames(ReturningColumnsType returningColumnNamesType);
    public static string GetColumnNameAlias(string columnName, ICollection`1<string> columnNames);
    public static Collection`1<string> SplitColumnNames(IEnumerable`1<string> columnNames);
    public static DataTable ConvertToDataTable(IEnumerable`1<Feature> features, IEnumerable`1<string> columnNames);
    protected static Dictionary`2<string, string> CombineFieldValues(Dictionary`2<string, string> columnValues, IEnumerable`1<string> originalColumnNames);
    private static int px4=(List`1<double> doubles);
    private static bool qB4=(IEnumerable`1<string> originalComlumnNames);
    private static Collection`1<string> qR4=(string multiFieldName);
    private static Collection`1<string> qh4=(string multiFieldName);
    private static Collection`1<Feature> mR4=(Collection`1<Feature> features, TransactionBuffer transactionBuffer, IEnumerable`1<string> returningIds);
    private static Dictionary`2<string, Feature> mR4=(Dictionary`2<string, Feature> features, TransactionBuffer transactionBuffer);
    private static Dictionary`2<string, Feature> qx4=(Collection`1<Feature> features);
    private static Collection`1<Feature> rB4=(Dictionary`2<string, Feature> features);
    protected virtual void OnDrawingProgressChanged(DrawingProgressChangedEventArgs e);
    internal Collection`1<string> rR4=(IEnumerable`1<string> returningColumnNames);
    [OnGeodeserializedAttribute]
private void rh4=();
    private static Collection`1<Feature> rx4=(Collection`1<Feature> features, IEnumerable`1<string> returningColumnNames);
    private static string sB4=(string columnName, ICollection`1<string> columnNames, int alias);
    public bool CanGetBoundingBoxQuickly();
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    public bool CanGetCountQuickly();
    protected virtual bool CanGetCountQuicklyCore();
    public Collection`1<DistinctColumnValue> GetDistinctColumnValues(string columnName);
    protected virtual Collection`1<DistinctColumnValue> GetDistinctColumnValuesCore(string columnName);
    public Collection`1<Feature> GetAllFeatures(ReturningColumnsType returningColumnTypes, int startIndex);
    public Collection`1<Feature> GetAllFeatures(ReturningColumnsType returningColumnTypes, int startIndex, int takeCount);
    public Collection`1<Feature> GetAllFeatures(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    [CompilerGeneratedAttribute]
private bool sR4=(Feature f);
    [CompilerGeneratedAttribute]
private bool sh4=(Feature f);
}
public class ThinkGeo.Core.FeatureSourceColumn : object {
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private string typeName;
    [ObfuscationAttribute]
private int maxLength;
    public string ColumnName { get; public set; }
    public string TypeName { get; public set; }
    public int MaxLength { get; public set; }
    public FeatureSourceColumn(string columnName);
    public FeatureSourceColumn(string columnName, string typeName, int maxLength);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public int get_MaxLength();
    public void set_MaxLength(int value);
    public virtual string ToString();
}
public enum ThinkGeo.Core.FeatureValidationType : Enum {
    public int value__;
    public static FeatureValidationType Invalid;
    public static FeatureValidationType Valid;
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.FeetValues : ValueType {
    [ObfuscationAttribute]
private double v10;
    [ObfuscationAttribute]
private double v100;
    [ObfuscationAttribute]
private double v1000;
    [ObfuscationAttribute]
private double v20;
    [ObfuscationAttribute]
private double v200;
    [ObfuscationAttribute]
private double v2000;
    [ObfuscationAttribute]
private double v30;
    [ObfuscationAttribute]
private double v300;
    [ObfuscationAttribute]
private double v40;
    [ObfuscationAttribute]
private double v400;
    [ObfuscationAttribute]
private double v50;
    [ObfuscationAttribute]
private double v500;
    public double JCE= { get; }
    public double JiE= { get; }
    public double KCE= { get; }
    public double KiE= { get; }
    public double LCE= { get; }
    public double LiE= { get; }
    public double MCE= { get; }
    public double MiE= { get; }
    public double NCE= { get; }
    public double NiE= { get; }
    public double OCE= { get; }
    public double OiE= { get; }
    public FeetValues(int width, double extentLengthBar, DistanceUnit distanceUnit);
    public double IyE=();
    public double JSE=();
    public double JyE=();
    public double KSE=();
    public double KyE=();
    public double LSE=();
    public double LyE=();
    public double MSE=();
    public double MyE=();
    public double NSE=();
    public double NyE=();
    public double OSE=();
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.FileHeader : ValueType {
    [ObfuscationAttribute]
public string descriptionString;
    [ObfuscationAttribute]
public UInt32 extensionId;
    [ObfuscationAttribute]
public UInt32 freePageId;
    [ObfuscationAttribute]
public string extensionName;
    [ObfuscationAttribute]
public UInt32 pageSize;
    [ObfuscationAttribute]
public bool isFloat;
    private static int kh8=;
    private static int kx8=;
    private static int lB8=;
    public void Kh8=();
    public bool oBw=(BinaryReader r);
    public bool rhw=(BinaryWriter w);
    public virtual string ToString();
}
public class ThinkGeo.Core.FileRasterTileCache : RasterTileCache {
    [ObfuscationAttribute]
private static int DigitCount;
    [ObfuscationAttribute]
private string cacheDirectory;
    private static object jxY=;
    public string CacheDirectory { get; public set; }
    public FileRasterTileCache(string cacheDirectory);
    public FileRasterTileCache(string cacheDirectory, string cacheId);
    public FileRasterTileCache(string cacheDirectory, string cacheId, GeoImageFormat imageFormat);
    private static FileRasterTileCache();
    public string get_CacheDirectory();
    public void set_CacheDirectory(string value);
    protected virtual Tile GetTileCore(int zoom, long column, long row);
    [AsyncStateMachineAttribute("ThinkGeo.Core.FileRasterTileCache//D4=")]
protected virtual Task`1<Tile> GetTileAsyncCore(int zoom, long column, long row, CancellationToken cancellationToken);
    protected virtual void SaveTileCore(Tile tile);
    [AsyncStateMachineAttribute("ThinkGeo.Core.FileRasterTileCache/AT8=")]
protected virtual Task SaveTileAsyncCore(Tile tile, CancellationToken cancellationToken);
    protected virtual void DeleteTileCore(Tile tile);
    internal bool yB0=(string tileImageFileName);
    public void ClearCache(TimeSpan tileExpiration);
    public void ClearCache(double maxSizeInMegabytes);
    public void ClearCache(TimeSpan tileExpiration, double maxSizeInMegabytes);
    public virtual string ToString();
    [IteratorStateMachineAttribute("ThinkGeo.Core.FileRasterTileCache/9z4=")]
private static IEnumerable`1<string> yR0=();
    private static IEnumerable`1<FileInfo> yh0=(DirectoryInfo dirInfo);
    private static long yx0=(DirectoryInfo dirInfo);
    protected virtual void ClearCacheCore();
    private static bool zB0=(string folder);
    private static string zR0=(int zoom, long column, long row, string cacheId, string cacheDirectory, GeoImageFormat imageFormat);
}
public class ThinkGeo.Core.FileVectorTileCache : TileCache {
    [ObfuscationAttribute]
private string fileExtension;
    [ObfuscationAttribute]
private string cacheDirectory;
    public string CacheDirectory { get; public set; }
    public string FileExtension { get; public set; }
    public FileVectorTileCache(string cacheDirectory);
    public FileVectorTileCache(string cacheDirectory, string cacheId);
    public FileVectorTileCache(string cacheDirectory, string cacheId, string fileExtension);
    public string get_CacheDirectory();
    public void set_CacheDirectory(string value);
    public string get_FileExtension();
    public void set_FileExtension(string value);
    protected virtual void ClearCacheCore();
    protected virtual void DeleteTileCore(Tile tile);
    protected virtual Tile GetTileCore(int zoom, long column, long row);
    [AsyncStateMachineAttribute("ThinkGeo.Core.FileVectorTileCache/BD8=")]
protected virtual Task`1<Tile> GetTileAsyncCore(int zoom, long column, long row, CancellationToken cancellationToken);
    protected virtual void SaveTileCore(Tile tile);
    [AsyncStateMachineAttribute("ThinkGeo.Core.FileVectorTileCache/Bj8=")]
protected virtual Task SaveTileAsyncCore(Tile tile, CancellationToken cancellationToken);
    private static string zR0=(int zoom, long row, long column, string cacheId, string cacheDirectory, string fileExtension);
}
public enum ThinkGeo.Core.FilterApplyMode : Enum {
    public int value__;
    public static FilterApplyMode ApplyFirst;
    public static FilterApplyMode ApplyAll;
}
public class ThinkGeo.Core.FilterCondition : object {
    internal static string wjE=;
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private string expression;
    [ObfuscationAttribute]
private string name;
    private Regex wzE=;
    private string xDE=;
    [ObfuscationAttribute]
private RegexOptions regexOptions;
    [ObfuscationAttribute]
private bool logical;
    [ObfuscationAttribute]
private bool isLeftBracket;
    [ObfuscationAttribute]
private bool isRightBracket;
    public string Expression { get; public set; }
    public string ColumnName { get; public set; }
    public string Name { get; public set; }
    public RegexOptions RegexOptions { get; public set; }
    public bool Logical { get; public set; }
    public bool IsLeftBracket { get; public set; }
    public bool IsRightBracket { get; public set; }
    public FilterCondition(string columnName);
    public FilterCondition(string columnName, string expression);
    private static FilterCondition();
    public string get_Expression();
    public void set_Expression(string value);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public string get_Name();
    public void set_Name(string value);
    public RegexOptions get_RegexOptions();
    public void set_RegexOptions(RegexOptions value);
    public bool get_Logical();
    public void set_Logical(bool value);
    public bool get_IsLeftBracket();
    public void set_IsLeftBracket(bool value);
    public bool get_IsRightBracket();
    public void set_IsRightBracket(bool value);
    public Collection`1<Feature> GetMatchingFeatures(IEnumerable`1<Feature> features);
    protected virtual Collection`1<Feature> GetMatchingFeaturesCore(IEnumerable`1<Feature> features);
    internal bool xTE=(Feature feature);
    internal bool xTE=(KeyValuePair`2<string, string> value);
    internal virtual bool SSM=(KeyValuePair`2<string, string> value);
    internal virtual bool SSM=(Feature feature);
    internal bool xjE=(Collection`1<string> values);
    private bool xzE=(string value, string expression);
    private static bool yDE=(Collection`1<string> columnValues, string expression, Func`4<double, double, double, bool> doubleMatchingFunc);
    private static bool yDE=(Collection`1<string> columnValues, string expression, Func`3<double, double, bool> doubleMatchingFunc);
    private static Collection`1<string> yTE=(Feature feature, string columnName);
    private static bool yjE=(IEnumerable`1<string> columnValues, Func`2<string, bool> matchFunc);
    [CompilerGeneratedAttribute]
private bool yzE=(Feature f);
    [CompilerGeneratedAttribute]
private bool zDE=(string v);
    [CompilerGeneratedAttribute]
private bool zTE=(string v);
}
public class ThinkGeo.Core.FilterStyle : Style {
    [ObfuscationAttribute]
private Collection`1<Style> styles;
    [ObfuscationAttribute]
private Collection`1<FilterCondition> conditions;
    public Collection`1<Style> Styles { get; }
    public Collection`1<FilterCondition> Conditions { get; }
    public Collection`1<Style> get_Styles();
    public Collection`1<FilterCondition> get_Conditions();
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    private static Collection`1<string> zjE=(string expression);
}
public class ThinkGeo.Core.FormattedPositionStyleEventArgs : EventArgs {
    [ObfuscationAttribute]
private string text;
    [ObfuscationAttribute]
private BaseShape shape;
    public string Text { get; public set; }
    public BaseShape Shape { get; public set; }
    public FormattedPositionStyleEventArgs(string text, BaseShape shape);
    public string get_Text();
    public void set_Text(string value);
    public BaseShape get_Shape();
    public void set_Shape(BaseShape value);
}
public class ThinkGeo.Core.FormattingPositionStyleEventArgs : EventArgs {
    [ObfuscationAttribute]
private string text;
    [ObfuscationAttribute]
private BaseShape shape;
    public string Text { get; public set; }
    public BaseShape Shape { get; public set; }
    public FormattingPositionStyleEventArgs(string text, BaseShape shape);
    public string get_Text();
    public void set_Text(string value);
    public BaseShape get_Shape();
    public void set_Shape(BaseShape value);
}
public class ThinkGeo.Core.GaussianKrigingGridInterpolationModel : KrigingGridInterpolationModel {
    public GaussianKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    public GaussianKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points, int numberOfRefrencedPoints);
    protected virtual double GetSillSlopeCore(double distance, double range);
}
public class ThinkGeo.Core.GeneratedTileMBTilesLayerEventArgs : EventArgs {
    public int TileX;
    public int TileY;
    public int ZoomLevel;
    public GeneratedTileMBTilesLayerEventArgs(int tileX, int tileY, int zoomLevel);
}
public class ThinkGeo.Core.GeneratingGridFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private int gridCount;
    [ObfuscationAttribute]
private int gridIndex;
    [ObfuscationAttribute]
private DateTime startProcessTime;
    [ObfuscationAttribute]
private bool isCanceled;
    [ObfuscationAttribute]
private string gridPathFilename;
    public string GridPathFilename { get; public set; }
    public bool IsCanceled { get; public set; }
    public DateTime StartProcessTime { get; public set; }
    public int GridIndex { get; public set; }
    public int GridCount { get; public set; }
    public GeneratingGridFeatureSourceEventArgs(int gridCount, int gridIndex, DateTime startProcessTime, bool isCanceled);
    public GeneratingGridFeatureSourceEventArgs(int gridCount, int gridIndex, DateTime startProcessTime, bool isCanceled, string gridPathFilename);
    public string get_GridPathFilename();
    public void set_GridPathFilename(string value);
    public bool get_IsCanceled();
    public void set_IsCanceled(bool value);
    public DateTime get_StartProcessTime();
    public void set_StartProcessTime(DateTime value);
    public int get_GridIndex();
    public void set_GridIndex(int value);
    public int get_GridCount();
    public void set_GridCount(int value);
}
public class ThinkGeo.Core.GeneratingTileMBTilesLayerEventArgs : EventArgs {
    public int TileX;
    public int TileY;
    public int ZoomLevel;
    public bool Cancel;
    public GeneratingTileMBTilesLayerEventArgs(int tileX, int tileY, int zoomLevel);
}
public enum ThinkGeo.Core.GeoAlphaType : Enum {
    public int value__;
    public static GeoAlphaType Unknown;
    public static GeoAlphaType Opaque;
    public static GeoAlphaType Premul;
    public static GeoAlphaType Unpremul;
}
public abstract class ThinkGeo.Core.GeoBrush : object {
    [ObfuscationAttribute]
private long id;
    [ObfuscationAttribute]
private static long geoBrushIdCounter;
    public long Id { get; }
    public long get_Id();
}
public static class ThinkGeo.Core.GeoBrushes : object {
    public static GeoSolidBrush AliceBlue { get; }
    public static GeoSolidBrush AntiqueWhite { get; }
    public static GeoSolidBrush Aqua { get; }
    public static GeoSolidBrush Aquamarine { get; }
    public static GeoSolidBrush Azure { get; }
    public static GeoSolidBrush Beige { get; }
    public static GeoSolidBrush Bisque { get; }
    public static GeoSolidBrush Black { get; }
    public static GeoSolidBrush BlanchedAlmond { get; }
    public static GeoSolidBrush Blue { get; }
    public static GeoSolidBrush BlueViolet { get; }
    public static GeoSolidBrush Brown { get; }
    public static GeoSolidBrush BurlyWood { get; }
    public static GeoSolidBrush CadetBlue { get; }
    public static GeoSolidBrush Chartreuse { get; }
    public static GeoSolidBrush Chocolate { get; }
    public static GeoSolidBrush Coral { get; }
    public static GeoSolidBrush CornflowerBlue { get; }
    public static GeoSolidBrush CornSilk { get; }
    public static GeoSolidBrush Crimson { get; }
    public static GeoSolidBrush Cyan { get; }
    public static GeoSolidBrush DarkBlue { get; }
    public static GeoSolidBrush DarkCyan { get; }
    public static GeoSolidBrush DarkGoldenrod { get; }
    public static GeoSolidBrush DarkGray { get; }
    public static GeoSolidBrush DarkGreen { get; }
    public static GeoSolidBrush DarkKhaki { get; }
    public static GeoSolidBrush DarkMagenta { get; }
    public static GeoSolidBrush DarkOliveGreen { get; }
    public static GeoSolidBrush DarkOrange { get; }
    public static GeoSolidBrush DarkOrchid { get; }
    public static GeoSolidBrush DarkRed { get; }
    public static GeoSolidBrush DarkSalmon { get; }
    public static GeoSolidBrush DarkSeaGreen { get; }
    public static GeoSolidBrush DarkSlateBlue { get; }
    public static GeoSolidBrush DarkSlateGray { get; }
    public static GeoSolidBrush DarkTurquoise { get; }
    public static GeoSolidBrush DarkViolet { get; }
    public static GeoSolidBrush DeepPink { get; }
    public static GeoSolidBrush DeepSkyBlue { get; }
    public static GeoSolidBrush DimGray { get; }
    public static GeoSolidBrush DodgerBlue { get; }
    public static GeoSolidBrush Firebrick { get; }
    public static GeoSolidBrush FloralWhite { get; }
    public static GeoSolidBrush ForestGreen { get; }
    public static GeoSolidBrush Fuchsia { get; }
    public static GeoSolidBrush Gainsboro { get; }
    public static GeoSolidBrush GhostWhite { get; }
    public static GeoSolidBrush Gold { get; }
    public static GeoSolidBrush Goldenrod { get; }
    public static GeoSolidBrush Gray { get; }
    public static GeoSolidBrush Green { get; }
    public static GeoSolidBrush GreenYellow { get; }
    public static GeoSolidBrush HoneyDew { get; }
    public static GeoSolidBrush HotPink { get; }
    public static GeoSolidBrush IndianRed { get; }
    public static GeoSolidBrush Indigo { get; }
    public static GeoSolidBrush Ivory { get; }
    public static GeoSolidBrush Khaki { get; }
    public static GeoSolidBrush Lavender { get; }
    public static GeoSolidBrush LavenderBlush { get; }
    public static GeoSolidBrush LawnGreen { get; }
    public static GeoSolidBrush LemonChiffon { get; }
    public static GeoSolidBrush LightBlue { get; }
    public static GeoSolidBrush LightCoral { get; }
    public static GeoSolidBrush LightCyan { get; }
    public static GeoSolidBrush LightGoldenrodYellow { get; }
    public static GeoSolidBrush LightGray { get; }
    public static GeoSolidBrush LightGreen { get; }
    public static GeoSolidBrush LightPink { get; }
    public static GeoSolidBrush LightRed { get; }
    public static GeoSolidBrush LightSalmon { get; }
    public static GeoSolidBrush LightSeaGreen { get; }
    public static GeoSolidBrush LightSkyBlue { get; }
    public static GeoSolidBrush LightSlateGray { get; }
    public static GeoSolidBrush LightSteelBlue { get; }
    public static GeoSolidBrush LightYellow { get; }
    public static GeoSolidBrush Lime { get; }
    public static GeoSolidBrush LimeGreen { get; }
    public static GeoSolidBrush Linen { get; }
    public static GeoSolidBrush Magenta { get; }
    public static GeoSolidBrush Maroon { get; }
    public static GeoSolidBrush MediumAquamarine { get; }
    public static GeoSolidBrush MediumBlue { get; }
    public static GeoSolidBrush MediumOrchid { get; }
    public static GeoSolidBrush MediumPurple { get; }
    public static GeoSolidBrush MediumSeaGreen { get; }
    public static GeoSolidBrush MediumSlateBlue { get; }
    public static GeoSolidBrush MediumSpringGreen { get; }
    public static GeoSolidBrush MediumTurquoise { get; }
    public static GeoSolidBrush MediumVioletRed { get; }
    public static GeoSolidBrush MidnightBlue { get; }
    public static GeoSolidBrush MintCream { get; }
    public static GeoSolidBrush MistyRose { get; }
    public static GeoSolidBrush Moccasin { get; }
    public static GeoSolidBrush NavajoWhite { get; }
    public static GeoSolidBrush Navy { get; }
    public static GeoSolidBrush OldLace { get; }
    public static GeoSolidBrush Olive { get; }
    public static GeoSolidBrush OliveDrab { get; }
    public static GeoSolidBrush Orange { get; }
    public static GeoSolidBrush OrangeRed { get; }
    public static GeoSolidBrush Orchid { get; }
    public static GeoSolidBrush PaleGoldenrod { get; }
    public static GeoSolidBrush PaleGreen { get; }
    public static GeoSolidBrush PaleTurquoise { get; }
    public static GeoSolidBrush PaleVioletRed { get; }
    public static GeoSolidBrush PapayaWhip { get; }
    public static GeoSolidBrush PeachPuff { get; }
    public static GeoSolidBrush Peru { get; }
    public static GeoSolidBrush Pink { get; }
    public static GeoSolidBrush Plum { get; }
    public static GeoSolidBrush PowderBlue { get; }
    public static GeoSolidBrush Purple { get; }
    public static GeoSolidBrush Red { get; }
    public static GeoSolidBrush RosyBrown { get; }
    public static GeoSolidBrush RoyalBlue { get; }
    public static GeoSolidBrush SaddleBrown { get; }
    public static GeoSolidBrush Salmon { get; }
    public static GeoSolidBrush SandyBrown { get; }
    public static GeoSolidBrush SeaGreen { get; }
    public static GeoSolidBrush SeaShell { get; }
    public static GeoSolidBrush Sienna { get; }
    public static GeoSolidBrush Silver { get; }
    public static GeoSolidBrush SkyBlue { get; }
    public static GeoSolidBrush SlateBlue { get; }
    public static GeoSolidBrush SlateGray { get; }
    public static GeoSolidBrush Snow { get; }
    public static GeoSolidBrush SpringGreen { get; }
    public static GeoSolidBrush SteelBlue { get; }
    public static GeoSolidBrush Tan { get; }
    public static GeoSolidBrush Teal { get; }
    public static GeoSolidBrush Thistle { get; }
    public static GeoSolidBrush Tomato { get; }
    public static GeoSolidBrush Turquoise { get; }
    public static GeoSolidBrush Violet { get; }
    public static GeoSolidBrush Wheat { get; }
    public static GeoSolidBrush White { get; }
    public static GeoSolidBrush WhiteSmoke { get; }
    public static GeoSolidBrush Yellow { get; }
    public static GeoSolidBrush YellowGreen { get; }
    public static GeoSolidBrush DarkYellow { get; }
    public static GeoSolidBrush LightOrange { get; }
    public static GeoSolidBrush PaleRed { get; }
    public static GeoSolidBrush PaleBlue { get; }
    public static GeoSolidBrush PaleYellow { get; }
    public static GeoSolidBrush PaleOrange { get; }
    public static GeoSolidBrush BrightRed { get; }
    public static GeoSolidBrush BrightBlue { get; }
    public static GeoSolidBrush BrightYellow { get; }
    public static GeoSolidBrush BrightOrange { get; }
    public static GeoSolidBrush PastelRed { get; }
    public static GeoSolidBrush PastelBlue { get; }
    public static GeoSolidBrush PastelYellow { get; }
    public static GeoSolidBrush PastelGreen { get; }
    public static GeoSolidBrush PastelOrange { get; }
    public static GeoSolidBrush Copper { get; }
    public static GeoSolidBrush get_AliceBlue();
    public static GeoSolidBrush get_AntiqueWhite();
    public static GeoSolidBrush get_Aqua();
    public static GeoSolidBrush get_Aquamarine();
    public static GeoSolidBrush get_Azure();
    public static GeoSolidBrush get_Beige();
    public static GeoSolidBrush get_Bisque();
    public static GeoSolidBrush get_Black();
    public static GeoSolidBrush get_BlanchedAlmond();
    public static GeoSolidBrush get_Blue();
    public static GeoSolidBrush get_BlueViolet();
    public static GeoSolidBrush get_Brown();
    public static GeoSolidBrush get_BurlyWood();
    public static GeoSolidBrush get_CadetBlue();
    public static GeoSolidBrush get_Chartreuse();
    public static GeoSolidBrush get_Chocolate();
    public static GeoSolidBrush get_Coral();
    public static GeoSolidBrush get_CornflowerBlue();
    public static GeoSolidBrush get_CornSilk();
    public static GeoSolidBrush get_Crimson();
    public static GeoSolidBrush get_Cyan();
    public static GeoSolidBrush get_DarkBlue();
    public static GeoSolidBrush get_DarkCyan();
    public static GeoSolidBrush get_DarkGoldenrod();
    public static GeoSolidBrush get_DarkGray();
    public static GeoSolidBrush get_DarkGreen();
    public static GeoSolidBrush get_DarkKhaki();
    public static GeoSolidBrush get_DarkMagenta();
    public static GeoSolidBrush get_DarkOliveGreen();
    public static GeoSolidBrush get_DarkOrange();
    public static GeoSolidBrush get_DarkOrchid();
    public static GeoSolidBrush get_DarkRed();
    public static GeoSolidBrush get_DarkSalmon();
    public static GeoSolidBrush get_DarkSeaGreen();
    public static GeoSolidBrush get_DarkSlateBlue();
    public static GeoSolidBrush get_DarkSlateGray();
    public static GeoSolidBrush get_DarkTurquoise();
    public static GeoSolidBrush get_DarkViolet();
    public static GeoSolidBrush get_DeepPink();
    public static GeoSolidBrush get_DeepSkyBlue();
    public static GeoSolidBrush get_DimGray();
    public static GeoSolidBrush get_DodgerBlue();
    public static GeoSolidBrush get_Firebrick();
    public static GeoSolidBrush get_FloralWhite();
    public static GeoSolidBrush get_ForestGreen();
    public static GeoSolidBrush get_Fuchsia();
    public static GeoSolidBrush get_Gainsboro();
    public static GeoSolidBrush get_GhostWhite();
    public static GeoSolidBrush get_Gold();
    public static GeoSolidBrush get_Goldenrod();
    public static GeoSolidBrush get_Gray();
    public static GeoSolidBrush get_Green();
    public static GeoSolidBrush get_GreenYellow();
    public static GeoSolidBrush get_HoneyDew();
    public static GeoSolidBrush get_HotPink();
    public static GeoSolidBrush get_IndianRed();
    public static GeoSolidBrush get_Indigo();
    public static GeoSolidBrush get_Ivory();
    public static GeoSolidBrush get_Khaki();
    public static GeoSolidBrush get_Lavender();
    public static GeoSolidBrush get_LavenderBlush();
    public static GeoSolidBrush get_LawnGreen();
    public static GeoSolidBrush get_LemonChiffon();
    public static GeoSolidBrush get_LightBlue();
    public static GeoSolidBrush get_LightCoral();
    public static GeoSolidBrush get_LightCyan();
    public static GeoSolidBrush get_LightGoldenrodYellow();
    public static GeoSolidBrush get_LightGray();
    public static GeoSolidBrush get_LightGreen();
    public static GeoSolidBrush get_LightPink();
    public static GeoSolidBrush get_LightRed();
    public static GeoSolidBrush get_LightSalmon();
    public static GeoSolidBrush get_LightSeaGreen();
    public static GeoSolidBrush get_LightSkyBlue();
    public static GeoSolidBrush get_LightSlateGray();
    public static GeoSolidBrush get_LightSteelBlue();
    public static GeoSolidBrush get_LightYellow();
    public static GeoSolidBrush get_Lime();
    public static GeoSolidBrush get_LimeGreen();
    public static GeoSolidBrush get_Linen();
    public static GeoSolidBrush get_Magenta();
    public static GeoSolidBrush get_Maroon();
    public static GeoSolidBrush get_MediumAquamarine();
    public static GeoSolidBrush get_MediumBlue();
    public static GeoSolidBrush get_MediumOrchid();
    public static GeoSolidBrush get_MediumPurple();
    public static GeoSolidBrush get_MediumSeaGreen();
    public static GeoSolidBrush get_MediumSlateBlue();
    public static GeoSolidBrush get_MediumSpringGreen();
    public static GeoSolidBrush get_MediumTurquoise();
    public static GeoSolidBrush get_MediumVioletRed();
    public static GeoSolidBrush get_MidnightBlue();
    public static GeoSolidBrush get_MintCream();
    public static GeoSolidBrush get_MistyRose();
    public static GeoSolidBrush get_Moccasin();
    public static GeoSolidBrush get_NavajoWhite();
    public static GeoSolidBrush get_Navy();
    public static GeoSolidBrush get_OldLace();
    public static GeoSolidBrush get_Olive();
    public static GeoSolidBrush get_OliveDrab();
    public static GeoSolidBrush get_Orange();
    public static GeoSolidBrush get_OrangeRed();
    public static GeoSolidBrush get_Orchid();
    public static GeoSolidBrush get_PaleGoldenrod();
    public static GeoSolidBrush get_PaleGreen();
    public static GeoSolidBrush get_PaleTurquoise();
    public static GeoSolidBrush get_PaleVioletRed();
    public static GeoSolidBrush get_PapayaWhip();
    public static GeoSolidBrush get_PeachPuff();
    public static GeoSolidBrush get_Peru();
    public static GeoSolidBrush get_Pink();
    public static GeoSolidBrush get_Plum();
    public static GeoSolidBrush get_PowderBlue();
    public static GeoSolidBrush get_Purple();
    public static GeoSolidBrush get_Red();
    public static GeoSolidBrush get_RosyBrown();
    public static GeoSolidBrush get_RoyalBlue();
    public static GeoSolidBrush get_SaddleBrown();
    public static GeoSolidBrush get_Salmon();
    public static GeoSolidBrush get_SandyBrown();
    public static GeoSolidBrush get_SeaGreen();
    public static GeoSolidBrush get_SeaShell();
    public static GeoSolidBrush get_Sienna();
    public static GeoSolidBrush get_Silver();
    public static GeoSolidBrush get_SkyBlue();
    public static GeoSolidBrush get_SlateBlue();
    public static GeoSolidBrush get_SlateGray();
    public static GeoSolidBrush get_Snow();
    public static GeoSolidBrush get_SpringGreen();
    public static GeoSolidBrush get_SteelBlue();
    public static GeoSolidBrush get_Tan();
    public static GeoSolidBrush get_Teal();
    public static GeoSolidBrush get_Thistle();
    public static GeoSolidBrush get_Tomato();
    public static GeoSolidBrush get_Turquoise();
    public static GeoSolidBrush get_Violet();
    public static GeoSolidBrush get_Wheat();
    public static GeoSolidBrush get_White();
    public static GeoSolidBrush get_WhiteSmoke();
    public static GeoSolidBrush get_Yellow();
    public static GeoSolidBrush get_YellowGreen();
    public static GeoSolidBrush get_DarkYellow();
    public static GeoSolidBrush get_LightOrange();
    public static GeoSolidBrush get_PaleRed();
    public static GeoSolidBrush get_PaleBlue();
    public static GeoSolidBrush get_PaleYellow();
    public static GeoSolidBrush get_PaleOrange();
    public static GeoSolidBrush get_BrightRed();
    public static GeoSolidBrush get_BrightBlue();
    public static GeoSolidBrush get_BrightYellow();
    public static GeoSolidBrush get_BrightOrange();
    public static GeoSolidBrush get_PastelRed();
    public static GeoSolidBrush get_PastelBlue();
    public static GeoSolidBrush get_PastelYellow();
    public static GeoSolidBrush get_PastelGreen();
    public static GeoSolidBrush get_PastelOrange();
    public static GeoSolidBrush get_Copper();
}
public enum ThinkGeo.Core.GeoBrushWrapMode : Enum {
    public int value__;
    public static GeoBrushWrapMode Tile;
    public static GeoBrushWrapMode Clamp;
    public static GeoBrushWrapMode TileFlipX;
    public static GeoBrushWrapMode TileFlipY;
    public static GeoBrushWrapMode TileFlipXY;
}
public abstract class ThinkGeo.Core.GeoCanvas : object {
    private static int IxU=;
    private static int JBU=;
    private static int JRU=;
    private static int JhU=;
    private static int JxU=;
    private static int KBU=;
    private static int KRU=;
    private static int KhU=;
    [ObfuscationAttribute]
private int progressDrawingRaisingFrenquency;
    [ObfuscationAttribute]
private int progressDrawingRaisedCount;
    [ObfuscationAttribute]
private bool isDrawing;
    [ObfuscationAttribute]
private float width;
    [ObfuscationAttribute]
private float height;
    [ObfuscationAttribute]
private double worldToScreenFactorX;
    [ObfuscationAttribute]
private double worldToScreenFactorY;
    [ObfuscationAttribute]
private object nativeImage;
    [ObfuscationAttribute]
private RectangleShape currentWorldExtent;
    [ObfuscationAttribute]
private DrawingQuality drawingQuality;
    [ObfuscationAttribute]
private GeographyUnit mapUnit;
    [ObfuscationAttribute]
private float dpi;
    [ObfuscationAttribute]
private Collection`1<GeoColor> keyColors;
    [ObfuscationAttribute]
private double currentScale;
    [ObfuscationAttribute]
private float scaleFactor;
    [ObfuscationAttribute]
private CancellationToken cancellationToken;
    [ObfuscationAttribute]
private Dictionary`2<int, GeoPen> CachedScaledPen;
    [ObfuscationAttribute]
private RectangleShape clippingArea;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingProgressChangedEventArgs> KxU=;
    [CompilerGeneratedAttribute]
private double LBU=;
    public double CurrentScale { get; }
    public double FontDisplayDensity { get; }
    public DrawingQuality DrawingQuality { get; public set; }
    public GeographyUnit MapUnit { get; }
    public float Width { get; protected set; }
    public float Height { get; protected set; }
    public RectangleShape CurrentWorldExtent { get; protected set; }
    public bool SupportKeyColor { get; }
    public Collection`1<GeoColor> KeyColors { get; }
    public object NativeImage { get; }
    public bool IsDrawing { get; protected set; }
    public float Dpi { get; public set; }
    public float ScaleFactor { get; public set; }
    public CancellationToken CancellationToken { get; public set; }
    public RectangleShape ClippingArea { get; public set; }
    private bool LhU= { get; }
    [CompilerGeneratedAttribute]
public void add_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    public double get_CurrentScale();
    [CompilerGeneratedAttribute]
public virtual double get_FontDisplayDensity();
    public DrawingQuality get_DrawingQuality();
    public void set_DrawingQuality(DrawingQuality value);
    public GeographyUnit get_MapUnit();
    public float get_Width();
    protected void set_Width(float value);
    public float get_Height();
    protected void set_Height(float value);
    public RectangleShape get_CurrentWorldExtent();
    protected void set_CurrentWorldExtent(RectangleShape value);
    public virtual bool get_SupportKeyColor();
    public Collection`1<GeoColor> get_KeyColors();
    public object get_NativeImage();
    public bool get_IsDrawing();
    protected void set_IsDrawing(bool value);
    public virtual float get_Dpi();
    public virtual void set_Dpi(float value);
    public float get_ScaleFactor();
    public void set_ScaleFactor(float value);
    public CancellationToken get_CancellationToken();
    public void set_CancellationToken(CancellationToken value);
    public RectangleShape get_ClippingArea();
    public void set_ClippingArea(RectangleShape value);
    public void Clear(GeoBrush fillBrush);
    protected virtual void ClearCore(GeoBrush fillBrush);
    public void DrawArc(GeoPen pen, DrawingRectangleF rect, float startAngle, float sweepAngle, DrawingLevel drawingLevel);
    public void DrawArc(GeoPen pen, float x, float y, float width, float height, float startAngle, float sweepAngle, DrawingLevel drawingLevel);
    protected abstract virtual void DrawArcCore(GeoPen pen, float x, float y, float width, float height, float startAngle, float sweepAngle, DrawingLevel drawingLevel);
    public void DrawArea(Feature feature, GeoPen outlinePen, DrawingLevel drawingLevel);
    public void DrawArea(AreaBaseShape shape, GeoPen outlinePen, DrawingLevel drawingLevel);
    public void DrawArea(Feature feature, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawArea(AreaBaseShape shape, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawArea(Feature feature, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawArea(AreaBaseShape shape, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawArea(Feature feature, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    public void DrawArea(AreaBaseShape shape, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    private List`1<List`1<ScreenPointF[]>> LxU=(Byte[] areaShapeWkb, byte byteOrder);
    public void DrawArea(IEnumerable`1<ScreenPointF[]> screenPoints, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    protected abstract virtual void DrawAreaCore(IEnumerable`1<ScreenPointF[]> screenPoints, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    public void DrawLine(Feature feature, GeoPen linePen, DrawingLevel drawingLevel);
    public void DrawLine(LineBaseShape shape, GeoPen linePen, DrawingLevel drawingLevel);
    public void DrawLine(Feature feature, GeoPen linePen, DrawingLevel drawingLevel, float xOffset, float yOffset);
    public void DrawLine(LineBaseShape shape, GeoPen linePen, DrawingLevel drawingLevel, float xOffset, float yOffset);
    public void DrawLine(IEnumerable`1<ScreenPointF> screenPoints, GeoPen linePen, DrawingLevel drawingLevel, float xOffset, float yOffset);
    protected abstract virtual void DrawLineCore(IEnumerable`1<ScreenPointF> screenPoints, GeoPen linePen, DrawingLevel drawingLevel, float xOffset, float yOffset);
    public void DrawEllipse(Feature feature, float width, float height, GeoPen outlinePen, DrawingLevel drawingLevel);
    public void DrawEllipse(PointBaseShape shape, float width, float height, GeoPen outlinePen, DrawingLevel drawingLevel);
    public void DrawEllipse(Feature centerPointFeature, float width, float height, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawEllipse(PointBaseShape shape, float width, float height, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawEllipse(Feature feature, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawEllipse(PointBaseShape shape, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel);
    public void DrawEllipse(Feature feature, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    public void DrawEllipse(PointBaseShape shape, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    public void DrawEllipse(ScreenPointF screenPoint, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    protected abstract virtual void DrawEllipseCore(ScreenPointF screenPoint, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    public void DrawWorldImageWithoutScaling(GeoImage image, double centerXInWorld, double centerYInWorld, DrawingLevel drawingLevel);
    public void DrawWorldImageWithoutScaling(GeoImage image, double centerXInWorld, double centerYInWorld, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    public void DrawScreenImageWithoutScaling(GeoImage image, float centerXInScreen, float centerYInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    protected abstract virtual void DrawScreenImageWithoutScalingCore(GeoImage image, float centerXInScreen, float centerYInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    public void DrawWorldImage(GeoImage image, double centerXInWorld, double centerYInWorld, float widthInScreen, float heightInScreen, DrawingLevel drawingLevel);
    public void DrawWorldImage(GeoImage image, double centerXInWorld, double centerYInWorld, double imageScale, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    public void DrawWorldImage(GeoImage image, double centerXInWorld, double centerYInWorld, float widthInScreen, float heightInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    public void DrawScreenImage(GeoImage image, float centerXInScreen, float centerYInScreen, float widthInScreen, float heightInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    protected abstract virtual void DrawScreenImageCore(GeoImage image, float centerXInScreen, float centerYInScreen, float widthInScreen, float heightInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    public void DrawTextWithScreenCoordinate(string text, GeoFont font, GeoBrush fillBrush, float upperLeftXInScreen, float upperLeftYInScreen, DrawingLevel drawingLevel);
    public void DrawTextWithScreenCoordinate(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, float upperLeftXInScreen, float upperLeftYInScreen, DrawingLevel drawingLevel);
    public void DrawTextWithWorldCoordinate(string text, GeoFont font, GeoBrush fillBrush, double upperLeftXInWorld, double upperLeftYInWorld, DrawingLevel drawingLevel, DrawingTextAlignment drawingTextAlignment);
    public void DrawTextWithWorldCoordinate(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, double upperLeftXInWorld, double upperLeftYInWorld, DrawingLevel drawingLevel, DrawingTextAlignment drawingTextAlignment);
    public void DrawText(string text, GeoFont font, GeoBrush fillBrush, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingLevel drawingLevel);
    public void DrawText(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, DrawingTextAlignment drawingTextAlignment);
    public void DrawText(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, DrawingTextAlignment drawingTextAlignment, float rotateAngle);
    protected abstract virtual void DrawTextCore(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, DrawingTextAlignment drawingTextAlignment, float rotateAngle);
    public DrawingRectangleF MeasureText(string text, GeoFont font);
    protected abstract virtual DrawingRectangleF MeasureTextCore(string text, GeoFont font);
    public void BeginDrawing(object geoImage, RectangleShape worldExtent, GeographyUnit drawingMapUnit);
    protected abstract virtual void BeginDrawingCore(object nativeImage, RectangleShape worldExtent, GeographyUnit drawingMapUnit);
    public void EndDrawing();
    protected float GetCanvasWidth();
    protected abstract virtual float GetCanvasWidthCore();
    protected float GetCanvasHeight();
    protected abstract virtual float GetCanvasHeightCore();
    public static GeoCanvas CreateDefaultGeoCanvas();
    private void MBU=();
    private void MRU=(string waterMarkedString);
    private List`1<ScreenPointF[]> MhU=(Byte[] areaShapeWkb);
    private int MxU=(ScreenPointF[]& areaPoints, Byte[] wkb, int dataIndex, byte byteOrder);
    private int NBU=(Byte[] lineShapeWkb, int startIndex, float xOffset, float yOffset, DrawingLevel drawingLevel, GeoPen linePen);
    private void NRU=(Double& screenX, Double& screenY);
    private int NhU=(Byte[] centerPointWkb, int startIndex, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    protected abstract virtual void EndDrawingCore();
    public void Flush();
    protected abstract virtual void FlushCore();
    protected virtual void OnDrawingProgressChanged(DrawingProgressChangedEventArgs e);
    public double MeasureOffset(double offsetInPixel);
    protected virtual double MeasureOffsetCore(double offsetInPixel);
    private bool LRU=();
    internal RectangleShape NxU=(DrawingRectangleF drawingRectangle);
    private GeoPen OBU=(GeoPen pen);
    private static int ORU=(Byte[] wkb, int startIndex, byte byteOrder);
    private static double OhU=(Byte[] wkb, int startIndex, byte byteOrder);
    internal virtual float OxU=(GeoFont font, DrawingTextBaseline textBaseline, string text);
}
public class ThinkGeo.Core.GeocodingCloudClient : CloudClient {
    public GeocodingCloudClient(string clientId, string clientSecret);
    public CloudGeocodingResult Search(string location);
    public CloudGeocodingResult Search(string location, CloudGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/Qj4=")]
public Task`1<CloudGeocodingResult> SearchAsync(string location);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/RD4=")]
public Task`1<CloudGeocodingResult> SearchAsync(string location, CloudGeocodingOptions options);
    public Collection`1<CloudGeocodingResult> Search(IEnumerable`1<string> locations);
    public Collection`1<CloudGeocodingResult> Search(IEnumerable`1<string> locations, CloudGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/Rj4=")]
public Task`1<Collection`1<CloudGeocodingResult>> SearchAsync(IEnumerable`1<string> locations);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/SD4=")]
public Task`1<Collection`1<CloudGeocodingResult>> SearchAsync(IEnumerable`1<string> locations, CloudGeocodingOptions options);
    private CloudGeocodingResult 2RQ=(string location, CloudGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/ST4=")]
private Task`1<CloudGeocodingResult> 2hQ=(string location, CloudGeocodingOptions options);
    private Collection`1<CloudGeocodingResult> 2RQ=(IEnumerable`1<string> locations, CloudGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GeocodingCloudClient/Sj4=")]
private Task`1<Collection`1<CloudGeocodingResult>> 2hQ=(IEnumerable`1<string> locations, CloudGeocodingOptions options);
    private static string 2xQ=(CloudGeocodingOptions options);
    private static string 3BQ=(IEnumerable`1<string> locations, CloudGeocodingOptions options);
    private static CloudGeocodingResult 3RQ=(WebResponse response);
    private static Collection`1<CloudGeocodingResult> 3hQ=(WebResponse response);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.GeocodingLocationDto : object {
    [CompilerGeneratedAttribute]
private LocationPoint <LocationPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BoundingBox>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Geometry>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AddressComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HouseNumber>k__BackingField;
    public LocationPoint LocationPoint { get; public set; }
    public string Address { get; public set; }
    public string Name { get; public set; }
    public string LocationType { get; public set; }
    public string BoundingBox { get; public set; }
    public string Geometry { get; public set; }
    public Dictionary`2<string, string> Properties { get; public set; }
    public Dictionary`2<string, string> AddressComponents { get; public set; }
    public string HouseNumber { get; public set; }
    [CompilerGeneratedAttribute]
public LocationPoint get_LocationPoint();
    [CompilerGeneratedAttribute]
public void set_LocationPoint(LocationPoint value);
    [CompilerGeneratedAttribute]
public string get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_LocationType();
    [CompilerGeneratedAttribute]
public void set_LocationType(string value);
    [CompilerGeneratedAttribute]
public string get_BoundingBox();
    [CompilerGeneratedAttribute]
public void set_BoundingBox(string value);
    [CompilerGeneratedAttribute]
public string get_Geometry();
    [CompilerGeneratedAttribute]
public void set_Geometry(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AddressComponents();
    [CompilerGeneratedAttribute]
public void set_AddressComponents(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_HouseNumber();
    [CompilerGeneratedAttribute]
public void set_HouseNumber(string value);
    public CloudGeocodingLocation ToGeocodingLocation();
}
[DefaultMemberAttribute("Item")]
public class ThinkGeo.Core.GeoCollection`1 : Collection`1<T> {
    [ObfuscationAttribute]
private Dictionary`2<string, T> dictionary;
    [ObfuscationAttribute]
private Dictionary`2<int, string> mappingCache;
    [CompilerGeneratedAttribute]
private EventHandler`1<InsertingGeoCollectionEventArgs> pRU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<InsertedGeoCollectionEventArgs> phU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemovingGeoCollectionEventArgs> pxU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemovedGeoCollectionEventArgs> qBU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<AddingGeoCollectionEventArgs> qRU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<AddedGeoCollectionEventArgs> qhU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClearingItemsGeoCollectionEventArgs> qxU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClearedItemsGeoCollectionEventArgs> rBU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<MovedItemGeoCollectionEventArgs> rRU=;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler rhU=;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler rxU=;
    public T Item { get; public set; }
    [CompilerGeneratedAttribute]
public void add_Inserting(EventHandler`1<InsertingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Inserting(EventHandler`1<InsertingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Inserted(EventHandler`1<InsertedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Inserted(EventHandler`1<InsertedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Removing(EventHandler`1<RemovingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Removing(EventHandler`1<RemovingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Removed(EventHandler`1<RemovedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Removed(EventHandler`1<RemovedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Adding(EventHandler`1<AddingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Adding(EventHandler`1<AddingGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Added(EventHandler`1<AddedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Added(EventHandler`1<AddedGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClearingItems(EventHandler`1<ClearingItemsGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClearingItems(EventHandler`1<ClearingItemsGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClearedItems(EventHandler`1<ClearedItemsGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClearedItems(EventHandler`1<ClearedItemsGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_MovedItem(EventHandler`1<MovedItemGeoCollectionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_MovedItem(EventHandler`1<MovedItemGeoCollectionEventArgs> value);
    protected virtual void OnInserting(InsertingGeoCollectionEventArgs e);
    protected virtual void OnInserted(InsertedGeoCollectionEventArgs e);
    protected virtual void OnRemoving(RemovingGeoCollectionEventArgs e);
    protected virtual void OnRemoved(RemovedGeoCollectionEventArgs e);
    protected virtual void OnAdding(AddingGeoCollectionEventArgs e);
    protected virtual void OnAdded(AddedGeoCollectionEventArgs e);
    protected virtual void OnClearingItems(ClearingItemsGeoCollectionEventArgs e);
    protected virtual void OnClearedItems(ClearedItemsGeoCollectionEventArgs e);
    protected virtual void OnMovedItem(MovedItemGeoCollectionEventArgs e);
    public T get_Item(string key);
    public void set_Item(string key, T value);
    public Collection`1<string> GetKeys();
    public void Add(string key, T item);
    public void Add(T item);
    public void Insert(int index, T item);
    protected virtual void InsertItem(int index, T item);
    public void Insert(int index, string key, T item);
    public void Remove(string key);
    protected virtual void RemoveItem(int index);
    public void MoveUp(int index);
    public void MoveUp(string key);
    public void MoveUp(T item);
    public void MoveDown(int index);
    public void MoveDown(string key);
    public void MoveDown(T item);
    public void MoveToTop(int index);
    public void MoveToTop(string key);
    public void MoveToTop(T item);
    public void MoveToBottom(int index);
    public void MoveToBottom(string key);
    public void MoveToBottom(T item);
    public void MoveTo(int fromIndex, int toIndex);
    public void MoveTo(string key, int toIndex);
    public void MoveTo(T item, int toIndex);
    public bool Contains(string key);
    protected virtual void ClearItems();
    protected virtual void SetItem(int index, T item);
    private int sBU=(string key);
    private string sRU=(T item);
    private void shU=(string key);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    protected virtual void OnCollectionChanged(NotifyCollectionChangedEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    protected virtual void OnPropertyChanged(PropertyChangedEventArgs e);
}
[DebuggerDisplayAttribute("{NameAndARGBValue}")]
public class ThinkGeo.Core.GeoColor : object {
    private static float hBU=;
    private static float hRU=;
    private static float hhU=;
    private static float hxU=;
    [ObfuscationAttribute]
private byte alphaComponent;
    [ObfuscationAttribute]
private byte redComponent;
    [ObfuscationAttribute]
private byte greenComponent;
    [ObfuscationAttribute]
private byte blueComponent;
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private ColorType colorType;
    [ObfuscationAttribute]
private static Random random;
    private static Regex iBU=;
    private static Regex iRU=;
    private static Regex ihU=;
    private static Regex ixU=;
    public bool IsTransparent { get; }
    public string HtmlColor { get; public set; }
    public string Ahsl { get; public set; }
    public string Argb { get; public set; }
    public byte A { get; public set; }
    public byte R { get; public set; }
    public byte G { get; public set; }
    public byte B { get; public set; }
    public float Hue { get; }
    public float Saturation { get; }
    public float Luminance { get; }
    [ObfuscationAttribute]
private string NameAndARGBValue { get; }
    public GeoColor(byte red, byte green, byte blue);
    public GeoColor(byte alpha, byte red, byte green, byte blue);
    public GeoColor(byte alpha, GeoColor color);
    internal GeoColor(string name, ColorType colorType, byte alpha, byte red, byte green, byte blue);
    private static GeoColor();
    public bool get_IsTransparent();
    public string get_HtmlColor();
    public void set_HtmlColor(string value);
    public string get_Ahsl();
    public void set_Ahsl(string value);
    public string get_Argb();
    public void set_Argb(string value);
    public byte get_A();
    public void set_A(byte value);
    public byte get_R();
    public void set_R(byte value);
    public byte get_G();
    public void set_G(byte value);
    public byte get_B();
    public void set_B(byte value);
    public float get_Hue();
    public float get_Saturation();
    public float get_Luminance();
    private string get_NameAndARGBValue();
    public static Collection`1<GeoColor> GetColorsInHueFamily(GeoColor baseColor, int numbersOfColors);
    private static float jBU=(float saturation, float ratio);
    private static float jRU=(float luminance, float ratio);
    public static Collection`1<GeoColor> GetColorsInQualityFamily(GeoColor baseColor, int numberOfColors);
    public static Collection`1<GeoColor> GetColorsInQualityFamily(GeoColor fromColor, GeoColor toColor, int numberOfColors, ColorWheelDirection colorWheelDirection);
    private static float jhU=(float hue, float ratio);
    public static GeoColor FromArgb(byte alpha, byte red, byte green, byte blue);
    public static GeoColor FromArgb(byte alpha, GeoColor baseColor);
    public static GeoColor FromAhsl(int alpha, float hue, float saturation, float luminance);
    public static GeoColor FromOle(int oleColor);
    public static GeoColor FromHtml(string htmlColor);
    internal static GeoColor jxU=(string colorExpression);
    private static string kBU=(string htmlColor);
    private static GeoColor kRU=(string htmlColor);
    public static GeoColor GetRandomGeoColor(RandomColorType colorType);
    public static GeoColor GetRandomGeoColor(byte alpha, RandomColorType colorType);
    public static GeoColor FromWin32(int win32Color);
    public static int ToOle(GeoColor color);
    public static string ToHtml(GeoColor color);
    public static int ToWin32(GeoColor color);
    public virtual string ToString();
    public static bool op_Equality(GeoColor geoColor1, GeoColor geoColor2);
    public static bool op_Inequality(GeoColor geoColor1, GeoColor geoColor2);
    public virtual bool Equals(object obj);
    private bool khU=(GeoColor compareObj);
    public virtual int GetHashCode();
    private static GeoColor kxU=(float hueIn0To360Format, float saturation, float luminance);
    private static byte lBU=(double v1, double v2, double vH);
    private static void lRU=(GeoColor geoColor, Single& hue, Single& saturation, Single& luminance);
    [CompilerGeneratedAttribute]
internal static Double[] lhU=(GroupCollection groups);
}
public static class ThinkGeo.Core.GeoColors : object {
    public static GeoColor Sand { get; }
    public static GeoColor Grass { get; }
    public static GeoColor Dirt { get; }
    public static GeoColor Mountains { get; }
    public static GeoColor Lake { get; }
    public static GeoColor DeepOcean { get; }
    public static GeoColor ShallowOcean { get; }
    public static GeoColor Tundra { get; }
    public static GeoColor Forest { get; }
    public static GeoColor Ice { get; }
    public static GeoColor Swamp { get; }
    public static GeoColor Road { get; }
    public static GeoColor Highway { get; }
    public static GeoColor InnerState { get; }
    public static GeoColor LocalRoad { get; }
    public static GeoColor MajorRoad { get; }
    public static GeoColor ActiveBorder { get; }
    public static GeoColor ActiveCaption { get; }
    public static GeoColor ActiveCaptionText { get; }
    public static GeoColor AppWorkspace { get; }
    public static GeoColor Control { get; }
    public static GeoColor ControlDark { get; }
    public static GeoColor ControlDarkDark { get; }
    public static GeoColor ControlLight { get; }
    public static GeoColor ControlLightLight { get; }
    public static GeoColor ControlText { get; }
    public static GeoColor Desktop { get; }
    public static GeoColor GrayText { get; }
    public static GeoColor Highlight { get; }
    public static GeoColor HighlightText { get; }
    public static GeoColor HotTrack { get; }
    public static GeoColor InactiveBorder { get; }
    public static GeoColor InactiveCaption { get; }
    public static GeoColor InactiveCaptionText { get; }
    public static GeoColor Info { get; }
    public static GeoColor InfoText { get; }
    public static GeoColor Menu { get; }
    public static GeoColor MenuText { get; }
    public static GeoColor ScrollBar { get; }
    public static GeoColor Window { get; }
    public static GeoColor WindowFrame { get; }
    public static GeoColor WindowText { get; }
    public static GeoColor Transparent { get; }
    public static GeoColor AliceBlue { get; }
    public static GeoColor AntiqueWhite { get; }
    public static GeoColor Aqua { get; }
    public static GeoColor Aquamarine { get; }
    public static GeoColor Azure { get; }
    public static GeoColor Beige { get; }
    public static GeoColor Bisque { get; }
    public static GeoColor Black { get; }
    public static GeoColor BlanchedAlmond { get; }
    public static GeoColor Blue { get; }
    public static GeoColor BlueViolet { get; }
    public static GeoColor Brown { get; }
    public static GeoColor BurlyWood { get; }
    public static GeoColor CadetBlue { get; }
    public static GeoColor Chartreuse { get; }
    public static GeoColor Chocolate { get; }
    public static GeoColor Coral { get; }
    public static GeoColor CornflowerBlue { get; }
    public static GeoColor Cornsilk { get; }
    public static GeoColor Crimson { get; }
    public static GeoColor Cyan { get; }
    public static GeoColor DarkBlue { get; }
    public static GeoColor DarkCyan { get; }
    public static GeoColor DarkGoldenrod { get; }
    public static GeoColor DarkGray { get; }
    public static GeoColor DarkGreen { get; }
    public static GeoColor DarkKhaki { get; }
    public static GeoColor DarkMagenta { get; }
    public static GeoColor DarkOliveGreen { get; }
    public static GeoColor DarkOrange { get; }
    public static GeoColor DarkOrchid { get; }
    public static GeoColor DarkRed { get; }
    public static GeoColor DarkSalmon { get; }
    public static GeoColor DarkSeaGreen { get; }
    public static GeoColor DarkSlateBlue { get; }
    public static GeoColor DarkSlateGray { get; }
    public static GeoColor DarkTurquoise { get; }
    public static GeoColor DarkViolet { get; }
    public static GeoColor DeepPink { get; }
    public static GeoColor DeepSkyBlue { get; }
    public static GeoColor DimGray { get; }
    public static GeoColor DodgerBlue { get; }
    public static GeoColor Firebrick { get; }
    public static GeoColor FloralWhite { get; }
    public static GeoColor ForestGreen { get; }
    public static GeoColor Fuchsia { get; }
    public static GeoColor Gainsboro { get; }
    public static GeoColor GhostWhite { get; }
    public static GeoColor Gold { get; }
    public static GeoColor Goldenrod { get; }
    public static GeoColor Gray { get; }
    public static GeoColor Green { get; }
    public static GeoColor GreenYellow { get; }
    public static GeoColor Honeydew { get; }
    public static GeoColor HotPink { get; }
    public static GeoColor IndianRed { get; }
    public static GeoColor Indigo { get; }
    public static GeoColor Ivory { get; }
    public static GeoColor Khaki { get; }
    public static GeoColor Lavender { get; }
    public static GeoColor LavenderBlush { get; }
    public static GeoColor LawnGreen { get; }
    public static GeoColor LemonChiffon { get; }
    public static GeoColor LightBlue { get; }
    public static GeoColor LightCoral { get; }
    public static GeoColor LightCyan { get; }
    public static GeoColor LightGoldenrodYellow { get; }
    public static GeoColor LightGray { get; }
    public static GeoColor LightGreen { get; }
    public static GeoColor LightPink { get; }
    public static GeoColor LightSalmon { get; }
    public static GeoColor LightSeaGreen { get; }
    public static GeoColor LightSkyBlue { get; }
    public static GeoColor LightSlateGray { get; }
    public static GeoColor LightSteelBlue { get; }
    public static GeoColor LightYellow { get; }
    public static GeoColor Lime { get; }
    public static GeoColor LimeGreen { get; }
    public static GeoColor Linen { get; }
    public static GeoColor Magenta { get; }
    public static GeoColor Maroon { get; }
    public static GeoColor MediumAquamarine { get; }
    public static GeoColor MediumBlue { get; }
    public static GeoColor MediumOrchid { get; }
    public static GeoColor MediumPurple { get; }
    public static GeoColor MediumSeaGreen { get; }
    public static GeoColor MediumSlateBlue { get; }
    public static GeoColor MediumSpringGreen { get; }
    public static GeoColor MediumTurquoise { get; }
    public static GeoColor MediumVioletRed { get; }
    public static GeoColor MidnightBlue { get; }
    public static GeoColor MintCream { get; }
    public static GeoColor MistyRose { get; }
    public static GeoColor Moccasin { get; }
    public static GeoColor NavajoWhite { get; }
    public static GeoColor Navy { get; }
    public static GeoColor OldLace { get; }
    public static GeoColor Olive { get; }
    public static GeoColor OliveDrab { get; }
    public static GeoColor Orange { get; }
    public static GeoColor OrangeRed { get; }
    public static GeoColor Orchid { get; }
    public static GeoColor PaleGoldenrod { get; }
    public static GeoColor PaleGreen { get; }
    public static GeoColor PaleTurquoise { get; }
    public static GeoColor PaleVioletRed { get; }
    public static GeoColor PapayaWhip { get; }
    public static GeoColor PeachPuff { get; }
    public static GeoColor Peru { get; }
    public static GeoColor Pink { get; }
    public static GeoColor Plum { get; }
    public static GeoColor PowderBlue { get; }
    public static GeoColor Purple { get; }
    public static GeoColor Red { get; }
    public static GeoColor RosyBrown { get; }
    public static GeoColor RoyalBlue { get; }
    public static GeoColor SaddleBrown { get; }
    public static GeoColor Salmon { get; }
    public static GeoColor SandyBrown { get; }
    public static GeoColor SeaGreen { get; }
    public static GeoColor SeaShell { get; }
    public static GeoColor Sienna { get; }
    public static GeoColor Silver { get; }
    public static GeoColor SkyBlue { get; }
    public static GeoColor SlateBlue { get; }
    public static GeoColor SlateGray { get; }
    public static GeoColor Snow { get; }
    public static GeoColor SpringGreen { get; }
    public static GeoColor SteelBlue { get; }
    public static GeoColor Tan { get; }
    public static GeoColor Teal { get; }
    public static GeoColor Thistle { get; }
    public static GeoColor Tomato { get; }
    public static GeoColor Turquoise { get; }
    public static GeoColor Violet { get; }
    public static GeoColor Wheat { get; }
    public static GeoColor White { get; }
    public static GeoColor WhiteSmoke { get; }
    public static GeoColor Yellow { get; }
    public static GeoColor YellowGreen { get; }
    public static GeoColor ButtonFace { get; }
    public static GeoColor ButtonHighlight { get; }
    public static GeoColor ButtonShadow { get; }
    public static GeoColor GradientActiveCaption { get; }
    public static GeoColor GradientInactiveCaption { get; }
    public static GeoColor MenuBar { get; }
    public static GeoColor MenuHighlight { get; }
    public static GeoColor DarkYellow { get; }
    public static GeoColor LightRed { get; }
    public static GeoColor LightOrange { get; }
    public static GeoColor PaleRed { get; }
    public static GeoColor PaleBlue { get; }
    public static GeoColor PaleYellow { get; }
    public static GeoColor PaleOrange { get; }
    public static GeoColor BrightRed { get; }
    public static GeoColor BrightBlue { get; }
    public static GeoColor BrightYellow { get; }
    public static GeoColor BrightGreen { get; }
    public static GeoColor BrightOrange { get; }
    public static GeoColor PastelRed { get; }
    public static GeoColor PastelBlue { get; }
    public static GeoColor PastelYellow { get; }
    public static GeoColor PastelGreen { get; }
    public static GeoColor PastelOrange { get; }
    public static GeoColor Copper { get; }
    public static GeoColor get_Sand();
    public static GeoColor get_Grass();
    public static GeoColor get_Dirt();
    public static GeoColor get_Mountains();
    public static GeoColor get_Lake();
    public static GeoColor get_DeepOcean();
    public static GeoColor get_ShallowOcean();
    public static GeoColor get_Tundra();
    public static GeoColor get_Forest();
    public static GeoColor get_Ice();
    public static GeoColor get_Swamp();
    public static GeoColor get_Road();
    public static GeoColor get_Highway();
    public static GeoColor get_InnerState();
    public static GeoColor get_LocalRoad();
    public static GeoColor get_MajorRoad();
    public static GeoColor get_ActiveBorder();
    public static GeoColor get_ActiveCaption();
    public static GeoColor get_ActiveCaptionText();
    public static GeoColor get_AppWorkspace();
    public static GeoColor get_Control();
    public static GeoColor get_ControlDark();
    public static GeoColor get_ControlDarkDark();
    public static GeoColor get_ControlLight();
    public static GeoColor get_ControlLightLight();
    public static GeoColor get_ControlText();
    public static GeoColor get_Desktop();
    public static GeoColor get_GrayText();
    public static GeoColor get_Highlight();
    public static GeoColor get_HighlightText();
    public static GeoColor get_HotTrack();
    public static GeoColor get_InactiveBorder();
    public static GeoColor get_InactiveCaption();
    public static GeoColor get_InactiveCaptionText();
    public static GeoColor get_Info();
    public static GeoColor get_InfoText();
    public static GeoColor get_Menu();
    public static GeoColor get_MenuText();
    public static GeoColor get_ScrollBar();
    public static GeoColor get_Window();
    public static GeoColor get_WindowFrame();
    public static GeoColor get_WindowText();
    public static GeoColor get_Transparent();
    public static GeoColor get_AliceBlue();
    public static GeoColor get_AntiqueWhite();
    public static GeoColor get_Aqua();
    public static GeoColor get_Aquamarine();
    public static GeoColor get_Azure();
    public static GeoColor get_Beige();
    public static GeoColor get_Bisque();
    public static GeoColor get_Black();
    public static GeoColor get_BlanchedAlmond();
    public static GeoColor get_Blue();
    public static GeoColor get_BlueViolet();
    public static GeoColor get_Brown();
    public static GeoColor get_BurlyWood();
    public static GeoColor get_CadetBlue();
    public static GeoColor get_Chartreuse();
    public static GeoColor get_Chocolate();
    public static GeoColor get_Coral();
    public static GeoColor get_CornflowerBlue();
    public static GeoColor get_Cornsilk();
    public static GeoColor get_Crimson();
    public static GeoColor get_Cyan();
    public static GeoColor get_DarkBlue();
    public static GeoColor get_DarkCyan();
    public static GeoColor get_DarkGoldenrod();
    public static GeoColor get_DarkGray();
    public static GeoColor get_DarkGreen();
    public static GeoColor get_DarkKhaki();
    public static GeoColor get_DarkMagenta();
    public static GeoColor get_DarkOliveGreen();
    public static GeoColor get_DarkOrange();
    public static GeoColor get_DarkOrchid();
    public static GeoColor get_DarkRed();
    public static GeoColor get_DarkSalmon();
    public static GeoColor get_DarkSeaGreen();
    public static GeoColor get_DarkSlateBlue();
    public static GeoColor get_DarkSlateGray();
    public static GeoColor get_DarkTurquoise();
    public static GeoColor get_DarkViolet();
    public static GeoColor get_DeepPink();
    public static GeoColor get_DeepSkyBlue();
    public static GeoColor get_DimGray();
    public static GeoColor get_DodgerBlue();
    public static GeoColor get_Firebrick();
    public static GeoColor get_FloralWhite();
    public static GeoColor get_ForestGreen();
    public static GeoColor get_Fuchsia();
    public static GeoColor get_Gainsboro();
    public static GeoColor get_GhostWhite();
    public static GeoColor get_Gold();
    public static GeoColor get_Goldenrod();
    public static GeoColor get_Gray();
    public static GeoColor get_Green();
    public static GeoColor get_GreenYellow();
    public static GeoColor get_Honeydew();
    public static GeoColor get_HotPink();
    public static GeoColor get_IndianRed();
    public static GeoColor get_Indigo();
    public static GeoColor get_Ivory();
    public static GeoColor get_Khaki();
    public static GeoColor get_Lavender();
    public static GeoColor get_LavenderBlush();
    public static GeoColor get_LawnGreen();
    public static GeoColor get_LemonChiffon();
    public static GeoColor get_LightBlue();
    public static GeoColor get_LightCoral();
    public static GeoColor get_LightCyan();
    public static GeoColor get_LightGoldenrodYellow();
    public static GeoColor get_LightGray();
    public static GeoColor get_LightGreen();
    public static GeoColor get_LightPink();
    public static GeoColor get_LightSalmon();
    public static GeoColor get_LightSeaGreen();
    public static GeoColor get_LightSkyBlue();
    public static GeoColor get_LightSlateGray();
    public static GeoColor get_LightSteelBlue();
    public static GeoColor get_LightYellow();
    public static GeoColor get_Lime();
    public static GeoColor get_LimeGreen();
    public static GeoColor get_Linen();
    public static GeoColor get_Magenta();
    public static GeoColor get_Maroon();
    public static GeoColor get_MediumAquamarine();
    public static GeoColor get_MediumBlue();
    public static GeoColor get_MediumOrchid();
    public static GeoColor get_MediumPurple();
    public static GeoColor get_MediumSeaGreen();
    public static GeoColor get_MediumSlateBlue();
    public static GeoColor get_MediumSpringGreen();
    public static GeoColor get_MediumTurquoise();
    public static GeoColor get_MediumVioletRed();
    public static GeoColor get_MidnightBlue();
    public static GeoColor get_MintCream();
    public static GeoColor get_MistyRose();
    public static GeoColor get_Moccasin();
    public static GeoColor get_NavajoWhite();
    public static GeoColor get_Navy();
    public static GeoColor get_OldLace();
    public static GeoColor get_Olive();
    public static GeoColor get_OliveDrab();
    public static GeoColor get_Orange();
    public static GeoColor get_OrangeRed();
    public static GeoColor get_Orchid();
    public static GeoColor get_PaleGoldenrod();
    public static GeoColor get_PaleGreen();
    public static GeoColor get_PaleTurquoise();
    public static GeoColor get_PaleVioletRed();
    public static GeoColor get_PapayaWhip();
    public static GeoColor get_PeachPuff();
    public static GeoColor get_Peru();
    public static GeoColor get_Pink();
    public static GeoColor get_Plum();
    public static GeoColor get_PowderBlue();
    public static GeoColor get_Purple();
    public static GeoColor get_Red();
    public static GeoColor get_RosyBrown();
    public static GeoColor get_RoyalBlue();
    public static GeoColor get_SaddleBrown();
    public static GeoColor get_Salmon();
    public static GeoColor get_SandyBrown();
    public static GeoColor get_SeaGreen();
    public static GeoColor get_SeaShell();
    public static GeoColor get_Sienna();
    public static GeoColor get_Silver();
    public static GeoColor get_SkyBlue();
    public static GeoColor get_SlateBlue();
    public static GeoColor get_SlateGray();
    public static GeoColor get_Snow();
    public static GeoColor get_SpringGreen();
    public static GeoColor get_SteelBlue();
    public static GeoColor get_Tan();
    public static GeoColor get_Teal();
    public static GeoColor get_Thistle();
    public static GeoColor get_Tomato();
    public static GeoColor get_Turquoise();
    public static GeoColor get_Violet();
    public static GeoColor get_Wheat();
    public static GeoColor get_White();
    public static GeoColor get_WhiteSmoke();
    public static GeoColor get_Yellow();
    public static GeoColor get_YellowGreen();
    public static GeoColor get_ButtonFace();
    public static GeoColor get_ButtonHighlight();
    public static GeoColor get_ButtonShadow();
    public static GeoColor get_GradientActiveCaption();
    public static GeoColor get_GradientInactiveCaption();
    public static GeoColor get_MenuBar();
    public static GeoColor get_MenuHighlight();
    public static GeoColor get_DarkYellow();
    public static GeoColor get_LightRed();
    public static GeoColor get_LightOrange();
    public static GeoColor get_PaleRed();
    public static GeoColor get_PaleBlue();
    public static GeoColor get_PaleYellow();
    public static GeoColor get_PaleOrange();
    public static GeoColor get_BrightRed();
    public static GeoColor get_BrightBlue();
    public static GeoColor get_BrightYellow();
    public static GeoColor get_BrightGreen();
    public static GeoColor get_BrightOrange();
    public static GeoColor get_PastelRed();
    public static GeoColor get_PastelBlue();
    public static GeoColor get_PastelYellow();
    public static GeoColor get_PastelGreen();
    public static GeoColor get_PastelOrange();
    public static GeoColor get_Copper();
}
public enum ThinkGeo.Core.GeoColorType : Enum {
    public int value__;
    public static GeoColorType Unknown;
    public static GeoColorType Alpha8;
    public static GeoColorType Rgb565;
    public static GeoColorType Argb4444;
    public static GeoColorType Rgba8888;
    public static GeoColorType Rgb888x;
    public static GeoColorType Bgra8888;
    public static GeoColorType Rgba1010102;
    public static GeoColorType Rgb101010x;
    public static GeoColorType Gray8;
    public static GeoColorType RgbaF16;
}
public enum ThinkGeo.Core.GeoDashCap : Enum {
    public int value__;
    public static GeoDashCap Flat;
    public static GeoDashCap Round;
    public static GeoDashCap Triangle;
    public static GeoDashCap Square;
}
public class ThinkGeo.Core.GeoDbf : object {
    private static string wB4=;
    private static string wR4=;
    private static Dictionary`2<string, string> wh4=;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    [ObfuscationAttribute]
private Dictionary`2<string, int> fieldNameCache;
    [ObfuscationAttribute]
private List`1<string> VFPSupportColumnNames;
    private static int wx4=;
    private static int xB4=;
    private static int xR4=;
    private static int xh4=;
    private static byte xx4=;
    private static byte yB4=;
    private static byte yR4=;
    private static byte yh4=;
    private static byte yx4=;
    private static byte zB4=;
    private static byte zR4=;
    private static byte zh4=;
    private static byte zx4=;
    private static byte 0B4=;
    private static byte 0R4=;
    private static byte 0h4=;
    private static byte 0x4=;
    private static byte 1B4=;
    private static byte 1R4=;
    private static byte 1h4=;
    private static byte 1x4=;
    private static byte 2B4=;
    private static byte 2R4=;
    private static byte 2h4=;
    private static byte 2x4=;
    private static int 3B4=;
    private static int 3R4=;
    private static int 3h4=;
    private static int 3x4=;
    private static int 4B4=;
    private static string 4R4=;
    private static string 4h4=;
    private static string 4x4=;
    private static string 5B4=;
    private static string 5R4=;
    private static string 5h4=;
    private static string 5x4=;
    private static string 6B4=;
    private static string 6R4=;
    private static string 6h4=;
    private static string 6x4=;
    private static string 7B4=;
    private static string 7R4=;
    private static string 7h4=;
    private static string 7x4=;
    private static string 8B4=;
    private static string 8R4=;
    private static string 8h4=;
    private static string 8x4=;
    private static string 9B4=;
    private static string 9R4=;
    private static string 9h4=;
    private static string 9x4=;
    private static string /B4=;
    private static string /R4=;
    private static string /h4=;
    private static string /x4=;
    private static string AB8=;
    private static string AR8=;
    private static string Ah8=;
    private static string Ax8=;
    private static string BB8=;
    private static string BR8=;
    private static string Bh8=;
    private static string Bx8=;
    private static string CB8=;
    private static string CR8=;
    private static string Ch8=;
    private static string Cx8=;
    private static string DB8=;
    private static string DR8=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Dh8=;
    [ObfuscationAttribute]
private bool needDBC;
    [ObfuscationAttribute]
private bool isOpenMemoFile;
    [ObfuscationAttribute]
private bool isUsingFPTMemoFile;
    [ObfuscationAttribute]
private string pathFilename;
    [ObfuscationAttribute]
private string dbtFileName;
    private Stream Dx8=;
    private Stream EB8=;
    [ObfuscationAttribute]
private int recordCount;
    [ObfuscationAttribute]
private int recordLength;
    [ObfuscationAttribute]
private int headerLength;
    [ObfuscationAttribute]
private int columnCount;
    [ObfuscationAttribute]
private bool isClosed;
    [ObfuscationAttribute]
private ArrayList fieldsHeader;
    [ObfuscationAttribute]
private Byte[] headerBytes;
    [ObfuscationAttribute]
private bool isCurrentRecordModified;
    [ObfuscationAttribute]
private int currentRecord;
    [ObfuscationAttribute]
private Byte[] currentRecords;
    [ObfuscationAttribute]
private ArrayList deletedItems;
    [ObfuscationAttribute]
private ArrayList originalIndexes;
    [ObfuscationAttribute]
private ArrayList newIndexes;
    [ObfuscationAttribute]
private string password;
    [ObfuscationAttribute]
private bool isFileDetached;
    [ObfuscationAttribute]
private bool haveMemoField;
    [ObfuscationAttribute]
private bool isUpdated;
    [ObfuscationAttribute]
private bool isFieldUpdated;
    [ObfuscationAttribute]
private bool isCreating;
    private Encoding ER8=;
    [ObfuscationAttribute]
private CultureInfo cultureInfo;
    [ObfuscationAttribute]
private int startPosition;
    public bool IsOpen { get; }
    public int ColumnCount { get; }
    public int RecordCount { get; }
    public string PathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public Encoding Encoding { get; public set; }
    public CultureInfo CultureInfo { get; public set; }
    public GeoDbf(string pathFilename);
    public GeoDbf(string pathFilename, FileAccess readWriteMode);
    public GeoDbf(string pathFilename, FileAccess readWriteMode, Encoding encoding);
    public GeoDbf(string pathFilename, FileAccess readWriteMode, Encoding encoding, CultureInfo cultureInfo);
    private static GeoDbf();
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    public bool get_IsOpen();
    public int get_ColumnCount();
    public int get_RecordCount();
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public CultureInfo get_CultureInfo();
    public void set_CultureInfo(CultureInfo value);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    public static void CopyDbfHeader(string sourcePathFilename, string destinationPathFilename);
    public static void CopyDbfHeader(string sourcePathFilename, string destinationPathFilename, OverwriteMode overwriteMode);
    public static void CreateDbfFile(string dbfPathFilename, IEnumerable`1<DbfColumn> dbfColumns);
    public static void CreateDbfFile(string dbfPathFilename, IEnumerable`1<DbfColumn> dbfColumns, OverwriteMode overwriteMode);
    public static void CreateDbfFile(string dbfPathFilename, IEnumerable`1<DbfColumn> dbfColumns, OverwriteMode overwriteMode, Encoding encoding);
    public DbfColumn GetColumn(string columnName);
    public DbfColumn GetColumn(int columnNumber);
    public Dictionary`2<string, object> ReadRecord(int recordNumber);
    public bool ReadFieldAsBoolean(int recordNumber, int columnNumber);
    public bool ReadFieldAsBoolean(int recordNumber, string columnName);
    private Nullable`1<bool> Eh8=(int recordNumber, int columnNumber);
    private Nullable`1<bool> Eh8=(int recordNumber, string columnName);
    private Nullable`1<DateTime> Ex8=(int recordNumber, string columnName);
    public DateTime ReadFieldAsDateTime(int recordNumber, string columnName);
    public DateTime ReadFieldAsDateTime(int recordNumber, int columnNumber);
    public double ReadFieldAsDouble(int recordNumber, string columnName);
    public double ReadFieldAsDouble(int recordNumber, int columnNumber);
    public int ReadFieldAsInteger(int recordNumber, int columnNumber);
    public int ReadFieldAsInteger(int recordNumber, string columnName);
    public string ReadFieldAsString(int recordNumber, string columnName);
    public string ReadFieldAsString(int recordNumber, int columnNumber);
    public void WriteField(int recordNumber, string columnName, double value);
    public void WriteField(int recordNumber, int columnNumber, int value);
    public void WriteField(int recordNumber, string columnName, bool value);
    public void WriteField(int recordNumber, int columnNumber, double value);
    public void WriteField(int recordNumber, string columnName, int value);
    public void WriteField(int recordNumber, int columnNumber, string value);
    public void WriteField(int recordNumber, string columnName, string value);
    public void WriteField(int recordNumber, int columnNumber, bool value);
    public void WriteField(int recordNumber, int columnNumber, DateTime value);
    public void WriteField(int recordNumber, string columnName, DateTime value);
    public void Open();
    public void Close();
    public void Flush();
    public void Pack();
    public int GetColumnNumber(string columnName);
    public string GetColumnName(int columnNumber);
    public void DeleteRecord(int recordNumber);
    public void UpdateColumnName(int columnNumber, string newColumnName);
    public void UndeleteRecord(int recordNumber);
    public bool IsRecordDeleted(int recordNumber);
    public void AddEmptyRecord();
    public Dictionary`2<string, string> ReadRecordAsString(int recordNumber);
    public void WriteRecord(int recordNumber, IEnumerable`1<object> values);
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns);
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns, Encoding encoding);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames, Encoding encoding);
    private static string FB8=(string baseString, int repeatNumber, Encoding encoding);
    private void FR8=(FileMode fileMode, FileAccess readWriteMode);
    public void AddStringColumn(string columnName, int length);
    public void AddIntegerColumn(string columnName, int length);
    public void AddDoubleColumn(string columnName, int length, int decimalLength);
    public void AddBooleanColumn(string columnName);
    public void AddMemoColumn(string columnName, int length);
    public void AddDateColumn(string columnName);
    internal void Fh8=(string columnName);
    public void UpdateDbcFilename(string newDbcFilename);
    public void AddColumn(string columnName, DbfColumnType columnType, int length, int decimalLength);
    private static string Fx8=(string columnName, int length);
    private bool GB8=(string columnName);
    private Collection`1<DbfColumn> GR8=();
    private DbfColumnType Gh8=(string fieldName);
    private DbfColumnType Gh8=(int fieldIndex);
    private int Gx8=(string fieldName);
    private int Gx8=(int fieldIndex);
    private int HB8=(string fieldName);
    private int HB8=(int fieldIndex);
    private string HR8=(int recordIndex, int fieldIndex);
    private static string Hh8=(Byte[] result, DbfColumnType type);
    private static string Hx8=(Byte[] result);
    private static string IB8=(Byte[] result);
    private static Byte[] IR8=(string datetime);
    private static string Ih8=(Byte[] result);
    private string HR8=(int recordIndex, string fieldName);
    private void Ix8=(int recordIndex, int fieldIndex, object value);
    private void Ix8=(int recordIndex, string fieldName, object value);
    private GeoDbf JB8=(string newPathFilename);
    private void JR8=(string fileName, FileAccess access);
    private static string Jh8=(string currentFileName);
    private static Encoding Jx8=(string ldid);
    private Stream KB8=(string fileName, FileMode fileMode, FileAccess readWriteMode);
    private Stream KR8=(string fileName, FileMode fileMode, FileAccess readWriteMode);
    private void Kh8=(string fileName, FileMode mode, FileAccess access, string strPassWord);
    private void Kx8=(string fileName, FileAccess access);
    private void LB8=();
    private void LR8=(Byte[] arrFileHeader, GeoDbf dbfFile);
    private void Lh8=(Byte[] arrHeader, GeoDbf dbfFile);
    private void Lx8=(string dbcFilePath, String[] columnNames);
    private string MB8=(int iRecord, int iField);
    private string MR8=(Byte[] bytesIn);
    private string MR8=(Byte[] bytesIn, int nIndex, int length);
    private Byte[] Mh8=(int iRecord, int iField);
    private Byte[] Mx8=(int iRecord, int iField);
    private Byte[] NB8=(int iRecord);
    private Byte[] NR8=(int iRecord);
    private string Nh8=(int iBlock);
    private string Nx8=(int iBlock);
    private void OB8=();
    private static void OR8=(Byte[]& arrUpdateBytes, int nOffset, int nWrittenBytes, int nSize, byte byteBlank);
    private void Oh8=(object value, int nOriginalBlock);
    private string Ox8=(int recordNumber, int fieldIndex);
    private void PB8=(int iField, object objValue);
    private void PR8=(object Value, int nOriginalBlock);
    private void Ph8=(int iRecord);
    private void Px8=(bool bHaveMemoField);
    private void QB8=();
    private void QR8=();
    private static string Qh8=(string dbf);
    private static void Qx8=(string strSrcDBF, string strDestDBF);
    private static string RB8=();
    private int RR8=(string FieldName, DbfColumnType type, int nWidth, int nDecimals);
    private int Rh8=(string FieldName, DbfColumnType type, int nWidth, int nDecimals);
    private void Rx8=(ArrayList DeletedArray);
    private void SB8=(ArrayList DeletedArray, ArrayList MemoFields);
    private void SR8=(Stream& fsDest, ArrayList DeletedArray);
    private void Sh8=(Stream& fsDest, ArrayList DeletedBlocks);
    private void Sx8=(ArrayList memoFields);
    private void TB8=(Stream fsSrc, int iStart, int iEnd, Stream& fsDest, int iWriteTo);
    private static void TR8=(Stream fsSrc, int iStart, int iEnd, Stream& fsDest, int iWriteTo);
    private static void Th8=(Stream fsDBT, int nDeletedBlocks);
    private int Tx8=(int OriginalValue);
    private static void UB8=(ArrayList& arrOriginal, ArrayList& arrNew, int iOriginalStart, int iOriginalEnd, int iNewStart);
    private ArrayList UR8=(ArrayList DeletedArray, ArrayList MemoFields);
    private ArrayList Uh8=();
    private void Ux8=();
    private static int VB8=(int iStart, int iEnd);
    private int VR8=(Stream fsDBT, int iBlock);
    private Byte[] Vh8=();
    private bool Vx8=(ArrayList Fields);
    private void WB8=(byte Flag);
    private void WR8=(string ErrorMsg);
    private DbfColumnInfo Wh8=(DbfColumnType type, int nWidth, int nDecimals);
    private Byte[] Wx8=(string FieldName, DbfColumnInfo Field);
    private string XB8=(int iField, DbfColumnType type, object objValue);
    private static string XR8=(object objValue, int nDecimalSize, DbfColumnType dbfColumnType, CultureInfo cultureInfo);
    private string Xh8=(string FieldName, DbfColumnType type, int nWidth, int nDecimals);
    private static int Xx8=(string strNum, CultureInfo cultureInfo);
    private static string YB8=(string strNum);
    private static void YR8=(Byte[]& bytes, int iStart, int intValue);
    private static int Yh8=(Byte[] bytes, int iStart);
    private static void Yx8=(Byte[]& FileHeader);
    private void ZB8=(GeoDbf dbfFile, Stream& fsDest);
    private static void ZR8=(Stream dbtFile, Stream& fsDest);
    private static string Zh8=(string value);
    private void 0x0=(bool disposing);
}
public class ThinkGeo.Core.GeoFont : object {
    [ObfuscationAttribute]
private float size;
    [ObfuscationAttribute]
private string fontName;
    [ObfuscationAttribute]
private string fontNameLowercase;
    [ObfuscationAttribute]
private bool isBold;
    [ObfuscationAttribute]
private bool isStrikeout;
    [ObfuscationAttribute]
private bool isItalic;
    [ObfuscationAttribute]
private bool isUnderline;
    [ObfuscationAttribute]
private long id;
    [ObfuscationAttribute]
private static long geoFontIdCounter;
    [ObfuscationAttribute]
private DrawingGraphicsUnit unit;
    [ObfuscationAttribute]
private DrawingFontStyles style;
    [ObfuscationAttribute]
private bool isDefault;
    [ObfuscationAttribute]
internal static Dictionary`2<Regex, string> SpecificFontNames;
    public bool IsBold { get; public set; }
    public bool IsStrikeout { get; public set; }
    public bool IsItalic { get; public set; }
    public bool IsUnderline { get; public set; }
    public string FontName { get; public set; }
    public float Size { get; public set; }
    public DrawingFontStyles Style { get; public set; }
    public long Id { get; }
    public DrawingGraphicsUnit Unit { get; public set; }
    internal bool ohU= { get; internal set; }
    public GeoFont(string fontName, float size);
    public GeoFont(string fontName, float size, DrawingFontStyles style);
    public GeoFont(string fontName, float size, DrawingFontStyles style, DrawingGraphicsUnit unit);
    private static GeoFont();
    public bool get_IsBold();
    public void set_IsBold(bool value);
    public bool get_IsStrikeout();
    public void set_IsStrikeout(bool value);
    public bool get_IsItalic();
    public void set_IsItalic(bool value);
    public bool get_IsUnderline();
    public void set_IsUnderline(bool value);
    public string get_FontName();
    public void set_FontName(string value);
    public float get_Size();
    public void set_Size(float value);
    public DrawingFontStyles get_Style();
    public void set_Style(DrawingFontStyles value);
    public long get_Id();
    public DrawingGraphicsUnit get_Unit();
    public void set_Unit(DrawingGraphicsUnit value);
    internal bool oBU=();
    internal void oRU=(bool value);
    public virtual int GetHashCode();
    public static string GetGlyphContent(int glyphIndex);
    public virtual bool Equals(object obj);
}
public enum ThinkGeo.Core.GeographyUnit : Enum {
    public int value__;
    public static GeographyUnit Unknown;
    public static GeographyUnit DecimalDegree;
    public static GeographyUnit Feet;
    public static GeographyUnit Meter;
}
public enum ThinkGeo.Core.GeohashAjacentDirection : Enum {
    public int value__;
    public static GeohashAjacentDirection Up;
    public static GeohashAjacentDirection UpperRight;
    public static GeohashAjacentDirection Right;
    public static GeohashAjacentDirection LowerRight;
    public static GeohashAjacentDirection Down;
    public static GeohashAjacentDirection LowerLeft;
    public static GeohashAjacentDirection Left;
    public static GeohashAjacentDirection UpperLeft;
}
public static class ThinkGeo.Core.GeohashHelper : object {
    private static string fCQ=;
    private static Int32[] fSQ=;
    private static String[][] fiQ=;
    private static String[][] fyQ=;
    private static GeohashHelper();
    public static PointShape ConvertToPointShape(string geohash);
    public static string ConvertToGeohash(PointShape pointShapeInDecimalDegree, int precision);
    public static string ConvertToGeohash(Vertex vertexInDecimalDegree, int precision);
    public static string ConvertToGeohash(double latitude, double longitude, int precision);
    public static string GetAdjacentGeohash(double latitude, double longitude, GeohashAjacentDirection direction);
    public static string GetAdjacentGeohash(double latitude, double longitude, GeohashAjacentDirection direction, int precision);
    public static string GetAdjacentGeohash(PointShape pointShapeInDecimalDegree, GeohashAjacentDirection direction);
    public static string GetAdjacentGeohash(PointShape pointShapeInDecimalDegree, GeohashAjacentDirection direction, int precision);
    public static string GetAdjacentGeohash(Vertex vertexInDecimalDegree, GeohashAjacentDirection direction);
    public static string GetAdjacentGeohash(Vertex vertexInDecimalDegree, GeohashAjacentDirection direction, int precision);
    public static string GetAdjacentGeohash(string geohash, GeohashAjacentDirection direction);
    public static Collection`1<string> GetAdjacentGeohashes(string geohash);
    public static Collection`1<string> GetAdjacentGeohashes(PointShape pointShapeInDecimalDegree);
    public static Collection`1<string> GetAdjacentGeohashes(PointShape pointShapeInDecimalDegree, int precision);
    public static Collection`1<string> GetAdjacentGeohashes(Vertex vertexInDecimalDegree);
    public static Collection`1<string> GetAdjacentGeohashes(Vertex vertexInDecimalDegree, int precision);
    public static Collection`1<string> GetAdjacentGeohashes(double latitude, double longitude);
    public static Collection`1<string> GetAdjacentGeohashes(double latitude, double longitude, int precision);
    private static string gCQ=(string hash, LEA= direction);
    private static void gSQ=(Double[]& interval, int cd, int mask);
    private static int giQ=(double doubleNumber);
}
public class ThinkGeo.Core.GeoHatchBrush : GeoBrush {
    [ObfuscationAttribute]
private GeoHatchStyle hatchStyle;
    [ObfuscationAttribute]
private GeoColor foregroundColor;
    [ObfuscationAttribute]
private GeoColor backgroundColor;
    public GeoHatchStyle HatchStyle { get; public set; }
    public GeoColor ForegroundColor { get; public set; }
    public GeoColor BackgroundColor { get; public set; }
    public GeoHatchBrush(GeoHatchStyle hatchStyle, GeoColor foregroundColor);
    public GeoHatchBrush(GeoHatchStyle hatchStyle, GeoColor foregroundColor, GeoColor backgroundColor);
    public GeoHatchStyle get_HatchStyle();
    public void set_HatchStyle(GeoHatchStyle value);
    public GeoColor get_ForegroundColor();
    public void set_ForegroundColor(GeoColor value);
    public GeoColor get_BackgroundColor();
    public void set_BackgroundColor(GeoColor value);
}
public enum ThinkGeo.Core.GeoHatchStyle : Enum {
    public int value__;
    public static GeoHatchStyle Horizontal;
    public static GeoHatchStyle Vertical;
    public static GeoHatchStyle ForwardDiagonal;
    public static GeoHatchStyle BackwardDiagonal;
    public static GeoHatchStyle LargeGrid;
    public static GeoHatchStyle DiagonalCross;
    public static GeoHatchStyle Percent05;
    public static GeoHatchStyle Percent10;
    public static GeoHatchStyle Percent20;
    public static GeoHatchStyle Percent25;
    public static GeoHatchStyle Percent30;
    public static GeoHatchStyle Percent40;
    public static GeoHatchStyle Percent50;
    public static GeoHatchStyle Percent60;
    public static GeoHatchStyle Percent70;
    public static GeoHatchStyle Percent75;
    public static GeoHatchStyle Percent80;
    public static GeoHatchStyle Percent90;
    public static GeoHatchStyle LightDownwardDiagonal;
    public static GeoHatchStyle LightUpwardDiagonal;
    public static GeoHatchStyle DarkDownwardDiagonal;
    public static GeoHatchStyle DarkUpwardDiagonal;
    public static GeoHatchStyle WideDownwardDiagonal;
    public static GeoHatchStyle WideUpwardDiagonal;
    public static GeoHatchStyle LightVertical;
    public static GeoHatchStyle LightHorizontal;
    public static GeoHatchStyle NarrowVertical;
    public static GeoHatchStyle NarrowHorizontal;
    public static GeoHatchStyle DarkVertical;
    public static GeoHatchStyle DarkHorizontal;
    public static GeoHatchStyle DashedDownwardDiagonal;
    public static GeoHatchStyle DashedUpwardDiagonal;
    public static GeoHatchStyle DashedHorizontal;
    public static GeoHatchStyle DashedVertical;
    public static GeoHatchStyle SmallConfetti;
    public static GeoHatchStyle LargeConfetti;
    public static GeoHatchStyle ZigZag;
    public static GeoHatchStyle Wave;
    public static GeoHatchStyle DiagonalBrick;
    public static GeoHatchStyle HorizontalBrick;
    public static GeoHatchStyle Weave;
    public static GeoHatchStyle Plaid;
    public static GeoHatchStyle Divot;
    public static GeoHatchStyle DottedGrid;
    public static GeoHatchStyle DottedDiamond;
    public static GeoHatchStyle Shingle;
    public static GeoHatchStyle Trellis;
    public static GeoHatchStyle Sphere;
    public static GeoHatchStyle SmallGrid;
    public static GeoHatchStyle SmallCheckerBoard;
    public static GeoHatchStyle LargeCheckerBoard;
    public static GeoHatchStyle OutlinedDiamond;
    public static GeoHatchStyle SolidDiamond;
    public static GeoHatchStyle Min;
    public static GeoHatchStyle Max;
    public static GeoHatchStyle Cross;
}
public class ThinkGeo.Core.GeoImage : object {
    [ObfuscationAttribute]
private float opacity;
    [ObfuscationAttribute]
private SKBitmap nativeImage;
    [ObfuscationAttribute]
private Byte[] bytes;
    [ObfuscationAttribute]
private string pathFilename;
    public string PathFilename { get; }
    public float Opacity { get; public set; }
    public int Width { get; }
    public int Height { get; }
    public SKBitmap NativeImage { get; }
    public GeoImage(int width, int height);
    public GeoImage(Stream stream);
    public GeoImage(string pathFilename);
    public GeoImage(Byte[] bytes);
    public GeoImage(SKBitmap skBitmap);
    public string get_PathFilename();
    public float get_Opacity();
    public void set_Opacity(float value);
    public int get_Width();
    public int get_Height();
    public SKBitmap get_NativeImage();
    public static GeoImage CreateCustomizedImage(int width, int height, GeoColorType colorType, GeoAlphaType alphaType);
    public Byte[] GetImageBytes(GeoImageFormat imageFormat, int imageQuality);
    public Byte[] ToBytesArray();
    public Stream GetImageStream(GeoImageFormat imageFormat, int imageQuality);
    public void Save(Stream stream, GeoImageFormat imageFormat, int quality);
    public void Save(string filePath, GeoImageFormat imageFormat, int quality);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool disposing);
    public void Clear(GeoColor color);
    public void SetPixels(GeoColor[] pixels);
    public IntPtr GetIntPtr();
    public GeoImage Scale(int targetWidth, int targetHeight);
    public GeoImage Crop(DrawingRectangle srcRect);
    public GeoImage Clip(DrawingRectangle clippingRectangle, int clippingWidth, int clippingHeight);
    public void DrawImage(GeoImage geoImage, float pointX, float pointY);
    public void DrawText(string text, GeoFont font, GeoBrush fillBrush, ScreenPointF[] points);
    internal GeoImage PRU=(bool isGrayscale, bool isNegative, float transparency, float redTranslation, float greenTranslation, float blueTranslation);
    internal GeoImage PhU=(Dictionary`2<GeoColor, GeoColor> colorMappings);
    [OnSerializingAttribute]
[OnGeoserializingAttribute]
private void PxU=(StreamingContext context);
    [OnDeserializedAttribute]
[OnGeodeserializedAttribute]
private void QBU=(StreamingContext context);
}
public enum ThinkGeo.Core.GeoImageFormat : Enum {
    public int value__;
    public static GeoImageFormat Png;
    public static GeoImageFormat Jpeg;
}
public class ThinkGeo.Core.GeoImageLayer : Layer {
    [ObfuscationAttribute]
private GeoImage _geoImage;
    [CompilerGeneratedAttribute]
private string UyA=;
    [CompilerGeneratedAttribute]
private PointShape eh0=;
    [CompilerGeneratedAttribute]
private double VCA=;
    [CompilerGeneratedAttribute]
private double 8B0=;
    [CompilerGeneratedAttribute]
private double 8R0=;
    public string ImagePathFilename { get; public set; }
    public PointShape CenterPoint { get; public set; }
    public double Scale { get; public set; }
    public double UpperThreshold { get; public set; }
    public double LowerThreshold { get; public set; }
    public GeoImageLayer(string imagePathFilename);
    [CompilerGeneratedAttribute]
public string get_ImagePathFilename();
    [CompilerGeneratedAttribute]
public void set_ImagePathFilename(string value);
    [CompilerGeneratedAttribute]
public PointShape get_CenterPoint();
    [CompilerGeneratedAttribute]
public void set_CenterPoint(PointShape value);
    [CompilerGeneratedAttribute]
public double get_Scale();
    [CompilerGeneratedAttribute]
public void set_Scale(double value);
    [CompilerGeneratedAttribute]
public double get_UpperThreshold();
    [CompilerGeneratedAttribute]
public void set_UpperThreshold(double value);
    [CompilerGeneratedAttribute]
public double get_LowerThreshold();
    [CompilerGeneratedAttribute]
public void set_LowerThreshold(double value);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual bool IsDrawingNeededCore(double currentScale);
}
[ObfuscationAttribute]
[DataContractAttribute]
internal class ThinkGeo.Core.GeoJsonFeature : GeoJsonObject {
    [CompilerGeneratedAttribute]
private GeoJsonObject <Geometry>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <BoundingBox>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [DataMemberAttribute]
public GeoJsonObject Geometry { get; public set; }
    [DataMemberAttribute]
public Dictionary`2<string, string> Properties { get; public set; }
    [DataMemberAttribute]
public Double[] BoundingBox { get; public set; }
    [DataMemberAttribute]
public string Id { get; public set; }
    public GeoJsonFeature(Feature feature);
    [CompilerGeneratedAttribute]
public GeoJsonObject get_Geometry();
    [CompilerGeneratedAttribute]
public void set_Geometry(GeoJsonObject value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Double[] get_BoundingBox();
    [CompilerGeneratedAttribute]
public void set_BoundingBox(Double[] value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
}
[DataContractAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonFeatureCollection : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<GeoJsonFeature> <GeoJsonFeatures>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Double[] <BoundingBox>k__BackingField;
    [DataMemberAttribute]
public Collection`1<GeoJsonFeature> GeoJsonFeatures { get; public set; }
    [DataMemberAttribute]
public Dictionary`2<string, string> Properties { get; public set; }
    [DataMemberAttribute]
public Double[] BoundingBox { get; public set; }
    public GeoJsonFeatureCollection(IEnumerable`1<Feature> features);
    [CompilerGeneratedAttribute]
public Collection`1<GeoJsonFeature> get_GeoJsonFeatures();
    [CompilerGeneratedAttribute]
public void set_GeoJsonFeatures(Collection`1<GeoJsonFeature> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Double[] get_BoundingBox();
    [CompilerGeneratedAttribute]
public void set_BoundingBox(Double[] value);
}
[ObfuscationAttribute]
[DataContractAttribute]
internal class ThinkGeo.Core.GeoJsonGeometryCollectionShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<GeoJsonObject> <Shapes>k__BackingField;
    [DataMemberAttribute]
public Collection`1<GeoJsonObject> Shapes { get; public set; }
    public GeoJsonGeometryCollectionShape(GeometryCollectionShape geometryCollection);
    [CompilerGeneratedAttribute]
public Collection`1<GeoJsonObject> get_Shapes();
    [CompilerGeneratedAttribute]
public void set_Shapes(Collection`1<GeoJsonObject> value);
}
[ObfuscationAttribute]
[DataContractAttribute]
internal class ThinkGeo.Core.GeoJsonLineStringShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<Double[]> <Vertices>k__BackingField;
    [DataMemberAttribute]
public Collection`1<Double[]> Vertices { get; public set; }
    public GeoJsonLineStringShape(LineShape line);
    [CompilerGeneratedAttribute]
public Collection`1<Double[]> get_Vertices();
    [CompilerGeneratedAttribute]
public void set_Vertices(Collection`1<Double[]> value);
}
[DataContractAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonMultiLineStringShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<Collection`1<Double[]>> <Lines>k__BackingField;
    [DataMemberAttribute]
public Collection`1<Collection`1<Double[]>> Lines { get; public set; }
    public GeoJsonMultiLineStringShape(MultilineShape multiLine);
    [CompilerGeneratedAttribute]
public Collection`1<Collection`1<Double[]>> get_Lines();
    [CompilerGeneratedAttribute]
public void set_Lines(Collection`1<Collection`1<Double[]>> value);
}
[ObfuscationAttribute]
[DataContractAttribute]
internal class ThinkGeo.Core.GeoJsonMultiPointShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<Double[]> <Points>k__BackingField;
    [DataMemberAttribute]
public Collection`1<Double[]> Points { get; public set; }
    public GeoJsonMultiPointShape(MultipointShape multiPoint);
    [CompilerGeneratedAttribute]
public Collection`1<Double[]> get_Points();
    [CompilerGeneratedAttribute]
public void set_Points(Collection`1<Double[]> value);
}
[DataContractAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonMultiPolygonShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<Collection`1<Collection`1<Double[]>>> <Polygons>k__BackingField;
    [DataMemberAttribute]
public Collection`1<Collection`1<Collection`1<Double[]>>> Polygons { get; public set; }
    public GeoJsonMultiPolygonShape(MultipolygonShape multiPolygon);
    [CompilerGeneratedAttribute]
public Collection`1<Collection`1<Collection`1<Double[]>>> get_Polygons();
    [CompilerGeneratedAttribute]
public void set_Polygons(Collection`1<Collection`1<Collection`1<Double[]>>> value);
    private static void FillRings(RingShape ring, Collection`1<Collection`1<Double[]>> polygon);
}
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonMultiPointShape")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonMultiLineStringShape")]
[ObfuscationAttribute]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonGeometryCollectionShape")]
[DataContractAttribute]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonFeature")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonPointShape")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonPolygonShape")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonLineStringShape")]
[KnownTypeAttribute("ThinkGeo.Core.GeoJsonMultiPolygonShape")]
internal class ThinkGeo.Core.GeoJsonObject : object {
    [CompilerGeneratedAttribute]
private string <ObjectType>k__BackingField;
    [DataMemberAttribute]
public string ObjectType { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ObjectType();
    [CompilerGeneratedAttribute]
public void set_ObjectType(string value);
}
[ObfuscationAttribute]
internal static class ThinkGeo.Core.GeoJsonObjectType : object {
    public static string Point;
    public static string LineString;
    public static string Polygon;
    public static string MultiPoint;
    public static string MultiLineString;
    public static string MultiPolygon;
    public static string GeometryCollection;
    public static string Feature;
    public static string FeatureCollection;
    private static GeoJsonObjectType();
}
[ObfuscationAttribute]
[DataContractAttribute]
internal class ThinkGeo.Core.GeoJsonPointShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Double[] <XY>k__BackingField;
    [DataMemberAttribute]
public Double[] XY { get; public set; }
    public GeoJsonPointShape(PointShape point);
    public GeoJsonPointShape(double x, double y);
    [CompilerGeneratedAttribute]
public Double[] get_XY();
    [CompilerGeneratedAttribute]
public void set_XY(Double[] value);
}
[DataContractAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonPolygonShape : GeoJsonObject {
    [CompilerGeneratedAttribute]
private Collection`1<Collection`1<Double[]>> <Rings>k__BackingField;
    [DataMemberAttribute]
public Collection`1<Collection`1<Double[]>> Rings { get; public set; }
    public GeoJsonPolygonShape(PolygonShape polygon);
    [CompilerGeneratedAttribute]
public Collection`1<Collection`1<Double[]>> get_Rings();
    [CompilerGeneratedAttribute]
public void set_Rings(Collection`1<Collection`1<Double[]>> value);
    private void FillRings(RingShape ring);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoJsonSerializeStrategy : object {
    [CompilerGeneratedAttribute]
private Func`2<object, GeoJsonType> <GetJsonType>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, object> <GetJsonNode>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<XElement> <FormalizedXml>k__BackingField;
    public Func`2<object, GeoJsonType> GetJsonType { get; public set; }
    public Func`2<object, object> GetJsonNode { get; public set; }
    public Action`1<XElement> FormalizedXml { get; public set; }
    [CompilerGeneratedAttribute]
public Func`2<object, GeoJsonType> get_GetJsonType();
    [CompilerGeneratedAttribute]
public void set_GetJsonType(Func`2<object, GeoJsonType> value);
    [CompilerGeneratedAttribute]
public Func`2<object, object> get_GetJsonNode();
    [CompilerGeneratedAttribute]
public void set_GetJsonNode(Func`2<object, object> value);
    [CompilerGeneratedAttribute]
public Action`1<XElement> get_FormalizedXml();
    [CompilerGeneratedAttribute]
public void set_FormalizedXml(Action`1<XElement> value);
    private static GeoJsonType GetJsonTypeHandler(object obj);
    private static object GetJsonNodeHandler(object obj);
    private static void FormalizedXmlHandler(XElement xElement);
}
[ObfuscationAttribute]
internal enum ThinkGeo.Core.GeoJsonType : Enum {
    public int value__;
    public static GeoJsonType unknown;
    public static GeoJsonType string;
    public static GeoJsonType number;
    public static GeoJsonType boolean;
    public static GeoJsonType object;
    public static GeoJsonType array;
    public static GeoJsonType null;
}
public class ThinkGeo.Core.GeoLinearGradientBrush : GeoBrush {
    [ObfuscationAttribute]
private GeoColor startColor;
    [ObfuscationAttribute]
private GeoColor endColor;
    [ObfuscationAttribute]
private GeoBrushWrapMode wrapMode;
    [ObfuscationAttribute]
private float directionAngle;
    public GeoColor StartColor { get; public set; }
    public GeoColor EndColor { get; public set; }
    public float DirectionAngle { get; public set; }
    public GeoBrushWrapMode WrapMode { get; public set; }
    public GeoLinearGradientBrush(GeoColor startColor, GeoColor endColor, GeoLinearGradientDirection direction);
    public GeoLinearGradientBrush(GeoColor startColor, GeoColor endColor, float directionAngle);
    private static float PBU=(GeoLinearGradientDirection direction);
    public GeoColor get_StartColor();
    public void set_StartColor(GeoColor value);
    public GeoColor get_EndColor();
    public void set_EndColor(GeoColor value);
    public float get_DirectionAngle();
    public void set_DirectionAngle(float value);
    public GeoBrushWrapMode get_WrapMode();
    public void set_WrapMode(GeoBrushWrapMode value);
}
public enum ThinkGeo.Core.GeoLinearGradientDirection : Enum {
    public int value__;
    public static GeoLinearGradientDirection LeftToRight;
    public static GeoLinearGradientDirection RightToLeft;
    public static GeoLinearGradientDirection TopToBottom;
    public static GeoLinearGradientDirection BottomToTop;
    public static GeoLinearGradientDirection UpperLeftToLowerRight;
    public static GeoLinearGradientDirection LowerRightToUpperLeft;
    public static GeoLinearGradientDirection LowerLeftToUpperRight;
    public static GeoLinearGradientDirection UpperRightToLowerLeft;
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.GeometryCollectionShape : BaseShape {
    [ObfuscationAttribute]
private Collection`1<BaseShape> shapes;
    public Collection`1<BaseShape> Shapes { get; }
    public GeometryCollectionShape(IEnumerable`1<BaseShape> baseShapes);
    public GeometryCollectionShape(IEnumerable`1<Feature> features);
    public GeometryCollectionShape(string wellKnownText);
    public GeometryCollectionShape(Byte[] wellKnownBinary);
    public Collection`1<BaseShape> get_Shapes();
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    private void RRw=(GeometryCollectionShape fromGeometryCollection);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual MultilineShape GetShortestLineToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual MultipolygonShape BufferCore(double distance, int quadrantSegments, BufferCapType bufferCapType, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual bool IsDisjointedCore(BaseShape targetShape);
    protected virtual bool IntersectsCore(BaseShape targetShape);
    protected virtual bool TouchesCore(BaseShape targetShape);
    protected virtual bool IsWithinCore(BaseShape targetShape);
    public GeometryCollectionShape GetIntersection(BaseShape targetShape);
    protected virtual GeometryCollectionShape GetIntersectionCore(BaseShape targetShape);
    public GeometryCollectionShape Union(BaseShape targetShape);
    public GeometryCollectionShape Union(IEnumerable`1<BaseShape> targetShape);
    protected virtual GeometryCollectionShape UnionCore(IEnumerable`1<BaseShape> targetShape);
    private static Collection`1<BaseShape> Rhw=(GeometryCollectionShape geometryCollection);
    internal static GeometryCollectionShape Rxw=(IEnumerable`1<BaseShape> shapes);
    public GeometryCollectionShape GetDifference(BaseShape targetShape);
    protected virtual GeometryCollectionShape GetDifferenceCore(BaseShape targetShape);
    public GeometryCollectionShape GetSymmetricalDifference(BaseShape targetShape);
    protected virtual GeometryCollectionShape GetSymmetricalDifferenceCore(BaseShape targetShape);
    public RingShape GetConvexHull();
    protected virtual RingShape GetConvexHullCore();
    public GeometryCollectionShape Simplify(GeographyUnit shapeUnit, double tolerance, DistanceUnit toleranceUnit, SimplificationType simplificationType);
    public GeometryCollectionShape Simplify(double tolerance, SimplificationType simplificationType);
    protected virtual GeometryCollectionShape SimplifyCore(double tolerance, SimplificationType simplificationType);
    private static EndCapStyle 2xo=(BufferCapType bufferCapStyle);
}
public class ThinkGeo.Core.GeoObjectModel : object {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private GeoObjectNode rootNode;
    public string Name { get; public set; }
    public GeoObjectNode RootNode { get; public set; }
    public GeoObjectModel(string name, GeoObjectNode rootNode);
    public string get_Name();
    public void set_Name(string value);
    public GeoObjectNode get_RootNode();
    public void set_RootNode(GeoObjectNode value);
}
internal class ThinkGeo.Core.GeoObjectModeler : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<CreatingMemberNodeGeoObjectModelerEventArgs> CreatingMemberNode;
    [CompilerGeneratedAttribute]
private EventHandler`1<CreatedMemberNodeGeoObjectModelerEventArgs> CreatedMemberNode;
    [CompilerGeneratedAttribute]
private EventHandler`1<CreatingMemberObjectGeoObjectModelerEventArgs> CreatingMemberObject;
    [CompilerGeneratedAttribute]
private EventHandler`1<CreatedMemberObjectGeoObjectModelerEventArgs> CreatedMemberObject;
    [CompilerGeneratedAttribute]
private bool <IsGeneratingCode>k__BackingField;
    private string circularReferenceAttributeName;
    private Type[] parameterToGetConstructor;
    private Object[] parameterToInvokeConstructor;
    private Type onDeserializingAttributeType;
    private Type onDeserializedAttributeType;
    private Type onSerializingAttributeType;
    private Type onSerializedAttributeType;
    private Dictionary`2<string, Collection`1<MethodInfo>> attributedMethodInfosCache;
    private static Dictionary`2<string, string> escapeCharactors;
    [ObfuscationAttribute]
private object referencedObject;
    [ObfuscationAttribute]
private string hashCode;
    [ObfuscationAttribute]
private string referenceTypeName;
    [ObfuscationAttribute]
private Dictionary`2<object, GeoObjectNodeAndGuid> hashCodeModelDictionary;
    [ObfuscationAttribute]
private Dictionary`2<string, object> hashcodeValueDictionary;
    [ObfuscationAttribute]
private Dictionary`2<Type, object> objectsInInitialState;
    [ObfuscationAttribute]
private GeoObjectModelerMemberTypes memberTypes;
    [ObfuscationAttribute]
private GeoObjectModelerDefaultValueMode defaultValueMode;
    [ObfuscationAttribute]
private BindingFlags bindingFlags;
    [ObfuscationAttribute]
private object tmpValue;
    [ObfuscationAttribute]
private PropertyInfo tmpProperty;
    internal bool IsGeneratingCode { get; internal set; }
    private static GeoObjectModeler();
    [CompilerGeneratedAttribute]
public void add_CreatingMemberNode(EventHandler`1<CreatingMemberNodeGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CreatingMemberNode(EventHandler`1<CreatingMemberNodeGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CreatedMemberNode(EventHandler`1<CreatedMemberNodeGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CreatedMemberNode(EventHandler`1<CreatedMemberNodeGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CreatingMemberObject(EventHandler`1<CreatingMemberObjectGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CreatingMemberObject(EventHandler`1<CreatingMemberObjectGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CreatedMemberObject(EventHandler`1<CreatedMemberObjectGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CreatedMemberObject(EventHandler`1<CreatedMemberObjectGeoObjectModelerEventArgs> value);
    [CompilerGeneratedAttribute]
internal bool get_IsGeneratingCode();
    [CompilerGeneratedAttribute]
internal void set_IsGeneratingCode(bool value);
    public GeoObjectModel CreateModel(object objectToModel, GeoObjectModelerMemberTypes memberTypes, BindingFlags bindingFlags, GeoObjectModelerDefaultValueMode defaultValueMode);
    public object CreateObject(GeoObjectModel model);
    protected Collection`1<MemberInfo> GetMembers(Type type, GeoObjectModelerMemberTypes memberTypes);
    protected virtual Collection`1<MemberInfo> GetMembersCore(Type type, GeoObjectModelerMemberTypes memberTypes);
    protected virtual void OnCreatingMemberNode(CreatingMemberNodeGeoObjectModelerEventArgs e);
    protected virtual void OnCreatingMemberObject(CreatingMemberObjectGeoObjectModelerEventArgs e);
    protected virtual void OnCreatedMemberNode(CreatedMemberNodeGeoObjectModelerEventArgs e);
    protected virtual void OnCreatedMemberObject(CreatedMemberObjectGeoObjectModelerEventArgs e);
    protected void CreateMemberNode(string memberName, object memberValue, Type memberType, object memberOwner, GeoObjectNode baseMemberNode);
    protected virtual void CreateMemberNodeCore(string memberName, object memberValue, Type memberType, object memberOwner, GeoObjectNode baseMemberNode);
    protected object CreateMemberObject(string memberName, Type memberType, object memberOwner, GeoObjectNode memberNode);
    protected virtual object CreateMemberObjectCore(string memberName, Type memberType, object memberOwner, GeoObjectNode memberNode);
    private GeoObjectNode CreateModelForObject(object modelSource);
    private Collection`1<MemberInfo> GetAllMembers(Type type);
    private void CreateNodeForObject(object serializationObject, GeoObjectNode baseObjectModel, string nodeName, Type parentType);
    private static void InvokeSerializingDeserializingMethods(object serializationObject, IEnumerable`1<MethodInfo> onSerializingMethods);
    private bool IsSpecialTypes(Type type);
    [IteratorStateMachineAttribute("ThinkGeo.Core.GeoObjectModeler/tz4=")]
private IEnumerable`1<MethodInfo> GetMethodsMarkedAs(Type type, Type attributeType);
    private static GeoObjectNode CreateNewNode(string name);
    private static void SetInheritAttribute(GeoObjectNode objectModel, Type type, Type parentType);
    private static void SetTypeAttribute(GeoObjectNode objectModel, Type objType);
    private static string SimplifyAssemblyQualifiedName(string name);
    private static void SetItemTypeAttribute(GeoObjectNode objectModel, Type objType);
    private bool IsCircularReferenced(object obj, GeoObjectNode objectModel);
    private void HandleCircularReferencing(object obj, GeoObjectNode objectModel, string fieldName);
    private static bool IsSimpleType(Type type);
    private static void CreateNodeForSimpleType(object serializationObject, GeoObjectNode currentModel);
    private void CreateNodeForArrayType(Array array, GeoObjectNode objectModel);
    private void CreateNodeForIEnumerableType(IEnumerable sequence, GeoObjectNode objectModel);
    private void CreateNodeForNormalType(object serializationObject, GeoObjectNode currentModel);
    private void RaiseEventAndCreateNodeForProperty(object serializationObject, GeoObjectNode currentModel, PropertyInfo property);
    private void RaiseEventAndCreateNodeForField(object serializationObject, GeoObjectNode currentModel, FieldInfo field);
    private static bool IsSerializable(FieldInfo field);
    private static bool IsSerializable(PropertyInfo property);
    private object CreateObjectFromModel(GeoObjectNode node, string typeName);
    private static string ReplaceInvalidCharacters(string name);
    private object CreateArray(GeoObjectNode node, Type type);
    private void SetValue(Array b, int rank, List`1<int> indecies, Collection`1<object> values, Int32& index);
    private void CreateIEnumerableObject(object result, GeoObjectNode node, Type type);
    private static object CreateSimpleObject(GeoObjectNode node, Type type);
    private object CreateNormalObject(GeoObjectNode node, object result);
    private static object GetSimpleTypeResult(Type type, string value);
    private Collection`1<MemberInfo> GetPrivateFieldsByType(Type type);
    private static Collection`1<MemberInfo> GetPublicPropertiesByType(Type type);
    private static bool IsSettable(PropertyInfo propertyInfo);
    private bool IsInitValue(FieldInfo fieldInfo, object ownerValue, Type ownerType);
    private bool IsInitValue(PropertyInfo propertyInfo, object ownerValue, Type ownerType);
    private object GetInitObject(Type ownerType);
    private bool AreSame(object obj1, object obj2, Type objType, bool checkProperties, bool checkFields);
    private bool FieldsSame(object obj1, object obj2, Type objType);
    private bool PropertiesSame(object obj1, object obj2, Type objType);
    private IEnumerable`1<FieldInfo> FilterFields(Type objType);
    private static IEnumerable`1<PropertyInfo> FilterProperties(Type objType);
    private bool AreIEnumerablesSame(object obj1, object obj2, bool checkProperties, bool checkFields);
}
internal enum ThinkGeo.Core.GeoObjectModelerDefaultValueMode : Enum {
    public int value__;
    public static GeoObjectModelerDefaultValueMode IncludeDefaultValues;
    public static GeoObjectModelerDefaultValueMode ExcludeDefaultValues;
}
[FlagsAttribute]
internal enum ThinkGeo.Core.GeoObjectModelerMemberTypes : Enum {
    public int value__;
    public static GeoObjectModelerMemberTypes Fields;
    public static GeoObjectModelerMemberTypes Properties;
}
public class ThinkGeo.Core.GeoObjectNode : object {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private GeoObjectNode parent;
    [ObfuscationAttribute]
private Collection`1<GeoObjectNode> children;
    [ObfuscationAttribute]
private Dictionary`2<string, string> attributes;
    [ObfuscationAttribute]
private string actualValue;
    [ObfuscationAttribute]
private bool isDefaultValue;
    [ObfuscationAttribute]
internal bool isNonGenericSequence;
    public string Name { get; public set; }
    public GeoObjectNode Parent { get; public set; }
    public Collection`1<GeoObjectNode> Children { get; private set; }
    public Dictionary`2<string, string> Attributes { get; private set; }
    public string Value { get; public set; }
    public bool IsDefaultValue { get; public set; }
    internal bool vRo= { get; internal set; }
    internal GeoObjectNode vxo= { get; }
    internal GeoObjectNode wRo= { get; }
    public GeoObjectNode(string name);
    public string get_Name();
    public void set_Name(string value);
    public GeoObjectNode get_Parent();
    public void set_Parent(GeoObjectNode value);
    public Collection`1<GeoObjectNode> get_Children();
    private void set_Children(Collection`1<GeoObjectNode> value);
    public Dictionary`2<string, string> get_Attributes();
    private void set_Attributes(Dictionary`2<string, string> value);
    public string get_Value();
    public void set_Value(string value);
    public bool get_IsDefaultValue();
    public void set_IsDefaultValue(bool value);
    internal bool uxo=();
    internal void vBo=(bool value);
    internal GeoObjectNode vho=();
    internal GeoObjectNode wBo=();
    internal void who=(string attributeName, string attributeValue);
    internal string wxo=(string attributeName);
    internal void xBo=(string attributeName);
    public virtual string ToString();
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.GeoObjectNodeAndGuid : object {
    [ObfuscationAttribute]
private GeoObjectNode node;
    [ObfuscationAttribute]
private string id;
    internal GeoObjectNode xho= { get; }
    internal string fxQ= { get; }
    public GeoObjectNodeAndGuid(GeoObjectNode node, string id);
    internal GeoObjectNode xRo=();
    internal string fRQ=();
}
public class ThinkGeo.Core.GeoPen : object {
    [ObfuscationAttribute]
private float width;
    [ObfuscationAttribute]
private float miterLimit;
    [ObfuscationAttribute]
private GeoBrush brush;
    [ObfuscationAttribute]
private GeoColor color;
    [ObfuscationAttribute]
private GeoDashCap dashCap;
    [ObfuscationAttribute]
private LineDashStyle dashStyle;
    [ObfuscationAttribute]
private DrawingLineCap startCap;
    [ObfuscationAttribute]
private DrawingLineCap endCap;
    [ObfuscationAttribute]
private DrawingLineJoin lineJoin;
    [ObfuscationAttribute]
private Collection`1<float> dashPattern;
    [ObfuscationAttribute]
private long id;
    [ObfuscationAttribute]
private static long geoPenIdCounter;
    public GeoBrush Brush { get; public set; }
    public GeoColor Color { get; public set; }
    public GeoDashCap DashCap { get; public set; }
    public Collection`1<float> DashPattern { get; }
    public LineDashStyle DashStyle { get; public set; }
    public DrawingLineCap EndCap { get; public set; }
    public DrawingLineJoin LineJoin { get; public set; }
    public float MiterLimit { get; public set; }
    public DrawingLineCap StartCap { get; public set; }
    public float Width { get; public set; }
    public long Id { get; }
    public GeoPen(GeoBrush brush);
    public GeoPen(GeoColor color);
    public GeoPen(GeoColor color, float width);
    public GeoPen(GeoBrush brush, float width);
    public void SetLineCap(DrawingLineCap startCap, DrawingLineCap endCap, GeoDashCap dashCap);
    public GeoBrush get_Brush();
    public void set_Brush(GeoBrush value);
    public GeoColor get_Color();
    public void set_Color(GeoColor value);
    public GeoDashCap get_DashCap();
    public void set_DashCap(GeoDashCap value);
    public Collection`1<float> get_DashPattern();
    public LineDashStyle get_DashStyle();
    public void set_DashStyle(LineDashStyle value);
    public DrawingLineCap get_EndCap();
    public void set_EndCap(DrawingLineCap value);
    public DrawingLineJoin get_LineJoin();
    public void set_LineJoin(DrawingLineJoin value);
    public float get_MiterLimit();
    public void set_MiterLimit(float value);
    public DrawingLineCap get_StartCap();
    public void set_StartCap(DrawingLineCap value);
    public float get_Width();
    public void set_Width(float value);
    public long get_Id();
    public GeoPen CloneDeep();
    protected virtual GeoPen CloneDeepCore();
    private void oxU=();
    private bool pBU=();
}
public static class ThinkGeo.Core.GeoPens : object {
    public static GeoPen AliceBlue { get; }
    public static GeoPen AntiqueWhite { get; }
    public static GeoPen Aqua { get; }
    public static GeoPen Aquamarine { get; }
    public static GeoPen Azure { get; }
    public static GeoPen Beige { get; }
    public static GeoPen Bisque { get; }
    public static GeoPen Black { get; }
    public static GeoPen BlanchedAlmond { get; }
    public static GeoPen Blue { get; }
    public static GeoPen BlueViolet { get; }
    public static GeoPen Brown { get; }
    public static GeoPen BurlyWood { get; }
    public static GeoPen CadetBlue { get; }
    public static GeoPen Chartreuse { get; }
    public static GeoPen Chocolate { get; }
    public static GeoPen Coral { get; }
    public static GeoPen CornflowerBlue { get; }
    public static GeoPen CornSilk { get; }
    public static GeoPen Crimson { get; }
    public static GeoPen Cyan { get; }
    public static GeoPen DarkBlue { get; }
    public static GeoPen DarkCyan { get; }
    public static GeoPen DarkGoldenrod { get; }
    public static GeoPen DarkGray { get; }
    public static GeoPen DarkGreen { get; }
    public static GeoPen DarkKhaki { get; }
    public static GeoPen DarkMagenta { get; }
    public static GeoPen DarkOliveGreen { get; }
    public static GeoPen DarkOrange { get; }
    public static GeoPen DarkOrchid { get; }
    public static GeoPen DarkRed { get; }
    public static GeoPen DarkSalmon { get; }
    public static GeoPen DarkSeaGreen { get; }
    public static GeoPen DarkSlateBlue { get; }
    public static GeoPen DarkSlateGray { get; }
    public static GeoPen DarkTurquoise { get; }
    public static GeoPen DarkViolet { get; }
    public static GeoPen DeepPink { get; }
    public static GeoPen DeepSkyBlue { get; }
    public static GeoPen DimGray { get; }
    public static GeoPen DodgerBlue { get; }
    public static GeoPen Firebrick { get; }
    public static GeoPen FloralWhite { get; }
    public static GeoPen ForestGreen { get; }
    public static GeoPen Fuchsia { get; }
    public static GeoPen Gainsboro { get; }
    public static GeoPen GhostWhite { get; }
    public static GeoPen Gold { get; }
    public static GeoPen Goldenrod { get; }
    public static GeoPen Gray { get; }
    public static GeoPen Green { get; }
    public static GeoPen GreenYellow { get; }
    public static GeoPen HoneyDew { get; }
    public static GeoPen HotPink { get; }
    public static GeoPen IndianRed { get; }
    public static GeoPen Indigo { get; }
    public static GeoPen Ivory { get; }
    public static GeoPen Khaki { get; }
    public static GeoPen Lavender { get; }
    public static GeoPen LavenderBlush { get; }
    public static GeoPen LawnGreen { get; }
    public static GeoPen LemonChiffon { get; }
    public static GeoPen LightBlue { get; }
    public static GeoPen LightCoral { get; }
    public static GeoPen LightCyan { get; }
    public static GeoPen LightGoldenrodYellow { get; }
    public static GeoPen LightGray { get; }
    public static GeoPen LightGreen { get; }
    public static GeoPen LightPink { get; }
    public static GeoPen LightRed { get; }
    public static GeoPen LightSalmon { get; }
    public static GeoPen LightSeaGreen { get; }
    public static GeoPen LightSkyBlue { get; }
    public static GeoPen LightSlateGray { get; }
    public static GeoPen LightSteelBlue { get; }
    public static GeoPen LightYellow { get; }
    public static GeoPen Lime { get; }
    public static GeoPen LimeGreen { get; }
    public static GeoPen Linen { get; }
    public static GeoPen Magenta { get; }
    public static GeoPen Maroon { get; }
    public static GeoPen MediumAquamarine { get; }
    public static GeoPen MediumBlue { get; }
    public static GeoPen MediumOrchid { get; }
    public static GeoPen MediumPurple { get; }
    public static GeoPen MediumSeaGreen { get; }
    public static GeoPen MediumSlateBlue { get; }
    public static GeoPen MediumSpringGreen { get; }
    public static GeoPen MediumTurquoise { get; }
    public static GeoPen MediumVioletRed { get; }
    public static GeoPen MidnightBlue { get; }
    public static GeoPen MintCream { get; }
    public static GeoPen MistyRose { get; }
    public static GeoPen Moccasin { get; }
    public static GeoPen NavajoWhite { get; }
    public static GeoPen Navy { get; }
    public static GeoPen OldLace { get; }
    public static GeoPen Olive { get; }
    public static GeoPen OliveDrab { get; }
    public static GeoPen Orange { get; }
    public static GeoPen OrangeRed { get; }
    public static GeoPen Orchid { get; }
    public static GeoPen PaleGoldenrod { get; }
    public static GeoPen PaleGreen { get; }
    public static GeoPen PaleTurquoise { get; }
    public static GeoPen PaleVioletRed { get; }
    public static GeoPen PapayaWhip { get; }
    public static GeoPen PeachPuff { get; }
    public static GeoPen Peru { get; }
    public static GeoPen Pink { get; }
    public static GeoPen Plum { get; }
    public static GeoPen PowderBlue { get; }
    public static GeoPen Purple { get; }
    public static GeoPen Red { get; }
    public static GeoPen RosyBrown { get; }
    public static GeoPen RoyalBlue { get; }
    public static GeoPen SaddleBrown { get; }
    public static GeoPen Salmon { get; }
    public static GeoPen SandyBrown { get; }
    public static GeoPen SeaGreen { get; }
    public static GeoPen SeaShell { get; }
    public static GeoPen Sienna { get; }
    public static GeoPen Silver { get; }
    public static GeoPen SkyBlue { get; }
    public static GeoPen SlateBlue { get; }
    public static GeoPen SlateGray { get; }
    public static GeoPen Snow { get; }
    public static GeoPen SpringGreen { get; }
    public static GeoPen SteelBlue { get; }
    public static GeoPen Tan { get; }
    public static GeoPen Teal { get; }
    public static GeoPen Thistle { get; }
    public static GeoPen Tomato { get; }
    public static GeoPen Turquoise { get; }
    public static GeoPen Violet { get; }
    public static GeoPen Wheat { get; }
    public static GeoPen White { get; }
    public static GeoPen WhiteSmoke { get; }
    public static GeoPen Yellow { get; }
    public static GeoPen YellowGreen { get; }
    public static GeoPen DarkYellow { get; }
    public static GeoPen LightOrange { get; }
    public static GeoPen PaleRed { get; }
    public static GeoPen PaleBlue { get; }
    public static GeoPen PaleYellow { get; }
    public static GeoPen PaleOrange { get; }
    public static GeoPen BrightRed { get; }
    public static GeoPen BrightBlue { get; }
    public static GeoPen BrightYellow { get; }
    public static GeoPen BrightOrange { get; }
    public static GeoPen PastelRed { get; }
    public static GeoPen PastelBlue { get; }
    public static GeoPen PastelYellow { get; }
    public static GeoPen PastelGreen { get; }
    public static GeoPen PastelOrange { get; }
    public static GeoPen Copper { get; }
    public static GeoPen get_AliceBlue();
    public static GeoPen get_AntiqueWhite();
    public static GeoPen get_Aqua();
    public static GeoPen get_Aquamarine();
    public static GeoPen get_Azure();
    public static GeoPen get_Beige();
    public static GeoPen get_Bisque();
    public static GeoPen get_Black();
    public static GeoPen get_BlanchedAlmond();
    public static GeoPen get_Blue();
    public static GeoPen get_BlueViolet();
    public static GeoPen get_Brown();
    public static GeoPen get_BurlyWood();
    public static GeoPen get_CadetBlue();
    public static GeoPen get_Chartreuse();
    public static GeoPen get_Chocolate();
    public static GeoPen get_Coral();
    public static GeoPen get_CornflowerBlue();
    public static GeoPen get_CornSilk();
    public static GeoPen get_Crimson();
    public static GeoPen get_Cyan();
    public static GeoPen get_DarkBlue();
    public static GeoPen get_DarkCyan();
    public static GeoPen get_DarkGoldenrod();
    public static GeoPen get_DarkGray();
    public static GeoPen get_DarkGreen();
    public static GeoPen get_DarkKhaki();
    public static GeoPen get_DarkMagenta();
    public static GeoPen get_DarkOliveGreen();
    public static GeoPen get_DarkOrange();
    public static GeoPen get_DarkOrchid();
    public static GeoPen get_DarkRed();
    public static GeoPen get_DarkSalmon();
    public static GeoPen get_DarkSeaGreen();
    public static GeoPen get_DarkSlateBlue();
    public static GeoPen get_DarkSlateGray();
    public static GeoPen get_DarkTurquoise();
    public static GeoPen get_DarkViolet();
    public static GeoPen get_DeepPink();
    public static GeoPen get_DeepSkyBlue();
    public static GeoPen get_DimGray();
    public static GeoPen get_DodgerBlue();
    public static GeoPen get_Firebrick();
    public static GeoPen get_FloralWhite();
    public static GeoPen get_ForestGreen();
    public static GeoPen get_Fuchsia();
    public static GeoPen get_Gainsboro();
    public static GeoPen get_GhostWhite();
    public static GeoPen get_Gold();
    public static GeoPen get_Goldenrod();
    public static GeoPen get_Gray();
    public static GeoPen get_Green();
    public static GeoPen get_GreenYellow();
    public static GeoPen get_HoneyDew();
    public static GeoPen get_HotPink();
    public static GeoPen get_IndianRed();
    public static GeoPen get_Indigo();
    public static GeoPen get_Ivory();
    public static GeoPen get_Khaki();
    public static GeoPen get_Lavender();
    public static GeoPen get_LavenderBlush();
    public static GeoPen get_LawnGreen();
    public static GeoPen get_LemonChiffon();
    public static GeoPen get_LightBlue();
    public static GeoPen get_LightCoral();
    public static GeoPen get_LightCyan();
    public static GeoPen get_LightGoldenrodYellow();
    public static GeoPen get_LightGray();
    public static GeoPen get_LightGreen();
    public static GeoPen get_LightPink();
    public static GeoPen get_LightRed();
    public static GeoPen get_LightSalmon();
    public static GeoPen get_LightSeaGreen();
    public static GeoPen get_LightSkyBlue();
    public static GeoPen get_LightSlateGray();
    public static GeoPen get_LightSteelBlue();
    public static GeoPen get_LightYellow();
    public static GeoPen get_Lime();
    public static GeoPen get_LimeGreen();
    public static GeoPen get_Linen();
    public static GeoPen get_Magenta();
    public static GeoPen get_Maroon();
    public static GeoPen get_MediumAquamarine();
    public static GeoPen get_MediumBlue();
    public static GeoPen get_MediumOrchid();
    public static GeoPen get_MediumPurple();
    public static GeoPen get_MediumSeaGreen();
    public static GeoPen get_MediumSlateBlue();
    public static GeoPen get_MediumSpringGreen();
    public static GeoPen get_MediumTurquoise();
    public static GeoPen get_MediumVioletRed();
    public static GeoPen get_MidnightBlue();
    public static GeoPen get_MintCream();
    public static GeoPen get_MistyRose();
    public static GeoPen get_Moccasin();
    public static GeoPen get_NavajoWhite();
    public static GeoPen get_Navy();
    public static GeoPen get_OldLace();
    public static GeoPen get_Olive();
    public static GeoPen get_OliveDrab();
    public static GeoPen get_Orange();
    public static GeoPen get_OrangeRed();
    public static GeoPen get_Orchid();
    public static GeoPen get_PaleGoldenrod();
    public static GeoPen get_PaleGreen();
    public static GeoPen get_PaleTurquoise();
    public static GeoPen get_PaleVioletRed();
    public static GeoPen get_PapayaWhip();
    public static GeoPen get_PeachPuff();
    public static GeoPen get_Peru();
    public static GeoPen get_Pink();
    public static GeoPen get_Plum();
    public static GeoPen get_PowderBlue();
    public static GeoPen get_Purple();
    public static GeoPen get_Red();
    public static GeoPen get_RosyBrown();
    public static GeoPen get_RoyalBlue();
    public static GeoPen get_SaddleBrown();
    public static GeoPen get_Salmon();
    public static GeoPen get_SandyBrown();
    public static GeoPen get_SeaGreen();
    public static GeoPen get_SeaShell();
    public static GeoPen get_Sienna();
    public static GeoPen get_Silver();
    public static GeoPen get_SkyBlue();
    public static GeoPen get_SlateBlue();
    public static GeoPen get_SlateGray();
    public static GeoPen get_Snow();
    public static GeoPen get_SpringGreen();
    public static GeoPen get_SteelBlue();
    public static GeoPen get_Tan();
    public static GeoPen get_Teal();
    public static GeoPen get_Thistle();
    public static GeoPen get_Tomato();
    public static GeoPen get_Turquoise();
    public static GeoPen get_Violet();
    public static GeoPen get_Wheat();
    public static GeoPen get_White();
    public static GeoPen get_WhiteSmoke();
    public static GeoPen get_Yellow();
    public static GeoPen get_YellowGreen();
    public static GeoPen get_DarkYellow();
    public static GeoPen get_LightOrange();
    public static GeoPen get_PaleRed();
    public static GeoPen get_PaleBlue();
    public static GeoPen get_PaleYellow();
    public static GeoPen get_PaleOrange();
    public static GeoPen get_BrightRed();
    public static GeoPen get_BrightBlue();
    public static GeoPen get_BrightYellow();
    public static GeoPen get_BrightOrange();
    public static GeoPen get_PastelRed();
    public static GeoPen get_PastelBlue();
    public static GeoPen get_PastelYellow();
    public static GeoPen get_PastelGreen();
    public static GeoPen get_PastelOrange();
    public static GeoPen get_Copper();
}
public abstract class ThinkGeo.Core.GeoSerializationFormatter : object {
    [ObfuscationAttribute]
private Encoding encoding;
    public Encoding Encoding { get; public set; }
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public void Save(GeoObjectModel model, Stream stream);
    protected abstract virtual void SaveCore(GeoObjectModel model, Stream stream);
    public GeoObjectModel Load(Stream stream);
    protected abstract virtual GeoObjectModel LoadCore(Stream stream);
}
public class ThinkGeo.Core.GeoSerializer : object {
    [ObfuscationAttribute]
private GeoSerializationFormatter formatter;
    [ObfuscationAttribute]
private GeoObjectModeler modeler;
    [ObfuscationAttribute]
private BindingFlags bindingFlags;
    public GeoSerializationFormatter Formatter { get; public set; }
    public GeoSerializer(GeoSerializationFormatter formatter);
    public GeoSerializationFormatter get_Formatter();
    public void set_Formatter(GeoSerializationFormatter value);
    public void Serialize(object objectToSerialize, string targetPathFilename);
    public void Serialize(object objectToSerialize, Stream targetStream);
    public string Serialize(object objectToSerialize);
    public object Deserialize(string sourcePathFilename, FileAccess readWriteMode);
    public object Deserialize(Stream sourceStream);
    public object Deserialize(string sourceString);
    public object Deserialize(Uri sourceUri);
}
public class ThinkGeo.Core.GeoSolidBrush : GeoBrush {
    [ObfuscationAttribute]
private GeoColor color;
    public GeoColor Color { get; public set; }
    public GeoSolidBrush(GeoColor color);
    public GeoColor get_Color();
    public void set_Color(GeoColor value);
}
public class ThinkGeo.Core.GeoTextureBrush : GeoBrush {
    [ObfuscationAttribute]
private GeoImage geoImage;
    [ObfuscationAttribute]
private GeoBrushWrapMode geoWrapMode;
    [ObfuscationAttribute]
private DrawingRectangleF drawingRectangleF;
    public GeoImage GeoImage { get; }
    public DrawingRectangleF DrawingRectangleF { get; public set; }
    public GeoBrushWrapMode GeoWrapMode { get; public set; }
    public GeoTextureBrush(GeoImage image);
    public GeoTextureBrush(GeoImage image, DrawingRectangleF rectangleF);
    public GeoTextureBrush(GeoImage image, GeoBrushWrapMode wrapMode);
    public GeoTextureBrush(GeoImage image, GeoBrushWrapMode wrapMode, DrawingRectangleF rectangleF);
    public GeoImage get_GeoImage();
    public DrawingRectangleF get_DrawingRectangleF();
    public void set_DrawingRectangleF(DrawingRectangleF value);
    public GeoBrushWrapMode get_GeoWrapMode();
    public void set_GeoWrapMode(GeoBrushWrapMode value);
}
public class ThinkGeo.Core.GeoTiffRasterLayer : RasterLayer {
    [ObfuscationAttribute]
private DrawingQuality drawingQuality;
    public string ImagePathFilename { get; public set; }
    public bool HasBoundingBox { get; }
    public DrawingQuality DrawingQuality { get; public set; }
    public GeoTiffRasterLayer(string imagePathFilename);
    public GeoTiffRasterLayer(string imagePathFilename, string worldfilePathFilename);
    public GeoTiffRasterLayer(string imagePathFilename, RectangleShape imageWorldExtent);
    public string get_ImagePathFilename();
    public void set_ImagePathFilename(string value);
    public virtual bool get_HasBoundingBox();
    public DrawingQuality get_DrawingQuality();
    public void set_DrawingQuality(DrawingQuality value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.GeoTiffRasterSource : RasterSource {
    [ObfuscationAttribute]
private static int pixelAmount;
    [ObfuscationAttribute]
private string imagePathFilename;
    [ObfuscationAttribute]
private WorldFile tiffWorldFile;
    [ObfuscationAttribute]
private int previousImageWidth;
    [ObfuscationAttribute]
private int previousImageHeight;
    [ObfuscationAttribute]
private int imageWidth;
    [ObfuscationAttribute]
private int imageHeight;
    [ObfuscationAttribute]
private Int32[] imageBuffer;
    [ObfuscationAttribute]
private RectangleShape imageExtent;
    private Tiff 0CE=;
    [ObfuscationAttribute]
private string worldfilePathFilename;
    [ObfuscationAttribute]
private bool tiffIsTiled;
    [ObfuscationAttribute]
private int rowNumberPerStrip;
    [ObfuscationAttribute]
private int planarConfig;
    [ObfuscationAttribute]
private Dictionary`2<short, DrawingRectangle> levelImageSize;
    [ObfuscationAttribute]
private short directoriesCount;
    [ObfuscationAttribute]
private int tileLength;
    [ObfuscationAttribute]
private int tileWidth;
    [ObfuscationAttribute]
private int tileDepth;
    [ObfuscationAttribute]
private Int64[] tileOffsets;
    [ObfuscationAttribute]
private Int64[] tileBytesCounts;
    [ObfuscationAttribute]
private short samplesPerPixel;
    [ObfuscationAttribute]
private int tilesCount;
    [ObfuscationAttribute]
private int photoMetric;
    private static object 0SE=;
    public string ImagePathFilename { get; public set; }
    public GeoTiffRasterSource(string imagePathFilename);
    public GeoTiffRasterSource(string imagePathFilename, string worldFilePathFilename);
    public GeoTiffRasterSource(string imagePathFilename, RectangleShape imageExtent);
    private static GeoTiffRasterSource();
    public string get_ImagePathFilename();
    public void set_ImagePathFilename(string value);
    protected virtual int GetImageWidthCore();
    protected virtual int GetImageHeightCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual GeoImage GetImageCore(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    private Dictionary`2<short, double> 0iE=(RectangleShape imageFullExtentInWorld);
    private Dictionary`2<short, double> 0yE=(RectangleShape imageFullExtentInWorld);
    private GeoImage 1CE=(int overlapUpLeftPointXInImage, int overlapUpLeftPointYInImage, int overlapWidthInImage, int overlapHeightInImage, int overlapWidthInScreen, int overlapHeightInScreen);
    private GeoImage 1CE=(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    private GeoImage 1SE=(int screenX, int screenY, int overlapWidth, int overlapHeight, int tempReturnWidth, int tempReturnHeight);
    private void 1iE=(object tileInfo);
    private WorldFile 1yE=();
    private void 2CE=();
}
public class ThinkGeo.Core.GettingAccessTokenEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private WebRequest wxQ=;
    [CompilerGeneratedAttribute]
private bool rBQ=;
    public WebRequest WebRequest { get; }
    public bool Cancel { get; public set; }
    public GettingAccessTokenEventArgs(WebRequest webRequest);
    public GettingAccessTokenEventArgs(WebRequest webRequest, bool cancel);
    [CompilerGeneratedAttribute]
public WebRequest get_WebRequest();
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
}
public class ThinkGeo.Core.GettingCacheImageBitmapTileCacheEventArgs : EventArgs {
    [ObfuscationAttribute]
private RasterTile bitmapTile;
    public RasterTile BitmapTile { get; public set; }
    public GettingCacheImageBitmapTileCacheEventArgs(RasterTile bitmapTile);
    public RasterTile get_BitmapTile();
    public void set_BitmapTile(RasterTile value);
}
public class ThinkGeo.Core.GettingCacheTileFileVectorTileCacheEventArgs : EventArgs {
    [ObfuscationAttribute]
private string tilePathFilename;
    [CompilerGeneratedAttribute]
private bool rBQ=;
    [CompilerGeneratedAttribute]
private VectorTile oys=;
    public string TilePathFilename { get; }
    public bool Cancel { get; public set; }
    public VectorTile AlternativeTile { get; public set; }
    public GettingCacheTileFileVectorTileCacheEventArgs(string tilePathFilename);
    public string get_TilePathFilename();
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
    [CompilerGeneratedAttribute]
public VectorTile get_AlternativeTile();
    [CompilerGeneratedAttribute]
public void set_AlternativeTile(VectorTile value);
}
public class ThinkGeo.Core.GettingColumnsFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    public Collection`1<FeatureSourceColumn> FeatureSourceColumns { get; }
    public bool Cancel { get; public set; }
    public Collection`1<FeatureSourceColumn> get_FeatureSourceColumns();
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.GettingFeaturesByIdsFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private Collection`1<Feature> features;
    [ObfuscationAttribute]
private Collection`1<string> ids;
    [ObfuscationAttribute]
private Collection`1<string> returningColumnNames;
    [ObfuscationAttribute]
private string filter;
    public string Filter { get; public set; }
    public bool Cancel { get; public set; }
    public Collection`1<string> ReturningColumnNames { get; }
    public Collection`1<Feature> Features { get; }
    public Collection`1<string> Ids { get; }
    public GettingFeaturesByIdsFeatureSourceEventArgs(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    public GettingFeaturesByIdsFeatureSourceEventArgs(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames, string filter);
    public string get_Filter();
    public void set_Filter(string value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Collection`1<string> get_ReturningColumnNames();
    public Collection`1<Feature> get_Features();
    public Collection`1<string> get_Ids();
}
public class ThinkGeo.Core.GettingFeaturesForDrawingFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private string filter;
    [ObfuscationAttribute]
private Collection`1<Feature> features;
    [ObfuscationAttribute]
private RectangleShape worldExtent;
    [ObfuscationAttribute]
private Collection`1<string> returningColumnNames;
    public Collection`1<string> ReturningColumnNames { get; }
    public string Filter { get; }
    public RectangleShape WorldExtent { get; public set; }
    public bool Cancel { get; public set; }
    public Collection`1<Feature> Features { get; }
    public GettingFeaturesForDrawingFeatureSourceEventArgs(RectangleShape worldExtent, IEnumerable`1<string> returningColumnNames);
    public GettingFeaturesForDrawingFeatureSourceEventArgs(RectangleShape worldExtent, IEnumerable`1<string> returningColumnNames, string filter);
    public Collection`1<string> get_ReturningColumnNames();
    public string get_Filter();
    public RectangleShape get_WorldExtent();
    public void set_WorldExtent(RectangleShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Collection`1<Feature> get_Features();
}
[ObfuscationAttribute]
internal enum ThinkGeo.Core.Gist_Ext_Id : Enum {
    public int value__;
    public static Gist_Ext_Id rt_point_ext_id;
    public static Gist_Ext_Id rt_rect_ext_id;
    public static Gist_Ext_Id gist_numext;
}
public class ThinkGeo.Core.GoogleMapsAsyncLayer : WebBasedAsyncLayer {
    private static RectangleShape IB4=;
    [ObfuscationAttribute]
private ProjectionConverter projectionFromSphericalMercator;
    [ObfuscationAttribute]
private ProjectionConverter googleWgs84Projection;
    [ObfuscationAttribute]
private double currentRequestSphereResolution;
    [CompilerGeneratedAttribute]
private GoogleMapsPictureFormat IR4=;
    [CompilerGeneratedAttribute]
private GoogleMapsMapType Ih4=;
    [CompilerGeneratedAttribute]
private string Ix4=;
    [CompilerGeneratedAttribute]
private string Ax4=;
    [CompilerGeneratedAttribute]
private string JB4=;
    [CompilerGeneratedAttribute]
private string JR4=;
    [CompilerGeneratedAttribute]
private string Jh4=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> Jx4=;
    [CompilerGeneratedAttribute]
private Projection KB4=;
    public GoogleMapsPictureFormat PictureFormat { get; public set; }
    public GoogleMapsMapType MapType { get; public set; }
    public string Language { get; public set; }
    public string ClientId { get; public set; }
    public string PrivateKey { get; public set; }
    public string UriSigningSecret { get; public set; }
    public string ApiKey { get; public set; }
    public Dictionary`2<string, string> CustomParameters { get; }
    public Projection TargetProjection { get; public set; }
    public GoogleMapsAsyncLayer(string apiKey);
    public GoogleMapsAsyncLayer(string apiKey, string uriSigningSecret);
    private static GoogleMapsAsyncLayer();
    [CompilerGeneratedAttribute]
public GoogleMapsPictureFormat get_PictureFormat();
    [CompilerGeneratedAttribute]
public void set_PictureFormat(GoogleMapsPictureFormat value);
    [CompilerGeneratedAttribute]
public GoogleMapsMapType get_MapType();
    [CompilerGeneratedAttribute]
public void set_MapType(GoogleMapsMapType value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_PrivateKey();
    [CompilerGeneratedAttribute]
public void set_PrivateKey(string value);
    [CompilerGeneratedAttribute]
public string get_UriSigningSecret();
    [CompilerGeneratedAttribute]
public void set_UriSigningSecret(string value);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_CustomParameters();
    [CompilerGeneratedAttribute]
public Projection get_TargetProjection();
    [CompilerGeneratedAttribute]
public void set_TargetProjection(Projection value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GoogleMapsAsyncLayer/MD8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GoogleMapsAsyncLayer/Kj8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GoogleMapsAsyncLayer/Lz8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.GoogleMapsAsyncLayer/Kz8=")]
protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    private RectangleShape KR4=(GeoCanvas canvas);
    private string Kh4=(double latitude, double longitude, int zoomLevelNumber, double tileWidth, double tileHeight, int scaleFactor);
    private static string Kx4=(double newWidth, double newHeight, int zoomLevelNumber, double latitude, double longitude);
    private string LB4=();
    public string GetPictureFormat();
    private string LR4=(string url);
    private string LR4=(string url, string uriSigningSecret);
    private static Byte[] Lh4=(string value);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task /h0=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /x0=(CancellationToken cancellationToken);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.GoogleMapsLayerImageCache : object {
    [ObfuscationAttribute]
private string cacheDirectory;
    public string 8SE= { get; public set; }
    public bool 8yE= { get; }
    public string 7yE=();
    public void 8CE=(string value);
    public bool 8iE=();
    public string 9CE=(GoogleMapsMapType mapType, int zoomlevel, int tileX, int tileY, GoogleMapsPictureFormat pictureFormat);
    public void 9SE=(GeoImage image, GoogleMapsMapType mapType, int zoomlevel, int tileX, int tileY, GoogleMapsPictureFormat pictureFormat);
    public GeoImage 9iE=(GoogleMapsMapType mapType, int zoomlevel, int tileX, int tileY, GoogleMapsPictureFormat pictureFormat);
    private static string LB4=(GoogleMapsMapType mapType);
    public static GeoImageFormat 9yE=(GoogleMapsPictureFormat pictureFormat);
    public static string /CE=(GoogleMapsPictureFormat pictureFormat);
}
public enum ThinkGeo.Core.GoogleMapsMapType : Enum {
    public int value__;
    public static GoogleMapsMapType RoadMap;
    public static GoogleMapsMapType Mobile;
    public static GoogleMapsMapType Satellite;
    public static GoogleMapsMapType Terrain;
    public static GoogleMapsMapType Hybrid;
}
public enum ThinkGeo.Core.GoogleMapsPictureFormat : Enum {
    public int value__;
    public static GoogleMapsPictureFormat Jpeg;
    public static GoogleMapsPictureFormat Gif;
    public static GoogleMapsPictureFormat Png8;
    public static GoogleMapsPictureFormat Png32;
}
public class ThinkGeo.Core.GoogleMapsZoomLevelSet : ZoomLevelSet {
    public GoogleMapsZoomLevelSet(int tileSize);
}
public static class ThinkGeo.Core.GoogleMapValidators : object {
    public static void CheckGoogleMapsTypeIsValid(GoogleMapsMapType mapType, string parameterName);
}
public class ThinkGeo.Core.GottenCacheImageBitmapTileCacheEventArgs : EventArgs {
    [ObfuscationAttribute]
private Tile tile;
    public Tile Tile { get; public set; }
    public GottenCacheImageBitmapTileCacheEventArgs(Tile tile);
    public Tile get_Tile();
    public void set_Tile(Tile value);
}
public class ThinkGeo.Core.GottenColumnsFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    public Collection`1<FeatureSourceColumn> FeatureSourceColumns { get; }
    public GottenColumnsFeatureSourceEventArgs(IEnumerable`1<FeatureSourceColumn> featureSourceColumns);
    public Collection`1<FeatureSourceColumn> get_FeatureSourceColumns();
}
public class ThinkGeo.Core.GottenFeatureValueClassBreakStyleEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature feature;
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private double newValue;
    public double Value { get; public set; }
    public Feature Feature { get; public set; }
    public string ColumnName { get; public set; }
    public GottenFeatureValueClassBreakStyleEventArgs(Feature feature, string columnName, double value);
    public double get_Value();
    public void set_Value(double value);
    public Feature get_Feature();
    public void set_Feature(Feature value);
    public string get_ColumnName();
    public void set_ColumnName(string value);
}
public class ThinkGeo.Core.GottenTileFileVectorTileCacheEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private VectorTile pCs=;
    public VectorTile Tile { get; public set; }
    public GottenTileFileVectorTileCacheEventArgs(VectorTile tile);
    [CompilerGeneratedAttribute]
public VectorTile get_Tile();
    [CompilerGeneratedAttribute]
public void set_Tile(VectorTile value);
}
public class ThinkGeo.Core.GpxFeatureLayer : FeatureLayer {
    public string GpxPathFilename { get; public set; }
    public bool HasBoundingBox { get; }
    public GpxFeatureLayer(string gpxPathFilename);
    public string get_GpxPathFilename();
    public void set_GpxPathFilename(string value);
    public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public virtual bool get_HasBoundingBox();
}
public class ThinkGeo.Core.GpxFeatureSource : FeatureSource {
    private static string DiI=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Dh8=;
    [ObfuscationAttribute]
private string gpxPathFilename;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private InMemoryFeatureSource source;
    [ObfuscationAttribute]
private Collection`1<Feature> segmentPoints;
    [ObfuscationAttribute]
private Dictionary`2<string, FeatureSourceColumn> tempColumns;
    [ObfuscationAttribute]
private Dictionary`2<string, string> metadata;
    public string GpxPathFilename { get; public set; }
    public GpxFeatureSource(string gpxPathFilename);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public string get_GpxPathFilename();
    public void set_GpxPathFilename(string value);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    public Dictionary`2<string, string> GetMetadata();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual long GetCountCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    private Feature DyI=(XElement wayPointNode);
    private Feature ECI=(XElement routeNode);
    private Feature ESI=(XElement trackNode);
    private LineShape EiI=(XElement trackSeg);
}
public class ThinkGeo.Core.GradientStyle : Style {
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private GeoColor lowerColor;
    [ObfuscationAttribute]
private double lowerValue;
    [ObfuscationAttribute]
private GeoColor noDataColor;
    [ObfuscationAttribute]
private double noDataValue;
    [ObfuscationAttribute]
private GeoColor upperColor;
    [ObfuscationAttribute]
private double upperValue;
    public string ColumnName { get; public set; }
    public double LowerValue { get; public set; }
    public GeoColor LowerColor { get; public set; }
    public double UpperValue { get; public set; }
    public GeoColor UpperColor { get; public set; }
    public double NoDataValue { get; public set; }
    public GeoColor NoDataColor { get; public set; }
    public GradientStyle(string columnName, double lowerValue, GeoColor lowerColor, double upperValue, GeoColor upperColor);
    public GradientStyle(string columnName, double lowerValue, GeoColor lowerColor, double upperValue, GeoColor upperColor, double noDataValue, GeoColor noDataColor);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public double get_LowerValue();
    public void set_LowerValue(double value);
    public GeoColor get_LowerColor();
    public void set_LowerColor(GeoColor value);
    public double get_UpperValue();
    public void set_UpperValue(double value);
    public GeoColor get_UpperColor();
    public void set_UpperColor(GeoColor value);
    public double get_NoDataValue();
    public void set_NoDataValue(double value);
    public GeoColor get_NoDataColor();
    public void set_NoDataColor(GeoColor value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private GeoColor 0zE=(GeoColor lowerColor, GeoColor upperColor, double value);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
}
public class ThinkGeo.Core.GraticuleFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private GraticuleFeatureSource graticuleFeatureSource;
    [ObfuscationAttribute]
private LineStyle graticuleLineStyle;
    [ObfuscationAttribute]
private GeoFont graticuleTextFont;
    [ObfuscationAttribute]
private GeoBrush graticuleTextBrush;
    [ObfuscationAttribute]
private GeoPen graticuleTextHaloPen;
    public LineStyle GraticuleLineStyle { get; public set; }
    public GeoFont GraticuleTextFont { get; public set; }
    public GeoBrush GraticuleTextBrush { get; public set; }
    public WrappingMode WrappingMode { get; public set; }
    public RectangleShape WrappingExtent { get; public set; }
    public GeoPen GraticuleTextHaloPen { get; public set; }
    public GraticuleFeatureLayer(int graticuleDensity);
    public LineStyle get_GraticuleLineStyle();
    public void set_GraticuleLineStyle(LineStyle value);
    public GeoFont get_GraticuleTextFont();
    public void set_GraticuleTextFont(GeoFont value);
    public GeoBrush get_GraticuleTextBrush();
    public void set_GraticuleTextBrush(GeoBrush value);
    public WrappingMode get_WrappingMode();
    public void set_WrappingMode(WrappingMode value);
    public RectangleShape get_WrappingExtent();
    public void set_WrappingExtent(RectangleShape value);
    public GeoPen get_GraticuleTextHaloPen();
    public void set_GraticuleTextHaloPen(GeoPen value);
    protected virtual bool IsDrawingNeededCore(double currentScale);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.GraticuleFeatureSource : FeatureSource {
    [ObfuscationAttribute]
private FeatureSourceColumn graticuleLabelColumn;
    private int JCI=;
    [ObfuscationAttribute]
private WrappingMode wrappingMode;
    private Collection`1<double> JSI=;
    [ObfuscationAttribute]
private RectangleShape wrappingExtent;
    private static Collection`1<double> JiI=;
    private static Collection`1<double> JyI=;
    internal FeatureSourceColumn KSI= { get; }
    public WrappingMode WrappingMode { get; public set; }
    public RectangleShape WrappingExtent { get; public set; }
    public int GraticuleDensity { get; public set; }
    private static GraticuleFeatureSource();
    internal FeatureSourceColumn KCI=();
    public WrappingMode get_WrappingMode();
    public void set_WrappingMode(WrappingMode value);
    public RectangleShape get_WrappingExtent();
    public void set_WrappingExtent(RectangleShape value);
    public int get_GraticuleDensity();
    public void set_GraticuleDensity(int value);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    internal Collection`1<Feature> KiI=(RectangleShape extent, float scaleFactor);
    internal Collection`1<Feature> KyI=(RectangleShape extent, float scaleFcator);
    private Collection`1<Feature> LCI=(RectangleShape extent, double currentMinX, double currentMaxX, double currentMaxY, double currentMinY, double increment, double dividor);
    private Collection`1<Feature> LSI=(RectangleShape extent, double currentMinX, double currentMaxX, double currentMaxY, double currentMinY, double increment, double dividor);
    private Vertex LiI=(double x, double y, bool isWrappingLeft);
    private EyI= LyI=(RectangleShape extent);
    private RectangleShape MCI=(RectangleShape extent);
    private static double MSI=(Collection`1<double> values);
    private static double MiI=(Collection`1<double> values);
    private double MyI=(RectangleShape currentExtentWidth, double divisor, GeographyUnit mapUnit);
    private static string NCI=(double value, OyI= lineType, double increment);
    private static double NSI=(double number, double interval);
    private static double NiI=(double number, double interval);
    private void NyI=();
    [CompilerGeneratedAttribute]
private Feature OCI=(Feature f);
}
public class ThinkGeo.Core.GridCell : object {
    [ObfuscationAttribute]
private double centerX;
    [ObfuscationAttribute]
private double centerY;
    [ObfuscationAttribute]
private double value;
    [ObfuscationAttribute]
private double weight;
    public double CenterX { get; public set; }
    public double CenterY { get; public set; }
    public double Value { get; public set; }
    public double Weight { get; public set; }
    public GridCell(double centerX, double centerY, double value);
    public GridCell(double centerX, double centerY, double value, double weight);
    public double get_CenterX();
    public void set_CenterX(double value);
    public double get_CenterY();
    public void set_CenterY(double value);
    public double get_Value();
    public void set_Value(double value);
    public double get_Weight();
    public void set_Weight(double value);
    public virtual int GetHashCode();
}
public class ThinkGeo.Core.GridDefinition : object {
    [ObfuscationAttribute]
private RectangleShape gridExtent;
    [ObfuscationAttribute]
private Dictionary`2<PointShape, double> dataPoints;
    [ObfuscationAttribute]
private double cellSize;
    [ObfuscationAttribute]
private double noDataValue;
    [CompilerGeneratedAttribute]
private FeatureSource giI=;
    [CompilerGeneratedAttribute]
private string gyI=;
    public FeatureSource DataPointsFeatureSource { get; public set; }
    public string DataPointsFeatureSourceColumnName { get; public set; }
    public RectangleShape GridExtent { get; public set; }
    public Dictionary`2<PointShape, double> DataPoints { get; }
    public double CellSize { get; public set; }
    public double NoDataValue { get; public set; }
    public GridDefinition(RectangleShape gridExtent, double cellSize, double noDataValue, Dictionary`2<PointShape, double> dataPoints);
    [CompilerGeneratedAttribute]
public FeatureSource get_DataPointsFeatureSource();
    [CompilerGeneratedAttribute]
public void set_DataPointsFeatureSource(FeatureSource value);
    [CompilerGeneratedAttribute]
public string get_DataPointsFeatureSourceColumnName();
    [CompilerGeneratedAttribute]
public void set_DataPointsFeatureSourceColumnName(string value);
    public RectangleShape get_GridExtent();
    public void set_GridExtent(RectangleShape value);
    public Dictionary`2<PointShape, double> get_DataPoints();
    public double get_CellSize();
    public void set_CellSize(double value);
    public double get_NoDataValue();
    public void set_NoDataValue(double value);
}
public class ThinkGeo.Core.GridFeatureLayer : FeatureLayer {
    public string PathFilename { get; public set; }
    public double CellSize { get; }
    public int NumberOfColumns { get; }
    public int NumberOfRows { get; }
    public double NoDataValue { get; }
    public bool HasBoundingBox { get; }
    public string DataValueColumnName { get; }
    public GridFeatureLayer(string gridPathFilename);
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public double get_CellSize();
    public int get_NumberOfColumns();
    public int get_NumberOfRows();
    public double get_NoDataValue();
    public virtual bool get_HasBoundingBox();
    public string get_DataValueColumnName();
    protected virtual RectangleShape GetBoundingBoxCore();
    public static void GenerateGrid(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel, Stream outputStream, Func`2<double, string> cellValueToStringFunc);
    public static GridCell[0...,0...] GenerateGridMatrix(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel);
    public GridCell[0...,0...] GenerateGridMatrix();
    public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
}
public class ThinkGeo.Core.GridFeatureSource : FeatureSource {
    private static string PiI=;
    [ObfuscationAttribute]
private double cellSize;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    [ObfuscationAttribute]
private RectangleShape gridExtent;
    [ObfuscationAttribute]
private string pathFilename;
    [ObfuscationAttribute]
private PointShape lowerLeftPoint;
    [ObfuscationAttribute]
private double noDataValue;
    [ObfuscationAttribute]
private int columnCount;
    [ObfuscationAttribute]
private int rowCount;
    [ObfuscationAttribute]
private string gridValuesString;
    [ObfuscationAttribute]
private int gridValuesDimension0Length;
    [ObfuscationAttribute]
private int gridValuesDimension1Length;
    private bool oBo=;
    private Double[0...,0...] PyI=;
    [CompilerGeneratedAttribute]
private static EventHandler`1<GeneratingGridFeatureSourceEventArgs> QCI=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Dh8=;
    private static Byte[] QSI=;
    public string PathFilename { get; public set; }
    public double CellSize { get; }
    public int NumberOfColumns { get; }
    public int NumberOfRows { get; }
    public PointShape LowerLeftPoint { get; }
    public double NoDataValue { get; }
    public bool IsEditable { get; }
    public string DataValueColumnName { get; }
    public GridFeatureSource(string gridPathFilename);
    private static GridFeatureSource();
    [CompilerGeneratedAttribute]
public static void add_GeneratingGrid(EventHandler`1<GeneratingGridFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_GeneratingGrid(EventHandler`1<GeneratingGridFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public double get_CellSize();
    public int get_NumberOfColumns();
    public int get_NumberOfRows();
    public PointShape get_LowerLeftPoint();
    public double get_NoDataValue();
    public virtual bool get_IsEditable();
    public string get_DataValueColumnName();
    protected virtual void OpenCore();
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    protected virtual void CloseCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    private Byte[] QiI=(double x1, double y1, double x2, double y2);
    private static String[] QyI=(string stringToSplit);
    public static GridCell[0...,0...] GenerateGridMatrix(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel);
    public GridCell[0...,0...] GenerateGridMatrix();
    public static GridCell[0...,0...] ReplaceNoDataValue(GridCell[0...,0...] gridMatrix, double noDataValue);
    public static GridCell[0...,0...] ReplaceNoDataValue(GridCell[0...,0...] gridMatrix, double noDataValue, GridInterpolationModel gridInterpolationModel);
    public static void GenerateGrid(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel, Stream outputStream, Func`2<double, string> cellValueToStringFunc);
    public static void SaveGridsToStream(GridCell[0...,0...] cells, double noDataValue, Stream outputStream, Func`2<double, string> cellValueToStringFunc);
    public static void SaveGridsToGrdFile(GridCell[0...,0...] cells, double noDataValue, string outputFilePath, Func`2<double, string> cellValueToStringFunc);
    [OnGeoserializingAttribute]
private void RCI=();
    [OnGeodeserializedAttribute]
private void RSI=();
    private void RiI=();
    private static void RyI=(GeneratingGridFeatureSourceEventArgs e);
}
public abstract class ThinkGeo.Core.GridInterpolationModel : object {
    public ValueTuple`2<double, double> Interpolate(RectangleShape cellExtent, GridDefinition gridDefinition);
    protected abstract virtual ValueTuple`2<double, double> InterpolateCore(RectangleShape cellExtent, GridDefinition gridDefinition);
}
public class ThinkGeo.Core.GridIsoLineLayer : IsoLineLayer {
    [ObfuscationAttribute]
private GridFeatureSource gridFeatureSource;
    [ObfuscationAttribute]
private Collection`1<Feature> cachedIsoLines;
    [ObfuscationAttribute]
private int previousGridMatrixCount;
    [ObfuscationAttribute]
private int previousGridMatrixHashCode;
    [ObfuscationAttribute]
private int previousIsoLineLevelsCount;
    [ObfuscationAttribute]
private int previousIsoLineLevelsHashCode;
    [ObfuscationAttribute]
private string previousDataValueColumnName;
    [ObfuscationAttribute]
private string gridMatrixString;
    [ObfuscationAttribute]
private int gridMatrixDimension0Length;
    [ObfuscationAttribute]
private int gridMatrixDimension1Length;
    private bool oBo=;
    private GridCell[0...,0...] 6CI=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Dh8=;
    public string GridPathFilename { get; public set; }
    public GridIsoLineLayer(string gridPathFilename);
    public GridIsoLineLayer(string gridPathFilename, IEnumerable`1<double> isoLineLevels);
    public GridIsoLineLayer(string gridPathFilename, IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale);
    public GridIsoLineLayer(string gridPathFilename, IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale, IsoLineType isoLineType);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    private void 6SI=(object sender, StreamLoadingEventArgs e);
    [OnGeoserializingAttribute]
private void RCI=();
    [OnGeodeserializedAttribute]
private void RSI=();
    protected virtual void OpenCore();
    public string get_GridPathFilename();
    public void set_GridPathFilename(string value);
    public Collection`1<Feature> GetIsoLineFeatures();
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private bool 6iI=();
    private void 6yI=();
}
public class ThinkGeo.Core.GroupLayer : Layer {
    [ObfuscationAttribute]
private GeoCollection`1<Layer> layers;
    public GeoCollection`1<Layer> Layers { get; }
    public bool HasBoundingBox { get; }
    public GroupLayer(IEnumerable`1<Layer> layers);
    public GeoCollection`1<Layer> get_Layers();
    public virtual bool get_HasBoundingBox();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.HeaderPage : RTPage {
    [ObfuscationAttribute]
private FileHeader fileHeader;
    public FileHeader lx8= { get; public set; }
    public HeaderPage(RtreeFile rtFile);
    public HeaderPage(RtreeFile rtFile, UInt32 pageNo, Gist_Ext_Id extId);
    public FileHeader lR8=();
    public void lh8=(FileHeader value);
    public bool oBw=();
    public bool rhw=();
    public virtual string jR8=();
}
public class ThinkGeo.Core.HeatStyle : Style {
    [ObfuscationAttribute]
private int alpha;
    [ObfuscationAttribute]
private Collection`1<GeoColor> colorPalette;
    [ObfuscationAttribute]
private string intensityColumnName;
    [ObfuscationAttribute]
private double intensityRangeEnd;
    [ObfuscationAttribute]
private double intensityRangeStart;
    [ObfuscationAttribute]
private int pointIntensity;
    [ObfuscationAttribute]
private double pointRadius;
    [ObfuscationAttribute]
private DistanceUnit pointRadiusUnit;
    private static int jCI=;
    public int PointIntensity { get; public set; }
    public int Alpha { get; public set; }
    public double IntensityRangeStart { get; public set; }
    public double IntensityRangeEnd { get; public set; }
    public string IntensityColumnName { get; public set; }
    public double PointRadius { get; public set; }
    public DistanceUnit PointRadiusUnit { get; public set; }
    public Collection`1<GeoColor> ColorPalette { get; }
    public HeatStyle(int pointIntensity);
    public HeatStyle(int pointIntensity, int alpha);
    public HeatStyle(int pointIntensity, double pointRadius, DistanceUnit pointRadiusUnit);
    public HeatStyle(int pointIntensity, int alpha, double pointRadius, DistanceUnit pointRadiusUnit);
    public HeatStyle(string intensityColumnName, double intensityRangeStart, double intensityRangeEnd);
    public HeatStyle(int alpha, string intensityColumnName, double intensityRangeStart, double intensityRangeEnd);
    public HeatStyle(string intensityColumnName, double intensityRangeStart, double intensityRangeEnd, double pointRadius, DistanceUnit pointRadiusUnit);
    public HeatStyle(int alpha, string intensityColumnName, double intensityRangeStart, double intensityRangeEnd, double pointRadius, DistanceUnit pointRadiusUnit);
    public HeatStyle(int pointIntensity, int alpha, string intensityColumnName, double intensityRangeStart, double intensityRangeEnd, double pointRadius, DistanceUnit pointRadiusUnit, GeoColor baseColor);
    public HeatStyle(int pointIntensity, int alpha, string intensityColumnName, double intensityRangeStart, double intensityRangeEnd, double pointRadius, DistanceUnit pointRadiusUnit, GeoColor fromColor, GeoColor toColor, ColorWheelDirection colorWheelDirection);
    private static HeatStyle();
    public int get_PointIntensity();
    public void set_PointIntensity(int value);
    public int get_Alpha();
    public void set_Alpha(int value);
    public double get_IntensityRangeStart();
    public void set_IntensityRangeStart(double value);
    public double get_IntensityRangeEnd();
    public void set_IntensityRangeEnd(double value);
    public string get_IntensityColumnName();
    public void set_IntensityColumnName(string value);
    public double get_PointRadius();
    public void set_PointRadius(double value);
    public DistanceUnit get_PointRadiusUnit();
    public void set_PointRadiusUnit(DistanceUnit value);
    public Collection`1<GeoColor> get_ColorPalette();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    private float jSI=(GeoCanvas canvas);
    private static double jiI=(string value, double lowValue, double highValue);
    private static double jyI=(double degrees);
    private static lxU=[] kCI=(byte alpha, Collection`1<GeoColor> colorPalette);
}
public class ThinkGeo.Core.HereMapsRasterTileAsyncLayer : XyzTileAsyncLayer {
    private static int 9B0=;
    private static string Lx4=;
    private string MB4=;
    private string MR4=;
    private string Mh4=;
    [CompilerGeneratedAttribute]
private string Jh4=;
    [CompilerGeneratedAttribute]
private HereMapsRasterType Ih4=;
    [CompilerGeneratedAttribute]
private HereMapsRasterTileFormat Mx4=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> NB4=;
    public string ApiKey { get; public set; }
    public HereMapsRasterType MapType { get; public set; }
    public HereMapsRasterTileFormat Format { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public HereMapsRasterTileAsyncLayer(string apiKey);
    public HereMapsRasterTileAsyncLayer(string apiKey, HereMapsRasterType mapType);
    [CompilerGeneratedAttribute]
public string get_ApiKey();
    [CompilerGeneratedAttribute]
public void set_ApiKey(string value);
    [CompilerGeneratedAttribute]
public HereMapsRasterType get_MapType();
    [CompilerGeneratedAttribute]
public void set_MapType(HereMapsRasterType value);
    [CompilerGeneratedAttribute]
public HereMapsRasterTileFormat get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(HereMapsRasterTileFormat value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Parameters();
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
}
public enum ThinkGeo.Core.HereMapsRasterTileFormat : Enum {
    public int value__;
    public static HereMapsRasterTileFormat Png;
    public static HereMapsRasterTileFormat Png8;
    public static HereMapsRasterTileFormat Jpg;
}
public enum ThinkGeo.Core.HereMapsRasterType : Enum {
    public int value__;
    public static HereMapsRasterType BaseMap;
    public static HereMapsRasterType Aerial;
    public static HereMapsRasterType Hybrid;
}
public class ThinkGeo.Core.HereMapsZoomLevelSet : ZoomLevelSet {
}
public class ThinkGeo.Core.HueFamilyAreaStyle : AreaStyle {
    [ObfuscationAttribute]
private Collection`1<AreaStyle> areaStyles;
    [ObfuscationAttribute]
private Dictionary`2<string, AreaStyle> cache;
    [ObfuscationAttribute]
private int numberOfColors;
    public int NumberOfColors { get; public set; }
    public Dictionary`2<string, AreaStyle> Cache { get; }
    public GeoColor BaseColor { get; public set; }
    public HueFamilyAreaStyle(GeoPen outlinePen, GeoColor baseColor, int numberOfColors);
    public HueFamilyAreaStyle(GeoPen outlinePen, GeoColor baseColor, int numberOfColors, PenBrushDrawingOrder penBrushDrawingOrder);
    public int get_NumberOfColors();
    public void set_NumberOfColors(int value);
    public Dictionary`2<string, AreaStyle> get_Cache();
    public GeoColor get_BaseColor();
    public void set_BaseColor(GeoColor value);
    public void ClearCache();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.IconStyle : TextStyle {
    [ObfuscationAttribute]
private GeoImage iconImage;
    [ObfuscationAttribute]
private double iconImageScale;
    [ObfuscationAttribute]
private string iconPathFilename;
    public string IconPathFilename { get; public set; }
    public GeoImage IconImage { get; public set; }
    public double IconImageScale { get; public set; }
    public bool SuppressPartialLabels { get; public set; }
    private bool 2DE= { get; }
    public IconStyle(string iconPathFilename, string textColumnName, GeoFont textFont, GeoBrush textBrush);
    public IconStyle(GeoImage iconImage, string textColumnName, GeoFont textFont, GeoBrush textBrush);
    public string get_IconPathFilename();
    public void set_IconPathFilename(string value);
    public GeoImage get_IconImage();
    public void set_IconImage(GeoImage value);
    public double get_IconImageScale();
    public void set_IconImageScale(double value);
    public bool get_SuppressPartialLabels();
    public void set_SuppressPartialLabels(bool value);
    private bool 1zE=();
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<LabelingCandidate> GetLabelingCandidateCore(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private void 2TE=(GeoImage imageForIcon, Feature feature, GeoCanvas canvas, int imageWidth, int imageHeight, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static RectangleShape 2jE=(PointShape centerPoint, int imageWidth, int imageHeight);
}
public class ThinkGeo.Core.IconValueItem : object {
    [ObfuscationAttribute]
private string fieldValue;
    [ObfuscationAttribute]
private string iconFilePathName;
    [ObfuscationAttribute]
private GeoImage iconImage;
    [ObfuscationAttribute]
private TextStyle textStyle;
    [ObfuscationAttribute]
private int textValueLengthMin;
    [ObfuscationAttribute]
private int textValueLengthMax;
    public TextStyle TextStyle { get; public set; }
    public string FieldValue { get; public set; }
    public string IconFilePathName { get; public set; }
    public int TextValueLengthMin { get; public set; }
    public int TextValueLengthMax { get; public set; }
    public IconValueItem(string fieldValue, string iconPathFilename, TextStyle textStyle);
    public IconValueItem(string fieldValue, GeoImage iconImage, TextStyle textStyle);
    public TextStyle get_TextStyle();
    public void set_TextStyle(TextStyle value);
    public string get_FieldValue();
    public void set_FieldValue(string value);
    public string get_IconFilePathName();
    public void set_IconFilePathName(string value);
    public int get_TextValueLengthMin();
    public void set_TextValueLengthMin(int value);
    public int get_TextValueLengthMax();
    public void set_TextValueLengthMax(int value);
    public GeoImage GetIconImage();
}
public class ThinkGeo.Core.IconValueStyle : PositionStyle {
    private static double 1DE=;
    private static int 1TE=;
    private static double 1jE=;
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private Dictionary`2<int, GeoImage> geoImageCache;
    [ObfuscationAttribute]
private Dictionary`2<int, int> geoImageHeightCache;
    [ObfuscationAttribute]
private Dictionary`2<int, int> geoImageWidthCache;
    [ObfuscationAttribute]
private Collection`1<IconValueItem> iconValueItems;
    [ObfuscationAttribute]
private int previousValueItemId;
    public string ColumnName { get; public set; }
    public Collection`1<IconValueItem> IconValueItems { get; }
    private bool 2DE= { get; }
    public IconValueStyle(string columnName);
    public IconValueStyle(string columnName, IEnumerable`1<IconValueItem> iconValueItems);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public Collection`1<IconValueItem> get_IconValueItems();
    private bool 1zE=();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual Collection`1<LabelingCandidate> GetLabelingCandidateCore(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private void 2TE=(Feature feature, GeoCanvas canvas, GeoFont font, GeoBrush textBrush, GeoPen haloPen, DrawingLevel drawingLevel, float xOffsetInPixel, float yOffsetInPixel, DrawingTextAlignment alignment, double rotationAngle, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static RectangleShape 2jE=(PointShape centerPoint, int imageWidth, int imageHeight);
    private int 2zE=(Feature feature, GeoCanvas canvas);
    private void 3DE=(TextStyle textStyle);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.IdsEngine : object {
    [ObfuscationAttribute]
private int recordLength;
    [ObfuscationAttribute]
private int headerLength;
    private static int 3x4=;
    private static int mh8=;
    private Stream mx8=;
    private Stream nB8=;
    [ObfuscationAttribute]
private IdsRecord idsRecord;
    [ObfuscationAttribute]
private IdsHeader idsHeader;
    [ObfuscationAttribute]
private Byte[] cache;
    [ObfuscationAttribute]
private int startIndex;
    [ObfuscationAttribute]
private int endIndex;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Dh8=;
    [CompilerGeneratedAttribute]
public void nR8=(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void nh8=(EventHandler`1<StreamLoadingEventArgs> value);
    internal virtual void oB8=(StreamLoadingEventArgs e);
    public bool FR8=(string fileName, FileAccess readWriteMode);
    public void oR8=();
    public void fx8=();
    public string oh8=(int block);
    public void ox8=();
    public int pB8=(string id);
    public static void pR8=(string fileName);
    private static Byte[] ph8=(int intValue, byte byteOrder);
}
public interface ThinkGeo.Core.IGeoCanvasRotatable {
    public double RotationAngle { get; public set; }
    public double PivotX { get; public set; }
    public double PivotY { get; public set; }
    public abstract virtual double get_RotationAngle();
    public abstract virtual void set_RotationAngle(double value);
    public abstract virtual double get_PivotX();
    public abstract virtual void set_PivotX(double value);
    public abstract virtual double get_PivotY();
    public abstract virtual void set_PivotY(double value);
}
public class ThinkGeo.Core.InMemoryFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    public Collection`1<FeatureSourceColumn> Columns { get; }
    public GeoCollection`1<Feature> InternalFeatures { get; }
    public bool HasBoundingBox { get; }
    public InMemoryFeatureLayer(IEnumerable`1<FeatureSourceColumn> featureSourceColumns);
    public InMemoryFeatureLayer(IEnumerable`1<FeatureSourceColumn> featureSourceColumns, IEnumerable`1<Feature> features);
    public InMemoryFeatureLayer(IEnumerable`1<FeatureSourceColumn> featureSourceColumns, IEnumerable`1<BaseShape> shapes);
    public Collection`1<FeatureSourceColumn> get_Columns();
    public GeoCollection`1<Feature> get_InternalFeatures();
    public virtual bool get_HasBoundingBox();
    public Collection`1<FeatureSourceColumn> GetColumns();
    protected virtual void OpenCore();
    public void BuildIndex();
    public void Clear();
}
public class ThinkGeo.Core.InMemoryFeatureSource : FeatureSource {
    private static string XyA=;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> columns;
    [ObfuscationAttribute]
private GeoCollection`1<Feature> internalFeatures;
    private STRtree`1<string> YCA=;
    internal Collection`1<FeatureSourceColumn> YiA= { get; }
    public GeoCollection`1<Feature> InternalFeatures { get; }
    public bool IsEditable { get; }
    protected bool CanExecuteSqlQueryCore { get; }
    public InMemoryFeatureSource(IEnumerable`1<FeatureSourceColumn> featureSourceColumns);
    public InMemoryFeatureSource(IEnumerable`1<FeatureSourceColumn> featureSourceColumns, IEnumerable`1<Feature> features);
    public InMemoryFeatureSource(IEnumerable`1<FeatureSourceColumn> featureSourceColumns, IEnumerable`1<BaseShape> shapes);
    internal Collection`1<FeatureSourceColumn> YSA=();
    public GeoCollection`1<Feature> get_InternalFeatures();
    public virtual bool get_IsEditable();
    protected virtual bool get_CanExecuteSqlQueryCore();
    private void YyA=(IEnumerable`1<FeatureSourceColumn> featureSourceColumns, IEnumerable`1<Feature> features);
    public void BuildIndex();
    public void Clear();
    protected virtual long GetCountCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    private void ZCA=(Collection`1<FeatureSourceColumn> addBuffer, TransactionResult transactionResult);
    private void ZSA=(Dictionary`2<string, Feature> addBuffer, TransactionResult transactionResult);
    private void ZiA=(Collection`1<string> deleteBuffer, TransactionResult transactionResult);
    private void ZyA=(Collection`1<string> deleteBuffer, TransactionResult transactionResult);
    private void aCA=(Dictionary`2<string, FeatureSourceColumn> editBuffer, TransactionResult transactionResult);
    private void aSA=(Dictionary`2<string, Feature> editBuffer, TransactionResult transactionResult);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    internal Collection`1<Feature> aiA=(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    private Collection`1<Feature> ayA=(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> bCA=(RectangleShape extent, IEnumerable`1<string> returningColumnNames);
    private void bSA=(Feature feature, IEnumerable`1<string> returningColumnNames);
}
public class ThinkGeo.Core.InMemoryGridFeatureLayer : FeatureLayer {
    public GridCell[0...,0...] GridMatrix { get; public set; }
    public double CellSize { get; }
    public int ColumnCount { get; }
    public int RowCount { get; }
    public double NoDataValue { get; }
    public bool HasBoundingBox { get; }
    public string DataValueColumnName { get; }
    public string DataWeightColumnName { get; }
    public InMemoryGridFeatureLayer(GridCell[0...,0...] gridMatrix);
    public GridCell[0...,0...] get_GridMatrix();
    public void set_GridMatrix(GridCell[0...,0...] value);
    public double get_CellSize();
    public int get_ColumnCount();
    public int get_RowCount();
    public double get_NoDataValue();
    public virtual bool get_HasBoundingBox();
    public string get_DataValueColumnName();
    public string get_DataWeightColumnName();
    protected virtual RectangleShape GetBoundingBoxCore();
    public static void GenerateGrid(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel, Stream outputStream, Func`2<double, string> cellValueToStringFunc);
    public static GridCell[0...,0...] GenerateGridMatrix(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel);
    public GridCell[0...,0...] GenerateGridMatrix();
}
public class ThinkGeo.Core.InMemoryGridFeatureSource : FeatureSource {
    private static string PiI=;
    private static string iCI=;
    [ObfuscationAttribute]
private double cellSize;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> featureSourceColumns;
    [ObfuscationAttribute]
private RectangleShape gridExtent;
    [ObfuscationAttribute]
private PointShape lowerLeftPoint;
    [ObfuscationAttribute]
private double noDataValue;
    [ObfuscationAttribute]
private int columnCount;
    [ObfuscationAttribute]
private int rowCount;
    [ObfuscationAttribute]
private GridCell[0...,0...] gridMatrix;
    public GridCell[0...,0...] GridMatrix { get; public set; }
    public double CellSize { get; }
    public int ColumnCount { get; }
    public int RowCount { get; }
    public PointShape LowerLeftPoint { get; }
    public double NoDataValue { get; }
    public bool IsEditable { get; }
    public string DataValueColumnName { get; }
    public string DataWeightColumnName { get; }
    public InMemoryGridFeatureSource(GridCell[0...,0...] gridMatrix);
    public GridCell[0...,0...] get_GridMatrix();
    public void set_GridMatrix(GridCell[0...,0...] value);
    public double get_CellSize();
    public int get_ColumnCount();
    public int get_RowCount();
    public PointShape get_LowerLeftPoint();
    public double get_NoDataValue();
    public virtual bool get_IsEditable();
    public string get_DataValueColumnName();
    public string get_DataWeightColumnName();
    protected virtual void OpenCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public static GridCell[0...,0...] GenerateGridMatrix(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel);
    public static void GenerateGrid(GridDefinition gridDefinition, GridInterpolationModel gridInterpolationModel, Stream outputStream, Func`2<double, string> cellValueToStringFunc);
    private void iSI=();
}
public class ThinkGeo.Core.InMemoryGridIsoLineLayer : IsoLineLayer {
    [ObfuscationAttribute]
private Collection`1<Feature> cachedIsoLines;
    [ObfuscationAttribute]
private int previousGridMatrixCount;
    [ObfuscationAttribute]
private int previousGridMatrixHashCode;
    [ObfuscationAttribute]
private int previousIsoLineLevelsCount;
    [ObfuscationAttribute]
private int previousIsoLineLevelsHashCode;
    [ObfuscationAttribute]
private string previousDataValueColumnName;
    [ObfuscationAttribute]
private string gridMatrixString;
    [ObfuscationAttribute]
private int gridMatrixDimension0Length;
    [ObfuscationAttribute]
private int gridMatrixDimension1Length;
    private GridCell[0...,0...] 6CI=;
    public GridCell[0...,0...] GridMatrix { get; public set; }
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, double noDataValue);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, double noDataValue);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale, double noDataValue);
    public InMemoryGridIsoLineLayer(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale, double noDataValue, IsoLineType isoLineType);
    public GridCell[0...,0...] get_GridMatrix();
    public void set_GridMatrix(GridCell[0...,0...] value);
    [OnGeoserializingAttribute]
private void RCI=();
    [OnGeodeserializedAttribute]
private void RSI=();
    public Collection`1<Feature> GetIsoLineFeatures();
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private bool 6iI=();
    private void 6yI=();
}
public class ThinkGeo.Core.InMemoryRasterTileCache : RasterTileCache {
    [ObfuscationAttribute]
private GeoCollection`1<RasterTile> cachedTiles;
    [ObfuscationAttribute]
private int maximumTilesCount;
    public int MaximumTilesCount { get; public set; }
    public int get_MaximumTilesCount();
    public void set_MaximumTilesCount(int value);
    protected virtual Tile GetTileCore(int zoom, long column, long row);
    protected virtual void SaveTileCore(Tile tile);
    protected virtual void DeleteTileCore(Tile tile);
    protected virtual void ClearCacheCore();
}
public class ThinkGeo.Core.InsertedGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    [ObfuscationAttribute]
private int index;
    public object Item { get; public set; }
    public int Index { get; public set; }
    public InsertedGeoCollectionEventArgs(object item);
    public InsertedGeoCollectionEventArgs(object item, int index);
    public object get_Item();
    public void set_Item(object value);
    public int get_Index();
    public void set_Index(int value);
}
public class ThinkGeo.Core.InsertingGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    public object Item { get; public set; }
    public InsertingGeoCollectionEventArgs(object item);
    public object get_Item();
    public void set_Item(object value);
}
public class ThinkGeo.Core.InverseDistanceWeightedGridInterpolationModel : GridInterpolationModel {
    [ObfuscationAttribute]
private double power;
    [ObfuscationAttribute]
private double searchRadius;
    private static double hCI=;
    public double Power { get; public set; }
    public double SearchRadius { get; public set; }
    public InverseDistanceWeightedGridInterpolationModel(double power, double searchRadius);
    public double get_Power();
    public void set_Power(double value);
    public double get_SearchRadius();
    public void set_SearchRadius(double value);
    protected virtual ValueTuple`2<double, double> InterpolateCore(RectangleShape cellExtent, GridDefinition gridDefinition);
    private double hSI=(RectangleShape cellExtent, GridDefinition gridDefinition);
    private ValueTuple`2<double, double> hiI=(PointShape point, GridDefinition gridDefinition);
    private ValueTuple`2<double, double> hyI=(PointShape point, Dictionary`2<PointShape, double> dataPoints, double noDataValue);
}
public abstract class ThinkGeo.Core.IsoLineLayer : Layer {
    [ObfuscationAttribute]
private Collection`1<double> isoLineLevels;
    [ObfuscationAttribute]
private string dataValueColumnName;
    [ObfuscationAttribute]
private double lowerScale;
    [ObfuscationAttribute]
private double upperScale;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    [ObfuscationAttribute]
private IsoLineType isoLineType;
    [ObfuscationAttribute]
private double noDataValue;
    public double NoDataValue { get; public set; }
    public double UpperScale { get; public set; }
    public double LowerScale { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    public string DataValueColumnName { get; public set; }
    public Collection`1<double> IsoLineLevels { get; public set; }
    public IsoLineType IsoLineType { get; public set; }
    protected IsoLineLayer(IEnumerable`1<double> isoLineLevels);
    protected IsoLineLayer(IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale);
    protected IsoLineLayer(IEnumerable`1<double> isoLineLevels, double lowerScale, double upperScale, IsoLineType isoLineType);
    public double get_NoDataValue();
    public void set_NoDataValue(double value);
    public double get_UpperScale();
    public void set_UpperScale(double value);
    public double get_LowerScale();
    public void set_LowerScale(double value);
    public Collection`1<Style> get_CustomStyles();
    public string get_DataValueColumnName();
    public void set_DataValueColumnName(string value);
    public Collection`1<double> get_IsoLineLevels();
    public void set_IsoLineLevels(Collection`1<double> value);
    public IsoLineType get_IsoLineType();
    public void set_IsoLineType(IsoLineType value);
    protected abstract virtual Collection`1<Feature> GetFeaturesForDrawingCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void OpenCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    public static Collection`1<Feature> GetIsoFeatures(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, string dataValueColumnName, IsoLineType isoLineType);
    public static Collection`1<Feature> GetIsoFeatures(GridCell[0...,0...] gridMatrix, IEnumerable`1<double> isoLineLevels, string dataValueColumnName, IsoLineType isoLineType, double noDataValue);
    private static Feature DyM=(GridCell[0...,0...] gridMatrix, string dataValueColumnName);
    public static Collection`1<Feature> GetIsoFeatures(GridFeatureSource gridFeatureSource, IEnumerable`1<double> isoLineLevels, string dataValueColumnName, IsoLineType isoLineType);
    public static Collection`1<double> GetIsoLineLevels(GridCell[0...,0...] gridMatrix, int isoLineLevelCount);
    public static Collection`1<double> GetIsoLineLevels(IEnumerable`1<double> dataValues, int isoLineLevelCount);
    public static Collection`1<double> GetIsoLineLevels(Dictionary`2<PointShape, double> dataPoints, int isoLineLevelCount);
    private static Collection`1<double> ECM=(int isoLevelCount, double minValue, double maxValue);
    private static List`1<NSM=> ESM=(GridCell[0...,0...] gridPoints, IEnumerable`1<double> levels, double noDataValue);
    private static BaseShape EiM=(GridCell[0...,0...] originalGrid, GridCell[0...,0...] extensionGrid, double noDataValue, double minValue);
    private static GridCell[0...,0...] EyM=(GridCell[0...,0...] grid, double noDataValue, Double& minValue);
    private static Collection`1<Feature> FCM=(List`1<NSM=> levelLineList, GridCell[0...,0...] grid, BaseShape gridShape, string dataValueColumnName);
    private static BaseShape FSM=(Collection`1<BaseShape> ringGeometries, Dictionary`2<BaseShape, BaseShape> geometriesDict);
    private static void FiM=(Collection`1<Feature> features, Collection`1<BaseShape> shapes, GridCell[0...,0...] grid, string dataValueColumnName);
    private static void FyM=(STRtree`1<object> rTree, Feature feature, BaseShape geometry, string dataValueColumnName);
}
public enum ThinkGeo.Core.IsoLineType : Enum {
    public int value__;
    public static IsoLineType LinesOnly;
    public static IsoLineType ClosedLinesAsPolygons;
}
public interface ThinkGeo.Core.IWmsEntity {
    public Collection`1<string> ActiveLayerNames { get; }
    public Collection`1<string> ActiveStyleNames { get; }
    public Uri Uri { get; public set; }
    public bool IsTransparent { get; public set; }
    public string OutputFormat { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public string Crs { get; public set; }
    public ICredentials Credentials { get; public set; }
    public string Exceptions { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public WmsAxisOrder AxisOrder { get; public set; }
    public bool FastMode { get; public set; }
    public string Version { get; }
    public TimeSpan CapabilitiesCacheTimeout { get; public set; }
    public string UserAgent { get; public set; }
    public abstract virtual Collection`1<string> get_ActiveLayerNames();
    public abstract virtual Collection`1<string> get_ActiveStyleNames();
    public abstract virtual Uri get_Uri();
    public abstract virtual void set_Uri(Uri value);
    public abstract virtual bool get_IsTransparent();
    public abstract virtual void set_IsTransparent(bool value);
    public abstract virtual string get_OutputFormat();
    public abstract virtual void set_OutputFormat(string value);
    public abstract virtual IWebProxy get_WebProxy();
    public abstract virtual void set_WebProxy(IWebProxy value);
    public abstract virtual int get_TimeoutInSeconds();
    public abstract virtual void set_TimeoutInSeconds(int value);
    public abstract virtual string get_Crs();
    public abstract virtual void set_Crs(string value);
    public abstract virtual ICredentials get_Credentials();
    public abstract virtual void set_Credentials(ICredentials value);
    public abstract virtual string get_Exceptions();
    public abstract virtual void set_Exceptions(string value);
    public abstract virtual Dictionary`2<string, string> get_Parameters();
    public abstract virtual WmsAxisOrder get_AxisOrder();
    public abstract virtual void set_AxisOrder(WmsAxisOrder value);
    public abstract virtual bool get_FastMode();
    public abstract virtual void set_FastMode(bool value);
    public abstract virtual string get_Version();
    public abstract virtual TimeSpan get_CapabilitiesCacheTimeout();
    public abstract virtual void set_CapabilitiesCacheTimeout(TimeSpan value);
    public abstract virtual string get_UserAgent();
    public abstract virtual void set_UserAgent(string value);
}
[DefaultMemberAttribute("Item")]
internal class ThinkGeo.Core.JArray : JContainer {
    private List`1<JToken> _values;
    protected IList`1<JToken> ChildrenTokens { get; }
    internal JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    public bool IsReadOnly { get; }
    public JArray(object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    internal virtual JTokenType get_Type();
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public sealed virtual JToken get_Item(int index);
    public sealed virtual void set_Item(int index, JToken value);
    public sealed virtual void Insert(int index, JToken item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual IEnumerator`1<JToken> GetEnumerator();
    public sealed virtual void Add(JToken item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JToken item);
    public sealed virtual void CopyTo(JToken[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(JToken item);
}
internal abstract class ThinkGeo.Core.JContainer : JToken {
    private object _syncRoot;
    protected IList`1<JToken> ChildrenTokens { get; }
    public bool HasValues { get; }
    public JToken First { get; }
    public JToken Last { get; }
    private JToken System.Collections.Generic.IList<ThinkGeo.Core.JToken>.Item { get; private set; }
    private bool System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    protected abstract virtual IList`1<JToken> get_ChildrenTokens();
    public virtual bool get_HasValues();
    public virtual JToken get_First();
    public virtual JToken get_Last();
    internal virtual JEnumerable`1<JToken> Children();
    public IEnumerable`1<JToken> Descendants();
    [IteratorStateMachineAttribute("ThinkGeo.Core.JContainer/pT4=")]
internal IEnumerable`1<JToken> GetDescendants(bool self);
    internal bool IsMultiContent(object content);
    internal JToken EnsureParentToken(JToken item, bool skipParentCheck);
    internal virtual int IndexOfItem(JToken item);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual void RemoveItemAt(int index);
    internal virtual bool RemoveItem(JToken item);
    internal virtual JToken GetItem(int index);
    internal virtual void SetItem(int index, JToken item);
    internal virtual void ClearItems();
    internal virtual bool ContainsItem(JToken item);
    internal virtual void CopyItemsTo(Array array, int arrayIndex);
    internal static bool IsTokenUnchanged(JToken currentValue, JToken newValue);
    public virtual void Add(object content);
    public void AddFirst(object content);
    internal void AddInternal(int index, object content, bool skipParentCheck);
    internal static JToken CreateFromContent(object content);
    internal void ReadTokenFrom(JsonReader reader);
    internal void ReadContentFrom(JsonReader r);
    private static JProperty ReadProperty(JsonReader r, JContainer parent);
    private sealed virtual override int System.Collections.Generic.IList<ThinkGeo.Core.JToken>.IndexOf(JToken item);
    private sealed virtual override void System.Collections.Generic.IList<ThinkGeo.Core.JToken>.Insert(int index, JToken item);
    private sealed virtual override void System.Collections.Generic.IList<ThinkGeo.Core.JToken>.RemoveAt(int index);
    private sealed virtual override JToken System.Collections.Generic.IList<ThinkGeo.Core.JToken>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<ThinkGeo.Core.JToken>.set_Item(int index, JToken value);
    private sealed virtual override void System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.Add(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.Contains(JToken item);
    private sealed virtual override void System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.CopyTo(JToken[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.Generic.ICollection<ThinkGeo.Core.JToken>.Remove(JToken item);
    private JToken EnsureValue(object value);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
}
[IsReadOnlyAttribute]
internal class ThinkGeo.Core.JEnumerable`1 : ValueType {
    private IEnumerable`1<T> _enumerable;
    public static JEnumerable`1<T> Empty;
    public JEnumerable`1(IEnumerable`1<T> enumerable);
    private static JEnumerable`1();
    public IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Equals(JEnumerable`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class ThinkGeo.Core.JObject : JContainer {
    private List`1<JToken> properties;
    protected IList`1<JToken> ChildrenTokens { get; }
    internal JTokenType Type { get; }
    public JToken Item { get; public set; }
    public JToken Item { get; public set; }
    protected virtual IList`1<JToken> get_ChildrenTokens();
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual JTokenType get_Type();
    internal JProperty Property(string name, StringComparison comparison);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public JToken get_Item(string propertyName);
    public void set_Item(string propertyName, JToken value);
    public void Add(string propertyName, JToken value);
    public bool ContainsKey(string propertyName);
}
internal class ThinkGeo.Core.JProperty : JContainer {
    private List`1<JToken> _content;
    private string _name;
    protected IList`1<JToken> ChildrenTokens { get; }
    public string Name { get; }
    public JToken Value { get; public set; }
    internal JTokenType Type { get; }
    internal JProperty(string name);
    public JProperty(string name, object content);
    protected virtual IList`1<JToken> get_ChildrenTokens();
    [DebuggerStepThroughAttribute]
public string get_Name();
    [DebuggerStepThroughAttribute]
public JToken get_Value();
    public void set_Value(JToken value);
    internal virtual JToken GetItem(int index);
    internal virtual void SetItem(int index, JToken item);
    internal virtual void InsertItem(int index, JToken item, bool skipParentCheck);
    internal virtual bool ContainsItem(JToken item);
    [DebuggerStepThroughAttribute]
internal virtual JTokenType get_Type();
}
internal class ThinkGeo.Core.JsonContainerContract : JsonContract {
    [ObfuscationAttribute]
private JsonContract _itemContract;
    [ObfuscationAttribute]
private JsonContract _finalItemContract;
    internal JsonContract ItemContract { get; internal set; }
    internal JsonContainerContract(Type underlyingType);
    internal JsonContract get_ItemContract();
    internal void set_ItemContract(JsonContract value);
}
internal enum ThinkGeo.Core.JsonContainerType : Enum {
    public int value__;
    public static JsonContainerType None;
    public static JsonContainerType Object;
    public static JsonContainerType Array;
    public static JsonContainerType Constructor;
}
internal class ThinkGeo.Core.JsonContract : object {
    [ObfuscationAttribute]
private Type _createdType;
    internal bool IsNullable;
    internal bool IsConvertable;
    internal bool IsEnum;
    internal Type NonNullableUnderlyingType;
    internal ReadType InternalReadType;
    internal JsonContractType ContractType;
    internal bool IsReadOnlyOrFixedSize;
    internal bool IsSealed;
    internal bool IsInstantiable;
    [CompilerGeneratedAttribute]
private Type <UnderlyingType>k__BackingField;
    public Type UnderlyingType { get; }
    public Type CreatedType { get; public set; }
    internal JsonContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_UnderlyingType();
    public Type get_CreatedType();
    public void set_CreatedType(Type value);
}
internal enum ThinkGeo.Core.JsonContractType : Enum {
    public int value__;
    public static JsonContractType None;
    public static JsonContractType Object;
    public static JsonContractType Array;
    public static JsonContractType Primitive;
    public static JsonContractType String;
    public static JsonContractType Dictionary;
    public static JsonContractType Dynamic;
    public static JsonContractType Serializable;
    public static JsonContractType Linq;
}
internal static class ThinkGeo.Core.JsonConvert : object {
    public static string True;
    public static string False;
    public static string Null;
    public static string Undefined;
    public static string PositiveInfinity;
    public static string NegativeInfinity;
    public static string NaN;
    private static JsonConvert();
    [DebuggerStepThroughAttribute]
public static object DeserializeObject(string value);
    [DebuggerStepThroughAttribute]
public static T DeserializeObject(string value);
    [DebuggerStepThroughAttribute]
public static T DeserializeAnonymousType(string value, T anonymousTypeObject);
    public static object DeserializeObject(string value, Type type);
}
internal class ThinkGeo.Core.JsonDictionaryContract : JsonContainerContract {
    public static string ConcurrentDictionaryTypeName;
    private Type _genericCollectionDefinitionType;
    private ConstructorInfo _parameterizedConstructor;
    [CompilerGeneratedAttribute]
private Type <DictionaryKeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DictionaryValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonContract <KeyContract>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldCreateWrapper>k__BackingField;
    [CompilerGeneratedAttribute]
private vRU=<object> <OverrideCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasParameterizedCreator>k__BackingField;
    public Type DictionaryKeyType { get; }
    public Type DictionaryValueType { get; }
    internal JsonContract KeyContract { get; internal set; }
    internal bool ShouldCreateWrapper { get; }
    public vRU=<object> OverrideCreator { get; public set; }
    public bool HasParameterizedCreator { get; public set; }
    internal bool HasParameterizedCreatorInternal { get; }
    public JsonDictionaryContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public Type get_DictionaryKeyType();
    [CompilerGeneratedAttribute]
public Type get_DictionaryValueType();
    [CompilerGeneratedAttribute]
internal JsonContract get_KeyContract();
    [CompilerGeneratedAttribute]
internal void set_KeyContract(JsonContract value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldCreateWrapper();
    [CompilerGeneratedAttribute]
public vRU=<object> get_OverrideCreator();
    [CompilerGeneratedAttribute]
public void set_OverrideCreator(vRU=<object> value);
    [CompilerGeneratedAttribute]
public bool get_HasParameterizedCreator();
    [CompilerGeneratedAttribute]
public void set_HasParameterizedCreator(bool value);
    internal bool get_HasParameterizedCreatorInternal();
    internal IDictionary CreateTemporaryDictionary();
}
internal class ThinkGeo.Core.JsonHelper : object {
    public static string CarriageReturnLineFeed;
    public static string Empty;
    public static char CarriageReturn;
    public static char LineFeed;
    public static char Tab;
    private static Dictionary`2<Type, PrimitiveTypeCode> TypeCodeMap;
    private static JsonHelper();
    internal static JObject Parse(string json);
    public static string ToString(object value);
    public static int ByteArrayCompare(Byte[] a1, Byte[] a2);
    public static int IntLength(ulong i);
    public static bool ApproxEquals(double d1, double d2);
    public static Char[] RentBuffer(int minSize);
    internal static bool IsEndToken(JsonToken token);
    internal static bool IsStartToken(JsonToken token);
    internal static bool IsPrimitiveToken(JsonToken token);
    public static void ArgumentNotNull(object value, string parameterName);
    public static ConstructorInfo ResolveEnumerableCollectionConstructor(Type collectionType, Type collectionItemType, Type constructorArgumentType);
    public static bool IsNullable(Type t);
    public static bool IsNullableType(Type t);
    public static bool ImplementsGenericDefinition(Type type, Type genericInterfaceDefinition, Type& implementingType);
    public static PrimitiveTypeCode GetTypeCode(Type t);
    public static PrimitiveTypeCode GetTypeCode(Type t, Boolean& isEnum);
    public static bool IsInteger(object value);
    public static bool TryHexTextToInt(Char[] text, int start, int end, Int32& value);
}
internal class ThinkGeo.Core.JsonObjectContract : JsonContainerContract {
    [ObfuscationAttribute]
private vRU=<object> _parameterizedCreator;
    private JsonPropertyCollection _creatorParameters;
    [CompilerGeneratedAttribute]
private JsonPropertyCollection <Properties>k__BackingField;
    public JsonPropertyCollection Properties { get; }
    internal vRU=<object> ParameterizedCreator { get; internal set; }
    public JsonPropertyCollection CreatorParameters { get; }
    public JsonObjectContract(Type underlyingType);
    [CompilerGeneratedAttribute]
public JsonPropertyCollection get_Properties();
    internal vRU=<object> get_ParameterizedCreator();
    internal void set_ParameterizedCreator(vRU=<object> value);
    public JsonPropertyCollection get_CreatorParameters();
}
internal class ThinkGeo.Core.JsonPrimitiveContract : JsonContract {
    [CompilerGeneratedAttribute]
private PrimitiveTypeCode <TypeCode>k__BackingField;
    private static Dictionary`2<Type, ReadType> ReadTypeMap;
    internal PrimitiveTypeCode TypeCode { get; internal set; }
    public JsonPrimitiveContract(Type underlyingType);
    private static JsonPrimitiveContract();
    [CompilerGeneratedAttribute]
internal PrimitiveTypeCode get_TypeCode();
    [CompilerGeneratedAttribute]
internal void set_TypeCode(PrimitiveTypeCode value);
}
internal class ThinkGeo.Core.JsonProperty : object {
    [ObfuscationAttribute]
private string _propertyName;
    [ObfuscationAttribute]
private Type _propertyType;
    [CompilerGeneratedAttribute]
private JsonContract <PropertyContract>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Ignored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Readable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Writable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMemberAttribute>k__BackingField;
    internal JsonContract PropertyContract { get; internal set; }
    public string PropertyName { get; public set; }
    public Nullable`1<int> Order { get; public set; }
    public Type PropertyType { get; public set; }
    public bool Ignored { get; public set; }
    public bool Readable { get; public set; }
    public bool Writable { get; public set; }
    public bool HasMemberAttribute { get; public set; }
    [CompilerGeneratedAttribute]
internal JsonContract get_PropertyContract();
    [CompilerGeneratedAttribute]
internal void set_PropertyContract(JsonContract value);
    public string get_PropertyName();
    public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(Nullable`1<int> value);
    public Type get_PropertyType();
    public void set_PropertyType(Type value);
    [CompilerGeneratedAttribute]
public bool get_Ignored();
    [CompilerGeneratedAttribute]
public void set_Ignored(bool value);
    [CompilerGeneratedAttribute]
public bool get_Readable();
    [CompilerGeneratedAttribute]
public void set_Readable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Writable();
    [CompilerGeneratedAttribute]
public void set_Writable(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasMemberAttribute();
    [CompilerGeneratedAttribute]
public void set_HasMemberAttribute(bool value);
    public virtual string ToString();
}
internal class ThinkGeo.Core.JsonPropertyCollection : KeyedCollection`2<string, JsonProperty> {
    private Type _type;
    private List`1<JsonProperty> _list;
    public JsonPropertyCollection(Type type);
    protected virtual string GetKeyForItem(JsonProperty item);
    public void AddProperty(JsonProperty property);
    public JsonProperty GetClosestMatchProperty(string propertyName);
    private bool TryGetValuePrivate(string key, JsonProperty& item);
    public JsonProperty GetProperty(string propertyName, StringComparison comparisonType);
}
internal abstract class ThinkGeo.Core.JsonReader : object {
    private JsonToken _tokenType;
    private object _value;
    internal char _quoteChar;
    internal State _currentState;
    private JsonContainerType currentType;
    [ObfuscationAttribute]
private CultureInfo _culture;
    private Nullable`1<int> _maxDepth;
    private bool _hasExceededMaxDepth;
    [ObfuscationAttribute]
private string _dateFormatString;
    private List`1<JsonContainerType> _stack;
    [CompilerGeneratedAttribute]
private bool <CloseInput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportMultipleContent>k__BackingField;
    protected State CurrentState { get; }
    public bool CloseInput { get; public set; }
    public bool SupportMultipleContent { get; public set; }
    public string DateFormatString { get; public set; }
    public JsonToken TokenType { get; }
    public object Value { get; }
    public int Depth { get; }
    public CultureInfo Culture { get; public set; }
    protected State get_CurrentState();
    [CompilerGeneratedAttribute]
public bool get_CloseInput();
    [CompilerGeneratedAttribute]
public void set_CloseInput(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportMultipleContent();
    [CompilerGeneratedAttribute]
public void set_SupportMultipleContent(bool value);
    public string get_DateFormatString();
    public void set_DateFormatString(string value);
    public virtual JsonToken get_TokenType();
    public virtual object get_Value();
    public virtual int get_Depth();
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    private void Push(JsonContainerType value);
    private JsonContainerType Pop();
    private JsonContainerType Peek();
    public abstract virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    internal Nullable`1<int> ReadInt32String(string s);
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    internal Byte[] ReadArrayIntoByteArray();
    private bool ReadArrayElementIntoByteArrayReportDone(List`1<byte> buffer);
    public virtual Nullable`1<double> ReadAsDouble();
    internal Nullable`1<double> ReadDoubleString(string s);
    public virtual Nullable`1<bool> ReadAsBoolean();
    internal Nullable`1<bool> ReadBooleanString(string s);
    public virtual Nullable`1<decimal> ReadAsDecimal();
    internal Nullable`1<decimal> ReadDecimalString(string s);
    internal void ReaderReadAndAssert();
    internal Exception CreateUnexpectedEndException();
    public void Skip();
    protected void SetToken(JsonToken newToken);
    protected void SetToken(JsonToken newToken, object value);
    protected void SetToken(JsonToken newToken, object value, bool updateIndex);
    internal void SetPostValueState(bool updateIndex);
    private void ValidateEnd(JsonToken endToken);
    protected void SetStateBasedOnCurrent();
    private void SetFinished();
    private JsonContainerType GetTypeForCloseToken(JsonToken token);
    private sealed virtual override void System.IDisposable.Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    internal void ReadAndAssert();
    internal bool ReadForType(JsonContract contract, bool hasConverter);
    internal bool ReadAndMoveToContent();
    internal bool MoveToContent();
    private JsonToken GetContentToken();
}
internal class ThinkGeo.Core.JsonSerializerInternalReader : object {
    private JsonContract GetContractSafe(Type type);
    private JsonContract GetContract(Type type);
    public object Deserialize(JsonReader reader, Type objectType);
    private JToken CreateJObject(JsonReader reader);
    private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty containerMember);
    private static bool CoerceEmptyStringToNull(Type objectType, JsonContract contract, string s);
    internal string GetExpectedDescription(JsonContract contract);
    private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member);
    public object CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, Boolean& createdFromNonDefaultCreator);
    private object CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, vRU=<object> creator);
    private List`1<sz4=> ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType);
    private object CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    private object CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, object existingValue);
    private bool HasNoDefinedType(JsonContract contract);
    private object EnsureType(JsonReader reader, object value, CultureInfo culture, JsonContract contract, Type targetType);
    private IDictionary CreateNewDictionary(JsonDictionaryContract contract);
    private object PopulateDictionary(IDictionary dictionary, JsonReader reader, JsonDictionaryContract contract, JsonProperty containerProperty);
}
internal class ThinkGeo.Core.JsonTextReader : JsonReader {
    private static char UnicodeReplacementChar;
    [CompilerGeneratedAttribute]
private int <LargeBufferLength>k__BackingField;
    private TextReader _reader;
    private Char[] _chars;
    private int _charsUsed;
    private int _charPos;
    private int _lineStartPos;
    private int _lineNumber;
    private bool _isEndOfFile;
    private StringBuffer _stringBuffer;
    private StringReference _stringReference;
    internal int LargeBufferLength { get; internal set; }
    public JsonTextReader(TextReader reader);
    [CompilerGeneratedAttribute]
internal int get_LargeBufferLength();
    [CompilerGeneratedAttribute]
internal void set_LargeBufferLength(int value);
    private void EnsureBufferNotEmpty();
    private void SetNewLine(bool hasNextChar);
    private void OnNewLine(int pos);
    private void ParseString(char quote, ReadType readType);
    private void ParseReadString(char quote, ReadType readType);
    private static void BlockCopyChars(Char[] src, int srcOffset, Char[] dst, int dstOffset, int count);
    private void ShiftBufferIfNeeded();
    private int ReadData(bool append);
    private void PrepareBufferForReadData(bool append, int charsRequired);
    private int ReadData(bool append, int charsRequired);
    private bool EnsureChars(int relativePosition, bool append);
    private bool ReadChars(int relativePosition, bool append);
    public virtual bool Read();
    public virtual Nullable`1<int> ReadAsInt32();
    public virtual string ReadAsString();
    public virtual Byte[] ReadAsBytes();
    private object ReadStringValue(ReadType readType);
    private object FinishReadQuotedStringValue(ReadType readType);
    private Exception CreateUnexpectedCharacterException(char c);
    public virtual Nullable`1<bool> ReadAsBoolean();
    private void ProcessValueComma();
    private object ReadNumberValue(ReadType readType);
    private object FinishReadQuotedNumber(ReadType readType);
    public virtual Nullable`1<decimal> ReadAsDecimal();
    public virtual Nullable`1<double> ReadAsDouble();
    private void HandleNull();
    private void ReadFinished();
    private bool ReadNullChar();
    private void EnsureBuffer();
    private void ReadStringIntoBuffer(char quote);
    private void FinishReadStringIntoBuffer(int charPos, int initialPosition, int lastWritePosition);
    private void WriteCharToBuffer(char writeChar, int lastWritePosition, int writeToPosition);
    private char ConvertUnicode(bool enoughChars);
    private char ParseUnicode();
    private void ReadNumberIntoBuffer();
    private bool ReadNumberCharIntoBuffer(char currentChar, int charPos);
    private void ClearRecentString();
    private bool ParsePostValue(bool ignoreComments);
    private bool ParseObject();
    private bool ParseProperty();
    private bool ValidIdentifierChar(char value);
    private void ParseUnquotedProperty();
    private bool ReadUnquotedPropertyReportIfDone(char currentChar, int initialPosition);
    private bool ParseValue();
    private void ProcessLineFeed();
    private void ProcessCarriageReturn(bool append);
    private void EatWhitespace();
    private void ParseConstructor();
    private void ParseNumber(ReadType readType);
    private void ParseReadNumber(ReadType readType, char firstChar, int initialPosition);
    private void ParseComment(bool setToken);
    private void EndComment(bool setToken, int initialPosition, int endPosition);
    private bool MatchValue(string value);
    private bool MatchValue(bool enoughChars, string value);
    private bool MatchValueWithTrailingSeparator(string value);
    private bool IsSeparator(char c);
    private void ParseTrue();
    private void ParseNull();
    private void ParseUndefined();
    private void ParseFalse();
    private object ParseNumberNegativeInfinity(ReadType readType);
    private object ParseNumberNegativeInfinity(ReadType readType, bool matched);
    private object ParseNumberPositiveInfinity(ReadType readType);
    private object ParseNumberPositiveInfinity(ReadType readType, bool matched);
    private object ParseNumberNaN(ReadType readType);
    private object ParseNumberNaN(ReadType readType, bool matched);
    public virtual void Close();
}
internal enum ThinkGeo.Core.JsonToken : Enum {
    public int value__;
    public static JsonToken None;
    public static JsonToken StartObject;
    public static JsonToken StartArray;
    public static JsonToken StartConstructor;
    public static JsonToken PropertyName;
    public static JsonToken Comment;
    public static JsonToken Raw;
    public static JsonToken Integer;
    public static JsonToken Float;
    public static JsonToken String;
    public static JsonToken Boolean;
    public static JsonToken Null;
    public static JsonToken Undefined;
    public static JsonToken EndObject;
    public static JsonToken EndArray;
    public static JsonToken EndConstructor;
    public static JsonToken Date;
    public static JsonToken Bytes;
}
[DefaultMemberAttribute("Item")]
internal abstract class ThinkGeo.Core.JToken : object {
    [ObfuscationAttribute]
private JContainer _parent;
    [ObfuscationAttribute]
private JToken _previous;
    [ObfuscationAttribute]
private JToken _next;
    public JContainer Parent { get; internal set; }
    internal JTokenType Type { get; }
    public bool HasValues { get; }
    public JToken Next { get; internal set; }
    public JToken Previous { get; internal set; }
    public JToken Item { get; public set; }
    public JToken First { get; }
    public JToken Last { get; }
    [DebuggerStepThroughAttribute]
public JContainer get_Parent();
    internal void set_Parent(JContainer value);
    internal abstract virtual JTokenType get_Type();
    public abstract virtual bool get_HasValues();
    public JToken get_Next();
    internal void set_Next(JToken value);
    public JToken get_Previous();
    internal void set_Previous(JToken value);
    public virtual JToken get_Item(object key);
    public virtual void set_Item(object key, JToken value);
    public virtual JToken get_First();
    public virtual JToken get_Last();
    internal virtual JEnumerable`1<JToken> Children();
    private static JValue EnsureValue(JToken value);
    public static bool op_Explicit(JToken value);
    public static int op_Explicit(JToken value);
    public static double op_Explicit(JToken value);
    public static float op_Explicit(JToken value);
    public static string op_Explicit(JToken value);
    public static JToken op_Implicit(string value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<JToken> System.Collections.Generic.IEnumerable<ThinkGeo.Core.JToken>.GetEnumerator();
    public T ToObject();
}
internal class ThinkGeo.Core.JTokenReader : JsonReader {
    private JToken _root;
    private JToken _parent;
    private JToken _current;
    internal JToken Root { get; }
    public JTokenReader(JToken token);
    internal JToken get_Root();
    public virtual bool Read();
    private bool ReadOver(JToken t);
    private bool ReadToEnd();
    private Nullable`1<JsonToken> GetEndToken(JContainer c);
    private bool ReadInto(JContainer c);
    private bool SetEnd(JContainer c);
    private void SetToken(JToken token);
    private string SafeToString(object value);
}
internal enum ThinkGeo.Core.JTokenType : Enum {
    public int value__;
    public static JTokenType None;
    public static JTokenType Object;
    public static JTokenType Array;
    public static JTokenType Constructor;
    public static JTokenType Property;
    public static JTokenType Comment;
    public static JTokenType Integer;
    public static JTokenType Float;
    public static JTokenType String;
    public static JTokenType Boolean;
    public static JTokenType Null;
    public static JTokenType Undefined;
    public static JTokenType Date;
    public static JTokenType Raw;
    public static JTokenType Bytes;
    public static JTokenType Guid;
    public static JTokenType Uri;
    public static JTokenType TimeSpan;
}
internal class ThinkGeo.Core.JValue : JToken {
    [ObfuscationAttribute]
private JTokenType _valueType;
    [ObfuscationAttribute]
private object _value;
    public bool HasValues { get; }
    internal JTokenType Type { get; }
    public object Value { get; public set; }
    internal JValue(object value, JTokenType type);
    public JValue(string value);
    public JValue(object value);
    public virtual bool get_HasValues();
    internal static int Compare(JTokenType valueType, object objA, object objB);
    private static int CompareFloat(object objA, object objB);
    public static JValue CreateNull();
    public static JValue CreateUndefined();
    private static JTokenType GetValueType(JTokenType current, object value);
    private static JTokenType GetStringValueType(JTokenType current);
    internal virtual JTokenType get_Type();
    public object get_Value();
    public void set_Value(object value);
    private static bool ValuesEquals(JValue v1, JValue v2);
    public sealed virtual bool Equals(JValue other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public sealed virtual int CompareTo(JValue obj);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.KiloMetersValues : ValueType {
    [ObfuscationAttribute]
private double v1;
    [ObfuscationAttribute]
private double v10;
    [ObfuscationAttribute]
private double v100;
    [ObfuscationAttribute]
private double v1000;
    [ObfuscationAttribute]
private double v2;
    [ObfuscationAttribute]
private double v20;
    [ObfuscationAttribute]
private double v200;
    [ObfuscationAttribute]
private double v2000;
    [ObfuscationAttribute]
private double v3;
    [ObfuscationAttribute]
private double v30;
    [ObfuscationAttribute]
private double v300;
    [ObfuscationAttribute]
private double v4;
    [ObfuscationAttribute]
private double v40;
    [ObfuscationAttribute]
private double v400;
    [ObfuscationAttribute]
private double v4000;
    [ObfuscationAttribute]
private double v5;
    [ObfuscationAttribute]
private double v50;
    [ObfuscationAttribute]
private double v500;
    public double PCE= { get; }
    public double PiE= { get; }
    public double QCE= { get; }
    public double QiE= { get; }
    public double RCE= { get; }
    public double JCE= { get; }
    public double JiE= { get; }
    public double KCE= { get; }
    public double KiE= { get; }
    public double LCE= { get; }
    public double LiE= { get; }
    public double MCE= { get; }
    public double MiE= { get; }
    public double NCE= { get; }
    public double NiE= { get; }
    public double OCE= { get; }
    public double OiE= { get; }
    public double RiE= { get; }
    public KiloMetersValues(int width, double extentLengthBar, DistanceUnit distanceUnit);
    public double OyE=();
    public double PSE=();
    public double PyE=();
    public double QSE=();
    public double QyE=();
    public double IyE=();
    public double JSE=();
    public double JyE=();
    public double KSE=();
    public double KyE=();
    public double LSE=();
    public double LyE=();
    public double MSE=();
    public double MyE=();
    public double NSE=();
    public double NyE=();
    public double OSE=();
    public double RSE=();
}
public abstract class ThinkGeo.Core.KrigingGridInterpolationModel : GridInterpolationModel {
    [ObfuscationAttribute]
private int referencingPointCount;
    [ObfuscationAttribute]
private Dictionary`2<PointShape, double> dataPoints;
    [ObfuscationAttribute]
private Double[0...,0...] pointValues;
    private fCI= SCI=;
    [ObfuscationAttribute]
private Double[] extent;
    public Dictionary`2<PointShape, double> Points { get; }
    public int NumberOfReferencedPoints { get; public set; }
    protected KrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    protected KrigingGridInterpolationModel(IDictionary`2<PointShape, double> points, int numberOfReferencedPoints);
    public Dictionary`2<PointShape, double> get_Points();
    public int get_NumberOfReferencedPoints();
    public void set_NumberOfReferencedPoints(int value);
    public double GetSemivariance(double distance, EmpiricalFunctionCoefficients coefficients);
    public EmpiricalFunctionCoefficients GetEmpiricalFunctionCoefficients(int numberOfPoints, Double[0...,0...] distance, Double[0...,0...] semivariances, double maxRange);
    protected virtual ValueTuple`2<double, double> InterpolateCore(RectangleShape cellExtent, GridDefinition gridDefinition);
    protected virtual double GetSemivarianceCore(double distance, EmpiricalFunctionCoefficients coefficients);
    protected double GetSillSlope(double distance, double range);
    protected abstract virtual double GetSillSlopeCore(double distance, double range);
    protected virtual EmpiricalFunctionCoefficients GetEmpiricalFunctionCoefficientsCore(int points, Double[0...,0...] distance, Double[0...,0...] semivariances, double maxRange);
    private ValueTuple`2<double, double> SSI=(int nPn, double x, double y);
    private void SiI=(Dictionary`2<PointShape, double> dataPoints);
    private Double[0...,0...] SyI=(int nPn, double x, double y, fCI= quadTree);
    private Double[0...,0...] TCI=(int npoints, Double[0...,0...] cpoints, EmpiricalFunctionCoefficients& coefficients);
    private Double[0...,0...] TSI=(int nPn, Double[0...,0...] mdistances, EmpiricalFunctionCoefficients coefficients);
    private static void TiI=(Double[]& a, Int32[]& b, int x);
    [OnGeodeserializedAttribute]
private void QBU=();
}
public enum ThinkGeo.Core.LabelDuplicateRule : Enum {
    public int value__;
    public static LabelDuplicateRule OneDuplicateLabelPerQuadrant;
    public static LabelDuplicateRule NoDuplicateLabels;
    public static LabelDuplicateRule UnlimitedDuplicateLabels;
}
public class ThinkGeo.Core.LabelInformation : object {
    [ObfuscationAttribute]
private ScreenPointF positionInScreenCoordinates;
    [ObfuscationAttribute]
private string text;
    [ObfuscationAttribute]
private double rotationAngle;
    public ScreenPointF PositionInScreenCoordinates { get; public set; }
    public string Text { get; public set; }
    public double RotationAngle { get; public set; }
    public LabelInformation(ScreenPointF positionInScreenCoordinates, string text, double rotationAngle);
    public ScreenPointF get_PositionInScreenCoordinates();
    public void set_PositionInScreenCoordinates(ScreenPointF value);
    public string get_Text();
    public void set_Text(string value);
    public double get_RotationAngle();
    public void set_RotationAngle(double value);
}
public class ThinkGeo.Core.LabelingCandidate : object {
    [ObfuscationAttribute]
private string originalText;
    [ObfuscationAttribute]
private PolygonShape screenArea;
    [ObfuscationAttribute]
private ScreenPointF centerPointInScreenCoordinate;
    [ObfuscationAttribute]
private Collection`1<LabelInformation> labelInformation;
    public string OriginalText { get; public set; }
    public PolygonShape ScreenArea { get; public set; }
    public ScreenPointF CenterPointInScreenCoordinate { get; public set; }
    public Collection`1<LabelInformation> LabelInformation { get; }
    public LabelingCandidate(string originalText, PolygonShape simplePolygonInScreenCoordinates, ScreenPointF centerPointInScreenCoordinate);
    public LabelingCandidate(string originalText, PolygonShape simplePolygonInScreenCoordinates, ScreenPointF centerPointInScreenCoordinate, Collection`1<LabelInformation> labelInformation);
    public string get_OriginalText();
    public void set_OriginalText(string value);
    public PolygonShape get_ScreenArea();
    public void set_ScreenArea(PolygonShape value);
    public ScreenPointF get_CenterPointInScreenCoordinate();
    public void set_CenterPointInScreenCoordinate(ScreenPointF value);
    public Collection`1<LabelInformation> get_LabelInformation();
}
public enum ThinkGeo.Core.LabelLeaderLinesRule : Enum {
    public int value__;
    public static LabelLeaderLinesRule NoLeaderLines;
    public static LabelLeaderLinesRule AllowLeaderLines;
}
public enum ThinkGeo.Core.LabelOverlappingRule : Enum {
    public int value__;
    public static LabelOverlappingRule NoOverlapping;
    public static LabelOverlappingRule AllowOverlapping;
}
public abstract class ThinkGeo.Core.Layer : LayerBase {
    private static object 9BM=;
    private Exception 7x0=;
    [ObfuscationAttribute]
private string attribution;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingAttributionLayerEventArgs> TCA=;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawnAttributionLayerEventArgs> TSA=;
    [ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
public string Attribution { get; public set; }
    private static Layer();
    [CompilerGeneratedAttribute]
public void add_DrawingAttribution(EventHandler`1<DrawingAttributionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingAttribution(EventHandler`1<DrawingAttributionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DrawnAttribution(EventHandler`1<DrawnAttributionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawnAttribution(EventHandler`1<DrawnAttributionLayerEventArgs> value);
    public string get_Attribution();
    public void set_Attribution(string value);
    [ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
protected virtual void OnDrawingAttribution(DrawingAttributionLayerEventArgs args);
    [ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
protected virtual void OnDrawnAttribution(DrawnAttributionLayerEventArgs args);
    public static Layer LoadLayer(Uri layerUri);
    public static Layer LoadLayer(Stream layerStream);
    public void Open();
    protected virtual void OpenCore();
    public void Close();
    protected virtual void CloseCore();
    public void Draw(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void TiA=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawWithColorTransformation(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers, RectangleShape extent, float width, float height);
    protected abstract virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void TyA=(GeoCanvas canvas, string attribution);
    [ObsoleteAttribute("Layer.Attribution (as well as Drawing Attribution) is deprecate and will be removed after v14.2. You can accomplish the similar feature by overriding layer.DrawCore/Layer.DrawAsyncCore method")]
protected virtual void DrawAttributionCore(GeoCanvas canvas, string attribution);
    private void 8x0=(object sender, DrawingProgressChangedEventArgs e);
}
public enum ThinkGeo.Core.LayerAnchorLocation : Enum {
    public int value__;
    public static LayerAnchorLocation UpperLeft;
    public static LayerAnchorLocation UpperRight;
    public static LayerAnchorLocation LowerRight;
    public static LayerAnchorLocation LowerLeft;
    public static LayerAnchorLocation Center;
    public static LayerAnchorLocation UpperCenter;
    public static LayerAnchorLocation LowerCenter;
    public static LayerAnchorLocation LeftCenter;
    public static LayerAnchorLocation RightCenter;
}
public abstract class ThinkGeo.Core.LayerBase : object {
    [ObfuscationAttribute]
private float redTranslation;
    [ObfuscationAttribute]
private float greenTranslation;
    [ObfuscationAttribute]
private float blueTranslation;
    [ObfuscationAttribute]
private float transparency;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingProgressChangedEventArgs> KxU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingExceptionLayerEventArgs> 1h0=;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawnExceptionLayerEventArgs> 1x0=;
    [CompilerGeneratedAttribute]
private string 2B0=;
    [CompilerGeneratedAttribute]
private bool 2R0=;
    [CompilerGeneratedAttribute]
private bool 2h0=;
    [CompilerGeneratedAttribute]
private TimeSpan 2x0=;
    [CompilerGeneratedAttribute]
private Projection 3B0=;
    [CompilerGeneratedAttribute]
private DrawingExceptionMode 3R0=;
    [CompilerGeneratedAttribute]
private GeoColor 3h0=;
    [CompilerGeneratedAttribute]
private Collection`1<GeoColor> 3x0=;
    [CompilerGeneratedAttribute]
private bool 4B0=;
    [CompilerGeneratedAttribute]
private bool 4R0=;
    [CompilerGeneratedAttribute]
private ThreadSafetyLevel 4h0=;
    [CompilerGeneratedAttribute]
private Dictionary`2<GeoColor, GeoColor> 4x0=;
    [CompilerGeneratedAttribute]
private WrappingMode 5B0=;
    [CompilerGeneratedAttribute]
private RectangleShape 5R0=;
    internal static RectangleShape 5h0=;
    internal static TimeSpan 5x0=;
    [ObfuscationAttribute]
private TimeSpan requestDrawingInterval;
    private Timer 6B0=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedDrawingLayerEventArgs> 6R0=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestingDrawingLayerEventArgs> 6h0=;
    public string Name { get; public set; }
    protected bool IsOpenCore { get; protected set; }
    public bool IsOpen { get; }
    public bool IsVisible { get; public set; }
    public TimeSpan DrawingTime { get; protected set; }
    public Projection Projection { get; public set; }
    public DrawingExceptionMode DrawingExceptionMode { get; public set; }
    public GeoColor Background { get; public set; }
    public float Transparency { get; public set; }
    public float BlueTranslation { get; public set; }
    public float RedTranslation { get; public set; }
    public float GreenTranslation { get; public set; }
    public Collection`1<GeoColor> KeyColors { get; }
    public bool IsNegative { get; public set; }
    public bool IsGrayscale { get; public set; }
    public bool HasBoundingBox { get; }
    public ThreadSafetyLevel ThreadSafe { get; public set; }
    public Dictionary`2<GeoColor, GeoColor> ColorMappings { get; }
    public WrappingMode WrappingMode { get; public set; }
    public RectangleShape WrappingExtent { get; public set; }
    public TimeSpan RequestDrawingInterval { get; public set; }
    private static LayerBase();
    [CompilerGeneratedAttribute]
public void add_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingProgressChanged(EventHandler`1<DrawingProgressChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DrawingException(EventHandler`1<DrawingExceptionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingException(EventHandler`1<DrawingExceptionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DrawnException(EventHandler`1<DrawnExceptionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawnException(EventHandler`1<DrawnExceptionLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
protected virtual bool get_IsOpenCore();
    [CompilerGeneratedAttribute]
protected virtual void set_IsOpenCore(bool value);
    public bool get_IsOpen();
    [CompilerGeneratedAttribute]
public bool get_IsVisible();
    [CompilerGeneratedAttribute]
public void set_IsVisible(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DrawingTime();
    [CompilerGeneratedAttribute]
protected void set_DrawingTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public virtual Projection get_Projection();
    [CompilerGeneratedAttribute]
public virtual void set_Projection(Projection value);
    [CompilerGeneratedAttribute]
public DrawingExceptionMode get_DrawingExceptionMode();
    [CompilerGeneratedAttribute]
public void set_DrawingExceptionMode(DrawingExceptionMode value);
    [CompilerGeneratedAttribute]
public GeoColor get_Background();
    [CompilerGeneratedAttribute]
public void set_Background(GeoColor value);
    public bool IsDrawingNeeded(double currentScale);
    protected virtual bool IsDrawingNeededCore(double currentScale);
    public float get_Transparency();
    public void set_Transparency(float value);
    public float get_BlueTranslation();
    public void set_BlueTranslation(float value);
    public float get_RedTranslation();
    public void set_RedTranslation(float value);
    public float get_GreenTranslation();
    public void set_GreenTranslation(float value);
    [CompilerGeneratedAttribute]
public Collection`1<GeoColor> get_KeyColors();
    [CompilerGeneratedAttribute]
public bool get_IsNegative();
    [CompilerGeneratedAttribute]
public void set_IsNegative(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsGrayscale();
    [CompilerGeneratedAttribute]
public void set_IsGrayscale(bool value);
    public virtual bool get_HasBoundingBox();
    [CompilerGeneratedAttribute]
public ThreadSafetyLevel get_ThreadSafe();
    [CompilerGeneratedAttribute]
public void set_ThreadSafe(ThreadSafetyLevel value);
    [CompilerGeneratedAttribute]
public Dictionary`2<GeoColor, GeoColor> get_ColorMappings();
    [CompilerGeneratedAttribute]
public WrappingMode get_WrappingMode();
    [CompilerGeneratedAttribute]
public void set_WrappingMode(WrappingMode value);
    [CompilerGeneratedAttribute]
public RectangleShape get_WrappingExtent();
    [CompilerGeneratedAttribute]
public void set_WrappingExtent(RectangleShape value);
    protected void DrawException(GeoCanvas canvas, Exception e);
    protected virtual void DrawExceptionCore(GeoCanvas canvas, Exception e);
    protected virtual void OnDrawingException(DrawingExceptionLayerEventArgs e);
    public RectangleShape GetBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void OnDrawnException(DrawnExceptionLayerEventArgs e);
    protected virtual void OnDrawingProgressChanged(DrawingProgressChangedEventArgs e);
    public LayerBase CloneDeep();
    protected virtual LayerBase CloneDeepCore();
    [CompilerGeneratedAttribute]
public void add_RequestedDrawing(EventHandler`1<RequestedDrawingLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedDrawing(EventHandler`1<RequestedDrawingLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_RequestingDrawing(EventHandler`1<RequestingDrawingLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestingDrawing(EventHandler`1<RequestingDrawingLayerEventArgs> value);
    public TimeSpan get_RequestDrawingInterval();
    public void set_RequestDrawingInterval(TimeSpan value);
    public void RequestDrawing();
    public void RequestDrawing(RectangleShape extentToRefresh);
    public void RequestDrawing(IEnumerable`1<RectangleShape> extentsToRefresh);
    public void RequestDrawing(TimeSpan bufferTime);
    public void RequestDrawing(TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public void RequestDrawing(RectangleShape extentToRefresh, TimeSpan bufferTime);
    public void RequestDrawing(RectangleShape extentToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public void RequestDrawing(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime);
    public void RequestDrawing(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    protected void StartRequestDrawing();
    protected void StopRequestDrawing();
    protected virtual void OnRequestedDrawing(RequestedDrawingLayerEventArgs eventArgs);
    protected virtual void OnRequestingDrawing(RequestingDrawingLayerEventArgs eventArgs);
    private void 6x0=(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    private void 7B0=(object sender, EventArgs e);
}
public class ThinkGeo.Core.LayerDrawingEventArgs : EventArgs {
    [ObfuscationAttribute]
private Layer currentLayer;
    [ObfuscationAttribute]
private RectangleShape worldExtent;
    [ObfuscationAttribute]
private object nativeImage;
    [ObfuscationAttribute]
private bool cancel;
    public bool Cancel { get; public set; }
    public Layer CurrentLayer { get; public set; }
    public RectangleShape WorldExtent { get; public set; }
    public object NativeImage { get; public set; }
    public LayerDrawingEventArgs(Layer currentLayer, RectangleShape worldExtent, object nativeImage);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Layer get_CurrentLayer();
    public void set_CurrentLayer(Layer value);
    public RectangleShape get_WorldExtent();
    public void set_WorldExtent(RectangleShape value);
    public object get_NativeImage();
    public void set_NativeImage(object value);
}
public class ThinkGeo.Core.LayerDrawnEventArgs : EventArgs {
    [ObfuscationAttribute]
private Layer currentLayer;
    [ObfuscationAttribute]
private RectangleShape worldExtent;
    [ObfuscationAttribute]
private object nativeImage;
    public Layer CurrentLayer { get; public set; }
    public RectangleShape WorldExtent { get; public set; }
    public object NativeImage { get; public set; }
    public LayerDrawnEventArgs(Layer currentLayer, RectangleShape worldExtent, object nativeImage);
    public Layer get_CurrentLayer();
    public void set_CurrentLayer(Layer value);
    public RectangleShape get_WorldExtent();
    public void set_WorldExtent(RectangleShape value);
    public object get_NativeImage();
    public void set_NativeImage(object value);
}
public class ThinkGeo.Core.LayersDrawingEventArgs : EventArgs {
    [ObfuscationAttribute]
private IEnumerable`1<Layer> layers;
    [ObfuscationAttribute]
private RectangleShape worldExtent;
    [ObfuscationAttribute]
private object nativeImage;
    [ObfuscationAttribute]
private bool cancel;
    public bool Cancel { get; public set; }
    public RectangleShape WorldExtent { get; public set; }
    public object NativeImage { get; public set; }
    public IEnumerable`1<Layer> Layers { get; public set; }
    public LayersDrawingEventArgs(IEnumerable`1<Layer> layers, RectangleShape worldExtent, object nativeImage);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public RectangleShape get_WorldExtent();
    public void set_WorldExtent(RectangleShape value);
    public object get_NativeImage();
    public void set_NativeImage(object value);
    public IEnumerable`1<Layer> get_Layers();
    public void set_Layers(IEnumerable`1<Layer> value);
}
public class ThinkGeo.Core.LayersDrawnEventArgs : EventArgs {
    [ObfuscationAttribute]
private IEnumerable`1<Layer> layers;
    [ObfuscationAttribute]
private RectangleShape worldExtent;
    [ObfuscationAttribute]
private object nativeImage;
    public RectangleShape WorldExtent { get; public set; }
    public object NativeImage { get; public set; }
    public IEnumerable`1<Layer> Layers { get; public set; }
    public LayersDrawnEventArgs(IEnumerable`1<Layer> layers, RectangleShape worldExtent, object nativeImage);
    public RectangleShape get_WorldExtent();
    public void set_WorldExtent(RectangleShape value);
    public object get_NativeImage();
    public void set_NativeImage(object value);
    public IEnumerable`1<Layer> get_Layers();
    public void set_Layers(IEnumerable`1<Layer> value);
}
internal class ThinkGeo.Core.LeafRecordWrapper : object {
    [CompilerGeneratedAttribute]
private px8= <Leaf>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RecordId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FeatureId>k__BackingField;
    public px8= Leaf { get; public set; }
    public int RecordId { get; public set; }
    public string FeatureId { get; public set; }
    public LeafRecordWrapper(px8= leaf, int recordId, string featureId);
    [CompilerGeneratedAttribute]
public px8= get_Leaf();
    [CompilerGeneratedAttribute]
public void set_Leaf(px8= value);
    [CompilerGeneratedAttribute]
public int get_RecordId();
    [CompilerGeneratedAttribute]
public void set_RecordId(int value);
    [CompilerGeneratedAttribute]
public string get_FeatureId();
    [CompilerGeneratedAttribute]
public void set_FeatureId(string value);
}
public class ThinkGeo.Core.LegendAdornmentLayer : AdornmentLayer {
    [ObfuscationAttribute]
private GeoCollection`1<LegendItem> legendItems;
    [ObfuscationAttribute]
private float titleHeight;
    [ObfuscationAttribute]
private float footerHeight;
    [ObfuscationAttribute]
private float rowMaxWidth;
    [ObfuscationAttribute]
private Collection`1<LegendDrawingParameters> offsets;
    [ObfuscationAttribute]
private LegendItem title;
    [ObfuscationAttribute]
private LegendItem footer;
    [ObfuscationAttribute]
private LegendContentResizeMode contentResizeMode;
    public LegendItem Title { get; public set; }
    public LegendItem Footer { get; public set; }
    public GeoCollection`1<LegendItem> LegendItems { get; }
    public LegendContentResizeMode ContentResizeMode { get; public set; }
    public LegendItem get_Title();
    public void set_Title(LegendItem value);
    public LegendItem get_Footer();
    public void set_Footer(LegendItem value);
    public GeoCollection`1<LegendItem> get_LegendItems();
    public LegendContentResizeMode get_ContentResizeMode();
    public void set_ContentResizeMode(LegendContentResizeMode value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void cCA=(Collection`1<SimpleCandidate> labelsInAllLayers, GeoCanvas adornmentGeoCanvas, int countPostion, LegendItem legendItem);
    private void cSA=(Collection`1<SimpleCandidate> labelsInAllLayers, GeoCanvas adornmentGeoCanvas);
    private void ciA=(Collection`1<SimpleCandidate> labelsInAllLayers, GeoCanvas adornmentGeoCanvas);
    private void cyA=(float widthEnlargedRatio, float heightEnlargedRatio);
    private bool dCA=(LegendItem legendItem, string type);
}
public enum ThinkGeo.Core.LegendContentResizeMode : Enum {
    public int value__;
    public static LegendContentResizeMode Default;
    public static LegendContentResizeMode Resizable;
    public static LegendContentResizeMode Fixed;
}
public class ThinkGeo.Core.LegendDrawingParameters : ValueType {
    [ObfuscationAttribute]
private float xOffset;
    [ObfuscationAttribute]
private float yOffset;
    public float XOffset { get; public set; }
    public float YOffset { get; public set; }
    public float get_XOffset();
    public void set_XOffset(float value);
    public float get_YOffset();
    public void set_YOffset(float value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool khU=(LegendDrawingParameters param);
    public static bool op_Equality(LegendDrawingParameters param1, LegendDrawingParameters param2);
    public static bool op_Inequality(LegendDrawingParameters param1, LegendDrawingParameters param2);
}
public enum ThinkGeo.Core.LegendImageJustificationMode : Enum {
    public int value__;
    public static LegendImageJustificationMode Default;
    public static LegendImageJustificationMode JustifyImageLeft;
    public static LegendImageJustificationMode JustifyImageRight;
}
public class ThinkGeo.Core.LegendItem : object {
    [ObfuscationAttribute]
private float width;
    [ObfuscationAttribute]
private float height;
    [ObfuscationAttribute]
private float imageWidth;
    [ObfuscationAttribute]
private float imageHeight;
    [ObfuscationAttribute]
private float topPadding;
    [ObfuscationAttribute]
private float bottomPadding;
    [ObfuscationAttribute]
private float leftPadding;
    [ObfuscationAttribute]
private float rightPadding;
    [ObfuscationAttribute]
private float imageTopPadding;
    [ObfuscationAttribute]
private float imageBottomPadding;
    [ObfuscationAttribute]
private float imageLeftPadding;
    [ObfuscationAttribute]
private float imageRightPadding;
    [ObfuscationAttribute]
private float textTopPadding;
    [ObfuscationAttribute]
private float textBottomPadding;
    [ObfuscationAttribute]
private float textLeftPadding;
    [ObfuscationAttribute]
private float textRightPadding;
    [ObfuscationAttribute]
private Style imageStyle;
    [ObfuscationAttribute]
private TextStyle textStyle;
    [ObfuscationAttribute]
private AreaStyle backgroundMask;
    [ObfuscationAttribute]
private AreaStyle textMask;
    [ObfuscationAttribute]
private AreaStyle imageMask;
    [ObfuscationAttribute]
private LegendImageJustificationMode imageJustificationMode;
    [ObfuscationAttribute]
private Nullable`1<float> originalFontSize;
    [ObfuscationAttribute]
private float ratio;
    public float TopPadding { get; public set; }
    public float BottomPadding { get; public set; }
    public float LeftPadding { get; public set; }
    public float RightPadding { get; public set; }
    public float ImageTopPadding { get; public set; }
    public float ImageBottomPadding { get; public set; }
    public float ImageLeftPadding { get; public set; }
    public float ImageRightPadding { get; public set; }
    public float TextTopPadding { get; public set; }
    public float TextBottomPadding { get; public set; }
    public float TextLeftPadding { get; public set; }
    public float TextRightPadding { get; public set; }
    public float Width { get; public set; }
    public float Height { get; public set; }
    public float ImageWidth { get; public set; }
    public float ImageHeight { get; public set; }
    public Style ImageStyle { get; public set; }
    public TextStyle TextStyle { get; public set; }
    public AreaStyle BackgroundMask { get; public set; }
    public AreaStyle TextMask { get; public set; }
    public AreaStyle ImageMask { get; public set; }
    public float Ratio { get; public set; }
    public LegendImageJustificationMode ImageJustificationMode { get; public set; }
    public LegendItem(int width, int height, float imageWidth, float imageHeight, Style imageStyle, TextStyle textStyle);
    public float get_TopPadding();
    public void set_TopPadding(float value);
    public float get_BottomPadding();
    public void set_BottomPadding(float value);
    public float get_LeftPadding();
    public void set_LeftPadding(float value);
    public float get_RightPadding();
    public void set_RightPadding(float value);
    public float get_ImageTopPadding();
    public void set_ImageTopPadding(float value);
    public float get_ImageBottomPadding();
    public void set_ImageBottomPadding(float value);
    public float get_ImageLeftPadding();
    public void set_ImageLeftPadding(float value);
    public float get_ImageRightPadding();
    public void set_ImageRightPadding(float value);
    public float get_TextTopPadding();
    public void set_TextTopPadding(float value);
    public float get_TextBottomPadding();
    public void set_TextBottomPadding(float value);
    public float get_TextLeftPadding();
    public void set_TextLeftPadding(float value);
    public float get_TextRightPadding();
    public void set_TextRightPadding(float value);
    public float get_Width();
    public void set_Width(float value);
    public float get_Height();
    public void set_Height(float value);
    public float get_ImageWidth();
    public void set_ImageWidth(float value);
    public float get_ImageHeight();
    public void set_ImageHeight(float value);
    public Style get_ImageStyle();
    public void set_ImageStyle(Style value);
    public TextStyle get_TextStyle();
    public void set_TextStyle(TextStyle value);
    public AreaStyle get_BackgroundMask();
    public void set_BackgroundMask(AreaStyle value);
    public AreaStyle get_TextMask();
    public void set_TextMask(AreaStyle value);
    public AreaStyle get_ImageMask();
    public void set_ImageMask(AreaStyle value);
    public float get_Ratio();
    public void set_Ratio(float value);
    public LegendImageJustificationMode get_ImageJustificationMode();
    public void set_ImageJustificationMode(LegendImageJustificationMode value);
    public void Draw(GeoCanvas adornmentGeoCanvas, Collection`1<SimpleCandidate> labelsInAllLayers, LegendDrawingParameters legendDrawingParameters);
    protected virtual void DrawCore(GeoCanvas adornmentGeoCanvas, Collection`1<SimpleCandidate> labelsInAllLayers, LegendDrawingParameters legendDrawingParameters);
    public void UpdateSizeByTextLength(GeoCanvas canvas, double zoomRatio);
    private string dSA=(int wordWrapLength);
}
public enum ThinkGeo.Core.LibTiff.Compression : Enum {
    public int value__;
    public static Compression NONE;
    public static Compression CCITTRLE;
    public static Compression CCITTFAX3;
    public static Compression CCITT_T4;
    public static Compression CCITTFAX4;
    public static Compression CCITT_T6;
    public static Compression LZW;
    public static Compression OJPEG;
    public static Compression JPEG;
    public static Compression NEXT;
    public static Compression CCITTRLEW;
    public static Compression PACKBITS;
    public static Compression THUNDERSCAN;
    public static Compression IT8CTPAD;
    public static Compression IT8LW;
    public static Compression IT8MP;
    public static Compression IT8BL;
    public static Compression PIXARFILM;
    public static Compression PIXARLOG;
    public static Compression DEFLATE;
    public static Compression ADOBE_DEFLATE;
    public static Compression DCS;
    public static Compression JBIG;
    public static Compression SGILOG;
    public static Compression SGILOG24;
    public static Compression JP2000;
}
public class ThinkGeo.Core.LibTiff.FieldValue : ValueType {
    private object 1jM=;
    public object Value { get; }
    internal FieldValue(object o);
    internal static FieldValue[] 1zM=(Object[] list);
    internal void 2DM=(object o);
    public object get_Value();
    public byte ToByte();
    public short ToShort();
    public ushort ToUShort();
    public int ToInt();
    public UInt32 ToUInt();
    public long ToLong();
    public float ToFloat();
    public double ToDouble();
    public virtual string ToString();
    public Byte[] GetBytes();
    public Byte[] ToByteArray();
    public Int16[] ToShortArray();
    public UInt16[] ToUShortArray();
    public Int32[] ToIntArray();
    public UInt32[] ToUIntArray();
    public Int64[] TolongArray();
    public Single[] ToFloatArray();
    public Double[] ToDoubleArray();
}
public enum ThinkGeo.Core.LibTiff.Orientation : Enum {
    public int value__;
    public static Orientation TOPLEFT;
    public static Orientation TOPRIGHT;
    public static Orientation BOTRIGHT;
    public static Orientation BOTLEFT;
    public static Orientation LEFTTOP;
    public static Orientation RIGHTTOP;
    public static Orientation RIGHTBOT;
    public static Orientation LEFTBOT;
}
public class ThinkGeo.Core.LibTiff.Tiff : object {
    private static TiffErrorHandler mzQ=;
    private static TiffExtendProc nDQ=;
    private static TiffFieldInfo[] nTQ=;
    private static TiffFieldInfo[] njQ=;
    private static int nzQ=;
    private static int oDQ=;
    private static short oTQ=;
    private static short ojQ=;
    private static short ozQ=;
    private static float pDQ=;
    private static float pTQ=;
    private static float pjQ=;
    internal static int pzQ=;
    internal static 6jY= qDQ=;
    internal static bool qTQ=;
    internal static bool qjQ=;
    internal static Encoding qzQ=;
    internal string rDQ=;
    internal int 4jM=;
    internal 6jY= rTQ=;
    internal ulong rjQ=;
    internal pjY= rzQ=;
    internal int sDQ=;
    internal int sTQ=;
    internal int sjQ=;
    internal int szQ=;
    internal TiffCodec tDQ=;
    internal int tTQ=;
    internal Byte[] tjQ=;
    internal int tzQ=;
    internal int uDQ=;
    internal int uTQ=;
    internal object ujQ=;
    internal 0UA= uzQ=;
    internal TiffTagMethods vDQ=;
    private ulong vTQ=;
    private UInt64[] vjQ=;
    private int vzQ=;
    private short wDQ=;
    private ADc= wTQ=;
    private Int32[] wjQ=;
    private UInt32[] wzQ=;
    private short xDQ=;
    private ulong xTQ=;
    private ulong xjQ=;
    private short xzQ=;
    private ulong yDQ=;
    private int yTQ=;
    private bool yjQ=;
    private TiffFieldInfo[] yzQ=;
    private int zDQ=;
    private TiffFieldInfo zTQ=;
    private 2kA= zjQ=;
    private TiffCodec[] zzQ=;
    private 10A= 0DQ=;
    private TiffTagMethods 0TQ=;
    private bool 0jQ=;
    private Stream 0zQ=;
    private TiffStream izQ=;
    private static UInt32[] 1DQ=;
    private static Int32[] 1TQ=;
    private static Int32[] 1jQ=;
    private static String[] 1zQ=;
    private static String[] 2DQ=;
    private static int 2TQ=;
    private static int 2jQ=;
    internal static int 2zQ=;
    internal static int 3DQ=;
    internal static int 3TQ=;
    internal static int 3jQ=;
    internal static int 3zQ=;
    private static Byte[] 4DQ=;
    private static Byte[] 4TQ=;
    public static string AssemblyVersion { get; }
    private static Tiff();
    private static Tiff FR8=(string fileName, string mode, TiffErrorHandler errorHandler);
    private static Tiff FR8=(string fileName, string mode, TiffErrorHandler errorHandler, TiffExtendProc extender);
    private static Tiff 4jQ=(string name, string mode, object clientData, TiffStream stream, TiffErrorHandler errorHandler);
    private static Tiff 4jQ=(string name, string mode, object clientData, TiffStream stream, TiffErrorHandler errorHandler, TiffExtendProc extender);
    private static TiffErrorHandler 4zQ=(TiffErrorHandler errorHandler);
    private static TiffExtendProc 5DQ=(TiffExtendProc extender);
    private static TiffErrorHandler 5TQ=(Tiff tif);
    private static bool 5jQ=(pjY= td);
    private static void 5zQ=(pjY= td);
    internal static ulong 6DQ=(Byte[] buffer, int offset);
    internal static int 6TQ=(Byte[] buffer, int offset);
    internal static void 6jQ=(int value, Byte[] buffer, int offset);
    internal static void 6zQ=(ulong value, Byte[] buffer, int offset);
    internal static short 7DQ=(Byte[] buffer, int offset);
    internal static void 7TQ=(Stream fd, string format, Object[] list);
    private static string 7jQ=(byte value);
    private void 7zQ=();
    internal static bool 8DQ=(TiffTag t);
    private bool 8TQ=(bjM= o);
    private static int 8jQ=(int n);
    private bool 8zQ=(TiffTag tag);
    private void 9DQ=();
    private bool 9TQ=(UInt64& nextdir, Int64& off);
    internal static void 9jQ=(String& cpp, string cp);
    internal static void 9zQ=(Int16[]& wpp, Int16[] wp, int n);
    internal static void /DQ=(Int32[]& lpp, Int32[] lp, int n);
    internal static void /TQ=(Int64[]& lpp, Int64[] lp, int n);
    internal static void /jQ=(Single[]& fpp, Single[] fp, int n);
    internal bool /zQ=(int field);
    internal void ADU=(int field);
    internal void ATU=(int field);
    private static TiffFieldInfo[] AjU=(Int32& size);
    private static TiffFieldInfo[] AzU=(Int32& size);
    private void BDU=(TiffFieldInfo[] info, int n);
    private TiffType BTU=();
    private static TiffFieldInfo BjU=(TiffTag tag, TiffType field_type);
    internal static int BzU=(TiffType type);
    private long CDU=(1jY= dir);
    private bool CTU=(pjY= td);
    private static int CjU=(int x);
    private bool CzU=(1jY=[] dir, long dircount);
    private void DDU=(string tagname);
    private int DTU=(1jY= dir);
    private static long DjU=(1jY=[] dir, ulong dircount, TiffTag tagid);
    private bool DzU=(ulong diroff);
    private ulong EDU=(ulong diroff, 1jY=[]& pdir, UInt64& nextdiroff);
    private bool ETU=(1jY= dir);
    private bool EjU=(1jY= dir, int count);
    private int EzU=(1jY= dir, Byte[] buffer);
    private int FDU=(1jY= dir, String& cp);
    private bool FTU=(1jY= dir, int num, int denom, Single& rv);
    private float FjU=(1jY= dir);
    private float FzU=(1jY= dir);
    private bool GDU=(1jY= dir, Byte[] v);
    private bool GTU=(1jY= dir, Int16[] v);
    private bool GjU=(1jY= dir);
    private bool GzU=(1jY= dir, Int32[] v);
    private bool HDU=(1jY= dir, Int64[] v);
    private bool HTU=(1jY= dir, Single[] v);
    private bool HjU=(1jY= dir, Single[] v);
    private bool HzU=(1jY= dir, Double[] v);
    private bool IDU=(1jY= dir, Double[] v);
    private bool ITU=(1jY= dir);
    private bool IjU=(1jY= dir, Int16& pl);
    private bool IzU=(1jY= dir, Int32& pl);
    private bool JDU=(1jY= dir, Double& pl);
    private bool JTU=(1jY= dir, int nstrips, Int64[]& lpp);
    private bool JTU=(1jY= dir, int nstrips, UInt64[]& lpp);
    private bool JjU=(1jY= dir);
    private void JzU=();
    internal static int KDU=(int x, int y);
    internal static int KTU=(int x, int y);
    internal static ulong KTU=(ulong x, ulong y);
    private ulong KjU=(TiffType type, int v);
    private static void KzU=(Int32[] fields, short f);
    private static bool /zQ=(Int32[] fields, short f);
    private bool LDU=(TiffType type, TiffTag tag, 1jY=& dir, float v);
    private bool LTU=(1jY=[] entries, int dirOffset, TiffType type, TiffTag tag1, float v1, TiffTag tag2, float v2);
    private bool LjU=(bool done);
    private bool LzU=();
    private bool MDU=(1jY=& dir, TiffFieldInfo fip);
    private void MTU=(TiffTag tag, 1jY=& dir, int v);
    private void MjU=(TiffTag tag, 1jY=& dir, short v);
    private bool MzU=(TiffTag tag, 1jY=& dir);
    private bool NDU=(TiffType type, TiffTag tag, 1jY=& dir);
    private bool NTU=(TiffTag tag, 1jY=& dir);
    private bool NjU=(TiffTag tag, 1jY=& dir, int n, Int16[][] table);
    private bool NzU=(1jY=& dir, Byte[] cp);
    private bool ODU=(1jY=& dir, Int16[] v);
    private bool OTU=(1jY=& dir, Int32[] v);
    private bool OTU=(1jY=& dir, UInt32[] v);
    private bool OjU=(1jY=& dir, Int64[] v);
    private bool OjU=(1jY=& dir, UInt64[] v);
    private bool OzU=(1jY=& dir, Single[] v);
    private bool PDU=(1jY=& dir, Single[] v);
    private bool PTU=(1jY=& dir, Double[] v);
    private bool PjU=(TiffType type, TiffTag tag, 1jY=& dir, int n, Double[] v);
    private bool PzU=(1jY=& dir);
    private bool QDU=(1jY=& dir);
    private bool QTU=(1jY=& dir, Byte[] buffer, int count);
    private bool QTU=(1jY=& dir, Int16[] buffer, int count);
    private bool QTU=(1jY=& dir, Int64[] buffer, int count);
    private bool QTU=(1jY=& dir, Int32[] cp, int cc);
    private bool QTU=(1jY=& dir, Single[] cp, int cc);
    private bool QTU=(1jY=& dir, Double[] buffer, int count);
    private bool QjU=();
    private void 0x0=(bool disposing);
    private bool QzU=(Int64& pdiroff);
    internal static void RDU=(UInt32& lp);
    internal static UInt64[] RTU=(UInt64[] buffer, int elementCount, int newElementCount);
    internal static TiffFieldInfo[] RTU=(TiffFieldInfo[] buffer, int elementCount, int newElementCount);
    internal static CTc=[] RTU=(CTc=[] buffer, int elementCount, int newElementCount);
    internal bool RjU=(Compression scheme);
    private void RzU=(Byte[] buffer, int offset, int count);
    private void SDU=(int magic);
    private static int STU=(string mode, string module, FileMode& m, FileAccess& a);
    private static void SjU=(Stream fd, TiffFieldInfo fip, int value_count, object raw_data);
    private bool SzU=(Stream fd, TiffTag tag, int value_count, object raw_data);
    private static void TDU=(Stream fd, string cp);
    private int TTU=(Byte[] buf, int offset, int size);
    private long TjU=(long off, SeekOrigin whence);
    private long TzU=();
    private bool UDU=(Byte[] buf, int size);
    private bool UTU=(Int16& value);
    private bool UjU=(UInt64& dircount, bool isBigTiff);
    private bool UzU=(UInt32& value);
    private bool VDU=(UInt64& value);
    private bool VTU=(Int64& value);
    private bool VjU=(Int32& value);
    private bool VzU=(1jY=[] dir, ulong dircount, bool isBigTiff);
    private static void WDU=(1jY=[] dir, ulong dircount, Byte[] bytes, int offset, bool isBigTiff);
    private bool WTU=(ADc=& header);
    private bool WjU=(long off);
    private bool WzU=(int row, short sample);
    private int XDU=(int strip, Byte[] buf, int offset, int size, string module);
    private int XTU=(int tile, Byte[] buf, int offset, int size, string module);
    private bool XjU=(int strip);
    private bool XzU=(int tile);
    private bool YDU=(bool tiles);
    private static void YTU=(Byte[] buffer, int offset, int count);
    private static void YjU=(Byte[] buffer, int offset, int count);
    private static void YzU=(Byte[] buffer, int offset, int count);
    private static void ZDU=(Byte[] buffer, int offset, int count);
    internal bool ZTU=(int strip);
    internal bool ZjU=(int tile);
    private int ZzU=(int summand1, int summand2, string where);
    private int aDU=(int nmemb, int elem_size, string where);
    internal int aTU=();
    internal int ajU=();
    private bool azU=(string module);
    private bool bDU=(string module);
    private void bTU=();
    private bool bjU=(Byte[] buffer, int offset, int count);
    private bool bzU=(ADc= header);
    private bool cDU=(1jY=[] entries, long count, bool isBigTiff);
    private bool cTU=(short value);
    private bool cjU=(long value, bool isBigTiff);
    private bool czU=(long value, bool isBigTiff);
    private bool dDU=(int value);
    private bool dTU=(long value);
    private bool djU=(int f);
    private bool dzU=(int delta);
    private bool eDU=(int strip, Byte[] buffer, int offset, long count);
    internal bool eTU=();
    public static string GetVersion();
    public static string get_AssemblyVersion();
    public static int GetR(int abgr);
    public static int GetG(int abgr);
    public static int GetB(int abgr);
    public static int GetA(int abgr);
    public TiffCodec FindCodec(Compression scheme);
    public void RegisterCodec(TiffCodec codec);
    public void UnRegisterCodec(TiffCodec codec);
    public bool IsCodecConfigured(Compression scheme);
    public TiffCodec[] GetConfiguredCodecs();
    public static Byte[] Realloc(Byte[] array, int size);
    public static Int32[] Realloc(Int32[] array, int size);
    public static int Compare(Int16[] first, Int16[] second, int elementCount);
    public static Tiff Open(string fileName, string mode);
    public static Tiff ClientOpen(string name, string mode, object clientData, TiffStream stream);
    public void Close();
    public sealed virtual void Dispose();
    public int GetTagListCount();
    public int GetTagListEntry(int index);
    public void MergeFieldInfo(TiffFieldInfo[] info, int count);
    public TiffFieldInfo FindFieldInfo(TiffTag tag, TiffType type);
    public TiffFieldInfo FindFieldInfoByName(string name, TiffType type);
    public TiffFieldInfo FieldWithTag(TiffTag tag);
    public TiffFieldInfo FieldWithName(string name);
    public TiffTagMethods GetTagMethods();
    public TiffTagMethods SetTagMethods(TiffTagMethods methods);
    public object GetClientInfo(string name);
    public void SetClientInfo(object data, string name);
    public bool Flush();
    public bool FlushData();
    public FieldValue[] GetField(TiffTag tag);
    public FieldValue[] GetFieldDefaulted(TiffTag tag);
    public bool ReadDirectory();
    public bool ReadCustomDirectory(long offset, TiffFieldInfo[] info, int count);
    public bool ReadEXIFDirectory(long offset);
    public int ScanlineSize();
    public int RasterScanlineSize();
    public int DefaultStripSize(int estimate);
    public int StripSize();
    public int VStripSize(int rowCount);
    public long RawStripSize(int strip);
    public int ComputeStrip(int row, short plane);
    public int NumberOfStrips();
    public void DefaultTileSize(Int32& width, Int32& height);
    public int TileSize();
    public int VTileSize(int rowCount);
    public long RawTileSize(int tile);
    public int TileRowSize();
    public int ComputeTile(int x, int y, int z, short plane);
    public bool CheckTile(int x, int y, int z, short plane);
    public int NumberOfTiles();
    public object Clientdata();
    public object SetClientdata(object data);
    public int GetMode();
    public int SetMode(int mode);
    public bool IsTiled();
    public bool IsByteSwapped();
    public bool IsUpSampled();
    public bool IsMSB2LSB();
    public bool IsBigEndian();
    public TiffStream GetStream();
    public int CurrentRow();
    public short CurrentDirectory();
    public short NumberOfDirectories();
    public long CurrentDirOffset();
    public int CurrentStrip();
    public int CurrentTile();
    public void ReadBufferSetup(Byte[] buffer, int size);
    public void WriteBufferSetup(Byte[] buffer, int size);
    public bool SetupStrips();
    public bool WriteCheck(bool tiles, string method);
    public void FreeDirectory();
    public void CreateDirectory();
    public bool LastDirectory();
    public bool SetDirectory(short number);
    public bool SetSubDirectory(long offset);
    public bool UnlinkDirectory(short number);
    public bool SetField(TiffTag tag, Object[] value);
    public bool WriteDirectory();
    public bool CheckpointDirectory();
    public bool RewriteDirectory();
    public void PrintDirectory(Stream stream);
    public void PrintDirectory(Stream stream, TiffPrintFlags flags);
    public bool ReadScanline(Byte[] buffer, int row);
    public bool ReadScanline(Byte[] buffer, int row, short plane);
    public bool ReadScanline(Byte[] buffer, int offset, int row, short plane);
    public bool WriteScanline(Byte[] buffer, int row);
    public bool WriteScanline(Byte[] buffer, int row, short plane);
    public bool WriteScanline(Byte[] buffer, int offset, int row, short plane);
    public bool ReadRGBAImage(int width, int height, Int32[] raster);
    public bool ReadRGBAImage(int width, int height, Int32[] raster, bool stopOnError);
    public bool ReadRGBAImageOriented(int width, int height, Int32[] raster, Orientation orientation);
    public bool ReadRGBAImageOriented(int width, int height, Int32[] raster, Orientation orientation, bool stopOnError);
    public bool ReadRGBAStrip(int row, Int32[] raster);
    public bool ReadRGBATile(int col, int row, Int32[] raster);
    public bool RGBAImageOK(String& errorMsg);
    public string FileName();
    public string SetFileName(string name);
    public static void Error(Tiff tif, string method, string format, Object[] args);
    public static void Error(string method, string format, Object[] args);
    public static void ErrorExt(Tiff tif, object clientData, string method, string format, Object[] args);
    public static void ErrorExt(object clientData, string method, string format, Object[] args);
    public static void Warning(Tiff tif, string method, string format, Object[] args);
    public static void Warning(string method, string format, Object[] args);
    public static void WarningExt(Tiff tif, object clientData, string method, string format, Object[] args);
    public static void WarningExt(object clientData, string method, string format, Object[] args);
    public static TiffErrorHandler SetErrorHandler(TiffErrorHandler errorHandler);
    public static TiffExtendProc SetTagExtender(TiffExtendProc extender);
    public int ReadTile(Byte[] buffer, int offset, int x, int y, int z, short plane);
    public int ReadEncodedTile(int tile, Byte[] buffer, int offset, int count);
    public int ReadRawTile(int tile, Byte[] buffer, int offset, int count);
    public int WriteTile(Byte[] buffer, int x, int y, int z, short plane);
    public int WriteTile(Byte[] buffer, int offset, int x, int y, int z, short plane);
    public int ReadEncodedStrip(int strip, Byte[] buffer, int offset, int count);
    public int ReadRawStrip(int strip, Byte[] buffer, int offset, int count);
    public int WriteEncodedStrip(int strip, Byte[] buffer, int count);
    public int WriteEncodedStrip(int strip, Byte[] buffer, int offset, int count);
    public int WriteRawStrip(int strip, Byte[] buffer, int count);
    public int WriteRawStrip(int strip, Byte[] buffer, int offset, int count);
    public int WriteEncodedTile(int tile, Byte[] buffer, int count);
    public int WriteEncodedTile(int tile, Byte[] buffer, int offset, int count);
    public int WriteRawTile(int tile, Byte[] buffer, int count);
    public int WriteRawTile(int tile, Byte[] buffer, int offset, int count);
    public void SetWriteOffset(long offset);
    public static int DataWidth(TiffType type);
    public static void SwabShort(Int16& value);
    public static void SwabLong(Int32& value);
    private static void ejU=(UInt64& value);
    private static void ezU=(UInt64& value, bool isBigTiff, bool isShort);
    public static void SwabDouble(Double& value);
    public static void SwabArrayOfShort(Int16[] array, int count);
    public static void SwabArrayOfShort(Int16[] array, int offset, int count);
    public static void SwabArrayOfTriples(Byte[] array, int count);
    public static void SwabArrayOfTriples(Byte[] array, int offset, int count);
    public static void SwabArrayOfLong(Int32[] array, int count);
    public static void SwabArrayOfLong8(Int64[] array, int count);
    public static void SwabArrayOfLong(Int32[] array, int offset, int count);
    public static void SwabArrayOfLong8(Int64[] array, int offset, int count);
    public static void SwabArrayOfDouble(Double[] array, int count);
    public static void SwabArrayOfDouble(Double[] array, int offset, int count);
    public static void ReverseBits(Byte[] buffer, int count);
    public static void ReverseBits(Byte[] buffer, int offset, int count);
    public static Byte[] GetBitRevTable(bool reversed);
    public static Int32[] ByteArrayToInts(Byte[] buffer, int offset, int count);
    public static Int64[] ByteArrayToLong8(Byte[] buffer, int offset, int count);
    public static void Long8ToByteArray(Int64[] source, int srcOffset, int srcCount, Byte[] bytes, int offset);
    public static void IntsToByteArray(Int32[] source, int srcOffset, int srcCount, Byte[] bytes, int offset);
    public static Int16[] ByteArrayToShorts(Byte[] buffer, int offset, int count);
    public static void ShortsToByteArray(Int16[] source, int srcOffset, int srcCount, Byte[] bytes, int offset);
    private static Int64[] fDU=(Int32[] inputArray);
    private static UInt32[] fTU=(UInt64[] inputArray);
    private static Int32[] fTU=(Int64[] inputArray);
}
public class ThinkGeo.Core.LibTiff.TiffCodec : object {
    protected Tiff m_tif;
    protected internal Compression m_scheme;
    protected internal string m_name;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public TiffCodec(Tiff tif, Compression scheme, string name);
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool Init();
    public virtual bool SetupDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual void Close();
    public virtual bool Seek(int row);
    public virtual void Cleanup();
    public virtual int DefStripSize(int size);
    public virtual void DefTileSize(Int32& width, Int32& height);
    private bool zDs=(string method);
    private bool zTs=(string method);
}
public class ThinkGeo.Core.LibTiff.TiffErrorHandler : object {
    public virtual void ErrorHandler(Tiff tif, string method, string format, Object[] args);
    public virtual void ErrorHandlerExt(Tiff tif, object clientData, string method, string format, Object[] args);
    public virtual void WarningHandler(Tiff tif, string method, string format, Object[] args);
    public virtual void WarningHandlerExt(Tiff tif, object clientData, string method, string format, Object[] args);
}
public class ThinkGeo.Core.LibTiff.TiffFieldInfo : object {
    private TiffTag zjs=;
    private short zzs=;
    private short 0Ds=;
    private TiffType 0Ts=;
    private short DTQ=;
    private bool 0js=;
    private bool 0zs=;
    private string rDQ=;
    public static short Variable;
    public static short Spp;
    public static short Variable2;
    public TiffTag Tag { get; }
    public short ReadCount { get; }
    public short WriteCount { get; }
    public TiffType Type { get; }
    public short Bit { get; }
    public bool OkToChange { get; }
    public bool PassCount { get; }
    public string Name { get; internal set; }
    public TiffFieldInfo(TiffTag tag, short readCount, short writeCount, TiffType type, short bit, bool okToChange, bool passCount, string name);
    public virtual string ToString();
    public TiffTag get_Tag();
    public short get_ReadCount();
    public short get_WriteCount();
    public TiffType get_Type();
    public short get_Bit();
    public bool get_OkToChange();
    public bool get_PassCount();
    public string get_Name();
    internal void set_Name(string value);
}
[FlagsAttribute]
public enum ThinkGeo.Core.LibTiff.TiffPrintFlags : Enum {
    public int value__;
    public static TiffPrintFlags NONE;
    public static TiffPrintFlags STRIPS;
    public static TiffPrintFlags CURVES;
    public static TiffPrintFlags COLORMAP;
    public static TiffPrintFlags JPEGQTABLES;
    public static TiffPrintFlags JPEGACTABLES;
    public static TiffPrintFlags JPEGDCTABLES;
}
public class ThinkGeo.Core.LibTiff.TiffStream : object {
    public virtual int Read(object clientData, Byte[] buffer, int offset, int count);
    public virtual void Write(object clientData, Byte[] buffer, int offset, int count);
    public virtual long Seek(object clientData, long offset, SeekOrigin origin);
    public virtual void Close(object clientData);
    public virtual long Size(object clientData);
}
public enum ThinkGeo.Core.LibTiff.TiffTag : Enum {
    public int value__;
    public static TiffTag IGNORE;
    public static TiffTag SUBFILETYPE;
    public static TiffTag OSUBFILETYPE;
    public static TiffTag IMAGEWIDTH;
    public static TiffTag IMAGELENGTH;
    public static TiffTag BITSPERSAMPLE;
    public static TiffTag COMPRESSION;
    public static TiffTag PHOTOMETRIC;
    public static TiffTag THRESHHOLDING;
    public static TiffTag CELLWIDTH;
    public static TiffTag CELLLENGTH;
    public static TiffTag FILLORDER;
    public static TiffTag DOCUMENTNAME;
    public static TiffTag IMAGEDESCRIPTION;
    public static TiffTag MAKE;
    public static TiffTag MODEL;
    public static TiffTag STRIPOFFSETS;
    public static TiffTag ORIENTATION;
    public static TiffTag SAMPLESPERPIXEL;
    public static TiffTag ROWSPERSTRIP;
    public static TiffTag STRIPBYTECOUNTS;
    public static TiffTag MINSAMPLEVALUE;
    public static TiffTag MAXSAMPLEVALUE;
    public static TiffTag XRESOLUTION;
    public static TiffTag YRESOLUTION;
    public static TiffTag PLANARCONFIG;
    public static TiffTag PAGENAME;
    public static TiffTag XPOSITION;
    public static TiffTag YPOSITION;
    public static TiffTag FREEOFFSETS;
    public static TiffTag FREEBYTECOUNTS;
    public static TiffTag GRAYRESPONSEUNIT;
    public static TiffTag GRAYRESPONSECURVE;
    public static TiffTag GROUP3OPTIONS;
    public static TiffTag T4OPTIONS;
    public static TiffTag GROUP4OPTIONS;
    public static TiffTag T6OPTIONS;
    public static TiffTag RESOLUTIONUNIT;
    public static TiffTag PAGENUMBER;
    public static TiffTag COLORRESPONSEUNIT;
    public static TiffTag TRANSFERFUNCTION;
    public static TiffTag SOFTWARE;
    public static TiffTag DATETIME;
    public static TiffTag ARTIST;
    public static TiffTag HOSTCOMPUTER;
    public static TiffTag PREDICTOR;
    public static TiffTag WHITEPOINT;
    public static TiffTag PRIMARYCHROMATICITIES;
    public static TiffTag COLORMAP;
    public static TiffTag HALFTONEHINTS;
    public static TiffTag TILEWIDTH;
    public static TiffTag TILELENGTH;
    public static TiffTag TILEOFFSETS;
    public static TiffTag TILEBYTECOUNTS;
    public static TiffTag BADFAXLINES;
    public static TiffTag CLEANFAXDATA;
    public static TiffTag CONSECUTIVEBADFAXLINES;
    public static TiffTag SUBIFD;
    public static TiffTag INKSET;
    public static TiffTag INKNAMES;
    public static TiffTag NUMBEROFINKS;
    public static TiffTag DOTRANGE;
    public static TiffTag TARGETPRINTER;
    public static TiffTag EXTRASAMPLES;
    public static TiffTag SAMPLEFORMAT;
    public static TiffTag SMINSAMPLEVALUE;
    public static TiffTag SMAXSAMPLEVALUE;
    public static TiffTag CLIPPATH;
    public static TiffTag XCLIPPATHUNITS;
    public static TiffTag YCLIPPATHUNITS;
    public static TiffTag INDEXED;
    public static TiffTag JPEGTABLES;
    public static TiffTag OPIPROXY;
    public static TiffTag JPEGPROC;
    public static TiffTag JPEGIFOFFSET;
    public static TiffTag JPEGIFBYTECOUNT;
    public static TiffTag JPEGRESTARTINTERVAL;
    public static TiffTag JPEGLOSSLESSPREDICTORS;
    public static TiffTag JPEGPOINTTRANSFORM;
    public static TiffTag JPEGQTABLES;
    public static TiffTag JPEGDCTABLES;
    public static TiffTag JPEGACTABLES;
    public static TiffTag YCBCRCOEFFICIENTS;
    public static TiffTag YCBCRSUBSAMPLING;
    public static TiffTag YCBCRPOSITIONING;
    public static TiffTag REFERENCEBLACKWHITE;
    public static TiffTag XMLPACKET;
    public static TiffTag OPIIMAGEID;
    public static TiffTag REFPTS;
    public static TiffTag REGIONTACKPOINT;
    public static TiffTag REGIONWARPCORNERS;
    public static TiffTag REGIONAFFINE;
    public static TiffTag MATTEING;
    public static TiffTag DATATYPE;
    public static TiffTag IMAGEDEPTH;
    public static TiffTag TILEDEPTH;
    public static TiffTag PIXAR_IMAGEFULLWIDTH;
    public static TiffTag PIXAR_IMAGEFULLLENGTH;
    public static TiffTag PIXAR_TEXTUREFORMAT;
    public static TiffTag PIXAR_WRAPMODES;
    public static TiffTag PIXAR_FOVCOT;
    public static TiffTag PIXAR_MATRIX_WORLDTOSCREEN;
    public static TiffTag PIXAR_MATRIX_WORLDTOCAMERA;
    public static TiffTag WRITERSERIALNUMBER;
    public static TiffTag COPYRIGHT;
    public static TiffTag RICHTIFFIPTC;
    public static TiffTag IT8SITE;
    public static TiffTag IT8COLORSEQUENCE;
    public static TiffTag IT8HEADER;
    public static TiffTag IT8RASTERPADDING;
    public static TiffTag IT8BITSPERRUNLENGTH;
    public static TiffTag IT8BITSPEREXTENDEDRUNLENGTH;
    public static TiffTag IT8COLORTABLE;
    public static TiffTag IT8IMAGECOLORINDICATOR;
    public static TiffTag IT8BKGCOLORINDICATOR;
    public static TiffTag IT8IMAGECOLORVALUE;
    public static TiffTag IT8BKGCOLORVALUE;
    public static TiffTag IT8PIXELINTENSITYRANGE;
    public static TiffTag IT8TRANSPARENCYINDICATOR;
    public static TiffTag IT8COLORCHARACTERIZATION;
    public static TiffTag IT8HCUSAGE;
    public static TiffTag IT8TRAPINDICATOR;
    public static TiffTag IT8CMYKEQUIVALENT;
    public static TiffTag FRAMECOUNT;
    public static TiffTag PHOTOSHOP;
    public static TiffTag EXIFIFD;
    public static TiffTag ICCPROFILE;
    public static TiffTag JBIGOPTIONS;
    public static TiffTag GPSIFD;
    public static TiffTag FAXRECVPARAMS;
    public static TiffTag FAXSUBADDRESS;
    public static TiffTag FAXRECVTIME;
    public static TiffTag FAXDCS;
    public static TiffTag STONITS;
    public static TiffTag FEDEX_EDR;
    public static TiffTag INTEROPERABILITYIFD;
    public static TiffTag DNGVERSION;
    public static TiffTag DNGBACKWARDVERSION;
    public static TiffTag UNIQUECAMERAMODEL;
    public static TiffTag LOCALIZEDCAMERAMODEL;
    public static TiffTag CFAPLANECOLOR;
    public static TiffTag CFALAYOUT;
    public static TiffTag LINEARIZATIONTABLE;
    public static TiffTag BLACKLEVELREPEATDIM;
    public static TiffTag BLACKLEVEL;
    public static TiffTag BLACKLEVELDELTAH;
    public static TiffTag BLACKLEVELDELTAV;
    public static TiffTag WHITELEVEL;
    public static TiffTag DEFAULTSCALE;
    public static TiffTag DEFAULTCROPORIGIN;
    public static TiffTag DEFAULTCROPSIZE;
    public static TiffTag COLORMATRIX1;
    public static TiffTag COLORMATRIX2;
    public static TiffTag CAMERACALIBRATION1;
    public static TiffTag CAMERACALIBRATION2;
    public static TiffTag REDUCTIONMATRIX1;
    public static TiffTag REDUCTIONMATRIX2;
    public static TiffTag ANALOGBALANCE;
    public static TiffTag ASSHOTNEUTRAL;
    public static TiffTag ASSHOTWHITEXY;
    public static TiffTag BASELINEEXPOSURE;
    public static TiffTag BASELINENOISE;
    public static TiffTag BASELINESHARPNESS;
    public static TiffTag BAYERGREENSPLIT;
    public static TiffTag LINEARRESPONSELIMIT;
    public static TiffTag CAMERASERIALNUMBER;
    public static TiffTag LENSINFO;
    public static TiffTag CHROMABLURRADIUS;
    public static TiffTag ANTIALIASSTRENGTH;
    public static TiffTag SHADOWSCALE;
    public static TiffTag DNGPRIVATEDATA;
    public static TiffTag MAKERNOTESAFETY;
    public static TiffTag CALIBRATIONILLUMINANT1;
    public static TiffTag CALIBRATIONILLUMINANT2;
    public static TiffTag BESTQUALITYSCALE;
    public static TiffTag RAWDATAUNIQUEID;
    public static TiffTag ORIGINALRAWFILENAME;
    public static TiffTag ORIGINALRAWFILEDATA;
    public static TiffTag ACTIVEAREA;
    public static TiffTag MASKEDAREAS;
    public static TiffTag ASSHOTICCPROFILE;
    public static TiffTag ASSHOTPREPROFILEMATRIX;
    public static TiffTag CURRENTICCPROFILE;
    public static TiffTag CURRENTPREPROFILEMATRIX;
    public static TiffTag DCSHUESHIFTVALUES;
    public static TiffTag FAXMODE;
    public static TiffTag JPEGQUALITY;
    public static TiffTag JPEGCOLORMODE;
    public static TiffTag JPEGTABLESMODE;
    public static TiffTag FAXFILLFUNC;
    public static TiffTag PIXARLOGDATAFMT;
    public static TiffTag DCSIMAGERTYPE;
    public static TiffTag DCSINTERPMODE;
    public static TiffTag DCSBALANCEARRAY;
    public static TiffTag DCSCORRECTMATRIX;
    public static TiffTag DCSGAMMA;
    public static TiffTag DCSTOESHOULDERPTS;
    public static TiffTag DCSCALIBRATIONFD;
    public static TiffTag ZIPQUALITY;
    public static TiffTag PIXARLOGQUALITY;
    public static TiffTag DCSCLIPRECTANGLE;
    public static TiffTag SGILOGDATAFMT;
    public static TiffTag SGILOGENCODE;
    public static TiffTag EXIF_EXPOSURETIME;
    public static TiffTag EXIF_FNUMBER;
    public static TiffTag EXIF_EXPOSUREPROGRAM;
    public static TiffTag EXIF_SPECTRALSENSITIVITY;
    public static TiffTag EXIF_ISOSPEEDRATINGS;
    public static TiffTag EXIF_OECF;
    public static TiffTag EXIF_EXIFVERSION;
    public static TiffTag EXIF_DATETIMEORIGINAL;
    public static TiffTag EXIF_DATETIMEDIGITIZED;
    public static TiffTag EXIF_COMPONENTSCONFIGURATION;
    public static TiffTag EXIF_COMPRESSEDBITSPERPIXEL;
    public static TiffTag EXIF_SHUTTERSPEEDVALUE;
    public static TiffTag EXIF_APERTUREVALUE;
    public static TiffTag EXIF_BRIGHTNESSVALUE;
    public static TiffTag EXIF_EXPOSUREBIASVALUE;
    public static TiffTag EXIF_MAXAPERTUREVALUE;
    public static TiffTag EXIF_SUBJECTDISTANCE;
    public static TiffTag EXIF_METERINGMODE;
    public static TiffTag EXIF_LIGHTSOURCE;
    public static TiffTag EXIF_FLASH;
    public static TiffTag EXIF_FOCALLENGTH;
    public static TiffTag EXIF_SUBJECTAREA;
    public static TiffTag EXIF_MAKERNOTE;
    public static TiffTag EXIF_USERCOMMENT;
    public static TiffTag EXIF_SUBSECTIME;
    public static TiffTag EXIF_SUBSECTIMEORIGINAL;
    public static TiffTag EXIF_SUBSECTIMEDIGITIZED;
    public static TiffTag EXIF_FLASHPIXVERSION;
    public static TiffTag EXIF_COLORSPACE;
    public static TiffTag EXIF_PIXELXDIMENSION;
    public static TiffTag EXIF_PIXELYDIMENSION;
    public static TiffTag EXIF_RELATEDSOUNDFILE;
    public static TiffTag EXIF_FLASHENERGY;
    public static TiffTag EXIF_SPATIALFREQUENCYRESPONSE;
    public static TiffTag EXIF_FOCALPLANEXRESOLUTION;
    public static TiffTag EXIF_FOCALPLANEYRESOLUTION;
    public static TiffTag EXIF_FOCALPLANERESOLUTIONUNIT;
    public static TiffTag EXIF_SUBJECTLOCATION;
    public static TiffTag EXIF_EXPOSUREINDEX;
    public static TiffTag EXIF_SENSINGMETHOD;
    public static TiffTag EXIF_FILESOURCE;
    public static TiffTag EXIF_SCENETYPE;
    public static TiffTag EXIF_CFAPATTERN;
    public static TiffTag EXIF_CUSTOMRENDERED;
    public static TiffTag EXIF_EXPOSUREMODE;
    public static TiffTag EXIF_WHITEBALANCE;
    public static TiffTag EXIF_DIGITALZOOMRATIO;
    public static TiffTag EXIF_FOCALLENGTHIN35MMFILM;
    public static TiffTag EXIF_SCENECAPTURETYPE;
    public static TiffTag EXIF_GAINCONTROL;
    public static TiffTag EXIF_CONTRAST;
    public static TiffTag EXIF_SATURATION;
    public static TiffTag EXIF_SHARPNESS;
    public static TiffTag EXIF_DEVICESETTINGDESCRIPTION;
    public static TiffTag EXIF_SUBJECTDISTANCERANGE;
    public static TiffTag EXIF_IMAGEUNIQUEID;
    public static TiffTag GEOTIFF_MODELPIXELSCALETAG;
    public static TiffTag GEOTIFF_MODELTIEPOINTTAG;
    public static TiffTag GEOTIFF_MODELTRANSFORMATIONTAG;
    public static TiffTag GEOTIFF_GEOASCIIPARAMS;
    public static TiffTag GEOKEYDIRECTORY;
}
public class ThinkGeo.Core.LibTiff.TiffTagMethods : object {
    private static short RDw=;
    private static short RTw=;
    private static short Rjw=;
    private static short Rzw=;
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] value);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream stream, TiffPrintFlags flags);
    private static bool SDw=(pjY= td, Int32& v, FieldValue[] ap);
    private static int STw=(Tiff tif, int slen, string s);
    private static void Sjw=(String& cpp, string cp, int n);
}
public enum ThinkGeo.Core.LibTiff.TiffType : Enum {
    public short value__;
    public static TiffType NOTYPE;
    public static TiffType ANY;
    public static TiffType BYTE;
    public static TiffType ASCII;
    public static TiffType SHORT;
    public static TiffType LONG;
    public static TiffType RATIONAL;
    public static TiffType SBYTE;
    public static TiffType UNDEFINED;
    public static TiffType SSHORT;
    public static TiffType SLONG;
    public static TiffType SRATIONAL;
    public static TiffType FLOAT;
    public static TiffType DOUBLE;
    public static TiffType IFD;
    public static TiffType LONG8;
    public static TiffType SLONG8;
    public static TiffType IFD8;
}
public class ThinkGeo.Core.LinealKrigingGridInterpolationModel : KrigingGridInterpolationModel {
    public LinealKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    public LinealKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points, int numberOfRefreancedPoints);
    protected virtual double GetSemivarianceCore(double distance, EmpiricalFunctionCoefficients coefficients);
    protected virtual double GetSillSlopeCore(double distance, double range);
}
public abstract class ThinkGeo.Core.LineBaseShape : BaseShape {
    public double GetLength(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetLengthCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public static LineBaseShape ScaleUp(LineBaseShape sourceShape, double percentage);
    public static Feature ScaleUp(Feature sourceLine, double percentage);
    public void ScaleUp(double percentage);
    protected virtual void ScaleUpCore(double percentage);
    public static LineBaseShape ScaleDown(LineBaseShape sourceLineBaseShape, double percentage);
    public static Feature ScaleDown(Feature sourceLine, double percentage);
    public void ScaleDown(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    public double GetLength(int shapeSrid, DistanceUnit returningUnit);
    public double GetLength(string shapeProj4ProjectionParameters, DistanceUnit returningUnit);
    public double GetLength(Projection shapeProjection, DistanceUnit returningUnit);
    public double GetLength(int shapeSrid, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetLength(string shapeProj4ProjectionParameters, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public double GetLength(Projection shapeProjection, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    protected virtual double GetLengthCore(Projection shapeProjection, DistanceUnit returningUnit, DistanceCalculationMode distanceCalculationMode);
    public RingShape ConvexHull();
    protected virtual RingShape ConvexHullCore();
    private void SRU=(double factor);
    public static MultilineShape Simplify(LineBaseShape targetShape, GeographyUnit targetShapeUnit, double tolerance, DistanceUnit toleranceUnit, SimplificationType simplificationType);
    public static MultilineShape Simplify(LineBaseShape targetShape, double tolerance, SimplificationType simplificationType);
    public MultilineShape Simplify(GeographyUnit shapeUnit, double tolerance, DistanceUnit toleranceUnit, SimplificationType simplificationType);
    public MultilineShape Simplify(double tolerance, SimplificationType simplificationType);
    protected virtual MultilineShape SimplifyCore(double tolerance, SimplificationType simplificationType);
    public MultilineShape Union(LineBaseShape targetShape);
    public static MultilineShape Union(IEnumerable`1<LineBaseShape> lineBaseShapes);
    public MultilineShape Union(Feature targetFeature);
    public static MultilineShape Union(IEnumerable`1<Feature> targetFeatures);
    protected virtual MultilineShape UnionCore(IEnumerable`1<LineBaseShape> lineBaseShapes);
    private BaseShape zRo=(IEnumerable`1<LineBaseShape> lineBaseShapes, int count);
    public MultilineShape GetIntersection(Feature targetFeature);
    public MultilineShape GetIntersection(AreaBaseShape targetShape);
    protected virtual MultilineShape GetIntersectionCore(AreaBaseShape targetShape);
    internal static bool 3Ro=(Vertex vertex1, Vertex vertex2, PointShape point);
    public static Collection`1<LineShape> Snap(IEnumerable`1<LineBaseShape> shapes, GeographyUnit shapeUnit, double snappingTolerance, DistanceUnit toleranceUnit);
    private static Collection`1<LineShape> 3ho=(IEnumerable`1<LineBaseShape> lineBaseShapes);
    private static bool 3xo=(IEnumerable`1<LineShape> lineShapes, double tolerance);
    private static void 4Bo=(Collection`1<LineShape> lineshapes);
    private static Collection`1<LineShape> 4Ro=(IEnumerable`1<LineShape> intersectingLines);
    private static bool 4ho=(Collection`1<LineShape> lineShapes, double tolerance);
    private static void 4xo=(Collection`1<KeyValuePair`2<LineShape, int>> linesCache, Vertex newVertex);
    private static bool 5Bo=(Vertex currentVertex, LineShape currentLineShape, int currentVertexIndex, LineShape closestLineShape, PointShape closestPoint);
    private static bool 5Ro=(LineShape lineShape, LineShape intersectingLine);
}
public enum ThinkGeo.Core.LineDashStyle : Enum {
    public int value__;
    public static LineDashStyle Solid;
    public static LineDashStyle Custom;
    public static LineDashStyle DashDot;
    public static LineDashStyle DashDotDot;
    public static LineDashStyle Dot;
    public static LineDashStyle Dash;
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.LineShape : LineBaseShape {
    [ObfuscationAttribute]
private Collection`1<Vertex> vertices;
    public Collection`1<Vertex> Vertices { get; }
    public LineShape(IEnumerable`1<Vertex> points);
    public LineShape(string wellKnownText);
    public LineShape(Byte[] wellKnownBinary);
    public Collection`1<Vertex> get_Vertices();
    public void ReversePoints();
    protected virtual void ReversePointsCore();
    protected virtual BaseShape CloneDeepCore();
    public bool IsClosed();
    protected virtual bool IsClosedCore();
    protected virtual double GetLengthCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public PointShape GetPointOnALine(StartingPoint startingPoint, float percentageOfLine);
    public PointShape GetPointOnALine(StartingPoint startingPoint, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetPointOnALineCore(StartingPoint startingPoint, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, float startingPercentageOfTheLine, float percentageOfTheLine);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, float percentageOfLine);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, double startingDistance, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual LineBaseShape GetLineOnALineCore(StartingPoint startingPoint, double startingDistance, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, PointShape endPointShape);
    public LineBaseShape GetLineOnALine(PointShape startPointShape, PointShape endPointShape);
    public double GetSublinePercentage(PointShape sublineEndpoint, double tolerance);
    protected virtual double GetSublinePercentageCore(PointShape sublineEndpoint, double tolerance);
    public PointLineRelationship GetPointPosition(PointShape pointShape, double tolerance);
    protected virtual PointLineRelationship GetPointPositionCore(PointShape pointShape, double tolerance);
    private LineShape SBw=(PointShape startPointShape, PointShape endPointShape);
    private double SRw=(PointShape pointShape);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual PointShape GetCenterPointCore();
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    private static void Shw=(LineShape fromLine, LineShape toLine);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public static bool RemoveVertex(Vertex selectedVertex, LineShape lineShape);
    public bool RemoveVertex(Vertex selectedVertex);
    public PolygonShape ToPolygonShape();
    private MultipointShape Sxw=(BaseShape targetShape);
    private MultipointShape TBw=(BaseShape targetShape);
    private MultipointShape TRw=(BaseShape targetShape);
    private static void Thw=(Geometry result, MultipointShape resultMultiPointShape);
    internal void SRU=(double factor);
    private void Txw=(EllipseShape ellipse, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void UBw=(PolygonShape polygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void URw=(MultipolygonShape multiPolygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void KRw=(PointShape pointShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void Uhw=(MultipointShape multiPointShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void Uxw=(LineShape lineShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private void VBw=(MultilineShape multilineShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit, PointShape& closestPointShape, Double& minDistance);
    private static RectangleShape VRw=(IEnumerable`1<Vertex> vertices);
    private PointShape Vhw=(double distance);
    private PointShape Vxw=(double distance, DistanceUnit distanceUnit);
}
public class ThinkGeo.Core.LineStyle : Style {
    [ObfuscationAttribute]
private GeoPen centerPen;
    [ObfuscationAttribute]
private Collection`1<LineStyle> customLineStyles;
    [ObfuscationAttribute]
private GeoPen innerPen;
    [ObfuscationAttribute]
private GeoPen outerPen;
    [ObfuscationAttribute]
private float xOffsetInPixel;
    [ObfuscationAttribute]
private float yOffsetInPixel;
    [ObfuscationAttribute]
private DrawingLevel outerPenDrawingLevel;
    [ObfuscationAttribute]
private DrawingLevel innerPenDrawingLevel;
    [ObfuscationAttribute]
private DrawingLevel centerPenDrawingLevel;
    [ObfuscationAttribute]
private PointStyle directionPointStyle;
    [ObfuscationAttribute]
private double directionPointInterval;
    [ObfuscationAttribute]
private double directionPointMinimumInterval;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingDirectionPointEventArgs> GjE=;
    public float XOffsetInPixel { get; public set; }
    public float YOffsetInPixel { get; public set; }
    public Collection`1<LineStyle> CustomLineStyles { get; }
    public GeoPen OuterPen { get; public set; }
    public GeoPen InnerPen { get; public set; }
    public GeoPen CenterPen { get; public set; }
    public DrawingLevel OuterPenDrawingLevel { get; public set; }
    public DrawingLevel InnerPenDrawingLevel { get; public set; }
    public DrawingLevel CenterPenDrawingLevel { get; public set; }
    internal bool ohU= { get; }
    public PointStyle DirectionPointStyle { get; public set; }
    public double DirectionPointInterval { get; public set; }
    public double DirectionPointMinimumInterval { get; public set; }
    public LineStyle(GeoPen outerPen);
    public LineStyle(GeoPen outerPen, GeoPen innerPen);
    public LineStyle(GeoPen outerPen, GeoPen innerPen, GeoPen centerPen);
    [CompilerGeneratedAttribute]
public void add_DrawingDirectionPoint(EventHandler`1<DrawingDirectionPointEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DrawingDirectionPoint(EventHandler`1<DrawingDirectionPointEventArgs> value);
    public float get_XOffsetInPixel();
    public void set_XOffsetInPixel(float value);
    public float get_YOffsetInPixel();
    public void set_YOffsetInPixel(float value);
    public Collection`1<LineStyle> get_CustomLineStyles();
    public GeoPen get_OuterPen();
    public void set_OuterPen(GeoPen value);
    public GeoPen get_InnerPen();
    public void set_InnerPen(GeoPen value);
    public GeoPen get_CenterPen();
    public void set_CenterPen(GeoPen value);
    public DrawingLevel get_OuterPenDrawingLevel();
    public void set_OuterPenDrawingLevel(DrawingLevel value);
    public DrawingLevel get_InnerPenDrawingLevel();
    public void set_InnerPenDrawingLevel(DrawingLevel value);
    public DrawingLevel get_CenterPenDrawingLevel();
    public void set_CenterPenDrawingLevel(DrawingLevel value);
    internal virtual bool oBU=();
    public PointStyle get_DirectionPointStyle();
    public void set_DirectionPointStyle(PointStyle value);
    public double get_DirectionPointInterval();
    public void set_DirectionPointInterval(double value);
    public double get_DirectionPointMinimumInterval();
    public void set_DirectionPointMinimumInterval(double value);
    public static LineStyle Parse(string styleJson);
    internal static LineStyle jxU=(JObject jObject);
    public static LineStyle CreateSimpleLineStyle(GeoColor centerlineColor, float centerlineWidth, bool roundCap);
    public static LineStyle CreateSimpleLineStyle(GeoColor centerlineColor, float centerlineWidth, LineDashStyle centerlineDashStyle, bool roundCap);
    public static LineStyle CreateSimpleLineStyle(GeoColor innerLineColor, float innerLineWidth, GeoColor outerLineColor, float outerLineWidth, bool roundCap);
    public static LineStyle CreateSimpleLineStyle(GeoColor innerLineColor, float innerLineWidth, LineDashStyle innerLineDashStyle, GeoColor outerLineColor, float outerLineWidth, LineDashStyle outerLineDashStyle, bool roundCap);
    public static LineStyle CreateSimpleLineStyle(GeoColor centerlineColor, float centerlineWidth, GeoColor innerLineColor, float innerLineWidth, GeoColor outerLineColor, float outerLineWidth, bool roundCap);
    public static LineStyle CreateSimpleLineStyle(GeoColor centerlineColor, float centerlineWidth, LineDashStyle centerlineDashStyle, GeoColor innerLineColor, float innerLineWidth, LineDashStyle innerLineDashStyle, GeoColor outerLineColor, float outerLineWidth, LineDashStyle outerLineDashStyle, bool roundCap);
    private static LineStyle GzE=(GeoColor innerPenColor, float innerPenWidth, GeoColor outerPenColor, float outerPenWidth, GeoColor centerPenColor, float centerPenWidth, Collection`1<float> dashPattern);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void HDE=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers, IEnumerable`1<Feature> featuresList);
    private void HTE=(Feature item, GeoCanvas canvas);
    private void HjE=(GeoCanvas canvas, LineShape lineShape, Feature item);
    protected virtual void OnDrawingDirectionPoint(DrawingDirectionPointEventArgs drawingDirectionPointEventArgs);
    private float HzE=(Vertex v1, Vertex v2);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    private static LineShape IDE=(RectangleShape rectangle);
    private static List`1<Feature> /zA=(RectangleShape currentExtent, IEnumerable`1<Feature> featureList);
    private static MultilineShape ITE=(LineShape line, RectangleShape rectangle);
    private static MultilineShape IjE=(MultilineShape multiline, RectangleShape rectangle);
    private static LineShape IzE=(Vertex startPoint, Vertex endPoint, RectangleShape rectangle);
    private static Vertex JDE=(Vertex startPoint, Vertex endPoint, RectangleShape rectangle);
    private static bool JTE=(double value, double start, double end);
    internal static GeoPen JjE=(String[] valueExpressions);
    private static PointStyle JzE=(String[] valueExpressions);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.LocationPoint : object {
    [CompilerGeneratedAttribute]
private double <PointX>k__BackingField;
    [CompilerGeneratedAttribute]
private double <PointY>k__BackingField;
    public double PointX { get; public set; }
    public double PointY { get; public set; }
    [CompilerGeneratedAttribute]
public double get_PointX();
    [CompilerGeneratedAttribute]
public void set_PointX(double value);
    [CompilerGeneratedAttribute]
public double get_PointY();
    [CompilerGeneratedAttribute]
public void set_PointY(double value);
}
public class ThinkGeo.Core.LogoAdornmentLayer : AdornmentLayer {
    [ObfuscationAttribute]
private GeoImage image;
    public GeoImage Image { get; public set; }
    public LogoAdornmentLayer(GeoImage image);
    public GeoImage get_Image();
    public void set_Image(GeoImage value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.MagneticDeclination : object {
    [ObfuscationAttribute]
private double magneticNorthInDegree;
    [ObfuscationAttribute]
private double gridNorthInDegree;
    [ObfuscationAttribute]
private string changedByYear;
    [ObfuscationAttribute]
private double centralMeridian;
    [ObfuscationAttribute]
private string zone;
    public double MagneticNorthInDegree { get; public set; }
    public double GridNorthInDegree { get; public set; }
    public string ChangedByYear { get; public set; }
    public double CentralMeridian { get; public set; }
    public string Zone { get; public set; }
    public MagneticDeclination(double magneticNorthInDegree, double gridNorthInDegree, string changedByYear, double centralMeridian, string zone);
    public double get_MagneticNorthInDegree();
    public void set_MagneticNorthInDegree(double value);
    public double get_GridNorthInDegree();
    public void set_GridNorthInDegree(double value);
    public string get_ChangedByYear();
    public void set_ChangedByYear(string value);
    public double get_CentralMeridian();
    public void set_CentralMeridian(double value);
    public string get_Zone();
    public void set_Zone(string value);
}
public class ThinkGeo.Core.MagneticDeclinationAdornmentLayer : AdornmentLayer {
    private static int 8SA=;
    private static int 8iA=;
    private static float 8yA=;
    private static double 9CA=;
    private static double 9SA=;
    private static double 9iA=;
    private static double 9yA=;
    [ObfuscationAttribute]
private TextStyle textStyle;
    [ObfuscationAttribute]
private LineStyle trueNorthLineStyle;
    [ObfuscationAttribute]
private LineStyle magneticNorthLineStyle;
    [ObfuscationAttribute]
private LineStyle gridNorthLineStyle;
    [ObfuscationAttribute]
private PointStyle trueNorthPointStyle;
    [ObfuscationAttribute]
private DistanceUnit elevationUnit;
    [ObfuscationAttribute]
private double elevation;
    [ObfuscationAttribute]
private DateTime sampleDateTime;
    [ObfuscationAttribute]
private string magneticFieldPathFilename;
    [ObfuscationAttribute]
private ProjectionConverter projectionToDecimalDegrees;
    [ObfuscationAttribute]
private PointShape canvasCenterPoint;
    [ObfuscationAttribute]
private int gridNorthTextLocationXoffset;
    [ObfuscationAttribute]
private int gridNorthDegreeLocationXoffset;
    [ObfuscationAttribute]
private int magneticNorthTextLocationYoffset;
    [ObfuscationAttribute]
private int gridNorthTextXOffsetInPixel;
    [ObfuscationAttribute]
private int degreeMinutesSecondsXOffsetInPixel;
    [ObfuscationAttribute]
private Stream magneticFieldFileStream;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Dh8=;
    public LineStyle GridNorthLineStyle { get; public set; }
    public LineStyle TrueNorthLineStyle { get; public set; }
    public LineStyle MagneticNorthLineStyle { get; public set; }
    public TextStyle TextStyle { get; public set; }
    public PointStyle TrueNorthPointStyle { get; public set; }
    public DistanceUnit ElevationUnit { get; public set; }
    public string MagneticFieldPathFilename { get; }
    public double Elevation { get; public set; }
    public DateTime SampleDateTime { get; public set; }
    public MagneticDeclinationAdornmentLayer(ScreenPointF startPoint);
    public MagneticDeclinationAdornmentLayer(AdornmentLocation adornmentLocation);
    public MagneticDeclinationAdornmentLayer(string magneticFieldPathFilename, AdornmentLocation adornmentLocation);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public LineStyle get_GridNorthLineStyle();
    public void set_GridNorthLineStyle(LineStyle value);
    public LineStyle get_TrueNorthLineStyle();
    public void set_TrueNorthLineStyle(LineStyle value);
    public LineStyle get_MagneticNorthLineStyle();
    public void set_MagneticNorthLineStyle(LineStyle value);
    public TextStyle get_TextStyle();
    public void set_TextStyle(TextStyle value);
    public PointStyle get_TrueNorthPointStyle();
    public void set_TrueNorthPointStyle(PointStyle value);
    public DistanceUnit get_ElevationUnit();
    public void set_ElevationUnit(DistanceUnit value);
    public string get_MagneticFieldPathFilename();
    public double get_Elevation();
    public void set_Elevation(double value);
    public DateTime get_SampleDateTime();
    public void set_SampleDateTime(DateTime value);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    public virtual ScreenPointF GetDrawingLocation(GeoCanvas canvas, float adornmentWidth, float adornmentHeight);
    public static MagneticDeclination GetMagneticDeclination(Feature pointFeature, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime);
    public static MagneticDeclination GetMagneticDeclination(Feature pointFeature, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, string magneticFieldPathFilename);
    public static MagneticDeclination GetMagneticDeclination(Feature pointFeature, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, Stream magneticFieldStream);
    public static MagneticDeclination GetMagneticDeclination(PointShape point, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime);
    public static MagneticDeclination GetMagneticDeclination(PointShape point, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, string magneticFieldPathFilename);
    public static MagneticDeclination GetMagneticDeclination(PointShape point, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, Stream magneticFieldStream);
    public static MagneticDeclination GetMagneticDeclination(double x, double y, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime);
    public static MagneticDeclination GetMagneticDeclination(double x, double y, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, string magneticFieldPathFilename);
    public static MagneticDeclination GetMagneticDeclination(double x, double y, double elevation, DistanceUnit elevationUnit, DateTime sampleDateTime, Stream magneticFieldStream);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void /CA=(ScreenPointF startPoint, double length, GeoCanvas canvas);
    private void /SA=(ScreenPointF gridNorthLineStartPoint, double length, double offsetInDegree, GeoCanvas canvas);
    private void /iA=(ScreenPointF magneticNorthLineStartPoint, double length, double offsetInDegree, GeoCanvas canvas);
    private static double /yA=(string zoneString, int zoneNum);
    private static string ACE=(PointShape centerPoint, Int32& zoneNum);
    private static double wyA=(PointShape centerPoint, double centralMeridian);
    private static int ASE=(object Test);
    private static int AiE=(double degree);
    private static double AyE=(double offTrueNorth);
    private static ScreenPointF BCE=(double lineGradient, double lineIntercept, double centerPointX, double centerPointY, double length, bool iswest);
    private static double BSE=(double degree);
}
public class ThinkGeo.Core.MagneticNorthLineStyle : LineStyle {
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static double BSE=(double degree);
    private static double AyE=(double offTrueNorth);
    private static ScreenPointF BCE=(double lineK, double lineB, double centerPointX, double centerPointY, double length, bool iswest);
}
public class ThinkGeo.Core.MapArguments : object {
    [ObfuscationAttribute]
private Collection`1<double> zoomLevelScales;
    [ObfuscationAttribute]
private Dictionary`2<string, object> customData;
    [CompilerGeneratedAttribute]
private GeographyUnit bB0=;
    [CompilerGeneratedAttribute]
private double bR0=;
    [CompilerGeneratedAttribute]
private double bh0=;
    [CompilerGeneratedAttribute]
private double bx0=;
    [CompilerGeneratedAttribute]
private double cB0=;
    [CompilerGeneratedAttribute]
private double cR0=;
    [CompilerGeneratedAttribute]
private ZoomLevelSet ch0=;
    [CompilerGeneratedAttribute]
private ScreenPointF cx0=;
    [CompilerGeneratedAttribute]
private PointShape dB0=;
    [CompilerGeneratedAttribute]
private double dR0=;
    [CompilerGeneratedAttribute]
private double dh0=;
    [CompilerGeneratedAttribute]
private double dx0=;
    [CompilerGeneratedAttribute]
private double eB0=;
    [CompilerGeneratedAttribute]
private RectangleShape eR0=;
    [CompilerGeneratedAttribute]
private PointShape eh0=;
    [CompilerGeneratedAttribute]
private RectangleShape ex0=;
    [CompilerGeneratedAttribute]
private float fB0=;
    [CompilerGeneratedAttribute]
private ZoomLevelSnappingMode fR0=;
    [CompilerGeneratedAttribute]
private bool fh0=;
    public GeographyUnit MapUnit { get; public set; }
    public double ScreenWidth { get; public set; }
    public double ScreenHeight { get; public set; }
    public double MapWidth { get; public set; }
    public double MapHeight { get; public set; }
    public double RotationAngle { get; public set; }
    public ZoomLevelSet ZoomLevelSet { get; public set; }
    public Dictionary`2<string, object> CustomData { get; }
    public ScreenPointF PivotScreenPoint { get; public set; }
    public PointShape PivotWorldPoint { get; public set; }
    public Collection`1<double> ZoomLevelScales { get; }
    public double CurrentResolution { get; public set; }
    public double CurrentScale { get; public set; }
    public double MaximumScale { get; public set; }
    public double MinimumScale { get; public set; }
    public RectangleShape CurrentExtent { get; public set; }
    public PointShape CenterPoint { get; public set; }
    public RectangleShape MaxExtent { get; public set; }
    public float ScaleFactor { get; public set; }
    public ZoomLevelSnappingMode ZoomLevelSnappingMode { get; public set; }
    public bool RotationEnabled { get; public set; }
    public MapArguments(RectangleShape currentExtent, GeographyUnit mapUnit, float screenWidth, float screenHeight);
    [CompilerGeneratedAttribute]
public GeographyUnit get_MapUnit();
    [CompilerGeneratedAttribute]
public void set_MapUnit(GeographyUnit value);
    [CompilerGeneratedAttribute]
public double get_ScreenWidth();
    [CompilerGeneratedAttribute]
public void set_ScreenWidth(double value);
    [CompilerGeneratedAttribute]
public double get_ScreenHeight();
    [CompilerGeneratedAttribute]
public void set_ScreenHeight(double value);
    [CompilerGeneratedAttribute]
public double get_MapWidth();
    [CompilerGeneratedAttribute]
public void set_MapWidth(double value);
    [CompilerGeneratedAttribute]
public double get_MapHeight();
    [CompilerGeneratedAttribute]
public void set_MapHeight(double value);
    [CompilerGeneratedAttribute]
public double get_RotationAngle();
    [CompilerGeneratedAttribute]
public void set_RotationAngle(double value);
    [CompilerGeneratedAttribute]
public ZoomLevelSet get_ZoomLevelSet();
    [CompilerGeneratedAttribute]
public void set_ZoomLevelSet(ZoomLevelSet value);
    public Dictionary`2<string, object> get_CustomData();
    [CompilerGeneratedAttribute]
public ScreenPointF get_PivotScreenPoint();
    [CompilerGeneratedAttribute]
public void set_PivotScreenPoint(ScreenPointF value);
    [CompilerGeneratedAttribute]
public PointShape get_PivotWorldPoint();
    [CompilerGeneratedAttribute]
public void set_PivotWorldPoint(PointShape value);
    public Collection`1<double> get_ZoomLevelScales();
    [CompilerGeneratedAttribute]
public double get_CurrentResolution();
    [CompilerGeneratedAttribute]
public void set_CurrentResolution(double value);
    [CompilerGeneratedAttribute]
public double get_CurrentScale();
    [CompilerGeneratedAttribute]
public void set_CurrentScale(double value);
    [CompilerGeneratedAttribute]
public double get_MaximumScale();
    [CompilerGeneratedAttribute]
public void set_MaximumScale(double value);
    [CompilerGeneratedAttribute]
public double get_MinimumScale();
    [CompilerGeneratedAttribute]
public void set_MinimumScale(double value);
    [CompilerGeneratedAttribute]
public RectangleShape get_CurrentExtent();
    [CompilerGeneratedAttribute]
public void set_CurrentExtent(RectangleShape value);
    [CompilerGeneratedAttribute]
public PointShape get_CenterPoint();
    [CompilerGeneratedAttribute]
public void set_CenterPoint(PointShape value);
    [CompilerGeneratedAttribute]
public RectangleShape get_MaxExtent();
    [CompilerGeneratedAttribute]
public void set_MaxExtent(RectangleShape value);
    [CompilerGeneratedAttribute]
public float get_ScaleFactor();
    [CompilerGeneratedAttribute]
public void set_ScaleFactor(float value);
    [CompilerGeneratedAttribute]
public ZoomLevelSnappingMode get_ZoomLevelSnappingMode();
    [CompilerGeneratedAttribute]
public void set_ZoomLevelSnappingMode(ZoomLevelSnappingMode value);
    [CompilerGeneratedAttribute]
public bool get_RotationEnabled();
    [CompilerGeneratedAttribute]
public void set_RotationEnabled(bool value);
    public PointShape ToWorldCoordinate(ScreenPointF screenCoordinate);
    public int GetSnappedZoomLevelIndex(RectangleShape extent);
    public int GetSnappedZoomLevelIndex(double scale);
    public RectangleShape GetSnappedExtent(RectangleShape extent, ZoomSnapDirection zoomSnapDirection);
}
public class ThinkGeo.Core.MapBoxStaticTilesAsyncLayer : XyzTileAsyncLayer {
    private static int 9B0=;
    [ObfuscationAttribute]
private MapBoxStyleId styleId;
    [ObfuscationAttribute]
private string baseUrl;
    [ObfuscationAttribute]
private string apiVersion;
    [CompilerGeneratedAttribute]
private string NR4=;
    public string AccessToken { get; public set; }
    public MapBoxStyleId StyleId { get; public set; }
    public MapBoxStaticTilesAsyncLayer(string accessToken);
    public MapBoxStaticTilesAsyncLayer(string accessToken, MapBoxStyleId styleId);
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public void set_AccessToken(string value);
    public MapBoxStyleId get_StyleId();
    public void set_StyleId(MapBoxStyleId value);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    private string Nh4=();
    private void Nx4=(MapBoxStyleId id);
    private bool OB4=(string cacheId);
    private string OR4=(MapBoxStyleId id);
}
public enum ThinkGeo.Core.MapBoxStyleId : Enum {
    public int value__;
    public static MapBoxStyleId Streets;
    public static MapBoxStyleId Outdoors;
    public static MapBoxStyleId Light;
    public static MapBoxStyleId Dark;
    public static MapBoxStyleId Satellite;
    public static MapBoxStyleId SatelliteStreets;
}
public class ThinkGeo.Core.MapBoxZoomLevelSet : ZoomLevelSet {
    public MapBoxZoomLevelSet(int tileSize);
    public MapBoxZoomLevelSet(int tileSize, RectangleShape maxExtent);
}
public enum ThinkGeo.Core.MapDoubleTapMode : Enum {
    public int value__;
    public static MapDoubleTapMode Default;
    public static MapDoubleTapMode ZoomIn;
    public static MapDoubleTapMode Disabled;
}
public class ThinkGeo.Core.MapEngine : object {
    [ObfuscationAttribute]
private bool showLogo;
    [ObfuscationAttribute]
private RectangleShape currentExtent;
    [ObfuscationAttribute]
private GeoBrush backgroundFillBrush;
    [ObfuscationAttribute]
private GeoCanvas canvas;
    [ObfuscationAttribute]
private Collection`1<SimpleCandidate> labeledFeaturesInLayers;
    [ObfuscationAttribute]
private GeoCollection`1<Layer> staticLayers;
    [ObfuscationAttribute]
private GeoCollection`1<Layer> dynamicLayers;
    [ObfuscationAttribute]
private GeoCollection`1<AdornmentLayer> adornmentLayers;
    [CompilerGeneratedAttribute]
private EventHandler`1<LayersDrawingEventArgs> vhU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<LayersDrawnEventArgs> vxU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<LayerDrawingEventArgs> wBU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<LayerDrawnEventArgs> wRU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingAdornmentLayersEventArgs> whU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawnAdornmentLayersEventArgs> wxU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawingAdornmentLayerEventArgs> xBU=;
    [CompilerGeneratedAttribute]
private EventHandler`1<DrawnAdornmentLayerEventArgs> xRU=;
    public GeoCanvas Canvas { get; public set; }
    public bool ShowLogo { get; public set; }
    public GeoCollection`1<AdornmentLayer> AdornmentLayers { get; }
    public RectangleShape CurrentExtent { get; public set; }
    public GeoCollection`1<Layer> StaticLayers { get; }
    public GeoCollection`1<Layer> DynamicLayers { get; }
    public GeoBrush BackgroundFillBrush { get; public set; }
    [CompilerGeneratedAttribute]
public void add_LayersDrawing(EventHandler`1<LayersDrawingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LayersDrawing(EventHandler`1<LayersDrawingEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_LayersDrawn(EventHandler`1<LayersDrawnEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LayersDrawn(EventHandler`1<LayersDrawnEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_LayerDrawing(EventHandler`1<LayerDrawingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LayerDrawing(EventHandler`1<LayerDrawingEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_LayerDrawn(EventHandler`1<LayerDrawnEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_LayerDrawn(EventHandler`1<LayerDrawnEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AdornmentLayersDrawing(EventHandler`1<DrawingAdornmentLayersEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AdornmentLayersDrawing(EventHandler`1<DrawingAdornmentLayersEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AdornmentLayersDrawn(EventHandler`1<DrawnAdornmentLayersEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AdornmentLayersDrawn(EventHandler`1<DrawnAdornmentLayersEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AdornmentLayerDrawing(EventHandler`1<DrawingAdornmentLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AdornmentLayerDrawing(EventHandler`1<DrawingAdornmentLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AdornmentLayerDrawn(EventHandler`1<DrawnAdornmentLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AdornmentLayerDrawn(EventHandler`1<DrawnAdornmentLayerEventArgs> value);
    protected virtual void OnAdornmentLayersDrawing(DrawingAdornmentLayersEventArgs e);
    protected virtual void OnAdornmentLayersDrawn(DrawnAdornmentLayersEventArgs e);
    protected virtual void OnAdornmentLayerDrawing(DrawingAdornmentLayerEventArgs e);
    protected virtual void OnAdornmentLayerDrawn(DrawnAdornmentLayerEventArgs e);
    protected virtual void OnLayersDrawing(LayersDrawingEventArgs e);
    protected virtual void OnLayersDrawn(LayersDrawnEventArgs e);
    protected virtual void OnLayerDrawing(LayerDrawingEventArgs e);
    protected virtual void OnLayerDrawn(LayerDrawnEventArgs e);
    public GeoCanvas get_Canvas();
    public void set_Canvas(GeoCanvas value);
    public bool get_ShowLogo();
    public void set_ShowLogo(bool value);
    public GeoCollection`1<AdornmentLayer> get_AdornmentLayers();
    public RectangleShape get_CurrentExtent();
    public void set_CurrentExtent(RectangleShape value);
    public GeoCollection`1<Layer> get_StaticLayers();
    public GeoCollection`1<Layer> get_DynamicLayers();
    public GeoBrush get_BackgroundFillBrush();
    public void set_BackgroundFillBrush(GeoBrush value);
    public FeatureLayer FindStaticFeatureLayer(string name);
    public RasterLayer FindStaticRasterLayer(string name);
    public FeatureLayer FindDynamicFeatureLayer(string name);
    public RasterLayer FindDynamicRasterLayer(string name);
    public RectangleShape GetDrawingExtent(float screenWidth, float screenHeight);
    public static RectangleShape GetDrawingExtent(RectangleShape worldExtent, float screenWidth, float screenHeight);
    public void OpenAllLayers();
    public void CloseAllLayers();
    public static RectangleShape CenterAt(RectangleShape worldExtent, PointShape worldPoint, float screenWidth, float screenHeight);
    public void CenterAt(PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape CenterAt(RectangleShape worldExtent, Feature centerFeature, float screenWidth, float screenHeight);
    public void CenterAt(Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape CenterAt(RectangleShape worldExtent, float screenX, float screenY, float screenWidth, float screenHeight);
    public void CenterAt(float screenX, float screenY, float screenWidth, float screenHeight);
    public static float GetScreenDistanceBetweenTwoWorldPoints(RectangleShape worldExtent, PointShape worldPoint1, PointShape worldPoint2, float screenWidth, float screenHeight);
    public float GetScreenDistanceBetweenTwoWorldPoints(PointShape worldPoint1, PointShape worldPoint2, float screenWidth, float screenHeight);
    public float GetScreenDistanceBetweenTwoWorldPoints(Feature worldPointFeature1, Feature worldPointFeature2, float screenWidth, float screenHeight);
    public static float GetScreenDistanceBetweenTwoWorldPoints(RectangleShape worldExtent, Feature worldPointFeature1, Feature worldPointFeature2, float screenWidth, float screenHeight);
    public static double GetWorldDistanceBetweenTwoScreenPoints(RectangleShape worldExtent, ScreenPointF screenPoint1, ScreenPointF screenPoint2, float screenWidth, float screenHeight, GeographyUnit worldExtentUnit, DistanceUnit distanceUnit);
    public double GetWorldDistanceBetweenTwoScreenPoints(ScreenPointF screenPoint1, ScreenPointF screenPoint2, float screenWidth, float screenHeight, GeographyUnit mapUnit, DistanceUnit distanceUnit);
    public static double GetWorldDistanceBetweenTwoScreenPoints(RectangleShape worldExtent, float screenPoint1X, float screenPoint1Y, float screenPoint2X, float screenPoint2Y, float screenWidth, float screenHeight, GeographyUnit worldExtentUnit, DistanceUnit distanceUnit);
    public double GetCurrentScale(float screenWidth, float screenHeight, GeographyUnit mapUnit);
    public static double GetCurrentScale(RectangleShape worldExtent, float screenWidth, float screenHeight, GeographyUnit mapUnit);
    public static RectangleShape GetBoundingBoxOfItems(IEnumerable`1<BaseShape> shapes);
    public static RectangleShape GetBoundingBoxOfItems(IEnumerable`1<Feature> features);
    public GeoImage Draw(IEnumerable`1<Layer> layers, GeoImage image, GeographyUnit mapUnit);
    public GeoImage Draw(IEnumerable`1<Layer> layers, int width, int height, GeographyUnit mapUnit);
    public GeoImage DrawStaticLayers(GeoImage image, GeographyUnit mapUnit);
    public GeoImage DrawDynamicLayers(GeoImage image, GeographyUnit mapUnit);
    public GeoImage DrawAdornmentLayers(GeoImage image, GeographyUnit mapUnit);
    public GeoImage DrawStaticLayers(int width, int height, GeographyUnit mapUnit);
    public GeoImage DrawDynamicLayers(int width, int height, GeographyUnit mapUnit);
    public GeoImage DrawAdornmentLayers(int width, int height, GeographyUnit mapUnit);
    private GeoImage xhU=(IEnumerable`1<AdornmentLayer> adornmentLayers, int width, int height, GeographyUnit mapUnit);
    private GeoImage xhU=(IEnumerable`1<Layer> layers, int width, int height, GeographyUnit mapUnit, bool isToDrawBackground);
    private object xhU=(IEnumerable`1<Layer> layers, GeoImage image, GeographyUnit mapUnit, bool isToDrawBackground);
    private void xxU=();
    public void ZoomIn(int percentage);
    public static RectangleShape ZoomIn(RectangleShape worldExtent, int percentage);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public void ZoomIntoCenter(int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public void ZoomIntoCenter(int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public void ZoomIntoCenter(int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOut(RectangleShape worldExtent, int percentage);
    public void ZoomOut(int percentage);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public void ZoomOutToCenter(int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public void ZoomOutToCenter(int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public void ZoomOutToCenter(int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public static RectangleShape Pan(RectangleShape worldExtent, PanDirection direction, int percentage);
    public void Pan(PanDirection panDirection, int percentage);
    public static RectangleShape Pan(RectangleShape worldExtent, float degree, int percentage);
    public void Pan(float degree, int percentage);
    public ScreenPointF ToScreenCoordinate(double worldX, double worldY, float screenWidth, float screenHeight);
    public ScreenPointF ToScreenCoordinate(PointShape worldPoint, float screenWidth, float screenHeight);
    public ScreenPointF ToScreenCoordinate(Feature worldPointFeature, float screenWidth, float screenHeight);
    public PointShape ToWorldCoordinate(float screenX, float screenY, float screenWidth, float screenHeight);
    public PointShape ToWorldCoordinate(ScreenPointF screenPoint, float screenWidth, float screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, double worldX, double worldY, float screenWidth, float screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, PointShape worldPoint, float screenWidth, float screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, Feature worldPointFeature, float screenWidth, float screenHeight);
    public static PointShape ToWorldCoordinate(RectangleShape worldExtent, float screenX, float screenY, float screenWidth, float screenHeight);
    public static PointShape ToWorldCoordinate(RectangleShape worldExtent, ScreenPointF screenPoint, float screenWidth, float screenHeight);
    public static RectangleShape SnapToZoomLevel(RectangleShape worldExtent, GeographyUnit worldExtentUnit, float screenWidth, float screenHeight, ZoomLevelSet zoomLevelSet);
    public void SnapToZoomLevel(GeographyUnit worldExtentUnit, float screenWidth, float screenHeight, ZoomLevelSet zoomLevelSet);
    public static RectangleShape ZoomToScale(double targetScale, RectangleShape worldExtent, GeographyUnit worldExtentUnit, float screenWidth, float screenHeight);
    public void ZoomToScale(double targetScale, GeographyUnit worldExtentUnit, float screenWidth, float screenHeight);
    public static string GetVersion();
    private void yBU=(Layer layer, object nativeImage);
    private void yRU=(AdornmentLayer adornmentLayer);
    public static DataTable LoadDataTable(Collection`1<Feature> features, IEnumerable`1<string> returningColumnNames);
}
public class ThinkGeo.Core.MapsCloudClient : CloudClient {
    public MapsCloudClient(string clientId, string clientSecret);
    public Stream GetRasterTile(long z, long x, long y, CloudMapProjection projection, CloudRasterMapType mapType, CloudTileSize tileSize, TileResolution tileResolution);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsCloudClient/Wz4=")]
public Task`1<Stream> GetRasterTileAsync(long z, long x, long y, CloudMapProjection projection, CloudRasterMapType mapType, CloudTileSize tileSize, TileResolution tileResolution);
    public Stream GetVectorTile(long z, long x, long y, CloudMapProjection projection);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsCloudClient/Xz4=")]
public Task`1<Stream> GetVectorTileAsync(long z, long x, long y, CloudMapProjection projection);
    private static string 7xQ=(CloudRasterMapType mapType);
    private static string 8BQ=(CloudRasterMapType mapType);
    private static string 8RQ=(CloudMapProjection projection);
    private static int 8hQ=(CloudTileSize tileSize);
    private static int 8hQ=(TileResolution tileResolution);
}
public class ThinkGeo.Core.MapShape : object {
    [ObfuscationAttribute]
private Feature feature;
    [ObfuscationAttribute]
private ZoomLevelSet zoomLevels;
    public Feature Feature { get; public set; }
    public ZoomLevelSet ZoomLevels { get; public set; }
    public MapShape(Feature feature);
    public Feature get_Feature();
    public void set_Feature(Feature value);
    public ZoomLevelSet get_ZoomLevels();
    public void set_ZoomLevels(ZoomLevelSet value);
}
public class ThinkGeo.Core.MapShapeLayer : Layer {
    [ObfuscationAttribute]
private Dictionary`2<string, MapShape> mapShapes;
    public Dictionary`2<string, MapShape> MapShapes { get; }
    public Dictionary`2<string, MapShape> get_MapShapes();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.MapsQueryCloudClient : CloudClient {
    public MapsQueryCloudClient(string clientId, string clientSecret);
    public CloudMapsQueryResult GetFeaturesWithin(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesWithin(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesWithin(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesContaining(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesContaining(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesContaining(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesIntersecting(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesIntersecting(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesIntersecting(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesOverlapping(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesOverlapping(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesOverlapping(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesTouching(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesTouching(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesTouching(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, int srid, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, string proj4String, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, int srid, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesNearest(string queryLayer, BaseShape shape, string proj4String, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public CloudMapsQueryResult GetFeaturesWithinDistance(string queryLayer, BaseShape shape, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesWithinDistance(string queryLayer, BaseShape shape, int srid, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesWithinDistance(string queryLayer, BaseShape shape, string proj4String, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public CloudMapsQueryResult GetFeaturesCustom(CloudMapsQueryCustomQueryOptions options);
    public CloudMapsQueryGetLayersResult GetLayers();
    public CloudMapsQueryGetAttributesOfLayerResult GetAttributesOfLayer(string queryLayer);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinAsync(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinAsync(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinAsync(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesContainingAsync(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesContainingAsync(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesContainingAsync(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesIntersectingAsync(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesIntersectingAsync(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesIntersectingAsync(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesOverlappingAsync(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesOverlappingAsync(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesOverlappingAsync(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesTouchingAsync(string queryLayer, BaseShape shape, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesTouchingAsync(string queryLayer, BaseShape shape, int srid, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesTouchingAsync(string queryLayer, BaseShape shape, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, int srid, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, string proj4String, int maxResults, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, int srid, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesNearestAsync(string queryLayer, BaseShape shape, string proj4String, int maxResults, double searchRadius, DistanceUnit searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinDistanceAsync(string queryLayer, BaseShape shape, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinDistanceAsync(string queryLayer, BaseShape shape, int srid, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesWithinDistanceAsync(string queryLayer, BaseShape shape, string proj4String, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    public Task`1<CloudMapsQueryResult> GetFeaturesCustomAsync(CloudMapsQueryCustomQueryOptions options);
    public Task`1<CloudMapsQueryGetLayersResult> GetLayersAsync();
    public Task`1<CloudMapsQueryGetAttributesOfLayerResult> GetAttributesOfLayerAsync(string queryLayer);
    private CloudMapsQueryResult 3xQ=(QueryType queryType, string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/WT4=")]
private Task`1<CloudMapsQueryResult> 4BQ=(QueryType queryType, string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    private CloudMapsQueryResult 4RQ=(string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, int maxResults, Nullable`1<double> searchRadius, Nullable`1<DistanceUnit> searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/Tj4=")]
private Task`1<CloudMapsQueryResult> 4hQ=(string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, int maxResults, Nullable`1<double> searchRadius, Nullable`1<DistanceUnit> searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    private CloudMapsQueryResult 4xQ=(string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/VT4=")]
private Task`1<CloudMapsQueryResult> 5BQ=(string queryLayer, BaseShape shape, Nullable`1<int> srid, string proj4String, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    private CloudMapsQueryResult 5RQ=(CloudMapsQueryCustomQueryOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/TT4=")]
private Task`1<CloudMapsQueryResult> 5hQ=(CloudMapsQueryCustomQueryOptions options);
    private CloudMapsQueryGetLayersResult 5xQ=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/WD4=")]
private Task`1<CloudMapsQueryGetLayersResult> 6BQ=();
    private CloudMapsQueryGetAttributesOfLayerResult 6RQ=(string queryLayer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MapsQueryCloudClient/Sz4=")]
private Task`1<CloudMapsQueryGetAttributesOfLayerResult> 6hQ=(string queryLayer);
    private CloudMapsQueryResult 6xQ=(WebResponse response);
    private CloudMapsQueryGetLayersResult 7BQ=(WebResponse response);
    private CloudMapsQueryGetAttributesOfLayerResult 7RQ=(WebResponse response);
    private string 2xQ=(BaseShape shape, Nullable`1<int> srid, string proj4String, CloudMapsQuerySpatialQueryOptions options);
    private string 2xQ=(BaseShape shape, Nullable`1<int> srid, string proj4String, int maxResults, Nullable`1<double> searchRadius, Nullable`1<DistanceUnit> searchRadiusUnit, CloudMapsQueryNearestQueryOptions options);
    private string 2xQ=(BaseShape shape, Nullable`1<int> srid, string proj4String, double distance, DistanceUnit distanceUnit, CloudMapsQuerySpatialQueryOptions options);
    private string 7hQ=(QueryType queryType);
}
public static class ThinkGeo.Core.MapUtil : object {
    public static float StandardDpi;
    public static double InchesPerFeet;
    public static double InchesPerMeter;
    public static double InchesPerMile;
    public static double InchesPerYard;
    public static double InchesPerNauticalMile;
    public static double InchesPerDecimalDegree;
    public static float PointsPerInch;
    private static Dictionary`2<string, string> fx0=;
    private static MapUtil();
    public static double GetResolutionFromScale(double scale, GeographyUnit unit, float dpi);
    public static double GetResolution(RectangleShape boundingBox, double widthInPixel, double heightInPixel);
    public static double GetScale(RectangleShape worldExtent, double screenWidth, GeographyUnit worldExtentUnit, float dpi);
    public static double GetScale(GeographyUnit mapUnit, RectangleShape boundingBox, double widthInPixel, double heightInPixel, float dpi);
    public static double GetSnappedScale(RectangleShape worldExtent, float screenWidth, GeographyUnit worldExtentUnit, ZoomLevelSet zoomLevelSet);
    public static double GetSnappedScale(double scale, ZoomLevelSet zoomLevelSet);
    public static RectangleShape CalculateExtent(PointShape worldCenter, double scale, GeographyUnit mapUnit, double mapWidth, double mapHeight);
    public static RectangleShape AdjustExtentByRestrictions(RectangleShape targetExtent, double width, double height, RectangleShape restrictExtent, double maximumScale, double minimumScale, GeographyUnit mapUnit);
    public static PointShape ToWorldCoordinate(RectangleShape currentExtent, double screenX, double screenY, double screenWidth, double screenHeight);
    public static double GetDistance(PointShape fromPoint, PointShape toPoint);
    public static int GetFloorZoomLevelIndex(double scale, ZoomLevelSet zoomLevelSet);
    public static ValueTuple`2<int, int> GetFloorCeilingZoomLevelIndex(double scale, ZoomLevelSet zoomLevelSet);
    public static int GetClosestZoomLevelIndex(double scale, ZoomLevelSet zoomLevelSet);
    public static int GetFloorZoomLevelIndex(double scale, Collection`1<double> zoomLevelScales);
    public static ValueTuple`2<int, int> GetFloorCeilingZoomLevelIndex(double scale, Collection`1<double> zoomLevelScales);
    public static int GetClosestZoomLevelIndex(double scale, Collection`1<double> zoomLevelScales);
    public static int GetSnappedZoomLevelIndex(RectangleShape extent, GeographyUnit mapUnit, Collection`1<double> zoomLevelScales, double actualWidth, double actualHeight);
    public static int GetSnappedZoomLevelIndex(double scale, ZoomLevelSet zoomLevelSet);
    public static int GetSnappedZoomLevelIndex(double scale, IEnumerable`1<double> zoomLevelScales, double minimumScale, double maximumScale);
    public static ScreenPointF GetRotatedScreenPoint(double x, double y, double rotatedAngle, ScreenPointF pivotPoint);
    public static ScreenPointF GetRotatedScreenPoint(double x, double y, double rotatedAngle, ScreenPointD pivotPoint);
    public static PointShape GetRotatedPoint(double x, double y, double rotatedAngle, PointShape pivotPoint);
    public static RectangleShape GetRotatedExtent(RectangleShape extent, double rotatedAngle, PointShape pivotPoint);
    public static AreaBaseShape GetRotatedPolygon(RectangleShape extent, double rotatedAngle, PointShape pivotPoint);
    public static RectangleShape ApplyDrawingMarginToExtent(RectangleShape worldExtent, float marginInPixel, float screenWidth, float screenHeight);
    public static RectangleShape CenterAt(RectangleShape worldExtent, PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape CenterAt(RectangleShape worldExtent, Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape CenterAt(RectangleShape worldExtent, float screenX, float screenY, float screenWidth, float screenHeight);
    public static RectangleShape GetBoundingBoxOfItems(IEnumerable`1<BaseShape> shapes);
    public static RectangleShape GetBoundingBoxOfItems(IEnumerable`1<Feature> features);
    public static RectangleShape GetDrawingExtent(RectangleShape worldExtent, double screenWidth, double screenHeight);
    public static float GetScreenDistanceBetweenTwoWorldPoints(RectangleShape worldExtent, PointShape worldPoint1, PointShape worldPoint2, float screenWidth, float screenHeight);
    public static float GetScreenDistanceBetweenTwoWorldPoints(RectangleShape worldExtent, Feature worldPointFeature1, Feature worldPointFeature2, float screenWidth, float screenHeight);
    public static RectangleShape GetSnappedExtent(RectangleShape worldExtent, GeographyUnit worldExtentUnit, float screenWidth, float screenHeight, ZoomLevelSet zoomLevelSet);
    public static double GetWorldDistanceBetweenTwoScreenPoints(RectangleShape worldExtent, ScreenPointF screenPoint1, ScreenPointF screenPoint2, float screenWidth, float screenHeight, GeographyUnit worldExtentUnit, DistanceUnit distanceUnit);
    public static double GetWorldDistanceBetweenTwoScreenPoints(RectangleShape worldExtent, float screenPoint1X, float screenPoint1Y, float screenPoint2X, float screenPoint2Y, float screenWidth, float screenHeight, GeographyUnit worldExtentUnit, DistanceUnit distanceUnit);
    public static RectangleShape Pan(RectangleShape worldExtent, PanDirection direction, int percentage);
    public static RectangleShape Pan(RectangleShape worldExtent, float degree, int percentage);
    public static BaseShape ToScreenCoordinate(BaseShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    public static DrawingRectangle ToScreenCoordinate(RectangleShape worldExtent, RectangleShape targetWorldExtent, float screenWidth, float screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, double worldX, double worldY, double screenWidth, double screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, PointShape worldPoint, float screenWidth, float screenHeight);
    public static ScreenPointF ToScreenCoordinate(RectangleShape worldExtent, Feature worldPointFeature, float screenWidth, float screenHeight);
    public static PointShape ToWorldCoordinate(RectangleShape worldExtent, float screenX, float screenY, float screenWidth, float screenHeight);
    public static PointShape ToWorldCoordinate(RectangleShape worldExtent, ScreenPointF screenPoint, float screenWidth, float screenHeight);
    public static RectangleShape ZoomIn(RectangleShape worldExtent, int percentage);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape ZoomIntoCenter(RectangleShape worldExtent, int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOut(RectangleShape worldExtent, int percentage);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, PointShape worldPoint, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, Feature centerFeature, float screenWidth, float screenHeight);
    public static RectangleShape ZoomOutToCenter(RectangleShape worldExtent, int percentage, float screenX, float screenY, float screenWidth, float screenHeight);
    public static RectangleShape ZoomToScale(double targetScale, RectangleShape worldExtent, GeographyUnit worldExtentUnit, double screenWidth, double screenHeight);
    public static RectangleShape ZoomToScale(double targetScale, RectangleShape worldExtent, GeographyUnit worldExtentUnit, float screenWidth, float screenHeight, ScreenPointF offsetScreenPoint);
    public static Feature ToWorldCoordinate(PolygonShape simplyPolygon, RectangleShape currentWorldExtent, float canvasWidth, float canvasHeight);
    private static void gB0=(Byte[] sourceArray, Byte[] targetArray, long targetIndex);
    private static BaseShape gR0=(PointShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape gh0=(LineShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape gx0=(PolygonShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape hB0=(MultipointShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape hR0=(MultilineShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape hh0=(MultipolygonShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static BaseShape hx0=(GeometryCollectionShape shape, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static PointShape iB0=(Byte[] wellKnownBinary, Int32& startIndex, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static PolygonShape iR0=(Byte[] wellKnownBinary, Int32& startIndex, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static LineShape ih0=(Byte[] wellKnownBinary, Int32& startIndex, RectangleShape worldExtent, float screenWidth, float screenHeight);
    private static double ix0=(Byte[] bytes, int startIndex, byte byteOrder);
    private static int jB0=(Byte[] bytes, int startIndex, byte byteOrder);
    public static string GetVersion();
    public static Collection`1<Feature> BuildFourColorColumn(string columnName, Collection`1<Feature> features);
    public static bool isSameScale(double scale1, double scale2, double epsilon);
    public static bool IsSameDouble(double double1, double double2, double epsilon);
    public static bool IsSameExtent(RectangleShape extent1, RectangleShape extent2, double epsilon);
    public static bool IsSamePoint(Vertex a, Vertex b, double epsilon);
    public static bool IsSamePoint(PointShape a, PointShape b, double epsilon);
    public static bool IsSamePoint(Vertex a, PointShape b, double epsilon);
    private static Collection`1<Collection`1<Feature>> jR0=(Collection`1<Feature> features);
    private static Int32[] jh0=(Collection`1<Feature> features);
    public static double GetInchesPerDistanceUnit(DistanceUnit targetUnit);
    public static double GetInchesPerGeographyUnit(GeographyUnit targetUnit);
    private static double jx0=(GeographyUnit unit);
    public static AreaUnit GetAreaUnitFromDistanceUnit(DistanceUnit distanceUnit);
    public static string GetShortUnitString(DistanceUnit targetUnit, Dictionary`2<string, string> preferredDisplayUnitString);
    private static RectangleShape kB0=(RectangleShape targetExtent, RectangleShape restrictExtent, double actualWidth, double actualHeight, double maximumScale, double minimumScale, GeographyUnit mapUnit);
    private static RectangleShape kR0=(RectangleShape targetExtent, double actualWidth, double actualHeight, double maximumScale, double minimumScale, GeographyUnit mapUnit);
    public static double GetScaleFromResolution(double resolution, GeographyUnit unit, float dpi);
    internal static float kh0=(float point);
    public static ValueTuple`2<double, double> Rotate(double sourceX, double sourceY, double destinationX, double destinationY, double rotationAngle);
    public static ValueTuple`2<double, double> RotatePoint(double x, double y, double rotationAngle, double pivotX, double pivotY);
    public static RingShape RotateRingShape(RingShape ringShape, double rotationAngle, double pivotX, double pivotY);
    public static PolygonShape RotatePolygonShape(PolygonShape polygonShape, double rotationAngle, double pivotX, double pivotY);
    public static RectangleShape ScaleExtent(double mapWidth, double mapHeight, double resolution, double centerScreenX, double centerScreenY, double centerWorldX, double centerWorldY);
    public static double GetRotatedCanvasRadius(double pivotX, double pivotY, double canvasWidth, double canvasHeight);
    public static PointShape OffsetPointWithScreenOffset(PointShape pointShape, double xScreenOffset, double yScreenOffset, double mapRotation, double mapScale, GeographyUnit mapUnit);
    private static double kx0=(double x1, double y1, double x2, double y2);
    public static RectangleShape GetWorldExtent(GeographyUnit unit);
    public static PointShape ToWorldCoordinate(double screenX, double screenY, PointShape centerPoint, double centerScreenX, double centerScreenY, double scale, GeographyUnit mapUnit, double mapRotation);
    public static RectangleShape GetExtentFromCenterPoint(PointShape centerPoint, double canvasWidth, double canvasHeight, double scale, GeographyUnit mapUnit);
    public static ValueTuple`2<double, double> GetFloorCeilingScales(double scale, ZoomLevelSet zoomLevelSet);
    public static double GetDegreeFromPanDirection(PanDirection panDirection);
    public static double GetResolutionOfRotatedExtent(RectangleShape extent, double rotationAngle, double canvasWidth, double canvasHeight);
}
public enum ThinkGeo.Core.MaskType : Enum {
    public int value__;
    public static MaskType Default;
    public static MaskType Rectangle;
    public static MaskType RoundedCorners;
    public static MaskType RoundedEnds;
    public static MaskType Circle;
}
public abstract class ThinkGeo.Core.Matrix : object {
    [ObfuscationAttribute]
private static int MAXIMUM_CELL_COUNT;
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private double cellWidth;
    [ObfuscationAttribute]
private double cellHeight;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [CompilerGeneratedAttribute]
private double ux0=;
    public double CellWidth { get; public set; }
    public double CellHeight { get; public set; }
    public RectangleShape BoundingBox { get; public set; }
    public string Id { get; public set; }
    internal double vh0= { get; internal set; }
    protected Matrix(string id, double cellWidth, double cellHeight, RectangleShape boundingBox);
    public double get_CellWidth();
    public void set_CellWidth(double value);
    public double get_CellHeight();
    public void set_CellHeight(double value);
    public RectangleShape get_BoundingBox();
    public void set_BoundingBox(RectangleShape value);
    public string get_Id();
    public void set_Id(string value);
    [CompilerGeneratedAttribute]
internal double vB0=();
    [CompilerGeneratedAttribute]
internal void vR0=(double value);
    public Collection`1<MatrixCell> GetAllCells();
    public MatrixCell GetCell(long row, long column);
    public MatrixCell GetCell(PointShape intersectingPoint);
    public long GetRowIndex(PointShape intersectingPoint);
    public long GetColumnIndex(PointShape intersectingPoint);
    public Collection`1<MatrixCell> GetIntersectingCells(RectangleShape worldExtent);
    public Collection`1<MatrixCell> GetContainedCells(RectangleShape worldExtent);
    public RowColumnRange GetIntersectingRowColumnRange(RectangleShape worldExtent);
    public RowColumnRange GetContainedRowColumnRange(RectangleShape worldExtent);
    public long GetRowCount();
    public long GetColumnCount();
    private RowColumnRange vx0=(RectangleShape worldExtent, bool isContains);
    protected virtual RowColumnRange GetRowColumnRangeCore(RectangleShape worldExtent, bool isContains);
    internal RowColumnRange vx0=(RectangleShape worldExtent, bool isContains, double epsilon, bool wrapWorldExtent);
}
public class ThinkGeo.Core.MatrixCell : ValueType {
    [ObfuscationAttribute]
private long row;
    [ObfuscationAttribute]
private long column;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    public long Row { get; public set; }
    public long Column { get; public set; }
    public RectangleShape BoundingBox { get; public set; }
    public MatrixCell(long row, long column, RectangleShape boundingBox);
    public long get_Row();
    public void set_Row(long value);
    public long get_Column();
    public void set_Column(long value);
    public RectangleShape get_BoundingBox();
    public void set_BoundingBox(RectangleShape value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual int CompareTo(MatrixCell other);
    public static bool op_Equality(MatrixCell cell1, MatrixCell cell2);
    public static bool op_Inequality(MatrixCell cell1, MatrixCell cell2);
}
public enum ThinkGeo.Core.MatrixReferenceCorner : Enum {
    public int value__;
    public static MatrixReferenceCorner UpperLeft;
    public static MatrixReferenceCorner UpperRight;
    public static MatrixReferenceCorner LowerLeft;
    public static MatrixReferenceCorner LowerRight;
}
public static class ThinkGeo.Core.MaxExtents : object {
    public static RectangleShape SphericalMercator;
    public static RectangleShape ThinkGeoMaps;
    public static RectangleShape MapBoxMaps;
    public static RectangleShape BingMaps;
    public static RectangleShape HereMaps;
    public static RectangleShape GoogleMaps;
    public static RectangleShape OsmMaps;
    public static RectangleShape Feet;
    public static RectangleShape DecimalDegree;
    private static MaxExtents();
    public static RectangleShape GetDefaultMaxExtent(GeographyUnit unit);
}
public static class ThinkGeo.Core.MbStyleFilter : object {
    internal static List`1<FilterCondition> jxU=(JsonElement filterElement);
    private static List`1<FilterCondition> SiM=(JsonElement filterElement);
    private static List`1<FilterCondition> SyM=(JsonElement filterElement);
    private static IEnumerable`1<FilterCondition> TCM=(JsonElement filterElement);
    private static IEnumerable`1<FilterCondition> TSM=(JsonElement inElement);
    private static IEnumerable`1<FilterCondition> TiM=(JsonElement filterElement);
}
public class ThinkGeo.Core.MBTilesGenerationLayerSetting : object {
    [ObfuscationAttribute]
private FeatureLayer featureLayer;
    [ObfuscationAttribute]
private Collection`1<string> columnNames;
    [ObfuscationAttribute]
private int minimumZoom;
    [ObfuscationAttribute]
private int maximumZoom;
    public FeatureLayer FeatureLayer { get; public set; }
    public Collection`1<string> ColumnNames { get; public set; }
    public int MinimumZoom { get; public set; }
    public int MaximumZoom { get; public set; }
    public MBTilesGenerationLayerSetting(FeatureLayer featureLayer, IEnumerable`1<string> columnNames, int minimumZoom, int maximumZoom);
    public FeatureLayer get_FeatureLayer();
    public void set_FeatureLayer(FeatureLayer value);
    public Collection`1<string> get_ColumnNames();
    public void set_ColumnNames(Collection`1<string> value);
    public int get_MinimumZoom();
    public void set_MinimumZoom(int value);
    public int get_MaximumZoom();
    public void set_MaximumZoom(int value);
}
public class ThinkGeo.Core.MbTilesLayer : LayerAsync {
    private SqliteConnection WiM=;
    private string WyM=;
    private string XCM=;
    private RectangleShape XSM=;
    private PointShape XiM=;
    private int XyM=;
    private int YCM=;
    private int YSM=;
    private string YiM=;
    private string YyM=;
    private string ZCM=;
    private string ZSM=;
    private string ZiM=;
    private string ZyM=;
    [CompilerGeneratedAttribute]
private string aCM=;
    [CompilerGeneratedAttribute]
private Stream aSM=;
    private ZoomLevelSet aiM=;
    [CompilerGeneratedAttribute]
private GeoColor ayM=;
    public string FilePath { get; public set; }
    public Stream StyleJsonStream { get; public set; }
    public ZoomLevelSet ZoomLevelSet { get; public set; }
    public GeoColor BackgroundColor { get; public set; }
    public bool HasBoundingBox { get; }
    public MbTilesLayer(string filePath, string styleJsonFilePath);
    public MbTilesLayer(string filePath, Stream styleJsonStream);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public Stream get_StyleJsonStream();
    [CompilerGeneratedAttribute]
public void set_StyleJsonStream(Stream value);
    public ZoomLevelSet get_ZoomLevelSet();
    public void set_ZoomLevelSet(ZoomLevelSet value);
    [CompilerGeneratedAttribute]
public GeoColor get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(GeoColor value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/DUA=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/CUA=")]
private Task bCM=(CancellationToken cancellationToken);
    public virtual bool get_HasBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/A0A=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/BEA=")]
private Task bSM=(ZoomLevel zoomLevel, RowColumnRange rowColumnRange, int zoom, GeoCanvas canvas);
    private static List`1<Feature> biM=(Collection`1<VectorTile> tiles, RectangleShape currentExtent, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/BUA=")]
private Task`1<Collection`1<VectorTile>> byM=(RowColumnRange rowColumnRange, int zoomLevel);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesLayer/AkA=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    private static ValueTuple`2<ZoomLevelSet, GeoColor> cCM=(string styleJsonString, ZoomLevelSet zoomLevelSet, string layerColumnName);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task /h0=(CancellationToken cancellationToken);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task /x0=(CancellationToken cancellationToken);
}
public class ThinkGeo.Core.MbTilesRasterLayer : LayerAsync {
    private SqliteConnection WiM=;
    private string WyM=;
    private string XCM=;
    private RectangleShape XSM=;
    private PointShape XiM=;
    private int XyM=;
    private int YCM=;
    private int YSM=;
    private string YiM=;
    private string YyM=;
    private string ZCM=;
    private string ZSM=;
    private string ZiM=;
    [CompilerGeneratedAttribute]
private ZoomLevelSet ch0=;
    [CompilerGeneratedAttribute]
private string aCM=;
    public ZoomLevelSet ZoomLevelSet { get; public set; }
    public string FilePath { get; public set; }
    public bool HasBoundingBox { get; }
    public MbTilesRasterLayer(string filePath);
    [CompilerGeneratedAttribute]
public ZoomLevelSet get_ZoomLevelSet();
    [CompilerGeneratedAttribute]
public void set_ZoomLevelSet(ZoomLevelSet value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public void set_FilePath(string value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesRasterLayer/FUA=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesRasterLayer/FEA=")]
private Task bCM=(CancellationToken cancellationToken);
    public virtual bool get_HasBoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesRasterLayer/D0A=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesRasterLayer/EEA=")]
private Task bSM=(RowColumnRange rowColumnRange, int zoom, GeoCanvas geoCanvas);
    [AsyncStateMachineAttribute("ThinkGeo.Core.MbTilesRasterLayer/DkA=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task /h0=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /x0=(CancellationToken cancellationToken);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.MetersValues : ValueType {
    [ObfuscationAttribute]
private double v10;
    [ObfuscationAttribute]
private double v100;
    [ObfuscationAttribute]
private double v1000;
    [ObfuscationAttribute]
private double v20;
    [ObfuscationAttribute]
private double v200;
    [ObfuscationAttribute]
private double v30;
    [ObfuscationAttribute]
private double v300;
    [ObfuscationAttribute]
private double v40;
    [ObfuscationAttribute]
private double v400;
    [ObfuscationAttribute]
private double v50;
    [ObfuscationAttribute]
private double v500;
    public double JCE= { get; }
    public double JiE= { get; }
    public double KCE= { get; }
    public double KiE= { get; }
    public double LCE= { get; }
    public double LiE= { get; }
    public double MCE= { get; }
    public double MiE= { get; }
    public double NCE= { get; }
    public double NiE= { get; }
    public double OCE= { get; }
    public MetersValues(int width, double extentLengthBar, DistanceUnit distanceUnit);
    public double IyE=();
    public double JSE=();
    public double JyE=();
    public double KSE=();
    public double KyE=();
    public double LSE=();
    public double LyE=();
    public double MSE=();
    public double MyE=();
    public double NSE=();
    public double NyE=();
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.MilesValues : ValueType {
    [ObfuscationAttribute]
private double v01;
    [ObfuscationAttribute]
private double v02;
    [ObfuscationAttribute]
private double v03;
    [ObfuscationAttribute]
private double v04;
    [ObfuscationAttribute]
private double v05;
    [ObfuscationAttribute]
private double v1;
    [ObfuscationAttribute]
private double v10;
    [ObfuscationAttribute]
private double v100;
    [ObfuscationAttribute]
private double v1000;
    [ObfuscationAttribute]
private double v2;
    [ObfuscationAttribute]
private double v20;
    [ObfuscationAttribute]
private double v200;
    [ObfuscationAttribute]
private double v3;
    [ObfuscationAttribute]
private double v30;
    [ObfuscationAttribute]
private double v300;
    [ObfuscationAttribute]
private double v4;
    [ObfuscationAttribute]
private double v40;
    [ObfuscationAttribute]
private double v400;
    [ObfuscationAttribute]
private double v5;
    [ObfuscationAttribute]
private double v50;
    [ObfuscationAttribute]
private double v500;
    public double SCE= { get; }
    public double SiE= { get; }
    public double TCE= { get; }
    public double TiE= { get; }
    public double UCE= { get; }
    public double PCE= { get; }
    public double PiE= { get; }
    public double QCE= { get; }
    public double QiE= { get; }
    public double RCE= { get; }
    public double JCE= { get; }
    public double JiE= { get; }
    public double KCE= { get; }
    public double KiE= { get; }
    public double LCE= { get; }
    public double LiE= { get; }
    public double MCE= { get; }
    public double MiE= { get; }
    public double NCE= { get; }
    public double NiE= { get; }
    public double OCE= { get; }
    public MilesValues(int width, double extentLengthBar, DistanceUnit distanceUnit);
    public double RyE=();
    public double SSE=();
    public double SyE=();
    public double TSE=();
    public double TyE=();
    public double OyE=();
    public double PSE=();
    public double PyE=();
    public double QSE=();
    public double QyE=();
    public double IyE=();
    public double JSE=();
    public double JyE=();
    public double KSE=();
    public double KyE=();
    public double LSE=();
    public double LyE=();
    public double MSE=();
    public double MyE=();
    public double NSE=();
    public double NyE=();
}
public class ThinkGeo.Core.MouseMovedTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Vertex movedVertex;
    [ObfuscationAttribute]
private Feature affectedFeature;
    public Vertex MovedVertex { get; public set; }
    public Feature AffectedFeature { get; public set; }
    public MouseMovedTrackInteractiveOverlayEventArgs(Vertex movedVertex, Feature affectedFeature);
    public Vertex get_MovedVertex();
    public void set_MovedVertex(Vertex value);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
}
public class ThinkGeo.Core.MovedItemGeoCollectionEventArgs : object {
    [CompilerGeneratedAttribute]
private int sxU=;
    [CompilerGeneratedAttribute]
private int tBU=;
    public int FromIndex { get; public set; }
    public int ToIndex { get; public set; }
    public MovedItemGeoCollectionEventArgs(int fromIndex, int toIndex);
    [CompilerGeneratedAttribute]
public int get_FromIndex();
    [CompilerGeneratedAttribute]
public void set_FromIndex(int value);
    [CompilerGeneratedAttribute]
public int get_ToIndex();
    [CompilerGeneratedAttribute]
public void set_ToIndex(int value);
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.MultilineShape : LineBaseShape {
    [ObfuscationAttribute]
private Collection`1<LineShape> lines;
    public Collection`1<LineShape> Lines { get; }
    public MultilineShape(IEnumerable`1<LineShape> lineShapes);
    public MultilineShape(string wellKnownText);
    public MultilineShape(Byte[] wellKnownBinary);
    public Collection`1<LineShape> get_Lines();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual BaseShape CloneDeepCore();
    protected virtual PointShape GetCenterPointCore();
    public void Reorder(PointShape startPoint, double tolerance);
    public void Reorder(PointShape startPoint, double tolerance, GeographyUnit shapeUnit, DistanceUnit unitOfTolerance);
    protected virtual void ReorderCore(PointShape startPoint, double tolerance, GeographyUnit shapeUnit, DistanceUnit unitOfTolerance);
    protected virtual double GetLengthCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    public PointShape GetPointOnALine(StartingPoint startingPoint, float percentageOfLine);
    public PointShape GetPointOnALine(StartingPoint startingPoint, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetPointOnALineCore(StartingPoint startingPoint, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, float startingPercentageOfTheLine, float percentageOfTheLine);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, float percentageOfLine);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, double startingDistance, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual LineBaseShape GetLineOnALineCore(StartingPoint startingPoint, double startingDistance, double distance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    public LineBaseShape GetLineOnALine(StartingPoint startingPoint, PointShape endPointShape);
    public LineBaseShape GetLineOnALine(PointShape startPointShape, PointShape endPointShape);
    private MultilineShape SBw=(PointShape startPointShape, PointShape endPointShape);
    private double SRw=(PointShape pointShape);
    private static void WBw=(MultilineShape ResultMultiLine, Double& CumulDistEnd, LineShape LineShape, StartingPoint startingPoint, double StartingDistance, double EndingDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    private static void WRw=(MultilineShape fromLines, MultilineShape toLines);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public static bool RemoveVertex(Vertex selectedVertex, MultilineShape multilineShape);
    public bool RemoveVertex(Vertex selectedVertex);
    public MultipolygonShape ToMultiPolygonShape();
    internal void SRU=(double factor);
    private static void Whw=(LineShape lineShape, StringBuilder wellKnownText);
    private LineShape Wxw=(Vertex vertex, double Tolerance, GeographyUnit ShapesUnit, DistanceUnit ToleranceUnit);
    private bool XBw=(double tolerance, GeographyUnit shapeUnit, DistanceUnit unitOfTolerance);
    private bool XRw=(PointShape pointShape, double tolerance, GeographyUnit shapeUnit, DistanceUnit unitOfTolerance);
    private static RectangleShape VRw=(IEnumerable`1<Vertex> vertices);
}
public class ThinkGeo.Core.MultipleFeatureLayer : FeatureLayer {
    public Collection`1<FeatureSource> FeatureSources { get; }
    public bool HasBoundingBox { get; }
    public MultipleFeatureLayer(IEnumerable`1<FeatureSource> featureSources);
    public Collection`1<FeatureSource> get_FeatureSources();
    public virtual bool get_HasBoundingBox();
}
public class ThinkGeo.Core.MultipleFeatureSource : FeatureSource {
    [ObfuscationAttribute]
private Collection`1<FeatureSource> featureSources;
    [ObfuscationAttribute]
private Collection`1<long> featureCounts;
    public Collection`1<FeatureSource> FeatureSources { get; }
    public bool IsEditable { get; }
    public MultipleFeatureSource(IEnumerable`1<FeatureSource> featureSources);
    public Collection`1<FeatureSource> get_FeatureSources();
    public virtual bool get_IsEditable();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual long GetCountCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesNearestToCore(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesWithinDistanceOfCore(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> SpatialQueryCore(BaseShape targetShape, QueryType queryType, IEnumerable`1<string> returningColumnNames);
}
public class ThinkGeo.Core.MultipleShapeFileFeatureLayer : FeatureLayer {
    public Collection`1<string> ShapeFiles { get; }
    public Collection`1<string> Indexes { get; }
    public string MultipleShapeFilePattern { get; public set; }
    public string IndexFilePattern { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool HasBoundingBox { get; }
    public MultipleShapeFileFeatureLayer(string multipleShapeFilePattern);
    public MultipleShapeFileFeatureLayer(string multipleShapeFilePattern, string indexFilePattern);
    public MultipleShapeFileFeatureLayer(IEnumerable`1<string> shapeFiles);
    public MultipleShapeFileFeatureLayer(IEnumerable`1<string> shapeFiles, IEnumerable`1<string> indexes);
    public Collection`1<string> get_ShapeFiles();
    public Collection`1<string> get_Indexes();
    public string get_MultipleShapeFilePattern();
    public void set_MultipleShapeFilePattern(string value);
    public string get_IndexFilePattern();
    public void set_IndexFilePattern(string value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public virtual bool get_HasBoundingBox();
    public static void BuildIndex(string multipleShapeFilePattern);
    public static void BuildIndex(string multipleShapeFilePattern, BuildIndexMode buildIndexMode);
    public static void BuildIndex(string multipleShapeFilePattern, string indexFilePattern);
    public static void BuildIndex(string multipleShapeFilePattern, string indexFilePattern, BuildIndexMode buildIndexMode);
    public static void BuildIndex(string multipleShapeFilePattern, string columnName, string regularExpression, string indexFilename);
    public static void BuildIndex(string multipleShapeFilePattern, string columnName, string regularExpression, string indexFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndex(String[] multipleShapeFiles, String[] multipleShapeFileIndexes);
    public static void BuildIndex(String[] multipleShapeFiles, String[] multipleShapeFileIndexes, BuildIndexMode buildIndexMode);
    public Collection`1<string> GetShapePathFilenames();
    public Collection`1<string> GetIndexPathFilenames();
}
public class ThinkGeo.Core.MultipleShapeFileFeatureSource : FeatureSource {
    private static int 7iM=;
    private static char 7yM=;
    private static char 8CM=;
    [ObfuscationAttribute]
private Dictionary`2<string, GeoDbf> dBaseEngines;
    [ObfuscationAttribute]
private string indexFilePattern;
    [ObfuscationAttribute]
private bool isBigMultipleIndex;
    [ObfuscationAttribute]
private string multipleShapeFilePattern;
    [ObfuscationAttribute]
private Dictionary`2<string, RtreeSpatialIndex> rTreeIndexs;
    [ObfuscationAttribute]
private Collection`1<string> shapeFiles;
    [ObfuscationAttribute]
private Collection`1<string> indexes;
    [ObfuscationAttribute]
private FileAccess shapeFileReadWriteMode;
    [ObfuscationAttribute]
private Dictionary`2<string, ShapeFile> cachedShapeFiles;
    [ObfuscationAttribute]
private Encoding encoding;
    public Collection`1<string> ShapeFiles { get; }
    public Collection`1<string> Indexes { get; }
    public string MultipleShapeFilePattern { get; public set; }
    public string IndexFilePattern { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool IsEditable { get; }
    public MultipleShapeFileFeatureSource(string multipleShapeFilePattern);
    public MultipleShapeFileFeatureSource(string multipleShapeFilePattern, string indexFilePattern);
    public MultipleShapeFileFeatureSource(IEnumerable`1<string> shapeFiles);
    public MultipleShapeFileFeatureSource(IEnumerable`1<string> shapeFiles, IEnumerable`1<string> indexes);
    private void Kh8=(IEnumerable`1<string> multipleShapeFiles, IEnumerable`1<string> multipleShapeFileIndexes);
    public Collection`1<string> get_ShapeFiles();
    public Collection`1<string> get_Indexes();
    public string get_MultipleShapeFilePattern();
    public void set_MultipleShapeFilePattern(string value);
    public string get_IndexFilePattern();
    public void set_IndexFilePattern(string value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public virtual bool get_IsEditable();
    public Collection`1<string> GetShapePathFilenames();
    public Collection`1<string> GetIndexPathFilenames();
    public static void BuildIndex(string multipleShapeFilePattern);
    public static void BuildIndex(string multipleShapeFilePattern, BuildIndexMode buildIndexMode);
    public static void BuildIndex(string multipleShapeFilePattern, string indexFilePattern);
    public static void BuildIndex(string multipleShapeFilePattern, string indexFilePattern, BuildIndexMode buildIndexMode);
    public static void BuildIndex(string multipleShapeFilePattern, string columnName, string regularExpression, string indexFilename);
    public static void BuildIndex(string multipleShapeFilePattern, string columnName, string regularExpression, string indexPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndex(String[] multipleShapeFiles, String[] multipleShapeFileIndexes);
    public static void BuildIndex(String[] multipleShapeFiles, String[] multipleShapeFileIndexes, BuildIndexMode buildIndexMode);
    private static bool 8SM=(BuildIndexMode buildIndexMode, IEnumerable`1<string> idxPathFilenames);
    private static Dictionary`2<string, string> 8iM=(string multipleShapeFilePattern, string indexFilePattern);
    private static void 8yM=(string shapePathFilename, string idxFileName, string columnName, string regularExpression);
    private static bool 9CM=(GeoDbf dbaseEngine, int recourdId, string columnName, Regex regex);
    private static void 9SM=(string idxPathFilename, WellKnownType wellKnownType);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    private Collection`1<string> 9iM=(string shapePathFilename, string key);
    private Collection`1<Feature> 9yM=(string shapePathFilename, string key, List`1<string> columnNames);
    private static Dictionary`2<string, string> /CM=(GeoDbf dBaseEngine, string id, IEnumerable`1<string> columnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    private RectangleShape /SM=(string shapePathFilename, string key);
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    private Feature /iM=(string originalId, string key, string recordId, List`1<string> recordNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> /yM=(string shapePathFilename, string key, RectangleShape boundingBox, List`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private string ACQ=(string shapefile);
    private Collection`1<Feature> ASQ=(string shapePathFilename, string key, RectangleShape boundingBox, List`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesWithinDistanceOfCore(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    private Collection`1<Feature> AiQ=(string shapeFilePathName, string key, BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, List`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesNearestToCore(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    private static String[] AyQ=(string wildcardPathFilename);
    private ShapeFile BCQ=(string shapePathFilename, string key);
    private GeoDbf BSQ=(string shapePathFilename, string key);
    private RtreeSpatialIndex BiQ=(string shapePathFilename, string key);
    private static void ByQ=(string pathFilename);
    private static WellKnownType qxo=(ShapeFileType shapeFileType);
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.MultipointShape : PointBaseShape {
    [ObfuscationAttribute]
private Collection`1<PointShape> points;
    public Collection`1<PointShape> Points { get; }
    public MultipointShape(IEnumerable`1<PointShape> points);
    public MultipointShape(IEnumerable`1<Feature> pointFeatures);
    public MultipointShape(Feature multipointFeature);
    public MultipointShape(string wellKnownText);
    public MultipointShape(Byte[] wellKnownBinary);
    public Collection`1<PointShape> get_Points();
    protected virtual BaseShape CloneDeepCore();
    protected virtual PointShape GetCenterPointCore();
    public void ScaleUp(double percentage);
    protected virtual void ScaleUpCore(double percentage);
    public void ScaleDown(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    private void SRU=(float multiplicator);
    public RingShape ConvexHull();
    protected virtual RingShape ConvexHullCore();
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    private static void Xhw=(MultipointShape fromMultipoint, MultipointShape toMultipoint);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public static bool RemoveVertex(Vertex selectedVertex, MultipointShape multipointShape);
    public bool RemoveVertex(Vertex selectedVertex);
    private static RectangleShape Xxw=(IEnumerable`1<PointShape> points);
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.MultipolygonShape : AreaBaseShape {
    [ObfuscationAttribute]
private Collection`1<PolygonShape> polygons;
    public Collection`1<PolygonShape> Polygons { get; }
    public MultipolygonShape(IEnumerable`1<PolygonShape> polygons);
    public MultipolygonShape(string wellKnownText);
    public MultipolygonShape(Byte[] wellKnownBinary);
    public Collection`1<PolygonShape> get_Polygons();
    protected virtual BaseShape CloneDeepCore();
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    private static void YBw=(RingShape targetRingShape, WkbByteOrder byteOrder, BinaryWriter writer);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual RectangleShape GetBoundingBoxCore();
    private static void YRw=(MultipolygonShape fromMultipolygon, MultipolygonShape toMultipolygon);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    protected virtual bool ContainsCore(BaseShape targetShape);
    public static bool RemoveVertex(Vertex selectedVertex, MultipolygonShape multipolygonShape);
    public bool RemoveVertex(Vertex selectedVertex);
    public MultilineShape ToMultiLineShape();
    private static void Yhw=(RingShape targetRingShape, WkbByteOrder byteOrder, BinaryWriter writer);
    private void Yxw=(string wellKnownText);
    private void ZBw=(Byte[] wellKnownBinary);
    internal void SRU=(double multiplicator);
    private static RectangleShape VRw=(IEnumerable`1<Vertex> vertices);
}
public class ThinkGeo.Core.NativeImageRasterLayer : RasterLayer {
    public bool HasBoundingBox { get; }
    public string ImagePathFilename { get; public set; }
    public NativeImageRasterLayer(string imagePathFilename);
    public NativeImageRasterLayer(string imagePathFilename, string worldfilePathFilename);
    public NativeImageRasterLayer(string imagePathFilename, RectangleShape imageExtent);
    public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public virtual bool get_HasBoundingBox();
    public string get_ImagePathFilename();
    public void set_ImagePathFilename(string value);
}
public class ThinkGeo.Core.NativeImageRasterSource : RasterSource {
    [ObfuscationAttribute]
private static int smallestSizeForTemplate;
    [ObfuscationAttribute]
private GeoImage bufferBitmap;
    [ObfuscationAttribute]
private RectangleShape imageExtent;
    [ObfuscationAttribute]
private string imagePathFilename;
    [ObfuscationAttribute]
private WorldFile worldFile;
    [ObfuscationAttribute]
private string worldFilePathFilename;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Dh8=;
    public bool IsNegative { get; public set; }
    public bool IsGrayscale { get; public set; }
    public string FileName { get; }
    public string FilePath { get; }
    public string ImagePathFilename { get; public set; }
    public NativeImageRasterSource(string imagePathFilename);
    public NativeImageRasterSource(string imagePathFilename, string worldfilePathFilename);
    public NativeImageRasterSource(string imagePathFilename, RectangleShape imageExtent);
    public bool get_IsNegative();
    public void set_IsNegative(bool value);
    public bool get_IsGrayscale();
    public void set_IsGrayscale(bool value);
    public string get_FileName();
    public string get_FilePath();
    public string get_ImagePathFilename();
    public void set_ImagePathFilename(string value);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    protected virtual int GetImageWidthCore();
    protected virtual int GetImageHeightCore();
    private static WorldFile gyM=(string worldFilePath);
    private static WorldFile hCM=(Stream stream);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual GeoImage GetImageCore(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    protected virtual RectangleShape GetBoundingBoxCore();
    private static DrawingRectangle hSM=(float bmpWidth, float bmpHeight, RectangleShape sourceRectangleInWorld, RectangleShape boundingBox);
    private RectangleShape hiM=();
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.NauticalMilesValues : ValueType {
    [ObfuscationAttribute]
private double v01;
    [ObfuscationAttribute]
private double v02;
    [ObfuscationAttribute]
private double v03;
    [ObfuscationAttribute]
private double v04;
    [ObfuscationAttribute]
private double v05;
    [ObfuscationAttribute]
private double v1;
    [ObfuscationAttribute]
private double v10;
    [ObfuscationAttribute]
private double v100;
    [ObfuscationAttribute]
private double v1000;
    [ObfuscationAttribute]
private double v2;
    [ObfuscationAttribute]
private double v20;
    [ObfuscationAttribute]
private double v200;
    [ObfuscationAttribute]
private double v3;
    [ObfuscationAttribute]
private double v30;
    [ObfuscationAttribute]
private double v300;
    [ObfuscationAttribute]
private double v4;
    [ObfuscationAttribute]
private double v40;
    [ObfuscationAttribute]
private double v400;
    [ObfuscationAttribute]
private double v5;
    [ObfuscationAttribute]
private double v50;
    [ObfuscationAttribute]
private double v500;
    public double SCE= { get; }
    public double SiE= { get; }
    public double TCE= { get; }
    public double TiE= { get; }
    public double UCE= { get; }
    public double PCE= { get; }
    public double PiE= { get; }
    public double QCE= { get; }
    public double QiE= { get; }
    public double RCE= { get; }
    public double JCE= { get; }
    public double JiE= { get; }
    public double KCE= { get; }
    public double KiE= { get; }
    public double LCE= { get; }
    public double LiE= { get; }
    public double MCE= { get; }
    public double MiE= { get; }
    public double NCE= { get; }
    public double NiE= { get; }
    public double OCE= { get; }
    public NauticalMilesValues(int width, double extentLengthBar, DistanceUnit distanceUnit);
    public double RyE=();
    public double SSE=();
    public double SyE=();
    public double TSE=();
    public double TyE=();
    public double OyE=();
    public double PSE=();
    public double PyE=();
    public double QSE=();
    public double QyE=();
    public double IyE=();
    public double JSE=();
    public double JyE=();
    public double KSE=();
    public double KyE=();
    public double LSE=();
    public double LyE=();
    public double MSE=();
    public double MyE=();
    public double NSE=();
    public double NyE=();
}
public class ThinkGeo.Core.NoaaWeatherStation : object {
    [CompilerGeneratedAttribute]
private string mCM=;
    [CompilerGeneratedAttribute]
private string 2B0=;
    [CompilerGeneratedAttribute]
private string mSM=;
    [CompilerGeneratedAttribute]
private string miM=;
    [CompilerGeneratedAttribute]
private double myM=;
    [CompilerGeneratedAttribute]
private double nCM=;
    [CompilerGeneratedAttribute]
private double nSM=;
    [CompilerGeneratedAttribute]
private NoaaWeatherStationSiteType niM=;
    [CompilerGeneratedAttribute]
private string nyM=;
    [CompilerGeneratedAttribute]
private string oCM=;
    [XmlElementAttribute]
public string StationId { get; public set; }
    [XmlElementAttribute]
public string Name { get; public set; }
    [XmlElementAttribute]
public string State { get; public set; }
    [XmlElementAttribute]
public string Country { get; public set; }
    [XmlElementAttribute]
public double Latitude { get; public set; }
    [XmlElementAttribute]
public double Longitude { get; public set; }
    [XmlElementAttribute]
public double Elevation { get; public set; }
    [XmlElementAttribute]
public NoaaWeatherStationSiteType SiteType { get; public set; }
    public string Description { get; public set; }
    public string Temperature { get; public set; }
    [CompilerGeneratedAttribute]
public string get_StationId();
    [CompilerGeneratedAttribute]
public void set_StationId(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_State();
    [CompilerGeneratedAttribute]
public void set_State(string value);
    [CompilerGeneratedAttribute]
public string get_Country();
    [CompilerGeneratedAttribute]
public void set_Country(string value);
    [CompilerGeneratedAttribute]
public double get_Latitude();
    [CompilerGeneratedAttribute]
public void set_Latitude(double value);
    [CompilerGeneratedAttribute]
public double get_Longitude();
    [CompilerGeneratedAttribute]
public void set_Longitude(double value);
    [CompilerGeneratedAttribute]
public double get_Elevation();
    [CompilerGeneratedAttribute]
public void set_Elevation(double value);
    [CompilerGeneratedAttribute]
public NoaaWeatherStationSiteType get_SiteType();
    [CompilerGeneratedAttribute]
public void set_SiteType(NoaaWeatherStationSiteType value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Temperature();
    [CompilerGeneratedAttribute]
public void set_Temperature(string value);
    public Feature ToFeature();
    public void FillDescriptionAndTemperature();
    private static string oSM=(string celsiusString);
}
public class ThinkGeo.Core.NoaaWeatherStationFeatureLayer : FeatureLayer {
}
public class ThinkGeo.Core.NoaaWeatherStationFeatureSource : FeatureSource {
    private Dictionary`2<string, Feature> kCM=;
    private Dictionary`2<string, NoaaWeatherStation> kSM=;
    private STRtree`1<string> YCA=;
    [CompilerGeneratedAttribute]
private int BR4=;
    public int TimeoutInSeconds { get; public set; }
    [CompilerGeneratedAttribute]
public int get_TimeoutInSeconds();
    [CompilerGeneratedAttribute]
public void set_TimeoutInSeconds(int value);
    protected virtual void OpenCore();
    private static STRtree`1<string> kiM=(Dictionary`2<string, Feature> stationsCache);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public void UpdateWeatherStations();
    public Dictionary`2<string, Feature> GetStationFeatures();
    private Dictionary`2<string, NoaaWeatherStation> kyM=();
    private void lCM=(Uri cycleUri);
    private static Collection`1<Uri> lSM=();
}
[XmlRootAttribute]
public class ThinkGeo.Core.NoaaWeatherStationResponse : object {
    [CompilerGeneratedAttribute]
private double liM=;
    [CompilerGeneratedAttribute]
private List`1<NoaaWeatherStation> lyM=;
    [XmlElementAttribute]
public double RequestIndex { get; public set; }
    [XmlArrayItemAttribute("Station", "ThinkGeo.Core.NoaaWeatherStation")]
[XmlArrayAttribute("data")]
public List`1<NoaaWeatherStation> Stations { get; public set; }
    [CompilerGeneratedAttribute]
public double get_RequestIndex();
    [CompilerGeneratedAttribute]
public void set_RequestIndex(double value);
    [CompilerGeneratedAttribute]
public List`1<NoaaWeatherStation> get_Stations();
    [CompilerGeneratedAttribute]
public void set_Stations(List`1<NoaaWeatherStation> value);
    public static NoaaWeatherStationResponse DownloadNoaaWeatherStationResponse();
}
public class ThinkGeo.Core.NoaaWeatherStationSiteType : object {
    [CompilerGeneratedAttribute]
private string oiM=;
    [CompilerGeneratedAttribute]
private string oyM=;
    [CompilerGeneratedAttribute]
private string pCM=;
    [CompilerGeneratedAttribute]
private string pSM=;
    [CompilerGeneratedAttribute]
private string piM=;
    [XmlElementAttribute("METAR")]
public string Metar { get; public set; }
    [XmlElementAttribute("TAF")]
public string Taf { get; public set; }
    [XmlElementAttribute("rawinsonde")]
public string Rawinsonde { get; public set; }
    [XmlElementAttribute("WFO_office")]
public string WfoOffice { get; public set; }
    [XmlElementAttribute("NEXRAD")]
public string Nexrad { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Metar();
    [CompilerGeneratedAttribute]
public void set_Metar(string value);
    [CompilerGeneratedAttribute]
public string get_Taf();
    [CompilerGeneratedAttribute]
public void set_Taf(string value);
    [CompilerGeneratedAttribute]
public string get_Rawinsonde();
    [CompilerGeneratedAttribute]
public void set_Rawinsonde(string value);
    [CompilerGeneratedAttribute]
public string get_WfoOffice();
    [CompilerGeneratedAttribute]
public void set_WfoOffice(string value);
    [CompilerGeneratedAttribute]
public string get_Nexrad();
    [CompilerGeneratedAttribute]
public void set_Nexrad(string value);
    public int GetPriority();
}
public class ThinkGeo.Core.NoaaWeatherStationStyle : Style {
    private Dictionary`2<string, GeoImage> rSM=;
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    private void riM=();
    private static void ryM=(Feature feature, Collection`1<RectangleShape> recordsDrawn, GeoCanvas canvas, GeoImage image, double x, double y, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotationAngle);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual override void Finalize();
}
public class ThinkGeo.Core.NoaaWeatherWarningsFeatureLayer : FeatureLayer {
}
public class ThinkGeo.Core.NoaaWeatherWarningsFeatureSource : FeatureSource {
    private TinyGeoFeatureSource pyM=;
    private Dictionary`2<string, List`1<Dictionary`2<string, string>>> qCM=;
    protected virtual void OpenCore();
    private Dictionary`2<string, List`1<Dictionary`2<string, string>>> qSM=();
    private void qiM=(XmlNode warningEntry, XmlNamespaceManager nsmgr, TinyGeoFeatureSource countiesFeatureSource, Dictionary`2<string, List`1<Dictionary`2<string, string>>> warnings, Dictionary`2<string, string> fipsToFeatureIds);
    protected virtual void CloseCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual long GetCountCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private TinyGeoFeatureSource qyM=();
    private void rCM=(object sender, StreamLoadingEventArgs e);
}
public class ThinkGeo.Core.NoaaWeatherWarningsStyle : ValueStyle {
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    private void sCM=();
}
[AttributeUsageAttribute("4124")]
public class ThinkGeo.Core.NonSerializableBaseTypeAttribute : Attribute {
}
public class ThinkGeo.Core.OgcApiFeatureLayer : FeatureLayer {
    public string Url { get; public set; }
    public int BulkSize { get; public set; }
    public string CollectionId { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public bool HasBoundingBox { get; }
    public IWebProxy WebProxy { get; public set; }
    public OgcApiFeatureLayer(string url, string collectionId, int bulkSize);
    public string get_Url();
    public void set_Url(string value);
    public int get_BulkSize();
    public void set_BulkSize(int value);
    public string get_CollectionId();
    public void set_CollectionId(string value);
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public virtual bool get_HasBoundingBox();
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public Collection`1<string> GetLayers();
}
public class ThinkGeo.Core.OgcApiFeatureSource : FeatureSource {
    private static string zyM=;
    private Collection`1<FeatureSourceColumn> 0CM=;
    [ObfuscationAttribute]
private Collection`1<string> layers;
    [ObfuscationAttribute]
private wSM= ogcApiFeatureCollection;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingWebRequestEventArgs> vhQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentWebRequestEventArgs> vxQ=;
    [CompilerGeneratedAttribute]
private string 0SM=;
    [CompilerGeneratedAttribute]
private string 0iM=;
    [CompilerGeneratedAttribute]
private int 0yM=;
    [CompilerGeneratedAttribute]
private int BR4=;
    [CompilerGeneratedAttribute]
private IWebProxy Bh4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> 1CM=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> 1SM=;
    public string Url { get; public set; }
    public string CollectionId { get; public set; }
    public int BulkSize { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public OgcApiFeatureSource(string url, string collectionId, int bulkSize);
    [CompilerGeneratedAttribute]
public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_CollectionId();
    [CompilerGeneratedAttribute]
public void set_CollectionId(string value);
    [CompilerGeneratedAttribute]
public int get_BulkSize();
    [CompilerGeneratedAttribute]
public void set_BulkSize(int value);
    [CompilerGeneratedAttribute]
public int get_TimeoutInSeconds();
    [CompilerGeneratedAttribute]
public void set_TimeoutInSeconds(int value);
    [CompilerGeneratedAttribute]
public IWebProxy get_WebProxy();
    [CompilerGeneratedAttribute]
public void set_WebProxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public void add_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestingData(RequestingDataWfsFeatureSourceEventArgs requestingDataWfsFeatureSourceEventArgs);
    [CompilerGeneratedAttribute]
public void add_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestedData(RequestedDataWfsFeatureSourceEventArgs requestedDataWfsFeatureSourceEventArgs);
    protected WebResponse SendWebRequest(WebRequest webRequest);
    protected virtual WebResponse SendWebRequestCore(WebRequest webRequest);
    protected virtual void OnSendingWebRequest(SendingWebRequestEventArgs e);
    protected virtual void OnSentWebRequest(SentWebRequestEventArgs e);
    public string GetCapabilities();
    private string 1iM=(string requestString);
    private static void ZR4=(string requestCapabilities, string jsonString);
    private static string 1yM=(string requestCapabilities);
    public Collection`1<string> GetLayers();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public string GetRequestUrlForFeatures(RectangleShape boundingBox, Nullable`1<int> limit);
    public ValueTuple`2<string, Collection`1<Feature>> GetFeatures(string requestFeaturesUrl);
    public Collection`1<string> GetSupportedCrs();
    public string GetDefaultCrs();
    private static string 2CM=(string crs);
    private Collection`1<Feature> 2SM=(string requestFeaturesUrl);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    [CompilerGeneratedAttribute]
private bool 2iM=(uCM= col);
    [CompilerGeneratedAttribute]
private bool 2yM=(uCM= c);
    [CompilerGeneratedAttribute]
private bool 3CM=(uCM= col);
}
[AttributeUsageAttribute("64")]
public class ThinkGeo.Core.OnGeodeserializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class ThinkGeo.Core.OnGeodeserializingAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class ThinkGeo.Core.OnGeoserializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class ThinkGeo.Core.OnGeoserializingAttribute : Attribute {
}
public class ThinkGeo.Core.OpenedFeatureSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.OpenedRasterSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.OpeningFeatureSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.OpeningRasterSourceEventArgs : EventArgs {
}
public class ThinkGeo.Core.OpenStreetMapAsyncLayer : XyzTileAsyncLayer {
    [ObfuscationAttribute]
private static int TILE_SIZE;
    [ObfuscationAttribute]
private static Uri[] DefaultUris;
    [ObfuscationAttribute]
private Collection`1<Uri> customServerUris;
    public Collection`1<Uri> CustomServerUris { get; }
    public OpenStreetMapAsyncLayer(string userAgent);
    public OpenStreetMapAsyncLayer(IWebProxy webProxy);
    public OpenStreetMapAsyncLayer(string userAgent, IWebProxy webProxy);
    private static OpenStreetMapAsyncLayer();
    [AsyncStateMachineAttribute("ThinkGeo.Core.OpenStreetMapAsyncLayer/MT8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public Collection`1<Uri> get_CustomServerUris();
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /h0=(CancellationToken cancellationToken);
}
public class ThinkGeo.Core.OpenStreetMapsZoomLevelSet : ZoomLevelSet {
}
public class ThinkGeo.Core.OsmBuildingAreaStyle : BuildingAreaStyle {
    private string sDE=;
    private double sTE=;
    public string LevelColumnName { get; public set; }
    public double LevelHeightInMeters { get; public set; }
    public OsmBuildingAreaStyle(string levelColumnName);
    public OsmBuildingAreaStyle(string levelColumnName, double levelHeightInMeters);
    public string get_LevelColumnName();
    public void set_LevelColumnName(string value);
    public double get_LevelHeightInMeters();
    public void set_LevelHeightInMeters(double value);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual double GetHeightInMeters(Feature feature);
}
public class ThinkGeo.Core.OsmBuildingOnlineFeatureLayer : FeatureLayer {
    public FileVectorTileCache TileCache { get; public set; }
    public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public FileVectorTileCache get_TileCache();
    public void set_TileCache(FileVectorTileCache value);
}
public class ThinkGeo.Core.OsmBuildingOnlineFeatureSource : FeatureSource {
    private static Collection`1<string> 5SM=;
    private 3SM= 5iM=;
    [ObfuscationAttribute]
private FileVectorTileCache tileCache;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingWebRequestEventArgs> vhQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentWebRequestEventArgs> vxQ=;
    public FileVectorTileCache TileCache { get; public set; }
    private static OsmBuildingOnlineFeatureSource();
    [CompilerGeneratedAttribute]
public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public FileVectorTileCache get_TileCache();
    public void set_TileCache(FileVectorTileCache value);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    internal ScreenPointF 5yM=(double lon, double lat, int zoom);
    private Byte[] 6CM=(string requestingUri);
    protected WebResponse SendWebRequest(WebRequest webRequest);
    protected virtual void OnSendingWebRequest(SendingWebRequestEventArgs e);
    protected virtual void OnSentWebRequest(SentWebRequestEventArgs e);
    protected virtual WebResponse SendWebRequestCore(WebRequest webRequest);
}
public enum ThinkGeo.Core.OverwriteMode : Enum {
    public int value__;
    public static OverwriteMode Overwrite;
    public static OverwriteMode DoNotOverwrite;
}
public enum ThinkGeo.Core.PanDirection : Enum {
    public int value__;
    public static PanDirection Up;
    public static PanDirection UpperRight;
    public static PanDirection Right;
    public static PanDirection LowerRight;
    public static PanDirection Down;
    public static PanDirection LowerLeft;
    public static PanDirection Left;
    public static PanDirection UpperLeft;
}
public class ThinkGeo.Core.PbfLayer : object {
    [CompilerGeneratedAttribute]
private string 2B0=;
    [CompilerGeneratedAttribute]
private ulong CRQ=;
    [CompilerGeneratedAttribute]
private List`1<string> 3ys=;
    [CompilerGeneratedAttribute]
private ulong vCM=;
    [CompilerGeneratedAttribute]
private List`1<object> 4Cs=;
    [CompilerGeneratedAttribute]
private List`1<Byte[]> 4Ss=;
    public string Name { get; private set; }
    public ulong Version { get; private set; }
    public List`1<string> Keys { get; private set; }
    internal ulong 5Cs= { get; private set; }
    internal List`1<object> syE= { get; private set; }
    internal List`1<Byte[]> 6Cs= { get; internal set; }
    public PbfLayer(Byte[] data);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public ulong get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(ulong value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Keys();
    [CompilerGeneratedAttribute]
private void set_Keys(List`1<string> value);
    [CompilerGeneratedAttribute]
internal ulong 4is=();
    [CompilerGeneratedAttribute]
private void 4ys=(ulong value);
    [CompilerGeneratedAttribute]
internal List`1<object> siE=();
    [CompilerGeneratedAttribute]
private void 5Ss=(List`1<object> value);
    [CompilerGeneratedAttribute]
internal List`1<Byte[]> 5is=();
    [CompilerGeneratedAttribute]
internal void 5ys=(List`1<Byte[]> value);
    internal xSs= 6Ss=(int featureIndex);
    private void 6is=(Byte[] data);
    private void 6ys=(Byte[] data);
}
public enum ThinkGeo.Core.PenBrushDrawingOrder : Enum {
    public int value__;
    public static PenBrushDrawingOrder BrushFirst;
    public static PenBrushDrawingOrder PenFirst;
}
public abstract class ThinkGeo.Core.PointBaseShape : BaseShape {
}
public abstract class ThinkGeo.Core.PointBaseStyle : Style {
    [ObfuscationAttribute]
private DrawingLevel drawingLevel;
    [ObfuscationAttribute]
private float rotationAngle;
    [ObfuscationAttribute]
private GeoPen symbolPen;
    [ObfuscationAttribute]
private float symbolSize;
    [ObfuscationAttribute]
private GeoBrush symbolBrush;
    [ObfuscationAttribute]
private float xOffsetInPixel;
    [ObfuscationAttribute]
private float yOffsetInPixel;
    [ObfuscationAttribute]
private Collection`1<PointBaseStyle> customPointStyles;
    public DrawingLevel DrawingLevel { get; public set; }
    public GeoBrush FillBrush { get; public set; }
    public GeoPen OutlinePen { get; public set; }
    public float SymbolSize { get; public set; }
    public float RotationAngle { get; public set; }
    public float XOffsetInPixel { get; public set; }
    public float YOffsetInPixel { get; public set; }
    public Collection`1<PointBaseStyle> CustomPointStyles { get; }
    protected PointBaseStyle(GeoBrush symbolBrush, int symbolSize);
    protected PointBaseStyle(GeoBrush symbolBrush, GeoPen symbolPen, int symbolSize);
    public DrawingLevel get_DrawingLevel();
    public void set_DrawingLevel(DrawingLevel value);
    public GeoBrush get_FillBrush();
    public void set_FillBrush(GeoBrush value);
    public GeoPen get_OutlinePen();
    public void set_OutlinePen(GeoPen value);
    public float get_SymbolSize();
    public void set_SymbolSize(float value);
    public float get_RotationAngle();
    public void set_RotationAngle(float value);
    public float get_XOffsetInPixel();
    public void set_XOffsetInPixel(float value);
    public float get_YOffsetInPixel();
    public void set_YOffsetInPixel(float value);
    public Collection`1<PointBaseStyle> get_CustomPointStyles();
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
}
public enum ThinkGeo.Core.PointLineRelationship : Enum {
    public int value__;
    public static PointLineRelationship Left;
    public static PointLineRelationship Right;
    public static PointLineRelationship OnLine;
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.PointShape : PointBaseShape {
    [ObfuscationAttribute]
private double x;
    [ObfuscationAttribute]
private double y;
    [ObfuscationAttribute]
private double z;
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Z { get; public set; }
    public PointShape(double x, double y);
    public PointShape(double x, double y, double z);
    public PointShape(Vertex vertex);
    public PointShape(string wellKnownText);
    public PointShape(Byte[] wellKnownBinary);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Z();
    public void set_Z(double value);
    public bool Equal2D(PointShape targetShape);
    public bool Equal2D(Feature targetPointFeature);
    protected virtual BaseShape CloneDeepCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    public MultilineShape GreatCircle(PointShape pointShape);
    public MultilineShape GreatCircle(Feature pointFeature);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetCenterPointCore();
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public virtual string ToString();
    protected virtual bool IsWithinCore(BaseShape targetShape);
    private double ZRw=(RingShape ringShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double Zhw=(MultipolygonShape multipolygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double Zxw=(MultipointShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double aBw=(MultilineShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double aRw=(LineShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double ahw=(RectangleShape rectangleShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double axw=(PointShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double bBw=(PolygonShape polygonShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    private double bRw=(PointShape toPointShape);
    internal double bhw=(double fromPointX, double fromPointY, double toPointX, double toPointY);
    internal PointShape bxw=(double fromX, double fromY, double toX, double toY);
    private PointShape cBw=(double offset, float degree);
}
public class ThinkGeo.Core.PointStyle : PointBaseStyle {
    private static int SSo=;
    private static int IxU=;
    private static int JRU=;
    private static int JhU=;
    private static int JxU=;
    private static int JBU=;
    private static double TCo=;
    private static int KhU=;
    private static int KBU=;
    private static int TSo=;
    private static int Tio=;
    private static int Ryo=;
    private static int SCo=;
    [ObfuscationAttribute]
private GeoFont glyphFont;
    [ObfuscationAttribute]
private GeoImage image;
    [ObfuscationAttribute]
private double imageScale;
    [ObfuscationAttribute]
private PointSymbolType symbolType;
    [ObfuscationAttribute]
private PointType pointType;
    [ObfuscationAttribute]
private AreaStyle mask;
    [ObfuscationAttribute]
private DrawingMargin maskMargin;
    [ObfuscationAttribute]
private MaskType maskType;
    [ObfuscationAttribute]
private string glyphContent;
    private static GeoFont KDE=;
    public PointType PointType { get; public set; }
    public GeoImage Image { get; public set; }
    public double ImageScale { get; public set; }
    public GeoFont GlyphFont { get; public set; }
    public string GlyphContent { get; public set; }
    public PointSymbolType SymbolType { get; public set; }
    public AreaStyle Mask { get; public set; }
    public DrawingMargin MaskMargin { get; public set; }
    public MaskType MaskType { get; public set; }
    internal bool ohU= { get; }
    public PointStyle(GeoImage image);
    public PointStyle(GeoFont glyphFont, string glyphContent, GeoBrush fillBrush);
    public PointStyle(GeoFont glyphFont, string glyphContent, GeoBrush fillBrush, GeoPen outlinePen);
    public PointStyle(PointSymbolType symbolType, int symbolSize, GeoBrush fillBrush);
    public PointStyle(PointSymbolType symbolType, int symbolSize, GeoBrush fillBrush, GeoPen outlinePen);
    private PointStyle(GeoImage image, GeoFont glyphFont, PointType pointType, PointSymbolType pointSymbolType, GeoBrush geoBrush, GeoPen symbolPen, int symbolSize);
    private static PointStyle();
    public PointType get_PointType();
    public void set_PointType(PointType value);
    public GeoImage get_Image();
    public void set_Image(GeoImage value);
    public double get_ImageScale();
    public void set_ImageScale(double value);
    public GeoFont get_GlyphFont();
    public void set_GlyphFont(GeoFont value);
    public string get_GlyphContent();
    public void set_GlyphContent(string value);
    public PointSymbolType get_SymbolType();
    public void set_SymbolType(PointSymbolType value);
    public AreaStyle get_Mask();
    public void set_Mask(AreaStyle value);
    public DrawingMargin get_MaskMargin();
    public void set_MaskMargin(DrawingMargin value);
    public MaskType get_MaskType();
    public void set_MaskType(MaskType value);
    public static PointStyle Parse(string styleJson);
    internal static PointStyle jxU=(JObject jObject);
    public static PointStyle CreateSimplePointStyle(PointSymbolType pointStyle, GeoColor fillColor, float size);
    public static PointStyle CreateSimplePointStyle(PointSymbolType pointStyle, GeoColor fillColor, GeoColor outlineColor, float outlineWidth, float size);
    public static PointStyle CreateSimplePointStyle(PointSymbolType pointStyle, GeoColor fillColor, GeoColor outlineColor, float size);
    public static PointStyle CreateSimpleCircleStyle(GeoColor fillColor, float size);
    public static PointStyle CreateSimpleCircleStyle(GeoColor fillColor, float size, GeoColor outlineColor, float outlineWidth);
    public static PointStyle CreateSimpleCircleStyle(GeoColor fillColor, float size, GeoColor outlineColor);
    public static PointStyle CreateSimpleSquareStyle(GeoColor fillColor, float size);
    public static PointStyle CreateSimpleSquareStyle(GeoColor fillColor, float size, GeoColor outlineColor);
    public static PointStyle CreateSimpleSquareStyle(GeoColor fillColor, float size, GeoColor outlineColor, float outlineWidth);
    public static PointStyle CreateSimpleStarStyle(GeoColor fillColor, float size);
    public static PointStyle CreateSimpleStarStyle(GeoColor fillColor, float size, GeoColor outlineColor);
    public static PointStyle CreateSimpleStarStyle(GeoColor fillColor, float size, GeoColor outlineColor, float outlineWidth);
    public static PointStyle CreateSimpleTriangleStyle(GeoColor fillColor, float size);
    public static PointStyle CreateSimpleTriangleStyle(GeoColor fillColor, float size, GeoColor outlineColor);
    public static PointStyle CreateSimpleTriangleStyle(GeoColor fillColor, float size, GeoColor outlineColor, float outlineWidth);
    public static PointStyle CreateCompoundCircleStyle(GeoColor fillColor1, float size1, GeoColor outlineColor1, float outlineWidth1, GeoColor fillColor2, float size2);
    public static PointStyle CreateCompoundCircleStyle(GeoColor fillColor1, float size1, GeoColor outlineColor1, float outlineWidth1, GeoColor fillColor2, float size2, GeoColor outlineColor2, float outlineWidth2);
    public static PointStyle CreateCompoundPointStyle(PointSymbolType pointStyle1, GeoColor fillColor1, GeoColor outlineColor1, float outlineWidth1, float size1, PointSymbolType pointStyle2, GeoColor fillColor2, GeoColor outlineColor2, float outlineWidth2, float size2);
    internal virtual bool oBU=();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    protected void DrawSymbol(PointSymbolType symbolType, Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen geoPen, float symbolSize, float rotationAngle);
    protected void DrawImage(GeoImage geoImage, Feature feature, GeoCanvas canvas, float symbolSize, float rotationAngle);
    private void XCo=(GeoImage image, PointShape point, GeoCanvas canvas, float symbolSize, float rotationAngle);
    private void EiE=(GeoCanvas canvas, float screenX, float screenY, float width, float height, float rotationAngle);
    protected void DrawGlyph(GeoFont glyphFont, string glyphConent, Feature pointFeature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen geoPen, float symbolSize, float rotationAngle);
    private PolygonShape KTE=(Vertex[] maskAreaVertexs, Vertex pivotLowerCenterPoint, double angle, bool isStraight);
    private void KjE=(GeoFont glyphFont, string glyphConent, PointShape point, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, float rotationAngle);
    private void ZSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float symbolSize, float rotationAngle);
    private void Wio=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float symbolSize, double rotationAngle);
    private void Yyo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float symbolSize, float rotationAngle);
    private void YSo=(Feature feature, GeoCanvas canvas, GeoPen geoPen, float symbolSize, float rotationAngle);
    private void KzE=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float symbolSize, float rotationAngle, Action`7<double, double, GeoCanvas, GeoPen, GeoBrush, double, double> drawAction);
    private int Xio=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, double symbolSize, double rotationAngle);
    private int Zio=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush, float symbolSize, float rotationAngle);
    private void LDE=(double centerWorldX, double centerWorldY, GeoCanvas canvas, GeoPen geoPen, GeoBrush fillBrush, double symbolSize, double rotationAngle);
    private void LTE=(double centerWorldX, double centerWorldY, GeoCanvas canvas, GeoPen geoPen, GeoBrush fillBrush, double symbolSize, double rotationAngle);
    private void LjE=(double centerWorldX, double centerWorldY, GeoCanvas canvas, GeoPen geoPen, GeoBrush fillBrush, double symbolSize, double rotationAngle, Double[] angles);
    private Byte[] LzE=(IEnumerable`1<PointShape> worldPoints);
    private int Yio=(Byte[] centerPointWkb, int startIndex, GeoCanvas canvas, GeoPen geoPen, float symbolSize, float rotationAngle);
    private bool aCo=(double screenX, double screenY, float canvasWidth, float canvasHeight);
    private static void gB0=(Byte[] sourceArray, Byte[] destinateArray, long destinateIndex);
    private static IEnumerable`1<Vertex> MDE=(Vertex startPoint, Vertex pivot, float radius);
    private static IEnumerable`1<Vertex> MTE=(Vertex startPoint, Vertex pivot, float radius);
    private static Vertex MjE=(Vertex startPoint, Vertex pivot, double angle, float radius);
    private static int ORU=(Byte[] wkb, int startIndex, byte byteOrder);
    private static double OhU=(Byte[] wkb, int startIndex, byte byteOrder);
    private static WkbShapeType MzE=(Byte[] wkb, int startIndex);
    private static GeoFont NDE=(String[] valueExpressions);
    private static GeoPen NTE=(String[] valueExpressions);
    private static GeoBrush NjE=(String[] valueExpressions);
    private static AreaStyle NzE=(String[] valueExpressions);
}
public enum ThinkGeo.Core.PointSymbolType : Enum {
    public int value__;
    public static PointSymbolType Circle;
    public static PointSymbolType Square;
    public static PointSymbolType Triangle;
    public static PointSymbolType Cross;
    public static PointSymbolType DiamondNarrow;
    public static PointSymbolType Diamond;
    public static PointSymbolType Star;
    public static PointSymbolType StarCircled;
    public static PointSymbolType CrossArrow;
    public static PointSymbolType BidirectionalArrow;
}
public enum ThinkGeo.Core.PointType : Enum {
    public int value__;
    public static PointType Symbol;
    public static PointType Image;
    public static PointType Glyph;
}
public enum ThinkGeo.Core.PolygonLabelingLocationMode : Enum {
    public int value__;
    public static PolygonLabelingLocationMode Default;
    public static PolygonLabelingLocationMode Centroid;
    public static PolygonLabelingLocationMode BoundingBoxCenter;
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.PolygonShape : AreaBaseShape {
    [ObfuscationAttribute]
private RingShape outerRing;
    [ObfuscationAttribute]
private Collection`1<RingShape> innerRings;
    public RingShape OuterRing { get; public set; }
    public Collection`1<RingShape> InnerRings { get; }
    public PolygonShape(RingShape outerRing);
    public PolygonShape(RingShape outerRing, IEnumerable`1<RingShape> innerRings);
    public PolygonShape(string wellKnownText);
    public PolygonShape(Byte[] wellKnownBinary);
    public RingShape get_OuterRing();
    public void set_OuterRing(RingShape value);
    public Collection`1<RingShape> get_InnerRings();
    protected virtual WellKnownType GetWellKnownTypeCore();
    protected virtual BaseShape CloneDeepCore();
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    public static bool RemoveVertex(Vertex selectedVertex, PolygonShape polygonShape);
    public bool RemoveVertex(Vertex selectedVertex);
    public MultilineShape ToMultiLineShape();
    internal void SRU=(double multiplicator);
    private static void Yhw=(RingShape targetRingShape, WkbByteOrder byteOrder, BinaryWriter writer);
    private static void YBw=(RingShape targetRingShape, WkbByteOrder byteOrder, BinaryWriter writer);
    private static void cRw=(RingShape ringShape, StringBuilder wellKnownText);
    private static void chw=(RingShape ringShape, StringBuilder wellKnownText);
    private static void cxw=(PolygonShape targetPolygon);
    private static void dBw=(PolygonShape fromPolygon, PolygonShape toPolygon);
    internal static MultilineShape dRw=(PolygonShape polygonShape);
    internal bool dhw=();
}
public abstract class ThinkGeo.Core.PositionStyle : Style {
    private static Regex ODE=;
    [ObfuscationAttribute]
private bool allowLineCarriage;
    [ObfuscationAttribute]
private bool allowSpline;
    [ObfuscationAttribute]
private WellKnownType currentShapeWellKnownType;
    [ObfuscationAttribute]
private Collection`1<TextStyle> customTextStyles;
    [ObfuscationAttribute]
private string dateFormat;
    [ObfuscationAttribute]
private DrawingLevel drawingLevel;
    [ObfuscationAttribute]
private bool fittingPolygon;
    [ObfuscationAttribute]
private double fittingPolygonFactor;
    [ObfuscationAttribute]
private GeoFont font;
    [ObfuscationAttribute]
private bool forceHorizontalLabelForLine;
    [ObfuscationAttribute]
private bool forceLineCarriage;
    [ObfuscationAttribute]
private PolygonLabelingLocationMode polygonLabelingLocationMode;
    [ObfuscationAttribute]
private int gridSize;
    [ObfuscationAttribute]
private GeoPen haloPen;
    [ObfuscationAttribute]
private bool labelAllPolygonParts;
    [ObfuscationAttribute]
private bool labelAllLineParts;
    [ObfuscationAttribute]
private LabelDuplicateRule duplicateRule;
    [ObfuscationAttribute]
private LabelOverlappingRule overlappingRule;
    [ObfuscationAttribute]
private bool allowLabelNudging;
    [ObfuscationAttribute]
private Dictionary`2<string, WorldLabelingCandidate> labelPositions;
    [ObfuscationAttribute]
private AreaStyle mask;
    [ObfuscationAttribute]
private double maxAdjacentCharDeltaAngle;
    [ObfuscationAttribute]
private DrawingMargin maskMargin;
    [ObfuscationAttribute]
private MaskType maskType;
    [ObfuscationAttribute]
private string numericFormat;
    [ObfuscationAttribute]
private TextPlacement textPlacement;
    [ObfuscationAttribute]
private bool fittingLineInScreen;
    [ObfuscationAttribute]
private bool fittingPolygonInScreen;
    [ObfuscationAttribute]
private double rotationAngle;
    [ObfuscationAttribute]
private SplineType splineType;
    [ObfuscationAttribute]
private bool suppressPartialLabels;
    [ObfuscationAttribute]
private string textColumnName;
    [ObfuscationAttribute]
private string textFormat;
    [ObfuscationAttribute]
private double textLineSegmentRatio;
    [ObfuscationAttribute]
private GeoBrush textBrush;
    [ObfuscationAttribute]
private float xOffsetInPixel;
    [ObfuscationAttribute]
private float yOffsetInPixel;
    [ObfuscationAttribute]
private int maxNudgingInPixel;
    [ObfuscationAttribute]
private float nudgingIntervalInPixel;
    [ObfuscationAttribute]
private Dictionary`2<string, string> abbreviationDictionary;
    [ObfuscationAttribute]
private float bestPlacementSymbolWidth;
    [ObfuscationAttribute]
private float bestPlacementSymbolHeight;
    [ObfuscationAttribute]
private LineStyle leaderLineStyle;
    [ObfuscationAttribute]
private LabelLeaderLinesRule leaderLineRule;
    [ObfuscationAttribute]
private float leaderLineMinimumLengthInPixels;
    [ObfuscationAttribute]
private DrawingTextAlignment alignment;
    [ObfuscationAttribute]
private DrawingTextLetterCase letterCase;
    [ObfuscationAttribute]
private double maxCharAngleDelta;
    [ObfuscationAttribute]
private double minDistance;
    [ObfuscationAttribute]
private double spacing;
    [ObfuscationAttribute]
private double wrapWidth;
    [ObfuscationAttribute]
private PointStyle basePoint;
    [ObfuscationAttribute]
private string textContent;
    [ObfuscationAttribute]
private String[] tempColumnNames;
    [ObfuscationAttribute]
private bool isSplinedText;
    [ObfuscationAttribute]
private double textLetterSpacing;
    [ObfuscationAttribute]
private DrawingTextBaseline textBaseline;
    [ObfuscationAttribute]
private float textLineSpacing;
    [ObfuscationAttribute]
private bool allowOverlapping;
    [ObfuscationAttribute]
private bool drawBasePointWithoutText;
    [ObfuscationAttribute]
private bool isStyleJsonStyle;
    [CompilerGeneratedAttribute]
private EventHandler`1<FormattingPositionStyleEventArgs> OTE=;
    [CompilerGeneratedAttribute]
private EventHandler`1<FormattedPositionStyleEventArgs> OjE=;
    [ObfuscationAttribute]
private ConcurrentDictionary`2<string, DrawingRectangleF> _cachedCharSize;
    protected Dictionary`2<string, WorldLabelingCandidate> LabelPositions { get; }
    public PolygonLabelingLocationMode PolygonLabelingLocationMode { get; public set; }
    public int MaxNudgingInPixel { get; public set; }
    public float NudgingIntervalInPixel { get; public set; }
    public float BestPlacementSymbolWidth { get; public set; }
    public float BestPlacementSymbolHeight { get; public set; }
    public Dictionary`2<string, string> AbbreviationDictionary { get; public set; }
    public LineStyle LeaderLineStyle { get; public set; }
    public LabelLeaderLinesRule LeaderLineRule { get; public set; }
    public float LeaderLineMinimumLengthInPixels { get; public set; }
    protected float XOffsetInPixel { get; protected set; }
    protected float YOffsetInPixel { get; protected set; }
    public int GridSize { get; public set; }
    protected Collection`1<TextStyle> CustomTextStyles { get; }
    protected double RotationAngle { get; protected set; }
    protected bool FittingLineInScreen { get; protected set; }
    protected bool FittingPolygonInScreen { get; protected set; }
    protected string TextFormat { get; protected set; }
    protected string NumericFormat { get; protected set; }
    protected string DateFormat { get; protected set; }
    protected GeoBrush TextBrush { get; protected set; }
    protected GeoFont Font { get; protected set; }
    protected GeoPen HaloPen { get; protected set; }
    protected string TextColumnName { get; protected set; }
    protected AreaStyle Mask { get; protected set; }
    protected DrawingMargin MaskMargin { get; protected set; }
    public LabelDuplicateRule DuplicateRule { get; public set; }
    public LabelOverlappingRule OverlappingRule { get; public set; }
    public bool AllowLabelNudging { get; public set; }
    protected bool AllowSpline { get; protected set; }
    public bool AllowLineCarriage { get; public set; }
    public bool SuppressPartialLabels { get; public set; }
    public bool ForceLineCarriage { get; public set; }
    public bool FittingPolygon { get; public set; }
    public bool LabelAllPolygonParts { get; public set; }
    public bool LabelAllLineParts { get; public set; }
    protected bool ForceHorizontalLabelForLine { get; protected set; }
    public double FittingPolygonFactor { get; public set; }
    public double TextLineSegmentRatio { get; public set; }
    public TextPlacement TextPlacement { get; public set; }
    protected SplineType SplineType { get; protected set; }
    protected DrawingLevel DrawingLevel { get; protected set; }
    internal bool ohU= { get; }
    public MaskType MaskType { get; public set; }
    protected DrawingTextAlignment Alignment { get; protected set; }
    protected DrawingTextLetterCase LetterCase { get; protected set; }
    protected double MaxCharAngleDelta { get; protected set; }
    protected double MinDistance { get; protected set; }
    protected double Spacing { get; protected set; }
    protected double WrapWidth { get; protected set; }
    protected PointStyle BasePoint { get; protected set; }
    internal bool PTE= { get; internal set; }
    public string TextContent { get; public set; }
    internal double QDE= { get; internal set; }
    internal DrawingTextBaseline QzE= { get; internal set; }
    internal float RjE= { get; internal set; }
    internal bool STE= { get; internal set; }
    internal bool TDE= { get; internal set; }
    public double MaxAdjacentCharDeltaAngle { get; public set; }
    private static PositionStyle();
    [CompilerGeneratedAttribute]
public void add_Formatting(EventHandler`1<FormattingPositionStyleEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Formatting(EventHandler`1<FormattingPositionStyleEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Formatted(EventHandler`1<FormattedPositionStyleEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Formatted(EventHandler`1<FormattedPositionStyleEventArgs> value);
    protected Dictionary`2<string, WorldLabelingCandidate> get_LabelPositions();
    public PolygonLabelingLocationMode get_PolygonLabelingLocationMode();
    public void set_PolygonLabelingLocationMode(PolygonLabelingLocationMode value);
    public int get_MaxNudgingInPixel();
    public void set_MaxNudgingInPixel(int value);
    public float get_NudgingIntervalInPixel();
    public void set_NudgingIntervalInPixel(float value);
    public float get_BestPlacementSymbolWidth();
    public void set_BestPlacementSymbolWidth(float value);
    public float get_BestPlacementSymbolHeight();
    public void set_BestPlacementSymbolHeight(float value);
    public Dictionary`2<string, string> get_AbbreviationDictionary();
    public void set_AbbreviationDictionary(Dictionary`2<string, string> value);
    public LineStyle get_LeaderLineStyle();
    public void set_LeaderLineStyle(LineStyle value);
    public LabelLeaderLinesRule get_LeaderLineRule();
    public void set_LeaderLineRule(LabelLeaderLinesRule value);
    public float get_LeaderLineMinimumLengthInPixels();
    public void set_LeaderLineMinimumLengthInPixels(float value);
    protected float get_XOffsetInPixel();
    protected void set_XOffsetInPixel(float value);
    protected float get_YOffsetInPixel();
    protected void set_YOffsetInPixel(float value);
    public int get_GridSize();
    public void set_GridSize(int value);
    protected Collection`1<TextStyle> get_CustomTextStyles();
    protected double get_RotationAngle();
    protected void set_RotationAngle(double value);
    protected bool get_FittingLineInScreen();
    protected void set_FittingLineInScreen(bool value);
    protected bool get_FittingPolygonInScreen();
    protected void set_FittingPolygonInScreen(bool value);
    protected string get_TextFormat();
    protected void set_TextFormat(string value);
    protected string get_NumericFormat();
    protected void set_NumericFormat(string value);
    protected string get_DateFormat();
    protected void set_DateFormat(string value);
    protected GeoBrush get_TextBrush();
    protected void set_TextBrush(GeoBrush value);
    protected GeoFont get_Font();
    protected void set_Font(GeoFont value);
    protected GeoPen get_HaloPen();
    protected void set_HaloPen(GeoPen value);
    protected string get_TextColumnName();
    protected void set_TextColumnName(string value);
    protected AreaStyle get_Mask();
    protected void set_Mask(AreaStyle value);
    protected DrawingMargin get_MaskMargin();
    protected void set_MaskMargin(DrawingMargin value);
    public LabelDuplicateRule get_DuplicateRule();
    public void set_DuplicateRule(LabelDuplicateRule value);
    public LabelOverlappingRule get_OverlappingRule();
    public void set_OverlappingRule(LabelOverlappingRule value);
    public bool get_AllowLabelNudging();
    public void set_AllowLabelNudging(bool value);
    protected bool get_AllowSpline();
    protected void set_AllowSpline(bool value);
    public bool get_AllowLineCarriage();
    public void set_AllowLineCarriage(bool value);
    public bool get_SuppressPartialLabels();
    public void set_SuppressPartialLabels(bool value);
    public bool get_ForceLineCarriage();
    public void set_ForceLineCarriage(bool value);
    public bool get_FittingPolygon();
    public void set_FittingPolygon(bool value);
    public bool get_LabelAllPolygonParts();
    public void set_LabelAllPolygonParts(bool value);
    public bool get_LabelAllLineParts();
    public void set_LabelAllLineParts(bool value);
    protected bool get_ForceHorizontalLabelForLine();
    protected void set_ForceHorizontalLabelForLine(bool value);
    public double get_FittingPolygonFactor();
    public void set_FittingPolygonFactor(double value);
    public double get_TextLineSegmentRatio();
    public void set_TextLineSegmentRatio(double value);
    public TextPlacement get_TextPlacement();
    public void set_TextPlacement(TextPlacement value);
    protected SplineType get_SplineType();
    protected void set_SplineType(SplineType value);
    protected DrawingLevel get_DrawingLevel();
    protected void set_DrawingLevel(DrawingLevel value);
    internal virtual bool oBU=();
    public MaskType get_MaskType();
    public void set_MaskType(MaskType value);
    protected DrawingTextAlignment get_Alignment();
    protected void set_Alignment(DrawingTextAlignment value);
    protected DrawingTextLetterCase get_LetterCase();
    protected void set_LetterCase(DrawingTextLetterCase value);
    protected double get_MaxCharAngleDelta();
    protected void set_MaxCharAngleDelta(double value);
    protected double get_MinDistance();
    protected void set_MinDistance(double value);
    protected double get_Spacing();
    protected void set_Spacing(double value);
    protected double get_WrapWidth();
    protected void set_WrapWidth(double value);
    protected PointStyle get_BasePoint();
    protected void set_BasePoint(PointStyle value);
    internal bool OzE=();
    internal void PDE=(bool value);
    public string get_TextContent();
    public void set_TextContent(string value);
    internal double PjE=();
    internal void PzE=(double value);
    internal DrawingTextBaseline QTE=();
    internal void QjE=(DrawingTextBaseline value);
    internal float RDE=();
    internal void RTE=(float value);
    internal bool RzE=();
    internal void SDE=(bool value);
    internal bool SjE=();
    internal void SzE=(bool value);
    public double get_MaxAdjacentCharDeltaAngle();
    public void set_MaxAdjacentCharDeltaAngle(double value);
    protected void DrawMask(LabelingCandidate labelingCandidate, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected internal Collection`1<Feature> FilterFeatures(IEnumerable`1<Feature> features, GeoCanvas canvas);
    protected virtual Collection`1<Feature> FilterFeaturesCore(IEnumerable`1<Feature> features, GeoCanvas canvas);
    protected void AbbreviateText(Feature feature, GeoCanvas canvas);
    protected virtual void AbbreviateTextCore(Feature feature, GeoCanvas canvas);
    protected Collection`1<LabelingCandidate> GetLabelingCandidates(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    protected virtual Collection`1<LabelingCandidate> GetLabelingCandidateCore(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private void TTE=(PointShape point, GeoFont font, GeoCanvas canvas, DrawingTextBaseline textBaseline, string text, double angle);
    internal DrawingRectangleF TjE=(GeoCanvas canvas, string text, GeoFont font);
    public string WrapText(string text, GeoFont font, GeoCanvas canvas);
    private string TzE=(string text);
    protected bool CheckDuplicate(LabelingCandidate labelingCandidate, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual bool CheckDuplicateCore(LabelingCandidate labelingCandidate, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static bool UDE=(Collection`1<SimpleCandidate> labelCandidates, LabelingCandidate currentLabelCandidate);
    private static bool UTE=(Collection`1<SimpleCandidate> labelCandidates, LabelingCandidate currentLabelCandidate, ScreenPointF ulPointF, ScreenPointF lrPointF);
    protected bool CheckOverlapping(LabelingCandidate labelingCandidate, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual bool CheckOverlappingCore(LabelingCandidate labelingCandidate, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected static BaseShape ConvertToScreenShape(Feature feature, GeoCanvas canvas);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    protected virtual Style CloneDeepCore();
    private bool UjE=(Collection`1<SimpleCandidate> labelInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayer, LabelingCandidate currentLabelCandidate);
    private ScreenPointF UzE=(PointShape point);
    private FeatureLabelingCandidate VDE=(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private ScreenPointF[] VTE=(ScreenPointF[] textPathInScreen, DrawingTextAlignment alignment, double drawingRectangleWidth, float drawingTextWidth, int drawingTextLinesCount);
    private Collection`1<LabelingCandidate> VjE=(MultilineShape multilineShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> VzE=(MultilineShape multiLineShape, EDE= lineLabelAdjuster, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, GeoCanvas canvas, RectangleShape screenExtent, bool allowLineLabelingMoving);
    private Collection`1<LabelingCandidate> WDE=(MultilineShape multilineShape, EDE= lineLabelAdjuster, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, GeoCanvas canvas, string labelText, double width, double height, RectangleShape screenExtent, bool allowLineLabelingMoving);
    private ValueTuple`2<LineShape, LineShape> WTE=(LineShape lineShape);
    private LabelingCandidate WjE=(EDE= lineLabelAdjuster, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, string labelText, double width, double height);
    private float WzE=(GeoCanvas canvas);
    private Collection`1<LabelingCandidate> XDE=(MultilineShape multiLineShape, EDE= lineLabelAdjuster, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, GeoCanvas canvas, RectangleShape screenExtent, bool allowLineLabelingMoving);
    private Collection`1<LabelingCandidate> XTE=(MultilineShape multiLineShape, EDE= lineLabelAdjuster, GeoCanvas canvas, string text, string labelText, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle, double width, double height, RectangleShape screenExtent, bool allowLineLabelingMoving);
    private LabelingCandidate XjE=(EDE= lineLabelAdjuster, GeoCanvas canvas, string text, string labelText, double width, double height, double xOffsetInPixel, double yOffsetInPixel);
    private Collection`1<LabelingCandidate> XzE=(MultilineShape multilineShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> YDE=(LineShape lineShape, double labelWidth, double lineLength, string text, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private Collection`1<LabelingCandidate> YTE=(LineShape lineShape, double labelWidth, double lineLength, string text, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private static StartingPoint YjE=(StartingPoint startingPoint);
    private LabelingCandidate XzE=(LineShape lineShape, double lineLength, string text, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel);
    private static ValueTuple`2<PointShape, double> YzE=(PointShape centerPointForLabel, IGeoCanvasRotatable rotatableGeoCanvas, double angle);
    private static Collection`1<LabelInformation> ZDE=(string text, Collection`1<LabelInformation> labelInformationCollection, IGeoCanvasRotatable rotatableGeoCanvas);
    private static double ZTE=(double angle, double canvasRotationAngle);
    private static bool ZjE=(double angle);
    private DrawingRectangleF ZzE=(GeoCanvas canvas, GeoFont font, char centerText);
    private PolygonShape aDE=(string text, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, DrawingRectangleF firstSize, PointShape firstPoint, PointShape secondPoint, double firstAngle, PointShape& centerPointForLabel);
    private Collection`1<DrawingRectangleF> aTE=(string labelText, GeoCanvas canvas, GeoFont font);
    private LabelingCandidate ajE=(Collection`1<PointShape> coordinates, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas);
    private bool azE=(Collection`1<PointShape> coordinates, double maxCharAngle);
    private double bDE=(Vertex start, Vertex middle, Vertex end);
    private LabelingCandidate XzE=(Collection`1<PointShape> coordinates, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas);
    private static bool bTE=(AreaBaseShape firstPolygon, AreaBaseShape secondPolygon);
    private static float bjE=(PolygonShape rectangleA, double angleA, PolygonShape rectangleB, double angleB);
    private static EDE= bzE=(MultilineShape multilineShape, RectangleShape screenExtent, bool allowLineLabelingMoving, double rotateAngle);
    private static PolygonShape cDE=(MultipolygonShape multipolygonShape, RectangleShape screenExtent);
    private Collection`1<LabelingCandidate> cTE=(MultipointShape multipoint, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private LabelingCandidate cjE=(PointShape point, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private LabelingCandidate czE=(PointShape point, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private LabelingCandidate dDE=(PointShape point, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas);
    private Collection`1<LabelingCandidate> dTE=(MultilineShape multilineShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> djE=(MultilineShape multilineShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> dzE=(MultilineShape multilineShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private static LineShape eDE=(MultilineShape multilineShape);
    private Collection`1<LabelingCandidate> eTE=(LineShape line, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> ejE=(MultipolygonShape multipolygonShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> ezE=(Feature feature, GeoCanvas canvas, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, double rotationAngle);
    private Collection`1<LabelingCandidate> fDE=(MultipolygonShape multipolygonShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    internal LabelingCandidate fTE=(PolygonShape polygon, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private Collection`1<LabelingCandidate> fjE=(MultipolygonShape multipolygonShape, string text, GeoFont font, float xOffsetInPixel, float yOffsetInPixel, GeoCanvas canvas, double rotationAngle);
    private static double fzE=(Vertex fromVertex, Vertex toVertex);
    private static double HzE=(Vertex fromVertex, Vertex toVertex);
    private static double gDE=(Vertex fromVertex, Vertex toVertex);
    private String[] gTE=(PolygonShape polygon, string text, GeoFont font, GeoCanvas canvas);
    private static String[] gjE=(string text);
    private static PointShape gzE=(Vertex fromVertex, Vertex toVertex);
    private static PointShape hDE=(PointShape fromVertex, PointShape toVertex);
    private static PointShape hTE=(PointShape point, double distance, double angle);
    private PointShape hjE=(PolygonShape polygon);
    private static PointShape hzE=(PointShape upperLeftPoint, double width, double height, TextPlacement placementOfPoint);
    private PointShape iDE=(ScreenPointF centerPointBePlacemented, double width, double height, TextPlacement placementOfLabel, float xOffsetInPixel, float yOffsetInPixel, float canvasDpi, float canvasScaleFactor);
    private static PolygonShape iTE=(MultipolygonShape multipolygonShape);
    private PolygonShape ijE=(PointShape lowerLeftPoint, double width, double height);
    private PolygonShape izE=(PointShape upperCenterPoint, double width, double height, double angle);
    private PolygonShape jDE=(PointShape lowerCenterPoint, double width, double height, double angle);
    private PolygonShape KTE=(Vertex[] maskAreaVertexs, Vertex pivotLowerCenterPoint, double angle, bool isStraight);
    private static IEnumerable`1<Vertex> MDE=(Vertex startPoint, Vertex pivot, float radius);
    private static IEnumerable`1<Vertex> MTE=(Vertex startPoint, Vertex pivot, float radius);
    private static Vertex MjE=(Vertex startPoint, Vertex pivot, double angle, float radius);
    private LabelInformation jTE=(string text, double height, PointShape centerPoint, double yOffset, double rotationAngle);
    private static BaseShape gR0=(Feature feature, GeoCanvas canvas);
    private static BaseShape gh0=(Feature feature, GeoCanvas canvas);
    private static BaseShape gx0=(Feature feature, GeoCanvas canvas);
    private static BaseShape hB0=(Feature feature, GeoCanvas canvas);
    private static BaseShape hR0=(Feature feature, GeoCanvas canvas);
    private static BaseShape hh0=(Feature feature, GeoCanvas canvas);
    private static BaseShape hx0=(Feature feature, GeoCanvas canvas);
    private static PointShape iB0=(Byte[] wellKnownBinary, Int32& startIndex, GeoCanvas canvas);
    private static PolygonShape iR0=(Byte[] wellKnownBinary, Int32& startIndex, GeoCanvas canvas);
    private static LineShape ih0=(Byte[] wellKnownBinary, Int32& startIndex, GeoCanvas canvas);
    private static TextPlacement jjE=(int index, TextPlacement baseOfPointPlacement);
    protected string Format(string text, BaseShape labeledShape);
    protected virtual string FormatCore(string text, BaseShape labeledShape);
    private static string jzE=(string text);
    protected virtual void OnFormatting(FormattingPositionStyleEventArgs e);
    protected virtual void OnFormatted(FormattedPositionStyleEventArgs e);
    private static void kDE=(LabelingCandidate sourceLabelingCandidate, LabelingCandidate destinateLabelingCandidate);
    private static double ix0=(Byte[] bytes, int startIndex, byte byteOrder);
    private static int jB0=(Byte[] bytes, int startIndex, byte byteOrder);
    private bool eRw=(PolygonShape polygon01, PolygonShape polygon02, bool isInThisLayer);
    private bool eRw=(RectangleShape rectangle01, RectangleShape rectangle02);
    private RectangleShape kTE=(PolygonShape polygon, bool isInThisLayer);
    private static PointShape kjE=(PolygonShape polygon);
    private static bool kzE=(PolygonShape polygon, PointShape point, RectangleShape boundingBox);
    private static bool kzE=(PolygonShape polygon, double pointX, double pointY, RectangleShape boundingBox);
    private static void lDE=(Collection`1<Vertex> crossingPoints, RingShape ringShape, double pointX, double pointY, double secondLineEndPointX);
    private static Vertex lTE=(Vertex startPoint, Vertex endPoint, double secondLineStartX, double secondLineStartY, double secondLineEndPointX);
    private static bool ljE=(Collection`1<Vertex> crossingPoints, Vertex vertex);
    private static bool JTE=(double value, double start, double end);
    private static bool lzE=(Vertex vertex);
    private static MultilineShape ITE=(LineShape line, RectangleShape rectangle);
    private static LineShape IzE=(Vertex startPoint, Vertex endPoint, RectangleShape rectangle);
    private static Vertex JDE=(Vertex startPoint, Vertex endPoint, RectangleShape rectangle);
    internal void mDE=(FeatureLabelingCandidate featureLabelingCandidate, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    internal Collection`1<FeatureLabelingCandidate> mTE=(IEnumerable`1<Feature> features, GeoCanvas canvas);
    private Collection`1<FeatureLabelingCandidate> mjE=(IEnumerable`1<Feature> features, GeoCanvas canvas);
}
internal enum ThinkGeo.Core.PrimitiveTypeCode : Enum {
    public int value__;
    public static PrimitiveTypeCode Empty;
    public static PrimitiveTypeCode Object;
    public static PrimitiveTypeCode Char;
    public static PrimitiveTypeCode CharNullable;
    public static PrimitiveTypeCode Boolean;
    public static PrimitiveTypeCode BooleanNullable;
    public static PrimitiveTypeCode SByte;
    public static PrimitiveTypeCode SByteNullable;
    public static PrimitiveTypeCode Int16;
    public static PrimitiveTypeCode Int16Nullable;
    public static PrimitiveTypeCode UInt16;
    public static PrimitiveTypeCode UInt16Nullable;
    public static PrimitiveTypeCode Int32;
    public static PrimitiveTypeCode Int32Nullable;
    public static PrimitiveTypeCode Byte;
    public static PrimitiveTypeCode ByteNullable;
    public static PrimitiveTypeCode UInt32;
    public static PrimitiveTypeCode UInt32Nullable;
    public static PrimitiveTypeCode Int64;
    public static PrimitiveTypeCode Int64Nullable;
    public static PrimitiveTypeCode UInt64;
    public static PrimitiveTypeCode UInt64Nullable;
    public static PrimitiveTypeCode Single;
    public static PrimitiveTypeCode SingleNullable;
    public static PrimitiveTypeCode Double;
    public static PrimitiveTypeCode DoubleNullable;
    public static PrimitiveTypeCode DateTime;
    public static PrimitiveTypeCode DateTimeNullable;
    public static PrimitiveTypeCode DateTimeOffset;
    public static PrimitiveTypeCode DateTimeOffsetNullable;
    public static PrimitiveTypeCode Decimal;
    public static PrimitiveTypeCode DecimalNullable;
    public static PrimitiveTypeCode Guid;
    public static PrimitiveTypeCode GuidNullable;
    public static PrimitiveTypeCode TimeSpan;
    public static PrimitiveTypeCode TimeSpanNullable;
    public static PrimitiveTypeCode BigInteger;
    public static PrimitiveTypeCode BigIntegerNullable;
    public static PrimitiveTypeCode Uri;
    public static PrimitiveTypeCode String;
    public static PrimitiveTypeCode Bytes;
    public static PrimitiveTypeCode DBNull;
}
public enum ThinkGeo.Core.PrinterDragMode : Enum {
    public int value__;
    public static PrinterDragMode Fixed;
    public static PrinterDragMode Draggable;
}
internal static class ThinkGeo.Core.PrinterHelper : object {
    private static double feetPerMeter;
    public static double ConvertLength(double length, PrintingUnit fromUnit, PrintingUnit toUnit);
    public static double GetPointsPerGeographyUnit(GeographyUnit mapUnit);
}
public abstract class ThinkGeo.Core.PrinterLayer : Layer {
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private AreaStyle backgroundMask;
    [ObfuscationAttribute]
private PrinterResizeMode resizeMode;
    [ObfuscationAttribute]
private PrinterDragMode dragMode;
    [ObfuscationAttribute]
private PrinterLayerSelectabilityMode selectabilityMode;
    [ObfuscationAttribute]
private bool isDrawing;
    [ObfuscationAttribute]
private RectangleShape lastBoundingBox;
    [ObfuscationAttribute]
private bool isResizing;
    public bool IsDrawing { get; public set; }
    public bool HasBoundingBox { get; }
    public AreaStyle BackgroundMask { get; public set; }
    public PrinterResizeMode ResizeMode { get; public set; }
    public PrinterDragMode DragMode { get; public set; }
    public bool IsResizing { get; public set; }
    public PrinterLayerSelectabilityMode SelectabilityMode { get; public set; }
    public bool get_IsDrawing();
    public void set_IsDrawing(bool value);
    public virtual bool get_HasBoundingBox();
    public AreaStyle get_BackgroundMask();
    public void set_BackgroundMask(AreaStyle value);
    public PrinterResizeMode get_ResizeMode();
    public void set_ResizeMode(PrinterResizeMode value);
    public PrinterDragMode get_DragMode();
    public void set_DragMode(PrinterDragMode value);
    public bool get_IsResizing();
    public void set_IsResizing(bool value);
    public PrinterLayerSelectabilityMode get_SelectabilityMode();
    public void set_SelectabilityMode(PrinterLayerSelectabilityMode value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual RectangleShape GetBoundingBoxCore();
    public RectangleShape GetDynamicBoundingBox();
    protected virtual RectangleShape GetDynamicBoundingBoxCore();
    public RectangleShape GetPosition();
    public RectangleShape GetPosition(PrintingUnit unit);
    protected virtual RectangleShape GetPositionCore(PrintingUnit unit);
    public void SetPosition(RectangleShape boundingBox);
    public void SetPosition(RectangleShape boundingBox, PrintingUnit unit);
    public void SetPosition(double width, double height, PointShape centerPoint, PrintingUnit unit);
    public void SetPosition(double width, double height, double centerPointX, double centerPointY, PrintingUnit unit);
    public void SetPosition(double width, double height, LayerAnchorLocation corner, PointShape cornerPoint, PrintingUnit unit);
    public void SetPosition(double width, double height, LayerAnchorLocation corner, double cornerPointX, double cornerPointY, PrintingUnit unit);
    protected virtual RectangleShape SetPositionCore(double width, double height, double centerPointX, double centerPointY, PrintingUnit unit);
    private RectangleShape biA=(RectangleShape newBoundingBox);
    private RectangleShape byA=(RectangleShape newBoundingBox, bool maintainAspectRatio, bool dragable);
    private static bool khU=(PointShape point1, PointShape point2);
}
public enum ThinkGeo.Core.PrinterLayerSelectabilityMode : Enum {
    public int value__;
    public static PrinterLayerSelectabilityMode Selectable;
    public static PrinterLayerSelectabilityMode NonSelectable;
}
public enum ThinkGeo.Core.PrinterResizeMode : Enum {
    public int value__;
    public static PrinterResizeMode Fixed;
    public static PrinterResizeMode MaintainAspectRatio;
    public static PrinterResizeMode Resizable;
}
public enum ThinkGeo.Core.PrintingUnit : Enum {
    public int value__;
    public static PrintingUnit Millimeter;
    public static PrintingUnit Inch;
    public static PrintingUnit Meter;
    public static PrintingUnit Centimeter;
    public static PrintingUnit Point;
}
public class ThinkGeo.Core.Projection : object {
    [ObfuscationAttribute]
private string projString;
    [ObfuscationAttribute]
private int srid;
    private static object mBo=;
    private static Dictionary`2<string, ProjectionConverter> mRo=;
    private static object jxY=;
    public int Srid { get; public set; }
    public string ProjString { get; public set; }
    public Projection(int srid);
    public Projection(string projString);
    private static Projection();
    public int get_Srid();
    public void set_Srid(int value);
    public string get_ProjString();
    public void set_ProjString(string value);
    public GeographyUnit GetUnit();
    public static string GetProjStringByEpsgSrid(int srid);
    public static int GetEpsgSridByProjString(string projString);
    public static string GetProjStringByEsriSrid(int srid);
    public static int GetEsriSridByProjString(string projString);
    public static string GetWgs84ProjString();
    public static string GetLatLongProjString();
    public static string GetDecimalDegreesProjString();
    public static string GetGoogleMapProjString();
    public static string GetBingMapProjString();
    public static string GetSphericalMercatorProjString();
    public static string GetLocalUtmZoneProjString(double latitude, double longitude);
    public static string GetLocalUtmZoneProjString(Feature feature, string projString);
    public static string GetLocalUtmZoneProjString(Feature feature, int srid);
    public static string GetLocalUtmZoneProjString(BaseShape shape, Projection projection);
    public static string GetLocalUtmZoneProjString(BaseShape shape, string projString);
    public static string GetLocalUtmZoneProjString(BaseShape shape, int srid);
    public static int GetLocalUtmZoneNumber(double latitude, double longitude);
    public static int GetLocalUtmZoneNumber(Feature feature, string projString);
    public static int GetLocalUtmZoneNumber(Feature feature, int srid);
    public static int GetLocalUtmZoneNumber(BaseShape shape, string projString);
    public static int GetLocalUtmZoneNumber(BaseShape shape, int srid);
    public static GeographyUnit GetGeographyUnitFromWkb(string wkt);
    public static GeographyUnit GetGeographyUnitFromProj(string projString);
    public static string ConvertEpsgToWkt(int srid);
    public static string ConvertProjStringToWkt(string projString);
    public static string ConvertWktToProjString(string wkt);
    private static int mho=(double latitude, double longitude);
    public static string ConvertEpsgToProjString(int srid);
    public static int ConvertProjStringToEpsg(string projString);
    private static string mxo=(string srid, Byte[] fileBuffer);
    private static int nBo=(string projString, Byte[] fileBuffer);
    public static GeographyUnit GetGeographyUnit(int srid);
    public static GeographyUnit GetGeographyUnit(string projString);
    private static ProjectionConverter nRo=(string proj4ProjectionParameters);
}
public class ThinkGeo.Core.ProjectionCloudClient : CloudClient {
    public ProjectionCloudClient(string clientId, string clientSecret);
    public Feature Project(Feature feature, int fromProjectionInSrid, int toProjectionInSrid);
    public Feature Project(Feature feature, int fromProjectionInSrid, string toProjectionInProj4String);
    public Feature Project(Feature feature, string fromProjectionInProj4String, int toProjectionInSrid);
    public Feature Project(Feature feature, string fromProjectionInProj4String, string toProjectionInProj4String);
    public Task`1<Feature> ProjectAsync(Feature feature, int fromProjectionInSrid, int toProjectionInSrid);
    public Task`1<Feature> ProjectAsync(Feature feature, int fromProjectionInSrid, string toProjectionInProj4String);
    public Task`1<Feature> ProjectAsync(Feature feature, string fromProjectionInProj4String, int toProjectionInSrid);
    public Task`1<Feature> ProjectAsync(Feature feature, string fromProjectionInProj4String, string toProjectionInProj4String);
    public Collection`1<Feature> Project(IEnumerable`1<Feature> features, int fromProjectionInSrid, int toProjectionInSrid);
    public Collection`1<Feature> Project(IEnumerable`1<Feature> features, int fromProjectionInSrid, string toProjectionInProj4String);
    public Collection`1<Feature> Project(IEnumerable`1<Feature> features, string fromProjectionInProj4String, int toProjectionInSrid);
    public Collection`1<Feature> Project(IEnumerable`1<Feature> features, string fromProjectionInProj4String, string toProjectionInProj4String);
    public Task`1<Collection`1<Feature>> ProjectAsync(IEnumerable`1<Feature> features, int fromProjectionInSrid, int toProjectionInSrid);
    public Task`1<Collection`1<Feature>> ProjectAsync(IEnumerable`1<Feature> features, int fromProjectionInSrid, string toProjectionInProj4String);
    public Task`1<Collection`1<Feature>> ProjectAsync(IEnumerable`1<Feature> features, string fromProjectionInProj4String, int toProjectionInSrid);
    public Task`1<Collection`1<Feature>> ProjectAsync(IEnumerable`1<Feature> features, string fromProjectionInProj4String, string toProjectionInProj4String);
    private Feature 8xQ=(Feature feature, string fromProjectionInProj4String, string toProjectionInProj4String);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ProjectionCloudClient/YD4=")]
private Task`1<Feature> 9BQ=(Feature feature, string fromProjectionInProj4String, string toProjectionInProj4String);
    private Collection`1<Feature> 8xQ=(IEnumerable`1<Feature> features, string fromProjectionInProj4String, string toProjectionInProj4String);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ProjectionCloudClient/ZD4=")]
private Task`1<Collection`1<Feature>> 9BQ=(IEnumerable`1<Feature> features, string fromProjectionInProj4String, string toProjectionInProj4String);
    private static Feature 9RQ=(WebResponse response);
    private static Collection`1<Feature> 9hQ=(WebResponse response);
}
public class ThinkGeo.Core.ProjectionConverter : object {
    private iBo= nho=;
    private iBo= nxo=;
    [ObfuscationAttribute]
private static int positionByteOrder;
    private bool oBo=;
    [ObfuscationAttribute]
private bool canConvertRasterToExternalProjection;
    [ObfuscationAttribute]
private RectangleShape decimalDegreeBoundary;
    [ObfuscationAttribute]
private RectangleShape sphecicalMercatorBoundary;
    private gBg= oRo=;
    [CompilerGeneratedAttribute]
private Projection oho=;
    [CompilerGeneratedAttribute]
private Projection oxo=;
    public RectangleShape DecimalDegreeBoundary { get; public set; }
    public Projection InternalProjection { get; public set; }
    public Projection ExternalProjection { get; public set; }
    public bool IsOpen { get; protected set; }
    public bool CanConvertRasterToExternalProjection { get; protected set; }
    public GeographyUnit InternalProjectionUnit { get; }
    public ProjectionConverter(string internalProjString, string externalProjString);
    public ProjectionConverter(int internalSrid, int externalSrid);
    public ProjectionConverter(string internalProjString, int externalSrid);
    public ProjectionConverter(int internalSridString, string externalProjString);
    public ProjectionConverter(Projection internalProjection, Projection externalProjection);
    public RectangleShape get_DecimalDegreeBoundary();
    public void set_DecimalDegreeBoundary(RectangleShape value);
    [CompilerGeneratedAttribute]
public Projection get_InternalProjection();
    [CompilerGeneratedAttribute]
public void set_InternalProjection(Projection value);
    [CompilerGeneratedAttribute]
public Projection get_ExternalProjection();
    [CompilerGeneratedAttribute]
public void set_ExternalProjection(Projection value);
    public bool get_IsOpen();
    protected void set_IsOpen(bool value);
    public bool get_CanConvertRasterToExternalProjection();
    protected void set_CanConvertRasterToExternalProjection(bool value);
    public virtual GeographyUnit get_InternalProjectionUnit();
    public void Open();
    public RasterProjectionResult ConvertToExternalProjection(GeoImage image, RectangleShape imageExtent, RectangleShape targetExtent, int width, int height);
    public RasterProjectionResult ConvertToExternalProjection(GeoImage image, RectangleShape imageExtent);
    public RasterProjectionResult ConvertToExternalProjection(GeoImage image, RectangleShape imageExtent, RectangleShape targetExtent);
    protected virtual RasterProjectionResult ConvertToExternalProjectionCore(GeoImage image, RectangleShape imageExtent, RectangleShape targetExtent, int width, int height);
    protected virtual void OpenCore();
    [OnGeodeserializedAttribute]
private void pBo=();
    public void Close();
    protected virtual void CloseCore();
    public Vertex ConvertToExternalProjection(double x, double y);
    public BaseShape ConvertToExternalProjection(BaseShape baseShape);
    public Feature ConvertToExternalProjection(Feature feature);
    public Collection`1<Feature> ConvertToExternalProjection(IEnumerable`1<Feature> features);
    internal void pRo=(Feature feature);
    public RectangleShape ConvertToExternalProjection(RectangleShape rectangleShape);
    protected virtual Collection`1<Vertex> ConvertToExternalProjectionCore(IEnumerable`1<Vertex> verticies);
    public Collection`1<Vertex> ConvertToExternalProjection(IEnumerable`1<Vertex> vertices);
    public Vertex ConvertToInternalProjection(double x, double y);
    public BaseShape ConvertToInternalProjection(BaseShape baseShape);
    public Feature ConvertToInternalProjection(Feature feature);
    public Collection`1<Vertex> ConvertToInternalProjection(IEnumerable`1<Vertex> vertices);
    public RectangleShape ConvertToInternalProjection(RectangleShape rectangleShape);
    protected virtual Collection`1<Vertex> ConvertToInternalProjectionCore(IEnumerable`1<Vertex> verticies);
    internal void pho=(Feature feature);
    private static Collection`1<Vertex> pxo=(RectangleShape rectangleShape, int pointCountBySide);
    private RectangleShape qBo=(IEnumerable`1<Vertex> vertices);
    private Byte[] qRo=(Byte[] wellKnownBinary);
    private Byte[] qho=(Byte[] wellKnownBinary);
    private static WellKnownType qxo=(Byte[] wkb);
    private Byte[] rBo=(Byte[] wellKnownBinary);
    private Byte[] rRo=(Byte[] wellKnownBinary);
    private Byte[] rho=(Byte[] wellKnownBinary);
    private Byte[] rxo=(Byte[] wellKnownBinary);
    private Byte[] sBo=(Byte[] wellKnownBinary);
    private Byte[] sRo=(Byte[] wellKnownBinary);
    private Byte[] sho=(Byte[] wellKnownBinary);
    private Byte[] sxo=(Byte[] wellKnownBinary);
    private Byte[] tBo=(Byte[] wellKnownBinary);
    private Byte[] tRo=(Byte[] wellKnownBinary);
    private Byte[] tho=(Byte[] wellKnownBinary);
    private Byte[] txo=(Byte[] wellKnownBinary);
    private static int ORU=(Byte[] wkb, int startIndex, byte byteOrder);
    private static double OhU=(Byte[] wkb, int startIndex, byte byteOrder);
    private static Byte[] uBo=(double doubleValue, byte byteOrder);
    private Collection`1<Vertex> uRo=(IEnumerable`1<Vertex> verticies, iBo= sourceProjType, iBo= destinationProjType, bool isFromDegree, bool isToDegree);
    public static PointShape Convert(int fromSrid, int toSrid, PointShape sourcePoint);
    public static Feature Convert(int fromSrid, int toSrid, Feature feature);
    public static RectangleShape Convert(int fromSrid, int toSrid, RectangleShape rectangleShape);
    public static IEnumerable`1<Feature> Convert(int fromSrid, int toSrid, IEnumerable`1<Feature> features);
    public static IEnumerable`1<Vertex> Convert(int fromSrid, int toSrid, IEnumerable`1<Vertex> vertices);
    public static Vertex Convert(int fromSrid, int toSrid, double x, double y);
    public static PointShape Convert(int fromSrid, string toProjString, PointShape sourcePoint);
    public static Feature Convert(int fromSrid, string toProjString, Feature feature);
    public static RectangleShape Convert(int fromSrid, string toProjString, RectangleShape rectangleShape);
    public static IEnumerable`1<Feature> Convert(int fromSrid, string toProjString, IEnumerable`1<Feature> features);
    public static IEnumerable`1<Vertex> Convert(int fromSrid, string toProjString, IEnumerable`1<Vertex> vertices);
    public static Vertex Convert(int fromSrid, string toProjString, double x, double y);
    public static PointShape Convert(Projection fromProjection, Projection toProjection, PointShape sourcePoint);
    public static Feature Convert(Projection fromProjection, Projection toProjection, Feature feature);
    public static RectangleShape Convert(Projection fromProjection, Projection toProjection, RectangleShape rectangleShape);
    public static IEnumerable`1<Feature> Convert(Projection fromProjection, Projection toProjection, IEnumerable`1<Feature> features);
    public static IEnumerable`1<Vertex> Convert(Projection fromProjection, Projection toProjection, IEnumerable`1<Vertex> vertices);
    public static Vertex Convert(Projection fromProjection, Projection toProjection, double x, double y);
    public static PointShape Convert(string fromProjString, int toSrid, PointShape sourcePoint);
    public static Feature Convert(string fromProjString, int toSrid, Feature feature);
    public static RectangleShape Convert(string fromProjString, int toSrid, RectangleShape rectangleShape);
    public static IEnumerable`1<Feature> Convert(string fromProjString, int toSrid, IEnumerable`1<Feature> features);
    public static IEnumerable`1<Vertex> Convert(string fromProjString, int toSrid, IEnumerable`1<Vertex> vertices);
    public static Vertex Convert(string fromProjString, int toSrid, double x, double y);
    public static PointShape Convert(string fromProjString, string toProjString, PointShape sourcePoint);
    public static Feature Convert(string fromProjString, string toProjString, Feature feature);
    public static RectangleShape Convert(string fromProjString, string toProjString, RectangleShape rectangleShape);
    public static IEnumerable`1<Feature> Convert(string fromProjString, string toProjString, IEnumerable`1<Feature> features);
    public static IEnumerable`1<Vertex> Convert(string fromProjString, string toProjString, IEnumerable`1<Vertex> vertices);
    public static Vertex Convert(string fromProjString, string toProjString, double x, double y);
    private static void uho=(int errorNumber);
}
public class ThinkGeo.Core.QualityFamilyAreaStyle : AreaStyle {
    [ObfuscationAttribute]
private Collection`1<AreaStyle> areaStyles;
    [ObfuscationAttribute]
private Dictionary`2<string, AreaStyle> cache;
    [ObfuscationAttribute]
private int numberOfColors;
    public int NumberOfColors { get; public set; }
    public Dictionary`2<string, AreaStyle> Cache { get; }
    public GeoColor BaseColor { get; public set; }
    public QualityFamilyAreaStyle(GeoPen outlinePen, GeoColor baseColor, int numberOfColors);
    public QualityFamilyAreaStyle(GeoPen outlinePen, GeoColor baseColor, int numberOfColors, PenBrushDrawingOrder penBrushDrawingOrder);
    public int get_NumberOfColors();
    public void set_NumberOfColors(int value);
    public Dictionary`2<string, AreaStyle> get_Cache();
    public GeoColor get_BaseColor();
    public void set_BaseColor(GeoColor value);
    public void ClearCache();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.QueryTools : object {
    [ObfuscationAttribute]
private FeatureSource featureSource;
    public bool CanExecuteSqlQuery { get; }
    public QueryTools(FeatureSource featureSource);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue, ReturningColumnsType returningColumnType);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesByColumnValue(string columnName, string columnValue);
    public Collection`1<Feature> GetFeaturesContaining(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesContaining(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesContaining(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesContaining(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesCrossing(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesCrossing(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesCrossing(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesCrossing(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesDisjointed(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesDisjointed(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesDisjointed(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesDisjointed(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesIntersecting(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesIntersecting(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesIntersecting(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesIntersecting(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesOverlapping(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesOverlapping(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesOverlapping(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesOverlapping(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesTopologicalEqual(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesTopologicalEqual(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesTopologicalEqual(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesTopologicalEqual(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesTouching(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesTouching(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesTouching(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesTouching(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesWithin(BaseShape targetShape, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithin(BaseShape targetShape, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesWithin(Feature targetFeature, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithin(Feature targetFeature, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesOutsideBoundingBox(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesOutsideBoundingBox(RectangleShape boundingBox, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesInsideBoundingBox(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesInsideBoundingBox(RectangleShape boundingBox, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesNearestTo(Feature targetFeature, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames, double searchRadius, DistanceUnit unitOfSearchRadius);
    public Collection`1<Feature> GetFeaturesNearestTo(BaseShape targetShape, GeographyUnit unitOfData, int maxItemsToFind, IEnumerable`1<string> returningColumnNames, double searchRadius, DistanceUnit unitOfSearchRadius);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(BaseShape targetShape, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(Feature targetFeature, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesWithinDistanceOf(Feature targetFeature, GeographyUnit unitOfData, DistanceUnit distanceUnit, double distance, ReturningColumnsType returningColumnNamesType);
    public Feature GetFeatureById(string id, IEnumerable`1<string> returningColumnNames);
    public Feature GetFeatureById(string id, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Feature> GetFeaturesByIds(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetFeaturesByIds(IEnumerable`1<string> ids, ReturningColumnsType returningColumnNamesType);
    public RectangleShape GetBoundingBoxById(string id);
    public Collection`1<RectangleShape> GetBoundingBoxesByIds(IEnumerable`1<string> ids);
    public Collection`1<FeatureSourceColumn> GetColumns();
    public long GetCount();
    public Collection`1<Feature> GetAllFeatures(IEnumerable`1<string> returningColumnNames);
    public Collection`1<Feature> GetAllFeatures(ReturningColumnsType returningColumnNamesType);
    public WellKnownType GetFirstFeaturesWellKnownType();
    public bool get_CanExecuteSqlQuery();
    public int ExecuteNonQuery(string sqlStatement);
    public object ExecuteScalar(string sqlStatement);
    public DataTable ExecuteQuery(string sqlStatement);
}
public enum ThinkGeo.Core.QueryType : Enum {
    public int value__;
    public static QueryType Disjoint;
    public static QueryType Intersects;
    public static QueryType Touches;
    public static QueryType Crosses;
    public static QueryType Within;
    public static QueryType Contains;
    public static QueryType Overlaps;
    public static QueryType TopologicalEqual;
}
public enum ThinkGeo.Core.RandomColorType : Enum {
    public int value__;
    public static RandomColorType All;
    public static RandomColorType Pastel;
    public static RandomColorType Bright;
}
public enum ThinkGeo.Core.RangeCheckingInclusion : Enum {
    public int value__;
    public static RangeCheckingInclusion IncludeValue;
    public static RangeCheckingInclusion ExcludeValue;
}
public abstract class ThinkGeo.Core.RasterLayer : Layer {
    [ObfuscationAttribute]
private double upperThreshold;
    [ObfuscationAttribute]
private double lowerThreshold;
    [ObfuscationAttribute]
private RasterSource imageSource;
    public RasterSource ImageSource { get; protected set; }
    public double UpperThreshold { get; public set; }
    public double LowerThreshold { get; public set; }
    public double ScaleFactor { get; public set; }
    public Projection Projection { get; }
    protected bool IsOpenCore { get; }
    public RasterSource get_ImageSource();
    protected void set_ImageSource(RasterSource value);
    public double get_UpperThreshold();
    public void set_UpperThreshold(double value);
    public double get_LowerThreshold();
    public void set_LowerThreshold(double value);
    public double get_ScaleFactor();
    public void set_ScaleFactor(double value);
    public virtual Projection get_Projection();
    protected virtual bool get_IsOpenCore();
    public float GetHorizontalResolution();
    public float GetVerticalResolution();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual bool IsDrawingNeededCore(double currentScale);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void UCA=(GeoCanvas canvas);
    private void USA=(GeoCanvas canvas);
    private void UiA=(GeoCanvas canvas);
}
public class ThinkGeo.Core.RasterProjectionResult : object {
    [ObfuscationAttribute]
private GeoImage image;
    [ObfuscationAttribute]
private RectangleShape imageExtent;
    public GeoImage Image { get; public set; }
    public RectangleShape ImageExtent { get; public set; }
    public RasterProjectionResult(GeoImage image, RectangleShape imageExtent);
    public GeoImage get_Image();
    public void set_Image(GeoImage value);
    public RectangleShape get_ImageExtent();
    public void set_ImageExtent(RectangleShape value);
}
public abstract class ThinkGeo.Core.RasterSource : object {
    [ObfuscationAttribute]
private float transparency;
    [ObfuscationAttribute]
private float redTranslation;
    [ObfuscationAttribute]
private float greenTranslation;
    [ObfuscationAttribute]
private float blueTranslation;
    [ObfuscationAttribute]
private bool isNegative;
    [ObfuscationAttribute]
private bool isGrayscale;
    private bool oBo=;
    [ObfuscationAttribute]
private ProjectionConverter projectionConverter;
    [ObfuscationAttribute]
private Projection projection;
    [ObfuscationAttribute]
private double scaleFactor;
    [CompilerGeneratedAttribute]
private EventHandler`1<OpeningRasterSourceEventArgs> sx4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<OpenedRasterSourceEventArgs> tB4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClosingRasterSourceEventArgs> tR4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<ClosedRasterSourceEventArgs> th4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<iR4=> tx4=;
    public ProjectionConverter ProjectionConverter { get; public set; }
    public Projection Projection { get; protected set; }
    public float Transparency { get; public set; }
    public float BlueTranslation { get; public set; }
    public float RedTranslation { get; public set; }
    public float GreenTranslation { get; public set; }
    public bool IsNegative { get; public set; }
    public bool IsGrayscale { get; public set; }
    public double ScaleFactor { get; public set; }
    public bool IsOpen { get; protected set; }
    [CompilerGeneratedAttribute]
public void add_OpeningRasterSource(EventHandler`1<OpeningRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OpeningRasterSource(EventHandler`1<OpeningRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_OpenedRasterSource(EventHandler`1<OpenedRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_OpenedRasterSource(EventHandler`1<OpenedRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClosingRasterSource(EventHandler`1<ClosingRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClosingRasterSource(EventHandler`1<ClosingRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ClosedRasterSource(EventHandler`1<ClosedRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ClosedRasterSource(EventHandler`1<ClosedRasterSourceEventArgs> value);
    [CompilerGeneratedAttribute]
internal void uB4=(EventHandler`1<iR4=> value);
    [CompilerGeneratedAttribute]
internal void uR4=(EventHandler`1<iR4=> value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    public Projection get_Projection();
    protected void set_Projection(Projection value);
    public float get_Transparency();
    public void set_Transparency(float value);
    public float get_BlueTranslation();
    public void set_BlueTranslation(float value);
    public float get_RedTranslation();
    public void set_RedTranslation(float value);
    public float get_GreenTranslation();
    public void set_GreenTranslation(float value);
    public bool get_IsNegative();
    public void set_IsNegative(bool value);
    public bool get_IsGrayscale();
    public void set_IsGrayscale(bool value);
    public double get_ScaleFactor();
    public void set_ScaleFactor(double value);
    protected virtual void OnOpeningRasterSource(OpeningRasterSourceEventArgs e);
    internal virtual void ux4=(iR4= e);
    protected virtual void OnOpenedRasterSource(OpenedRasterSourceEventArgs e);
    protected virtual void OnClosingRasterSource(ClosingRasterSourceEventArgs e);
    protected virtual void OnClosedRasterSource(ClosedRasterSourceEventArgs e);
    public RasterSource CloneDeep();
    protected virtual RasterSource CloneDeepCore();
    public string GetWorldFileText();
    public static string GenerateWorldFileText(RectangleShape worldExtent, int imageWidth, int imageHeight);
    public int GetImageWidth();
    protected abstract virtual int GetImageWidthCore();
    public int GetImageHeight();
    protected abstract virtual int GetImageHeightCore();
    public float GetHorizontalResolution();
    public float GetVerticalResolution();
    public RectangleShape GetBoundingBox();
    protected abstract virtual RectangleShape GetBoundingBoxCore();
    public bool get_IsOpen();
    protected void set_IsOpen(bool value);
    public void Open();
    protected abstract virtual void OpenCore();
    public void Close();
    protected virtual void CloseCore();
    public GeoImage GetImage(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    internal GeoImage vB4=(RectangleShape boundingBox, double screenWidth, double screenHeight, RectangleShape wrappingExtent);
    internal GeoImage vR4=(RectangleShape boundingBox, double screenWidth, double screenHeight, RectangleShape wrappingExtent);
    protected abstract virtual GeoImage GetImageCore(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
}
public class ThinkGeo.Core.RasterTile : Tile {
    [ObfuscationAttribute]
private GeoImage bitmap;
    [CompilerGeneratedAttribute]
private Byte[] 0h0=;
    [ObsoleteAttribute("This property is obsoleted and will be removed on 14.4, please use GetImage() instead")]
public GeoImage Bitmap { get; public set; }
    public Byte[] RasterData { get; public set; }
    public RasterTile(Byte[] rasterData, int zoom, long column, long row);
    public GeoImage get_Bitmap();
    public void set_Bitmap(GeoImage value);
    [CompilerGeneratedAttribute]
public Byte[] get_RasterData();
    [CompilerGeneratedAttribute]
public void set_RasterData(Byte[] value);
    public GeoImage GetImage();
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void 0x0=(bool disposing);
}
public abstract class ThinkGeo.Core.RasterTileCache : TileCache {
    [ObfuscationAttribute]
private GeoImageFormat imageFormat;
    [ObfuscationAttribute]
private short jpegQuality;
    private GeoImage wx0=;
    private GeoImage xB0=;
    public GeoImage NoDataTileImage { get; }
    public GeoImage LoadingTileImage { get; }
    public GeoImageFormat ImageFormat { get; public set; }
    public short JpegQuality { get; public set; }
    protected RasterTileCache(string cacheId, GeoImageFormat imageFormat);
    public GeoImage get_NoDataTileImage();
    public GeoImage get_LoadingTileImage();
    public GeoImageFormat get_ImageFormat();
    public void set_ImageFormat(GeoImageFormat value);
    public short get_JpegQuality();
    public void set_JpegQuality(short value);
    public virtual string ToString();
}
[ObsoleteAttribute("This enum is obsoleted, please use GeoImageFormat instead")]
public enum ThinkGeo.Core.RasterTileFormat : Enum {
    public int value__;
    public static RasterTileFormat Png;
    public static RasterTileFormat Jpeg;
}
internal enum ThinkGeo.Core.ReadType : Enum {
    public int value__;
    public static ReadType Read;
    public static ReadType ReadAsInt32;
    public static ReadType ReadAsInt64;
    public static ReadType ReadAsBytes;
    public static ReadType ReadAsString;
    public static ReadType ReadAsDecimal;
    public static ReadType ReadAsDateTime;
    public static ReadType ReadAsDouble;
    public static ReadType ReadAsBoolean;
}
public class ThinkGeo.Core.RebuildingShapeFileFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private long recordCount;
    [ObfuscationAttribute]
private long currentRecordIndex;
    [ObfuscationAttribute]
private Feature currentFeature;
    [ObfuscationAttribute]
private DateTime startProcessTime;
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private string shapePathFilename;
    public long RecordCount { get; }
    public long CurrentRecordIndex { get; }
    public Feature CurrentFeature { get; }
    public DateTime StartProcessTime { get; }
    public bool Cancel { get; public set; }
    public string ShapePathFilename { get; }
    public RebuildingShapeFileFeatureSourceEventArgs(long recordCount, long currentRecordIndex, Feature currentFeature, DateTime startProcessTime, bool cancel);
    public RebuildingShapeFileFeatureSourceEventArgs(long recordCount, long currentRecordIndex, Feature currentFeature, DateTime startProcessTime, bool cancel, string shapePathFilename);
    public long get_RecordCount();
    public long get_CurrentRecordIndex();
    public Feature get_CurrentFeature();
    public DateTime get_StartProcessTime();
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public string get_ShapePathFilename();
}
public class ThinkGeo.Core.ReceivedHttpResponseMessageEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private HttpResponseMessage VSA=;
    public HttpResponseMessage ResponseMessage { get; public set; }
    public ReceivedHttpResponseMessageEventArgs(HttpResponseMessage responseMessage);
    [CompilerGeneratedAttribute]
public HttpResponseMessage get_ResponseMessage();
    [CompilerGeneratedAttribute]
public void set_ResponseMessage(HttpResponseMessage value);
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.RectangleShape : AreaBaseShape {
    [ObfuscationAttribute]
private PointShape upperLeftPoint;
    [ObfuscationAttribute]
private PointShape lowerRightPoint;
    protected static double tolerance;
    public PointShape UpperLeftPoint { get; public set; }
    public PointShape UpperRightPoint { get; }
    public PointShape LowerRightPoint { get; public set; }
    public PointShape LowerLeftPoint { get; }
    public double Height { get; }
    public double Width { get; }
    public double MinX { get; }
    public double MaxY { get; }
    public double MaxX { get; }
    public double MinY { get; }
    public RectangleShape(PointShape upperLeftPoint, PointShape lowerRightPoint);
    public RectangleShape(double minX, double maxY, double maxX, double minY);
    public RectangleShape(string wellKnownText);
    public RectangleShape(Byte[] wellKnownBinary);
    private static RectangleShape();
    private exw= dxw=(RectangleShape targetShape);
    private RectangleShape eBw=(RectangleShape targetShape);
    protected virtual bool IntersectsCore(BaseShape targetShape);
    public RectangleShape GetIntersection(RectangleShape targetShape);
    protected virtual WellKnownType GetWellKnownTypeCore();
    public PointShape get_UpperLeftPoint();
    public void set_UpperLeftPoint(PointShape value);
    public PointShape get_UpperRightPoint();
    public PointShape get_LowerRightPoint();
    public void set_LowerRightPoint(PointShape value);
    public PointShape get_LowerLeftPoint();
    public double get_Height();
    public double get_Width();
    public double get_MinX();
    public double get_MaxY();
    public double get_MaxX();
    public double get_MinY();
    protected virtual BaseShape CloneDeepCore();
    public PolygonShape ToPolygon();
    private bool eRw=(RectangleShape targetShape);
    public void ExpandToInclude(BaseShape targetShape);
    public void ExpandToInclude(Feature targetFeature);
    public void ExpandToInclude(IEnumerable`1<BaseShape> targetShapes);
    public void ExpandToInclude(IEnumerable`1<Feature> targetFeatures);
    protected virtual PointShape GetCenterPointCore();
    protected virtual void ExpandToIncludeCore(BaseShape targetShape);
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    protected virtual bool IsDisjointedCore(BaseShape targetShape);
    private static void ehw=(RectangleShape fromRectangle, RectangleShape toRectangle);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    protected virtual MultipointShape GetCrossingCore(BaseShape targetShape);
    protected virtual bool ContainsCore(BaseShape targetShape);
    public virtual string ToString();
    private void SRU=(double multiplicator);
}
public class ThinkGeo.Core.RegexItem : object {
    [ObfuscationAttribute]
private string regularExpression;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    [ObfuscationAttribute]
private LineStyle defaultLineStyle;
    [ObfuscationAttribute]
private AreaStyle defaultAreaStyle;
    [ObfuscationAttribute]
private TextStyle defaultTextStyle;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    public string RegularExpression { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    public AreaStyle DefaultAreaStyle { get; public set; }
    public LineStyle DefaultLineStyle { get; public set; }
    public PointStyle DefaultPointStyle { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    public RegexItem(string regularExpression, AreaStyle areaStyle);
    public RegexItem(string regularExpression, LineStyle lineStyle);
    public RegexItem(string regularExpression, PointStyle pointStyle);
    public RegexItem(string regularExpression, TextStyle textStyle);
    public RegexItem(string regularExpression, Collection`1<Style> styles);
    private RegexItem(string regularExpression, AreaStyle areaStyle, LineStyle lineStyle, PointStyle pointStyle, TextStyle textStyle, Collection`1<Style> styles);
    public string get_RegularExpression();
    public void set_RegularExpression(string value);
    public Collection`1<Style> get_CustomStyles();
    public AreaStyle get_DefaultAreaStyle();
    public void set_DefaultAreaStyle(AreaStyle value);
    public LineStyle get_DefaultLineStyle();
    public void set_DefaultLineStyle(LineStyle value);
    public PointStyle get_DefaultPointStyle();
    public void set_DefaultPointStyle(PointStyle value);
    public TextStyle get_DefaultTextStyle();
    public void set_DefaultTextStyle(TextStyle value);
}
public enum ThinkGeo.Core.RegexMatching : Enum {
    public int value__;
    public static RegexMatching MatchFirstOnly;
    public static RegexMatching MatchAll;
}
public class ThinkGeo.Core.RegexStyle : Style {
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private Collection`1<RegexItem> regexItems;
    [ObfuscationAttribute]
private RegexMatching regexMatchingRule;
    public RegexMatching RegexMatchingRule { get; public set; }
    public string ColumnName { get; public set; }
    public Collection`1<RegexItem> RegexItems { get; }
    public RegexStyle(string columnName, Collection`1<RegexItem> regexItems);
    public RegexStyle(string columnName, Collection`1<RegexItem> regexItems, RegexMatching regexMatching);
    public RegexMatching get_RegexMatchingRule();
    public void set_RegexMatchingRule(RegexMatching value);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public Collection`1<RegexItem> get_RegexItems();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    private Collection`1<RegexItem> 3TE=(string columnValue, RegexMatching regexMatching);
    private static void tjE=(Collection`1<string> requiredFieldNames, Collection`1<string> fieldNames);
}
public class ThinkGeo.Core.RemovedGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    [ObfuscationAttribute]
private int index;
    public object Item { get; public set; }
    public int Index { get; public set; }
    public RemovedGeoCollectionEventArgs(object item);
    public RemovedGeoCollectionEventArgs(object item, int index);
    public object get_Item();
    public void set_Item(object value);
    public int get_Index();
    public void set_Index(int value);
}
public class ThinkGeo.Core.RemovingGeoCollectionEventArgs : EventArgs {
    [ObfuscationAttribute]
private object item;
    public object Item { get; public set; }
    public RemovingGeoCollectionEventArgs(object item);
    public object get_Item();
    public void set_Item(object value);
}
public enum ThinkGeo.Core.RequestDrawingBufferTimeType : Enum {
    public int value__;
    public static RequestDrawingBufferTimeType Default;
    public static RequestDrawingBufferTimeType MinimumDelay;
    public static RequestDrawingBufferTimeType ResetDelay;
}
public class ThinkGeo.Core.RequestedDataWfsFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private string xmlResponse;
    [ObfuscationAttribute]
private string serviceUrl;
    public string XmlResponse { get; }
    public string ServiceUrl { get; }
    public RequestedDataWfsFeatureSourceEventArgs(string serviceUrl, string xmlResponse);
    public string get_XmlResponse();
    public string get_ServiceUrl();
}
public class ThinkGeo.Core.RequestedDrawingLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private TimeSpan bufferTime;
    [ObfuscationAttribute]
private RequestDrawingBufferTimeType bufferTimeType;
    [ObfuscationAttribute]
private Collection`1<RectangleShape> extentsToRefresh;
    public TimeSpan BufferTime { get; public set; }
    public RequestDrawingBufferTimeType BufferTimeType { get; public set; }
    public Collection`1<RectangleShape> ExtentsToRefresh { get; }
    public RequestedDrawingLayerEventArgs(RectangleShape extentToRefresh);
    public RequestedDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh);
    public RequestedDrawingLayerEventArgs(TimeSpan bufferTime);
    public RequestedDrawingLayerEventArgs(TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public RequestedDrawingLayerEventArgs(RectangleShape extentToRefresh, TimeSpan bufferTime);
    public RequestedDrawingLayerEventArgs(RectangleShape extentToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public RequestedDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime);
    public RequestedDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public TimeSpan get_BufferTime();
    public void set_BufferTime(TimeSpan value);
    public RequestDrawingBufferTimeType get_BufferTimeType();
    public void set_BufferTimeType(RequestDrawingBufferTimeType value);
    public Collection`1<RectangleShape> get_ExtentsToRefresh();
}
public class ThinkGeo.Core.RequestedImageExceptionEventArgs : EventArgs {
    [ObfuscationAttribute]
private GeoImage result;
    [ObfuscationAttribute]
private bool cancel;
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.4. Please use Exception instead.")]
[ObfuscationAttribute]
private string errorMsg;
    [ObfuscationAttribute]
private Exception exception;
    public GeoImage Result { get; public set; }
    public bool Cancel { get; public set; }
    public string ErrorMsg { get; public set; }
    public Exception Exception { get; public set; }
    [ObsoleteAttribute("This constructor is obsoleted and will be removed after v14.4.")]
public RequestedImageExceptionEventArgs(GeoImage geoImage, string errorMsg);
    public RequestedImageExceptionEventArgs(GeoImage geoImage, Exception exception);
    public GeoImage get_Result();
    public void set_Result(GeoImage value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public string get_ErrorMsg();
    public void set_ErrorMsg(string value);
    public Exception get_Exception();
    public void set_Exception(Exception value);
}
public class ThinkGeo.Core.RequestingDataWfsFeatureSourceEventArgs : EventArgs {
    [ObfuscationAttribute]
private string serviceUrl;
    [ObfuscationAttribute]
private bool overrideResponse;
    [ObfuscationAttribute]
private string xmlResponse;
    public string ServiceUrl { get; public set; }
    public bool OverrideResponse { get; public set; }
    public string XmlResponse { get; public set; }
    public RequestingDataWfsFeatureSourceEventArgs(string serviceUrl, bool overrideResponse, string xmlResponse);
    public string get_ServiceUrl();
    public void set_ServiceUrl(string value);
    public bool get_OverrideResponse();
    public void set_OverrideResponse(bool value);
    public string get_XmlResponse();
    public void set_XmlResponse(string value);
}
public class ThinkGeo.Core.RequestingDrawingLayerEventArgs : EventArgs {
    [ObfuscationAttribute]
private TimeSpan bufferTime;
    [ObfuscationAttribute]
private RequestDrawingBufferTimeType bufferTimeType;
    [ObfuscationAttribute]
private Collection`1<RectangleShape> extentsToRefresh;
    [ObfuscationAttribute]
private bool cancel;
    public TimeSpan BufferTime { get; public set; }
    public Collection`1<RectangleShape> ExtentsToRefresh { get; }
    public RequestDrawingBufferTimeType BufferTimeType { get; public set; }
    public bool Cancel { get; public set; }
    public RequestingDrawingLayerEventArgs(RectangleShape extentToRefresh);
    public RequestingDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh);
    public RequestingDrawingLayerEventArgs(TimeSpan bufferTime);
    public RequestingDrawingLayerEventArgs(TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public RequestingDrawingLayerEventArgs(RectangleShape extentToRefresh, TimeSpan bufferTime);
    public RequestingDrawingLayerEventArgs(RectangleShape extentToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public RequestingDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime);
    public RequestingDrawingLayerEventArgs(IEnumerable`1<RectangleShape> extentsToRefresh, TimeSpan bufferTime, RequestDrawingBufferTimeType bufferTimeType);
    public TimeSpan get_BufferTime();
    public void set_BufferTime(TimeSpan value);
    public Collection`1<RectangleShape> get_ExtentsToRefresh();
    public RequestDrawingBufferTimeType get_BufferTimeType();
    public void set_BufferTimeType(RequestDrawingBufferTimeType value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public enum ThinkGeo.Core.RequestProtocol : Enum {
    public int value__;
    public static RequestProtocol Default;
    public static RequestProtocol Https;
    public static RequestProtocol Http;
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ClientIDOrSecretInvalid { get; }
    internal static string InputMustValid { get; }
    internal static string ValueMustInRange { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ClientIDOrSecretInvalid();
    internal static string get_InputMustValid();
    internal static string get_ValueMustInRange();
}
public class ThinkGeo.Core.RestrictionLayer : Layer {
    [ObfuscationAttribute]
private GeoCollection`1<Style> customStyles;
    [ObfuscationAttribute]
private Style defaultStyle;
    [ObfuscationAttribute]
private double lowerScale;
    [ObfuscationAttribute]
private RestrictionMode restrictionMode;
    [ObfuscationAttribute]
private RestrictionStyle restrictionStyle;
    [ObfuscationAttribute]
private double upperScale;
    [ObfuscationAttribute]
private GeoCollection`1<AreaBaseShape> zones;
    public double UpperScale { get; public set; }
    public double LowerScale { get; public set; }
    public GeoCollection`1<Style> CustomStyles { get; }
    public RestrictionMode RestrictionMode { get; public set; }
    public GeoCollection`1<AreaBaseShape> Zones { get; }
    public RestrictionStyle RestrictionStyle { get; public set; }
    public RestrictionLayer(IEnumerable`1<AreaBaseShape> zones);
    public RestrictionLayer(IEnumerable`1<AreaBaseShape> zones, RestrictionMode zonesToShowOrHide);
    public RestrictionLayer(IEnumerable`1<AreaBaseShape> zones, RestrictionMode zonesToShowOrHide, double upperScale, double lowerScale);
    public double get_UpperScale();
    public void set_UpperScale(double value);
    public double get_LowerScale();
    public void set_LowerScale(double value);
    public GeoCollection`1<Style> get_CustomStyles();
    public RestrictionMode get_RestrictionMode();
    public void set_RestrictionMode(RestrictionMode value);
    public GeoCollection`1<AreaBaseShape> get_Zones();
    public RestrictionStyle get_RestrictionStyle();
    public void set_RestrictionStyle(RestrictionStyle value);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void 6SM=(GeoCanvas canvas);
    private void 6iM=(GeoCanvas canvas);
    private void 6yM=(GeoCanvas canvas);
    private void SxU=(IEnumerable`1<Feature> features, GeoCanvas canvas);
    private static Style 7CM=(Stream stream);
    private static Style 7SM=();
}
public enum ThinkGeo.Core.RestrictionMode : Enum {
    public int value__;
    public static RestrictionMode HideZones;
    public static RestrictionMode ShowZones;
}
public enum ThinkGeo.Core.RestrictionStyle : Enum {
    public int value__;
    public static RestrictionStyle HatchPattern;
    public static RestrictionStyle CircleWithSlashImage;
    public static RestrictionStyle UseCustomStyles;
}
public static class ThinkGeo.Core.RestrictionValidatorHelper : object {
    public static void CheckRestrictionModeIsValid(RestrictionMode restrictionMode, string parameterName);
    public static void CheckRestrictionStyleIsValid(RestrictionStyle restrictionStyle, string parameterName);
    public static void CheckRestrictionStyleIsNotConflicted(RestrictionStyle restrictionStyle, IEnumerable`1<Style> customStyles);
}
public enum ThinkGeo.Core.ReturningColumnsType : Enum {
    public int value__;
    public static ReturningColumnsType NoColumns;
    public static ReturningColumnsType AllColumns;
}
public class ThinkGeo.Core.ReverseGeocodingCloudClient : CloudClient {
    private static int 9xQ=;
    private static int yRQ=;
    public ReverseGeocodingCloudClient(string clientId, string clientSecret);
    public CloudReverseGeocodingResult SearchPointInDecimalDegree(double latitude, double longitude, double searchRadius, DistanceUnit unitOfsearchRadius);
    public CloudReverseGeocodingResult SearchPointInDecimalDegree(double latitude, double longitude, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchPoint(double x, double y, int pointProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius);
    public CloudReverseGeocodingResult SearchPoint(double x, double y, int pointProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchPoint(double x, double y, string pointProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius);
    public CloudReverseGeocodingResult SearchPoint(double x, double y, string pointProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/gj4=")]
public Task`1<CloudReverseGeocodingResult> SearchPointInDecimalDegreeAsync(double latitude, double longitude, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/gz4=")]
public Task`1<CloudReverseGeocodingResult> SearchPointInDecimalDegreeAsync(double latitude, double longitude, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/fD4=")]
public Task`1<CloudReverseGeocodingResult> SearchPointAsync(double x, double y, int pointProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/fj4=")]
public Task`1<CloudReverseGeocodingResult> SearchPointAsync(double x, double y, int pointProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/fz4=")]
public Task`1<CloudReverseGeocodingResult> SearchPointAsync(double x, double y, string pointProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/gD4=")]
public Task`1<CloudReverseGeocodingResult> SearchPointAsync(double x, double y, string pointProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public Collection`1<CloudReverseGeocodingResult> SearchPointsInDecimalDegree(IEnumerable`1<PointShape> points, double searchRadius, DistanceUnit unitOfsearchRadius);
    public Collection`1<CloudReverseGeocodingResult> SearchPointsInDecimalDegree(IEnumerable`1<PointShape> points, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public Collection`1<CloudReverseGeocodingResult> SearchPoints(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius);
    public Collection`1<CloudReverseGeocodingResult> SearchPoints(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public Collection`1<CloudReverseGeocodingResult> SearchPoints(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius);
    public Collection`1<CloudReverseGeocodingResult> SearchPoints(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/iT4=")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsInDecimalDegreeAsync(IEnumerable`1<PointShape> points, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/ij4=")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsInDecimalDegreeAsync(IEnumerable`1<PointShape> points, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/hD4=")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsAsync(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/hT4=")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsAsync(IEnumerable`1<PointShape> points, int pointsProjectionInSrid, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/hj4=")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsAsync(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/hz4=")]
public Task`1<Collection`1<CloudReverseGeocodingResult>> SearchPointsAsync(IEnumerable`1<PointShape> points, string pointsProjectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchLineInDecimalDegree(LineShape line, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    public CloudReverseGeocodingResult SearchLineInDecimalDegree(LineShape line, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchLine(LineShape line, int lineProjectionInSrid, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    public CloudReverseGeocodingResult SearchLine(LineShape line, int lineProjectionInSrid, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchLine(LineShape line, string lineProjectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    public CloudReverseGeocodingResult SearchLine(LineShape line, string lineProjectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/ej4=")]
public Task`1<CloudReverseGeocodingResult> SearchLineInDecimalDegreeAsync(LineShape line, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/ez4=")]
public Task`1<CloudReverseGeocodingResult> SearchLineInDecimalDegreeAsync(LineShape line, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/cz4=")]
public Task`1<CloudReverseGeocodingResult> SearchLineAsync(LineShape line, int lineProjectionInSrid, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/dj4=")]
public Task`1<CloudReverseGeocodingResult> SearchLineAsync(LineShape line, int lineProjectionInSrid, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/dz4=")]
public Task`1<CloudReverseGeocodingResult> SearchLineAsync(LineShape line, string lineProjectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/eD4=")]
public Task`1<CloudReverseGeocodingResult> SearchLineAsync(LineShape line, string lineProjectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchAreaInDecimalDegree(PolygonShape area);
    public CloudReverseGeocodingResult SearchAreaInDecimalDegree(PolygonShape area, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchArea(PolygonShape area, int areaProjectionInSrid);
    public CloudReverseGeocodingResult SearchArea(PolygonShape area, int areaProjectionInSrid, CloudReverseGeocodingOptions options);
    public CloudReverseGeocodingResult SearchArea(PolygonShape area, string areaProjectionInProj4String);
    public CloudReverseGeocodingResult SearchArea(PolygonShape area, string areaProjectionInProj4String, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/cT4=")]
public Task`1<CloudReverseGeocodingResult> SearchAreaInDecimalDegreeAsync(PolygonShape area);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/cj4=")]
public Task`1<CloudReverseGeocodingResult> SearchAreaInDecimalDegreeAsync(PolygonShape area, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/bD4=")]
public Task`1<CloudReverseGeocodingResult> SearchAreaAsync(PolygonShape area, int areaProjectionInSrid);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/bT4=")]
public Task`1<CloudReverseGeocodingResult> SearchAreaAsync(PolygonShape area, int areaProjectionInSrid, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/bj4=")]
public Task`1<CloudReverseGeocodingResult> SearchAreaAsync(PolygonShape area, string areaProjectionInProj4String);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/bz4=")]
public Task`1<CloudReverseGeocodingResult> SearchAreaAsync(PolygonShape area, string areaProjectionInProj4String, CloudReverseGeocodingOptions options);
    private CloudReverseGeocodingResult /BQ=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/gT4=")]
private Task`1<CloudReverseGeocodingResult> /RQ=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    private Collection`1<CloudReverseGeocodingResult> /hQ=(IEnumerable`1<PointShape> points, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/iD4=")]
private Task`1<Collection`1<CloudReverseGeocodingResult>> /xQ=(IEnumerable`1<PointShape> points, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchRadius, DistanceUnit unitOfsearchRadius, CloudReverseGeocodingOptions options);
    private CloudReverseGeocodingResult ABU=(LineShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/eT4=")]
private Task`1<CloudReverseGeocodingResult> ARU=(LineShape line, Nullable`1<int> projectionInSrid, string projectionInProj4String, double searchBuffer, DistanceUnit unitOfsearchBuffer, CloudReverseGeocodingOptions options);
    private CloudReverseGeocodingResult AhU=(PolygonShape area, Nullable`1<int> projectionInSrid, string projectionInProj4String, CloudReverseGeocodingOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ReverseGeocodingCloudClient/cD4=")]
private Task`1<CloudReverseGeocodingResult> AxU=(PolygonShape area, Nullable`1<int> projectionInSrid, string projectionInProj4String, CloudReverseGeocodingOptions options);
    private static string BBU=(CloudReverseGeocodingOptions options, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<double> searchRadius, Nullable`1<DistanceUnit> unitOfsearchRadius, string additionalQueryString);
    private static string BRU=(CloudReverseGeocodingOptions options, Nullable`1<int> projectionInSrid, string projectionInProj4String, Nullable`1<double> searchRadius, Nullable`1<DistanceUnit> unitOfsearchRadius, string wkt);
    private static CloudReverseGeocodingResult BhU=(WebResponse response, BaseShape queryShape);
    private static Collection`1<CloudReverseGeocodingResult> BxU=(WebResponse response, IEnumerable`1<PointShape> queryPoints);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.ReverseGeocodingLocationDto : object {
    [CompilerGeneratedAttribute]
private string <LocationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AddressComponents>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <OptionalNames>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationFeatureWellKnownText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HouseNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Postcode>k__BackingField;
    [CompilerGeneratedAttribute]
private CloudLocationCategories <LocationCategory>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocationType>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Distance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DirectionFromQueryFeature>k__BackingField;
    public string LocationName { get; public set; }
    public string Address { get; public set; }
    public Dictionary`2<string, string> AddressComponents { get; public set; }
    public Dictionary`2<string, string> OptionalNames { get; public set; }
    public string LocationFeatureWellKnownText { get; public set; }
    public string HouseNumber { get; public set; }
    public string Postcode { get; public set; }
    public CloudLocationCategories LocationCategory { get; public set; }
    public Dictionary`2<string, string> Properties { get; public set; }
    public string LocationType { get; public set; }
    public double Distance { get; public set; }
    public string DirectionFromQueryFeature { get; public set; }
    [CompilerGeneratedAttribute]
public string get_LocationName();
    [CompilerGeneratedAttribute]
public void set_LocationName(string value);
    [CompilerGeneratedAttribute]
public string get_Address();
    [CompilerGeneratedAttribute]
public void set_Address(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AddressComponents();
    [CompilerGeneratedAttribute]
public void set_AddressComponents(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_OptionalNames();
    [CompilerGeneratedAttribute]
public void set_OptionalNames(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_LocationFeatureWellKnownText();
    [CompilerGeneratedAttribute]
public void set_LocationFeatureWellKnownText(string value);
    [CompilerGeneratedAttribute]
public string get_HouseNumber();
    [CompilerGeneratedAttribute]
public void set_HouseNumber(string value);
    [CompilerGeneratedAttribute]
public string get_Postcode();
    [CompilerGeneratedAttribute]
public void set_Postcode(string value);
    [CompilerGeneratedAttribute]
public CloudLocationCategories get_LocationCategory();
    [CompilerGeneratedAttribute]
public void set_LocationCategory(CloudLocationCategories value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_LocationType();
    [CompilerGeneratedAttribute]
public void set_LocationType(string value);
    [CompilerGeneratedAttribute]
public double get_Distance();
    [CompilerGeneratedAttribute]
public void set_Distance(double value);
    [CompilerGeneratedAttribute]
public string get_DirectionFromQueryFeature();
    [CompilerGeneratedAttribute]
public void set_DirectionFromQueryFeature(string value);
    public CloudReverseGeocodingLocation ToReverseGeocodingLocation();
}
public enum ThinkGeo.Core.RingOrder : Enum {
    public int value__;
    public static RingOrder Unknown;
    public static RingOrder Clockwise;
    public static RingOrder Counterclockwise;
}
[TypeConverterAttribute("ThinkGeo.Core.BaseShapeTypeConverter")]
public class ThinkGeo.Core.RingShape : AreaBaseShape {
    [ObfuscationAttribute]
private Collection`1<Vertex> vertices;
    public Collection`1<Vertex> Vertices { get; }
    public RingShape(IEnumerable`1<Vertex> points);
    public RingShape(string wellKnownText);
    public RingShape(Byte[] wellKnownBinary);
    protected virtual WellKnownType GetWellKnownTypeCore();
    public Collection`1<Vertex> get_Vertices();
    protected virtual BaseShape CloneDeepCore();
    public PolygonShape ToPolygon();
    protected virtual double GetPerimeterCore(GeographyUnit shapeUnit, DistanceUnit returningUnit);
    protected virtual double GetAreaCore(GeographyUnit shapeUnit, AreaUnit returningUnit);
    protected virtual void ScaleUpCore(double percentage);
    protected virtual void ScaleDownCore(double percentage);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual BaseShape RegisterCore(PointShape fromPoint, PointShape toPoint, DistanceUnit fromUnit, GeographyUnit toUnit);
    protected virtual void TranslateByOffsetCore(double xOffsetDistance, double yOffsetDistance, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void TranslateByDegreeCore(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual void RotateCore(PointShape pivotPoint, double degreeAngle);
    protected virtual double GetDistanceToCore(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    protected virtual PointShape GetClosestPointToCore(BaseShape targetShape, GeographyUnit shapeUnit);
    protected virtual string GetWellKnownTextCore(RingOrder outerRingOrder);
    protected virtual Byte[] GetWellKnownBinaryCore(RingOrder outerRingOrder, WkbByteOrder byteOrder);
    protected virtual void LoadFromWellKnownDataCore(string wellKnownText);
    protected virtual void LoadFromWellKnownDataCore(Byte[] wellKnownBinary);
    public static bool RemoveVertex(Vertex selectedVertex, RingShape ringShape);
    public bool RemoveVertex(Vertex selectedVertex);
    private static void gBw=(PolygonShape fromPolygon, RingShape toRing);
    protected virtual ShapeValidationResult ValidateCore(ShapeValidationMode validationMode);
    private static void gRw=(RingShape ringShape);
    private void SRU=(double multiplicator);
    internal static void ghw=(RingShape targetRingShape, double multiplicator, double centerX, double centerY);
    private void Yhw=(WkbByteOrder byteOrder, BinaryWriter writer);
    private void YBw=(WkbByteOrder byteOrder, BinaryWriter writer);
    private static void cRw=(RingShape ringShape, StringBuilder wellKnownText);
    private static void chw=(RingShape ringShape, StringBuilder wellKnownText);
    public bool IsCounterClockwise();
    public void ReversePoints();
    protected virtual void ReversePointsCore();
    public bool IsSelfIntersecting();
    private static bool gxw=(Vertex Pt1, Vertex Pt2, Vertex CompPt1, Vertex CompPt2);
    private static bool hBw=(Vertex InPt1, Vertex InPt2, Vertex InCompPt1, Vertex InCompPt2);
    private static bool hRw=(double x1, double y1, double xp1, double yp1, double xp2, double yp2);
    private static bool hhw=(double Value, double CompValue1, double CompValue2);
    private static bool hxw=(Vertex PointShape1, Vertex LinePointShape1, Vertex LinePointShape2);
    private static RectangleShape VRw=(IEnumerable`1<Vertex> vertices);
}
public class ThinkGeo.Core.RotationProjectionConverter : ProjectionConverter {
    [ObfuscationAttribute]
private PointShape pivotCenter;
    [ObfuscationAttribute]
private double previousRotateAngle;
    [ObfuscationAttribute]
private double angle;
    [ObfuscationAttribute]
private GeographyUnit sourceUnit;
    [ObfuscationAttribute]
private bool isManualPivoit;
    [ObfuscationAttribute]
private PolygonShape previousRotationShape;
    internal PolygonShape aR8= { get; internal set; }
    internal double bB8= { get; internal set; }
    public double Angle { get; public set; }
    public GeographyUnit InternalProjectionUnit { get; }
    public PointShape PivotCenter { get; public set; }
    public RotationProjectionConverter(double angle);
    public RotationProjectionConverter(GeographyUnit sourceUnit);
    public RotationProjectionConverter(double angle, GeographyUnit sourceUnit);
    internal PolygonShape Zx8=();
    internal void aB8=(PolygonShape value);
    internal double ah8=();
    internal void ax8=(double value);
    public double get_Angle();
    public void set_Angle(double value);
    public virtual GeographyUnit get_InternalProjectionUnit();
    public PointShape get_PivotCenter();
    public void set_PivotCenter(PointShape value);
    public RectangleShape GetUpdatedExtent(RectangleShape worldExtent);
    protected virtual void OpenCore();
    protected virtual Collection`1<Vertex> ConvertToExternalProjectionCore(IEnumerable`1<Vertex> verticies);
    protected virtual Collection`1<Vertex> ConvertToInternalProjectionCore(IEnumerable`1<Vertex> verticies);
    private Vertex bR8=(double x, double y, double angle);
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.RouteType : Enum {
    public int value__;
    public static RouteType Fastest;
    public static RouteType Shortest;
}
public class ThinkGeo.Core.RoutingCloudClient : CloudClient {
    public RoutingCloudClient(string clientId, string clientSecret);
    public CloudRoutingGetRouteResult GetRoute(IEnumerable`1<PointShape> waypoints, CloudRoutingGetRouteOptions options);
    public CloudRoutingGetRouteResult GetRoute(IEnumerable`1<PointShape> waypoints, int srid, CloudRoutingGetRouteOptions options);
    public CloudRoutingGetRouteResult GetRoute(IEnumerable`1<PointShape> waypoints, string proj4String, CloudRoutingGetRouteOptions options);
    public Task`1<CloudRoutingGetRouteResult> GetRouteAsync(IEnumerable`1<PointShape> waypoints, CloudRoutingGetRouteOptions options);
    public Task`1<CloudRoutingGetRouteResult> GetRouteAsync(IEnumerable`1<PointShape> waypoints, int srid, CloudRoutingGetRouteOptions options);
    public Task`1<CloudRoutingGetRouteResult> GetRouteAsync(IEnumerable`1<PointShape> waypoints, string proj4String, CloudRoutingGetRouteOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, int srid, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, string proj4String, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, int srid, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetServiceAreaResult GetServiceArea(PointShape point, string proj4String, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, int srid, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, string proj4String, IEnumerable`1<double> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, int srid, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public Task`1<CloudRoutingGetServiceAreaResult> GetServiceAreaAsync(PointShape point, string proj4String, IEnumerable`1<TimeSpan> serviceLimits, CloudRoutingGetServiceAreaOptions options);
    public CloudRoutingGetTimeCostMatrixResult GetTimeCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingGetTimeCostMatrixResult GetTimeCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, int srid, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingGetTimeCostMatrixResult GetTimeCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, string proj4String, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetTimeCostMatrixResult> GetTimeCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetTimeCostMatrixResult> GetTimeCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, int srid, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetTimeCostMatrixResult> GetTimeCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, string proj4String, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingGetDistanceCostMatrixResult GetDistanceCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingGetDistanceCostMatrixResult GetDistanceCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, int srid, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingGetDistanceCostMatrixResult GetDistanceCostMatrix(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, string proj4String, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetDistanceCostMatrixResult> GetDistanceCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetDistanceCostMatrixResult> GetDistanceCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, int srid, CloudRoutingGetCostMatrixOptions options);
    public Task`1<CloudRoutingGetDistanceCostMatrixResult> GetDistanceCostMatrixAsync(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, string proj4String, CloudRoutingGetCostMatrixOptions options);
    public CloudRoutingOptimizationResult GetOptimizedRoute(IEnumerable`1<PointShape> coordinates, CloudRoutingOptimizationOptions options);
    public CloudRoutingOptimizationResult GetOptimizedRoute(IEnumerable`1<PointShape> coordinates, int srid, CloudRoutingOptimizationOptions options);
    public CloudRoutingOptimizationResult GetOptimizedRoute(IEnumerable`1<PointShape> coordinates, string proj4String, CloudRoutingOptimizationOptions options);
    public Task`1<CloudRoutingOptimizationResult> GetOptimizedRouteAsync(IEnumerable`1<PointShape> coordinates, CloudRoutingOptimizationOptions options);
    public Task`1<CloudRoutingOptimizationResult> GetOptimizedRouteAsync(IEnumerable`1<PointShape> coordinates, int srid, CloudRoutingOptimizationOptions options);
    public Task`1<CloudRoutingOptimizationResult> GetOptimizedRouteAsync(IEnumerable`1<PointShape> coordinates, string proj4String, CloudRoutingOptimizationOptions options);
    private CloudRoutingGetRouteResult CBU=(IEnumerable`1<PointShape> waypoints, Nullable`1<int> srid, string proj4String, CloudRoutingGetRouteOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.RoutingCloudClient/kD4=")]
private Task`1<CloudRoutingGetRouteResult> CRU=(IEnumerable`1<PointShape> waypoints, Nullable`1<int> srid, string proj4String, CloudRoutingGetRouteOptions options);
    private CloudRoutingGetServiceAreaResult ChU=(PointShape point, Nullable`1<int> srid, string proj4String, IEnumerable`1<double> serviceLimitsDistance, IEnumerable`1<TimeSpan> serviceLimitsTime, CloudRoutingGetServiceAreaOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.RoutingCloudClient/kj4=")]
private Task`1<CloudRoutingGetServiceAreaResult> CxU=(PointShape point, Nullable`1<int> srid, string proj4String, IEnumerable`1<double> serviceLimitsDistance, IEnumerable`1<TimeSpan> serviceLimitsTime, CloudRoutingGetServiceAreaOptions options);
    private CloudRoutingGetTimeCostMatrixResult DBU=(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, Nullable`1<int> srid, string proj4String, CloudRoutingGetCostMatrixOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.RoutingCloudClient/lT4=")]
private Task`1<CloudRoutingGetTimeCostMatrixResult> DRU=(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, Nullable`1<int> srid, string proj4String, CloudRoutingGetCostMatrixOptions options);
    private CloudRoutingGetDistanceCostMatrixResult DhU=(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, Nullable`1<int> srid, string proj4String, CloudRoutingGetCostMatrixOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.RoutingCloudClient/iz4=")]
private Task`1<CloudRoutingGetDistanceCostMatrixResult> DxU=(IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, Nullable`1<int> srid, string proj4String, CloudRoutingGetCostMatrixOptions options);
    private CloudRoutingOptimizationResult EBU=(IEnumerable`1<PointShape> coordinates, Nullable`1<int> srid, string proj4String, CloudRoutingOptimizationOptions options);
    [AsyncStateMachineAttribute("ThinkGeo.Core.RoutingCloudClient/jj4=")]
private Task`1<CloudRoutingOptimizationResult> ERU=(IEnumerable`1<PointShape> coordinates, Nullable`1<int> srid, string proj4String, CloudRoutingOptimizationOptions options);
    private static CloudRoutingGetRouteResult EhU=(WebResponse response);
    private static CloudRoutingGetServiceAreaResult ExU=(WebResponse response);
    private static CloudRoutingGetTimeCostMatrixResult FBU=(WebResponse response);
    private static CloudRoutingGetDistanceCostMatrixResult FRU=(WebResponse response);
    private static CloudRoutingOptimizationResult FhU=(WebResponse response);
    private static string 2xQ=(Nullable`1<int> srid, string proj4String, CloudRoutingGetRouteOptions options);
    private static string 2xQ=(IEnumerable`1<double> serviceLimitsDistance, IEnumerable`1<TimeSpan> serviceLimitsTime, Nullable`1<int> srid, string proj4String, CloudRoutingGetServiceAreaOptions options);
    private static string 2xQ=(string costMatrixType, IEnumerable`1<PointShape> origins, IEnumerable`1<PointShape> destinations, Nullable`1<int> srid, string proj4String, CloudRoutingGetCostMatrixOptions options);
    private static string 2xQ=(Nullable`1<int> srid, string proj4String, CloudRoutingOptimizationOptions options);
    private static string FxU=(IEnumerable`1<PointShape> points);
    private static string FxU=(IEnumerable`1<string> items, string separator);
}
public class ThinkGeo.Core.RowColumnRange : ValueType {
    [ObfuscationAttribute]
private long minRowIndex;
    [ObfuscationAttribute]
private long maxRowIndex;
    [ObfuscationAttribute]
private long minColumnIndex;
    [ObfuscationAttribute]
private long maxColumnIndex;
    public long MinRowIndex { get; public set; }
    public long MaxRowIndex { get; public set; }
    public long MinColumnIndex { get; public set; }
    public long MaxColumnIndex { get; public set; }
    public RowColumnRange(long minRowIndex, long maxRowIndex, long minColumnIndex, long maxColumnIndex);
    public long get_MinRowIndex();
    public void set_MinRowIndex(long value);
    public long get_MaxRowIndex();
    public void set_MaxRowIndex(long value);
    public long get_MinColumnIndex();
    public void set_MinColumnIndex(long value);
    public long get_MaxColumnIndex();
    public void set_MaxColumnIndex(long value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool khU=(RowColumnRange compareObj);
    public static bool op_Equality(RowColumnRange rowColumnRange1, RowColumnRange rowColumnRange2);
    public static bool op_Inequality(RowColumnRange rowColumnRange1, RowColumnRange rowColumnRange2);
}
[ObfuscationAttribute]
internal abstract class ThinkGeo.Core.RTPage : object {
    protected MemoryStream CyA=;
    [ObfuscationAttribute]
protected Byte[] arrayBuffer;
    protected Stream DCA=;
    [ObfuscationAttribute]
protected RtreeFile rTreeFile;
    [ObfuscationAttribute]
protected UInt32 pageNumber;
    [ObfuscationAttribute]
protected Gist_Ext_Id extensionId;
    protected BinaryReader DSA=;
    protected BinaryWriter DiA=;
    [ObfuscationAttribute]
protected bool isDirty;
    [ObfuscationAttribute]
public int pageSize;
    [ObfuscationAttribute]
private bool isFloat;
    internal static int DyA=;
    internal static string ECA=;
    [ObfuscationAttribute]
internal int pageHeaderSize;
    [ObfuscationAttribute]
internal int recordSetHeaderSize;
    [ObfuscationAttribute]
internal int slotSize;
    public UInt32 EyA= { get; public set; }
    public bool FSA= { get; }
    public RTPage(RtreeFile rtFile, Gist_Ext_Id extId);
    public RTPage(RtreeFile rtFile, UInt32 pageNo, Gist_Ext_Id extId);
    public RTPage(RtreeFile rtFile, UInt32 pageNo);
    public RTPage(RtreeFile rtFile);
    public virtual bool fx8=();
    internal void oR8=();
    internal void FiA=();
    public UInt32 ESA=();
    public void EiA=(UInt32 value);
    public void FyA=();
    public Stream GCA=();
    public Gist_Ext_Id tB8=();
    public RtreeFile GSA=();
    public bool FCA=();
    public abstract virtual string jR8=();
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.RtreeFile : object {
    [ObfuscationAttribute]
private HeaderPage headerPage;
    private Stream DCA=;
    private bool oBo=;
    [ObfuscationAttribute]
private bool isReadOnly;
    [ObfuscationAttribute]
private bool isFloat;
    [ObfuscationAttribute]
private int pageSize;
    private static string GiA=;
    private static string GyA=;
    private static string HCA=;
    private static string HSA=;
    private static string HiA=;
    public int ISA= { get; public set; }
    public bool FSA= { get; }
    public int HyA=();
    public void ICA=(int value);
    public bool FCA=();
    public bool pR8=(string fileName, Gist_Ext_Id extId, uz8= openStreamLoadingDelegate, bool isFloat);
    private void IiA=(Gist_Ext_Id extId, bool isFloat);
    public bool FR8=(string fileName, bool isReadOnly, uz8= openStreamLoadingEvent);
    public bool oR8=();
    public bool fx8=();
    public bool IyA=();
    public bool JCA=();
    public bool JSA=();
    public Stream GCA=();
    internal MemoryStream JiA=();
    public Gist_Ext_Id tB8=();
    internal dB8= JyA=();
    internal int KCA=();
    public Stream KSA=(string fileName, FileMode fileMode, FileAccess readWriteMode, uz8= openStreamLoadingDelegate);
}
public class ThinkGeo.Core.RtreeSpatialIndex : SpatialIndex {
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Dh8=;
    [ObfuscationAttribute]
private RtreeFile rTreeFile;
    [ObfuscationAttribute]
private IdsEngine idsEngine;
    [ObfuscationAttribute]
internal static double m_FillFactor;
    private static string LyA=;
    private static string MCA=;
    private static string MSA=;
    [ObfuscationAttribute]
private bool hasIdx;
    [ObfuscationAttribute]
private string pathFilename;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    public string PathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public RtreeSpatialIndexDataFormat DataFormat { get; }
    public bool HasIdx { get; }
    public int PageSize { get; }
    public RtreeSpatialIndex(string pathFilename);
    public RtreeSpatialIndex(string pathFilename, FileAccess readWriteMode);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    private void MiA=(object sender, StreamLoadingEventArgs e);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
    private void 0x0=(bool disposing);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public RtreeSpatialIndexDataFormat get_DataFormat();
    public void RefreshCache();
    protected virtual void DeleteCore(Feature feature);
    protected virtual void AddCore(Feature feature);
    protected virtual Collection`1<string> GetFeatureIdsIntersectingBoundingBoxCore(RectangleShape boundingBox);
    public Collection`1<string> GetFeatureIdsWithinBoundingBox(RectangleShape boundingBox);
    protected virtual Collection`1<string> GetFeatureIdsWithinBoundingBoxCore(RectangleShape boundingBox);
    public Collection`1<string> GetFeatureIdsContainingRectangleShape(RectangleShape boundingBox);
    protected virtual Collection`1<string> GetFeatureIdsContainingRectangleShapeCore(RectangleShape rectangleShape);
    public Collection`1<string> GetFeatureIdsNearestTo(PointShape pointShape, int maxReturningCount);
    protected virtual Collection`1<string> GetFeatureIdsNearestToCore(PointShape pointShape, int maxReturningCount);
    public bool get_HasIdx();
    public static RtreeSpatialIndexPageSize GetBestPageSize(int recordCount);
    public int get_PageSize();
    internal sR8= MyA=();
    public static void CreateRectangleSpatialIndex(string pathFilename);
    public static void CreateRectangleSpatialIndex(string pathFilename, RtreeSpatialIndexPageSize pageSize);
    public static void CreateRectangleSpatialIndex(string pathFilename, RtreeSpatialIndexPageSize pageSize, RtreeSpatialIndexDataFormat dataFormat);
    public static void CreatePointSpatialIndex(string pathFilename);
    public static void CreatePointSpatialIndex(string pathFilename, RtreeSpatialIndexPageSize pageSize);
    public static void CreatePointSpatialIndex(string pathFilename, RtreeSpatialIndexPageSize pageSize, RtreeSpatialIndexDataFormat dataFormat);
    private bool NCA=(string indexFileName, bool isFloat, RtreeSpatialIndexPageSize pageSize);
    private void NSA=(RtreeSpatialIndexPageSize pageSize);
    private static void NiA=(string indexFileName, bool isFloat, RtreeSpatialIndexPageSize pageSize);
    private bool NyA=(string indexFileName, bool isFloat, RtreeSpatialIndexPageSize pageSize);
    private static void OCA=(string indexFileName, bool isFloat, RtreeSpatialIndexPageSize pageSize);
    private bool OSA=();
    public static bool IsRtreeSpatialIndexFileValid(string indexFileName);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    public void Flush();
    private void OiA=(double x, double y, string pointId);
    private void OiA=(PointShape point, string pointId);
    private void OyA=(double x, double y);
    private void OyA=(PointShape point);
    private void PCA=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY, string rectangleId);
    private void PCA=(RectangleShape rectangle, string rectangleId);
    private void PSA=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY);
    private void PSA=(RectangleShape rectangle);
    private Collection`1<string> PiA=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY);
    private Collection`1<string> PiA=(RectangleShape rectangle);
    private Collection`1<string> PyA=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY);
    private Collection`1<string> PyA=(RectangleShape rectangle);
    private Collection`1<string> QCA=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY);
    public Collection`1<string> GetFeatureIdsIntersectingBoundingBox(RectangleShape rectangleShape, double screenWidth, double screenHeight, int simplifyPixelBufferSize, Collection`1<RectangleShape> dimensionlessBoxes);
    private Collection`1<string> QCA=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY, double screenWidth, double screenHeight, int simplifyPixelBufferSize, Collection`1<RectangleShape> dimensionlessBoxes);
    private Collection`1<string> QCA=(RectangleShape rectangle);
    private Collection`1<string> QSA=(double x, double y, int returningRecordCount);
    private Collection`1<string> QSA=(PointShape point, int returningRecordCount);
    private Collection`1<string> QiA=(double x, double y, int MaxNum);
    protected virtual int GetFeatureCountCore();
    private static string QyA=(string idxFileName);
    public RectangleShape GetBoundingBox();
    public void DeleteRecord(BaseShape shape);
    private void OyA=(PointShape pointShape, IEnumerable`1<string> ids, IdsEngine idsEngine);
    private void OyA=(double x, double y, IEnumerable`1<string> ids, IdsEngine idsEngine);
    private void PSA=(RectangleShape rectangle, IEnumerable`1<string> ids, IdsEngine idsEngine);
    private void PSA=(double upperLeftX, double upperLeftY, double lowerRightX, double lowerRightY, IEnumerable`1<string> ids, IdsEngine idsEngine);
}
public enum ThinkGeo.Core.RtreeSpatialIndexDataFormat : Enum {
    public int value__;
    public static RtreeSpatialIndexDataFormat Float;
    public static RtreeSpatialIndexDataFormat Double;
}
public enum ThinkGeo.Core.RtreeSpatialIndexPageSize : Enum {
    public int value__;
    public static RtreeSpatialIndexPageSize FourKilobytes;
    public static RtreeSpatialIndexPageSize EightKilobytes;
    public static RtreeSpatialIndexPageSize SixteenKilobytes;
    public static RtreeSpatialIndexPageSize ThirtytwoKilobytes;
}
public class ThinkGeo.Core.ScaleBarAdornmentLayer : AdornmentLayer {
    private static int BiE=;
    private static int ByE=;
    private static int CCE=;
    private static int CSE=;
    private static int CiE=;
    private static int CyE=;
    private static int DCE=;
    private static int DSE=;
    private static int DiE=;
    private static int DyE=;
    [ObfuscationAttribute]
private GeoBrush barBrush;
    [ObfuscationAttribute]
private GeoBrush alternateBarBrush;
    [ObfuscationAttribute]
private Dictionary`2<string, string> displayUnitString;
    [ObfuscationAttribute]
private FeetValues feetValues;
    [ObfuscationAttribute]
private GeoFont font;
    [ObfuscationAttribute]
private int fontRatio;
    [ObfuscationAttribute]
private bool hasMask;
    [ObfuscationAttribute]
private int height;
    [ObfuscationAttribute]
private KiloMetersValues kilometersValues;
    [ObfuscationAttribute]
private UnitSystem unitFamily;
    [ObfuscationAttribute]
private GeoBrush maskBrush;
    [ObfuscationAttribute]
private GeoPen maskContour;
    [ObfuscationAttribute]
private int maxWidth;
    [ObfuscationAttribute]
private bool isMeaningfulScale;
    [ObfuscationAttribute]
private MetersValues metersValues;
    [ObfuscationAttribute]
private MilesValues milesValues;
    [ObfuscationAttribute]
private NauticalMilesValues nauticalMilesValues;
    [ObfuscationAttribute]
private string numberFormat;
    [ObfuscationAttribute]
private bool needToRefresh;
    [ObfuscationAttribute]
private ScreenPointF screenLocation;
    [ObfuscationAttribute]
private GeoColor textColor;
    [ObfuscationAttribute]
private int thickness;
    [ObfuscationAttribute]
private int width;
    [ObfuscationAttribute]
private ProjectionConverter projectionToDecimalDegrees;
    [ObfuscationAttribute]
private TextStyle textStyle;
    [ObfuscationAttribute]
private GeoPen barPen;
    public Dictionary`2<string, string> DisplayUnitString { get; }
    public UnitSystem UnitFamily { get; public set; }
    public int Thickness { get; public set; }
    public int MaxWidth { get; public set; }
    public GeoBrush BarBrush { get; public set; }
    public TextStyle TextStyle { get; public set; }
    public GeoBrush AlternateBarBrush { get; public set; }
    public GeoBrush MaskBrush { get; public set; }
    public bool HasMask { get; public set; }
    public GeoPen MaskContour { get; public set; }
    public GeoPen BarPen { get; public set; }
    public Dictionary`2<string, string> get_DisplayUnitString();
    public UnitSystem get_UnitFamily();
    public void set_UnitFamily(UnitSystem value);
    public int get_Thickness();
    public void set_Thickness(int value);
    public int get_MaxWidth();
    public void set_MaxWidth(int value);
    public GeoBrush get_BarBrush();
    public void set_BarBrush(GeoBrush value);
    public TextStyle get_TextStyle();
    public void set_TextStyle(TextStyle value);
    public GeoBrush get_AlternateBarBrush();
    public void set_AlternateBarBrush(GeoBrush value);
    public GeoBrush get_MaskBrush();
    public void set_MaskBrush(GeoBrush value);
    public bool get_HasMask();
    public void set_HasMask(bool value);
    public GeoPen get_MaskContour();
    public void set_MaskContour(GeoPen value);
    public GeoPen get_BarPen();
    public void set_BarPen(GeoPen value);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    internal void ECE=(GeoCanvas canvas, GeographyUnit mapUnit);
    private void ESE=(GeoCanvas canvas);
    private void EiE=(GeoCanvas canvas, float textWidth, int margin, Collection`1<RectangleShape> rectCollection);
    private void EyE=(GeoCanvas canvas, float textWidth, int margin, Collection`1<RectangleShape> rectCollection);
    private static double FCE=(Dictionary`2<double, double> xUnitHashTable);
    private Dictionary`2<double, double> FSE=();
    private Dictionary`2<double, double> FiE=();
    private Dictionary`2<double, double> FyE=();
    private Dictionary`2<double, double> GCE=();
    private Dictionary`2<double, double> GSE=();
    private static void GiE=(int i, Dictionary`2<double, double> xHashTable, Double[] xValues);
    private Collection`1<RectangleShape> GyE=(Dictionary`2<double, double> hashTable);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
}
public class ThinkGeo.Core.ScaleLineAdornmentLayer : AdornmentLayer {
    private static int HCE=;
    private static int HSE=;
    [ObfuscationAttribute]
private int bottomLengthPixel;
    [ObfuscationAttribute]
private string bottomString;
    [ObfuscationAttribute]
private Dictionary`2<string, string> displayUnitString;
    [ObfuscationAttribute]
private int scaleLineHeightInPixel;
    [ObfuscationAttribute]
private int scaleLineWidthInPixel;
    [ObfuscationAttribute]
private int topLengthPixel;
    [ObfuscationAttribute]
private string topString;
    [ObfuscationAttribute]
private ScaleLineUnitSystem unitSystem;
    [ObfuscationAttribute]
private ProjectionConverter projectionToDecimalDegrees;
    [ObfuscationAttribute]
private TextStyle textStyle;
    [ObfuscationAttribute]
private GeoPen pen;
    [ObfuscationAttribute]
private GeoPen backPen;
    public Dictionary`2<string, string> DisplayUnitString { get; }
    public ScaleLineUnitSystem UnitSystem { get; public set; }
    public TextStyle TextStyle { get; public set; }
    public GeoPen Pen { get; public set; }
    public GeoPen HaloPen { get; public set; }
    public ScaleLineAdornmentLayer(ScreenPointF startPoint);
    public ScaleLineAdornmentLayer(AdornmentLocation location);
    public Dictionary`2<string, string> get_DisplayUnitString();
    public ScaleLineUnitSystem get_UnitSystem();
    public void set_UnitSystem(ScaleLineUnitSystem value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    public TextStyle get_TextStyle();
    public void set_TextStyle(TextStyle value);
    public GeoPen get_Pen();
    public void set_Pen(GeoPen value);
    public GeoPen get_HaloPen();
    public void set_HaloPen(GeoPen value);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    private void HiE=(GeoCanvas canvas);
    private void EyE=(GeoCanvas canvas, int topBarHeight, int bottomBarHeight, ScreenPointF startPointF);
    private static string HyE=(string text, GeoFont font, int lengthPixel, GeoCanvas canvas);
    private bool ICE=(GeoCanvas canvas, GeographyUnit mapUnit);
    private static int ISE=(int maxLength);
}
public enum ThinkGeo.Core.ScaleLineUnitSystem : Enum {
    public int value__;
    public static ScaleLineUnitSystem Default;
    public static ScaleLineUnitSystem MetricAndNauticalMile;
    public static ScaleLineUnitSystem NauticalMileAndImperial;
    public static ScaleLineUnitSystem ImperialAndMetric;
}
public class ThinkGeo.Core.ScaleTextAdornmentLayer : AdornmentLayer {
    private static int CyE=;
    private static int DiE=;
    [ObfuscationAttribute]
private ScaleTextScreenUnit screenUnit;
    [ObfuscationAttribute]
private DistanceUnit worldUnit;
    [ObfuscationAttribute]
private GeoFont font;
    [ObfuscationAttribute]
private GeoBrush textBrush;
    [ObfuscationAttribute]
private int width;
    [ObfuscationAttribute]
private int height;
    [ObfuscationAttribute]
private ScreenPointF screenLocation;
    [ObfuscationAttribute]
private bool needToRefresh;
    public ScaleTextScreenUnit ScreenUnit { get; public set; }
    public DistanceUnit WorldUnit { get; public set; }
    public GeoFont Font { get; public set; }
    public GeoBrush TextBrush { get; public set; }
    public ScaleTextAdornmentLayer(ScaleTextScreenUnit screenUnit, DistanceUnit worldUnit);
    public ScaleTextAdornmentLayer(ScaleTextScreenUnit screenUnit, DistanceUnit worldUnit, GeoFont font, GeoBrush textBrush);
    public ScaleTextScreenUnit get_ScreenUnit();
    public void set_ScreenUnit(ScaleTextScreenUnit value);
    public DistanceUnit get_WorldUnit();
    public void set_WorldUnit(DistanceUnit value);
    public GeoFont get_Font();
    public void set_Font(GeoFont value);
    public GeoBrush get_TextBrush();
    public void set_TextBrush(GeoBrush value);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private double IiE=(double amount, ScaleTextScreenUnit fromUnit, ScaleTextScreenUnit toUnit);
    private void ECE=(GeoCanvas canvas, GeographyUnit mapUnit);
}
public enum ThinkGeo.Core.ScaleTextScreenUnit : Enum {
    public int value__;
    public static ScaleTextScreenUnit Inch;
    public static ScaleTextScreenUnit Centimeter;
}
public class ThinkGeo.Core.ScreenPoint : ValueType {
    [ObfuscationAttribute]
private int x;
    [ObfuscationAttribute]
private int y;
    public int X { get; }
    public int Y { get; }
    public ScreenPoint(int x, int y);
    public int get_X();
    public int get_Y();
    public virtual string ToString();
    public static bool op_Equality(ScreenPoint screenPoint1, ScreenPoint screenPoint2);
    public static bool op_Inequality(ScreenPoint screenPoint1, ScreenPoint screenPoint2);
    public virtual bool Equals(object obj);
    private bool khU=(ScreenPoint compareObj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
public class ThinkGeo.Core.ScreenPointD : ValueType {
    [CompilerGeneratedAttribute]
private double Dhw=;
    [CompilerGeneratedAttribute]
private double Dxw=;
    public double X { get; }
    public double Y { get; }
    public ScreenPointD(double x, double y);
    [CompilerGeneratedAttribute]
public double get_X();
    [CompilerGeneratedAttribute]
public double get_Y();
    public virtual string ToString();
    public static bool op_Equality(ScreenPointD p1, ScreenPointD p2);
    public static bool op_Inequality(ScreenPointD p1, ScreenPointD p2);
    public virtual bool Equals(object obj);
    private bool khU=(ScreenPointF compareObj);
    public virtual int GetHashCode();
}
public class ThinkGeo.Core.ScreenPointF : ValueType {
    [ObfuscationAttribute]
private float x;
    [ObfuscationAttribute]
private float y;
    public float X { get; }
    public float Y { get; }
    public ScreenPointF(float x, float y);
    public float get_X();
    public float get_Y();
    public virtual string ToString();
    public static bool op_Equality(ScreenPointF screenPointF1, ScreenPointF screenPointF2);
    public static bool op_Inequality(ScreenPointF screenPointF1, ScreenPointF screenPointF2);
    public virtual bool Equals(object obj);
    private bool khU=(ScreenPointF compareObj);
    public virtual int GetHashCode();
}
public class ThinkGeo.Core.SendingHttpRequestMessageEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private HttpRequestMessage ViA=;
    [CompilerGeneratedAttribute]
private bool rBQ=;
    public HttpRequestMessage HttpRequestMessage { get; public set; }
    public bool Cancel { get; public set; }
    public SendingHttpRequestMessageEventArgs(HttpRequestMessage webRequest);
    public SendingHttpRequestMessageEventArgs(HttpRequestMessage webRequest, bool cancel);
    [CompilerGeneratedAttribute]
public HttpRequestMessage get_HttpRequestMessage();
    [CompilerGeneratedAttribute]
public void set_HttpRequestMessage(HttpRequestMessage value);
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
}
public class ThinkGeo.Core.SendingWebRequestEventArgs : EventArgs {
    [ObfuscationAttribute]
private WebRequest webRequest;
    [ObfuscationAttribute]
private bool cancel;
    public WebRequest WebRequest { get; public set; }
    public bool Cancel { get; public set; }
    public SendingWebRequestEventArgs(WebRequest webRequest);
    public SendingWebRequestEventArgs(WebRequest webRequest, bool cancel);
    public WebRequest get_WebRequest();
    public void set_WebRequest(WebRequest value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.SentWebRequestEventArgs : EventArgs {
    [ObfuscationAttribute]
private WebResponse response;
    public WebResponse Response { get; public set; }
    public SentWebRequestEventArgs(WebResponse response);
    public WebResponse get_Response();
    public void set_Response(WebResponse value);
}
public class ThinkGeo.Core.SerializerHelper : object {
    public static T SerializeCloneDeep(object instance);
    public static Byte[] Serialize(object instance);
    public static T Deserialize(Byte[] bytes);
}
public class ThinkGeo.Core.SessionFileRasterTileCache : FileRasterTileCache {
    [ObfuscationAttribute]
private Collection`1<string> obsoleteCacheIds;
    private static object jxY=;
    private Thread zh0=;
    public SessionFileRasterTileCache(string cacheDirectory);
    public SessionFileRasterTileCache(string cacheDirectory, string cacheId);
    public SessionFileRasterTileCache(string cacheDirectory, string cacheId, GeoImageFormat imageFormat);
    private static SessionFileRasterTileCache();
    protected virtual void ClearCacheCore();
    private void zx0=();
    private Collection`1<string> 0B0=();
}
public static class ThinkGeo.Core.ShapeConverter : object {
    [CompilerGeneratedAttribute]
private static EventHandler`1<ConvertedShapeToNtsGeometryShapeConverterEventArgs> EBw=;
    private static WkbByteOrder ERw=;
    private static WKBReader Ehw=;
    private static ShapeConverter();
    [CompilerGeneratedAttribute]
public static void add_ConvertedShapeToNtsGeometry(EventHandler`1<ConvertedShapeToNtsGeometryShapeConverterEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_ConvertedShapeToNtsGeometry(EventHandler`1<ConvertedShapeToNtsGeometryShapeConverterEventArgs> value);
    internal static BaseShape Exw=(Geometry targetJtsShape);
    internal static Geometry FBw=(BaseShape targetShape);
    internal static Geometry FBw=(Byte[] wkb);
    internal static void FRw=(WkbShapeType wkbShapeType, WkbByteOrder byteOrder, BinaryWriter writer);
    internal static void FRw=(int wkbShapeType, WkbByteOrder byteOrder, BinaryWriter writer);
    internal static void FRw=(double value, WkbByteOrder byteOrder, BinaryWriter writer);
    internal static BaseShape Fhw=(Byte[] wkb);
    private static BaseShape Fxw=(BinaryReader binaryReader);
    private static PointShape GBw=(BinaryReader binaryReader);
    private static Vertex GRw=(BinaryReader binaryReader);
    private static LineShape Ghw=(BinaryReader binaryReader);
    private static PolygonShape Dhs=(BinaryReader binaryReader);
    private static MultipointShape Gxw=(BinaryReader binaryReader);
    private static MultilineShape HBw=(BinaryReader binaryReader);
    private static GeometryCollectionShape HRw=(BinaryReader binaryReader);
    private static MultipolygonShape Hhw=(BinaryReader binaryReader);
    private static RingShape Hxw=(BinaryReader binaryReader);
    private static void IBw=(BinaryReader binaryReader);
    private static void IRw=(BinaryReader binaryReader, WkbShapeType wkbShapeType);
    private static int Ihw=(BinaryReader binaryReader);
    private static double Ixw=(BinaryReader binaryReader);
    internal static Vertex JBw=(string oneVertexWkt);
    internal static string JRw=(string oneVertexWkt, Vertex vertex);
}
[ObfuscationAttribute]
[ObfuscationAttribute]
internal class ThinkGeo.Core.ShapeFile : object {
    private static int CCQ=;
    private static int CSQ=;
    private static int CiQ=;
    private static int CyQ=;
    private static int DCQ=;
    private static int mh8=;
    [ObfuscationAttribute]
private string pathFilename;
    private bool oBo=;
    private Stream DSQ=;
    [ObfuscationAttribute]
private ShapeFileIndex shx;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Dh8=;
    private static Byte[] DiQ=;
    private static Byte[] DyQ=;
    public string EiQ= { get; public set; }
    public ShapeFileIndex FCQ= { get; }
    public ShapeFileType FiQ= { get; }
    public ShapeFile(string pathFilename);
    private static ShapeFile();
    [CompilerGeneratedAttribute]
public void nR8=(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void nh8=(EventHandler`1<StreamLoadingEventArgs> value);
    public string ECQ=();
    public void ESQ=(string value);
    public ShapeFileIndex EyQ=();
    public ShapeFileType FSQ=();
    public virtual void oB8=(StreamLoadingEventArgs e);
    public string FyQ=(int recordIndex);
    public int hB8=();
    public static void GCQ=(string pathFilename, ShapeFileType shapeType);
    private static void GSQ=(string pathFilename, ShapeFileType shapeType);
    public void FR8=(FileAccess readWriteMode);
    public void oR8=();
    public RectangleShape GiQ=();
    public ShapeFileType GyQ=();
    public RectangleShape HCQ=(int recordIndex);
    public void ySE=(BaseShape targetShape);
    public void fh8=(int recordIndex);
    public void yiE=(int index, BaseShape targetShape);
    public void fx8=();
    public void ox8=();
    public Byte[] HSQ=(int recordIndex);
    private Byte[] HiQ=(Byte[] dataBytes, int startIndex);
    private int HyQ=(BaseShape targetShape);
    private int ICQ=(MultipolygonShape targetShape, Stream stream);
    private static List`1<RingShape> ISQ=(MultipolygonShape targetShape);
    private int IiQ=(MultilineShape targetShape, Stream stream);
    private int IyQ=(MultipointShape targetShape, Stream stream);
    private static int JCQ=(PointShape targetShape, Stream stream);
    private static Byte[] phw=(Byte[] dataBytes, int startIndex);
    private static MultipolygonShape JSQ=(RingShape[] ringShapes);
    private static void JiQ=(RingShape innerRing, MultipolygonShape multiPolygonShape, List`1<RectangleShape> polygonBoundingBoxes);
    private static Byte[] JyQ=(MultipolygonShape multipolygon);
    private static Byte[] KCQ=(PolygonShape polygonShape);
    private static Byte[] pBw=(Byte[] dataBytes, int startIndex);
    private static Byte[] KSQ=(Byte[] dataBytes, int startIndex);
    private static Byte[] KiQ=(Byte[] dataBytes, int startIndex);
    private static Byte[] KyQ=(int partsCount, Byte[] dataBytes, int startIndex);
    private static void gB0=(Byte[] sourceArray, Byte[] destinateArray, long destinateIndex);
    private static int ORU=(Byte[] wkb, int startIndex, byte byteOrder);
    internal static int LCQ=(Stream stream, WkbByteOrder byteOrder);
    internal static void LSQ=(int value, Stream stream, WkbByteOrder byteOrder);
    private static void LiQ=(double value, Stream stream, WkbByteOrder byteOrder);
    internal static int LyQ=(ShapeFileType shapeFileType);
    private static ShapeFileBoundingBox MCQ=(RectangleShape rectangleShape);
    private static bool MSQ=(Vertex p, RingShape ring);
    private static int MiQ=(double x1, double y1, double x2, double y2);
    private static Byte[] MyQ=(Byte[] dataBytes, int startIndex);
    private static void NCQ=(Collection`1<IEA=> outerWkbRing, RectangleShape outerRingBoudingBox, Collection`1<IEA=> innerWkbRings, Collection`1<RectangleShape> innerRingsBoudingBoxes);
    private static bool NSQ=(IEA= innerWkbRing, RectangleShape innerRingsBoudingBox, Collection`1<Collection`1<IEA=>> outerWkbRings, Collection`1<RectangleShape> outerRingBoudingBoxes);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.ShapeFileBoundingBox : object {
    private static int NiQ=;
    private static int NyQ=;
    [ObfuscationAttribute]
private double minX;
    [ObfuscationAttribute]
private double maxX;
    [ObfuscationAttribute]
private double minY;
    [ObfuscationAttribute]
private double maxY;
    public double OiQ= { get; public set; }
    public double PSQ= { get; public set; }
    public double QCQ= { get; public set; }
    public double QyQ= { get; public set; }
    public double OCQ=();
    public void OSQ=(double value);
    public double OyQ=();
    public void PCQ=(double value);
    public double PiQ=();
    public void PyQ=(double value);
    public double QSQ=();
    public void QiQ=(double value);
    public static ShapeFileBoundingBox RCQ=(Stream stream);
    public void RSQ=(ShapeFileBoundingBox targetBox);
    public void RiQ=(Stream stream, bool isHeaderBoundingBox);
    private static Byte[] uBo=(double doubleValue, byte byteOrder);
    internal RectangleShape RyQ=();
}
public class ThinkGeo.Core.ShapeFileFeatureLayer : FeatureLayer {
    private static int SCQ=;
    [ObfuscationAttribute]
private int progressiveDrawingRecordsCount;
    public bool HasBoundingBox { get; }
    public bool UsingSpatialIndex { get; }
    public Encoding Encoding { get; public set; }
    public string ShapePathFilename { get; public set; }
    public string IndexPathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public bool RequireIndex { get; public set; }
    public int ProgressiveDrawingRecordsCount { get; public set; }
    public int SimplificationAreaInPixel { get; public set; }
    public ShapeFileFeatureLayer(string shapePathFilename);
    public ShapeFileFeatureLayer(string shapePathFilename, FileAccess readWriteMode);
    public ShapeFileFeatureLayer(string shapePathFilename, string indexPathFilename);
    public ShapeFileFeatureLayer(string shapePathFilename, string indexPathFilename, FileAccess readWriteMode);
    public ShapeFileFeatureLayer(string shapePathFilename, string indexPathFilename, FileAccess readWriteMode, Encoding encoding);
    public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public virtual bool get_HasBoundingBox();
    public bool get_UsingSpatialIndex();
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public string get_ShapePathFilename();
    public void set_ShapePathFilename(string value);
    public string get_IndexPathFilename();
    public void set_IndexPathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    public int get_ProgressiveDrawingRecordsCount();
    public void set_ProgressiveDrawingRecordsCount(int value);
    public int get_SimplificationAreaInPixel();
    public void set_SimplificationAreaInPixel(int value);
    protected virtual LayerBase CloneDeepCore();
    public static void Rebuild(string shapePathFilename);
    public static void Rebuild(string shapePathFilename, ShapeFileSortingMode sortingMode, int sridForSorting);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns, Encoding encoding);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns, Encoding encoding, OverwriteMode overwriteMode);
    public static void BuildIndexFile(string pathFilename);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string pathFilename, BuildIndexMode rebuildExistingIndexMode);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, ProjectionConverter projectionConverter);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, ProjectionConverter projectionConverter, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, string columnName, string regularExpression, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename);
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename, OverwriteMode overwriteMode);
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename, OverwriteMode overwriteMode, Encoding encoding);
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded);
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded, int startNumber);
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded, int startNumber, Encoding encoding);
    public ShapeFileType GetShapeFileType();
    public static void Reproject(string sourceShapeFile, string targetShapeFile, ProjectionConverter projectionConverter, OverwriteMode overwriteMode);
    public Dictionary`2<string, string> Validate();
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns);
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns, Encoding encoding);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames, Encoding encoding);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static BaseShape dSQ=(ShapeFileType shapeFileType, RectangleShape boundingBox);
    private void diQ=(GeoCanvas canvas, RectangleShape marginWorldExtent, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers, ZoomLevel currentZoomLevel, Collection`1<string> columnNames, ShapeFileFeatureSource shapeFileFeatureSource, Collection`1<RectangleShape> smallBoxes, Collection`1<string> ids);
    private void dyQ=(GeoCanvas canvas, RectangleShape drawingExtent, Collection`1<SimpleCandidate> labelsInAllLayers, ZoomLevel currentZoomLevel, Collection`1<string> columnNames, ShapeFileFeatureSource shapeFileFeatureSource, Collection`1<string> idsToDraw);
    private RectangleShape eCQ=(RectangleShape boundingBox);
    private bool WSQ=(int progressPercentage, object userState, int featuresToDraw, int featuresDrawn);
    private static void eSQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private static void eiQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private static void eyQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private void SyA=(object sender, DrawingProgressChangedEventArgs e);
    private static BaseShape qho=(ProjectionConverter projection, BaseShape shape);
}
public class ThinkGeo.Core.ShapeFileFeatureSource : FeatureSource {
    private static int SCQ=;
    private GeoDbf SSQ=;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    [ObfuscationAttribute]
private string indexPathFilename;
    [ObfuscationAttribute]
private bool requireIndex;
    private RtreeSpatialIndex wiE=;
    private ShapeFile SiQ=;
    private FileAccess SyQ=;
    [ObfuscationAttribute]
private string shapePathFilename;
    private Encoding ER8=;
    [ObfuscationAttribute]
private int codePage;
    [ObfuscationAttribute]
private int simplificationAreaInPixel;
    [ObfuscationAttribute]
private Collection`1<RectangleShape> simplifiedAreas;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Dh8=;
    [CompilerGeneratedAttribute]
private static EventHandler`1<BuildingIndexShapeFileFeatureSourceEventArgs> wSE=;
    [CompilerGeneratedAttribute]
private static EventHandler`1<RebuildingShapeFileFeatureSourceEventArgs> TCQ=;
    public string ShapePathFilename { get; public set; }
    public string IndexPathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public bool IsEditable { get; }
    public bool UsingSpatialIndex { get; }
    public bool RequireIndex { get; public set; }
    public Encoding Encoding { get; public set; }
    public int SimplificationAreaInPixel { get; public set; }
    public Collection`1<RectangleShape> SimplifiedAreas { get; }
    public ShapeFileFeatureSource(string shapePathFilename);
    public ShapeFileFeatureSource(string shapePathFilename, FileAccess readWriteMode);
    public ShapeFileFeatureSource(string shapePathFilename, string indexPathFilename);
    public ShapeFileFeatureSource(string shapePathFilename, string indexPathFilename, FileAccess readWriteMode);
    public ShapeFileFeatureSource(string shapePathFilename, string indexPathFilename, FileAccess readWriteMode, Encoding encoding);
    public string get_ShapePathFilename();
    public void set_ShapePathFilename(string value);
    public string get_IndexPathFilename();
    public void set_IndexPathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public virtual bool get_IsEditable();
    public bool get_UsingSpatialIndex();
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public int get_SimplificationAreaInPixel();
    public void set_SimplificationAreaInPixel(int value);
    public Collection`1<RectangleShape> get_SimplifiedAreas();
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_BuildingIndex(EventHandler`1<BuildingIndexShapeFileFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_BuildingIndex(EventHandler`1<BuildingIndexShapeFileFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_Rebuilding(EventHandler`1<RebuildingShapeFileFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_Rebuilding(EventHandler`1<RebuildingShapeFileFeatureSourceEventArgs> value);
    protected virtual FeatureSource CloneDeepCore();
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    protected static void OnBuildingIndex(BuildingIndexShapeFileFeatureSourceEventArgs e);
    protected static void OnRebuilding(RebuildingShapeFileFeatureSourceEventArgs e);
    public static void Rebuild(string shapePathFilename);
    public static void Rebuild(string shapePathFilename, ShapeFileSortingMode sortingMode, int sridForSorting);
    private static void TSQ=(string shapePathFilename, ShapeFileSortingMode sortingMode, int srid);
    public static void BuildIndexFile(string shapePathFilename);
    public static void BuildIndexFile(string shapePathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, string columnName, string regularExpression, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode, Encoding encoding);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, ProjectionConverter projectionConverter);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(IEnumerable`1<Feature> features, string indexPathFilename, ProjectionConverter projectionConverter, BuildIndexMode buildIndexMode);
    private static void TiQ=(BaseShape baseShape, RtreeSpatialIndex openedRtree, ProjectionConverter openedProjection);
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns);
    public static Collection`1<DbfColumn> GetValidColumns(IEnumerable`1<DbfColumn> columns, Encoding encoding);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames);
    public static Collection`1<string> GetValidColumnNames(IEnumerable`1<string> columnNames, Encoding encoding);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns, Encoding encoding);
    public static void CreateShapeFile(ShapeFileType shapeType, string pathFilename, IEnumerable`1<DbfColumn> databaseColumns, Encoding encoding, OverwriteMode overwriteMode);
    public Collection`1<DbfColumn> GetDbfColumns();
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename);
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename, OverwriteMode overwriteMode);
    public static void CloneShapeFileStructure(string sourceShapePathFilename, string targetShapePathFilename, OverwriteMode overwriteMode, Encoding encoding);
    public Dictionary`2<string, string> Validate();
    public void AddColumnBoolean(string columnName);
    public void AddColumnDate(string columnName);
    public void AddColumnDouble(string columnName, int totalLength, int precisionLength);
    public void AddColumnInteger(string columnName, int length);
    public void AddColumnMemo(string columnName);
    public void AddColumnMemo(string columnName, int memoValueLength);
    public void AddColumnString(string columnName, int length);
    public string GetDataFromDbf(string id, string columnName);
    public Dictionary`2<string, string> GetDataFromDbf(string id);
    public Dictionary`2<string, string> GetDataFromDbf(string id, IEnumerable`1<string> returningColumnNames);
    public Dictionary`2<string, string> GetDataFromDbf(string id, ReturningColumnsType returningColumnNamesType);
    public Collection`1<Dictionary`2<string, string>> GetDataFromDbf(IEnumerable`1<string> ids);
    public Collection`1<Dictionary`2<string, string>> GetDataFromDbf(IEnumerable`1<string> ids, string columnName);
    public Collection`1<Dictionary`2<string, string>> GetDataFromDbf(IEnumerable`1<string> ids, IEnumerable`1<string> columnNames);
    public Collection`1<Dictionary`2<string, string>> GetDataFromDbf(IEnumerable`1<string> ids, ReturningColumnsType returningColumnNamesType);
    public void UpdateDbfData(string id, string columnName, string value);
    public void UpdateDbfData(string id, IEnumerable`1<string> columnNames, IEnumerable`1<string> values);
    public ShapeFileType GetShapeFileType();
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded);
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded, int startNumber);
    public static void BuildRecordIdColumn(string shapeFilename, string fieldname, BuildRecordIdMode rebuildNeeded, int startNumber, Encoding encoding);
    public static void Reproject(string sourceShapeFile, string targetShapeFile, ProjectionConverter projectionConverter, OverwriteMode overwriteMode);
    private void TyQ=(string fieldName, int startNumber, bool fieldNameFound);
    protected virtual void OpenCore();
    private void UCQ=(FileAccess rTreeFileAccess);
    private void JR8=();
    private void USQ=();
    protected virtual void CloseCore();
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    private void UiQ=(TransactionBuffer transactions, TransactionResult transactionResult);
    private Collection`1<DbfColumn> UyQ=(Dictionary`2<string, FeatureSourceColumn> filteredEditColumns);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual RectangleShape GetBoundingBoxByIdCore(string id);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    public Collection`1<string> GetFeatureIdsForDrawing(RectangleShape boundingBox, double screenWidth, double screenHeight);
    protected virtual Collection`1<string> GetFeatureIdsForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    private static Byte[] VCQ=(RectangleShape rectangleShape);
    private static void VSQ=(Byte[] sourceBytes, Byte[] destinateBytes, int startIndex);
    private static bool ViQ=(PointShape upperLeftPoint, RectangleShape boundingBox, double screenFactorX, double screenFactorY);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual long GetCountCore();
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual Collection`1<DistinctColumnValue> GetDistinctColumnValuesCore(string columnName);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    private void VyQ=(object sender, StreamLoadingEventArgs e);
    private static void 9SM=(string idxPathFilename, WellKnownType wellKnownType);
    private static void 9SM=(string idxPathFilename, ShapeFileType shapeFileType);
    private void ySE=(Feature feature);
    private Dictionary`2<string, string> WCQ=(Dictionary`2<string, string> fieldValues);
    private void fh8=(int index);
    private void yiE=(Feature targetFeature);
    private bool WSQ=(int progressPercentage, object userState, int featuresToDraw, int featuresDrawn);
    private static void ByQ=(string pathFilename);
    private static void WiQ=(string sourcePathFilename, string targetPathFilename);
    private static bool WyQ=(IEnumerable`1<string> values);
    [OnGeodeserializedAttribute]
private void QBU=();
    private void XCQ=(FeatureSourceColumn column);
    private static DbfColumnType XSQ=(string columnTypeName);
    private Collection`1<int> XiQ=();
    private void XyQ=(Action`1<int> processById);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.ShapeFileHeader : object {
    private static int YCQ=;
    private static long YSQ=;
    private static int NiQ=;
    private static int NyQ=;
    private static int CSQ=;
    [ObfuscationAttribute]
private int fileCode;
    [ObfuscationAttribute]
private int fileLength;
    [ObfuscationAttribute]
private int version;
    [ObfuscationAttribute]
private ShapeFileBoundingBox boundingBox;
    [ObfuscationAttribute]
private ShapeFileType shapeFileType;
    public int ZCQ= { get; public set; }
    public ShapeFileType FiQ= { get; public set; }
    public ShapeFileBoundingBox aCQ= { get; public set; }
    public ShapeFileHeader(ShapeFileType shapeFileType);
    public int YiQ=();
    public void YyQ=(int value);
    public ShapeFileType FSQ=();
    public void ZSQ=(ShapeFileType value);
    public ShapeFileBoundingBox ZiQ=();
    public void ZyQ=(ShapeFileBoundingBox value);
    public static ShapeFileHeader aSQ=(Stream stream);
    public void aiQ=(Stream targetFileStream);
    private static ShapeFileType ayQ=(int value);
}
[ObfuscationAttribute]
internal class ThinkGeo.Core.ShapeFileIndex : object {
    private static int bCQ=;
    private static int bSQ=;
    private static int mh8=;
    [ObfuscationAttribute]
private string shxPathFilename;
    [ObfuscationAttribute]
private ShapeFileHeader fileHeader;
    private Stream biQ=;
    [ObfuscationAttribute]
private long startIndex;
    [ObfuscationAttribute]
private long endIndex;
    [ObfuscationAttribute]
private Byte[] cache;
    private bool oBo=;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Dh8=;
    public string cSQ= { get; public set; }
    public ShapeFileHeader lx8= { get; public set; }
    public ShapeFileIndex(string shxPathFilename);
    [CompilerGeneratedAttribute]
public void nR8=(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void nh8=(EventHandler`1<StreamLoadingEventArgs> value);
    public string byQ=();
    public void cCQ=(string value);
    public ShapeFileHeader lR8=();
    public void lh8=(ShapeFileHeader value);
    internal virtual void oB8=(StreamLoadingEventArgs e);
    public void FR8=();
    public void FR8=(FileAccess readWriteMode);
    public void oR8=();
    public int hB8=();
    public long ciQ=(int recordIndex);
    public void ox8=();
    public int cyQ=(int recordIndex);
    public void yiE=(int recordIndex, long offset, int contentLength);
    public void ySE=(long offset, int contentLength);
    private void dCQ=(int recordIndex, long offset, int contentLength);
    public void fh8=(int recordIndex);
    public void fx8=();
}
public enum ThinkGeo.Core.ShapeFileSortingMode : Enum {
    public int value__;
    public static ShapeFileSortingMode Default;
    public static ShapeFileSortingMode Geohash;
    public static ShapeFileSortingMode None;
}
public enum ThinkGeo.Core.ShapeFileType : Enum {
    public int value__;
    public static ShapeFileType Null;
    public static ShapeFileType Point;
    public static ShapeFileType Polyline;
    public static ShapeFileType Polygon;
    public static ShapeFileType Multipoint;
    public static ShapeFileType PointZ;
    public static ShapeFileType PolylineZ;
    public static ShapeFileType PolygonZ;
    public static ShapeFileType MultipointZ;
    public static ShapeFileType PointM;
    public static ShapeFileType PolylineM;
    public static ShapeFileType PolygonM;
    public static ShapeFileType MultipointM;
    public static ShapeFileType Multipatch;
}
public static class ThinkGeo.Core.ShapefileValidatorHelper : object {
    internal static void hCQ=(string pathFilename, string parameterName);
    internal static void hSQ=(ShapeFileBoundingBox shapeFileBoundingBox);
    public static void CheckSqlStatementIsSupported(string sqlStatement);
    public static void CheckShapeFileIsWriteable(FileAccess readWriteMode, string parameterName);
    public static void CheckShapeFileTypeIsValid(ShapeFileType shapeFileType, string parameterName);
    public static void CheckDbfColumnsAreEmpty(IEnumerable`1<DbfColumn> dbfColumns, string parameterName);
    public static void CheckShapeFileIsEditable(ShapeFileType shapeFileType, string parameterName);
    public static void CheckShapeFileTypeIsSupported(ShapeFileType shapeFileType, string parameterName);
}
public enum ThinkGeo.Core.ShapeValidationMode : Enum {
    public int value__;
    public static ShapeValidationMode Simple;
    public static ShapeValidationMode Advanced;
}
public class ThinkGeo.Core.ShapeValidationResult : ValueType {
    [ObfuscationAttribute]
private bool isValid;
    [ObfuscationAttribute]
private string validationErrors;
    public bool IsValid { get; }
    public string ValidationErrors { get; }
    public ShapeValidationResult(bool isValid, string validationErrors);
    public bool get_IsValid();
    public string get_ValidationErrors();
    public static bool op_Equality(ShapeValidationResult sourceShapeValidationResult, ShapeValidationResult targetShapeValidationResult);
    public static bool op_Inequality(ShapeValidationResult sourceShapeValidationResult, ShapeValidationResult targetShapeValidationResult);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ThinkGeo.Core.SimpleCandidate : object {
    [ObfuscationAttribute]
private string originalText;
    [ObfuscationAttribute]
private PolygonShape simplePolygonInScreenCoordinate;
    [ObfuscationAttribute]
private bool isAllowOverlapping;
    public string OriginalText { get; public set; }
    public PolygonShape SimplePolygonInScreenCoordinate { get; public set; }
    internal bool njE= { get; internal set; }
    public SimpleCandidate(string originalText, PolygonShape simplePolygonInScreenCoordinate);
    public string get_OriginalText();
    public void set_OriginalText(string value);
    public PolygonShape get_SimplePolygonInScreenCoordinate();
    public void set_SimplePolygonInScreenCoordinate(PolygonShape value);
    internal bool nDE=();
    internal void nTE=(bool value);
}
public class ThinkGeo.Core.SimpleFilterCondition : FilterCondition {
    private string zzE=;
    private SimpleFilterConditionType 0DE=;
    private static Dictionary`2<SimpleFilterConditionType, Tuple`2<string, string>> 0TE=;
    public string MatchValue { get; public set; }
    public SimpleFilterConditionType MatchType { get; public set; }
    private static SimpleFilterCondition();
    public SimpleFilterCondition(string columnName, SimpleFilterConditionType matchType, string matchValue);
    public string get_MatchValue();
    public void set_MatchValue(string value);
    public SimpleFilterConditionType get_MatchType();
    public void set_MatchType(SimpleFilterConditionType value);
    protected virtual Collection`1<Feature> GetMatchingFeaturesCore(IEnumerable`1<Feature> features);
    private void 0jE=();
}
[ObfuscationAttribute]
public enum ThinkGeo.Core.SimpleFilterConditionType : Enum {
    public int value__;
    public static SimpleFilterConditionType Equal;
    public static SimpleFilterConditionType Contains;
    public static SimpleFilterConditionType StartsWith;
    public static SimpleFilterConditionType EndsWith;
    public static SimpleFilterConditionType DoesNotEqual;
    public static SimpleFilterConditionType DoesNotContain;
    public static SimpleFilterConditionType GreaterThan;
    public static SimpleFilterConditionType GreaterThanOrEqualTo;
    public static SimpleFilterConditionType LessThan;
    public static SimpleFilterConditionType LessThanOrEqualTo;
    public static SimpleFilterConditionType IsEmpty;
    public static SimpleFilterConditionType IsNotEmpty;
}
public enum ThinkGeo.Core.SimplificationType : Enum {
    public int value__;
    public static SimplificationType TopologyPreserving;
    public static SimplificationType DouglasPeucker;
}
public class ThinkGeo.Core.SkiaGeoCanvas : GeoCanvas {
    [ObfuscationAttribute]
private GeoImage[] bufferImages;
    [ObfuscationAttribute]
private XBU=[] graphicses;
    public bool SupportKeyColor { get; }
    public virtual bool get_SupportKeyColor();
    protected virtual void BeginDrawingCore(object nativeImage, RectangleShape worldExtent, GeographyUnit drawingMapUnit);
    private XBU= VBU=(int i);
    private GeoImage VRU=(int i);
    protected virtual void DrawArcCore(GeoPen pen, float x, float y, float width, float height, float startAngle, float sweepAngle, DrawingLevel drawingLevel);
    protected virtual void DrawAreaCore(IEnumerable`1<ScreenPointF[]> screenPoints, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    protected virtual void DrawEllipseCore(ScreenPointF screenPoint, float width, float height, GeoPen outlinePen, GeoBrush fillBrush, DrawingLevel drawingLevel, float xOffset, float yOffset, PenBrushDrawingOrder penBrushDrawingOrder);
    protected virtual void DrawLineCore(IEnumerable`1<ScreenPointF> screenPoints, GeoPen linePen, DrawingLevel drawingLevel, float xOffset, float yOffset);
    protected virtual void DrawScreenImageCore(GeoImage image, float centerXInScreen, float centerYInScreen, float widthInScreen, float heightInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    protected virtual void DrawScreenImageWithoutScalingCore(GeoImage image, float centerXInScreen, float centerYInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, float rotateAngle);
    protected virtual void DrawTextCore(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, DrawingLevel drawingLevel, float xOffset, float yOffset, DrawingTextAlignment drawingTextAlignment, float rotateAngle);
    private static void VhU=(string text, GeoFont font, GeoBrush fillBrush, GeoPen haloPen, IEnumerable`1<ScreenPointF> textPathInScreen, float xOffset, float yOffset, DrawingTextAlignment drawingTextAlignment, float rotateAngle, XBU= graphics, DrawingRectangleF rectangle);
    protected virtual void EndDrawingCore();
    private void VxU=(GeoImage geoImage);
    private void WBU=(GeoImage geoImage, GeoColor keyColor);
    protected virtual void FlushCore();
    protected virtual float GetCanvasHeightCore();
    protected virtual float GetCanvasWidthCore();
    protected virtual DrawingRectangleF MeasureTextCore(string text, GeoFont font);
    internal virtual float OxU=(GeoFont font, DrawingTextBaseline textBaseline, string text);
    internal void WRU=(GeoImage image, int srcX, int srcY, int srcWidth, int srcHeight, lxU=[] colors, DrawingLevel drawingLevel);
    internal void WhU=(ScreenPointF centerPoint, int radius, Single[] positions, GeoColor[] colors, DrawingLevel drawingLevel);
    private SKFilterQuality WxU=(DrawingQuality drawingQuality);
}
public abstract class ThinkGeo.Core.SpatialIndex : object {
    private bool oBo=;
    [ObfuscationAttribute]
private bool canDelete;
    public bool IsOpen { get; }
    public bool CanDelete { get; protected set; }
    protected bool IsOpenCore { get; protected set; }
    public bool get_IsOpen();
    public bool get_CanDelete();
    protected void set_CanDelete(bool value);
    protected virtual bool get_IsOpenCore();
    protected virtual void set_IsOpenCore(bool value);
    public void Add(BaseShape baseShape);
    public void Add(Feature feature);
    protected abstract virtual void AddCore(Feature feature);
    public void Delete(Feature feature);
    public void Delete(BaseShape baseShape);
    protected virtual void DeleteCore(Feature feature);
    public void Close();
    protected virtual void CloseCore();
    public int GetFeatureCount();
    protected virtual int GetFeatureCountCore();
    public Collection`1<string> GetFeatureIdsIntersectingBoundingBox(RectangleShape boundingBox);
    protected abstract virtual Collection`1<string> GetFeatureIdsIntersectingBoundingBoxCore(RectangleShape boundingBox);
    public void Open();
    protected virtual void OpenCore();
}
public class ThinkGeo.Core.SphericalKrigingGridInterpolationModel : KrigingGridInterpolationModel {
    public SphericalKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points);
    public SphericalKrigingGridInterpolationModel(IDictionary`2<PointShape, double> points, int numberOfRefrencedPoints);
    protected virtual double GetSemivarianceCore(double distance, EmpiricalFunctionCoefficients coefficients);
    protected virtual double GetSillSlopeCore(double distance, double range);
}
public class ThinkGeo.Core.SphericalMercatorZoomLevelSet : ZoomLevelSet {
    public SphericalMercatorZoomLevelSet(int tileSize);
    public SphericalMercatorZoomLevelSet(int tileSize, RectangleShape maxExtent);
}
public enum ThinkGeo.Core.SplineType : Enum {
    public int value__;
    public static SplineType Default;
    public static SplineType None;
    public static SplineType StandardSplining;
    public static SplineType ForceSplining;
}
public class ThinkGeo.Core.SqliteColumn : FeatureSourceColumn {
    [ObfuscationAttribute]
private SqliteColumnType columnType;
    public SqliteColumnType ColumnType { get; public set; }
    public SqliteColumn(string columnName, SqliteColumnType columnType);
    public SqliteColumnType get_ColumnType();
    public void set_ColumnType(SqliteColumnType value);
}
public enum ThinkGeo.Core.SqliteColumnType : Enum {
    public int value__;
    public static SqliteColumnType Null;
    public static SqliteColumnType Integer;
    public static SqliteColumnType Real;
    public static SqliteColumnType Text;
    public static SqliteColumnType Blob;
    public static SqliteColumnType Numeric;
}
[DebuggerNonUserCodeAttribute]
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[ObfuscationAttribute]
[CompilerGeneratedAttribute]
internal class ThinkGeo.Core.SqliteExceptionDescription : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ColumnNameNotExist { get; }
    internal static string ConnectionStringCannotBeNull { get; }
    internal static string FeatureIdColumnNotExist { get; }
    internal static string FeatureSourceCanNotExecuteSqlQuery { get; }
    internal static string FeatureSourceIsNotInTransaction { get; }
    internal static string FeatureSourceIsNotOpen { get; }
    internal static string GeometryColumnNotExist { get; }
    internal static string InvalidSrid { get; }
    internal static string ParameterIsInvalid { get; }
    internal static string ParameterIsNull { get; }
    internal static string ParameterIsNullOrEmpty { get; }
    internal static string SqliteDatabaseIsReadOnly { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ColumnNameNotExist();
    internal static string get_ConnectionStringCannotBeNull();
    internal static string get_FeatureIdColumnNotExist();
    internal static string get_FeatureSourceCanNotExecuteSqlQuery();
    internal static string get_FeatureSourceIsNotInTransaction();
    internal static string get_FeatureSourceIsNotOpen();
    internal static string get_GeometryColumnNotExist();
    internal static string get_InvalidSrid();
    internal static string get_ParameterIsInvalid();
    internal static string get_ParameterIsNull();
    internal static string get_ParameterIsNullOrEmpty();
    internal static string get_SqliteDatabaseIsReadOnly();
}
public class ThinkGeo.Core.SqliteFeatureLayer : FeatureLayer {
    public bool HasBoundingBox { get; }
    public int CommandTimeout { get; public set; }
    public string ConnectionString { get; public set; }
    public string TableName { get; public set; }
    public string FeatureIdColumn { get; public set; }
    public string GeometryColumnName { get; public set; }
    public string WhereClause { get; public set; }
    public SqliteFeatureLayer(string connectionString, string tableName, string featureIdColumn, string geometryColumnName);
    public SqliteFeatureLayer(SqliteConnection connection, string tableName, string featureIdeColumn, string geometryColumnName);
    public virtual bool get_HasBoundingBox();
    public int get_CommandTimeout();
    public void set_CommandTimeout(int value);
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
    public string get_TableName();
    public void set_TableName(string value);
    public string get_FeatureIdColumn();
    public void set_FeatureIdColumn(string value);
    public string get_GeometryColumnName();
    public void set_GeometryColumnName(string value);
    public WellKnownType GetFirstGeometryType();
    public string get_WhereClause();
    public void set_WhereClause(string value);
    public int ExecuteNonQuery(string sqlStatement);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.SqliteFeatureSource : FeatureSource {
    private static int queryInside;
    private static int queryOutside;
    [ObfuscationAttribute]
private string connectionString;
    [ObfuscationAttribute]
private string tableName;
    [ObfuscationAttribute]
private string geometryColumn;
    [ObfuscationAttribute]
private string featureIdColumn;
    [ObfuscationAttribute]
private int commandTimeout;
    [ObfuscationAttribute]
private bool isConnectionFromUser;
    private SqliteConnection userConnection;
    private Collection`1<FeatureSourceColumn> featureSourceColumns;
    [ObfuscationAttribute]
private string whereClause;
    [ObfuscationAttribute]
private double fetchTime;
    [ObfuscationAttribute]
private int drawnFeatureCount;
    [ObfuscationAttribute]
private int totalBytesDrawn;
    [ObfuscationAttribute]
private string alternateGeometryIndexTableName;
    [ObfuscationAttribute]
private bool isEditable;
    private bool isEditableChecked;
    [CompilerGeneratedAttribute]
private EventHandler`1<ExecutingSqlStatementSqliteFeatureSourceEventArgs> ExecutingSqlStatement;
    protected bool CanExecuteSqlQueryCore { get; }
    public double FetchTime { get; public set; }
    public int DrawnFeatureCount { get; public set; }
    public int TotalBytesDrawn { get; public set; }
    public string WhereClause { get; public set; }
    public int CommandTimeout { get; public set; }
    public string GeometryColumnName { get; public set; }
    public string ConnectionString { get; public set; }
    public string TableName { get; public set; }
    public string FeatureIdColumn { get; public set; }
    public bool IsEditable { get; }
    public string AlternateGeometryIndexTableName { get; public set; }
    public SqliteFeatureSource(string connectionString, string tableName, string featureIdColumn, string geometryColumnName);
    public SqliteFeatureSource(SqliteConnection connection, string tableName, string featureIdColumn, string geometryColumnName);
    public SqliteFeatureSource(SqliteConnection connection, string tableName);
    public SqliteFeatureSource(string connectionString, string tableName);
    private SqliteFeatureSource(SqliteConnection connection, string connectionString, string tableName, string featureIdColumn, string geometryColumnName);
    [CompilerGeneratedAttribute]
public void add_ExecutingSqlStatement(EventHandler`1<ExecutingSqlStatementSqliteFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ExecutingSqlStatement(EventHandler`1<ExecutingSqlStatementSqliteFeatureSourceEventArgs> value);
    public static void CreateTable(SqliteConnection connection, string tableName, IEnumerable`1<SqliteColumn> nonGeometryColumns, GeographyUnit unit);
    public static void CreateTable(string connectionString, string tableName, IEnumerable`1<SqliteColumn> nonGeometryColumns, GeographyUnit unit);
    protected virtual void OnExecutingSqlStatement(ExecutingSqlStatementSqliteFeatureSourceEventArgs e);
    public static void CreateView(SqliteConnection connection, string viewName, string createViewSql, string featureIdColumn, GeographyUnit unit, string geometryColumnName);
    public static void CreateView(SqliteConnection connection, string viewName, string createViewSql, string featureIdColumn, GeographyUnit unit);
    public static void CreateView(string connectionString, string viewName, string createViewSql, string featureIdColumn, GeographyUnit unit);
    protected virtual bool get_CanExecuteSqlQueryCore();
    public double get_FetchTime();
    public void set_FetchTime(double value);
    public int get_DrawnFeatureCount();
    public void set_DrawnFeatureCount(int value);
    public int get_TotalBytesDrawn();
    public void set_TotalBytesDrawn(int value);
    public string get_WhereClause();
    public void set_WhereClause(string value);
    public int get_CommandTimeout();
    public void set_CommandTimeout(int value);
    public string get_GeometryColumnName();
    public void set_GeometryColumnName(string value);
    public string get_ConnectionString();
    public void set_ConnectionString(string value);
    public string get_TableName();
    public void set_TableName(string value);
    public string get_FeatureIdColumn();
    public void set_FeatureIdColumn(string value);
    public virtual bool get_IsEditable();
    public string get_AlternateGeometryIndexTableName();
    public void set_AlternateGeometryIndexTableName(string value);
    private string GetGeometryIndexTableName();
    protected virtual int ExecuteNonQueryCore(string sqlStatement);
    public static void CreateDatabase(string databasePathFilename);
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    private bool IsView();
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> columnNames);
    public static Collection`1<string> GetColumnNames(string connectionString, string tableName);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    protected virtual DataTable ExecuteQueryCore(string sqlStatement);
    public static Collection`1<string> GetTableNames(string connectionString);
    private string QuoteColumnName(string columnName);
    private string GetSpatialQueryCondition(int queryType, RectangleShape boundingBox);
    private string BuildSelectColumnsString(IEnumerable`1<string> columnNames);
    private Feature GetFeature(SqliteDataReader dataReader, IEnumerable`1<string> columnNames);
    public static bool CreateSpatialIndex(SqliteConnection SqliteConnection, string tableName, string geometryColumnName, int srid);
    private Feature GetFeature(SqliteDataReader dataReader);
    private string SanitizeParameterNames(string parameterName);
    private void ProcessAddBuffer(Dictionary`2<string, Feature> addBuffer, TransactionResult result, SqliteConnection connection);
    private static string ReplaceNulls(string value);
    private void ProcessDeleteBuffer(Collection`1<string> deleteBuffer, TransactionResult transactionResult, SqliteConnection connection);
    private void ProcessEditBuffer(Dictionary`2<string, Feature> editBuffer, TransactionResult transactionResult, SqliteConnection connection);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    protected virtual Collection`1<string> GetFeatureIdsInsideBoundingBoxCore(RectangleShape boundingBox);
    private Collection`1<Feature> GetFeaturesByBoundingBox(BaseShape targetShape, int queryType, IEnumerable`1<string> returningColumnNames);
    private SqliteCommand GetNewCommand(string sqlStatement, ExecutingSqlStatementType sqlStatementType, SqliteConnection& connection, RectangleShape boundingBox);
}
internal class ThinkGeo.Core.SqliteRasterTileCache : RasterTileCache {
    [ObfuscationAttribute]
private string databasePathFilename;
    public string DatabasePathFilename { get; public set; }
    public string CacheId { get; public set; }
    public SqliteRasterTileCache(string databasePathFilename, string cacheId);
    public string get_DatabasePathFilename();
    public void set_DatabasePathFilename(string value);
    public virtual string get_CacheId();
    public virtual void set_CacheId(string value);
    protected virtual Tile GetTileCore(int zoom, long column, long row);
    protected virtual void ClearCacheCore();
    protected virtual void SaveTileCore(Tile tile);
    protected virtual void DeleteTileCore(Tile tile);
    private SqliteConnection GetConnection();
    private void CheckCacheId();
}
public static class ThinkGeo.Core.SqliteValidatorHelper : object {
    public static void CheckFeatureSourceIsInTransaction(bool isInTransaction);
    public static void CheckParameterIsValid(BaseShape BasheShapeToTest, string parameterName);
    public static void CheckFeatureSourceIsOpen(bool isOpen);
    public static void CheckParameterIsNotNullOrEmpty(string value, string parameterName);
    public static bool CheckIsEmptyOrNull(IEnumerable`1<string> values);
    public static void CheckFeatureSourceCanExecuteSqlQuery(bool canExecuteSqlQuery);
    public static void CheckFeatureIdAndGeometryColumn(string connectionString, string tableName, string featureIdColumn, string geometryColumnName);
}
public enum ThinkGeo.Core.StartingPoint : Enum {
    public int value__;
    public static StartingPoint FirstPoint;
    public static StartingPoint LastPoint;
}
internal enum ThinkGeo.Core.State : Enum {
    public int value__;
    public static State Start;
    public static State Complete;
    public static State Property;
    public static State ObjectStart;
    public static State Object;
    public static State ArrayStart;
    public static State Array;
    public static State Closed;
    public static State PostValue;
    public static State ConstructorStart;
    public static State Constructor;
    public static State Error;
    public static State Finished;
}
public class ThinkGeo.Core.StreamLoadingEventArgs : EventArgs {
    [ObfuscationAttribute]
private string alternateStreamName;
    private Stream RyA=;
    [ObfuscationAttribute]
private FileMode fileMode;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    [ObfuscationAttribute]
private string streamType;
    public string AlternateStreamName { get; public set; }
    public Stream AlternateStream { get; public set; }
    public FileMode FileMode { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public string StreamType { get; }
    public StreamLoadingEventArgs(string alternateStreamName, string streamType);
    public StreamLoadingEventArgs(string alternateStreamName, Stream alternateStream, FileMode fileMode, FileAccess readWriteMode);
    public StreamLoadingEventArgs(string alternateStreamName, string streamType, Stream alternateStream, FileMode fileMode, FileAccess readWriteMode);
    public string get_AlternateStreamName();
    public void set_AlternateStreamName(string value);
    public Stream get_AlternateStream();
    public void set_AlternateStream(Stream value);
    public FileMode get_FileMode();
    public void set_FileMode(FileMode value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public string get_StreamType();
}
internal class ThinkGeo.Core.StringBuffer : ValueType {
    [ObfuscationAttribute]
private Char[] _buffer;
    [ObfuscationAttribute]
private int _position;
    public int Position { get; public set; }
    public bool IsEmpty { get; }
    public Char[] InternalBuffer { get; }
    public StringBuffer(int initalSize);
    private StringBuffer(Char[] buffer);
    public int get_Position();
    public void set_Position(int value);
    public bool get_IsEmpty();
    public void Append(char value);
    public void Append(Char[] buffer, int startIndex, int count);
    public void Clear();
    private void EnsureSize(int appendLength);
    public virtual string ToString();
    public string ToString(int start, int length);
    public Char[] get_InternalBuffer();
}
[IsReadOnlyAttribute]
internal class ThinkGeo.Core.StringReference : ValueType {
    private Char[] _chars;
    private int _startIndex;
    private int _length;
    public Char[] Chars { get; }
    public int StartIndex { get; }
    public int Length { get; }
    public StringReference(Char[] chars, int startIndex, int length);
    public Char[] get_Chars();
    public int get_StartIndex();
    public int get_Length();
    public virtual string ToString();
}
public abstract class ThinkGeo.Core.Style : object {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private Collection`1<string> filters;
    [ObfuscationAttribute]
private bool isActive;
    [ObfuscationAttribute]
private Collection`1<string> requiredColumnNames;
    public string Name { get; public set; }
    public bool IsActive { get; public set; }
    internal bool ohU= { get; }
    public Collection`1<string> RequiredColumnNames { get; }
    public Collection`1<string> Filters { get; }
    protected Collection`1<string> FiltersCore { get; }
    public string get_Name();
    public void set_Name(string value);
    public bool get_IsActive();
    public void set_IsActive(bool value);
    internal virtual bool oBU=();
    public Collection`1<string> get_RequiredColumnNames();
    public Collection`1<string> get_Filters();
    protected virtual Collection`1<string> get_FiltersCore();
    public Style CloneDeep();
    protected virtual Style CloneDeepCore();
    public void Draw(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    public void Draw(IEnumerable`1<BaseShape> shapes, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected abstract virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    public Collection`1<FeatureLabelingCandidate> DrawWithoutLabeling(IEnumerable`1<Feature> features, GeoCanvas canvas);
    protected virtual Collection`1<FeatureLabelingCandidate> DrawWithoutLabelingCore(IEnumerable`1<Feature> features, GeoCanvas canvas);
    public Collection`1<string> GetRequiredColumnNames();
    internal static void 9DA=(string content, char start, char end, Action`1<string> oneParsed);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    public void DrawSample(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    public void DrawSample(GeoCanvas canvas);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    public void SaveStyle(string filePathName);
    public void SaveStyle(Stream stream);
    public static Style LoadStyle(Uri styleUri);
    public static Style LoadStyle(Stream styleStream);
}
internal class ThinkGeo.Core.StyleJsonDocument : object {
    internal Dictionary`2<int, Collection`1<StyleJsonStyle>> styles;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, GeoColor> <BackgroundForZooms>k__BackingField;
    [CompilerGeneratedAttribute]
private GeoColor <globalBackground>k__BackingField;
    internal static string versionKey;
    private double version;
    internal Dictionary`2<int, GeoColor> BackgroundForZooms { get; internal set; }
    internal GeoColor globalBackground { get; internal set; }
    public double Version { get; private set; }
    [CompilerGeneratedAttribute]
internal Dictionary`2<int, GeoColor> get_BackgroundForZooms();
    [CompilerGeneratedAttribute]
internal void set_BackgroundForZooms(Dictionary`2<int, GeoColor> value);
    [CompilerGeneratedAttribute]
internal GeoColor get_globalBackground();
    [CompilerGeneratedAttribute]
internal void set_globalBackground(GeoColor value);
    public double get_Version();
    private void set_Version(double value);
    public static StyleJsonDocument Load(string styleJsonPathFileName);
    public static StyleJsonDocument Load(Uri styleJsonUri);
    public static StyleJsonDocument Parse(Byte[] styleJsonBytes);
    public void ApplyStyleJsonToZoomLevel(ZoomLevelSet zoomLevelSet);
    public void ApplyBackgroundToZoomLevel(ZoomLevelSet zoomLevelSet);
}
public class ThinkGeo.Core.StyleJsonItem : object {
    private Collection`1<FilterCondition> /DE=;
    [ObfuscationAttribute]
private Style style;
    [ObfuscationAttribute]
private FilterApplyMode filterApplyMode;
    public Style Style { get; public set; }
    public Collection`1<FilterCondition> Filters { get; }
    public FilterApplyMode FilterApplyMode { get; public set; }
    public StyleJsonItem(Style style);
    public StyleJsonItem(Style style, IEnumerable`1<FilterCondition> filters);
    public Style get_Style();
    public void set_Style(Style value);
    public Collection`1<FilterCondition> get_Filters();
    public FilterApplyMode get_FilterApplyMode();
    public void set_FilterApplyMode(FilterApplyMode value);
    public Collection`1<Feature> GetMatchedFeatures(IEnumerable`1<Feature> features);
}
public class ThinkGeo.Core.StyleJsonStyle : Style {
    private Collection`1<StyleJsonItem> /TE=;
    [CompilerGeneratedAttribute]
private string /jE=;
    public string ZIndexColumn { get; public set; }
    public Collection`1<StyleJsonItem> StyleJsonItems { get; }
    public StyleJsonStyle(string zIndexColumn);
    [CompilerGeneratedAttribute]
public string get_ZIndexColumn();
    [CompilerGeneratedAttribute]
public void set_ZIndexColumn(string value);
    public Collection`1<StyleJsonItem> get_StyleJsonItems();
    private Dictionary`2<int, Dictionary`2<Style, Collection`1<Feature>>> /zE=(GeoCanvas canvas, iBw= styleJsonFeatures);
    protected virtual Collection`1<FeatureLabelingCandidate> DrawWithoutLabelingCore(IEnumerable`1<Feature> features, GeoCanvas canvas);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    [CompilerGeneratedAttribute]
private int ADI=(Feature f);
}
public class ThinkGeo.Core.TabDbfColumn : DbfColumn {
    [ObfuscationAttribute]
private bool buildIndex;
    [ObfuscationAttribute]
private bool uniqueIndexColumnValues;
    public bool BuildIndex { get; public set; }
    public bool UniqueIndexColumnValues { get; public set; }
    public TabDbfColumn(string columnName, DbfColumnType columnType, int length, int decimalLength, bool buildIndex, bool uniqueIndexColumnValues);
    public bool get_BuildIndex();
    public void set_BuildIndex(bool value);
    public bool get_UniqueIndexColumnValues();
    public void set_UniqueIndexColumnValues(bool value);
}
public class ThinkGeo.Core.TabFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private TabStylingType stylingType;
    [ObfuscationAttribute]
private STRtree`1<string> rTree;
    [ObfuscationAttribute]
private Dictionary`2<string, KeyValuePair`2<Feature, IEnumerable`1<Style>>> featuresDics;
    public string TabPathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public bool HasBoundingBox { get; }
    public TabStylingType StylingType { get; public set; }
    public bool RequireIndex { get; public set; }
    public Encoding Encoding { get; public set; }
    public TabFeatureLayer(string tabPathFilename);
    public TabFeatureLayer(string tabPathFilename, FileAccess readWriteMode);
    public string get_TabPathFilename();
    public void set_TabPathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public virtual bool get_HasBoundingBox();
    public TabStylingType get_StylingType();
    public void set_StylingType(TabStylingType value);
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    protected virtual LayerBase CloneDeepCore();
    internal static WkbShapeType lBw=(Byte[] wkb, int startIndex);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features, OverwriteMode overwriteMode);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features, OverwriteMode overwriteMode, Encoding encoding);
    public static void BuildIndexFile(string tabPathFilename);
    public static void BuildIndexFile(string tabPathFilename, BuildIndexMode buildIndexMode);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode, int startNumber);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode, int startNumber, Encoding encoding);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private STRtree`1<string> oSs=(Dictionary`2<Feature, IEnumerable`1<Style>> cadFeatureStyles);
}
public class ThinkGeo.Core.TabFeatureSource : FeatureSource {
    private fCU= fSs=;
    private STRtree`1<string> fis=;
    [ObfuscationAttribute]
private RtreeSpatialIndex rTreeIndex;
    [ObfuscationAttribute]
private bool requireIndex;
    [ObfuscationAttribute]
private string tabPathFilename;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    [ObfuscationAttribute]
private Encoding encoding;
    public string TabPathFilename { get; public set; }
    public FileAccess ReadWriteMode { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool IsEditable { get; }
    public bool RequireIndex { get; public set; }
    public TabFeatureSource(string tabPathFilename);
    public TabFeatureSource(string tabPathFilename, FileAccess readWriteMode);
    public string get_TabPathFilename();
    public void set_TabPathFilename(string value);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public virtual bool get_IsEditable();
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual long GetCountCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<string> GetFeatureIdsCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    internal void fys=(hCo= proj);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    private List`1<TabDbfColumn> gCs=(TransactionBuffer transactions, TransactionResult transactionResult);
    private Feature gSs=(hSg= tabFeature);
    private static PointShape gis=(QCo= tabPoint);
    private static MultipointShape gys=(NSo= tabMultiPoint);
    private static LineBaseShape hCs=(gCo= tabPolyline);
    private static LineShape hSs=(FSg= tabArc);
    private static PolygonShape his=(7So= tabRegion);
    private static EllipseShape hys=(hCg= tabEllipse);
    private void UCQ=();
    private TabDbfColumn iCs=(int index);
    public static void BuildIndexFile(string tabPathFilename);
    public static void BuildIndexFile(string tabPathFilename, BuildIndexMode buildIndexMode);
    private static void zSE=(string tabPathFilename, ProjectionConverter projection, BuildIndexMode buildIndexMode);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features, OverwriteMode overwriteMode);
    public static void CreateTabFile(string tabPathFilename, IEnumerable`1<TabDbfColumn> databaseColumns, IEnumerable`1<Feature> features, OverwriteMode overwriteMode, Encoding encoding);
    internal hCo= iSs=();
    private static void iis=(string pathFilename, IEnumerable`1<TabDbfColumn> columns, IEnumerable`1<Feature> features, OverwriteMode overwriteMode, eys= tabFileType, string mifProjection, double north, double south, double east, double west, Encoding encoding);
    private static void iys=(fCU= mapInfoFile, TabDbfColumn column);
    private static void jCs=(fCU= mapInfoFile, Feature feature);
    private static void ByQ=(string path);
    private static void WiQ=(string sourceFileName, string targetFileName);
    private static hSg= jSs=(fCU= mapInfoFile, Feature feature);
    private static hSg= jis=(fCU= mapInfoFile, Feature feature);
    private static hSg= jys=(fCU= mapInfoFile, Feature feature);
    private static hSg= kCs=(fCU= mapInfoFile, Feature feature);
    private static Collection`1<hSg=> kSs=(fCU= mapInfoFile, Feature feature);
    private static void kis=(fCU= mapInfoFile, hSg= tabFeature, Feature feature);
    private static hSg= kys=(fCU= mapInfoFile, Feature feature);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode, int startNumber);
    public static void BuildRecordIdColumn(string tabFileName, string fieldName, BuildRecordIdMode buildRecordIdMode, int startNumber, Encoding encoding);
    internal Dictionary`2<Feature, IEnumerable`1<Style>> lCs=();
    internal void lSs=();
    public void SetEmbeddedSymbolStyle(Feature feature, PointStyle pointStyle);
    public void SetEmbeddedPenStyle(Feature feature, LineStyle lineStyle);
    public void SetEmbeddedBrushStyle(Feature feature, AreaStyle areaStyle);
    public void SetEmbeddedTextStyle(Feature feature, TextStyle textStyle);
    private int lis=(GeoColor color);
    private Collection`1<Style> lys=(hSg= tabFeature, Feature feature, WellKnownType wellKnownType);
    private DbfColumnType mCs=(string typeName);
}
public enum ThinkGeo.Core.TabStylingType : Enum {
    public int value__;
    public static TabStylingType EmbeddedStyling;
    public static TabStylingType StandardStyling;
}
public enum ThinkGeo.Core.TextPlacement : Enum {
    public int value__;
    public static TextPlacement Default;
    public static TextPlacement UpperLeft;
    public static TextPlacement Upper;
    public static TextPlacement UpperRight;
    public static TextPlacement Right;
    public static TextPlacement Center;
    public static TextPlacement Left;
    public static TextPlacement LowerLeft;
    public static TextPlacement Lower;
    public static TextPlacement LowerRight;
    public static TextPlacement AutoPlacement;
}
public class ThinkGeo.Core.TextStyle : PositionStyle {
    private static double 1DE=;
    private static int 1TE=;
    private static double 1jE=;
    public float XOffsetInPixel { get; public set; }
    public float YOffsetInPixel { get; public set; }
    public bool FittingLineInScreen { get; public set; }
    public bool FittingPolygonInScreen { get; public set; }
    public Collection`1<TextStyle> CustomTextStyles { get; }
    public double RotationAngle { get; public set; }
    public string TextFormat { get; public set; }
    public string NumericFormat { get; public set; }
    public string DateFormat { get; public set; }
    public GeoBrush TextBrush { get; public set; }
    public GeoFont Font { get; public set; }
    public GeoPen HaloPen { get; public set; }
    public string TextColumnName { get; public set; }
    public AreaStyle Mask { get; public set; }
    public DrawingMargin MaskMargin { get; public set; }
    public bool ForceHorizontalLabelForLine { get; public set; }
    public SplineType SplineType { get; public set; }
    public DrawingLevel DrawingLevel { get; public set; }
    public Dictionary`2<string, WorldLabelingCandidate> LabelPositions { get; }
    public DrawingTextAlignment Alignment { get; public set; }
    public DrawingTextLetterCase LetterCase { get; public set; }
    public double MaxCharAngleDelta { get; public set; }
    public double MinDistance { get; public set; }
    public double Spacing { get; public set; }
    public double WrapWidth { get; public set; }
    public PointStyle BasePoint { get; public set; }
    public TextStyle(string textColumnName, GeoFont textFont, GeoBrush textBrush);
    public float get_XOffsetInPixel();
    public void set_XOffsetInPixel(float value);
    public float get_YOffsetInPixel();
    public void set_YOffsetInPixel(float value);
    public bool get_FittingLineInScreen();
    public void set_FittingLineInScreen(bool value);
    public bool get_FittingPolygonInScreen();
    public void set_FittingPolygonInScreen(bool value);
    public Collection`1<TextStyle> get_CustomTextStyles();
    public double get_RotationAngle();
    public void set_RotationAngle(double value);
    public string get_TextFormat();
    public void set_TextFormat(string value);
    public string get_NumericFormat();
    public void set_NumericFormat(string value);
    public string get_DateFormat();
    public void set_DateFormat(string value);
    public GeoBrush get_TextBrush();
    public void set_TextBrush(GeoBrush value);
    public GeoFont get_Font();
    public void set_Font(GeoFont value);
    public GeoPen get_HaloPen();
    public void set_HaloPen(GeoPen value);
    public string get_TextColumnName();
    public void set_TextColumnName(string value);
    public AreaStyle get_Mask();
    public void set_Mask(AreaStyle value);
    public DrawingMargin get_MaskMargin();
    public void set_MaskMargin(DrawingMargin value);
    public bool get_ForceHorizontalLabelForLine();
    public void set_ForceHorizontalLabelForLine(bool value);
    public SplineType get_SplineType();
    public void set_SplineType(SplineType value);
    public DrawingLevel get_DrawingLevel();
    public void set_DrawingLevel(DrawingLevel value);
    public Dictionary`2<string, WorldLabelingCandidate> get_LabelPositions();
    public DrawingTextAlignment get_Alignment();
    public void set_Alignment(DrawingTextAlignment value);
    public DrawingTextLetterCase get_LetterCase();
    public void set_LetterCase(DrawingTextLetterCase value);
    public double get_MaxCharAngleDelta();
    public void set_MaxCharAngleDelta(double value);
    public double get_MinDistance();
    public void set_MinDistance(double value);
    public double get_Spacing();
    public void set_Spacing(double value);
    public double get_WrapWidth();
    public void set_WrapWidth(double value);
    public PointStyle get_BasePoint();
    public void set_BasePoint(PointStyle value);
    public static TextStyle Parse(string styleJson);
    internal static TextStyle jxU=(JObject jObject);
    public static TextStyle CreateSimpleTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor);
    public static TextStyle CreateSimpleTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, float xOffset, float yOffset);
    public static TextStyle CreateSimpleTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor haloPenColor, float haloPenWidth);
    public static TextStyle CreateSimpleTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor haloPenColor, float haloPenWidth, float xOffset, float yOffset);
    public static TextStyle CreateMaskTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor maskFillColor);
    public static TextStyle CreateMaskTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor maskFillColor, float xOffset, float yOffset);
    public static TextStyle CreateMaskTextStyle(string textColumnName, GeoFont textFont, GeoBrush textBrush, AreaStyle areaStyle, float xOffset, float yOffset);
    public static TextStyle CreateMaskTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor maskPenColor, float maskPenSize);
    public static TextStyle CreateMaskTextStyle(string textColumnName, string fontFamilyName, float fontSize, DrawingFontStyles drawingFontStyle, GeoColor fontColor, GeoColor maskPenColor, float maskPenSize, float xOffset, float yOffset);
    private static DrawingMargin DDM=(string expression);
    private static GeoFont DTM=(string fontExpression);
    private static GeoPen NTE=(String[] valueExpressions);
    private static GeoBrush DjM=(String[] valueExpressions);
    private static AreaStyle DzM=(String[] valueExpressions);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.ThinkGeoCloudApplicationException : ApplicationException {
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    public HttpStatusCode StatusCode { get; }
    public ThinkGeoCloudApplicationException(HttpStatusCode statusCode, string message, Exception innerException);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
}
public class ThinkGeo.Core.ThinkGeoCloudMapsZoomLevelSet : ZoomLevelSet {
    public ThinkGeoCloudMapsZoomLevelSet(int tileSize);
}
public enum ThinkGeo.Core.ThinkGeoCloudRasterMapsMapType : Enum {
    public int value__;
    [ObsoleteAttribute("Default has been changed from Light to Light_V2_X1. Please always specify a MapType without using the default.")]
public static ThinkGeoCloudRasterMapsMapType Default;
    [ObsoleteAttribute("Light has been renamed to Light_V1_X1. Please consider upgrading to Light_V1_X2 for higher resolution or upgrading to Light_V2 for a sharper style. ")]
public static ThinkGeoCloudRasterMapsMapType Light;
    [ObsoleteAttribute("Dark has been renamed to Dark_V1_X1, please consider upgrading to Dark_V1_X2 for higher resolution or upgrading to Dark_V2 for a sharper style. ")]
public static ThinkGeoCloudRasterMapsMapType Dark;
    [ObsoleteAttribute("Hybrid has been renamed to Hybrid_V1_X1, please consider upgrading to Hybrid_V1_X2 for higher resolution or upgrading to Hybrid_V2 for a sharper style. ")]
public static ThinkGeoCloudRasterMapsMapType Hybrid;
    [ObsoleteAttribute("Aerial has been renamed to Aerial_V1_X1, please consider upgrading to Aerial_V2_X1 for a newer data set or upgrading to Aerial_V2_X2 for higher resolution.")]
public static ThinkGeoCloudRasterMapsMapType Aerial;
    [ObsoleteAttribute("TransparentBackground has been renamed to TransparentBackground_V1_X1, please consider upgrading to TransparentBackground_V1_X2 for higher resolution or upgrading to TransparentBackground_V2 for a sharper style. ")]
public static ThinkGeoCloudRasterMapsMapType TransparentBackground;
    public static ThinkGeoCloudRasterMapsMapType Light_V1_X1;
    public static ThinkGeoCloudRasterMapsMapType Light_V1_X2;
    public static ThinkGeoCloudRasterMapsMapType Light_V2_X1;
    public static ThinkGeoCloudRasterMapsMapType Light_V2_X2;
    public static ThinkGeoCloudRasterMapsMapType Dark_V1_X1;
    public static ThinkGeoCloudRasterMapsMapType Dark_V1_X2;
    public static ThinkGeoCloudRasterMapsMapType Dark_V2_X1;
    public static ThinkGeoCloudRasterMapsMapType Dark_V2_X2;
    public static ThinkGeoCloudRasterMapsMapType Hybrid_V1_X1;
    public static ThinkGeoCloudRasterMapsMapType Hybrid_V1_X2;
    public static ThinkGeoCloudRasterMapsMapType Hybrid_V2_X1;
    public static ThinkGeoCloudRasterMapsMapType Hybrid_V2_X2;
    public static ThinkGeoCloudRasterMapsMapType Aerial_V1_X1;
    public static ThinkGeoCloudRasterMapsMapType Aerial_V1_X2;
    public static ThinkGeoCloudRasterMapsMapType Aerial_V2_X1;
    public static ThinkGeoCloudRasterMapsMapType Aerial_V2_X2;
    public static ThinkGeoCloudRasterMapsMapType TransparentBackground_V1_X1;
    public static ThinkGeoCloudRasterMapsMapType TransparentBackground_V1_X2;
    public static ThinkGeoCloudRasterMapsMapType TransparentBackground_V2_X1;
    public static ThinkGeoCloudRasterMapsMapType TransparentBackground_V2_X2;
}
public enum ThinkGeo.Core.ThinkGeoCloudVectorMapsMapType : Enum {
    public int value__;
    public static ThinkGeoCloudVectorMapsMapType Default;
    public static ThinkGeoCloudVectorMapsMapType Light;
    public static ThinkGeoCloudVectorMapsMapType Dark;
    public static ThinkGeoCloudVectorMapsMapType TransparentBackground;
    public static ThinkGeoCloudVectorMapsMapType CustomizedByStyleJson;
}
public static class ThinkGeo.Core.ThinkGeoDebugger : object {
    [CompilerGeneratedAttribute]
private static ThinkGeoLogLevel lB0=;
    [CompilerGeneratedAttribute]
private static ThinkGeoLogType lR0=;
    [CompilerGeneratedAttribute]
private static StreamWriter lh0=;
    [CompilerGeneratedAttribute]
private static bool lx0=;
    [CompilerGeneratedAttribute]
private static bool mB0=;
    public static ThinkGeoLogLevel LogLevel { get; public set; }
    public static ThinkGeoLogType LogType { get; public set; }
    public static StreamWriter LogStreamWriter { get; public set; }
    public static bool LogToConsole { get; public set; }
    public static bool DisplayTileId { get; public set; }
    private static ThinkGeoDebugger();
    [CompilerGeneratedAttribute]
public static ThinkGeoLogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public static void set_LogLevel(ThinkGeoLogLevel value);
    [CompilerGeneratedAttribute]
public static ThinkGeoLogType get_LogType();
    [CompilerGeneratedAttribute]
public static void set_LogType(ThinkGeoLogType value);
    [CompilerGeneratedAttribute]
public static StreamWriter get_LogStreamWriter();
    [CompilerGeneratedAttribute]
public static void set_LogStreamWriter(StreamWriter value);
    [CompilerGeneratedAttribute]
public static bool get_LogToConsole();
    [CompilerGeneratedAttribute]
public static void set_LogToConsole(bool value);
    public static void Log(string message, ThinkGeoLogType logType, ThinkGeoLogLevel logLevel);
    [CompilerGeneratedAttribute]
public static bool get_DisplayTileId();
    [CompilerGeneratedAttribute]
public static void set_DisplayTileId(bool value);
}
public enum ThinkGeo.Core.ThinkGeoLicenseStatus : Enum {
    public int value__;
    public static ThinkGeoLicenseStatus None;
    public static ThinkGeoLicenseStatus SoftwareAssuranceAssemblyInvalid;
    public static ThinkGeoLicenseStatus SoftwareAssuranceNotFound;
    public static ThinkGeoLicenseStatus SoftwareAssuranceExpired;
    public static ThinkGeoLicenseStatus LicenseFileInvalid;
    public static ThinkGeoLicenseStatus EvalWithProductExpired;
    public static ThinkGeoLicenseStatus EvalWithProductCallerNotMatch;
    public static ThinkGeoLicenseStatus FullWithoutProduct;
    public static ThinkGeoLicenseStatus FullWithProductExpired;
    public static ThinkGeoLicenseStatus FullWithProductCallerNotMatch;
    public static ThinkGeoLicenseStatus RuntimeLicenseForDebug;
    public static ThinkGeoLicenseStatus FullWithoutServer;
    public static ThinkGeoLicenseStatus EvalWithProduct;
    public static ThinkGeoLicenseStatus FullWithProduct;
    public static ThinkGeoLicenseStatus FullWithServer;
}
public enum ThinkGeo.Core.ThinkGeoLogLevel : Enum {
    public int value__;
    public static ThinkGeoLogLevel All;
    public static ThinkGeoLogLevel Message;
    public static ThinkGeoLogLevel Warning;
    public static ThinkGeoLogLevel Error;
    public static ThinkGeoLogLevel None;
}
[FlagsAttribute]
public enum ThinkGeo.Core.ThinkGeoLogType : Enum {
    public int value__;
    public static ThinkGeoLogType Others;
    public static ThinkGeoLogType Rendering;
    public static ThinkGeoLogType Licensing;
    public static ThinkGeoLogType Interaction;
    public static ThinkGeoLogType PopupAndMarker;
    public static ThinkGeoLogType WebRequest;
    public static ThinkGeoLogType Caching;
    public static ThinkGeoLogType DataFetching;
    public static ThinkGeoLogType All;
}
public class ThinkGeo.Core.ThinkGeoMBTilesLayer : Layer {
    private int LSw=;
    [ObfuscationAttribute]
private Uri styleJsonUri;
    [ObfuscationAttribute]
private RasterTileCache bitmapTileCache;
    private ZoomLevelSet Qx4=;
    private bool Liw=;
    [ObfuscationAttribute]
private string mbTilesPathFilename;
    private SqliteConnection Lyw=;
    private bool MCw=;
    [ObfuscationAttribute]
private static bool newFormat;
    private static Dictionary`2<string, Feature> MSw=;
    private static object Miw=;
    private static object Myw=;
    private static object 9BM=;
    private static int NCw=;
    private Collection`1<VectorTile> NSw=;
    private Collection`1<VectorTile> Niw=;
    private Collection`1<VectorTile> Nyw=;
    private bool OCw=;
    private bool OSw=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GeneratingTileMBTilesLayerEventArgs> Oiw=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GeneratedTileMBTilesLayerEventArgs> Oyw=;
    private ProjectionConverter RR4=;
    [CompilerGeneratedAttribute]
private DrawingQuality PCw=;
    [CompilerGeneratedAttribute]
private int Rx4=;
    public ProjectionConverter ProjectionConverter { get; public set; }
    public RasterTileCache BitmapTileCache { get; public set; }
    public Uri StyleJsonUri { get; public set; }
    public DrawingQuality DrawingQuality { get; public set; }
    public bool ShowDebugInfo { get; public set; }
    public int TileSize { get; public set; }
    public ThinkGeoMBTilesLayer(string mbTilesPathFilename);
    public ThinkGeoMBTilesLayer(string mbTilesPathFilename, Uri styleJsonUri);
    private static ThinkGeoMBTilesLayer();
    [CompilerGeneratedAttribute]
public void add_GeneratingTile(EventHandler`1<GeneratingTileMBTilesLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GeneratingTile(EventHandler`1<GeneratingTileMBTilesLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GeneratedTile(EventHandler`1<GeneratedTileMBTilesLayerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GeneratedTile(EventHandler`1<GeneratedTileMBTilesLayerEventArgs> value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    public RasterTileCache get_BitmapTileCache();
    public void set_BitmapTileCache(RasterTileCache value);
    public Uri get_StyleJsonUri();
    public void set_StyleJsonUri(Uri value);
    [CompilerGeneratedAttribute]
public DrawingQuality get_DrawingQuality();
    [CompilerGeneratedAttribute]
public void set_DrawingQuality(DrawingQuality value);
    public bool get_ShowDebugInfo();
    public void set_ShowDebugInfo(bool value);
    [CompilerGeneratedAttribute]
public int get_TileSize();
    [CompilerGeneratedAttribute]
public void set_TileSize(int value);
    protected virtual void CloseCore();
    protected virtual void OpenCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    public VectorTile GetTile(long zoom, long column, long row);
    public void LoadStyleJson();
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoMBTilesLayer/XEA=")]
public Task DrawTileAsync(GeoCanvas canvas, int zoomIndex, long columnIndex, long rowIndex);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoMBTilesLayer/XkA=")]
internal static Task PSw=(GeoCanvas canvas, int zoomIndex, long columnIndex, long rowIndex, ZoomLevelSet zoomLevelSet, bool ShowDebugInfo, RasterTileCache BitmapTileCache, int maxZoom, List`1<string> pbfLayerNames, UUA= getFeaturesFromPbfVectorTileAsyncDelegate, bool useLegacyLabeling, int tileSize);
    internal static Collection`1<Feature> Piw=(int zoom, long column, long row, RectangleShape boundingBox, CancellationToken cancellationToken, int maxZoom, List`1<string> pbfLayerNames, UkA= getFeaturesFromPbfVectorTile);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoMBTilesLayer/ZUA=")]
internal static Task`1<Collection`1<Feature>> Pyw=(int zoom, long column, long row, RectangleShape boundingBox, CancellationToken cancellationToken, int maxZoom, List`1<string> pbfLayerNames, UUA= getFeaturesFromPbfVectorTileAsync);
    internal static List`1<string> QCw=(ZoomLevelSet zoomLevelSet, int zoomLevelIndex);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoMBTilesLayer/aEA=")]
private Task`1<Collection`1<Feature>> SR4=(int zoom, long column, long row, List`1<string> pbfLayerNames, CancellationToken cancellationToken);
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void OnGeneratingTile(GeneratingTileMBTilesLayerEventArgs e);
    protected virtual void OnGeneratedTile(GeneratedTileMBTilesLayerEventArgs e);
    private Collection`1<Feature> Piw=(RectangleShape boundingBox, double screenWidth, CancellationToken cancellationToken);
    private Collection`1<Feature> QSw=(RectangleShape boundingBox, double screenWidth, CancellationToken cancellationToken);
    private string Qiw=(int zoom, long minColumn, long maxColumn, long minRow, long maxRow);
    private Collection`1<VectorTile> Qyw=(string sqlStatement);
    private void RCw=();
    public void BeginTransaction();
    public TransactionResult CommitTransaction();
    public void WriteMetaData(string key, string value);
    public static void CreateDatabase(string mbTilesPath, bool isOverwrite);
    public void AddTile(VectorTile vectorTile);
    public void UpdateTile(VectorTile vectorTile);
    public void DeleteTile(VectorTile vectorTile);
    private static void RSw=(SqliteConnection connection);
    private static void Riw=(SqliteConnection connection);
    private static void Ryw=(SqliteConnection connection);
    private void SCw=(Collection`1<VectorTile> deleteBuffer);
    private void SSw=(Collection`1<VectorTile> addBuffer);
    private void Siw=(Collection`1<VectorTile> updateBuffer);
    private void Syw=(RectangleShape boundingBox, int minZoom, int maxZoom);
    private static Collection`1<Feature> TCw=(FeatureLayer featureLayer, List`1<string> featureIds, IEnumerable`1<string> columnNames);
}
public class ThinkGeo.Core.ThinkGeoProductLicense : object {
    internal static string sR0=;
    internal static string sh0=;
    internal static string sx0=;
    internal static string tB0=;
    internal static string tR0=;
    internal static string th0=;
    internal static string tx0=;
    internal static string uB0=;
    internal static string uR0=;
    private static ThinkGeoProductLicense();
    public static ThinkGeoLicenseStatus GetCoreLicenseStatus();
    public static ThinkGeoLicenseStatus GetWinformsLicenseStatus();
    public static ThinkGeoLicenseStatus GetWpfLicenseStatus();
    public static ThinkGeoLicenseStatus GetBlazorLicenseStatus();
    public static ThinkGeoLicenseStatus GetBlazorServerLicenseStatus();
    public static ThinkGeoLicenseStatus GetWebApiLicenseStatus();
    public static ThinkGeoLicenseStatus GetWebApiServerLicenseStatus();
    public static ThinkGeoLicenseStatus GetiOSLicenseStatus();
    public static ThinkGeoLicenseStatus GetAndroidLicenseStatus();
    public static ThinkGeoLicenseStatus GetXamarinFormsLicenseStatus();
    private static ThinkGeoLicenseStatus uh0=(string productId);
}
public class ThinkGeo.Core.ThinkGeoRasterMapsAsyncLayer : XyzTileAsyncLayer {
    private static int 9B0=;
    private AB4= Oh4=;
    private ThinkGeoCloudRasterMapsMapType Ox4=;
    public RasterTileCache TileCache { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public ProjectionConverter ProjectionConverterFromServerProjection { get; public set; }
    public ThinkGeoCloudRasterMapsMapType MapType { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public ThinkGeoRasterMapsAsyncLayer(string clientId, string clientSecret);
    public ThinkGeoRasterMapsAsyncLayer(string clientId, string clientSecret, ThinkGeoCloudRasterMapsMapType mapType);
    public virtual RasterTileCache get_TileCache();
    public virtual void set_TileCache(RasterTileCache value);
    public virtual RasterTileCache get_ProjectedTileCache();
    public virtual void set_ProjectedTileCache(RasterTileCache value);
    public virtual ProjectionConverter get_ProjectionConverterFromServerProjection();
    public virtual void set_ProjectionConverterFromServerProjection(ProjectionConverter value);
    public ThinkGeoCloudRasterMapsMapType get_MapType();
    public void set_MapType(ThinkGeoCloudRasterMapsMapType value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoRasterMapsAsyncLayer/Mz8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoRasterMapsAsyncLayer/Mj8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoRasterMapsAsyncLayer/ND8=")]
private void PB4=(object sender, SendingHttpRequestMessageEventArgs e);
    private void Nx4=();
    private string PR4=(string cacheIdWithSuffix);
    protected virtual int GetTileScale();
    private string Ph4=();
    private string Px4=(ThinkGeoCloudRasterMapsMapType mapType);
    private string QB4=(ThinkGeoCloudRasterMapsMapType mapType);
    private string QR4=(ThinkGeoCloudRasterMapsMapType mapType);
    private GeoImageFormat 8RY=(ThinkGeoCloudRasterMapsMapType mapType);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /h0=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /x0=(CancellationToken cancellationToken);
}
public class ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer : WebBasedAsyncLayer {
    private static int Qh4=;
    [ObfuscationAttribute]
private Uri styleJsonUri;
    [ObfuscationAttribute]
private RasterTileCache bitmapTileCache;
    private ZoomLevelSet Qx4=;
    private AB4= Oh4=;
    private ThinkGeoCloudVectorMapsMapType Ox4=;
    private FileVectorTileCache RB4=;
    private ProjectionConverter RR4=;
    [CompilerGeneratedAttribute]
private bool Rh4=;
    [CompilerGeneratedAttribute]
private int Rx4=;
    private bool SB4=;
    public bool ShowDebugInfo { get; public set; }
    public int TileSize { get; public set; }
    public string ClientId { get; public set; }
    public string ClientSecret { get; public set; }
    public ThinkGeoCloudVectorMapsMapType MapType { get; public set; }
    public FileVectorTileCache VectorTileCache { get; public set; }
    public RasterTileCache BitmapTileCache { get; public set; }
    public Uri StyleJsonUri { get; public set; }
    public ProjectionConverter ProjectionConverter { get; public set; }
    public ThinkGeoVectorMapsAsyncLayer(string clientId, string clientSecret);
    public ThinkGeoVectorMapsAsyncLayer(string clientId, string clientSecret, Uri styleJsonUri);
    public ThinkGeoVectorMapsAsyncLayer(string clientId, string clientSecret, ThinkGeoCloudVectorMapsMapType mapType);
    [CompilerGeneratedAttribute]
public bool get_ShowDebugInfo();
    [CompilerGeneratedAttribute]
public void set_ShowDebugInfo(bool value);
    [CompilerGeneratedAttribute]
public int get_TileSize();
    [CompilerGeneratedAttribute]
public void set_TileSize(int value);
    public string get_ClientId();
    public void set_ClientId(string value);
    public string get_ClientSecret();
    public void set_ClientSecret(string value);
    public ThinkGeoCloudVectorMapsMapType get_MapType();
    public void set_MapType(ThinkGeoCloudVectorMapsMapType value);
    public FileVectorTileCache get_VectorTileCache();
    public void set_VectorTileCache(FileVectorTileCache value);
    public RasterTileCache get_BitmapTileCache();
    public void set_BitmapTileCache(RasterTileCache value);
    public Uri get_StyleJsonUri();
    public void set_StyleJsonUri(Uri value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/MD8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/Kj8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/VD8=")]
private Task`1<Collection`1<Feature>> SR4=(int zoom, long column, long row, List`1<string> pbfLayerNames, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/VT8=")]
private Task`1<VectorTile> Sh4=(int zoom, long column, long row, CancellationToken cancellationToken);
    private void Sx4=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/UD8=")]
public Task DrawTileAsync(GeoCanvas canvas, int zoomIndex, long columnIndex, long rowIndex);
    [AsyncStateMachineAttribute("ThinkGeo.Core.ThinkGeoVectorMapsAsyncLayer/QD8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void Nx4=(ThinkGeoCloudVectorMapsMapType mapType);
    private bool OB4=(string cacheId);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task /h0=(CancellationToken cancellationToken);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task /x0=(CancellationToken cancellationToken);
}
internal class ThinkGeo.Core.ThreadSafeStore`2 : object {
    private object _lock;
    [ObfuscationAttribute]
private Dictionary`2<TKey, TValue> _store;
    private Func`2<TKey, TValue> _creator;
    public ThreadSafeStore`2(Func`2<TKey, TValue> creator);
    public TValue Get(TKey key);
    private TValue AddValue(TKey key);
}
public enum ThinkGeo.Core.ThreadSafetyLevel : Enum {
    public int value__;
    public static ThreadSafetyLevel Unsafe;
    public static ThreadSafetyLevel Safe;
}
public class ThinkGeo.Core.ThrowingExceptionOverlayEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception rxQ=;
    [CompilerGeneratedAttribute]
private string sBQ=;
    [CompilerGeneratedAttribute]
private bool sRQ=;
    public Exception Exception { get; private set; }
    public string MemberName { get; private set; }
    public bool Handled { get; public set; }
    public ThrowingExceptionOverlayEventArgs(Exception exception, string memberName);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public string get_MemberName();
    [CompilerGeneratedAttribute]
private void set_MemberName(string value);
    [CompilerGeneratedAttribute]
public bool get_Handled();
    [CompilerGeneratedAttribute]
public void set_Handled(bool value);
}
public abstract class ThinkGeo.Core.Tile : object {
    [ObfuscationAttribute]
private int zoomIndex;
    [ObfuscationAttribute]
private long cloumn;
    [ObfuscationAttribute]
private long row;
    [CompilerGeneratedAttribute]
private string 0R0=;
    public int ZoomIndex { get; public set; }
    public long Column { get; public set; }
    public long Row { get; public set; }
    public string CacheId { get; public set; }
    public Tile(int zoomIndex, long column, long row);
    public int get_ZoomIndex();
    public void set_ZoomIndex(int value);
    public long get_Column();
    public void set_Column(long value);
    public long get_Row();
    public void set_Row(long value);
    [CompilerGeneratedAttribute]
public string get_CacheId();
    [CompilerGeneratedAttribute]
public void set_CacheId(string value);
    public Tile CloneDeep();
    protected virtual Tile CloneDeepCore();
}
public enum ThinkGeo.Core.TileAccessMode : Enum {
    public int value__;
    public static TileAccessMode Default;
    public static TileAccessMode ReadOnly;
    public static TileAccessMode ReadAdd;
    public static TileAccessMode ReadAddDelete;
}
public abstract class ThinkGeo.Core.TileCache : object {
    [ObfuscationAttribute]
private string cacheId;
    [ObfuscationAttribute]
private TimeSpan expirationTime;
    [ObfuscationAttribute]
private TileAccessMode tileAccessMode;
    [CompilerGeneratedAttribute]
private EventHandler`1<GottenCacheImageBitmapTileCacheEventArgs> xR0=;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingCacheImageBitmapTileCacheEventArgs> xh0=;
    public TileAccessMode TileAccessMode { get; public set; }
    public string CacheId { get; public set; }
    public TimeSpan ExpirationTime { get; public set; }
    protected TileCache(string cacheId);
    [CompilerGeneratedAttribute]
public void add_GottenCacheTile(EventHandler`1<GottenCacheImageBitmapTileCacheEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GottenCacheTile(EventHandler`1<GottenCacheImageBitmapTileCacheEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GettingCacheTile(EventHandler`1<GettingCacheImageBitmapTileCacheEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingCacheTile(EventHandler`1<GettingCacheImageBitmapTileCacheEventArgs> value);
    public TileAccessMode get_TileAccessMode();
    public void set_TileAccessMode(TileAccessMode value);
    public virtual string get_CacheId();
    public virtual void set_CacheId(string value);
    public TimeSpan get_ExpirationTime();
    public void set_ExpirationTime(TimeSpan value);
    protected virtual void OnGottenCacheTile(GottenCacheImageBitmapTileCacheEventArgs e);
    protected virtual void OnGettingCacheTile(GettingCacheImageBitmapTileCacheEventArgs e);
    [ObsoleteAttribute("This API is obsoleted, please use GetTileAsync() instead")]
public Tile GetTile(int zoom, long column, long row);
    [AsyncStateMachineAttribute("ThinkGeo.Core.TileCache/8D4=")]
public Task`1<Tile> GetTileAsync(int zoom, long column, long row, CancellationToken cancellationToken);
    [ObsoleteAttribute("This API is obsoleted, please use SaveTileAsync() instead")]
public void SaveTile(Tile tile);
    [AsyncStateMachineAttribute("ThinkGeo.Core.TileCache/8j4=")]
public Task SaveTileAsync(Tile tile, CancellationToken cancellationToken);
    public void DeleteTile(Tile tile);
    public void ClearCache();
    protected abstract virtual void ClearCacheCore();
    [ObsoleteAttribute("This API is obsoleted, please use SaveTileAsyncCore() instead")]
protected virtual void SaveTileCore(Tile tile);
    protected abstract virtual void DeleteTileCore(Tile tile);
    protected virtual Task SaveTileAsyncCore(Tile tile, CancellationToken cancellationToken);
    protected virtual Task`1<Tile> GetTileAsyncCore(int zoom, long column, long row, CancellationToken cancellationToken);
    [ObsoleteAttribute("This API is obsoleted, please use GetTileAsync() instead")]
protected virtual Tile GetTileCore(int zoom, long column, long row);
}
public class ThinkGeo.Core.TileMatrix : Matrix {
    [ObfuscationAttribute]
private double scale;
    [ObfuscationAttribute]
private int tileWidth;
    [ObfuscationAttribute]
private int tileHeight;
    [ObfuscationAttribute]
private GeographyUnit geographyUnit;
    private static int wB0=;
    public double Scale { get; public set; }
    public int TileWidth { get; public set; }
    public int TileHeight { get; public set; }
    public GeographyUnit GeographyUnit { get; public set; }
    public TileMatrix(double scale);
    public TileMatrix(double scale, RectangleShape boundingBox, GeographyUnit geographyUnit);
    public TileMatrix(double scale, int tileWidth, int tileHeight, RectangleShape boundingBox, GeographyUnit geographyUnit);
    public double get_Scale();
    public void set_Scale(double value);
    internal void wR0=(double currentScale);
    public int get_TileWidth();
    public void set_TileWidth(int value);
    public int get_TileHeight();
    public void set_TileHeight(int value);
    public GeographyUnit get_GeographyUnit();
    public void set_GeographyUnit(GeographyUnit value);
    public static TileMatrix GetDefaultMatrix(double scale, int tileWidth, int tileHeight, GeographyUnit unit);
    private void wh0=();
    protected virtual RowColumnRange GetRowColumnRangeCore(RectangleShape worldExtent, bool isContains);
}
public enum ThinkGeo.Core.TileResolution : Enum {
    public int value__;
    public static TileResolution Default;
    public static TileResolution Standard;
    public static TileResolution High;
}
public enum ThinkGeo.Core.TileSizeMode : Enum {
    public int value__;
    public static TileSizeMode Default;
    public static TileSizeMode Small;
    public static TileSizeMode Medium;
    public static TileSizeMode DefaultX2;
}
public enum ThinkGeo.Core.TileSnappingMode : Enum {
    public int value__;
    public static TileSnappingMode NoSnapping;
    public static TileSnappingMode Snapping;
}
public class ThinkGeo.Core.TimeZoneCloudClient : CloudClient {
    private static int yRQ=;
    public TimeZoneCloudClient(string clientId, string clientSecret);
    public CloudTimeZoneResult GetTimeZoneByCoordinate(double latitude, double longitude);
    public CloudTimeZoneResult GetTimeZoneByCoordinate(double x, double y, int projectionInSrid);
    public CloudTimeZoneResult GetTimeZoneByCoordinate(double x, double y, string projectionInProj4String);
    public Task`1<CloudTimeZoneResult> GetTimeZoneByCoordinateAsync(double latitude, double longitude);
    public Task`1<CloudTimeZoneResult> GetTimeZoneByCoordinateAsync(double x, double y, int projectionInSrid);
    public Task`1<CloudTimeZoneResult> GetTimeZoneByCoordinateAsync(double x, double y, string projectionInProj4String);
    public Collection`1<string> GetAllTimeZoneNames();
    public Task`1<Collection`1<string>> GetAllTimeZoneNamesAsync();
    public Collection`1<CloudTimeZoneResult> GetAllTimeZones();
    public Task`1<Collection`1<CloudTimeZoneResult>> GetAllTimeZonesAsync();
    private CloudTimeZoneResult GhU=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String);
    [AsyncStateMachineAttribute("ThinkGeo.Core.TimeZoneCloudClient/nj4=")]
private Task`1<CloudTimeZoneResult> GxU=(double x, double y, Nullable`1<int> projectionInSrid, string projectionInProj4String);
    private Collection`1<string> HBU=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.TimeZoneCloudClient/nD4=")]
private Task`1<Collection`1<string>> HRU=();
    private Collection`1<CloudTimeZoneResult> HhU=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.TimeZoneCloudClient/nT4=")]
private Task`1<Collection`1<CloudTimeZoneResult>> HxU=();
    private static CloudTimeZoneResult IBU=(WebResponse response);
    private static Collection`1<string> IRU=(WebResponse response);
    private static Collection`1<CloudTimeZoneResult> IhU=(WebResponse response);
    private static string BBU=(Nullable`1<int> projectionInSrid, string projectionInProj4String);
}
public class ThinkGeo.Core.TinyGeoFeatureLayer : FeatureLayer {
    public bool HasBoundingBox { get; }
    public string TinyGeoPathFilename { get; public set; }
    public string Password { get; public set; }
    public TinyGeoFeatureLayer(string tinyGeoPathFilename);
    public TinyGeoFeatureLayer(string tinyGeoPathFilename, string password);
    public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    public virtual bool get_HasBoundingBox();
    public string get_TinyGeoPathFilename();
    public void set_TinyGeoPathFilename(string value);
    public string get_Password();
    public void set_Password(string value);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, string password);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, string password, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter, Encoding shapeEncoding);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, FeatureLayer featureLayer, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter, Encoding shapeEncoding, WellKnownType type);
    public static double GetOptimalPrecision(string shapePathFilename, GeographyUnit unitOfData, DistanceUnit returningDistanceUnit, TinyGeoPrecisionMode precisionMode);
    public static double GetOptimalPrecision(FeatureLayer featureLayer, GeographyUnit unitOfData, DistanceUnit returningDistanceUnit, TinyGeoPrecisionMode precisionMode);
    public static void EncryptTinyGeoFile(string unencryptedTinyGeoPathFilename, string encryptedTinyGeoPathFilename, string password);
    public static void DecryptTinyGeoFile(string encryptedTinyGeoPathFilename, string decryptedTinyGeoPathFilename, string password);
    public TinyGeoFileType GetTinyGeoFileType();
}
public class ThinkGeo.Core.TinyGeoFeatureSource : FeatureSource {
    private static double LC8=;
    [ObfuscationAttribute]
private string tinyGeoFilePathName;
    private dy4= LS8=;
    [ObfuscationAttribute]
private string password;
    [CompilerGeneratedAttribute]
private EventHandler`1<StreamLoadingEventArgs> Dh8=;
    public string Password { get; public set; }
    public string TinyGeoPathFilename { get; public set; }
    public TinyGeoFeatureSource(string tinyGeoPathFilename);
    public TinyGeoFeatureSource(string tinyGeoPathFilename, string password);
    [CompilerGeneratedAttribute]
public void add_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StreamLoading(EventHandler`1<StreamLoadingEventArgs> value);
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    public string get_Password();
    public void set_Password(string value);
    public string get_TinyGeoPathFilename();
    public void set_TinyGeoPathFilename(string value);
    protected virtual void OnStreamLoading(StreamLoadingEventArgs e);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    public TinyGeoFileType GetTinyGeoFileType();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames, int startIndex, int takeCount);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, string password);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, ReturningColumnsType returningColumnType, string password, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, string shapePathFilename, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter, Encoding shapeEncoding);
    public static void CreateTinyGeoFile(string tinyGeoPathFilename, FeatureLayer featureLayer, GeographyUnit unitOfData, IEnumerable`1<string> columnNames, string password, double precisionInMeter, Encoding shapeEncoding, WellKnownType type);
    public static double GetOptimalPrecision(FeatureLayer featureLayer, GeographyUnit unitOfData, DistanceUnit returningDistanceUnit, TinyGeoPrecisionMode precisionMode);
    public static double GetOptimalPrecision(string shapePathFilename, GeographyUnit unitOfData, DistanceUnit returningDistanceUnit, TinyGeoPrecisionMode precisionMode);
    public static void EncryptTinyGeoFile(string unencryptedTinyGeoPathFilename, string encryptedTinyGeoPathFilename, string password);
    public static void DecryptTinyGeoFile(string encryptedTinyGeoPathFilename, string decryptedTinyGeoPathFilename, string password);
    private void Li8=(object sender, StreamLoadingEventArgs e);
    private static void Ly8=(string tinyGeoPathFilename, FeatureLayer featureLayer, IEnumerable`1<string> columnNames, string password, Uiw= accuracy, Collection`1<string> ids, double extentWidthLimitation, Encoding shapeEncoding);
    private static double YSc=(double maxFeatureWidth, GeographyUnit unit);
    private static double MC8=(Uiw= accuracy);
    private static double MS8=(Uiw= accuracy);
    private static double Mi8=(Uiw= accuracy);
    private static double My8=(RectangleShape rect);
    private static Uiw= Gy4=(Double& extentWidthLimitation, double minExtent, double precision, GeographyUnit unit);
    private static Uiw= Gy4=(Double& extentWidthLimitation, double minExtent, double precision, double maxExtent);
    private static int NC8=(Uiw= accuracy);
    private static Uiw= NS8=(int number);
    private static Uiw= Ni8=(double distance);
}
public enum ThinkGeo.Core.TinyGeoFileType : Enum {
    public int value__;
    public static TinyGeoFileType Point;
    public static TinyGeoFileType Polyline;
    public static TinyGeoFileType Polygon;
}
public enum ThinkGeo.Core.TinyGeoPrecisionMode : Enum {
    public int value__;
    public static TinyGeoPrecisionMode AllowSplitting;
    public static TinyGeoPrecisionMode PreventSplitting;
}
public class ThinkGeo.Core.TobinBasFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private BasAnnotationTextStylingType annotationTextStylingType;
    [ObfuscationAttribute]
private int progressiveDrawingRecordsCount;
    [ObfuscationAttribute]
private string tobinBasFilePathName;
    [ObfuscationAttribute]
private int minAnnotationFontSize;
    public string TobinBasFilePathName { get; public set; }
    public int ProgressiveDrawingRecordsCount { get; public set; }
    public int MinAnnotationFontSize { get; public set; }
    public BasAnnotationTextStylingType AnnotationTextStylingType { get; public set; }
    public bool HasBoundingBox { get; }
    public TobinBasFeatureLayer(string tobinBasFileName);
    public string get_TobinBasFilePathName();
    public void set_TobinBasFilePathName(string value);
    public int get_ProgressiveDrawingRecordsCount();
    public void set_ProgressiveDrawingRecordsCount(int value);
    public int get_MinAnnotationFontSize();
    public void set_MinAnnotationFontSize(int value);
    public BasAnnotationTextStylingType get_AnnotationTextStylingType();
    public void set_AnnotationTextStylingType(BasAnnotationTextStylingType value);
    protected virtual void OpenCore();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    public virtual bool get_HasBoundingBox();
    public static void BuildIndexFile(string pathFilename);
}
public class ThinkGeo.Core.TobinBasFeatureSource : FeatureSource {
    [ObfuscationAttribute]
private string tobinBasFilePathName;
    [ObfuscationAttribute]
private string indexPathFilename;
    private RtreeSpatialIndex wiE=;
    private 3y8= 4C8=;
    private Encoding ER8=;
    [ObfuscationAttribute]
private bool requireIndex;
    private Collection`1<Feature> 8S8=;
    private SortedList`2<string, 1i8=> 8i8=;
    private int 8y8=;
    [CompilerGeneratedAttribute]
private static EventHandler`1<BuildingIndexBasFileFeatureSourceEventArgs> wSE=;
    public Collection`1<Feature> AnnotationFeatures { get; public set; }
    public Encoding Encoding { get; public set; }
    public bool RequireIndex { get; public set; }
    public string TobinBasFileName { get; public set; }
    public TobinBasFeatureSource(string tobinBasFilePathName);
    public Collection`1<Feature> get_AnnotationFeatures();
    public void set_AnnotationFeatures(Collection`1<Feature> value);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    public bool get_RequireIndex();
    public void set_RequireIndex(bool value);
    public string get_TobinBasFileName();
    public void set_TobinBasFileName(string value);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public static void BuildIndexFile(string shapePathFilename);
    public static void BuildIndexFile(string shapePathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode);
    public static void BuildIndexFile(string basPathFilename, string indexPathFilename, ProjectionConverter projectionConverter, string columnName, string regularExpression, BuildIndexMode buildIndexMode, Encoding encoding);
    [CompilerGeneratedAttribute]
public static void add_BuildingIndex(EventHandler`1<BuildingIndexBasFileFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_BuildingIndex(EventHandler`1<BuildingIndexBasFileFeatureSourceEventArgs> value);
    private void 9C8=(1i8= entity);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected static void OnBuildingIndex(BuildingIndexBasFileFeatureSourceEventArgs e);
    private void UCQ=(FileAccess rTreeFileAccess);
    private static Dictionary`2<string, string> 9S8=(RC8= annotation);
    private string 9i8=(string p, string columnName);
    private static void ByQ=(string pathFilename);
    private static void WiQ=(string sourcePathFilename, string targetPathFilename);
    private static void TiQ=(1i8= featureEntity, RtreeSpatialIndex openedRtree, ProjectionConverter openedProjection);
}
public class ThinkGeo.Core.TobinBasValidatorHelper : object {
    public static void CheckRecordLength(string Record);
    public static void CheckTobinBasFileName(string path);
}
public class ThinkGeo.Core.TopologyValidationResult : ValueType {
    [CompilerGeneratedAttribute]
private bool mR0=;
    [CompilerGeneratedAttribute]
private Collection`1<Feature> mh0=;
    public bool IsValid { get; }
    public Collection`1<Feature> InvalidFeatures { get; }
    public TopologyValidationResult(bool isValid, IEnumerable`1<Feature> invalidFeatures);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_IsValid();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Collection`1<Feature> get_InvalidFeatures();
}
public static class ThinkGeo.Core.TopologyValidator : object {
    private static string mx0=;
    public static TopologyValidationResult PolygonsMustNotOverlap(IEnumerable`1<Feature> polygonFeatures);
    public static TopologyValidationResult PolygonsMustNotHaveGaps(IEnumerable`1<Feature> polygonFeatures);
    public static TopologyValidationResult PolygonsMustContainPoint(IEnumerable`1<Feature> polygonFeatures, IEnumerable`1<Feature> pointFeatures);
    public static TopologyValidationResult PolygonsMustBeWithinPolygons(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult PolygonBoundariesMustOverlapLines(IEnumerable`1<Feature> polygonFeatures, IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult PolygonsMustOverlapPolygons(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult PolygonsMustNotOverlapPolygons(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult PolygonsMustOverlapEachOther(IEnumerable`1<Feature> firstPolygonGroup, IEnumerable`1<Feature> secondPolygonGroup);
    public static TopologyValidationResult PolygonBoundariesMustOverlapPolygonBoundaries(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult LinesMustFormClosedPolygon(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotHavePseudonodes(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotOverlap(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotSelfOverlap(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotIntersect(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotSelfIntersect(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotSelfIntersectOrTouch(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustBeSinglePart(IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult LinesMustNotOverlapLines(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult LinesMustBeCoveredByLines(IEnumerable`1<Feature> featuresToValidateAgainst, IEnumerable`1<Feature> featuresToValidate);
    public static TopologyValidationResult LineEndPointsMustTouchPoints(IEnumerable`1<Feature> lineFeatures, IEnumerable`1<Feature> pointFeatures);
    public static TopologyValidationResult LinesMustOverlapPolygonBoundaries(IEnumerable`1<Feature> lineFeatures, IEnumerable`1<Feature> polygonFeatures);
    public static TopologyValidationResult PointsMustBeWithinPolygons(IEnumerable`1<Feature> pointFeatures, IEnumerable`1<Feature> polygonFeatures);
    public static TopologyValidationResult PointsMustTouchPolygonBoundaries(IEnumerable`1<Feature> pointFeatures, IEnumerable`1<Feature> polygonFeatures);
    public static TopologyValidationResult PointsMustTouchLineEndpoints(IEnumerable`1<Feature> pointFeatures, IEnumerable`1<Feature> lineFeatures);
    public static TopologyValidationResult PointsMustTouchLines(IEnumerable`1<Feature> pointFeatures, IEnumerable`1<Feature> lineFeatures);
    private static Collection`1<Feature> nB0=(IEnumerable`1<Feature> sourceFeatures, WellKnownType filterType1, WellKnownType filterType2);
    private static TopologyValidationResult nR0=(IEnumerable`1<Feature> coveringFeatures, IEnumerable`1<Feature> coveredFeatures);
    private static TopologyValidationResult nh0=(IEnumerable`1<Feature> coveringFeatures, IEnumerable`1<Feature> coveredFeatures);
    private static Collection`1<Feature> nx0=(IEnumerable`1<Feature> pointFeatures);
    private static Collection`1<Feature> oB0=(IEnumerable`1<Feature> polygonShapes);
    private static Collection`1<Feature> oR0=(Feature item);
    private static int oh0=(Feature lineFeature, Feature pointFeature);
    private static Collection`1<Feature> ox0=(IEnumerable`1<Feature> lineFeatures);
    private static void pB0=(Collection`1<Feature> results, Feature lineGeom, Feature intersectFeature);
    private static Collection`1<string> pR0=(Feature feature1, Feature feature2);
    private static Feature ph0=(IEnumerable`1<Feature> features);
    internal static STRtree`1<BaseShape> px0=(IEnumerable`1<BaseShape> baseShapes);
    private static STRtree`1<Feature> px0=(IEnumerable`1<Feature> features);
    private static PointShape[] qB0=(Feature lineFeature);
    private static bool qR0=(double start, double middle, double end);
    internal static bool qh0=(Vertex startVertex, Vertex endVertex, PointShape point);
}
public class ThinkGeo.Core.TouchMapViewEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ScreenPointD rRQ=;
    [CompilerGeneratedAttribute]
private PointShape rhQ=;
    public ScreenPointD PointInScreenCoordinate { get; public set; }
    public PointShape PointInWorldCoordinate { get; public set; }
    public TouchMapViewEventArgs(ScreenPointD pointInScreenCoordinate, PointShape pointInWorldCoordinate);
    [CompilerGeneratedAttribute]
public ScreenPointD get_PointInScreenCoordinate();
    [CompilerGeneratedAttribute]
public void set_PointInScreenCoordinate(ScreenPointD value);
    [CompilerGeneratedAttribute]
public PointShape get_PointInWorldCoordinate();
    [CompilerGeneratedAttribute]
public void set_PointInWorldCoordinate(PointShape value);
}
public class ThinkGeo.Core.TouchMovedTrackInteractiveOverlayEventArgs : EventArgs {
    private Vertex shQ=;
    private Feature sxQ=;
    public Vertex MovedVertex { get; public set; }
    public Feature AffectedFeature { get; public set; }
    public TouchMovedTrackInteractiveOverlayEventArgs(Vertex movedVertex, Feature affectedFeature);
    public Vertex get_MovedVertex();
    public void set_MovedVertex(Vertex value);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
}
public class ThinkGeo.Core.TouchMovingTrackInteractiveOverlayEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Vertex qxQ=;
    [CompilerGeneratedAttribute]
private bool rBQ=;
    public Vertex TargetVertex { get; }
    public bool Cancel { get; public set; }
    public TouchMovingTrackInteractiveOverlayEventArgs(Vertex targetVertex);
    [CompilerGeneratedAttribute]
public Vertex get_TargetVertex();
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
}
public class ThinkGeo.Core.TrackEndedTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private BaseShape trackShape;
    public BaseShape TrackShape { get; public set; }
    public TrackEndedTrackInteractiveOverlayEventArgs(BaseShape trackShape);
    public BaseShape get_TrackShape();
    public void set_TrackShape(BaseShape value);
}
public class ThinkGeo.Core.TrackEndingTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private BaseShape trackShape;
    [ObfuscationAttribute]
private bool cancel;
    public BaseShape TrackShape { get; public set; }
    public bool Cancel { get; public set; }
    public TrackEndingTrackInteractiveOverlayEventArgs(BaseShape shape, bool cancel);
    public BaseShape get_TrackShape();
    public void set_TrackShape(BaseShape value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public enum ThinkGeo.Core.TrackMode : Enum {
    public int value__;
    public static TrackMode None;
    public static TrackMode Point;
    public static TrackMode Line;
    public static TrackMode Polygon;
    public static TrackMode Rectangle;
    public static TrackMode Square;
    public static TrackMode Circle;
    public static TrackMode Ellipse;
    public static TrackMode StraightLine;
    public static TrackMode Freehand;
    public static TrackMode Custom;
    public static TrackMode Multipoint;
}
public class ThinkGeo.Core.TrackStartedTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Vertex startedVertex;
    public Vertex StartedVertex { get; public set; }
    public TrackStartedTrackInteractiveOverlayEventArgs(Vertex startedVertex);
    public Vertex get_StartedVertex();
    public void set_StartedVertex(Vertex value);
}
public class ThinkGeo.Core.TrackStartingTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private Vertex startingVertex;
    public bool Cancel { get; public set; }
    public Vertex StartingVertex { get; public set; }
    public TrackStartingTrackInteractiveOverlayEventArgs(Vertex startingVertex, bool cancel);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Vertex get_StartingVertex();
    public void set_StartingVertex(Vertex value);
}
public class ThinkGeo.Core.TransactionBuffer : object {
    [ObfuscationAttribute]
private Dictionary`2<string, Feature> addBuffer;
    [ObfuscationAttribute]
private Collection`1<string> deleteBuffer;
    [ObfuscationAttribute]
private Dictionary`2<string, Feature> editBuffer;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> addColumnBuffer;
    [ObfuscationAttribute]
private Collection`1<string> deleteColumnBuffer;
    [ObfuscationAttribute]
private Dictionary`2<string, FeatureSourceColumn> updateColumnBuffer;
    public Dictionary`2<string, Feature> AddBuffer { get; }
    public Collection`1<string> DeleteBuffer { get; }
    public Dictionary`2<string, Feature> EditBuffer { get; }
    public Collection`1<FeatureSourceColumn> AddColumnBuffer { get; }
    public Collection`1<string> DeleteColumnBuffer { get; }
    public Dictionary`2<string, FeatureSourceColumn> UpdateColumnBuffer { get; }
    public TransactionBuffer(Dictionary`2<string, Feature> addBuffer, Collection`1<string> deleteBuffer, Dictionary`2<string, Feature> editBuffer);
    public void Clear();
    public Dictionary`2<string, Feature> get_AddBuffer();
    public Collection`1<string> get_DeleteBuffer();
    public Dictionary`2<string, Feature> get_EditBuffer();
    public void AddFeature(Feature feature);
    public void AddFeature(BaseShape baseShape);
    public void AddFeature(BaseShape baseShape, Dictionary`2<string, string> columnValues);
    public void DeleteFeature(string featureId);
    public void EditFeature(Feature feature);
    public void EditFeature(BaseShape baseShape);
    public void EditFeature(BaseShape baseShape, Dictionary`2<string, string> columnValues);
    public Collection`1<FeatureSourceColumn> get_AddColumnBuffer();
    public void AddColumn(FeatureSourceColumn featureSourceColumn);
    public Collection`1<string> get_DeleteColumnBuffer();
    public void DeleteColumn(string columnName);
    public Dictionary`2<string, FeatureSourceColumn> get_UpdateColumnBuffer();
    public void UpdateColumn(string columnName, FeatureSourceColumn newFeatureSourceColumn);
}
public class ThinkGeo.Core.TransactionResult : object {
    [ObfuscationAttribute]
private int totalSuccessCount;
    [ObfuscationAttribute]
private int totalFailureCount;
    [ObfuscationAttribute]
private TransactionResultStatus transactionResultStatus;
    [ObfuscationAttribute]
private Dictionary`2<string, string> failureReasons;
    public int TotalSuccessCount { get; public set; }
    public int TotalFailureCount { get; public set; }
    public TransactionResultStatus TransactionResultStatus { get; public set; }
    public Dictionary`2<string, string> FailureReasons { get; }
    public TransactionResult(int totalSuccessCount, int totalFailureCount, Dictionary`2<string, string> failureReasons, TransactionResultStatus transactionResultStatus);
    public int get_TotalSuccessCount();
    public void set_TotalSuccessCount(int value);
    public int get_TotalFailureCount();
    public void set_TotalFailureCount(int value);
    public TransactionResultStatus get_TransactionResultStatus();
    public void set_TransactionResultStatus(TransactionResultStatus value);
    public Dictionary`2<string, string> get_FailureReasons();
}
public enum ThinkGeo.Core.TransactionResultStatus : Enum {
    public int value__;
    public static TransactionResultStatus Success;
    public static TransactionResultStatus Failure;
    public static TransactionResultStatus Cancel;
}
public enum ThinkGeo.Core.TransitionEffect : Enum {
    public int value__;
    public static TransitionEffect None;
    public static TransitionEffect Stretch;
}
public enum ThinkGeo.Core.UnitSystem : Enum {
    public int value__;
    public static UnitSystem Imperial;
    public static UnitSystem Metric;
    public static UnitSystem NauticalMile;
}
public static class ThinkGeo.Core.UnmanagedAssembliesHelper : object {
    public static string GetAssemblyPathFilename(string directoryName, string assemblyName);
    private static string qx0=();
    private static Collection`1<string> rB0=();
}
public class ThinkGeo.Core.UsgsDemFeatureLayer : FeatureLayer {
    public string PathFilename { get; public set; }
    public bool HasBoundingBox { get; }
    public string DataValueColumnName { get; }
    public string OriginCode { get; }
    public UsgsDemQualityLevel QualityLevel { get; }
    public int ColumnCount { get; }
    public int RowCount { get; }
    public float ResolutionX { get; }
    public float ResolutionY { get; }
    public float ResolutionZ { get; }
    public double MinElevation { get; }
    public double MaxElevation { get; }
    public DistanceUnit ElevationUnit { get; }
    public UsgsDemFeatureLayer(string pathFilename);
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public virtual bool get_HasBoundingBox();
    public string get_DataValueColumnName();
    public string get_OriginCode();
    public UsgsDemQualityLevel get_QualityLevel();
    public int get_ColumnCount();
    public int get_RowCount();
    public float get_ResolutionX();
    public float get_ResolutionY();
    public float get_ResolutionZ();
    public double get_MinElevation();
    public double get_MaxElevation();
    public DistanceUnit get_ElevationUnit();
}
public class ThinkGeo.Core.UsgsDemFeatureSource : FeatureSource {
    private static string PiI=;
    private Int16[0...,0...] 9y8=;
    [ObfuscationAttribute]
private string pathFilename;
    private string /C8=;
    private UsgsDemQualityLevel /S8=;
    private int /i8=;
    private int /y8=;
    private double ADA=;
    private double ATA=;
    private RectangleShape AjA=;
    private float AzA=;
    private float BDA=;
    private float BTA=;
    private DistanceUnit BjA=;
    public string PathFilename { get; public set; }
    public string OriginCode { get; }
    public UsgsDemQualityLevel QualityLevel { get; }
    public int ColumnCount { get; }
    public int RowCount { get; }
    public float ResolutionX { get; }
    public float ResolutionY { get; }
    public float ResolutionZ { get; }
    public double MinElevation { get; }
    public double MaxElevation { get; }
    public string DataValueColumnName { get; }
    public DistanceUnit ElevationUnit { get; }
    public UsgsDemFeatureSource(string pathFilename);
    private static UsgsDemFeatureSource();
    public string get_PathFilename();
    public void set_PathFilename(string value);
    public string get_OriginCode();
    public UsgsDemQualityLevel get_QualityLevel();
    public int get_ColumnCount();
    public int get_RowCount();
    public float get_ResolutionX();
    public float get_ResolutionY();
    public float get_ResolutionZ();
    public double get_MinElevation();
    public double get_MaxElevation();
    public string get_DataValueColumnName();
    public DistanceUnit get_ElevationUnit();
    protected virtual void OpenCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight, IEnumerable`1<string> returningColumnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    private Byte[] QiI=(double x1, double y1, double x2, double y2);
    private string BzA=(Char[] buffer, int start, int count);
    private int CDA=(Char[] buffer, int start, int count);
    private short CTA=(string value);
    private int CjA=(string value);
    private double CzA=(Char[] buffer, int start, int count);
    private float DDA=(Char[] buffer, int start, int count);
}
public enum ThinkGeo.Core.UsgsDemQualityLevel : Enum {
    public int value__;
    public static UsgsDemQualityLevel Default;
    public static UsgsDemQualityLevel Level1;
    public static UsgsDemQualityLevel Level2;
    public static UsgsDemQualityLevel Level3;
    public static UsgsDemQualityLevel Level4;
}
public static class ThinkGeo.Core.ValidatorHelper : object {
    private static bool rR0=;
    public static void CheckImageIsNotNullInPointStyle(GeoImage image);
    public static void CheckDrawingLineCapIsValid(DrawingLineCap drawingLineCap, string parameterName);
    public static void CheckGeoDashCapIsValid(GeoDashCap geoDashCap, string parameterName);
    public static void CheckDrawingLineJoinIsValid(DrawingLineJoin drawingLineJoin, string parameterName);
    public static void CheckLineDashStyleIsValid(LineDashStyle lineDashStyle, string parameterName);
    public static void CheckDrawingLevelIsValid(DrawingLevel drawingLevel, string parameterName);
    public static void CheckGeoImageIsValid(GeoImage image, string parameterName, GeoCanvas canvas);
    public static void CheckIconImageAndIconFilePathAreInvalid(string iconFilePath, GeoImage iconImage);
    public static void CheckRandomColorTypeIsValid(RandomColorType colorType, string parameterName);
    public static void CheckGroupLayerIsNotEmpty(GeoCollection`1<Layer> layers);
    public static void CheckQueryTypeIsValid(QueryType queryType, string parameterName);
    public static void CheckFeatureSourceCollectionIsNotEmpty(Collection`1<FeatureSource> featureSources);
    public static void CheckBuildIndexModeIsValid(BuildIndexMode buildIndexMode, string parameterName);
    public static void CheckOverwriteModeIsValid(OverwriteMode overwriteMode, string parameterName);
    public static void CheckRebuildRecordIdModeIsValid(BuildRecordIdMode rebuildRecordIdMode, string parameterName);
    public static void CheckDbfColumnDecimalLengthIsValid(DbfColumnType columnType, int decimalLength);
    public static void CheckPanDirectionIsValid(PanDirection panDirection, string parameterName);
    public static void CheckColumnNameIsInFeature(string columnName, IEnumerable`1<Feature> features);
    public static void CheckShapeIsValidForOperation(BaseShape shape);
    public static void CheckShapeIsValid(BaseShape shape, string parameterName);
    public static void CheckFeatureIsValid(Feature feature, string parameterName);
    public static void CheckShapeValidationModeIsValid(ShapeValidationMode shapeValidationMode, string parameterName);
    public static void CheckExtentIsValid(RectangleShape extent, string parameterName);
    public static void CheckStartingPointIsValid(StartingPoint startingPoint, string parameterName);
    public static void CheckWkbByteOrderIsValid(WkbByteOrder wkbByteOrder, string parameterName);
    public static void CheckRingOrderIsValid(RingOrder ringOrder, string parameterName);
    public static void CheckFeatureIsValid(Feature feature);
    public static void CheckShapeIsAreaBaseShape(BaseShape shape);
    public static void CheckShapeIsPointShape(BaseShape shape);
    public static void CheckShapeIsMultipointShape(BaseShape shape);
    public static void CheckShapeIsLineBaseShape(BaseShape shape);
    public static void CheckSimplificationTypeIsValid(SimplificationType simplificationType, string parameterName);
    public static void CheckReturningColumnsTypeIsValid(ReturningColumnsType returningColumnsType, string parameterName);
    public static void CheckAreaUnitIsValid(AreaUnit areaUnit, string parameterName);
    public static void CheckWktIsValid(string wkt, string parameterName);
    public static void CheckBufferCapTypeIsValid(BufferCapType bufferCapType, string parameterName);
    public static void CheckDistanceUnitIsValid(DistanceUnit distanceUnit, string parameterName);
    public static void CheckPointLineIsIntersected(PointShape pointShape, string pointShapeName, LineShape lineShape, string lineShapeName, double tolerance);
    public static void CheckPointSymbolTypeIsValid(PointSymbolType symbolType, string parameterName);
    public static void CheckPointTypeIsValid(PointType pointType, string parameterName);
    public static void CheckCanParseStringToDouble(string value, string parameterName);
    public static void CheckStringIsNotNullNorWhiteSpace(string value, string parameterName);
    public static void CheckStringIsValidDecimalDegree(string value, string parameterName);
    public static void CheckObjectsAreNotAllNull(object firstObject, object secondObject, string firstParameterName, string secondParameterName);
    public static void CheckTypeIsSupport(object instance, string typeName);
    public static void CheckCanvasWidthIsLargerThanZero(double canvasWidth, string parameterName);
    public static void CheckCanvasHeightIsLargerThanZero(double canvasHeight, string parameterName);
    public static void CheckGeographyUnitIsMeter(GeographyUnit geographyUnit, string parameterName);
    public static void CheckObjectIsNotNull(object parameterObject, string parameterName);
    public static void CheckObjectIsNotNull(object parameterObject, string parameterName, string exceptionMessage);
    public static void CheckInputValueIsLargerThan(double inputValue, string parameterName, double minValue, RangeCheckingInclusion includeMinValue);
    public static void CheckDateTimeIsInRange(DateTime inputDate, string parameterName, DateTime minDate, RangeCheckingInclusion includeMinValue, DateTime maxDate, RangeCheckingInclusion includeMaxValue);
    public static void CheckAreIntegerStrings(IEnumerable`1<string> ids, string parameterName);
    public static void CheckGeoCanvasIsInDrawing(bool isDrawing);
    public static void CheckScaleIsLargerThanZero(double imageScale, string parameterName);
    public static void CheckInputValueIsLargerThanZero(double value, string parameterName);
    public static void CheckObjectIsTargetType(object objectToTest, Type targetType, string operationName);
    public static void CheckLatitudeIsInRange(double latitude, string parameterName);
    public static void CheckLongitudeIsInRange(double longitude, string parameterName);
    public static void CheckInputValueIsInRange(double inputValue, string parameterName, double minValue, RangeCheckingInclusion includeMinValue, double maxValue, RangeCheckingInclusion includeMaxValue);
    public static void CheckInputValueIsInRange(double inputValue, string parameterName, double minValue, RangeCheckingInclusion includeMinValue, double maxValue, RangeCheckingInclusion includeMaxValue, string exceptionMessage);
    public static void CheckInputValueIsInRange(double inputValue, string parameterName, double minValue, double maxValue);
    public static void CheckInputValueIsLessThan(double inputValue, string parameterName, double maxValue, RangeCheckingInclusion includeMaxValue);
    public static void CheckInputValueIsValidDecimalDegree(double value, string parameterName);
    public static void CheckInputValueIsNotNaNNorInfinity(double value, string parameterName);
    public static void CheckFeatureSourceIsOpen(bool isOpen);
    public static void CheckRtreeSpatialIndexIsOpen(bool isOpen);
    public static void CheckRasterSourceIsOpen(bool isOpen);
    public static void CheckIsFastMode(bool fastMode);
    public static void CheckStringIsNotNullNorEmpty(string value, string parameterName);
    public static void CheckWkbIsValid(Byte[] wkb, string parameterName);
    public static void CheckHtmlColorIsValid(string htmlColor, string parameterName);
    public static void CheckFeatureSourceIsEditable(bool isEditable);
    public static void CheckCanModifyColumnStructure(bool canModifyColumnStructure);
    public static void CheckSpatialIndexIsDeletable(bool isDeletable);
    public static void CheckFeatureSourceIsInTransaction(bool isInTransaction);
    public static void CheckFeatureSourceIsNotInTransaction(bool isInTransaction);
    public static void CheckImageFormatSupport(string imageFormat);
    public static void CheckFileIsExist(string pathFilename);
    public static void CheckFileIsNotExist(string pathFilename);
    public static void CheckConnectionStringIsNotNull(string connectionString);
    public static void CheckLayerIsOpened(bool isOpen);
    public static void CheckLayerIsNotOpenedNorDrawing(bool isOpenOrDrawing);
    public static void CheckGeographyUnitIsValid(GeographyUnit geographyUnit, string parameterName);
    public static void CheckProjectionConverterIsOpen(bool isOpen);
    public static void CheckImageFormatIsValid(string imageFormat, Collection`1<string> outputFormats, string exceptionMessage);
    public static void CheckItemInCollection(string item, Collection`1<string> items, string exceptionMessage);
    public static void CheckItemsInCollection(Collection`1<string> items, Collection`1<string> itemCollection, string exceptionMessage);
    public static void CheckIEnumerableIsNotNullNorEmpty(IEnumerable values, string parameterName, string exceptionMessage);
    public static void CheckLayerHasBoundingBox(bool hasBoundingBox);
    public static void CheckFeatureColumnValueContainsColon(string value, string parameterName);
    public static void CheckFeatureSourceCanExecuteSqlQuery(bool canExecuteSqlQuery);
    public static void CheckNumberIsByte(int number, string paramterName);
    public static void CheckUriIsValid(Uri uri);
    public static void CheckStreamIsWritable(Stream stream, string parameterName);
    public static void CheckStringIsNotNullNorEmptyForOperation(string value, string exceptionMessage);
    public static void CheckStatus();
    public static void CheckLongIsNotGreaterThanUInt32MaxValue(long value);
    public static void CheckScaleIsValid(double scale, string parameterName);
    public static void CheckZoomLevelSetIsValid(ZoomLevelSet zoomLevelSet, string parameterName);
    internal static void rh0=(FileAccess readWriteMode, string parameterName);
}
public class ThinkGeo.Core.ValidFeatureFilterCondition : FilterCondition {
    [ObfuscationAttribute]
private FeatureValidationType validationType;
    public FeatureValidationType ValidationType { get; public set; }
    public ValidFeatureFilterCondition(FeatureValidationType validationType);
    public FeatureValidationType get_ValidationType();
    public void set_ValidationType(FeatureValidationType value);
    internal virtual bool SSM=(Feature feature);
}
public enum ThinkGeo.Core.ValueDrawingOrder : Enum {
    public int value__;
    public static ValueDrawingOrder Default;
    public static ValueDrawingOrder OrderByFeatures;
    public static ValueDrawingOrder OrderByValueItems;
}
public class ThinkGeo.Core.ValueItem : object {
    [ObfuscationAttribute]
private string value;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    [ObfuscationAttribute]
private LineStyle defaultLineStyle;
    [ObfuscationAttribute]
private AreaStyle defaultAreaStyle;
    [ObfuscationAttribute]
private TextStyle defaultTextStyle;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    public string Value { get; public set; }
    public AreaStyle DefaultAreaStyle { get; public set; }
    public LineStyle DefaultLineStyle { get; public set; }
    public PointStyle DefaultPointStyle { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    public ValueItem(string value, AreaStyle areaStyle);
    public ValueItem(string value, LineStyle lineStyle);
    public ValueItem(string value, PointStyle pointStyle);
    public ValueItem(string value, TextStyle textStyle);
    public ValueItem(string value, Collection`1<Style> customStyles);
    private ValueItem(string value, AreaStyle areaStyle, LineStyle lineStyle, PointStyle pointStyle, TextStyle textStyle, Collection`1<Style> styles);
    public string get_Value();
    public void set_Value(string value);
    public AreaStyle get_DefaultAreaStyle();
    public void set_DefaultAreaStyle(AreaStyle value);
    public LineStyle get_DefaultLineStyle();
    public void set_DefaultLineStyle(LineStyle value);
    public PointStyle get_DefaultPointStyle();
    public void set_DefaultPointStyle(PointStyle value);
    public TextStyle get_DefaultTextStyle();
    public void set_DefaultTextStyle(TextStyle value);
    public Collection`1<Style> get_CustomStyles();
}
public class ThinkGeo.Core.ValueStyle : Style {
    [ObfuscationAttribute]
private string columnName;
    [ObfuscationAttribute]
private Collection`1<ValueItem> valueItems;
    [ObfuscationAttribute]
private ValueDrawingOrder drawingOrder;
    public string ColumnName { get; public set; }
    public ValueDrawingOrder DrawingOrder { get; public set; }
    public Collection`1<ValueItem> ValueItems { get; }
    public ValueStyle(string columnName, Collection`1<ValueItem> valueItems);
    public string get_ColumnName();
    public void set_ColumnName(string value);
    public ValueDrawingOrder get_DrawingOrder();
    public void set_DrawingOrder(ValueDrawingOrder value);
    public Collection`1<ValueItem> get_ValueItems();
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual Collection`1<string> GetRequiredColumnNamesCore();
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    [IteratorStateMachineAttribute("ThinkGeo.Core.ValueStyle/rUA=")]
private IEnumerable`1<Style> szE=();
    private static void tjE=(Collection`1<string> requiredFieldNames, Collection`1<string> fieldNames);
}
public class ThinkGeo.Core.VectorTile : Tile {
    [ObfuscationAttribute]
private Byte[] content;
    public Byte[] Content { get; public set; }
    public VectorTile(Byte[] content, int zoom, long column, long row);
    public Byte[] get_Content();
    public void set_Content(Byte[] value);
    private static RectangleShape 1B0=(int zoom, long column, long row);
    internal Collection`1<Feature> 1R0=();
    internal Collection`1<Feature> 1R0=(List`1<string> pbfLayerNames);
    public Collection`1<PbfLayer> GetPbfLayers();
}
[ObfuscationAttribute]
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ThinkGeo.Core.VectorTileExceptionDescription : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CheckVarintIsInvalid { get; }
    internal static string CallViewError { get; }
    internal static string CheckWireTypeIsNotBytes { get; }
    internal static string CheckTagIsOutOfRange { get; }
    internal static string CallSkipError { get; }
    internal static string CheckWireTypeIsDefined { get; }
    internal static string CheckWireTypeIsKnown { get; }
    internal static string CheckSkipBytesIsValid { get; }
    internal static string CheckDataIsNotEmpty { get; }
    internal static string CheckDataIsZipped { get; }
    internal static string CheckVectorTileFeatureTagsIsEven { get; }
    internal static string CheckValueTypeIsValid { get; }
    internal static string DownloadFileFromNetworkError { get; }
    internal static string CheckColumnValuesAreValidInTileRange { get; }
    internal static string CheckRowValuesAreValidInTileRange { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CheckVarintIsInvalid();
    internal static string get_CallViewError();
    internal static string get_CheckWireTypeIsNotBytes();
    internal static string get_CheckTagIsOutOfRange();
    internal static string get_CallSkipError();
    internal static string get_CheckWireTypeIsDefined();
    internal static string get_CheckWireTypeIsKnown();
    internal static string get_CheckSkipBytesIsValid();
    internal static string get_CheckDataIsNotEmpty();
    internal static string get_CheckDataIsZipped();
    internal static string get_CheckVectorTileFeatureTagsIsEven();
    internal static string get_CheckValueTypeIsValid();
    internal static string get_DownloadFileFromNetworkError();
    internal static string get_CheckColumnValuesAreValidInTileRange();
    internal static string get_CheckRowValuesAreValidInTileRange();
}
public class ThinkGeo.Core.Vertex : ValueType {
    [ObfuscationAttribute]
private double x;
    [ObfuscationAttribute]
private double y;
    public double X { get; public set; }
    public double Y { get; public set; }
    public Vertex(double x, double y);
    public Vertex(PointShape point);
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private bool khU=(Vertex compareObj);
    public Vertex Add(Vertex targetVertex);
    public static Vertex op_Addition(Vertex vertex1, Vertex vertex2);
    public static bool op_Equality(Vertex vertex1, Vertex vertex2);
    public static bool op_Inequality(Vertex vertex1, Vertex vertex2);
    public static Vertex FindMiddleVertexBetweenTwoVertices(Vertex vertex1, Vertex vertex2);
    internal void jBw=(double xOffset, double yOffset, GeographyUnit shapeUnit, DistanceUnit unitOfOffset);
    internal void jRw=(double distance, double angleInDegrees, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    internal void jhw=(Vertex vertex, double degreeAngle);
    internal void jhw=(PointShape pivotPoint, double degreeAngle);
    internal double jxw=(BaseShape targetShape, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    internal double jxw=(Vertex targetVertex, GeographyUnit shapeUnit, DistanceUnit distanceUnit);
    internal double kBw=(double toX, double toY);
    private PointShape cBw=(double offset, float degree);
}
public class ThinkGeo.Core.VertexAddedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature affectedFeature;
    [ObfuscationAttribute]
private Vertex addedVertex;
    public Feature AffectedFeature { get; public set; }
    public Vertex AddedVertex { get; public set; }
    public VertexAddedEditInteractiveOverlayEventArgs(Feature affectedFeature, Vertex addedVertex);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    public Vertex get_AddedVertex();
    public void set_AddedVertex(Vertex value);
}
public class ThinkGeo.Core.VertexAddedTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Vertex addedVertex;
    [ObfuscationAttribute]
private Feature affectedFeature;
    public Vertex AddedVertex { get; public set; }
    public Feature AffectedFeature { get; public set; }
    public VertexAddedTrackInteractiveOverlayEventArgs(Vertex addedVertex, Feature affectedFeature);
    public Vertex get_AddedVertex();
    public void set_AddedVertex(Vertex value);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
}
public class ThinkGeo.Core.VertexAddingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature affectedFeature;
    [ObfuscationAttribute]
private Vertex addingVertex;
    [ObfuscationAttribute]
private bool cancel;
    [CompilerGeneratedAttribute]
private PointShape qBQ=;
    public Feature AffectedFeature { get; public set; }
    public Vertex AddingVertex { get; public set; }
    public bool Cancel { get; public set; }
    public PointShape TargetPointShape { get; public set; }
    public VertexAddingEditInteractiveOverlayEventArgs(bool cancel, Feature affectedFeature, Vertex addingVertex);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    public Vertex get_AddingVertex();
    public void set_AddingVertex(Vertex value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    [CompilerGeneratedAttribute]
public PointShape get_TargetPointShape();
    [CompilerGeneratedAttribute]
public void set_TargetPointShape(PointShape value);
}
public class ThinkGeo.Core.VertexAddingTrackInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private bool cancel;
    [ObfuscationAttribute]
private Vertex addingVertex;
    [ObfuscationAttribute]
private Feature affectedFeature;
    [CompilerGeneratedAttribute]
private PointShape qBQ=;
    public bool Cancel { get; public set; }
    public Vertex AddingVertex { get; public set; }
    public Feature AffectedFeature { get; public set; }
    public PointShape TargetPointShape { get; public set; }
    public VertexAddingTrackInteractiveOverlayEventArgs(Vertex addingVertex, Feature affectedFeature, bool cancel);
    public bool get_Cancel();
    public void set_Cancel(bool value);
    public Vertex get_AddingVertex();
    public void set_AddingVertex(Vertex value);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    [CompilerGeneratedAttribute]
public PointShape get_TargetPointShape();
    [CompilerGeneratedAttribute]
public void set_TargetPointShape(PointShape value);
}
public class ThinkGeo.Core.VertexMovedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature affectedFeature;
    [ObfuscationAttribute]
private Vertex movedVertex;
    public Feature AffectedFeature { get; public set; }
    public Vertex MovedVertex { get; public set; }
    public VertexMovedEditInteractiveOverlayEventArgs(Feature affectedFeature, Vertex movedVertex);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    public Vertex get_MovedVertex();
    public void set_MovedVertex(Vertex value);
}
public class ThinkGeo.Core.VertexMovingEditInteractiveOverlayEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Feature qRQ=;
    [CompilerGeneratedAttribute]
private Vertex qhQ=;
    [CompilerGeneratedAttribute]
private PointShape qxQ=;
    [CompilerGeneratedAttribute]
private bool rBQ=;
    public Feature AffectedFeature { get; public set; }
    public Vertex MovingVertex { get; public set; }
    public PointShape TargetVertex { get; public set; }
    public bool Cancel { get; public set; }
    public VertexMovingEditInteractiveOverlayEventArgs(bool cancel, Feature affectedFeature, Vertex movingVertex);
    public VertexMovingEditInteractiveOverlayEventArgs(bool cancel, Feature affectedFeature, Vertex movingVertex, PointShape targetVertex);
    [CompilerGeneratedAttribute]
public Feature get_AffectedFeature();
    [CompilerGeneratedAttribute]
public void set_AffectedFeature(Feature value);
    [CompilerGeneratedAttribute]
public Vertex get_MovingVertex();
    [CompilerGeneratedAttribute]
public void set_MovingVertex(Vertex value);
    [CompilerGeneratedAttribute]
public PointShape get_TargetVertex();
    [CompilerGeneratedAttribute]
public void set_TargetVertex(PointShape value);
    [CompilerGeneratedAttribute]
public bool get_Cancel();
    [CompilerGeneratedAttribute]
public void set_Cancel(bool value);
}
public class ThinkGeo.Core.VertexRemovedEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature affectedFeature;
    [ObfuscationAttribute]
private Vertex removedVertex;
    public Feature AffectedFeature { get; public set; }
    public Vertex RemovedVertex { get; public set; }
    public VertexRemovedEditInteractiveOverlayEventArgs(Feature affectedFeature, Vertex removedVertex);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    public Vertex get_RemovedVertex();
    public void set_RemovedVertex(Vertex value);
}
public class ThinkGeo.Core.VertexRemovingEditInteractiveOverlayEventArgs : EventArgs {
    [ObfuscationAttribute]
private Feature affectedFeature;
    [ObfuscationAttribute]
private Vertex removingVertex;
    [ObfuscationAttribute]
private bool cancel;
    public Feature AffectedFeature { get; public set; }
    public Vertex RemovingVertex { get; public set; }
    public bool Cancel { get; public set; }
    public VertexRemovingEditInteractiveOverlayEventArgs(bool cancel, Feature affectedFeature, Vertex removingVertex);
    public Feature get_AffectedFeature();
    public void set_AffectedFeature(Feature value);
    public Vertex get_RemovingVertex();
    public void set_RemovingVertex(Vertex value);
    public bool get_Cancel();
    public void set_Cancel(bool value);
}
public class ThinkGeo.Core.WarningMessage : object {
    public static string UseAsyncVersion;
    public static string WebRequestObsoleted;
    public static string WebRequestObsoleted2;
    public static string AttributionObsoleteMessage;
    public static string AutoRefreshOverlayObsoleteMessage;
}
public abstract class ThinkGeo.Core.WebBasedAsyncLayer : AsyncLayer {
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingHttpRequestMessageEventArgs> TB4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<ReceivedHttpResponseMessageEventArgs> TR4=;
    [CompilerGeneratedAttribute]
private HttpClient Th4=;
    [CompilerGeneratedAttribute]
private IWebProxy Bh4=;
    [CompilerGeneratedAttribute]
private int BR4=;
    [CompilerGeneratedAttribute]
private ICredentials Tx4=;
    [CompilerGeneratedAttribute]
private string UB4=;
    protected HttpClient HttpClient { get; protected set; }
    public IWebProxy WebProxy { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public ICredentials Credentials { get; public set; }
    public string UserAgent { get; public set; }
    [CompilerGeneratedAttribute]
public void add_SendingHttpRequest(EventHandler`1<SendingHttpRequestMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingHttpRequest(EventHandler`1<SendingHttpRequestMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ReceivedHttpResponse(EventHandler`1<ReceivedHttpResponseMessageEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ReceivedHttpResponse(EventHandler`1<ReceivedHttpResponseMessageEventArgs> value);
    [CompilerGeneratedAttribute]
protected HttpClient get_HttpClient();
    [CompilerGeneratedAttribute]
protected void set_HttpClient(HttpClient value);
    [CompilerGeneratedAttribute]
public sealed virtual IWebProxy get_WebProxy();
    [CompilerGeneratedAttribute]
public sealed virtual void set_WebProxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_TimeoutInSeconds();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TimeoutInSeconds(int value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WebBasedAsyncLayer/XT8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual ICredentials get_Credentials();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Credentials(ICredentials value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WebBasedAsyncLayer/Xj8=")]
protected Task`1<HttpResponseMessage> SendWebRequestAsync(HttpRequestMessage httpRequest, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual string get_UserAgent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_UserAgent(string value);
    public Task`1<Byte[]> FetchImageAsync(HttpRequestMessage requestMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WebBasedAsyncLayer/WD8=")]
protected Task`1<Byte[]> FetchImageAsyncCore(HttpRequestMessage requestMessage, CancellationToken cancellationToken);
    public Task`1<Byte[]> DownloadImageAsync(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    protected virtual void OnSendingHttpRequestMessage(SendingHttpRequestMessageEventArgs e);
    protected virtual void OnReceivedHttpResponseMessage(ReceivedHttpResponseMessageEventArgs e);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task /h0=(CancellationToken cancellationToken);
}
public enum ThinkGeo.Core.WellKnownType : Enum {
    public int value__;
    public static WellKnownType Invalid;
    public static WellKnownType Point;
    public static WellKnownType Line;
    public static WellKnownType Polygon;
    public static WellKnownType Multipoint;
    public static WellKnownType Multiline;
    public static WellKnownType Multipolygon;
    public static WellKnownType GeometryCollection;
}
public class ThinkGeo.Core.WellPointStyle : PointBaseStyle {
    [ObfuscationAttribute]
private int wellPointIndex;
    public int WellPointIndex { get; public set; }
    public WellPointStyle(int wellPointIndex);
    public WellPointStyle(int wellPointIndex, int symbolSize, GeoBrush fillBrush);
    public WellPointStyle(int wellPointIndex, int symbolSize, GeoBrush fillBrush, GeoPen outlinePen);
    private void SDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void STI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void SjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void SzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void TDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void TTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void TjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void TzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void UDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void UTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void UjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void UzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void VDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void VTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void VjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void VzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void WDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void WTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void WjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void WzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void XDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void XTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void XjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void XzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void YDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void YTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void YjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void YzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ZDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ZTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ZjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ZzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void aDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void aTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ajI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void azI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void bDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void bTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void bjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void bzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void cDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void cTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void cjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void czI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void dDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void dTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void djI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void dzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void eDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void eTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ejI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ezI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void fDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void fTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void fjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void fzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void gDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void gTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void gjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void gzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void hDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void hTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void hjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void hzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void iDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void iTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ijI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void izI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void jDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void jTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void jjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void jzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void kDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void kTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void kjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void kzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void lDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void lTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ljI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void lzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void mDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void mTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void mjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void mzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void nDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void nTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void njI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void nzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void oDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void oTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ojI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ozI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void pDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void pTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void pjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void pzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void qDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void qTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void qjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void qzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void rDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void rTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void rjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void rzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void sDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void sTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void sjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void szI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void tDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void tTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void tjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void tzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void uDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void uTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ujI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void uzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void vDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void vTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void vjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void vzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void wDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void wTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void wjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void wzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void xDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void xTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void xjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void xzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void yDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void yTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void yjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void yzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void zDI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void zTI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void zjI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void zzI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 0DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 0TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 0jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 0zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 1DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 1TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 1jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 1zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 2DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 2TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 2jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 2zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 3DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 3TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 3jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 3zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 4DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 4TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 4jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 4zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 5DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 5TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 5jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 5zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 6DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 6TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 6jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 6zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 7DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 7TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 7jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 7zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 8DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 8TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 8jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 8zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void 9DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 9TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void 9jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void 9zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void /DI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void /TI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void /jI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void /zI=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void ADM=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void ATM=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void AjM=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private void AzM=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen, bool useFillBrush);
    private void BDM=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    private static Feature BTM=(PointShape centerPoint, double resolutionX, double resolutionY, double radius);
    private static Feature BjM=(PointShape centerPoint, double resolutionX, double resolutionY, double radius);
    private static Feature BzM=(PointShape centerPoint, double resolutionX, double resolutionY, double radius);
    private void CDM=(Feature feature, GeoCanvas canvas, GeoPen haloPen, GeoBrush geobrush, PointShape centerPoint, double resolutionX, double resolutionY, float radius, float halfRadius, bool useFillBrush);
    private void CTM=(Feature feature, GeoCanvas canvas, GeoPen haloPen, GeoBrush geoBrush, string letter);
    private void CjM=(Feature feature, GeoCanvas canvas, GeoBrush geoBrush, GeoPen haloPen);
    public int get_WellPointIndex();
    public void set_WellPointIndex(int value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    protected virtual void DrawSampleCore(GeoCanvas canvas, DrawingRectangleF drawingExtent);
    private RectangleShape NxU=(DrawingRectangleF drawingRectangle, GeoCanvas canvas);
    private void CzM=(Feature feature, GeoCanvas canvas, GeoPen geoPen, GeoBrush geoBrush);
}
public class ThinkGeo.Core.WfsFeatureLayer : FeatureLayer {
    public string LastXmlResponse { get; }
    public string ServiceLocationUrl { get; public set; }
    public string TypeName { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public bool HasBoundingBox { get; }
    public IWebProxy WebProxy { get; public set; }
    public WfsFeatureLayer(string serviceLocationUrl, string typeName);
    public string get_LastXmlResponse();
    public string get_ServiceLocationUrl();
    public void set_ServiceLocationUrl(string value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public virtual bool get_HasBoundingBox();
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public static string GetCapabilities(string serviceLocationUrl);
    public static string GetCapabilities(Uri serverUri);
    public static string GetCapabilities(Uri serverUri, IWebProxy webProxy);
    public static Collection`1<string> GetLayers(string serviceLocationUrl);
    public static Collection`1<string> GetLayers(Uri serverUri, IWebProxy webProxy);
    public static Collection`1<string> GetLayers(Uri serverUri);
}
public class ThinkGeo.Core.WfsFeatureSource : FeatureSource {
    private static string zyM=;
    private static string ETA=;
    private static string EjA=;
    private static Dictionary`2<string, Dictionary`2<string, string>> JjA=;
    [ObfuscationAttribute]
private string version;
    [ObfuscationAttribute]
private WfsNamespace wfsNamespace;
    [ObfuscationAttribute]
private IWebProxy webProxy;
    private Collection`1<FeatureSourceColumn> 0CM=;
    private string FTA=;
    [ObfuscationAttribute]
private string lastXmlResponse;
    [ObfuscationAttribute]
private string serviceLocationUrl;
    [ObfuscationAttribute]
private int timeoutInSeconds;
    [ObfuscationAttribute]
private string typeName;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingWebRequestEventArgs> vhQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentWebRequestEventArgs> vxQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> 1CM=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> 1SM=;
    public string ServiceLocationUrl { get; public set; }
    public WfsNamespace WfsNamespace { get; public set; }
    public string TypeName { get; public set; }
    public string LastXmlResponse { get; }
    public int TimeoutInSeconds { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public WfsFeatureSource(string serviceLocationUrl, string typeName);
    private static WfsFeatureSource();
    [CompilerGeneratedAttribute]
public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    public string get_ServiceLocationUrl();
    public void set_ServiceLocationUrl(string value);
    public WfsNamespace get_WfsNamespace();
    public void set_WfsNamespace(WfsNamespace value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public string get_LastXmlResponse();
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public void add_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestingData(RequestingDataWfsFeatureSourceEventArgs requestingDataWfsFeatureSourceEventArgs);
    [CompilerGeneratedAttribute]
public void add_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestedData(RequestedDataWfsFeatureSourceEventArgs requestedDataWfsFeatureSourceEventArgs);
    protected WebResponse SendWebRequest(WebRequest webRequest);
    protected virtual WebResponse SendWebRequestCore(WebRequest webRequest);
    protected virtual void OnSendingWebRequest(SendingWebRequestEventArgs e);
    protected virtual void OnSentWebRequest(SentWebRequestEventArgs e);
    public static string GetCapabilities(string serviceLocationUrl);
    public static string GetCapabilities(Uri serverUri);
    public static string GetCapabilities(Uri serverUri, IWebProxy webProxy);
    private static string JzA=(XmlDocument xmlDocument);
    private static void ZR4=(string requestCapabilities, XmlDocument xmlDocument);
    private static XmlDocument 1yM=(string requestCapabilities);
    public static Collection`1<string> GetLayers(string serviceLocationUrl);
    public static Collection`1<string> GetLayers(Uri serverUri);
    public static Collection`1<string> GetLayers(Uri serverUri, IWebProxy webProxy);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    private void KDA=(XmlReader reader);
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private Stream FjA=(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private Stream FzA=(string requestString);
    private Feature zCE=(XmlReader reader, IEnumerable`1<string> columnNames);
    private static string GDA=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string GTA=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string GjA=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string GzA=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string HDA=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string HTA=(XmlReader reader, string shapeTypeName, string coordinatesName, string version);
    private static string HjA=(string tempString, string version);
    private string HzA=();
    private string IDA=(RectangleShape boundingBox);
    private static string ITA=(string shapeType);
    private bool IjA=(string shapeType);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    private XmlReader IzA=(Stream stream);
}
public enum ThinkGeo.Core.WfsNamespace : Enum {
    public int value__;
    public static WfsNamespace Null;
    public static WfsNamespace Ogc;
}
public class ThinkGeo.Core.WfsV2FeatureLayer : FeatureLayer {
    public string LastXmlResponse { get; }
    public string ServiceLocationUrl { get; public set; }
    public string TypeName { get; public set; }
    public int TimeoutInSeconds { get; public set; }
    public bool HasBoundingBox { get; }
    public IWebProxy WebProxy { get; public set; }
    public WfsV2FeatureLayer(string serviceLocationUrl, string typeName);
    public string get_LastXmlResponse();
    public string get_ServiceLocationUrl();
    public void set_ServiceLocationUrl(string value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public virtual bool get_HasBoundingBox();
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    public static string GetCapabilities(string serviceLocationUrl);
    public static string GetCapabilities(Uri serverUri);
    public static string GetCapabilities(Uri serverUri, IWebProxy webProxy);
    public static Collection`1<string> GetLayers(string serviceLocationUrl);
    public static Collection`1<string> GetLayers(Uri serverUri, IWebProxy webProxy);
    public static Collection`1<string> GetLayers(Uri serverUri);
}
public class ThinkGeo.Core.WfsV2FeatureSource : FeatureSource {
    private static string zyM=;
    private static string ETA=;
    private static string EjA=;
    private static string EzA=;
    private static string FDA=;
    [ObfuscationAttribute]
private WfsNamespace wfsNamespace;
    [ObfuscationAttribute]
private IWebProxy webProxy;
    private Collection`1<FeatureSourceColumn> 0CM=;
    private string FTA=;
    [ObfuscationAttribute]
private string lastXmlResponse;
    [ObfuscationAttribute]
private string serviceLocationUrl;
    [ObfuscationAttribute]
private int timeoutInSeconds;
    [ObfuscationAttribute]
private string typeName;
    [CompilerGeneratedAttribute]
private EventHandler`1<SendingWebRequestEventArgs> vhQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<SentWebRequestEventArgs> vxQ=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> 1CM=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> 1SM=;
    public string ServiceLocationUrl { get; public set; }
    public WfsNamespace WfsNamespace { get; public set; }
    public string TypeName { get; public set; }
    public string LastXmlResponse { get; }
    public int TimeoutInSeconds { get; public set; }
    public IWebProxy WebProxy { get; public set; }
    public WfsV2FeatureSource(string serviceLocationUrl, string typeName);
    [CompilerGeneratedAttribute]
public void add_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SendingWebRequest(EventHandler`1<SendingWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SentWebRequest(EventHandler`1<SentWebRequestEventArgs> value);
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    public string get_ServiceLocationUrl();
    public void set_ServiceLocationUrl(string value);
    public WfsNamespace get_WfsNamespace();
    public void set_WfsNamespace(WfsNamespace value);
    public string get_TypeName();
    public void set_TypeName(string value);
    public string get_LastXmlResponse();
    public int get_TimeoutInSeconds();
    public void set_TimeoutInSeconds(int value);
    public IWebProxy get_WebProxy();
    public void set_WebProxy(IWebProxy value);
    [CompilerGeneratedAttribute]
public void add_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestingData(EventHandler`1<RequestingDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestingData(RequestingDataWfsFeatureSourceEventArgs requestingDataWfsFeatureSourceEventArgs);
    [CompilerGeneratedAttribute]
public void add_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedData(EventHandler`1<RequestedDataWfsFeatureSourceEventArgs> value);
    protected virtual void OnRequestedData(RequestedDataWfsFeatureSourceEventArgs requestedDataWfsFeatureSourceEventArgs);
    protected WebResponse SendWebRequest(WebRequest webRequest);
    protected virtual WebResponse SendWebRequestCore(WebRequest webRequest);
    protected virtual void OnSendingWebRequest(SendingWebRequestEventArgs e);
    protected virtual void OnSentWebRequest(SentWebRequestEventArgs e);
    public static string GetCapabilities(string serviceLocationUrl);
    public static string GetCapabilities(Uri serverUri);
    public static XmlDocument GetCapabilities(Uri serverUri, IWebProxy webProxy);
    public static string GetCapabilitiesStringFromXml(XmlDocument xmlDocument);
    private static void ZR4=(string requestCapabilities, XmlDocument xmlDocument);
    private static XmlDocument 1yM=(string requestCapabilities);
    public static Collection`1<string> GetLayers(string serviceLocationUrl);
    public static Collection`1<string> GetLayers(Uri serverUri);
    public static Collection`1<string> GetLayers(Uri serverUri, IWebProxy webProxy);
    protected virtual void OpenCore();
    protected virtual void CloseCore();
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    public Collection`1<string> GetSupportedCrs();
    public string GetDefaultCrs();
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    public string GetRequestUrlForFeatures(RectangleShape boundingBox, int count, int startIndex);
    public ValueTuple`2<int, Collection`1<Feature>> GetFeatures(string requestUrl);
    private Stream FjA=(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    private Stream FzA=(string requestString);
    private Feature zCE=(XmlReader reader, IEnumerable`1<string> columnNames);
    private static string GDA=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string GTA=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string GjA=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string GzA=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string HDA=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string HTA=(XmlReader reader, string shapeTypeName, string coordinatesName);
    private static string HjA=(string tempString);
    private string HzA=();
    private string IDA=(RectangleShape boundingBox);
    private static string ITA=(string shapeType);
    private bool IjA=(string shapeType);
    protected virtual Collection`1<Feature> GetFeaturesByColumnValueCore(string columnName, string columnValue, IEnumerable`1<string> returningColumnNames);
    private XmlReader IzA=(Stream stream);
    [CompilerGeneratedAttribute]
private bool JDA=(XElement el);
    [CompilerGeneratedAttribute]
private bool JTA=(XElement el);
}
public class ThinkGeo.Core.WindBarbStyle : Style {
    [CompilerGeneratedAttribute]
private string sSM=;
    [CompilerGeneratedAttribute]
private string siM=;
    [CompilerGeneratedAttribute]
private DrawingLevel syM=;
    [CompilerGeneratedAttribute]
private float tCM=;
    [CompilerGeneratedAttribute]
private GeoPen tSM=;
    [CompilerGeneratedAttribute]
private GeoBrush tiM=;
    public string WindDirectionAngleColumnName { get; public set; }
    public string WindSpeedInKnotsColumnName { get; public set; }
    public DrawingLevel DrawingLevel { get; public set; }
    public float SymbolSize { get; public set; }
    public GeoPen Pen { get; public set; }
    public GeoBrush Brush { get; public set; }
    [CompilerGeneratedAttribute]
public string get_WindDirectionAngleColumnName();
    [CompilerGeneratedAttribute]
public void set_WindDirectionAngleColumnName(string value);
    [CompilerGeneratedAttribute]
public string get_WindSpeedInKnotsColumnName();
    [CompilerGeneratedAttribute]
public void set_WindSpeedInKnotsColumnName(string value);
    [CompilerGeneratedAttribute]
public DrawingLevel get_DrawingLevel();
    [CompilerGeneratedAttribute]
public void set_DrawingLevel(DrawingLevel value);
    [CompilerGeneratedAttribute]
public float get_SymbolSize();
    [CompilerGeneratedAttribute]
public void set_SymbolSize(float value);
    [CompilerGeneratedAttribute]
public GeoPen get_Pen();
    [CompilerGeneratedAttribute]
public void set_Pen(GeoPen value);
    [CompilerGeneratedAttribute]
public GeoBrush get_Brush();
    [CompilerGeneratedAttribute]
public void set_Brush(GeoBrush value);
    protected virtual void DrawCore(IEnumerable`1<Feature> features, GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInThisLayer, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static BaseShape tyM=(GeoCanvas canvas, PointShape centerPoint, float radius, Vertex lineEnd, int lineLocation, FkA= windBarbType, float symbolSize, double angle);
}
public enum ThinkGeo.Core.WkbByteOrder : Enum {
    public int value__;
    public static WkbByteOrder LittleEndian;
    public static WkbByteOrder BigEndian;
}
public class ThinkGeo.Core.WkbFileFeatureLayer : FeatureLayer {
    [ObfuscationAttribute]
private static int turnCount;
    [ObfuscationAttribute]
private int progressiveDrawingRecordsCount;
    public FileAccess ReadWriteMode { get; public set; }
    public string WkbPathFilename { get; public set; }
    public int ProgressiveDrawingRecordsCount { get; public set; }
    public bool HasBoundingBox { get; }
    public WkbFileFeatureLayer(string wkbPathFilename);
    public WkbFileFeatureLayer(string wkbPathFilename, FileAccess readWriteMode);
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public string get_WkbPathFilename();
    public void set_WkbPathFilename(string value);
    public int get_ProgressiveDrawingRecordsCount();
    public void set_ProgressiveDrawingRecordsCount(int value);
    public virtual bool get_HasBoundingBox();
    public static void CreateWkbFile(string pathFilename, WkbFileType wkbFileType, IEnumerable`1<FeatureSourceColumn> columns, IEnumerable`1<Feature> features);
    public WkbFileType GetWkbFileType();
    protected virtual void DrawCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private void diQ=(GeoCanvas canvas, RectangleShape marginWorldExtent, Collection`1<SimpleCandidate> labelsInAllLayers, ZoomLevel currentZoomLevel, Collection`1<string> columnNames, WkbFileFeatureSource wkbFileFeatureSource, Collection`1<RectangleShape> smallBoxes, Collection`1<string> ids);
    private void dyQ=(GeoCanvas canvas, RectangleShape drawingExtent, Collection`1<SimpleCandidate> labelsInAllLayers, ZoomLevel currentZoomLevel, Collection`1<string> columnNames, Collection`1<string> columnNamesForDrawing, WkbFileFeatureSource shapeFileFeatureSource, Collection`1<string> idsToDraw, Collection`1<string> fieldNamesOutsideOfSource);
    private bool WSQ=(int progressPercentage, object userState, int featuresToDraw, int featuresDrawn);
    private static void eSQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private static void eiQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private static void eyQ=(Collection`1<RectangleShape> smallBoxes, Collection`1<Feature> resultFeatures, Collection`1<string> columnNames);
    private void KjA=(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers, ZoomLevel currentZoomLevel, Collection`1<string> columnNames, RectangleShape marginWorldExtent);
    private static BaseShape qho=(ProjectionConverter projection, BaseShape shape);
}
public class ThinkGeo.Core.WkbFileFeatureSource : FeatureSource {
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private int columnCount;
    [ObfuscationAttribute]
private Collection`1<FeatureSourceColumn> columns;
    [ObfuscationAttribute]
private int featureCount;
    [ObfuscationAttribute]
private int headerLength;
    [ObfuscationAttribute]
private FileAccess readWriteMode;
    [ObfuscationAttribute]
private RtreeSpatialIndex spatialIndex;
    [ObfuscationAttribute]
private int version;
    [ObfuscationAttribute]
private WkbFileType wkbFileType;
    [ObfuscationAttribute]
private string wkbPathFilename;
    [ObfuscationAttribute]
private BinaryReader wkbReader;
    [ObfuscationAttribute]
private BinaryWriter wkbWriter;
    [ObfuscationAttribute]
private BinaryReader wkxReader;
    [ObfuscationAttribute]
private BinaryWriter wkxWriter;
    [ObfuscationAttribute]
private static int cacheSize;
    [ObfuscationAttribute]
private long start;
    [ObfuscationAttribute]
private long end;
    [ObfuscationAttribute]
private Byte[] cache;
    [ObfuscationAttribute]
private int simplificationAreaInPixel;
    [ObfuscationAttribute]
private Collection`1<RectangleShape> simplifiedAreas;
    public int SimplificationAreaInPixel { get; public set; }
    public Collection`1<RectangleShape> SimplifiedAreas { get; }
    public FileAccess ReadWriteMode { get; public set; }
    public string WkbPathFilename { get; public set; }
    public WkbFileFeatureSource(string wkbPathFilename);
    public WkbFileFeatureSource(string wkbPathFilename, FileAccess readWriteMode);
    public int get_SimplificationAreaInPixel();
    public void set_SimplificationAreaInPixel(int value);
    public Collection`1<RectangleShape> get_SimplifiedAreas();
    public FileAccess get_ReadWriteMode();
    public void set_ReadWriteMode(FileAccess value);
    public string get_WkbPathFilename();
    public void set_WkbPathFilename(string value);
    public WkbFileType GetWkbFileType();
    protected virtual bool CanGetBoundingBoxQuicklyCore();
    protected virtual bool CanGetCountQuicklyCore();
    protected virtual void CloseCore();
    protected virtual Collection`1<Feature> GetFeaturesOutsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual TransactionResult CommitTransactionCore(TransactionBuffer transactions);
    protected virtual Collection`1<Feature> GetAllFeaturesCore(IEnumerable`1<string> returningColumnNames);
    protected virtual RectangleShape GetBoundingBoxCore();
    protected virtual Collection`1<FeatureSourceColumn> GetColumnsCore();
    protected virtual long GetCountCore();
    protected virtual Collection`1<Feature> GetFeaturesByIdsCore(IEnumerable`1<string> ids, IEnumerable`1<string> returningColumnNames);
    protected virtual Collection`1<Feature> GetFeaturesInsideBoundingBoxCore(RectangleShape boundingBox, IEnumerable`1<string> returningColumnNames);
    protected virtual WellKnownType GetFirstFeaturesWellKnownTypeCore();
    protected virtual void OpenCore();
    public Collection`1<string> GetFeatureIdsForDrawing(RectangleShape boundingBox, double screenWidth, double screenHeight);
    protected virtual Collection`1<string> GetFeatureIdsForDrawingCore(RectangleShape boundingBox, double screenWidth, double screenHeight);
    protected virtual Collection`1<string> GetFeatureIdsCore();
    public static void CreateWkbFile(string pathFilename, WkbFileType wkbFileType, IEnumerable`1<FeatureSourceColumn> columns, IEnumerable`1<Feature> features);
    private static void KzA=(WkbFileType wkbFileType, string fileNameOnly, string filePath);
    private long LDA=(string id);
    private long LTA=(string id);
    private Feature LjA=(string id, IEnumerable`1<string> returningColumnNames);
    private void Cyk=();
}
public enum ThinkGeo.Core.WkbFileType : Enum {
    public int value__;
    public static WkbFileType Point;
    public static WkbFileType Polyline;
    public static WkbFileType Polygon;
    public static WkbFileType Hybrid;
}
public enum ThinkGeo.Core.WkbShapeType : Enum {
    public int value__;
    public static WkbShapeType Point;
    public static WkbShapeType LineString;
    public static WkbShapeType Polygon;
    public static WkbShapeType Multipoint;
    public static WkbShapeType Multiline;
    public static WkbShapeType Multipolygon;
    public static WkbShapeType GeometryCollection;
}
public class ThinkGeo.Core.WmsAsyncLayer : WebBasedAsyncLayer {
    private XmlDocument UR4=;
    [ObfuscationAttribute]
private string _crs;
    [ObfuscationAttribute]
private String[] _exceptionFormats;
    [ObfuscationAttribute]
private RectangleShape _currentExtent;
    [ObfuscationAttribute]
private WmsOnlineResource[] _wmsRequests;
    [ObfuscationAttribute]
private bool _hasParsedCapabilities;
    [ObfuscationAttribute]
private Collection`1<string> _serverCrsCollection;
    [ObfuscationAttribute]
private Collection`1<string> _serverLayerNames;
    [ObfuscationAttribute]
private Collection`1<string> _serverOutputFormats;
    [ObfuscationAttribute]
private Collection`1<string> _serverFeatureInfoFormats;
    [ObfuscationAttribute]
private Collection`1<string> _serverStyleNames;
    [ObfuscationAttribute]
private string _version;
    [ObfuscationAttribute]
private int _height;
    [ObfuscationAttribute]
private int _width;
    private WmsServerLayer Uh4=;
    private Collection`1<WmsServerLayer> Ux4=;
    [ObfuscationAttribute]
private Uri _uri;
    [ObfuscationAttribute]
private WmsAxisOrder _axisOrder;
    [ObfuscationAttribute]
private string _hrefNamespace;
    [ObfuscationAttribute]
private String[] _availableHrefNamespace;
    [ObfuscationAttribute]
private bool _fastMode;
    private static object VB4=;
    [CompilerGeneratedAttribute]
private EventHandler`1<RequestedImageExceptionEventArgs> VR4=;
    [CompilerGeneratedAttribute]
private Collection`1<string> Vh4=;
    [CompilerGeneratedAttribute]
private Collection`1<string> Vx4=;
    [CompilerGeneratedAttribute]
private bool WB4=;
    [CompilerGeneratedAttribute]
private string WR4=;
    [CompilerGeneratedAttribute]
private string Wh4=;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> NB4=;
    [CompilerGeneratedAttribute]
private TimeSpan Wx4=;
    public Collection`1<string> ActiveLayerNames { get; }
    public Collection`1<string> ActiveStyleNames { get; }
    public Uri Uri { get; public set; }
    public string Version { get; }
    public bool IsTransparent { get; public set; }
    public string OutputFormat { get; public set; }
    public string Crs { get; public set; }
    public string Exceptions { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public WmsAxisOrder AxisOrder { get; public set; }
    public bool FastMode { get; public set; }
    public TimeSpan CapabilitiesCacheTimeout { get; public set; }
    public bool HasBoundingBox { get; }
    public WmsAsyncLayer(Uri uri);
    public WmsAsyncLayer(Uri uri, IWebProxy webProxy);
    public WmsAsyncLayer(Uri uri, IWebProxy webProxy, string crs, WmsAxisOrder axisOrder, string version, bool fastMode);
    public WmsAsyncLayer(Collection`1<WmsServerLayer> flatWmsServerLayers);
    private static WmsAsyncLayer();
    [CompilerGeneratedAttribute]
public void add_RequestedImageException(EventHandler`1<RequestedImageExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RequestedImageException(EventHandler`1<RequestedImageExceptionEventArgs> value);
    protected virtual void OnRequestedImageException(RequestedImageExceptionEventArgs e);
    [CompilerGeneratedAttribute]
public sealed virtual Collection`1<string> get_ActiveLayerNames();
    [CompilerGeneratedAttribute]
public sealed virtual Collection`1<string> get_ActiveStyleNames();
    public sealed virtual Uri get_Uri();
    public sealed virtual void set_Uri(Uri value);
    public sealed virtual string get_Version();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsTransparent();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsTransparent(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_OutputFormat();
    [CompilerGeneratedAttribute]
public sealed virtual void set_OutputFormat(string value);
    public sealed virtual string get_Crs();
    public sealed virtual void set_Crs(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Exceptions();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Exceptions(string value);
    [CompilerGeneratedAttribute]
public sealed virtual Dictionary`2<string, string> get_Parameters();
    public sealed virtual WmsAxisOrder get_AxisOrder();
    public sealed virtual void set_AxisOrder(WmsAxisOrder value);
    public sealed virtual bool get_FastMode();
    public sealed virtual void set_FastMode(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_CapabilitiesCacheTimeout();
    [CompilerGeneratedAttribute]
public sealed virtual void set_CapabilitiesCacheTimeout(TimeSpan value);
    public virtual bool get_HasBoundingBox();
    public Collection`1<WmsServerLayer> GetServerLayers();
    public Collection`1<string> GetServerStyleNames();
    public Collection`1<string> GetServerOutputFormats();
    public Collection`1<string> GetServerCrsCollection();
    public Collection`1<string> GetServerExceptionFormats();
    public string GetServiceVersion();
    public string GetServiceBaseUrl();
    public Collection`1<string> GetServerFeatureInfoFormats();
    public string GetServerCapabilitiesXml();
    public string GetRequestUrl(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    protected virtual string GetRequestUrlCore(RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/ez8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/YT8=")]
protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/Zj8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private bool rx0=();
    private static int XB4=(string texts, int fontSize);
    private static string whQ=(XmlDocument xmlDocument);
    private static string XR4=(string message, int width);
    private WmsOnlineResource Xh4=();
    private void Xx4=();
    private void YB4=(WmsServerLayer serverLayer);
    private void YR4=(WmsServerLayer serverLayer);
    private void Yh4=(WmsServerLayer serverLayer);
    private void Yx4=(WmsServerLayer layer);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/fD8=")]
private Task ZB4=(string url, CancellationToken cancellationToken);
    private static void ZR4=(string requestCapabilities, XmlDocument xmlDocument);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/az8=")]
private Task`1<XmlDocument> Zh4=(string requestCapabilities);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/dz8=")]
private Task`1<XmlDocument> Zx4=(string requestCapabilities, IWebProxy proxy, ICredentials credentials, CancellationToken cancellationToken);
    private void aB4=(XmlDocument xmlDocument, XmlNamespaceManager namespaceManager);
    private static string aR4=(XmlNode node, string nodeName, XmlNamespaceManager namespaceManager);
    private void ah4=(XmlNode nodeCapability, XmlNamespaceManager namespaceManager);
    private void ax4=(XmlNode xmlRequestNode, XmlNamespaceManager namespaceManager);
    private WmsServerLayer bB4=(XmlNode xmlLayer, XmlNamespaceManager namespaceManager);
    private XmlAttribute bR4=(XmlNode xmlNode);
    private RectangleShape bh4=(XmlNode xmlLayer, XmlNamespaceManager namespaceManager);
    private void bx4=(XmlNode xnException, XmlNamespaceManager namespaceManager);
    private void cB4=(HttpRequestMessage httpRequestMessage);
    private static Collection`1<string> cR4=(IEnumerable`1<string> collection);
    private static Collection`1<WmsServerLayer> cR4=(IEnumerable`1<WmsServerLayer> collection);
    private void ch4=(string propertyName);
    protected virtual string BuildWmsGetFeatureInfoUri(ScreenPointF screenPointF, string infoFormat, int maxFeatures);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/cT8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/cj8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/cz8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, string infoFormat, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/bj8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfo(ScreenPointF screenPointF, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/dT8=")]
public Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsync(ScreenPointF screenPointF, string infoFormat, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/dj8=")]
protected virtual Task`1<Dictionary`2<string, Collection`1<Feature>>> GetFeatureInfoAsyncCore(ScreenPointF screenPointF, string infoFormat, int maxFeatures, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/Yj8=")]
protected virtual Task`1<Byte[]> DownloadImageAsyncCore(double width, double height, double scaleFactor, RectangleShape extent, GeographyUnit mapUnit, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmsAsyncLayer/eD8=")]
internal Task`1<Dictionary`2<string, Collection`1<Feature>>> cx4=(HttpRequestMessage request, CancellationToken cancellationToken);
    internal Dictionary`2<string, Collection`1<Feature>> dB4=(XmlDocument xmlDocument);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task /h0=(CancellationToken cancellationToken);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task /x0=(CancellationToken cancellationToken);
}
public enum ThinkGeo.Core.WmsAxisOrder : Enum {
    public int value__;
    public static WmsAxisOrder Default;
    public static WmsAxisOrder XY;
    public static WmsAxisOrder YX;
}
public class ThinkGeo.Core.WmsLayerStyle : object {
    public WmsStyleLegend LengendUrl;
    public WmsOnlineResource StyleSheetUrl;
    [ObfuscationAttribute]
private string mAbstract;
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private string title;
    public string Title { get; public set; }
    public string Name { get; public set; }
    unknown string Abstract {public set; }
    public WmsLayerStyle(string name);
    public WmsLayerStyle(string name, string title);
    public string get_Title();
    public void set_Title(string value);
    public string get_Name();
    public void set_Name(string value);
    public void set_Abstract(string value);
}
[ObfuscationAttribute]
public class ThinkGeo.Core.WmsOnlineResource : ValueType {
    [ObfuscationAttribute]
private string onlineResource;
    [ObfuscationAttribute]
private string type;
    public string Type { get; public set; }
    public string OnlineResource { get; public set; }
    public WmsOnlineResource(string onlineResource, string type);
    public string get_Type();
    public void set_Type(string value);
    public string get_OnlineResource();
    public void set_OnlineResource(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class ThinkGeo.Core.WmsServerLayer : object {
    [ObfuscationAttribute]
private RectangleShape boudingBox;
    [ObfuscationAttribute]
private int cascaded;
    [ObfuscationAttribute]
private WmsServerLayer[] childLayers;
    [ObfuscationAttribute]
private String[] crs;
    [ObfuscationAttribute]
private int fixedHeight;
    [ObfuscationAttribute]
private int fixedWidth;
    [ObfuscationAttribute]
private String[] keyWords;
    [ObfuscationAttribute]
private string mAbstract;
    [ObfuscationAttribute]
private double maxScale;
    [ObfuscationAttribute]
private double minScale;
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private bool noSubsets;
    [ObfuscationAttribute]
private bool opaque;
    [ObfuscationAttribute]
private bool queryable;
    [ObfuscationAttribute]
private WmsLayerStyle[] styles;
    [ObfuscationAttribute]
private string title;
    public int Cascaded { get; public set; }
    public double MinScale { get; public set; }
    public double MaxScale { get; public set; }
    public string Title { get; public set; }
    public string Name { get; public set; }
    public string Abstract { get; public set; }
    public bool Queryable { get; public set; }
    public bool Opaque { get; public set; }
    public bool NoSubsets { get; public set; }
    public int FixedWidth { get; public set; }
    public int FixedHeight { get; public set; }
    public String[] KeyWords { get; public set; }
    public WmsLayerStyle[] Styles { get; public set; }
    public String[] Crs { get; public set; }
    public WmsServerLayer[] ChildLayers { get; public set; }
    public RectangleShape BoudingBox { get; public set; }
    public int get_Cascaded();
    public void set_Cascaded(int value);
    public double get_MinScale();
    public void set_MinScale(double value);
    public double get_MaxScale();
    public void set_MaxScale(double value);
    public string get_Title();
    public void set_Title(string value);
    public string get_Name();
    public void set_Name(string value);
    public string get_Abstract();
    public void set_Abstract(string value);
    public bool get_Queryable();
    public void set_Queryable(bool value);
    public bool get_Opaque();
    public void set_Opaque(bool value);
    public bool get_NoSubsets();
    public void set_NoSubsets(bool value);
    public int get_FixedWidth();
    public void set_FixedWidth(int value);
    public int get_FixedHeight();
    public void set_FixedHeight(int value);
    public String[] get_KeyWords();
    public void set_KeyWords(String[] value);
    public WmsLayerStyle[] get_Styles();
    public void set_Styles(WmsLayerStyle[] value);
    public String[] get_Crs();
    public void set_Crs(String[] value);
    public WmsServerLayer[] get_ChildLayers();
    public void set_ChildLayers(WmsServerLayer[] value);
    public RectangleShape get_BoudingBox();
    public void set_BoudingBox(RectangleShape value);
    public WmsServerLayer Clone();
}
public class ThinkGeo.Core.WmsStyleLegend : ValueType {
    [ObfuscationAttribute]
private int height;
    [ObfuscationAttribute]
private int width;
    public WmsOnlineResource OnlineResource;
    unknown int Width {public set; }
    unknown int Height {public set; }
    public void set_Width(int value);
    public void set_Height(int value);
}
public enum ThinkGeo.Core.WmsTileType : Enum {
    public int value__;
    public static WmsTileType Default;
    public static WmsTileType MultiTile;
    public static WmsTileType SingleTile;
}
public static class ThinkGeo.Core.WmsUtil : object {
    public static string VERSION_1_3_0;
    public static string VERSION_1_1_1;
    public static string GetMap;
    private static WmsUtil();
    public static WmsAxisOrder GetAxisOrder(WmsAxisOrder axisOrder, string wmsVersion, string crs);
    public static WmsOnlineResource GetBaseUrl(WmsOnlineResource[] wmsRequests);
    public static string GetRequestUrl(IWmsEntity wmsRasterSource, string baseUrl, RectangleShape worldExtent, int canvasWidth, int canvasHeight);
    private static bool rx0=(string version);
    private static Dictionary`2<string, string> sB0=(string query);
}
public class ThinkGeo.Core.WmtsAsyncLayer : XyzTileAsyncLayer {
    [ObfuscationAttribute]
private Collection`1<Uri> serverUris;
    [ObfuscationAttribute]
private Uri serverUri;
    [ObfuscationAttribute]
private Dictionary`2<string, WmtsTileMatrixSet> tileMatrixSets;
    [ObfuscationAttribute]
private Collection`1<WmtsServerLayer> wmtsServerLayers;
    [ObfuscationAttribute]
private string activeLayerName;
    [ObfuscationAttribute]
private string activeStyleName;
    [ObfuscationAttribute]
private WmtsServerEncodingType wmtsServerEncodingType;
    [ObfuscationAttribute]
private string tileMatrixSetName;
    [ObfuscationAttribute]
private Dictionary`2<string, string> parameters;
    [ObfuscationAttribute]
private string outputFormat;
    [ObfuscationAttribute]
private double lowerScale;
    [ObfuscationAttribute]
private double upperScale;
    [ObfuscationAttribute]
private XmlDocument xmlDoc;
    [ObfuscationAttribute]
private TimeSpan capabilitesCacheTimeout;
    [ObfuscationAttribute]
private double wmtsConversionFactorForMeter;
    [ObfuscationAttribute]
private Dictionary`2<string, string> dimensions;
    [ObfuscationAttribute]
private WmtsAxisOrder axisOrder;
    [ObfuscationAttribute]
private RasterTileCache projectedTileCache;
    [ObfuscationAttribute]
private bool isCacheOnly;
    [ObfuscationAttribute]
private Dictionary`2<WmtsServerEncodingType, string> getTileEncodingTypes;
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.4. Please use ServerUri instead.")]
public Collection`1<Uri> ServerUris { get; }
    public Uri ServerUri { get; public set; }
    private Dictionary`2<string, string> dx4= { get; private set; }
    public TimeSpan CapabilitesCacheTimeout { get; public set; }
    public string ActiveLayerName { get; public set; }
    public WmtsServerEncodingType WmtsServerEncodingType { get; public set; }
    public Collection`1<WmtsServerLayer> WmtsServerLayers { get; public set; }
    public string ActiveStyleName { get; public set; }
    public Dictionary`2<string, string> Parameters { get; }
    public string OutputFormat { get; public set; }
    public double LowerScale { get; public set; }
    public double UpperScale { get; public set; }
    public string TileMatrixSetName { get; public set; }
    public WmtsAxisOrder AxisOrder { get; public set; }
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.3. Please use ProjectionConverterFromServerProjection instead. ")]
public ProjectionConverter ProjectionConverter { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public bool IsCacheOnly { get; public set; }
    public Dictionary`2<string, WmtsTileMatrixSet> TileMatrixSets { get; }
    public bool HasBoundingBox { get; }
    public WmtsAsyncLayer(Uri serverUri);
    public WmtsAsyncLayer(Uri serverUri, IWebProxy webProxy);
    public WmtsAsyncLayer(Uri serverUri, IWebProxy webProxy, WmtsServerEncodingType wmtsServerEncodingType);
    public Collection`1<Uri> get_ServerUris();
    public Uri get_ServerUri();
    public void set_ServerUri(Uri value);
    private Dictionary`2<string, string> dR4=();
    private void dh4=(Dictionary`2<string, string> value);
    public TimeSpan get_CapabilitesCacheTimeout();
    public void set_CapabilitesCacheTimeout(TimeSpan value);
    public string get_ActiveLayerName();
    public void set_ActiveLayerName(string value);
    public WmtsServerEncodingType get_WmtsServerEncodingType();
    public void set_WmtsServerEncodingType(WmtsServerEncodingType value);
    public Collection`1<WmtsServerLayer> get_WmtsServerLayers();
    public void set_WmtsServerLayers(Collection`1<WmtsServerLayer> value);
    public string get_ActiveStyleName();
    public void set_ActiveStyleName(string value);
    public Dictionary`2<string, string> get_Parameters();
    public string get_OutputFormat();
    public void set_OutputFormat(string value);
    public double get_LowerScale();
    public void set_LowerScale(double value);
    public double get_UpperScale();
    public void set_UpperScale(double value);
    public string get_TileMatrixSetName();
    public void set_TileMatrixSetName(string value);
    public WmtsAxisOrder get_AxisOrder();
    public void set_AxisOrder(WmtsAxisOrder value);
    public ProjectionConverter get_ProjectionConverter();
    public void set_ProjectionConverter(ProjectionConverter value);
    public RasterTileCache get_ProjectedTileCache();
    public void set_ProjectedTileCache(RasterTileCache value);
    public bool get_IsCacheOnly();
    public void set_IsCacheOnly(bool value);
    public Dictionary`2<string, WmtsTileMatrixSet> get_TileMatrixSets();
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/lj8=")]
protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    public virtual bool get_HasBoundingBox();
    public RectangleShape GetWGS84BoundingBox();
    protected virtual RectangleShape GetBoundingBoxCore();
    public Collection`1<Uri> GetRequestUris(RectangleShape requestExtent, int canvasWidth, int canvasHeight);
    protected virtual Collection`1<Uri> GetRequestUrisCore(RectangleShape requestExtent, int canvasWidth, int canvasHeight);
    public string GetServerCapabilitiesXml();
    public Collection`1<string> GetServerLayerNames();
    public Collection`1<string> GetServerLayerStyles();
    public Collection`1<string> GetServerTileMatrixSetNames();
    public Collection`1<WmtsServerEncodingType> GetServerEncodingType();
    public Collection`1<string> GetLayerOutputFormats(string layerName);
    protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    private Uri 7h0=();
    private Tuple`2<string, string> eB4=();
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/iz8=")]
private Task eR4=(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/lD8=")]
private Task`1<bool> eh4=(string kvpUrl, CancellationToken cancellationToken);
    public bool RemoveCachedCapability();
    private string ex4=();
    private void aB4=(XmlElement element, XmlNamespaceManager namespaceManager);
    private void fB4=(XmlNode operationTileNode, XmlNamespaceManager namespaceManager);
    public ZoomLevelSet GetZoomLevelSet(string tileMatrixSetName);
    public TileMatrix GetTileMatrix(string tileMatrixSetName, double scale);
    private void fR4=(XmlNode node, XmlNamespaceManager namespaceManager);
    private void fh4=(T& left, T& top);
    private void fx4=(XmlNode node, XmlNamespaceManager namespaceManager);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/fz8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private int gB4=(double newWidth, RectangleShape newTileExtent, GeographyUnit mapUnit);
    protected virtual void DrawExceptionCore(GeoCanvas canvas, Exception e);
    private string gR4=(WmtsServerLayer serverLayer, string zoomLevel, long y, long x, string tileMatrixSetName, int resourceURLIndex);
    public string GetRequestUri(long x, long y, int zoomLevel);
    private string gh4=(string requestString);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/jz8=")]
private Task`1<CloudRasterTileInfo> gx4=(MatrixCell cell, int zoomLevelIndex, int tileSize, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.WmtsAsyncLayer/kz8=")]
private Task`1<RasterTile> hB4=(int zoomLevel, long x, long y, CancellationToken cancellationToken);
    protected virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    [DebuggerHiddenAttribute]
[CompilerGeneratedAttribute]
private Task /h0=(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool hR4=(WmtsServerLayer l);
    [CompilerGeneratedAttribute]
private bool hh4=(WmtsServerLayer l);
    [CompilerGeneratedAttribute]
private bool hx4=(WmtsServerLayer l);
}
public enum ThinkGeo.Core.WmtsAxisOrder : Enum {
    public int value__;
    public static WmtsAxisOrder XY;
    public static WmtsAxisOrder YX;
}
public class ThinkGeo.Core.WmtsDimension : object {
    [ObfuscationAttribute]
private string defaultValue;
    [ObfuscationAttribute]
private string identifier;
    [ObfuscationAttribute]
private Collection`1<string> values;
    public string DefaultValue { get; public set; }
    public string Identifier { get; public set; }
    public Collection`1<string> Values { get; }
    public string get_DefaultValue();
    public void set_DefaultValue(string value);
    public string get_Identifier();
    public void set_Identifier(string value);
    public Collection`1<string> get_Values();
}
public class ThinkGeo.Core.WmtsRowColumnRange : object {
    [ObfuscationAttribute]
private double minTileRow;
    [ObfuscationAttribute]
private double maxTileRow;
    [ObfuscationAttribute]
private double minTileColumn;
    [ObfuscationAttribute]
private double maxTileColumn;
    [ObfuscationAttribute]
private string id;
    public double MinTileRow { get; }
    public double MaxTileRow { get; }
    public double MinTileColumn { get; }
    public double MaxTileColumn { get; }
    public string Id { get; }
    public WmtsRowColumnRange(string id, double minTileRow, double maxTileRow, double minTileColumn, double maxTileColumn);
    public double get_MinTileRow();
    public double get_MaxTileRow();
    public double get_MinTileColumn();
    public double get_MaxTileColumn();
    public string get_Id();
}
public enum ThinkGeo.Core.WmtsServerEncodingType : Enum {
    public int value__;
    public static WmtsServerEncodingType Kvp;
    public static WmtsServerEncodingType Restful;
    public static WmtsServerEncodingType Unknown;
}
public class ThinkGeo.Core.WmtsServerLayer : object {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private RectangleShape wgs84BoundingBox;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private string style;
    [ObfuscationAttribute]
private Collection`1<string> formats;
    [ObfuscationAttribute]
private String[] infoFormats;
    [ObfuscationAttribute]
private String[] tileMatrixLinkNames;
    [ObfuscationAttribute]
private Collection`1<WmtsRowColumnRange> rowColumnRange;
    [ObfuscationAttribute]
private WmtsURLTemplate[] resourceURL;
    [ObfuscationAttribute]
private WmtsDimension[] dimension;
    public string Name { get; public set; }
    public RectangleShape WGS84BoundingBox { get; public set; }
    public RectangleShape BoundingBox { get; public set; }
    public string Style { get; public set; }
    public Collection`1<string> Formats { get; public set; }
    public Collection`1<WmtsRowColumnRange> RowColumnRange { get; public set; }
    public String[] InfoFormats { get; public set; }
    public String[] TileMatrixLinkNames { get; public set; }
    public WmtsDimension[] Dimension { get; public set; }
    public WmtsURLTemplate[] ResourceURL { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public RectangleShape get_WGS84BoundingBox();
    public void set_WGS84BoundingBox(RectangleShape value);
    public RectangleShape get_BoundingBox();
    public void set_BoundingBox(RectangleShape value);
    public string get_Style();
    public void set_Style(string value);
    public Collection`1<string> get_Formats();
    public void set_Formats(Collection`1<string> value);
    public Collection`1<WmtsRowColumnRange> get_RowColumnRange();
    public void set_RowColumnRange(Collection`1<WmtsRowColumnRange> value);
    public String[] get_InfoFormats();
    public void set_InfoFormats(String[] value);
    public String[] get_TileMatrixLinkNames();
    public void set_TileMatrixLinkNames(String[] value);
    public WmtsDimension[] get_Dimension();
    public void set_Dimension(WmtsDimension[] value);
    public WmtsURLTemplate[] get_ResourceURL();
    public void set_ResourceURL(WmtsURLTemplate[] value);
}
[ObsoleteAttribute("This type is obsoleted and will be removed after v14.4. Please use WmtsServerEncodingType instead")]
public enum ThinkGeo.Core.WmtsSeverEncodingType : Enum {
    public int value__;
    public static WmtsSeverEncodingType Kvp;
    public static WmtsSeverEncodingType Restful;
    [ObsoleteAttribute("This property is obsoleted and will be removed after v14.4. In most cases, you don't need to specify the WmtsServerEncodingType.")]
public static WmtsSeverEncodingType KvpRestful;
    public static WmtsSeverEncodingType Unknown;
}
public class ThinkGeo.Core.WmtsTileMatrixSet : object {
    [ObfuscationAttribute]
private string id;
    [ObfuscationAttribute]
private string crs;
    [ObfuscationAttribute]
private RectangleShape boundingBox;
    [ObfuscationAttribute]
private Collection`1<TileMatrix> tileMatrices;
    public Collection`1<TileMatrix> TileMatrices { get; }
    public string Id { get; public set; }
    public string Crs { get; public set; }
    public RectangleShape BoundingBox { get; public set; }
    public WmtsTileMatrixSet(string id, string crs);
    public Collection`1<TileMatrix> get_TileMatrices();
    public string get_Id();
    public void set_Id(string value);
    public string get_Crs();
    public void set_Crs(string value);
    public RectangleShape get_BoundingBox();
    public void set_BoundingBox(RectangleShape value);
}
public class ThinkGeo.Core.WmtsURLTemplate : object {
    [ObfuscationAttribute]
private string format;
    [ObfuscationAttribute]
private string resourceType;
    [ObfuscationAttribute]
private string template;
    public string Format { get; public set; }
    public string ResourceType { get; public set; }
    public string Template { get; public set; }
    public string get_Format();
    public void set_Format(string value);
    public string get_ResourceType();
    public void set_ResourceType(string value);
    public string get_Template();
    public void set_Template(string value);
}
public class ThinkGeo.Core.WorldFile : object {
    [ObfuscationAttribute]
private float horizontalResolution;
    [ObfuscationAttribute]
private float rotationRow;
    [ObfuscationAttribute]
private float rotationColumn;
    [ObfuscationAttribute]
private float verticalResolution;
    [ObfuscationAttribute]
private float upperLeftX;
    [ObfuscationAttribute]
private float upperLeftY;
    public float HorizontalResolution { get; }
    public float RotationRow { get; }
    public float RotationColumn { get; }
    public float VerticalResolution { get; }
    public float UpperLeftX { get; }
    public float UpperLeftY { get; }
    public WorldFile(string worldFileText);
    public WorldFile(RectangleShape worldExtent, float imageWidth, float imageHeight);
    public WorldFile(double horizontalResolution, double rotationRow, double rotationColumn, double verticalResolution, double upperLeftX, double upperLeftY);
    public WorldFile(float horizontalResolution, float rotationRow, float rotationColumn, float verticalResolution, float upperLeftX, float upperLeftY);
    public float get_HorizontalResolution();
    public float get_RotationRow();
    public float get_RotationColumn();
    public float get_VerticalResolution();
    public float get_UpperLeftX();
    public float get_UpperLeftY();
    public RectangleShape GetBoundingBox(float width, float height);
    public void Save(string pathFilename);
}
public class ThinkGeo.Core.WorldLabelingCandidate : LabelingCandidate {
    [ObfuscationAttribute]
private PointShape centerPointInWorldCoordinates;
    public PointShape CenterPointInWorldCoordinates { get; public set; }
    public WorldLabelingCandidate(string originalText);
    public WorldLabelingCandidate(string originalText, PointShape centerPointInWorldCoordinates);
    public PointShape get_CenterPointInWorldCoordinates();
    public void set_CenterPointInWorldCoordinates(PointShape value);
}
public enum ThinkGeo.Core.WrappingMode : Enum {
    public int value__;
    public static WrappingMode None;
    public static WrappingMode WrapDateline;
}
public enum ThinkGeo.Core.WrappingWorldDirection : Enum {
    public int value__;
    public static WrappingWorldDirection West;
    public static WrappingWorldDirection East;
}
internal class ThinkGeo.Core.XmlGeoSerializationFormatter : GeoSerializationFormatter {
    protected virtual void SaveCore(GeoObjectModel model, Stream stream);
    protected virtual GeoObjectModel LoadCore(Stream stream);
    private void Save(GeoObjectNode node, XmlWriter xmlWriter);
    private static void RemoveRedundant(GeoObjectNode node);
    private static GeoObjectNode Load(XmlReader xmlReader);
}
public abstract class ThinkGeo.Core.XyzTileAsyncLayer : WebBasedAsyncLayer {
    [ObfuscationAttribute]
private RasterTileCache tileCache;
    [ObfuscationAttribute]
private RasterTileCache projectedTileCache;
    [ObfuscationAttribute]
private ProjectionConverter projectionConverterFromServerProjection;
    [ObfuscationAttribute]
private int cloudTileWidth;
    [ObfuscationAttribute]
private int cloudTileHeight;
    [ObfuscationAttribute]
private RectangleShape maxExtent;
    [ObfuscationAttribute]
private GeographyUnit cloudTileMapUnit;
    public int TileWidth { get; protected set; }
    public int TileHeight { get; protected set; }
    public GeographyUnit MapUnit { get; protected set; }
    public RectangleShape MaxExtent { get; protected set; }
    public RasterTileCache TileCache { get; public set; }
    public RasterTileCache ProjectedTileCache { get; public set; }
    public ProjectionConverter ProjectionConverterFromServerProjection { get; public set; }
    public XyzTileAsyncLayer(int tileSize, GeographyUnit mapUnit, RectangleShape maxExtent);
    public int get_TileWidth();
    protected void set_TileWidth(int value);
    public int get_TileHeight();
    protected void set_TileHeight(int value);
    public GeographyUnit get_MapUnit();
    protected void set_MapUnit(GeographyUnit value);
    public RectangleShape get_MaxExtent();
    protected void set_MaxExtent(RectangleShape value);
    public virtual RasterTileCache get_TileCache();
    public virtual void set_TileCache(RasterTileCache value);
    public virtual RasterTileCache get_ProjectedTileCache();
    public virtual void set_ProjectedTileCache(RasterTileCache value);
    public virtual ProjectionConverter get_ProjectionConverterFromServerProjection();
    public virtual void set_ProjectionConverterFromServerProjection(ProjectionConverter value);
    [AsyncStateMachineAttribute("ThinkGeo.Core.XyzTileAsyncLayer/sT8=")]
public Task`1<string> GetImageUriAsync(int zoomLevel, long x, long y, float resolutionFactor);
    protected abstract virtual Task`1<string> GetImageUriAsyncCore(int zoomLevel, long x, long y, float resolutionFactor);
    protected virtual Task OpenAsyncCore(CancellationToken cancellationToken);
    protected virtual Task CloseAsyncCore(CancellationToken cancellationToken);
    protected virtual int GetTileScale();
    [AsyncStateMachineAttribute("ThinkGeo.Core.XyzTileAsyncLayer/oT8=")]
protected virtual Task DrawAsyncCore(GeoCanvas canvas, Collection`1<SimpleCandidate> labelsInAllLayers);
    private static Dictionary`2<ValueTuple`2<long, long>, MatrixCell> iB4=(TileMatrix tileMatrix, RectangleShape requestedExtent, WrappingMode wrapDateline);
    protected virtual RectangleShape GetBoundingBoxCore();
    [AsyncStateMachineAttribute("ThinkGeo.Core.XyzTileAsyncLayer/sz8=")]
private Task`1<RasterTile> hB4=(int zoomLevel, long x, long y, float resolutionFactor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.XyzTileAsyncLayer/rz8=")]
private Task`1<CloudRasterTileInfo> gx4=(MatrixCell cell, int zoomLevelIndex, float scaleFactor, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("ThinkGeo.Core.XyzTileAsyncLayer/oD8=")]
public Task`1<Byte[]> DownloadImageAsync(int zoomLevelIndex, long column, long row, float scaleFactor, CancellationToken cancellationToken);
}
public class ThinkGeo.Core.ZoomLevel : object {
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private double scale;
    [ObfuscationAttribute]
private bool isActive;
    [ObfuscationAttribute]
private ApplyUntilZoomLevel applyUntilZoomLevel;
    [ObfuscationAttribute]
private TextStyle defaultTextStyle;
    [ObfuscationAttribute]
private AreaStyle defaultAreaStyle;
    [ObfuscationAttribute]
private LineStyle defaultLineStyle;
    [ObfuscationAttribute]
private PointStyle defaultPointStyle;
    [ObfuscationAttribute]
private Collection`1<Style> customStyles;
    [ObfuscationAttribute]
private GeoColor backgroundColor;
    [ObfuscationAttribute]
private bool useLegacyLabeling;
    public bool IsActive { get; public set; }
    public double Scale { get; public set; }
    public AreaStyle DefaultAreaStyle { get; public set; }
    public LineStyle DefaultLineStyle { get; public set; }
    public PointStyle DefaultPointStyle { get; public set; }
    public TextStyle DefaultTextStyle { get; public set; }
    public ApplyUntilZoomLevel ApplyUntilZoomLevel { get; public set; }
    public string Name { get; public set; }
    public Collection`1<Style> CustomStyles { get; }
    internal GeoColor WSA= { get; internal set; }
    public bool UseLegacyLabeling { get; public set; }
    internal bool ohU= { get; }
    public ZoomLevel(double scale);
    public bool get_IsActive();
    public void set_IsActive(bool value);
    public double get_Scale();
    public void set_Scale(double value);
    public AreaStyle get_DefaultAreaStyle();
    public void set_DefaultAreaStyle(AreaStyle value);
    public LineStyle get_DefaultLineStyle();
    public void set_DefaultLineStyle(LineStyle value);
    public PointStyle get_DefaultPointStyle();
    public void set_DefaultPointStyle(PointStyle value);
    public TextStyle get_DefaultTextStyle();
    public void set_DefaultTextStyle(TextStyle value);
    public ApplyUntilZoomLevel get_ApplyUntilZoomLevel();
    public void set_ApplyUntilZoomLevel(ApplyUntilZoomLevel value);
    public string get_Name();
    public void set_Name(string value);
    public Collection`1<Style> get_CustomStyles();
    internal GeoColor VyA=();
    internal void WCA=(GeoColor value);
    public bool get_UseLegacyLabeling();
    public void set_UseLegacyLabeling(bool value);
    public Collection`1<string> GetRequiredColumnNames();
    public void Draw(GeoCanvas canvas, IEnumerable`1<Feature> features, Collection`1<SimpleCandidate> currentLayerLabels, Collection`1<SimpleCandidate> allLayerLabels);
    public void Draw(GeoCanvas canvas, IEnumerable`1<BaseShape> shapes, Collection`1<SimpleCandidate> currentLayerLabels, Collection`1<SimpleCandidate> allLayerLabels);
    public bool HasValidStyles();
    protected virtual void DrawCore(GeoCanvas canvas, IEnumerable`1<Feature> features, Collection`1<SimpleCandidate> currentLayerLabels, Collection`1<SimpleCandidate> allLayerLabels);
    internal bool oBU=();
    private static void WiA=(Style style, Collection`1<string> columnNames);
    private static Collection`1<Collection`1<Feature>> WyA=(IEnumerable`1<Feature> allFeatures);
}
public class ThinkGeo.Core.ZoomLevelSet : object {
    private static int XCA=;
    private static float XSA=;
    [ObfuscationAttribute]
private string name;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel01;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel02;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel03;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel04;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel05;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel06;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel07;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel08;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel09;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel10;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel11;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel12;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel13;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel14;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel15;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel16;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel17;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel18;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel19;
    [ObfuscationAttribute]
private ZoomLevel zoomLevel20;
    [ObfuscationAttribute]
private Collection`1<ZoomLevel> customZoomLevels;
    [CompilerGeneratedAttribute]
private int Rx4=;
    [CompilerGeneratedAttribute]
private RectangleShape ex0=;
    public int TileSize { get; public set; }
    public RectangleShape MaxExtent { get; public set; }
    public string Name { get; public set; }
    public Collection`1<ZoomLevel> CustomZoomLevels { get; }
    public ZoomLevel ZoomLevel01 { get; }
    public ZoomLevel ZoomLevel02 { get; }
    public ZoomLevel ZoomLevel03 { get; }
    public ZoomLevel ZoomLevel04 { get; }
    public ZoomLevel ZoomLevel05 { get; }
    public ZoomLevel ZoomLevel06 { get; }
    public ZoomLevel ZoomLevel07 { get; }
    public ZoomLevel ZoomLevel08 { get; }
    public ZoomLevel ZoomLevel09 { get; }
    public ZoomLevel ZoomLevel10 { get; }
    public ZoomLevel ZoomLevel11 { get; }
    public ZoomLevel ZoomLevel12 { get; }
    public ZoomLevel ZoomLevel13 { get; }
    public ZoomLevel ZoomLevel14 { get; }
    public ZoomLevel ZoomLevel15 { get; }
    public ZoomLevel ZoomLevel16 { get; }
    public ZoomLevel ZoomLevel17 { get; }
    public ZoomLevel ZoomLevel18 { get; }
    public ZoomLevel ZoomLevel19 { get; }
    public ZoomLevel ZoomLevel20 { get; }
    public ZoomLevelSet(int tileSize);
    public ZoomLevelSet(int tileSize, RectangleShape maxExtent);
    public ZoomLevelSet(int tileSize, RectangleShape maxExtent, GeographyUnit maxExtentUnit);
    [CompilerGeneratedAttribute]
public int get_TileSize();
    [CompilerGeneratedAttribute]
public void set_TileSize(int value);
    [CompilerGeneratedAttribute]
public RectangleShape get_MaxExtent();
    [CompilerGeneratedAttribute]
public void set_MaxExtent(RectangleShape value);
    public string get_Name();
    public void set_Name(string value);
    public Collection`1<ZoomLevel> get_CustomZoomLevels();
    public ZoomLevel get_ZoomLevel01();
    public ZoomLevel get_ZoomLevel02();
    public ZoomLevel get_ZoomLevel03();
    public ZoomLevel get_ZoomLevel04();
    public ZoomLevel get_ZoomLevel05();
    public ZoomLevel get_ZoomLevel06();
    public ZoomLevel get_ZoomLevel07();
    public ZoomLevel get_ZoomLevel08();
    public ZoomLevel get_ZoomLevel09();
    public ZoomLevel get_ZoomLevel10();
    public ZoomLevel get_ZoomLevel11();
    public ZoomLevel get_ZoomLevel12();
    public ZoomLevel get_ZoomLevel13();
    public ZoomLevel get_ZoomLevel14();
    public ZoomLevel get_ZoomLevel15();
    public ZoomLevel get_ZoomLevel16();
    public ZoomLevel get_ZoomLevel17();
    public ZoomLevel get_ZoomLevel18();
    public ZoomLevel get_ZoomLevel19();
    public ZoomLevel get_ZoomLevel20();
    public void Load(string styleJsonPath);
    public void Load(Uri styleJsonUri);
    public ZoomLevel GetZoomLevel(RectangleShape extent, double screenWidth, GeographyUnit mapUnit);
    public ZoomLevel GetZoomLevel(RectangleShape extent, double screenWidth, GeographyUnit mapUnit, float dpi);
    public ZoomLevel GetZoomLevelForDrawing(RectangleShape extent, double screenWidth, GeographyUnit mapUnit, float dpi);
    public ZoomLevel GetZoomLevelForDrawing(double currentScale);
    public ZoomLevel GetZoomLevelForDrawing(RectangleShape extent, double screenWidth, GeographyUnit mapUnit);
    public Collection`1<ZoomLevel> GetZoomLevels();
    public static double GetLowerZoomLevelScale(double currentScale, ZoomLevelSet zoomLevelSet);
    public static double GetHigherZoomLevelScale(double currentScale, ZoomLevelSet zoomLevelSet);
    private double XiA=(ZoomLevel zoomLevel);
    public ZoomLevel GetDefaultZoomLevelByIndex(int zoomLevelIndex);
}
public enum ThinkGeo.Core.ZoomLevelSnappingMode : Enum {
    public int value__;
    public static ZoomLevelSnappingMode Default;
    public static ZoomLevelSnappingMode SnapUp;
    public static ZoomLevelSnappingMode SnapDown;
    public static ZoomLevelSnappingMode SnapToClosest;
    public static ZoomLevelSnappingMode None;
}
public enum ThinkGeo.Core.ZoomSnapDirection : Enum {
    public int value__;
    public static ZoomSnapDirection UpperScale;
    public static ZoomSnapDirection LowerScale;
}
[CompilerGeneratedAttribute]
internal class uhM= : object {
    [DebuggerBrowsableAttribute("0")]
private <exceptionGroup>j__TPar uxM=;
    [DebuggerBrowsableAttribute("0")]
private <exception>j__TPar vBM=;
    public <exceptionGroup>j__TPar vhM= { get; }
    public <exception>j__TPar wBM= { get; }
    [DebuggerHiddenAttribute]
public uhM=(<exceptionGroup>j__TPar exceptionGroup, <exception>j__TPar exception);
    public <exceptionGroup>j__TPar vRM=();
    public <exception>j__TPar vxM=();
    [DebuggerHiddenAttribute]
public virtual bool Equals(object value);
    [DebuggerHiddenAttribute]
public virtual int GetHashCode();
    [DebuggerHiddenAttribute]
public virtual string ToString();
}
internal class VTM=.0Dc= : object {
    private static int 0Tc=;
    private static int 0jc=;
    private static int 0zc=;
    private G0E= 1Dc=;
    private TTo= Xjc=;
    private Byte[][][] HTQ=;
    private bool 1Tc=;
    private int kTc=;
    private Int32[][][] JDc=;
    private Int32[] 1jc=;
    private int 1zc=;
    private int 2Dc=;
    private int 2Tc=;
    private int 2jc=;
    public 0Dc=(TTo= cinfo);
    public void Njc=(mzg= pass_mode);
    public void kzc=(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void 2zc=(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void 3Dc=(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void 3Tc=(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void 3jc=();
    private void 3zc=();
    private void 4Dc=();
    private void 4Tc=();
}
internal class VTM=.1Ds= : object {
    internal static string 1Ts=;
    private Tiff 1js=;
    private bool 1zs=;
    private bool 2Ds=;
    private XzM= 5Rk=;
    private int 9Cw=;
    private int vRk=;
    private short 2Ts=;
    private short 2js=;
    private Orientation 2zs=;
    private Orientation 3Ds=;
    private izM= 3Ts=;
    private UInt16[] 3js=;
    private UInt16[] 3zs=;
    private UInt16[] 4Ds=;
    private GetDelegate 4Ts=;
    private PutContigDelegate 4js=;
    private PutSeparateDelegate 4zs=;
    private Byte[] 5Ds=;
    private Int32[][] 5Ts=;
    private Int32[][] 5js=;
    private DDc= 5zs=;
    private ljY= 6Ds=;
    private static 3DY= 6Ts=;
    private static int Cxo=;
    private static int 6js=;
    private static int 6zs=;
    internal int 7Ds=;
    internal int 7Ts=;
    public bool 7zs= { get; }
    public XzM= 8Ts= { get; }
    public int 6y0= { get; }
    public int 7i0= { get; }
    public short 8zs= { get; }
    public short 9Ts= { get; }
    public Orientation 9zs= { get; }
    public Orientation /js= { get; public set; }
    public izM= ADw= { get; }
    public GetDelegate Azw= { get; public set; }
    public PutContigDelegate Bjw= { get; public set; }
    public PutSeparateDelegate CTw= { get; public set; }
    private static 1Ds=();
    public static 1Ds= pR8=(Tiff tif, bool stopOnError, String& errorMsg);
    public bool 7js=();
    public XzM= 8Ds=();
    public int 6S0=();
    public int 7C0=();
    public short 8js=();
    public short 9Ds=();
    public Orientation 9js=();
    public Orientation /Ds=();
    public void /Ts=(Orientation value);
    public izM= /zs=();
    public GetDelegate ATw=();
    public void Ajw=(GetDelegate value);
    public PutContigDelegate BDw=();
    public void BTw=(PutContigDelegate value);
    public PutSeparateDelegate Bzw=();
    public void CDw=(PutSeparateDelegate value);
    public bool Cjw=(Int32[] raster, int offset, int width, int height);
    private static int Czw=(int r, int g, int b);
    private static int DDw=(int r, int g, int b, int a);
    private static int DDw=(int rgb, int a);
    private static int DTw=(short v);
    private static int Djw=(short r, short g, short b);
    private static int Dzw=(short r, short g, short b, short a);
    private void EDw=(int x, int i, Int32& j);
    private void ETw=(int x, int i, Int32& j);
    private static bool Ejw=(1Ds= img, Int32[] raster, int offset, int width, int height);
    private static bool Ezw=(1Ds= img, Int32[] raster, int offset, int width, int height);
    private static bool FDw=(1Ds= img, Int32[] raster, int offset, int width, int height);
    private static bool FTw=(1Ds= img, Int32[] raster, int offset, int width, int height);
    private bool Fjw=();
    private int Fzw=();
    private bool GDw=();
    private bool GTw=();
    private bool Gjw=();
    private PutContigDelegate Gzw=();
    private bool HDw=();
    private bool HTw=();
    private int Hjw=();
    private void Hzw=();
    private bool IDw=();
    private bool ITw=();
    private void Fjc=(Int32& dst, int Y, int Cb, int Cr);
    private static void Ijw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Izw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void JDw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void JTw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Jjw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Jzw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void KDw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void KTw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Kjw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Kzw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void LDw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void LTw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Ljw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Lzw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void MDw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void MTw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Mjw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Mzw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void NDw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void NTw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Njw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Nzw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void ODw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void OTw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Ojw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void Ozw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
    private static void PDw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void PTw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void Pjw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void Pzw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void QDw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void QTw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void Qjw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset1, int offset2, int offset3, int offset4, int bufferShift);
    private static void Qzw=(1Ds= img, Int32[] raster, int rasterOffset, int rasterShift, int x, int y, int width, int height, Byte[] buffer, int offset, int bufferShift);
}
internal class VTM=.1jY= : object {
    public TiffTag 1zY=;
    public TiffType 2DY=;
    public int 2TY=;
    public ulong 2jY=;
    public string 5xM=();
    public static int 2zY=(bool isBigTiff);
}
internal abstract class VTM=.2jo= : object {
    private Byte[] HTQ=;
    private int 2zo=;
    private int 3Do=;
    protected int 3jo= { get; }
    public abstract virtual void xTU=();
    public abstract virtual bool xjU=();
    public abstract virtual void xzU=();
    public virtual bool Rjc=(int val);
    protected void 3zo=(Byte[] buffer, int offset);
    protected int 3To=();
}
internal class VTM=.2TM= : TiffCodec {
    public static int 2jM=;
    public static int 2zM=;
    public static int 3DM=;
    public static int 3TM=;
    public static int 3jM=;
    public static int 3zM=;
    public static int 4DM=;
    public static int 4TM=;
    internal YzM= 4jM=;
    internal dzM= 4zM=;
    internal VDM= 5DM=;
    internal int 5TM=;
    internal int 5jM=;
    internal int 5zM=;
    internal string 6DM=;
    internal int 6TM=;
    internal string 6jM=;
    internal FaxFillFunc 6zM=;
    private static int 7DM=;
    private static byte 7TM=;
    private static byte 7jM=;
    private static byte 7zM=;
    private static byte 8DM=;
    private static byte 8TM=;
    private static byte 8jM=;
    private static byte 8zM=;
    private static byte 9DM=;
    private static byte 9TM=;
    private static byte 9jM=;
    private static byte 9zM=;
    private static byte /DM=;
    private static byte /TM=;
    private static short /jM=;
    private static short /zM=;
    private static short ADQ=;
    private static short ATQ=;
    private static TiffFieldInfo[] AjQ=;
    private static TiffFieldInfo[] AzQ=;
    private static TiffFieldInfo[] BDQ=;
    private TiffTagMethods BTQ=;
    private TiffTagMethods BjQ=;
    private int BzQ=;
    private int CDQ=;
    private int CTQ=;
    private vUA= CjQ=;
    private Byte[] CzQ=;
    private int DDQ=;
    private int DTQ=;
    private int DjQ=;
    private Int32[] DzQ=;
    private int EDQ=;
    private int ETQ=;
    private int EjQ=;
    private int EzQ=;
    private int FDQ=;
    private int FTQ=;
    private int FjQ=;
    private wkA= FzQ=;
    private bool GDQ=;
    private Byte[] GTQ=;
    private int GjQ=;
    private int GzQ=;
    private int HDQ=;
    private Byte[] HTQ=;
    private int HjQ=;
    private static Int32[] HzQ=;
    private static Int32[] IDQ=;
    private static Int32[] ITQ=;
    private static Int16[] IjQ=;
    private static Int16[] IzQ=;
    private static tkA= JDQ=;
    private static tkA= JTQ=;
    private static tkA=[] JjQ=;
    private static Int32[] JzQ=;
    private static Byte[] KDQ=;
    private static Byte[] KTQ=;
    private static Byte[] KjQ=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public 2TM=(Tiff tif, Compression scheme, string name);
    private static 2TM=();
    private void KzQ=();
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool SetupDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual void Close();
    public virtual void Cleanup();
    private bool LDQ=();
    private void LTQ=(Int32& b1);
    private static void gig=(Int32& a, Int32& b);
    private static bool LjQ=(int offset);
    private static bool LzQ=(int offset);
    private static void MDQ=(int n, Byte[] cp, Int32& offset, byte value);
    private static void MTQ=(Byte[] buffer, int offset, Int32[] runs, int thisRunOffset, int nextRunOffset, int width);
    private static int MjQ=(Byte[] bp, int bpOffset, int bs, int be);
    private static int MzQ=(Byte[] bp, int bpOffset, int bs, int be);
    private static int NDQ=(Byte[] bp, int bpOffset, int _bs, int _be, int _color);
    private static int NTQ=(Byte[] bp, int bpOffset, int _bs, int _be, int _color);
    private bool NjQ=();
    private int NzQ=(int n);
    private void ODQ=(int n);
    private bool OTQ=(int n);
    private bool OjQ=(int n);
    private bool OzQ=(uUA=& TabEnt, int wid);
    private bool PDQ=(uUA=& TabEnt, int wid, bool useBlack);
    private bool PTQ=();
    private bool PjQ=();
    private void PzQ=(string module);
    private void QDQ=(string module);
    private void QTQ=(string module);
    private void QjQ=(string module);
    private bool QzQ=(Byte[] buffer, int offset, int count);
    private bool RDQ=(Byte[] buffer, int offset, int count);
    private bool RTQ=();
    private bool RjQ=();
    private static int RzQ=(Byte[] buf, int bufOffset, int ix);
    private bool SDQ=(Byte[] buffer, int offset, int count);
    private bool STQ=();
    private void SjQ=();
    private bool SzQ=();
    private void TDQ=();
    private void TTQ=(int bits, int length);
    private void TjQ=(tkA= te);
    private void TzQ=(int span, bool useBlack);
    private void UDQ=();
    private void UTQ=(int x);
    private void UjQ=(string module);
    private void UzQ=(string module);
    private bool VDQ=(string module);
    private bool VTQ=(string module, int b1);
    private bool VjQ=();
    private bool VzQ=();
    private bool WDQ=(Byte[] buffer, int offset, int count);
    private bool WTQ=();
    private bool WjQ=(Byte[] buffer, int offset, int count);
    private bool WzQ=(Byte[] buffer, int offset, int count);
    private bool XDQ=();
}
internal class VTM=.3DY= : object {
    internal Single[][] 3TY=;
    internal float 3jY=;
    internal float 3zY=;
    internal float 4DY=;
    internal int 4TY=;
    internal int 4jY=;
    internal int 4zY=;
    internal float 5DY=;
    internal float 5TY=;
    internal float 5jY=;
    internal float 5zY=;
    internal float 6DY=;
    internal float 6TY=;
    public 3DY=(Single[] mat0, Single[] mat1, Single[] mat2, float YCR, float YCG, float YCB, int Vrwr, int Vrwg, int Vrwb, float Y0R, float Y0G, float Y0B, float gammaR, float gammaG, float gammaB);
}
internal class VTM=.4Do= : object {
    internal int 4To=;
    internal Object[] 4jo=;
    internal int 4zo=;
    internal int 5Do=;
    public int 5zo= { get; public set; }
    public int 6To= { get; }
    public int 5To=();
    public void 5jo=(int value);
    public int 6Do=();
    public virtual void wTU=();
    public virtual void 6jo=(int msg_level);
    public virtual void wjU=();
    public virtual string 6zo=();
    public virtual void 7Do=();
    protected virtual string 7To=(int code);
}
internal class VTM=.4jc= : object {
    private H0E= 4zc=;
    private TTo= Xjc=;
    private TDs=<byte> wjc=;
    private Byte[][] HTQ=;
    private int 5Dc=;
    private int 5Tc=;
    private int 5jc=;
    public 4jc=(TTo= cinfo, bool need_full_buffer);
    public void Njc=(mzg= pass_mode);
    public void 5zc=(Izc=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void 6Dc=(Izc=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void 6Tc=(Izc=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Int32& out_row_ctr);
    private void 6jc=(Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
}
internal class VTM=.4zw= : object {
    private static int 5Dw=;
    private static Int32[] 5Tw=;
    internal static Int32[] 5jw=;
    private static int Zjw=;
    private static int Zzw=;
    private static int aDw=;
    private static int aTw=;
    private static int ajw=;
    private static int azw=;
    private static int bDw=;
    private static int bTw=;
    private static int bjw=;
    private static int 5zw=;
    private static int 6Dw=;
    private static int VDw=;
    private static int 6Tw=;
    private static int 6jw=;
    private static int 6zw=;
    private static int 7Dw=;
    private static int 7Tw=;
    private static int 7jw=;
    private static int 7zw=;
    internal int CRk=;
    internal int 8Dw=;
    internal int 8Tw=;
    internal int Px0=;
    internal Int32[] 8jw=;
    internal Int32[] 8zw=;
    internal Int32[] 9Dw=;
    internal CT0= 9Tw=;
    internal int 9jw=;
    internal int 9zw=;
    internal int /Dw=;
    internal Int32[] /Tw=;
    internal Byte[] lTw=;
    internal int /jw=;
    internal int /zw=;
    internal int AD0=;
    internal object AT0=;
    internal long Aj0=;
    internal 4zw=(cz0= z, object checkfn, int w);
    private static 4zw=();
    internal void Az0=(cz0= z, Int64[] c);
    internal int BD0=(cz0= z, int r);
    internal void BT0=(cz0= z);
    internal void Bj0=(Byte[] d, int start, int n);
    internal int Bz0=();
    internal int CD0=(cz0= z, int r);
}
[FlagsAttribute]
internal enum VTM=.6jY= : Enum {
    public int value__;
    public static 6jY= bzM=;
    public static 6jY= cDM=;
    public static 6jY= 6zY=;
    public static 6jY= 7DY=;
    public static 6jY= 7TY=;
    public static 6jY= 7jY=;
    public static 6jY= 7zY=;
    public static 6jY= 8DY=;
    public static 6jY= 8TY=;
    public static 6jY= 8jY=;
    public static 6jY= 8zY=;
    public static 6jY= 9DY=;
    public static 6jY= 9TY=;
    public static 6jY= 9jY=;
    public static 6jY= 9zY=;
    public static 6jY= /DY=;
    public static 6jY= /TY=;
    public static 6jY= /jY=;
    public static 6jY= /zY=;
}
internal class VTM=.6Tg= : object {
    private mzg= 6jg=;
    private nDk= Xjc=;
    private int 6zg=;
    private int 7Dg=;
    private int vzc=;
    private int wDc=;
    private NTk=[][] wTc=;
    private TDs=[] wjc=;
    public 6Tg=(nDk= cinfo, bool need_full_buffer);
    public virtual void Njc=(mzg= pass_mode);
    public virtual bool jjc=(Byte[][][] input_buf);
    private bool 7Tg=(Byte[][][] input_buf);
    private bool 7jg=(Byte[][][] input_buf);
    private bool 7zg=();
    private void zzc=();
}
internal abstract class VTM=.6zc= : object {
    private static Int32[] 7Dc=;
    private static Int32[] 7Tc=;
    protected static int 7jc=;
    protected static int 7zc=;
    protected TTo= Xjc=;
    protected bool 8Dc=;
    private static 6zc=();
    public abstract virtual void Njc=();
    public abstract virtual bool Nzc=(NTk=[] MCU_data);
    protected static int 8Tc=(int x, int s);
    protected void 8jc=(Hjc= bitstate, Int32& get_buffer, Int32& bits_left, ITc=& br_state);
    protected static void 8zc=(Hjc=& bitstate, int get_buffer, int bits_left);
    protected void 9Dc=(bool isDC, int tblno, Jjc=& dtbl);
    protected static bool 9Tc=(ITc=& state, int nbits, Int32& get_buffer, Int32& bits_left);
    protected static int 9jc=(int nbits, int get_buffer, Int32& bits_left);
    protected static int 9zc=(int nbits, int get_buffer, int bits_left);
    protected static void /Dc=(int nbits, Int32& bits_left);
    protected static bool /Tc=(ITc=& state, int get_buffer, int bits_left, int nbits);
    protected static bool /jc=(Int32& result, ITc=& state, Jjc= htbl, Int32& get_buffer, Int32& bits_left);
    protected static int /zc=(ITc=& state, int get_buffer, int bits_left, Jjc= htbl, int min_bits);
}
internal enum VTM=.7jo= : Enum {
    public int value__;
    public static 7jo= 7zo=;
    public static 7jo= 8Do=;
    public static 7jo= 8To=;
    public static 7jo= 8jo=;
    public static 7jo= 8zo=;
    public static 7jo= 9Do=;
    public static 7jo= 9To=;
    public static 7jo= 9jo=;
    public static 7jo= 9zo=;
    public static 7jo= /Do=;
    public static 7jo= /To=;
    public static 7jo= /jo=;
    public static 7jo= /zo=;
    public static 7jo= ADs=;
    public static 7jo= ATs=;
    public static 7jo= Ajs=;
    public static 7jo= Azs=;
    public static 7jo= BDs=;
    public static 7jo= BTs=;
    public static 7jo= Bjs=;
    public static 7jo= Bzs=;
    public static 7jo= CDs=;
    public static 7jo= CTs=;
    public static 7jo= Cjs=;
    public static 7jo= Czs=;
    public static 7jo= DDs=;
    public static 7jo= DTs=;
    public static 7jo= Djs=;
    public static 7jo= Dzs=;
    public static 7jo= EDs=;
    public static 7jo= ETs=;
    public static 7jo= Ejs=;
    public static 7jo= Ezs=;
    public static 7jo= FDs=;
    public static 7jo= FTs=;
    public static 7jo= Fjs=;
    public static 7jo= Fzs=;
    public static 7jo= GDs=;
    public static 7jo= GTs=;
    public static 7jo= Gjs=;
    public static 7jo= Gzs=;
    public static 7jo= HDs=;
    public static 7jo= HTs=;
    public static 7jo= Hjs=;
    public static 7jo= Hzs=;
    public static 7jo= IDs=;
    public static 7jo= ITs=;
    public static 7jo= Ijs=;
    public static 7jo= Izs=;
    public static 7jo= JDs=;
    public static 7jo= JTs=;
    public static 7jo= Jjs=;
    public static 7jo= Jzs=;
}
internal class VTM=.8Dg= : 2jo= {
    private static int 8Tg=;
    private nDk= Xjc=;
    private Stream 8jg=;
    private Byte[] HTQ=;
    public 8Dg=(nDk= cinfo, Stream alreadyOpenFile);
    public virtual void xTU=();
    public virtual bool xjU=();
    public virtual void xzU=();
    private void 8zg=(int dataCount);
}
internal class VTM=.9Dg= : mTg= {
    private static int Ujc=;
    private static int Dzc=;
    private TTo= Xjc=;
    private bool 9Tg=;
    private Int32[] cjc=;
    private Int32[] czc=;
    private Int32[] dDc=;
    private Int32[] dTc=;
    private Byte[] 9jg=;
    private bool 9zg=;
    private int /Dg=;
    private int lzc=;
    public 9Dg=(TTo= cinfo);
    public virtual void Njc=();
    public virtual void mjg=(Izc=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void /Tg=(Izc=[] input_buf, Int32& in_row_group_ctr, Byte[][] output_buf, Int32& out_row_ctr);
    private void /jg=(Izc=[] input_buf, Int32& in_row_group_ctr, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void /zg=(Izc=[] input_buf, int in_row_group_ctr, Byte[][] output_buf, int outRow);
    private void ADk=(Izc=[] input_buf, int in_row_group_ctr, Byte[][] output_buf);
    private void djc=();
    private static int aTc=(double x);
}
internal class VTM=.ADc= : ValueType {
    public static int ATc=;
    public static int Ajc=;
    public static int Azc=;
    public short BDc=;
    public short BTc=;
    public ulong Bjc=;
    public short Bzc=;
    public short CDc=;
    public static int 2zY=(bool isBigTiff);
}
internal abstract class VTM=.ADg= : object {
    protected static int ATg=;
    private static int Ajg=;
    protected nDk= Xjc=;
    public abstract virtual void Njc=(bool gather_statistics);
    public abstract virtual bool Pjc=(NTk=[][] MCU_data);
    public abstract virtual void Pzc=();
    protected void Azg=(bool isDC, int tblno, c_derived_tbl& dtbl);
    protected void BDg=(Njk= htbl, Int64[] freq);
}
[FlagsAttribute]
internal enum VTM=.ajM= : Enum {
    public int value__;
    public static ajM= azM=;
    public static ajM= bDM=;
    public static ajM= bTM=;
}
internal class VTM=.ATk= : RDs= {
    private static int Ajk=;
    private TTo= Xjc=;
    private Stream Azk=;
    private Byte[] HTQ=;
    private bool BDk=;
    public ATk=(TTo= cinfo);
    public void BTk=(Stream infile);
    public virtual void yjU=();
    public virtual bool yzU=();
}
internal class VTM=.bDk= : object {
    private int bTk=;
    private int lDg=;
    private int bjk=;
    private int bzk=;
    private int cDk=;
    private int cTk=;
    private int cjk=;
    private int czk=;
    internal int dDk=;
    internal int dTk=;
    internal int djk=;
    internal int dzk=;
    internal bool eDk=;
    internal int eTk=;
    internal int ejk=;
    internal int ezk=;
    internal int fDk=;
    internal int fTk=;
    internal int fjk=;
    internal Sjs= fzk=;
    public int gjk= { get; public set; }
    public int hTk= { get; public set; }
    public int iDk= { get; public set; }
    public int izk= { get; public set; }
    public int jjk= { get; public set; }
    public int kTk= { get; public set; }
    public int lDk= { get; public set; }
    public int lzk= { get; public set; }
    public int mTk= { get; }
    internal void mjk=(bDk= ci);
    public int gDk=();
    public void gTk=(int value);
    public int gzk=();
    public void hDk=(int value);
    public int hjk=();
    public void hzk=(int value);
    public int iTk=();
    public void ijk=(int value);
    public int jDk=();
    public void jTk=(int value);
    public int jzk=();
    public void kDk=(int value);
    public int kjk=();
    public void kzk=(int value);
    public int lTk=();
    public void ljk=(int value);
    public int mDk=();
    internal static bDk=[] mzk=(int length);
}
internal class VTM=.Bjk= : object {
    private nDk= Xjc=;
    private int 6zg=;
    private int 7Dg=;
    private int vzc=;
    private int wDc=;
    private TDs=[] wjc=;
    private NTk=[][] Bzk=;
    public Bjk=(nDk= cinfo, TDs=[] coef_arrays);
    public virtual void Njc=(mzg= pass_mode);
    public virtual bool jjc=(Byte[][][] input_buf);
    private void zzc=();
}
internal enum VTM=.bjM= : Enum {
    public int value__;
    public static bjM= bzM=;
    public static bjM= cDM=;
}
internal class VTM=.bT0= : object {
    private static string bj0=;
    public static int bz0=;
    public static int cD0=;
    public static int cT0=;
    public static int UTw=;
    public static int Xjw=;
    public static int Xzw=;
    public static int YDw=;
    public static int YTw=;
    public static int Yjw=;
    public static int Yzw=;
    public static int ZDw=;
    public static int ZTw=;
    public static int Zjw=;
    public static int Zzw=;
    public static int aDw=;
    public static int aTw=;
    public static int ajw=;
    public static int azw=;
    public static int bDw=;
    public static int bTw=;
    public static int bjw=;
    public static string cj0=();
}
internal class VTM=.BTg= : object {
    private static int Bjg=;
    private static int Bzg=;
    private static int CDg=;
    private static int CTg=;
    private static int Cjg=;
    private static int Czg=;
    private static int DDg=;
    private static int DTg=;
    private static int Djg=;
    private static int Dzg=;
    private static int EDg=;
    private static int ETg=;
    private static int Ejg=;
    private static int Ezg=;
    private static int FDg=;
    private static int FTg=;
    private static int Fjg=;
    private static int Fzg=;
    private static int GDg=;
    private static int GTg=;
    private static Int16[] Gjg=;
    private static Double[] Gzg=;
    private nDk= Xjc=;
    private bool HDg=;
    private bool HTg=;
    private Int32[][] Hjg=;
    private Single[][] Hzg=;
    public BTg=(nDk= cinfo);
    private static BTg=();
    public virtual void Njc=();
    public virtual void IDg=(int quant_tbl_no, Byte[][] sample_data, NTk=[] coef_blocks, int start_row, int start_col, int num_blocks);
    private void ITg=(int quant_tbl_no, Byte[][] sample_data, NTk=[] coef_blocks, int start_row, int start_col, int num_blocks);
    private void Ijg=(int quant_tbl_no, Byte[][] sample_data, NTk=[] coef_blocks, int start_row, int start_col, int num_blocks);
    private static void Izg=(Single[] data);
    private static void JDg=(Int32[] data);
    private static void JTg=(Int32[] data);
    private static int Jjg=(int var, int c);
}
internal class VTM=.BTY= : TiffCodec {
    internal static int BjY=;
    internal static int BzY=;
    internal static int CDY=;
    internal static int CTY=;
    internal static int CjY=;
    internal static int CzY=;
    internal static int DDY=;
    internal static int DTY=;
    private static int DjY=;
    private static TiffFieldInfo[] DzY=;
    internal UInt32 EDY=;
    internal UInt32 ETY=;
    internal byte EjY=;
    internal bool EzY=;
    internal bool FDY=;
    internal byte FTY=;
    internal byte FjY=;
    internal byte FzY=;
    internal byte GDY=;
    internal byte GTY=;
    internal UInt32[] GjY=;
    internal UInt32[] GzY=;
    internal UInt32[] HDY=;
    internal ushort HTY=;
    internal TTo= HjY=;
    private TiffTagMethods BjQ=;
    private TiffTagMethods BTQ=;
    private UInt32 HzY=;
    private UInt32 IDY=;
    private UInt32 ITY=;
    private UInt32 IjY=;
    private UInt32 IzY=;
    private UInt32 JDY=;
    private byte JTY=;
    private byte JjY=;
    private byte JzY=;
    private bool KDY=;
    private bool KTY=;
    private Byte[][] KjY=;
    private Byte[][] KzY=;
    private Byte[][] LDY=;
    private byte LTY=;
    private bool LjY=;
    private byte LzY=;
    private UInt32 MDY=;
    private UInt32 MTY=;
    private Byte[] MjY=;
    private Byte[] MzY=;
    private Byte[] NDY=;
    private Byte[] NTY=;
    private Byte[] NjY=;
    private /EA=[] NzY=;
    private bool ODY=;
    private bool OTY=;
    private short OjY=;
    private UInt32 OzY=;
    private bool PDY=;
    private byte PTY=;
    private 4Do= PjY=;
    private RDs= PzY=;
    private bool QDY=;
    private UInt32 QTY=;
    private UInt32 QjY=;
    private UInt32 QzY=;
    private UInt32 RDY=;
    private Byte[][] RTY=;
    private Byte[][] RjY=;
    private Byte[][] RzY=;
    private Byte[][][] SDY=;
    private UInt32 STY=;
    private UInt32 SjY=;
    private UInt32 SzY=;
    private UInt32 TDY=;
    private 30A= TTY=;
    private UInt32 TjY=;
    private UInt32 TzY=;
    private UInt32 UDY=;
    private bool UTY=;
    private UInt32 UjY=;
    private ushort UzY=;
    private int VDY=;
    private Byte[] VTY=;
    private 5EA= VjY=;
    private Byte[] VzY=;
    private Byte[] WDY=;
    private bool WTY=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public BTY=(Tiff tif, Compression scheme, string name);
    private static BTY=();
    private void KzQ=();
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public Tiff ljU=();
    public virtual bool SetupDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual void Cleanup();
    internal void WjY=(bool force);
    private bool WzY=();
    private bool XDY=(short s);
    private bool XTY=(Byte[] buf, int offset, int cc, short s);
    private bool XjY=();
    private void XzY=();
    private bool YDY=();
    private bool YTY=();
    private bool YjY=(Byte[] buf, int offset, int cc);
    private bool YzY=(Byte[] buf, int offset, int cc);
    public void ZDY=();
    private bool ZTY=();
    private bool ZjY=(short s);
    private bool ZzY=();
    private void aDY=();
    private bool aTY=();
    private bool ajY=();
    private bool azY=();
    private bool bDY=();
    private bool bTY=(byte marker_id);
    private bool bjY=();
    private bool bzY=();
    private bool cDY=();
    private bool cTY=();
    private bool cjY=();
    private bool czY=(Byte& b);
    public bool dDY=(Byte& b);
    private void dTY=();
    private bool djY=(UInt16& word);
    public bool dzY=(ushort len, Byte[] mem, int offset);
    private void eDY=(ushort len);
    internal bool eTY=(Byte[]& mem, UInt32& len);
    private void ejY=(Byte[]& mem, UInt32& len);
    private void ezY=(byte table_index, Byte[]& mem, UInt32& len);
    private void fDY=(byte table_index, Byte[]& mem, UInt32& len);
    private void fTY=(byte table_index, Byte[]& mem, UInt32& len);
    private void fjY=(Byte[]& mem, UInt32& len);
    private void fzY=(Byte[]& mem, UInt32& len);
    private void gDY=(Byte[]& mem, UInt32& len);
    private bool gTY=(Byte[]& mem, UInt32& len);
    private void gjY=(Byte[]& mem, UInt32& len);
    private void gzY=(Byte[]& mem, UInt32& len);
    private bool hDY=();
    private xDs= hTY=(bool require_image);
    private bool hjY=();
    private int hzY=(Byte[] scanlines, int max_lines);
    private int iDY=(int max_lines);
}
internal class VTM=.bzc= : object {
    private static int Ujc=;
    private static int Dzc=;
    private BkE= cDc=;
    private TTo= Xjc=;
    private Int32[] cTc=;
    private Int32[] cjc=;
    private Int32[] czc=;
    private Int32[] dDc=;
    private Int32[] dTc=;
    public bzc=(TTo= cinfo);
    public void Zjc=(Izc=[] input_buf, Int32[] perComponentOffsets, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void djc=();
    private void dzc=(Izc=[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void eDc=(Izc=[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void eTc=(Izc=[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void bTc=(Izc=[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private void bjc=(Izc=[] input_buf, int input_row, Byte[][] output_buf, int output_row, int num_rows);
    private static int aTc=(double x);
}
internal class VTM=.CDk= : mTg= {
    private TTo= Xjc=;
    private Izc=[] lTc=;
    private Int32[] cTc=;
    private P0E=[] CTk=;
    private int Cjk=;
    private int Czk=;
    private int DDk=;
    private int lzc=;
    private Int32[] DTk=;
    private Byte[] Djk=;
    private Byte[] Dzk=;
    public CDk=(TTo= cinfo);
    public virtual void Njc=();
    public virtual void mjg=(Izc=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    private void EDk=(Izc=& input_data);
    private static void ETk=();
    private void Ejk=(Izc=& input_data);
    private void Ezk=(int downsampled_width, Izc=& input_data);
    private void FDk=(Izc=& input_data);
    private void FTk=(int downsampled_width, Izc=& input_data);
    private void Fjk=(Izc=& input_data);
    private void Fzk=(Izc=& input_data);
}
internal class VTM=.CT0= : object {
    private static Int32[] 5Tw=;
    private static int Zjw=;
    private static int Zzw=;
    private static int aDw=;
    private static int aTw=;
    private static int ajw=;
    private static int azw=;
    private static int bDw=;
    private static int bTw=;
    private static int bjw=;
    private static int Cj0=;
    private static int Cz0=;
    private static int DD0=;
    private static int DT0=;
    private static int Dj0=;
    private static int Dz0=;
    private static int ED0=;
    private static int ET0=;
    private static int Ej0=;
    private static int Ez0=;
    internal int CRk=;
    internal int FD0=;
    internal Int32[] FT0=;
    internal int Fj0=;
    internal int Fz0=;
    internal int GD0=;
    internal int GT0=;
    internal int Gj0=;
    internal byte Gz0=;
    internal byte HD0=;
    internal Int32[] HT0=;
    internal int Hj0=;
    internal Int32[] Hz0=;
    internal int ID0=;
    internal CT0=(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, cz0= z);
    internal CT0=(int bl, int bd, Int32[] tl, Int32[] td, cz0= z);
    private static CT0=();
    internal int BD0=(4zw= s, cz0= z, int r);
    internal void BT0=(cz0= z);
    internal int IT0=(int bl, int bd, Int32[] tl, int tl_index, Int32[] td, int td_index, 4zw= s, cz0= z);
}
internal class VTM=.CTc= : ValueType {
    public TiffFieldInfo Cjc=;
    public int riw=;
    public Byte[] Czc=;
}
internal enum VTM=.cTM= : Enum {
    public int value__;
    public static cTM= cjM=;
    public static cTM= czM=;
    public static cTM= dDM=;
    public static cTM= dTM=;
    public static cTM= djM=;
}
internal class VTM=.cz0= : object {
    private static int Ujw=;
    private static int dD0=;
    private static int YTw=;
    private static int Yjw=;
    private static int Yzw=;
    private static int ZDw=;
    private static int ZTw=;
    private static int UDw=;
    private static int Zjw=;
    private static int Zzw=;
    private static int aDw=;
    private static int aTw=;
    private static int ajw=;
    private static int azw=;
    private static int bDw=;
    private static int bTw=;
    private static int bjw=;
    public Byte[] dT0=;
    public int dj0=;
    public int dz0=;
    public long eD0=;
    public Byte[] eT0=;
    public int ej0=;
    public int ez0=;
    public long fD0=;
    public string fT0=;
    internal Tzw= fj0=;
    internal Ij0= fz0=;
    internal int jzw=;
    public long gD0=;
    internal Szw= gT0=;
    public int Nz0=();
    public int NT0=();
    public int Nz0=(int w);
    public int OD0=(int f);
    public int Nj0=();
    public int Oj0=();
    public int OT0=(Byte[] dictionary, int dictLength);
    public int 3Dw=(int level);
    public int 3Dw=(int level, int bits);
    public int 4jw=(int flush);
    public int 3zw=();
    public int 4Dw=(int level, int strategy);
    public int 4Tw=(Byte[] dictionary, int dictLength);
    internal void gj0=();
    internal int gz0=(Byte[] buf, int start, int size);
    public void BT0=();
}
internal class VTM=.DDc= : object {
    private static int DTc=;
    private static int Djc=;
    private static int Dzc=;
    private Byte[] EDc=;
    private Int32[] ETc=;
    private Int32[] Ejc=;
    private Int32[] Ezc=;
    private Int32[] FDc=;
    private Int32[] FTc=;
    public void Kh8=(Single[] luma, Single[] refBlackWhite);
    public void Fjc=(int Y, int Cb, int Cr, Int32& r, Int32& g, Int32& b);
    private static int Fzc=(float x);
    private static int GDc=(int c, float RB, float RW, float CR);
    private static int GTc=(int f, int min, int max);
    private static int Gjc=(int f, int max);
}
[FlagsAttribute]
internal enum VTM=.dzM= : Enum {
    public int value__;
    public static dzM= eDM=;
    public static dzM= eTM=;
    public static dzM= ejM=;
    public static dzM= ezM=;
}
internal interface VTM=.ejc= {
    public abstract virtual void Njc=(bool is_pre_scan);
    public abstract virtual void ezc=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    public abstract virtual void Pzc=();
    public abstract virtual void fDc=();
}
internal enum VTM=.fDM= : Enum {
    public int value__;
    public static fDM= fTM=;
    public static fDM= fjM=;
}
internal class VTM=.fjU= : TiffCodec {
    public static int fzU=;
    public static int 3TM=;
    public static int 3jM=;
    public static int 3zM=;
    public static int 4DM=;
    internal nDk= gDU=;
    internal TTo= gTU=;
    internal Vjk= gjU=;
    internal int gzU=;
    internal int hDU=;
    internal Byte[] hTU=;
    internal int hjU=;
    internal int hzU=;
    internal fzM= iDU=;
    internal hTM= iTU=;
    internal bool ijU=;
    internal int 5zM=;
    internal string 6DM=;
    internal int 6TM=;
    internal string 6jM=;
    private static TiffFieldInfo[] izU=;
    private bool jDU=;
    private bool jTU=;
    private TiffTagMethods BjQ=;
    private TiffTagMethods BTQ=;
    private bool jjU=;
    internal 4Do= jzU=;
    private izM= kDU=;
    private int kTU=;
    private Byte[][][] kjU=;
    private int kzU=;
    private int lDU=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public fjU=(Tiff tif, Compression scheme, string name);
    private static fjU=();
    private void KzQ=();
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool SetupDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual void Cleanup();
    public virtual int DefStripSize(int size);
    public virtual void DefTileSize(Int32& width, Int32& height);
    public bool lTU=(bool force_encode, bool force_decode);
    public Tiff ljU=();
    public void lzU=();
    private bool mDU=(short s);
    private bool mTU=();
    private bool mjU=();
    private void mzU=();
    private bool nDU=(short s);
    private bool nTU=();
    private bool njU=();
    private int nzU=(Byte[][] scanlines, int max_lines);
    private bool oDU=(Byte[] buffer, int offset, int count, short plane);
    private bool oTU=(Byte[] buffer, int offset, int count, short plane);
    private bool ojU=(Byte[] buffer, int offset, int count, short plane);
    private bool ozU=(Byte[] buffer, int offset, int count, short plane);
    private int pDU=(int s);
    private void pTU=(Int32& tw, Int32& th);
    private bool pjU=();
    private bool pzU=();
    private bool qDU=();
    private bool qTU=(UTs= colorspace);
    private bool qjU=(int quality, bool force_baseline);
    private bool qzU=(bool suppress);
    private bool rDU=(bool write_all_tables);
    private int rTU=(Byte[][] scanlines, int num_lines);
    private int rjU=(Byte[][][] data, int num_lines);
    private bool rzU=();
    private bool sDU=();
    private xDs= sTU=(bool require_image);
    private bool sjU=();
    private int szU=(Byte[][][] data, int max_lines);
    private bool tDU=();
    private bool tTU=();
    private bool tjU=();
    private static Byte[][] tzU=(int samplesperrow, int numrows);
    private bool uDU=(bDk=[] comp_info, int num_components);
    private void uTU=(int tblno);
    private void ujU=(int tblno);
    private void uzU=();
    private bool vDU=();
}
internal class VTM=.fTc= : object {
    private nDk= Xjc=;
    private bool fjc=;
    private bool fzc=;
    private DEE= gDc=;
    private int gTc=;
    private int gjc=;
    private int gzc=;
    public fTc=(nDk= cinfo, bool transcode_only);
    public void hDc=();
    public void hTc=();
    public void Pzc=();
    public bool hjc=();
    public bool hzc=();
    private void iDc=();
    private bool iTc=();
    private void ijc=();
    private void izc=();
    private void jDc=();
}
internal enum VTM=.fzM= : Enum {
    public int value__;
    public static fzM= gDM=;
    public static fzM= gTM=;
}
internal class VTM=.gDg= : object {
    private nDk= Xjc=;
    private int gTg=;
    public gDg=(nDk= cinfo);
    public void gjg=();
    public void gzg=();
    public void hDg=();
    public void hTg=();
    public void hjg=();
    public void hzg=(int marker, int datalen);
    public void iDg=(byte val);
    private void iTg=();
    private void ijg=(7jo= code);
    private void izg=();
    private void jDg=();
    private void jTg=(int index, bool is_ac);
    private int jjg=(int index);
    private void jzg=();
    private void kDg=(7jo= mark);
    private void kTg=(int value);
    private void Rjc=(int val);
}
internal class VTM=.GDk= : 6zc= {
    private SEE= CjQ=;
    private Hjc= LTc=;
    private AkE= Ljc=;
    private int Lzc=;
    private Jjc=[] GTk=;
    private Jjc= Gjk=;
    public GDk=(TTo= cinfo);
    public virtual void Njc=();
    public virtual bool Nzc=(NTk=[] MCU_data);
    private bool Gzk=(NTk=[] MCU_data);
    private bool HDk=(NTk=[] MCU_data);
    private bool HTk=(NTk=[] MCU_data);
    private bool Hjk=(NTk=[] MCU_data);
    private bool ODc=();
    private static void Hzk=(NTk=[] block, Int32[] newnz_pos, int num_newnz);
}
internal enum VTM=.gjM= : Enum {
    public int value__;
    public static gjM= gzM=;
    public static gjM= hDM=;
}
internal enum VTM=.Gzc= : Enum {
    public int value__;
    public static Gzc= aRQ=;
    public static Gzc= HDc=;
    public static Gzc= HTc=;
}
internal class VTM=.hD0= : IOException {
    public hD0=(string s);
}
internal class VTM=.Hjc= : ValueType {
    public int Hzc=;
    public int IDc=;
}
[FlagsAttribute]
internal enum VTM=.hTM= : Enum {
    public int value__;
    public static hTM= hjM=;
    public static hTM= hzM=;
    public static hTM= iDM=;
}
internal class VTM=.hzQ= : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream fd, TiffPrintFlags flags);
}
internal class VTM=.IDk= : ADg= {
    private static int ITk=;
    private TUE= Ijk=;
    private bool Ojc=;
    private int Izk=;
    private int JDk=;
    private Int32[] JTk=;
    private int Jjk=;
    private int Jzk=;
    private int KDk=;
    private Char[] KTk=;
    private int Lzc=;
    private int Ozc=;
    private c_derived_tbl[] GTk=;
    private Int64[][] Kjk=;
    public IDk=(nDk= cinfo);
    public virtual void Njc=(bool gather_statistics);
    public virtual bool Pjc=(NTk=[][] MCU_data);
    public virtual void Pzc=();
    private bool Kzk=(NTk=[][] MCU_data);
    private bool LDk=(NTk=[][] MCU_data);
    private bool LTk=(NTk=[][] MCU_data);
    private bool Ljk=(NTk=[][] MCU_data);
    private void Lzk=();
    private void MDk=();
    private void Rjc=(int val);
    private void Rzc=(int code, int size);
    private void SDc=();
    private void MTk=(int tbl_no, int symbol);
    private void Mjk=(int offset, int nbits);
    private void Mzk=();
    private void STc=(int restart_num);
    private static int NDk=(int x, int shft);
}
internal class VTM=.iDQ= : XjQ= {
    public static int iTQ=;
    public static int ijQ=;
    public cz0= izQ=;
    public int jDQ=;
    public int jTQ=;
    private static TiffFieldInfo[] jjQ=;
    private TiffTagMethods BjQ=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public iDQ=(Tiff tif, Compression scheme, string name);
    private static iDQ=();
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual void Cleanup();
    public virtual bool ajQ=();
    public virtual bool azQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool bDQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool bTQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool bjQ=();
    public virtual bool bzQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool cDQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool cTQ=(Byte[] buffer, int offset, int count, short plane);
    private void jzQ=();
    private bool kDQ=(Byte[] buffer, int offset, int count, short plane);
    private bool kTQ=(Byte[] buffer, int offset, int count, short plane);
    private bool kjQ=();
    private bool kzQ=(short s);
    private bool lDQ=(short s);
    private bool lTQ=();
    private bool ljQ=();
}
internal class VTM=.Ij0= : object {
    private static int Ujw=;
    private static int XTw=;
    internal static int YTw=;
    internal static int Yjw=;
    internal static int Yzw=;
    internal static int ZDw=;
    internal static int ZTw=;
    private static int cjw=;
    private static int Zjw=;
    private static int Zzw=;
    private static int aDw=;
    private static int aTw=;
    private static int ajw=;
    private static int azw=;
    private static int bDw=;
    private static int bTw=;
    private static int bjw=;
    private static int Iz0=;
    private static int JD0=;
    private static int JT0=;
    private static int Jj0=;
    private static int Jz0=;
    private static int KD0=;
    private static int KT0=;
    private static int Kj0=;
    private static int Kz0=;
    private static int LD0=;
    private static int LT0=;
    private static int Lj0=;
    private static int 7jw=;
    private static int 7zw=;
    internal int CRk=;
    internal int kDw=;
    internal Int64[] Lz0=;
    internal long Fz0=;
    internal int MD0=;
    internal int MT0=;
    internal int Mj0=;
    internal 4zw= Mz0=;
    private static Byte[] ND0=;
    private static Ij0=();
    internal int NT0=(cz0= z);
    internal int Nj0=(cz0= z);
    internal int Nz0=(cz0= z, int w);
    internal int OD0=(cz0= z, int f);
    internal int OT0=(cz0= z, Byte[] dictionary, int dictLength);
    internal int Oj0=(cz0= z);
    internal int Oz0=(cz0= z);
}
internal class VTM=.ijY= : 4Do= {
    private BTY= wDU=;
    public ijY=(BTY= sp);
    public virtual void wTU=();
    public virtual void wjU=();
}
internal class VTM=.ITc= : ValueType {
    public int Hzc=;
    public int IDc=;
    public TTo= Ijc=;
}
internal enum VTM=.iTM= : Enum {
    public int value__;
    public static iTM= ijM=;
    public static iTM= azM=;
    public static iTM= bDM=;
}
internal class VTM=.iTY= : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream fd, TiffPrintFlags flags);
}
[DefaultMemberAttribute("Item")]
internal class VTM=.Izc= : object {
    private Byte[][] HTQ=;
    private Int32[] JDc=;
    private int JTc=;
    public Byte[] whw= { get; }
    public Izc=(Byte[][] buf, Int32[] funnyIndices, int funnyOffset);
    public void xhw=(Byte[][] buf, Int32[] funnyIndices, int funnyOffset);
    public Byte[] wBw=(int i);
}
internal enum VTM=.izM= : Enum {
    public int value__;
    public static izM= jDM=;
    public static izM= jTM=;
    public static izM= gTM=;
    public static izM= jjM=;
    public static izM= bTM=;
    public static izM= jzM=;
    public static izM= kDM=;
    public static izM= kTM=;
    public static izM= kjM=;
    public static izM= kzM=;
    public static izM= lDM=;
    public static izM= lTM=;
}
internal class VTM=.izY= : RDs= {
    protected BTY= wDU=;
    public izY=(BTY= sp);
    public virtual void yjU=();
    public virtual bool yzU=();
    public virtual void jDY=(int num_bytes);
    public virtual bool jTY=(TTo= cinfo, int desired);
    public virtual void jjY=();
}
internal class VTM=.Jjc= : object {
    public Int32[] Jzc=;
    public Int32[] KDc=;
    public Njk= KTc=;
    public Int32[] Kjc=;
    public Byte[] Kzc=;
}
internal interface VTM=.jTc= {
    public abstract virtual void Njc=(mzg= pass_mode);
    public abstract virtual bool jjc=(Byte[][][] input_buf);
}
internal class VTM=.jzc= : object {
    private nDk= Xjc=;
    private int kDc=;
    private int kTc=;
    private bool kjc=;
    private Byte[][][] HTQ=;
    public jzc=(nDk= cinfo);
    public void Njc=(mzg= pass_mode);
    public void kzc=(Byte[][] input_buf, Int32& in_row_ctr, int in_rows_avail);
}
internal class VTM=.Jzg= : object {
    private TTo= Xjc=;
    private bool KDg=;
    private bool KTg=;
    private bool Kjg=;
    private bool Kzg=;
    public Jzg=(TTo= cinfo);
    public xDs= LDg=();
    public void LTg=();
    public void xjc=();
    public void Ljg=();
    public bool Lzg=();
    public bool MDg=();
    private xDs= MTg=();
    private void Mjg=();
    private void Mzg=();
    private void jDc=();
}
internal class VTM=.jzY= : TiffCodec {
    private int kDY=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public jzY=(Tiff tif, Compression scheme, string name);
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool PreEncode(short plane);
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    private bool kTY=(short s);
    private bool kjY=(Byte[] buf, int offset, int cc, short s);
    private bool kzY=(Byte[] buffer, int offset, int count, short plane);
    private bool lDY=(Byte[] buffer, int offset, int count, short plane);
}
internal class VTM=.KDs= : object {
    private byte 1Dk=;
    private int KTs=;
    private Byte[] DDQ=;
    public byte Kzs= { get; }
    public int LTs= { get; }
    public Byte[] rxM= { get; }
    internal KDs=(byte marker, int originalDataLength, int lengthLimit);
    public byte Kjs=();
    public int LDs=();
    public Byte[] rhM=();
}
internal class VTM=.kjg= : object {
    public int kzg=;
    public Int32[] lDg=;
    public int lTg=;
    public int ljg=;
    public int lzg=;
    public int mDg=;
}
internal class VTM=.lDc= : object {
    private nDk= Xjc=;
    private Byte[][][] lTc=;
    private int ljc=;
    private int lzc=;
    private int mDc=;
    private int mTc=;
    private int mjc=;
    public lDc=(nDk= cinfo);
    public void Njc=(mzg= pass_mode);
    public void mzc=(Byte[][] input_buf, Int32& in_row_ctr, int in_rows_avail, Byte[][][] output_buf, Int32& out_row_group_ctr, int out_row_groups_avail);
    private void nDc=();
    private void nTc=(Byte[][] input_buf, Int32& in_row_ctr, int in_rows_avail, Byte[][][] output_buf, Int32& out_row_group_ctr, int out_row_groups_avail);
    private void njc=(Byte[][] input_buf, Int32& in_row_ctr, int in_rows_avail, Byte[][][] output_buf, Int32& out_row_group_ctr, int out_row_groups_avail);
    private static void nzc=(Byte[][] image_data, int rowsOffset, int num_cols, int input_rows, int output_rows);
}
internal class VTM=.LDc= : 6zc= {
    private Hjc= LTc=;
    private AkE= Ljc=;
    private int Lzc=;
    private Jjc=[] MDc=;
    private Jjc=[] MTc=;
    private Jjc=[] Mjc=;
    private Jjc=[] Mzc=;
    private Boolean[] NDc=;
    private Boolean[] NTc=;
    public LDc=(TTo= cinfo);
    public virtual void Njc=();
    public virtual bool Nzc=(NTk=[] MCU_data);
    private bool ODc=();
}
internal enum VTM=.ljM= : Enum {
    public int value__;
    public static ljM= eDM=;
    public static ljM= lzM=;
    public static ljM= mDM=;
}
internal class VTM=.Ljs= : object {
    private int Lzs=;
    private int MDs=;
    private int MTs=;
    private int Mjs=;
    [CompilerGeneratedAttribute]
private EventHandler Mzs=;
    public int Njs= { get; public set; }
    public int OTs= { get; public set; }
    public int PDs= { get; public set; }
    public int Pzs= { get; public set; }
    [CompilerGeneratedAttribute]
public void QDs=(EventHandler value);
    [CompilerGeneratedAttribute]
public void QTs=(EventHandler value);
    public int NDs=();
    public void NTs=(int value);
    public int Nzs=();
    public void ODs=(int value);
    public int Ojs=();
    public void Ozs=(int value);
    public int PTs=();
    public void Pjs=(int value);
    public void Qzs=();
}
internal class VTM=.ljY= : object {
    public static int lzY=;
    private int mDY=;
    private float mTY=;
    private float mjY=;
    private float mzY=;
    private float nDY=;
    private float nTY=;
    private float njY=;
    private 3DY= nzY=;
    private Single[] oDY=;
    private Single[] oTY=;
    private Single[] ojY=;
    public void Kh8=(3DY= refDisplay, Single[] refWhite);
    public void ozY=(int l, int a, int b, Single& X, Single& Y, Single& Z);
    public void pDY=(float X, float Y, float Z, Int32& r, Int32& g, Int32& b);
    private static int pTY=(float R);
}
internal class VTM=.lTY= : object {
    private sealed virtual override int System.Collections.IComparer.Compare(object x, object y);
}
internal class VTM=.lzQ= : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
}
internal class VTM=.mDQ= : TiffCodec {
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public mDQ=(Tiff tif, Compression scheme, string name);
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool Seek(int row);
    private bool mTQ=(Byte[] buffer, int offset, int count, short plane);
    private bool mjQ=(Byte[] buffer, int offset, int count, short plane);
}
internal abstract class VTM=.mTg= : object {
    protected bool qzc=;
    public abstract virtual void Njc=();
    public abstract virtual void mjg=(Izc=[] input_buf, Int32& in_row_group_ctr, int in_row_groups_avail, Byte[][] output_buf, Int32& out_row_ctr, int out_rows_avail);
    public bool rTc=();
}
internal enum VTM=.mTM= : Enum {
    public int value__;
    public static mTM= hjM=;
    public static mTM= mjM=;
    public static mTM= mzM=;
}
internal enum VTM=.mzg= : Enum {
    public int value__;
    public static mzg= nDg=;
    public static mzg= nTg=;
    public static mzg= njg=;
    public static mzg= nzg=;
}
internal class VTM=.NDg= : object {
    private static int NTg=;
    private static int Njg=;
    private static int Czg=;
    private static int DDg=;
    private static int DTg=;
    private static int Djg=;
    private static int Dzg=;
    private static int EDg=;
    private static int ETg=;
    private static int Ejg=;
    private static int Ezg=;
    private static int FDg=;
    private static int FTg=;
    private static int Fjg=;
    private static int Fzg=;
    private static int GDg=;
    private static int Bjg=;
    private static int Nzg=;
    private static int ODg=;
    private static int OTg=;
    private static int Ojg=;
    private static int Ozg=;
    private static int PDg=;
    private static int PTg=;
    private static int Pjg=;
    private static int Pzg=;
    private static int QDg=;
    private static int QTg=;
    private static int Qjg=;
    private static int Qzg=;
    private static int RDg=;
    private static int RTg=;
    private static int Rjg=;
    private static int Rzg=;
    private static int SDg=;
    private static int STg=;
    private static int Sjg=;
    private static int Szg=;
    private static Int16[] Gjg=;
    private static int GTg=;
    private static Double[] Gzg=;
    private I0E=[] TDg=;
    private KkE=[] TTg=;
    private TTo= Xjc=;
    private Int32[] Tjg=;
    private Izc= Tzg=;
    public NDg=(TTo= cinfo);
    private static NDg=();
    public void Njc=();
    public void UDg=(int component_index, Int16[] coef_block, Izc= output_buf, int output_row, int output_col);
    private void UTg=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private static int Ujg=(int coef, int quantval);
    private void Uzg=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private static int Jjg=(int var, int c);
    private static int VDg=(short coef, int quantval);
    private static int VTg=(int x, int shft);
    private static int Vjg=(int x, int n);
    private void Vzg=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private static float WDg=(short coef, float quantval);
    private void WTg=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void Wjg=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private void Wzg=(int component_index, Int16[] coef_block, int output_row, int output_col);
    private static int XDg=(short coef, int quantval);
}
internal class VTM=.nDk= : Vjk= {
    private static Int32[] nTk=;
    private static Int32[] njk=;
    private static Byte[] nzk=;
    private static Byte[] oDk=;
    private static Byte[] oTk=;
    private static Byte[] ojk=;
    private static Byte[] ozk=;
    private static Byte[] pDk=;
    private static Byte[] pTk=;
    private static Byte[] pjk=;
    internal 2jo= pzk=;
    internal int IDY=;
    internal int qDk=;
    internal int qTk=;
    internal UTs= qjk=;
    internal int qzk=;
    internal int rDk=;
    internal UTs= rTk=;
    private bDk=[] rjk=;
    internal Sjs=[] rzk=;
    internal Njk=[] sDk=;
    internal Njk=[] sTk=;
    internal int sjk=;
    internal kjg=[] szk=;
    internal bool tDk=;
    internal bool tTk=;
    internal bool tjk=;
    internal int tzk=;
    internal WDs= uDk=;
    internal int HTY=;
    internal int uTk=;
    internal bool ujk=;
    internal byte uzk=;
    internal byte vDk=;
    internal Gzc= vTk=;
    internal short vjk=;
    internal short vzk=;
    internal bool wDk=;
    internal int wTk=;
    internal bool wjk=;
    internal int wzk=;
    internal int xDk=;
    internal int xTk=;
    internal int xjk=;
    internal Int32[] xzk=;
    internal int yDk=;
    internal int yTk=;
    internal int yjk=;
    internal Int32[] yzk=;
    internal int zDk=;
    internal int zTk=;
    internal int zjk=;
    internal int zzk=;
    internal fTc= 0Dk=;
    internal jzc= 0Tk=;
    internal lDc= 0jk=;
    internal jTc= 0zk=;
    internal gDg= 1Dk=;
    internal UTc= 1Tk=;
    internal qTc= 1jk=;
    internal BTg= 1zk=;
    internal ADg= 2Dk=;
    internal kjg=[] 2Tk=;
    internal int 2jk=;
    public bool Wjk= { get; }
    public 2jo= 3Tk= { get; public set; }
    public int 4Dk= { get; public set; }
    public int 4zk= { get; public set; }
    public int 5jk= { get; public set; }
    public UTs= 6Tk= { get; public set; }
    public int 7Dk= { get; public set; }
    public int 7zk= { get; public set; }
    public UTs= 8jk= { get; public set; }
    public bool 9Tk= { get; public set; }
    public bool /Dk= { get; public set; }
    public bool /zk= { get; public set; }
    public int Ajo= { get; public set; }
    public WDs= BTo= { get; public set; }
    public int CDo= { get; public set; }
    public int Czo= { get; public set; }
    public bool Djo= { get; public set; }
    public byte ETo= { get; public set; }
    public byte FDo= { get; public set; }
    public Gzc= Fzo= { get; public set; }
    public short Gjo= { get; public set; }
    public short HTo= { get; public set; }
    public bool IDo= { get; public set; }
    public int Ijo= { get; }
    public bDk=[] JDo= { get; }
    public Sjs=[] Jjo= { get; }
    public Njk=[] KDo= { get; }
    public Njk=[] Kjo= { get; }
    public int LDo= { get; }
    public nDk=(4Do= errorManager);
    private static nDk=();
    public virtual bool WTk=();
    public 2jo= 2zk=();
    public void 3Dk=(2jo= value);
    public int 3jk=();
    public void 3zk=(int value);
    public int 4Tk=();
    public void 4jk=(int value);
    public int 5Dk=();
    public void 5Tk=(int value);
    public UTs= 5zk=();
    public void 6Dk=(UTs= value);
    public int 6jk=();
    public void 6zk=(int value);
    public int 7Tk=();
    public void 7jk=(int value);
    public UTs= 8Dk=();
    public void 8Tk=(UTs= value);
    public bool 8zk=();
    public void 9Dk=(bool value);
    public bool 9jk=();
    public void 9zk=(bool value);
    public bool /Tk=();
    public void /jk=(bool value);
    public int ADo=();
    public void ATo=(int value);
    public WDs= Azo=();
    public void BDo=(WDs= value);
    public int Bjo=();
    public void Bzo=(int value);
    public int CTo=();
    public void Cjo=(int value);
    public bool DDo=();
    public void DTo=(bool value);
    public byte Dzo=();
    public void EDo=(byte value);
    public byte Ejo=();
    public void Ezo=(byte value);
    public Gzc= FTo=();
    public void Fjo=(Gzc= value);
    public short GDo=();
    public void GTo=(short value);
    public short Gzo=();
    public void HDo=(short value);
    public bool Hjo=();
    public void Hzo=(bool value);
    public int ITo=();
    public bDk=[] Izo=();
    public Sjs=[] JTo=();
    public Njk=[] Jzo=();
    public Njk=[] KTo=();
    public int Kzo=();
    public void LTo=();
    public void Ljo=(bool suppress);
    public void Lzo=();
    public void MDo=(int marker, Byte[] data);
    public void MTo=(int marker, int datalen);
    public void Mjo=(byte val);
    public void Mzo=();
    public void NDo=(Stream outfile);
    public void NTo=();
    public void Njo=(UTs= colorspace);
    public void Nzo=();
    public void ODo=(int quality, bool force_baseline);
    public void OTo=(int scale_factor, bool force_baseline);
    public void Ojo=(int which_tbl, Int32[] basic_table, int scale_factor, bool force_baseline);
    public static int Ozo=(int quality);
    public void PDo=();
    public void PTo=(bool write_all_tables);
    public int Pjo=(Byte[][] scanlines, int num_lines);
    public int Pzo=(Byte[][][] data, int num_lines);
    public void QDo=(TDs=[] coef_arrays);
    private void QTo=();
    private void Qjo=();
    private void Qzo=(bool transcode_only);
    private void RDo=(bool need_full_buffer);
    private void RTo=(TDs=[] coef_arrays);
    private void Mjg=();
    private void Rjo=();
    private void Rzo=();
    private void SDo=(Njk=& htblptr, Byte[] bits, Byte[] val);
    private void STo=(Int32& scanIndex, int ci, int Ss, int Se, int Ah, int Al);
    private void Sjo=(Int32& scanIndex, int ncomps, int Ah, int Al);
    private void Szo=(Int32& scanIndex, int ncomps, int Ss, int Se, int Ah, int Al);
    private void TDo=(int index, int id, int hsamp, int vsamp, int quant, int dctbl, int actbl);
}
internal enum VTM=.nDM= : Enum {
    public int value__;
    public static nDM= hjM=;
    public static nDM= nTM=;
    public static nDM= njM=;
}
internal class VTM=.Njk= : object {
    private Byte[] Nzk=;
    private Byte[] ODk=;
    private bool OTk=;
    internal Byte[] Ozk= { get; }
    internal Byte[] PTk= { get; }
    public bool QDk= { get; public set; }
    internal Byte[] Ojk=();
    internal Byte[] PDk=();
    public bool Pjk=();
    public void Pzk=(bool value);
}
[DefaultMemberAttribute("Item")]
internal class VTM=.NTk= : object {
    internal Int16[] zBM=;
    public short whw= { get; public set; }
    public short wBw=(int index);
    public void wRw=(int index, short value);
}
internal enum VTM=.nzM= : Enum {
    public int value__;
    public static nzM= oDM=;
    public static nzM= oTM=;
    public static nzM= ojM=;
    public static nzM= ozM=;
    public static nzM= pDM=;
    public static nzM= pTM=;
}
internal class VTM=.oDc= : object {
    private TTo= Xjc=;
    private int gTc=;
    private bool oTc=;
    private bool ojc=;
    private ejc= ozc=;
    private ejc= pDc=;
    public oDc=(TTo= cinfo);
    public void ijc=();
    public void pTc=();
    public bool pjc=();
    private void pzc=();
    private void qDc=();
}
internal class VTM=.oDg= : object {
    private static Int32[] oTg=;
    private static int ojg=;
    private static int ozg=;
    private static int pDg=;
    private static int pTg=;
    private static Byte[][] pjg=;
    private LUE= pzg=;
    private TTo= Xjc=;
    private Byte[][] qDg=;
    private int qTg=;
    private Byte[][] qjg=;
    private Int32[] qzg=;
    private bool rDg=;
    private Int32[] rTg=;
    private int rjg=;
    private Int32[][][] rzg=;
    private Int16[][] sDg=;
    private bool sTg=;
    public oDg=(TTo= cinfo);
    private static oDg=();
    public virtual void Njc=(bool is_pre_scan);
    public virtual void ezc=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    public virtual void Pzc=();
    public virtual void fDc=();
    private void sjg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void szg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void tDg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void tTg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void tjg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void tzg=();
    private void uDg=();
    private void uTg=();
    private void ujg=();
    private static int uzg=(int j, int maxj);
    private static int vDg=(int j, int maxj);
    private int vTg=(Int32[] Ncolors);
    private static Int32[][] vjg=(int ncolors);
}
internal class VTM=.OTc= : ADg= {
    private bool Ojc=;
    private AkE= Ljc=;
    private int Lzc=;
    private int Ozc=;
    private c_derived_tbl[] MDc=;
    private c_derived_tbl[] MTc=;
    private Int64[][] PDc=;
    private Int64[][] PTc=;
    public OTc=(nDk= cinfo);
    public virtual void Njc=(bool gather_statistics);
    public virtual bool Pjc=(NTk=[][] MCU_data);
    public virtual void Pzc=();
    private bool QDc=(NTk=[][] MCU_data);
    private void QTc=();
    private bool Qjc=(NTk=[][] MCU_data);
    private void Qzc=();
    private bool RDc=(AkE= state, Int16[] block, int last_dc_val, c_derived_tbl dctbl, c_derived_tbl actbl);
    private void RTc=(Int16[] block, int last_dc_val, Int64[] dc_counts, Int64[] ac_counts);
    private bool Rjc=(int val);
    private bool Rzc=(AkE= state, int code, int size);
    private bool SDc=(AkE= state);
    private bool STc=(AkE= state, int restart_num);
}
internal class VTM=.PD0= : object {
    private static int 5Dw=;
    private static int Zjw=;
    private static int Zzw=;
    private static int aDw=;
    private static int aTw=;
    private static int ajw=;
    private static int azw=;
    private static int bDw=;
    private static int bTw=;
    private static int bjw=;
    internal static int PT0=;
    internal static int Pj0=;
    internal static Int32[] Pz0=;
    internal static Int32[] QD0=;
    internal static Int32[] QT0=;
    internal static Int32[] Qj0=;
    internal static Int32[] Qz0=;
    internal static Int32[] RD0=;
    internal static int RT0=;
    private static PD0=();
    internal static int Rj0=(Int32[] b, int bindex, int n, int s, Int32[] d, Int32[] e, Int32[] t, Int32[] m, Int32[] hp, Int32[] hn, Int32[] v);
    internal static int Rz0=(Int32[] c, Int32[] bb, Int32[] tb, Int32[] hp, cz0= z);
    internal static int SD0=(int nl, int nd, Int32[] c, Int32[] bl, Int32[] bd, Int32[] tl, Int32[] td, Int32[] hp, cz0= z);
    internal static int ST0=(Int32[] bl, Int32[] bd, Int32[][] tl, Int32[][] td, cz0= z);
}
internal enum VTM=.pjM= : Enum {
    public int value__;
    public static pjM= pzM=;
    public static pjM= qDM=;
    public static pjM= qTM=;
}
internal class VTM=.pjY= : object {
    public Int32[] pzY=;
    public int qDY=;
    public int qTY=;
    public int qjY=;
    public int qzY=;
    public int rDY=;
    public int rTY=;
    public ajM= rjY=;
    public short rzY=;
    public nzM= sDY=;
    public Compression sTY=;
    public izM= sjY=;
    public pjM= szY=;
    public bjM= tDY=;
    public Orientation tTY=;
    public short tjY=;
    public int tzY=;
    public ushort uDY=;
    public ushort uTY=;
    public double ujY=;
    public double uzY=;
    public float vDY=;
    public float vTY=;
    public nDM= vjY=;
    public ljM= vzY=;
    public float wDY=;
    public float wTY=;
    public Int16[] wjY=;
    public Int16[][] wzY=;
    public Int16[] xDY=;
    public short xTY=;
    public XzM=[] xjY=;
    public int xzY=;
    public int yDY=;
    public UInt64[] yTY=;
    public UInt64[] yjY=;
    public bool yzY=;
    public int zDY=;
    public Int64[] zTY=;
    public Int16[] zjY=;
    public qjM= zzY=;
    public Single[] 0DY=;
    public Int16[][] 0TY=;
    public int 0jY=;
    public string 0zY=;
    public int 1DY=;
    public CTc=[] 1TY=;
}
internal enum VTM=.qjM= : Enum {
    public int value__;
    public static qjM= qzM=;
    public static qjM= rDM=;
}
internal class VTM=.qTc= : object {
    private EEE=[] qjc=;
    private nDk= Xjc=;
    private bool qzc=;
    public qTc=(nDk= cinfo);
    public void rDc=(Byte[][][] input_buf, int in_row_index, Byte[][][] output_buf, int out_row_group_index);
    public bool rTc=();
    private void rjc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void rzc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void sDc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void sTc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void sjc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private void szc=(int componentIndex, Byte[][] input_data, int startInputRow, Byte[][] output_data, int startOutRow);
    private static void tDc=(Byte[][] image_data, int startInputRow, int num_rows, int input_cols, int output_cols);
}
internal static class VTM=.QTk= : object {
    public static int Qjk=;
    public static int Qzk=;
    public static int RDk=;
    public static int RTk=;
    public static int Rjk=;
    public static int Rzk=;
    public static int SDk=;
    public static int STk=;
    public static int Sjk=;
    public static int Szk=;
    public static WDs= TDk=;
    public static WDs= TTk=;
    public static int Tjk=;
    public static int Tzk=;
    public static int UDk=;
    public static int UTk=;
    public static int Ujk=;
    public static int Uzk=;
    public static int VDk=;
    public static int VTk=;
}
internal abstract class VTM=.RDs= : object {
    private Byte[] RTs=;
    private int Rjs=;
    private int 2zo=;
    public abstract virtual void yjU=();
    public abstract virtual bool yzU=();
    protected void 3zo=(Byte[] buffer, int size);
    public virtual void jDY=(int num_bytes);
    public virtual bool jTY=(TTo= cinfo, int desired);
    public virtual void jjY=();
    public virtual bool Rzs=(Int32& V);
    public virtual bool SDs=(Int32& V);
    public virtual int 6xM=(Byte[] dest, int amount);
    public virtual bool STs=();
}
internal static class VTM=.rTM= : object {
    internal static int rjM=;
    internal static short rzM=;
    internal static short sDM=;
    internal static short sTM=;
    internal static short sjM=;
    internal static short szM=;
    internal static short tDM=;
    internal static short tTM=;
    internal static short tjM=;
    internal static short tzM=;
    internal static short uDM=;
    internal static short uTM=;
    internal static short ujM=;
    internal static short uzM=;
    internal static short vDM=;
    internal static short vTM=;
    internal static short vjM=;
    internal static short vzM=;
    internal static short wDM=;
    internal static short wTM=;
    internal static short wjM=;
    internal static short wzM=;
    internal static short xDM=;
    internal static short xTM=;
    internal static short xjM=;
    internal static short xzM=;
    internal static short yDM=;
    internal static short yTM=;
    internal static short yjM=;
    internal static short yzM=;
    internal static short zDM=;
    internal static short zTM=;
    internal static short zjM=;
    internal static short zzM=;
    internal static short 0DM=;
    public static short 0TM=;
    public static short 0jM=;
    public static short 0zM=;
    public static short 1DM=;
    public static short 1TM=;
}
internal class VTM=.Sj0= : object {
    private static int gDw=;
    private static int gjw=;
    private static int gTw=;
    private static int hDw=;
    private static int gzw=;
    private static int hTw=;
    internal static int Sz0=;
    internal static Int16[] TD0=;
    internal static Int16[] TT0=;
    internal static Sj0= Tj0=;
    internal static Sj0= Tz0=;
    internal static Sj0= UD0=;
    internal Int16[] UT0=;
    internal Int32[] Uj0=;
    internal int Uz0=;
    internal int VD0=;
    internal int VT0=;
    internal Sj0=(Int16[] static_tree, Int32[] extra_bits, int extra_base, int elems, int max_length);
    private static Sj0=();
}
internal class VTM=.Sjc= : object {
    public static Int32[] Szc=;
    private static Sjc=();
    public static int TDc=(int x, int shft);
    public static int TTc=(int x, int n);
    public static int Tjc=(int a, int b);
    public static int Tzc=(int a, int b);
    public static void UDc=(Izc= input_array, int source_row, Byte[][] output_array, int dest_row, int num_rows, int num_cols);
    public static void UDc=(Izc= input_array, int source_row, Izc= output_array, int dest_row, int num_rows, int num_cols);
    public static void UDc=(Byte[][] input_array, int source_row, Byte[][] output_array, int dest_row, int num_rows, int num_cols);
}
internal class VTM=.Sjs= : object {
    private bool OTk=;
    internal Int16[] Szs=;
    public bool QDk= { get; public set; }
    public bool Pjk=();
    public void Pzk=(bool value);
}
internal class VTM=.Szw= : object {
    private static int TDw=;
    private static int TTw=;
    internal long Tjw=(long adler, Byte[] buf, int index, int len);
}
internal class VTM=.TDs= : object {
    private Vjk= Xjc=;
    private T[][] HTQ=;
    public Vjk= Tzs= { get; public set; }
    internal TDs=(int width, int height, Y0E=<T> allocator);
    public Vjk= TTs=();
    public void Tjs=(Vjk= value);
    public T[][] UDs=(int startRow, int numberOfRows);
}
internal class VTM=.tTc= : object {
    private static int tjc=;
    private static int tzc=;
    private static int uDc=;
    private static int uTc=;
    private static int ujc=;
    private static int uzc=;
    private TTo= Xjc=;
    private bool vDc=;
    private F0E= vTc=;
    private int vjc=;
    private int vzc=;
    private int wDc=;
    private NTk=[] wTc=;
    private TDs=[] wjc=;
    private TDs=[] wzc=;
    private Int32[] xDc=;
    private int xTc=;
    public tTc=(TTo= cinfo, bool need_full_buffer);
    public void xjc=();
    public xDs= xzc=();
    public void yDc=();
    public xDs= yTc=(Izc=[] output_buf);
    public TDs=[] yjc=();
    private xDs= yzc=(Izc=[] output_buf);
    private xDs= zDc=(Izc=[] output_buf);
    private xDs= zTc=(Izc=[] output_buf);
    private bool zjc=();
    private void zzc=();
}
internal class VTM=.TTo= : Vjk= {
    internal RDs= Tjo=;
    internal int IDY=;
    internal int qDk=;
    internal int rDk=;
    internal UTs= rTk=;
    internal UTs= Tzo=;
    internal int UDo=;
    internal int UTo=;
    internal bool Ujo=;
    internal bool Uzo=;
    internal WDs= uDk=;
    internal bool VDo=;
    internal bool VTo=;
    internal bool Vjo=;
    internal XDs= Vzo=;
    internal bool WDo=;
    internal int WTo=;
    internal bool Wjo=;
    internal bool Wzo=;
    internal bool XDo=;
    internal int XTo=;
    internal int Xjo=;
    internal int Xzo=;
    internal int YDo=;
    internal int YTo=;
    internal int Yjo=;
    internal Byte[][] Yzo=;
    internal int ZDo=;
    internal int ZTo=;
    internal int Zjo=;
    internal int Zzo=;
    internal int aDo=;
    internal Int32[][] aTo=;
    internal Sjs=[] rzk=;
    internal Njk=[] sDk=;
    internal Njk=[] sTk=;
    internal int qzk=;
    private bDk=[] rjk=;
    internal bool wjk=;
    internal int HTY=;
    internal bool ajo=;
    internal byte uzk=;
    internal byte vDk=;
    internal Gzc= vTk=;
    internal short vjk=;
    internal short vzk=;
    internal bool azo=;
    internal byte bDo=;
    internal bool tjk=;
    internal List`1<KDs=> bTo=;
    internal int wzk=;
    internal int xDk=;
    internal int bjo=;
    internal int xTk=;
    internal Byte[] bzo=;
    internal int cDo=;
    internal int xjk=;
    internal Int32[] xzk=;
    internal int yDk=;
    internal int yTk=;
    internal int yjk=;
    internal Int32[] yzk=;
    internal int zDk=;
    internal int zTk=;
    internal int zjk=;
    internal int zzk=;
    internal int cTo=;
    internal oDc= 0Dk=;
    internal 0Dc= 0Tk=;
    internal tTc= 0zk=;
    internal 4jc= cjo=;
    internal Jzg= czo=;
    internal XTg= 1Dk=;
    internal 6zc= 2Dk=;
    internal NDg= dDo=;
    internal mTg= dTo=;
    internal bzc= 1Tk=;
    internal ejc= djo=;
    public bool Wjk= { get; }
    public RDs= eTo= { get; public set; }
    public int 4Dk= { get; }
    public int 4zk= { get; }
    public int 7zk= { get; }
    public UTs= 8jk= { get; public set; }
    public UTs= fDo= { get; public set; }
    public int fzo= { get; public set; }
    public int gjo= { get; public set; }
    public bool hTo= { get; public set; }
    public bool iDo= { get; public set; }
    public WDs= BTo= { get; public set; }
    public bool izo= { get; public set; }
    public bool jjo= { get; public set; }
    public bool kTo= { get; public set; }
    public XDs= lDo= { get; public set; }
    public bool lzo= { get; public set; }
    public int mjo= { get; public set; }
    public bool nTo= { get; public set; }
    public bool oDo= { get; public set; }
    public bool ozo= { get; public set; }
    public int pTo= { get; }
    public int pzo= { get; }
    public int qTo= { get; }
    public int qzo= { get; }
    public int rTo= { get; }
    public int sDo= { get; public set; }
    public Byte[][] szo= { get; public set; }
    public int tTo= { get; }
    public int tzo= { get; }
    public int uTo= { get; }
    public int uzo= { get; }
    public int vTo= { get; }
    public Int32[][] vzo= { get; }
    public Gzc= Fzo= { get; }
    public short Gjo= { get; }
    public short HTo= { get; }
    public int 7Dk= { get; }
    public int Ijo= { get; }
    public int wTo= { get; }
    public bDk=[] xDo= { get; internal set; }
    public TTo=(4Do= errorManager);
    public virtual bool WTk=();
    public RDs= dzo=();
    public void eDo=(RDs= value);
    public int 3jk=();
    public int 4Tk=();
    public int 7Tk=();
    public UTs= 8Dk=();
    public void 8Tk=(UTs= value);
    public UTs= ejo=();
    public void ezo=(UTs= value);
    public int fTo=();
    public void fjo=(int value);
    public int gDo=();
    public void gTo=(int value);
    public bool gzo=();
    public void hDo=(bool value);
    public bool hjo=();
    public void hzo=(bool value);
    public WDs= Azo=();
    public void BDo=(WDs= value);
    public bool iTo=();
    public void ijo=(bool value);
    public bool jDo=();
    public void jTo=(bool value);
    public bool jzo=();
    public void kDo=(bool value);
    public XDs= kjo=();
    public void kzo=(XDs= value);
    public bool lTo=();
    public void ljo=(bool value);
    public int mDo=();
    public void mTo=(int value);
    public bool mzo=();
    public void nDo=(bool value);
    public bool njo=();
    public void nzo=(bool value);
    public bool oTo=();
    public void ojo=(bool value);
    public int pDo=();
    public int pjo=();
    public int qDo=();
    public int qjo=();
    public int rDo=();
    public int rjo=();
    public void rzo=(int value);
    public Byte[][] sTo=();
    public void sjo=(Byte[][] value);
    public int tDo=();
    public int tjo=();
    public int uDo=();
    public int ujo=();
    public int vDo=();
    public Int32[][] vjo=();
    public Gzc= FTo=();
    public short GDo=();
    public short Gzo=();
    public int 6jk=();
    public int ITo=();
    public int wDo=();
    public bDk=[] wjo=();
    internal void wzo=(bDk=[] value);
    public void xTo=(Stream infile);
    public xDs= xjo=(bool require_image);
    public bool xzo=();
    public int yDo=(Byte[][] scanlines, int max_lines);
    public bool yTo=();
    public int yjo=(Byte[][][] data, int max_lines);
    public bool yzo=();
    public bool zDo=(int scan_number);
    public bool zTo=();
    public bool zjo=();
    public xDs= zzo=();
    public void 0Do=();
    public TDs=[] 0To=();
    public void 0jo=(nDk= dstinfo);
    public void 0zo=();
    public void bjg=(int marker_code, jpeg_marker_parser_method routine);
    public void bzg=(int marker_code, int length_limit);
    internal bool 1Do=();
    private void QTo=();
    private void 1To=();
    private bool 1jo=();
    private void 1zo=();
    private void 2Do=();
    private xDs= 2To=();
}
internal class VTM=.Tzw= : object {
    private static int UDw=;
    private static int UTw=;
    private static int Ujw=;
    private static int Uzw=;
    private static int VDw=;
    private static int VTw=;
    private static int Vjw=;
    private static ZEE=[] Vzw=;
    private static String[] WDw=;
    private static int WTw=;
    private static int Wjw=;
    private static int Wzw=;
    private static int XDw=;
    private static int XTw=;
    private static int Xjw=;
    private static int Xzw=;
    private static int YDw=;
    private static int YTw=;
    private static int Yjw=;
    private static int Yzw=;
    private static int ZDw=;
    private static int ZTw=;
    private static int Zjw=;
    private static int Zzw=;
    private static int aDw=;
    private static int aTw=;
    private static int ajw=;
    private static int azw=;
    private static int bDw=;
    private static int bTw=;
    private static int bjw=;
    private static int bzw=;
    private static int cDw=;
    private static int cTw=;
    private static int cjw=;
    private static int czw=;
    private static int dDw=;
    private static int dTw=;
    private static int djw=;
    private static int dzw=;
    private static int eDw=;
    private static int eTw=;
    private static int ejw=;
    private static int ezw=;
    private static int fDw=;
    private static int fTw=;
    private static int fjw=;
    private static int fzw=;
    private static int gDw=;
    private static int gTw=;
    private static int gjw=;
    private static int gzw=;
    private static int hDw=;
    private static int hTw=;
    private static int hjw=;
    private static int hzw=;
    internal cz0= iDw=;
    internal int iTw=;
    internal Byte[] ijw=;
    internal int izw=;
    internal int jDw=;
    internal int jTw=;
    internal int jjw=;
    internal byte jzw=;
    internal byte kDw=;
    internal int kTw=;
    internal int kjw=;
    internal int kzw=;
    internal int lDw=;
    internal Byte[] lTw=;
    internal int ljw=;
    internal Int16[] lzw=;
    internal Int16[] mDw=;
    internal int mTw=;
    internal int mjw=;
    internal int mzw=;
    internal int nDw=;
    internal int nTw=;
    internal int njw=;
    internal int nzw=;
    internal int oDw=;
    internal int oTw=;
    internal int ojw=;
    internal int ozw=;
    internal int pDw=;
    internal int pTw=;
    internal int pjw=;
    internal int pzw=;
    internal int 9h8=;
    internal int Ehs=;
    internal int qDw=;
    internal int qTw=;
    internal Int16[] qjw=;
    internal Int16[] qzw=;
    internal Int16[] rDw=;
    internal Wz0= rTw=;
    internal Wz0= rjw=;
    internal Wz0= rzw=;
    internal Int16[] sDw=;
    internal Int32[] sTw=;
    internal int sjw=;
    internal int szw=;
    internal Byte[] tDw=;
    internal int tTw=;
    internal int tjw=;
    internal int tzw=;
    internal int uDw=;
    internal int uTw=;
    internal int ujw=;
    internal int uzw=;
    internal int vDw=;
    internal short vTw=;
    internal int vjw=;
    private static Tzw=();
    internal void vzw=();
    internal void wDw=();
    internal void wTw=();
    internal void wjw=(Int16[] tree, int k);
    internal static bool wzw=(Int16[] tree, int n, int m, Byte[] depth);
    internal void xDw=(Int16[] tree, int max_code);
    internal int xTw=();
    internal void xjw=(int lcodes, int dcodes, int blcodes);
    internal void xzw=(Int16[] tree, int max_code);
    internal void yDw=(Byte[] p, int start, int len);
    internal void yDw=(byte c);
    internal void yTw=(int w);
    internal void yjw=(int b);
    internal void yzw=(int c, Int16[] tree);
    internal void zDw=(int value_Renamed, int length);
    internal void zTw=();
    internal bool zjw=(int dist, int lc);
    internal void zzw=(Int16[] ltree, Int16[] dtree);
    internal void 0Dw=();
    internal void 0Tw=();
    internal void 0jw=();
    internal void 0zw=(int buf, int len, bool header);
    internal void 1Dw=(bool eof);
    internal int 1Tw=(int flush);
    internal void 1jw=(int buf, int stored_len, bool eof);
    internal void 1zw=(int buf, int stored_len, bool eof);
    internal void 2Dw=();
    internal int 2Tw=(int flush);
    internal int 2jw=(int flush);
    internal int 2zw=(int cur_match);
    internal int 3Dw=(cz0= strm, int level, int bits);
    internal int 3Dw=(cz0= strm, int level);
    internal int 3Tw=(cz0= strm, int level, int method, int windowBits, int memLevel, int strategy);
    internal int 3jw=(cz0= strm);
    internal int 3zw=();
    internal int 4Dw=(cz0= strm, int _level, int _strategy);
    internal int 4Tw=(cz0= strm, Byte[] dictionary, int dictLength);
    internal int 4jw=(cz0= strm, int flush);
}
internal class VTM=.UTc= : object {
    private static int Ujc=;
    private static int Uzc=;
    private static int Dzc=;
    private static int VDc=;
    private static int VTc=;
    private static int Vjc=;
    private static int Vzc=;
    private static int WDc=;
    private static int WTc=;
    private static int Wjc=;
    private static int Wzc=;
    private static int XDc=;
    private static int XTc=;
    private nDk= Xjc=;
    private bool Xzc=;
    private bool YDc=;
    private bool YTc=;
    private bool Yjc=;
    private bool Yzc=;
    private bool ZDc=;
    private Int32[] ZTc=;
    public UTc=(nDk= cinfo);
    public void Njc=();
    public void Zjc=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void Zzc=();
    private void aDc=();
    private static int aTc=(double x);
    private void ajc=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void azc=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void bDc=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void bTc=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
    private void bjc=(Byte[][] input_buf, int input_row, Byte[][][] output_buf, int output_row, int num_rows);
}
internal enum VTM=.UTs= : Enum {
    public int value__;
    public static UTs= Ujs=;
    public static UTs= Uzs=;
    public static UTs= VDs=;
    public static UTs= VTs=;
    public static UTs= Vjs=;
    public static UTs= Vzs=;
}
internal enum VTM=.VDM= : Enum {
    public int value__;
    public static VDM= VjM=;
    public static VDM= VzM=;
    public static VDM= WDM=;
}
internal class VTM=.Vj0= : object {
    public static long YyI=(long literal);
    public static ulong YyI=(ulong literal);
    public static float YyI=(float literal);
    public static double YyI=(double literal);
    public static int Vz0=(int number, int bits);
    public static int Vz0=(int number, long bits);
    public static long Vz0=(long number, int bits);
    public static long Vz0=(long number, long bits);
    public static int WD0=(Stream sourceStream, Byte[] target, int start, int count);
    public static int WD0=(TextReader sourceTextReader, Byte[] target, int start, int count);
    public static Byte[] WT0=(string sourceString);
    public static Char[] Wj0=(Byte[] byteArray);
}
internal abstract class VTM=.Vjk= : object {
    internal 4Do= jzU=;
    internal Ljs= Vzk=;
    internal UkE= WDk=;
    public bool Wjk= { get; }
    public Ljs= XTk= { get; public set; }
    public 4Do= YDk= { get; public set; }
    public static string ERQ= { get; }
    public static string Yjk= { get; }
    public Vjk=(4Do= errorManager);
    public abstract virtual bool WTk=();
    public Ljs= Wzk=();
    public void XDk=(Ljs= value);
    public 4Do= Xjk=();
    public void Xzk=(4Do= value);
    public static string DxQ=();
    public static string YTk=();
    public static TDs=<byte> Yzk=(int samplesPerRow, int numberOfRows);
    public static TDs=<NTk=> ZDk=(int blocksPerRow, int numberOfRows);
    public static Byte[][] ZTk=(int samplesPerRow, int numberOfRows);
    private static NTk=[][] Zjk=(int blocksPerRow, int numberOfRows);
    public void Zzk=();
    public void aDk=();
    public void aTk=(YDs= code);
    public void aTk=(YDs= code, Object[] args);
    public void aTk=(int code, Object[] args);
    public void ajk=(YDs= code);
    public void ajk=(YDs= code, Object[] args);
    public void ajk=(int code, Object[] args);
    public void azk=(int lvl, YDs= code);
    public void azk=(int lvl, YDs= code, Object[] args);
    public void azk=(int lvl, int code, Object[] args);
}
internal class VTM=.vTU= : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream fd, TiffPrintFlags flags);
    private static void vjU=(Tiff tif);
}
internal class VTM=.vzg= : object {
    private static int wDg=;
    private static int wTg=;
    private static int wjg=;
    private static int wzg=;
    private static int xDg=;
    private static int xTg=;
    private static int xjg=;
    private static int xzg=;
    private static int yDg=;
    private static int yTg=;
    private static int yjg=;
    private static int yzg=;
    private static int zDg=;
    private static int zTg=;
    private static int zjg=;
    private static int zzg=;
    private static int 0Dg=;
    private static int 0Tg=;
    private static int 0jg=;
    private static int 0zg=;
    private static int 1Dg=;
    private static int 1Tg=;
    private LUE= pzg=;
    private bool 1jg=;
    private TTo= Xjc=;
    private Byte[][] qDg=;
    private int 1zg=;
    private UInt16[][] 2Dg=;
    private bool 2Tg=;
    private Int16[] sDg=;
    private bool sTg=;
    private Int32[] 2jg=;
    public vzg=(TTo= cinfo);
    public virtual void Njc=(bool is_pre_scan);
    public virtual void ezc=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    public virtual void Pzc=();
    public virtual void fDc=();
    private void 2zg=(Byte[][] input_buf, int in_row, int num_rows);
    private void 3Dg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void 3Tg=(Byte[][] input_buf, int in_row, Byte[][] output_buf, int out_row, int num_rows);
    private void 3jg=();
    private void 3zg=(M0E=[] boxlist, int boxIndex, int icolor);
    private void 4Dg=(int desired_colors);
    private int 4Tg=(M0E=[] boxlist, int numboxes, int desired_colors);
    private static int 4jg=(M0E=[] boxlist, int numboxes);
    private static int 4zg=(M0E=[] boxlist, int numboxes);
    private void 5Dg=(M0E=[] boxlist, int boxIndex);
    private void 5Tg=();
    private int 5jg=(int minc0, int minc1, int minc2, Byte[] colorlist);
    private void 5zg=(int minc0, int minc1, int minc2, int numcolors, Byte[] colorlist, Byte[] bestcolor);
    private void 6Dg=(int c0, int c1, int c2);
}
internal class VTM=.vzU= : 4Do= {
    private fjU= wDU=;
    public vzU=(fjU= sp);
    public virtual void wTU=();
    public virtual void wjU=();
}
internal enum VTM=.WDs= : Enum {
    public int value__;
    public static WDs= WTs=;
    public static WDs= Wjs=;
    public static WDs= Wzs=;
}
internal enum VTM=.WTM= : Enum {
    public int value__;
    public static WTM= WjM=;
    public static WTM= WzM=;
    public static WTM= XDM=;
    public static WTM= XTM=;
    public static WTM= XjM=;
}
internal class VTM=.Wz0= : object {
    private static int gDw=;
    private static int gjw=;
    private static int gTw=;
    private static int hDw=;
    private static int gzw=;
    private static int hTw=;
    private static int hjw=;
    internal static int Sz0=;
    internal static int hzw=;
    internal static int ejw=;
    internal static int ezw=;
    internal static int fDw=;
    internal static Int32[] XD0=;
    internal static Int32[] XT0=;
    internal static Int32[] Xj0=;
    internal static Byte[] Xz0=;
    internal static int eTw=;
    internal static int YD0=;
    internal static Byte[] YT0=;
    internal static Byte[] Yj0=;
    internal static Int32[] Yz0=;
    internal static Int32[] ZD0=;
    internal Int16[] ZT0=;
    internal int Zj0=;
    internal Sj0= Zz0=;
    private static Wz0=();
    internal static int aD0=(int dist);
    internal void aT0=(Tzw= s);
    internal void aj0=(Tzw= s);
    internal static void az0=(Int16[] tree, int max_code, Int16[] bl_count);
    internal static int bD0=(int code, int len);
}
internal class VTM=.wzU= : 2jo= {
    private Tiff xDU=;
    public wzU=(Tiff tif);
    public virtual void xTU=();
    public virtual bool xjU=();
    public virtual void xzU=();
}
internal enum VTM=.xDs= : Enum {
    public int value__;
    public static xDs= xTs=;
    public static xDs= xjs=;
    public static xDs= xzs=;
    public static xDs= yDs=;
    public static xDs= yTs=;
    public static xDs= yjs=;
    public static xDs= yzs=;
}
internal enum VTM=.XDs= : Enum {
    public int value__;
    public static XDs= XTs=;
    public static XDs= Xjs=;
    public static XDs= Xzs=;
}
internal class VTM=.XjQ= : TiffCodec {
    public static int XzQ=;
    private static TiffFieldInfo[] YDQ=;
    private mTM= YTQ=;
    private int YjQ=;
    private int YzQ=;
    private TiffTagMethods BTQ=;
    private TiffTagMethods BjQ=;
    private TiffTagMethods ZDQ=;
    private bool ZTQ=;
    private bool ZjQ=;
    private xUA= ZzQ=;
    public XjQ=(Tiff tif, Compression scheme, string name);
    private static XjQ=();
    public void aDQ=(TiffTagMethods tagMethods);
    public void aTQ=();
    public virtual bool SetupDecode();
    public virtual bool DecodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool DecodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool SetupEncode();
    public virtual bool EncodeRow(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeStrip(Byte[] buffer, int offset, int count, short plane);
    public virtual bool EncodeTile(Byte[] buffer, int offset, int count, short plane);
    public virtual bool ajQ=();
    public virtual bool azQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool bDQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool bTQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool bjQ=();
    public virtual bool bzQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool cDQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool cTQ=(Byte[] buffer, int offset, int count, short plane);
    public mTM= cjQ=();
    public void czQ=(mTM= value);
    public TiffTagMethods dDQ=();
    private void dTQ=(Byte[] buffer, int offset, int count);
    private void djQ=(Byte[] buffer, int offset, int count);
    private void dzQ=(Byte[] buffer, int offset, int count);
    private void eDQ=(Byte[] buffer, int offset, int count);
    private void eTQ=(Byte[] buffer, int offset, int count);
    private void ejQ=(Byte[] buffer, int offset, int count);
    private void ezQ=(Byte[] buffer, int offset, int count);
    private void fDQ=(Byte[] buffer, int offset, int count);
    private void fTQ=(Byte[] buffer, int offset, int count);
    private void fjQ=(Byte[] buffer, int offset, int count);
    private void fzQ=(Byte[] buffer, int offset, int count);
    private bool gDQ=(Byte[] buffer, int offset, int count, short plane);
    private bool gTQ=(Byte[] buffer, int offset, int count, short plane);
    private bool gjQ=(Byte[] buffer, int offset, int count, short plane);
    private bool gzQ=(Byte[] buffer, int offset, int count, short plane);
    private bool hDQ=();
    private bool hTQ=();
    private bool hjQ=();
}
internal class VTM=.XTg= : object {
    private static int Xjg=;
    private static int Xzg=;
    private static int YDg=;
    private TTo= Xjc=;
    private jpeg_marker_parser_method YTg=;
    private jpeg_marker_parser_method[] Yjg=;
    private int Yzg=;
    private Int32[] ZDg=;
    private bool ZTg=;
    private bool Zjg=;
    private int Ozc=;
    private int Zzg=;
    private KDs= aDg=;
    private int aTg=;
    public XTg=(TTo= cinfo);
    public void ajg=();
    public xDs= azg=();
    public bool bDg=();
    public bool bTg=();
    public void bjg=(int marker_code, jpeg_marker_parser_method routine);
    public void bzg=(int marker_code, int length_limit);
    public bool cDg=();
    public bool cTg=();
    public int cjg=();
    public int czg=();
    public void BCw=(int count);
    private static bool dDg=(TTo= cinfo);
    private static bool dTg=(TTo= cinfo);
    private static bool djg=(TTo= cinfo);
    private static void dzg=(TTo= cinfo, Byte[] data, int datalen, int remaining);
    private static void eDg=(TTo= cinfo, Byte[] data, int datalen, int remaining);
    private bool eTg=();
    private bool ejg=(bool is_prog);
    private bool ezg=();
    private bool fDg=();
    private bool fTg=();
    private bool fjg=();
    private bool fzg=();
}
internal class VTM=.XTQ= : TiffTagMethods {
    public virtual bool SetField(Tiff tif, TiffTag tag, FieldValue[] ap);
    public virtual FieldValue[] GetField(Tiff tif, TiffTag tag);
    public virtual void PrintDir(Tiff tif, Stream fd, TiffPrintFlags flags);
}
internal enum VTM=.XzM= : Enum {
    public int value__;
    public static XzM= YDM=;
    public static XzM= YTM=;
    public static XzM= YjM=;
}
internal enum VTM=.YDs= : Enum {
    public int value__;
    public static YDs= YTs=;
    public static YDs= Yjs=;
    public static YDs= Yzs=;
    public static YDs= ZDs=;
    public static YDs= ZTs=;
    public static YDs= Zjs=;
    public static YDs= Zzs=;
    public static YDs= aDs=;
    public static YDs= aTs=;
    public static YDs= ajs=;
    public static YDs= azs=;
    public static YDs= bDs=;
    public static YDs= bTs=;
    public static YDs= bjs=;
    public static YDs= bzs=;
    public static YDs= cDs=;
    public static YDs= cTs=;
    public static YDs= cjs=;
    public static YDs= czs=;
    public static YDs= dDs=;
    public static YDs= dTs=;
    public static YDs= djs=;
    public static YDs= dzs=;
    public static YDs= eDs=;
    public static YDs= eTs=;
    public static YDs= ejs=;
    public static YDs= ezs=;
    public static YDs= fDs=;
    public static YDs= fTs=;
    public static YDs= fjs=;
    public static YDs= fzs=;
    public static YDs= gDs=;
    public static YDs= gTs=;
    public static YDs= gjs=;
    public static YDs= gzs=;
    public static YDs= hDs=;
    public static YDs= hTs=;
    public static YDs= hjs=;
    public static YDs= hzs=;
    public static YDs= iDs=;
    public static YDs= iTs=;
    public static YDs= ijs=;
    public static YDs= izs=;
    public static YDs= jDs=;
    public static YDs= jTs=;
    public static YDs= jjs=;
    public static YDs= jzs=;
    public static YDs= kDs=;
    public static YDs= kTs=;
    public static YDs= kjs=;
    public static YDs= kzs=;
    public static YDs= lDs=;
    public static YDs= lTs=;
    public static YDs= ljs=;
    public static YDs= lzs=;
    public static YDs= mDs=;
    public static YDs= mTs=;
    public static YDs= mjs=;
    public static YDs= mzs=;
    public static YDs= nDs=;
    public static YDs= nTs=;
    public static YDs= njs=;
    public static YDs= nzs=;
    public static YDs= oDs=;
    public static YDs= oTs=;
    public static YDs= ojs=;
    public static YDs= ozs=;
    public static YDs= pDs=;
    public static YDs= pTs=;
    public static YDs= pjs=;
    public static YDs= pzs=;
    public static YDs= qDs=;
    public static YDs= qTs=;
    public static YDs= qjs=;
    public static YDs= qzs=;
    public static YDs= rDs=;
    public static YDs= rTs=;
    public static YDs= rjs=;
    public static YDs= rzs=;
    public static YDs= sDs=;
    public static YDs= sTs=;
    public static YDs= sjs=;
    public static YDs= szs=;
    public static YDs= tDs=;
    public static YDs= tTs=;
    public static YDs= tjs=;
    public static YDs= tzs=;
    public static YDs= uDs=;
    public static YDs= uTs=;
    public static YDs= ujs=;
    public static YDs= uzs=;
    public static YDs= vDs=;
    public static YDs= vTs=;
    public static YDs= vjs=;
    public static YDs= vzs=;
    public static YDs= wDs=;
    public static YDs= wTs=;
    public static YDs= wjs=;
    public static YDs= wzs=;
}
internal class VTM=.yDU= : RDs= {
    private static Byte[] yTU=;
    protected fjU= wDU=;
    public yDU=(fjU= sp);
    private static yDU=();
    public virtual void yjU=();
    public virtual bool yzU=();
}
[FlagsAttribute]
internal enum VTM=.YzM= : Enum {
    public int value__;
    public static YzM= ZDM=;
    public static YzM= ZTM=;
    public static YzM= ZjM=;
    public static YzM= ZzM=;
    public static YzM= aDM=;
    public static YzM= aTM=;
}
internal class VTM=.zDU= : 2jo= {
    private fjU= wDU=;
    public zDU=(fjU= sp);
    public virtual void xTU=();
    public virtual bool xjU=();
    public virtual void xzU=();
}
internal class VTM=.zjU= : XjQ= {
    private bool zzU=;
    private static short 0DU=;
    private static short 0TU=;
    private static short 0jU=;
    private static short 0zU=;
    private static short 1DU=;
    private static short 1TU=;
    private static short 1jU=;
    private static int 1zU=;
    private static int 2DU=;
    private static int 2TU=;
    private static int 2jU=;
    private bool 2zU=;
    private short 3DU=;
    private short 3TU=;
    private short 3jU=;
    private int 3zU=;
    private int 4DU=;
    private int BzQ=;
    private int 4TU=;
    private int 4jU=;
    private int 4zU=;
    private bool 5DU=;
    private int 5TU=;
    private int 5jU=;
    private int 5zU=;
    private int 6DU=;
    private 20A=[] 6TU=;
    private int 6jU=;
    private int 6zU=;
    private int 7DU=;
    private int 7TU=;
    private int 7jU=;
    private int 7zU=;
    private 3UA=[] 8DU=;
    public bool CanEncode { get; }
    public bool CanDecode { get; }
    public zjU=(Tiff tif, Compression scheme, string name);
    public virtual bool Init();
    public virtual bool get_CanEncode();
    public virtual bool get_CanDecode();
    public virtual bool PreDecode(short plane);
    public virtual bool PreEncode(short plane);
    public virtual bool PostEncode();
    public virtual void Cleanup();
    public virtual bool ajQ=();
    public virtual bool azQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool bDQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool bTQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool bjQ=();
    public virtual bool bzQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool cDQ=(Byte[] buffer, int offset, int count, short plane);
    public virtual bool cTQ=(Byte[] buffer, int offset, int count, short plane);
    private bool 8TU=();
    private bool 8jU=(short s);
    private bool 8zU=(Byte[] buffer, int offset, int count, short plane);
    private bool 9DU=(Byte[] buffer, int offset, int count, short plane);
    private bool 9TU=();
    private bool 9jU=(short s);
    private bool 9zU=();
    private bool /DU=(Byte[] buffer, int offset, int count, short plane);
    private void /TU=();
    private static int /jU=(int n);
    private void /zU=(int c);
    private void ADY=();
    private void ATY=(Int16& _code, bool compat);
    private void AjY=(Int16& code);
    private void AzY=(Int16& code);
    private void BDY=();
}
internal class VTM=.zTU= : yDU= {
    public zTU=(fjU= sp);
    public virtual void yjU=();
}
[CompilerGeneratedAttribute]
internal class wRM= : object {
    [DebuggerBrowsableAttribute("0")]
private <candidateConstructor>j__TPar whM=;
    [DebuggerBrowsableAttribute("0")]
private <rank>j__TPar wxM=;
    public <candidateConstructor>j__TPar xRM= { get; }
    public <rank>j__TPar xxM= { get; }
    [DebuggerHiddenAttribute]
public wRM=(<candidateConstructor>j__TPar candidateConstructor, <rank>j__TPar rank);
    public <candidateConstructor>j__TPar xBM=();
    public <rank>j__TPar xhM=();
    [DebuggerHiddenAttribute]
public virtual bool Equals(object value);
    [DebuggerHiddenAttribute]
public virtual int GetHashCode();
    [DebuggerHiddenAttribute]
public virtual string ToString();
}
internal static class yhM=.7BM= : object {
    internal static string 7RM=(string plainText);
    internal static string 7hM=(string plainText);
    internal static string 7xM=(string plainText);
    internal static DateTime 8BM=(string formatedDate);
    internal static string 8RM=(DateTime expireTime);
}
internal class yhM=.8hM= : BxQ= {
    private static Dictionary`2<string, 8hM=> 8xM=;
    private static object 9BM=;
    private static bool 9RM=;
    private static Dictionary`2<string, 8hM=> 9xM= { get; }
    private static 8hM=();
    public static void /BM=(Dictionary`2<string, Collection`1<string>> licenseContents);
    private static Dictionary`2<string, 8hM=> 9hM=();
    public static IEnumerable`1<JxQ=> /RM=(Guid productId);
    private static void /hM=(Guid productId, aBQ= nodeType, IEnumerable`1<JxQ=> source, List`1<JxQ=> licenseNodes);
    public static void /xM=();
    private static 8hM= ABQ=(string fileLicensePathName);
    private static 8hM= ARQ=(Stream licenseStream);
    private static 8hM= AhQ=(Collection`1<string> licenseLines);
    private static void AxQ=(JxQ= node);
    private static JxQ= BBQ=(string content);
    private static IEnumerable`1<string> BRQ=(string licenseFileExtension, string searchPattern);
    private static IEnumerable`1<string> BhQ=();
}
internal enum yhM=.aBQ= : Enum {
    public int value__;
    public static aBQ= aRQ=;
    public static aBQ= ahQ=;
    public static aBQ= axQ=;
    public static aBQ= bBQ=;
}
internal abstract class yhM=.bhQ= : object {
    [CompilerGeneratedAttribute]
private bhQ= bxQ=;
    protected bhQ= chQ= { get; private set; }
    protected ThinkGeoLicenseStatus[] GxQ= { get; }
    [CompilerGeneratedAttribute]
protected bhQ= cBQ=();
    [CompilerGeneratedAttribute]
private void cRQ=(bhQ= value);
    public virtual void HBQ=(mRQ= context);
    public bhQ= cxQ=(bhQ= next);
    protected abstract virtual ThinkGeoLicenseStatus[] GhQ=();
}
internal class yhM=.bRQ= : bhQ= {
    protected ThinkGeoLicenseStatus[] GxQ= { get; }
    public virtual void HBQ=(mRQ= context);
    protected virtual ThinkGeoLicenseStatus[] GhQ=();
}
internal abstract class yhM=.BxQ= : object {
    [CompilerGeneratedAttribute]
private string CBQ=;
    [CompilerGeneratedAttribute]
private string CRQ=;
    private Collection`1<JxQ=> ChQ=;
    private Collection`1<JxQ=> CxQ=;
    public string DhQ= { get; public set; }
    public string ERQ= { get; public set; }
    public IEnumerable`1<JxQ=> ExQ= { get; }
    public IEnumerable`1<JxQ=> FRQ= { get; }
    public bool FxQ= { get; }
    [CompilerGeneratedAttribute]
public string DBQ=();
    [CompilerGeneratedAttribute]
public void DRQ=(string value);
    [CompilerGeneratedAttribute]
public string DxQ=();
    [CompilerGeneratedAttribute]
public void EBQ=(string value);
    public IEnumerable`1<JxQ=> EhQ=();
    public IEnumerable`1<JxQ=> FBQ=();
    public void GBQ=(JxQ= node);
    public bool FhQ=();
}
internal static class yhM=.dBQ= : object {
    private static bhQ= dRQ=;
    private static dBQ=();
    public static ThinkGeoLicenseStatus HBQ=(mRQ= validationContext);
}
internal class yhM=.dhQ= : object {
    private Guid dxQ=;
    private string eBQ=;
    private string eRQ=;
    private string ehQ=;
    private string exQ=;
    internal static Collection`1<dhQ=> fBQ=;
    public Guid fxQ= { get; public set; }
    public string pRM= { get; public set; }
    internal string gxQ= { get; internal set; }
    internal string hhQ= { get; internal set; }
    internal string iRQ= { get; internal set; }
    public bool ixQ= { get; }
    public bool jRQ= { get; }
    private static dhQ=();
    public Guid fRQ=();
    public void fhQ=(Guid value);
    public string pBM=();
    public void gBQ=(string value);
    internal string gRQ=();
    internal void ghQ=(string value);
    internal string hBQ=();
    internal void hRQ=(string value);
    internal string hxQ=();
    internal void iBQ=(string value);
    public bool ihQ=();
    public bool jBQ=();
    private static Collection`1<dhQ=> jhQ=();
    [CompilerGeneratedAttribute]
private bool jxQ=(dhQ= p);
}
internal class yhM=.GRQ= : bhQ= {
    protected ThinkGeoLicenseStatus[] GxQ= { get; }
    public virtual void HBQ=(mRQ= context);
    protected virtual ThinkGeoLicenseStatus[] GhQ=();
    private static bool HRQ=(JxQ= productNode);
    private static Assembly HhQ=(string assemblyPath, string assemblyName);
}
internal class yhM=.HxQ= : bhQ= {
    protected ThinkGeoLicenseStatus[] GxQ= { get; }
    public virtual void HBQ=(mRQ= context);
    protected virtual ThinkGeoLicenseStatus[] GhQ=();
    private static bool IBQ=(JxQ= productNode);
}
internal class yhM=.IRQ= : bhQ= {
    private static string IhQ=;
    protected ThinkGeoLicenseStatus[] GxQ= { get; }
    private static IRQ=();
    public virtual void HBQ=(mRQ= context);
    private static bool IxQ=(JxQ= node);
    protected virtual ThinkGeoLicenseStatus[] GhQ=();
    private bool JBQ=(JxQ= productNode);
    private static bool JRQ=(JxQ= productNode, bool isDebug);
}
internal class yhM=.JhQ= : bhQ= {
    protected ThinkGeoLicenseStatus[] GxQ= { get; }
    public virtual void HBQ=(mRQ= context);
    protected virtual ThinkGeoLicenseStatus[] GhQ=();
}
internal class yhM=.JxQ= : object {
    public static JxQ= KBQ=;
    private Guid KRQ=;
    private Version KhQ=;
    private string KxQ=;
    private string LBQ=;
    private string LRQ=;
    private dhQ= LhQ=;
    private JxQ= LxQ=;
    private JxQ= MBQ=;
    private string MRQ=;
    private DateTime MhQ=;
    private Nullable`1<DateTime> MxQ=;
    private aBQ= NBQ=;
    private BxQ= NRQ=;
    private ThinkGeoLicenseStatus NhQ=;
    private string NxQ=;
    public string OBQ=;
    public Guid OxQ= { get; public set; }
    public Version ERQ= { get; public set; }
    public string PhQ= { get; public set; }
    public string QRQ= { get; public set; }
    public string RBQ= { get; public set; }
    public dhQ= RxQ= { get; public set; }
    public JxQ= ShQ= { get; public set; }
    public JxQ= TRQ= { get; public set; }
    public string UBQ= { get; public set; }
    public DateTime UxQ= { get; public set; }
    public Nullable`1<DateTime> VhQ= { get; public set; }
    public aBQ= WRQ= { get; public set; }
    public BxQ= XBQ= { get; internal set; }
    public ThinkGeoLicenseStatus XxQ= { get; public set; }
    public string YhQ= { get; public set; }
    public string ZRQ= { get; public set; }
    public bool ZxQ= { get; }
    private static JxQ=();
    public Guid ORQ=();
    public void OhQ=(Guid value);
    public Version DxQ=();
    public void EBQ=(Version value);
    public string PBQ=();
    public void PRQ=(string value);
    public string PxQ=();
    public void QBQ=(string value);
    public string QhQ=();
    public void QxQ=(string value);
    public dhQ= RRQ=();
    public void RhQ=(dhQ= value);
    public JxQ= SBQ=();
    public void SRQ=(JxQ= value);
    public JxQ= SxQ=();
    public void TBQ=(JxQ= value);
    public string ThQ=();
    public void TxQ=(string value);
    public DateTime URQ=();
    public void UhQ=(DateTime value);
    public Nullable`1<DateTime> VBQ=();
    public void VRQ=(Nullable`1<DateTime> value);
    public aBQ= VxQ=();
    public void WBQ=(aBQ= value);
    public BxQ= WhQ=();
    internal void WxQ=(BxQ= value);
    public ThinkGeoLicenseStatus XRQ=();
    public void XhQ=(ThinkGeoLicenseStatus value);
    public string YBQ=();
    public void YRQ=(string value);
    public string YxQ=();
    public void ZBQ=(string value);
    public bool ZhQ=();
}
internal class yhM=.kBQ= : object {
    private static string kRQ=;
    private yRM= khQ=;
    private yRM= kxQ=;
    private RSACryptoServiceProvider lBQ=;
    private static kBQ=();
    private void lRQ=(string publicKeyBase64);
    public Byte[] lhQ=(Byte[] encryptedData);
    public sealed virtual void Dispose();
    public string lxQ=(string encryptedData);
}
internal class yhM=.mBQ= : bhQ= {
    protected ThinkGeoLicenseStatus[] GxQ= { get; }
    public virtual void HBQ=(mRQ= context);
    private static bool IxQ=(JxQ= node);
    protected virtual ThinkGeoLicenseStatus[] GhQ=();
}
internal class yhM=.mRQ= : object {
    [CompilerGeneratedAttribute]
private JxQ= mhQ=;
    [CompilerGeneratedAttribute]
private ThinkGeoLicenseStatus mxQ=;
    [CompilerGeneratedAttribute]
private bool nBQ=;
    public JxQ= nxQ= { get; private set; }
    public ThinkGeoLicenseStatus ohQ= { get; public set; }
    public bool pRQ= { get; private set; }
    public mRQ=(JxQ= productNode, bool isDebug);
    [CompilerGeneratedAttribute]
public JxQ= nRQ=();
    [CompilerGeneratedAttribute]
private void nhQ=(JxQ= value);
    [CompilerGeneratedAttribute]
public ThinkGeoLicenseStatus oBQ=();
    [CompilerGeneratedAttribute]
public void oRQ=(ThinkGeoLicenseStatus value);
    [CompilerGeneratedAttribute]
public bool oxQ=();
    [CompilerGeneratedAttribute]
private void pBQ=(bool value);
}
internal class yhM=.yRM= : object {
    private static int yxM=;
    private UInt32[] zBM=;
    public int zRM=;
    public yRM=(long value);
    public yRM=(ulong value);
    public yRM=(yRM= bi);
    public yRM=(string value, int radix);
    public yRM=(Byte[] inData);
    public yRM=(Byte[] inData, int inLen);
    public yRM=(UInt32[] inData);
    public static yRM= zhM=(long value);
    public static yRM= zhM=(ulong value);
    public static yRM= zhM=(int value);
    public static yRM= zhM=(UInt32 value);
    public static yRM= zxM=(yRM= bi1, yRM= bi2);
    public static yRM= 0BM=(yRM= bi1);
    public static yRM= 0RM=(yRM= bi1, yRM= bi2);
    public static yRM= 0hM=(yRM= bi1);
    public static yRM= 0xM=(yRM= bi1, yRM= bi2);
    public static yRM= 1BM=(yRM= bi1, int shiftVal);
    private static int 1RM=(UInt32[] buffer, int shiftVal);
    public static yRM= 1hM=(yRM= bi1, int shiftVal);
    private static int 1xM=(UInt32[] buffer, int shiftVal);
    public static yRM= 2BM=(yRM= bi1);
    public static yRM= 2RM=(yRM= bi1);
    public static bool 2hM=(yRM= bi1, yRM= bi2);
    public static bool 2xM=(yRM= bi1, yRM= bi2);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static bool 3BM=(yRM= bi1, yRM= bi2);
    public static bool 3RM=(yRM= bi1, yRM= bi2);
    public static bool 3hM=(yRM= bi1, yRM= bi2);
    public static bool 3xM=(yRM= bi1, yRM= bi2);
    private static void 4BM=(yRM= bi1, yRM= bi2, yRM= outQuotient, yRM= outRemainder);
    private static void 4RM=(yRM= bi1, yRM= bi2, yRM= outQuotient, yRM= outRemainder);
    public static yRM= 4hM=(yRM= bi1, yRM= bi2);
    public static yRM= 4xM=(yRM= bi1, yRM= bi2);
    public static yRM= 5BM=(yRM= bi1, yRM= bi2);
    public static yRM= 5RM=(yRM= bi1, yRM= bi2);
    public static yRM= 5hM=(yRM= bi1, yRM= bi2);
    public virtual string ToString();
    public string 5xM=(int radix);
    public yRM= 6BM=(yRM= exp, yRM= n);
    private yRM= 6RM=(yRM= x, yRM= n, yRM= constant);
    private int 6hM=();
    public Byte[] 6xM=();
}
