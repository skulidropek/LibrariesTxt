[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.AbsorbedDoseOfIonizingRadiation : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<AbsorbedDoseOfIonizingRadiationUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<AbsorbedDoseOfIonizingRadiationUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static AbsorbedDoseOfIonizingRadiationUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static AbsorbedDoseOfIonizingRadiationUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static AbsorbedDoseOfIonizingRadiation <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<AbsorbedDoseOfIonizingRadiationUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static AbsorbedDoseOfIonizingRadiationUnit BaseUnit { get; }
    public static AbsorbedDoseOfIonizingRadiationUnit[] Units { get; }
    public static AbsorbedDoseOfIonizingRadiation Zero { get; }
    public static AbsorbedDoseOfIonizingRadiation AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public AbsorbedDoseOfIonizingRadiationUnit Unit { get; }
    public QuantityInfo`1<AbsorbedDoseOfIonizingRadiationUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Centigrays { get; }
    public double Femtograys { get; }
    public double Gigagrays { get; }
    public double Grays { get; }
    public double Kilograys { get; }
    public double Kilorads { get; }
    public double Megagrays { get; }
    public double Megarads { get; }
    public double Micrograys { get; }
    public double Milligrays { get; }
    public double Millirads { get; }
    public double Nanograys { get; }
    public double Petagrays { get; }
    public double Picograys { get; }
    public double Rads { get; }
    public double Teragrays { get; }
    private static AbsorbedDoseOfIonizingRadiation();
    public AbsorbedDoseOfIonizingRadiation(double value, AbsorbedDoseOfIonizingRadiationUnit unit);
    public AbsorbedDoseOfIonizingRadiation(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<AbsorbedDoseOfIonizingRadiationUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static AbsorbedDoseOfIonizingRadiationUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static AbsorbedDoseOfIonizingRadiationUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override AbsorbedDoseOfIonizingRadiation get_Zero();
    public static override AbsorbedDoseOfIonizingRadiation get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual AbsorbedDoseOfIonizingRadiationUnit get_Unit();
    public sealed virtual QuantityInfo`1<AbsorbedDoseOfIonizingRadiationUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Centigrays();
    public double get_Femtograys();
    public double get_Gigagrays();
    public double get_Grays();
    public double get_Kilograys();
    public double get_Kilorads();
    public double get_Megagrays();
    public double get_Megarads();
    public double get_Micrograys();
    public double get_Milligrays();
    public double get_Millirads();
    public double get_Nanograys();
    public double get_Petagrays();
    public double get_Picograys();
    public double get_Rads();
    public double get_Teragrays();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(AbsorbedDoseOfIonizingRadiationUnit unit);
    public static string GetAbbreviation(AbsorbedDoseOfIonizingRadiationUnit unit, IFormatProvider provider);
    public static AbsorbedDoseOfIonizingRadiation FromCentigrays(double value);
    public static AbsorbedDoseOfIonizingRadiation FromFemtograys(double value);
    public static AbsorbedDoseOfIonizingRadiation FromGigagrays(double value);
    public static AbsorbedDoseOfIonizingRadiation FromGrays(double value);
    public static AbsorbedDoseOfIonizingRadiation FromKilograys(double value);
    public static AbsorbedDoseOfIonizingRadiation FromKilorads(double value);
    public static AbsorbedDoseOfIonizingRadiation FromMegagrays(double value);
    public static AbsorbedDoseOfIonizingRadiation FromMegarads(double value);
    public static AbsorbedDoseOfIonizingRadiation FromMicrograys(double value);
    public static AbsorbedDoseOfIonizingRadiation FromMilligrays(double value);
    public static AbsorbedDoseOfIonizingRadiation FromMillirads(double value);
    public static AbsorbedDoseOfIonizingRadiation FromNanograys(double value);
    public static AbsorbedDoseOfIonizingRadiation FromPetagrays(double value);
    public static AbsorbedDoseOfIonizingRadiation FromPicograys(double value);
    public static AbsorbedDoseOfIonizingRadiation FromRads(double value);
    public static AbsorbedDoseOfIonizingRadiation FromTeragrays(double value);
    public static AbsorbedDoseOfIonizingRadiation From(double value, AbsorbedDoseOfIonizingRadiationUnit fromUnit);
    public static AbsorbedDoseOfIonizingRadiation Parse(string str);
    public static override AbsorbedDoseOfIonizingRadiation Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, AbsorbedDoseOfIonizingRadiation& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, AbsorbedDoseOfIonizingRadiation& result);
    public static AbsorbedDoseOfIonizingRadiationUnit ParseUnit(string str);
    public static AbsorbedDoseOfIonizingRadiationUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, AbsorbedDoseOfIonizingRadiationUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, AbsorbedDoseOfIonizingRadiationUnit& unit);
    public static override AbsorbedDoseOfIonizingRadiation op_UnaryNegation(AbsorbedDoseOfIonizingRadiation right);
    public static override AbsorbedDoseOfIonizingRadiation op_Addition(AbsorbedDoseOfIonizingRadiation left, AbsorbedDoseOfIonizingRadiation right);
    public static override AbsorbedDoseOfIonizingRadiation op_Subtraction(AbsorbedDoseOfIonizingRadiation left, AbsorbedDoseOfIonizingRadiation right);
    public static AbsorbedDoseOfIonizingRadiation op_Multiply(double left, AbsorbedDoseOfIonizingRadiation right);
    public static override AbsorbedDoseOfIonizingRadiation op_Multiply(AbsorbedDoseOfIonizingRadiation left, double right);
    public static override AbsorbedDoseOfIonizingRadiation op_Division(AbsorbedDoseOfIonizingRadiation left, double right);
    public static double op_Division(AbsorbedDoseOfIonizingRadiation left, AbsorbedDoseOfIonizingRadiation right);
    public static override bool op_LessThanOrEqual(AbsorbedDoseOfIonizingRadiation left, AbsorbedDoseOfIonizingRadiation right);
    public static override bool op_GreaterThanOrEqual(AbsorbedDoseOfIonizingRadiation left, AbsorbedDoseOfIonizingRadiation right);
    public static override bool op_LessThan(AbsorbedDoseOfIonizingRadiation left, AbsorbedDoseOfIonizingRadiation right);
    public static override bool op_GreaterThan(AbsorbedDoseOfIonizingRadiation left, AbsorbedDoseOfIonizingRadiation right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(AbsorbedDoseOfIonizingRadiation other, AbsorbedDoseOfIonizingRadiation tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(AbsorbedDoseOfIonizingRadiation left, AbsorbedDoseOfIonizingRadiation right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(AbsorbedDoseOfIonizingRadiation other, AbsorbedDoseOfIonizingRadiation tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(AbsorbedDoseOfIonizingRadiation left, AbsorbedDoseOfIonizingRadiation right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(AbsorbedDoseOfIonizingRadiation other, AbsorbedDoseOfIonizingRadiation tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(AbsorbedDoseOfIonizingRadiation other, AbsorbedDoseOfIonizingRadiation tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(AbsorbedDoseOfIonizingRadiation other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(AbsorbedDoseOfIonizingRadiation other);
    [ObsoleteAttribute("Use Equals(AbsorbedDoseOfIonizingRadiation other, AbsorbedDoseOfIonizingRadiation tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(AbsorbedDoseOfIonizingRadiation other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(AbsorbedDoseOfIonizingRadiation other, AbsorbedDoseOfIonizingRadiation tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(AbsorbedDoseOfIonizingRadiationUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public AbsorbedDoseOfIonizingRadiation ToUnit(AbsorbedDoseOfIonizingRadiationUnit unit);
    public AbsorbedDoseOfIonizingRadiation ToUnit(AbsorbedDoseOfIonizingRadiationUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(AbsorbedDoseOfIonizingRadiationUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public AbsorbedDoseOfIonizingRadiation ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<AbsorbedDoseOfIonizingRadiationUnit> UnitsNet.IQuantity<UnitsNet.Units.AbsorbedDoseOfIonizingRadiationUnit>.ToUnit(AbsorbedDoseOfIonizingRadiationUnit unit);
    private sealed virtual override IQuantity`1<AbsorbedDoseOfIonizingRadiationUnit> UnitsNet.IQuantity<UnitsNet.Units.AbsorbedDoseOfIonizingRadiationUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Acceleration : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<AccelerationUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<AccelerationUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccelerationUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static AccelerationUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Acceleration <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<AccelerationUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static AccelerationUnit BaseUnit { get; }
    public static AccelerationUnit[] Units { get; }
    public static Acceleration Zero { get; }
    public static Acceleration AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public AccelerationUnit Unit { get; }
    public QuantityInfo`1<AccelerationUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentimetersPerSecondSquared { get; }
    public double DecimetersPerSecondSquared { get; }
    public double FeetPerSecondSquared { get; }
    public double InchesPerSecondSquared { get; }
    public double KilometersPerSecondSquared { get; }
    public double KnotsPerHour { get; }
    public double KnotsPerMinute { get; }
    public double KnotsPerSecond { get; }
    public double MetersPerSecondSquared { get; }
    public double MicrometersPerSecondSquared { get; }
    public double MillimetersPerSecondSquared { get; }
    public double MillistandardGravity { get; }
    public double NanometersPerSecondSquared { get; }
    public double StandardGravity { get; }
    private static Acceleration();
    public Acceleration(double value, AccelerationUnit unit);
    public Acceleration(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<AccelerationUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static AccelerationUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static AccelerationUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Acceleration get_Zero();
    public static override Acceleration get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual AccelerationUnit get_Unit();
    public sealed virtual QuantityInfo`1<AccelerationUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentimetersPerSecondSquared();
    public double get_DecimetersPerSecondSquared();
    public double get_FeetPerSecondSquared();
    public double get_InchesPerSecondSquared();
    public double get_KilometersPerSecondSquared();
    public double get_KnotsPerHour();
    public double get_KnotsPerMinute();
    public double get_KnotsPerSecond();
    public double get_MetersPerSecondSquared();
    public double get_MicrometersPerSecondSquared();
    public double get_MillimetersPerSecondSquared();
    public double get_MillistandardGravity();
    public double get_NanometersPerSecondSquared();
    public double get_StandardGravity();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(AccelerationUnit unit);
    public static string GetAbbreviation(AccelerationUnit unit, IFormatProvider provider);
    public static Acceleration FromCentimetersPerSecondSquared(double value);
    public static Acceleration FromDecimetersPerSecondSquared(double value);
    public static Acceleration FromFeetPerSecondSquared(double value);
    public static Acceleration FromInchesPerSecondSquared(double value);
    public static Acceleration FromKilometersPerSecondSquared(double value);
    public static Acceleration FromKnotsPerHour(double value);
    public static Acceleration FromKnotsPerMinute(double value);
    public static Acceleration FromKnotsPerSecond(double value);
    public static Acceleration FromMetersPerSecondSquared(double value);
    public static Acceleration FromMicrometersPerSecondSquared(double value);
    public static Acceleration FromMillimetersPerSecondSquared(double value);
    public static Acceleration FromMillistandardGravity(double value);
    public static Acceleration FromNanometersPerSecondSquared(double value);
    public static Acceleration FromStandardGravity(double value);
    public static Acceleration From(double value, AccelerationUnit fromUnit);
    public static Acceleration Parse(string str);
    public static override Acceleration Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Acceleration& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Acceleration& result);
    public static AccelerationUnit ParseUnit(string str);
    public static AccelerationUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, AccelerationUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, AccelerationUnit& unit);
    public static override Acceleration op_UnaryNegation(Acceleration right);
    public static override Acceleration op_Addition(Acceleration left, Acceleration right);
    public static override Acceleration op_Subtraction(Acceleration left, Acceleration right);
    public static Acceleration op_Multiply(double left, Acceleration right);
    public static override Acceleration op_Multiply(Acceleration left, double right);
    public static override Acceleration op_Division(Acceleration left, double right);
    public static double op_Division(Acceleration left, Acceleration right);
    public static override Duration op_Division(Acceleration acceleration, Jerk jerk);
    public static override Force op_Multiply(Acceleration acceleration, Mass mass);
    public static override Jerk op_Division(Acceleration acceleration, Duration duration);
    public static override SpecificWeight op_Multiply(Acceleration acceleration, Density density);
    public static override Speed op_Multiply(Acceleration acceleration, Duration duration);
    public static override bool op_LessThanOrEqual(Acceleration left, Acceleration right);
    public static override bool op_GreaterThanOrEqual(Acceleration left, Acceleration right);
    public static override bool op_LessThan(Acceleration left, Acceleration right);
    public static override bool op_GreaterThan(Acceleration left, Acceleration right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Acceleration other, Acceleration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Acceleration left, Acceleration right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Acceleration other, Acceleration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Acceleration left, Acceleration right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Acceleration other, Acceleration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Acceleration other, Acceleration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Acceleration other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Acceleration other);
    [ObsoleteAttribute("Use Equals(Acceleration other, Acceleration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Acceleration other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Acceleration other, Acceleration tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(AccelerationUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Acceleration ToUnit(AccelerationUnit unit);
    public Acceleration ToUnit(AccelerationUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(AccelerationUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Acceleration ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<AccelerationUnit> UnitsNet.IQuantity<UnitsNet.Units.AccelerationUnit>.ToUnit(AccelerationUnit unit);
    private sealed virtual override IQuantity`1<AccelerationUnit> UnitsNet.IQuantity<UnitsNet.Units.AccelerationUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.AmbiguousUnitParseException : UnitsNetException {
    public AmbiguousUnitParseException(string message);
    public AmbiguousUnitParseException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.AmountOfSubstance : ValueType {
    [CompilerGeneratedAttribute]
private static double <AvogadroConstant>k__BackingField;
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<AmountOfSubstanceUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<AmountOfSubstanceUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmountOfSubstanceUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmountOfSubstanceUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmountOfSubstance <Zero>k__BackingField;
    public static double AvogadroConstant { get; }
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<AmountOfSubstanceUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static AmountOfSubstanceUnit BaseUnit { get; }
    public static AmountOfSubstanceUnit[] Units { get; }
    public static AmountOfSubstance Zero { get; }
    public static AmountOfSubstance AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public AmountOfSubstanceUnit Unit { get; }
    public QuantityInfo`1<AmountOfSubstanceUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Centimoles { get; }
    public double CentipoundMoles { get; }
    public double Decimoles { get; }
    public double DecipoundMoles { get; }
    public double Femtomoles { get; }
    public double Kilomoles { get; }
    public double KilopoundMoles { get; }
    public double Megamoles { get; }
    public double Micromoles { get; }
    public double MicropoundMoles { get; }
    public double Millimoles { get; }
    public double MillipoundMoles { get; }
    public double Moles { get; }
    public double Nanomoles { get; }
    public double NanopoundMoles { get; }
    public double Picomoles { get; }
    public double PoundMoles { get; }
    private static AmountOfSubstance();
    public AmountOfSubstance(double value, AmountOfSubstanceUnit unit);
    public AmountOfSubstance(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static double get_AvogadroConstant();
    public double NumberOfParticles();
    public static AmountOfSubstance FromMass(Mass mass, MolarMass molarMass);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<AmountOfSubstanceUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static AmountOfSubstanceUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static AmountOfSubstanceUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override AmountOfSubstance get_Zero();
    public static override AmountOfSubstance get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual AmountOfSubstanceUnit get_Unit();
    public sealed virtual QuantityInfo`1<AmountOfSubstanceUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Centimoles();
    public double get_CentipoundMoles();
    public double get_Decimoles();
    public double get_DecipoundMoles();
    public double get_Femtomoles();
    public double get_Kilomoles();
    public double get_KilopoundMoles();
    public double get_Megamoles();
    public double get_Micromoles();
    public double get_MicropoundMoles();
    public double get_Millimoles();
    public double get_MillipoundMoles();
    public double get_Moles();
    public double get_Nanomoles();
    public double get_NanopoundMoles();
    public double get_Picomoles();
    public double get_PoundMoles();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(AmountOfSubstanceUnit unit);
    public static string GetAbbreviation(AmountOfSubstanceUnit unit, IFormatProvider provider);
    public static AmountOfSubstance FromCentimoles(double value);
    public static AmountOfSubstance FromCentipoundMoles(double value);
    public static AmountOfSubstance FromDecimoles(double value);
    public static AmountOfSubstance FromDecipoundMoles(double value);
    public static AmountOfSubstance FromFemtomoles(double value);
    public static AmountOfSubstance FromKilomoles(double value);
    public static AmountOfSubstance FromKilopoundMoles(double value);
    public static AmountOfSubstance FromMegamoles(double value);
    public static AmountOfSubstance FromMicromoles(double value);
    public static AmountOfSubstance FromMicropoundMoles(double value);
    public static AmountOfSubstance FromMillimoles(double value);
    public static AmountOfSubstance FromMillipoundMoles(double value);
    public static AmountOfSubstance FromMoles(double value);
    public static AmountOfSubstance FromNanomoles(double value);
    public static AmountOfSubstance FromNanopoundMoles(double value);
    public static AmountOfSubstance FromPicomoles(double value);
    public static AmountOfSubstance FromPoundMoles(double value);
    public static AmountOfSubstance From(double value, AmountOfSubstanceUnit fromUnit);
    public static AmountOfSubstance Parse(string str);
    public static override AmountOfSubstance Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, AmountOfSubstance& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, AmountOfSubstance& result);
    public static AmountOfSubstanceUnit ParseUnit(string str);
    public static AmountOfSubstanceUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, AmountOfSubstanceUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, AmountOfSubstanceUnit& unit);
    public static override AmountOfSubstance op_UnaryNegation(AmountOfSubstance right);
    public static override AmountOfSubstance op_Addition(AmountOfSubstance left, AmountOfSubstance right);
    public static override AmountOfSubstance op_Subtraction(AmountOfSubstance left, AmountOfSubstance right);
    public static AmountOfSubstance op_Multiply(double left, AmountOfSubstance right);
    public static override AmountOfSubstance op_Multiply(AmountOfSubstance left, double right);
    public static override AmountOfSubstance op_Division(AmountOfSubstance left, double right);
    public static double op_Division(AmountOfSubstance left, AmountOfSubstance right);
    public static override Duration op_Division(AmountOfSubstance amountOfSubstance, MolarFlow molarFlow);
    public static override Mass op_Multiply(AmountOfSubstance amountOfSubstance, MolarMass molarMass);
    public static override MolarFlow op_Division(AmountOfSubstance amountOfSubstance, Duration duration);
    public static override Molarity op_Division(AmountOfSubstance amountOfSubstance, Volume volume);
    public static override Volume op_Division(AmountOfSubstance amountOfSubstance, Molarity molarity);
    public static override bool op_LessThanOrEqual(AmountOfSubstance left, AmountOfSubstance right);
    public static override bool op_GreaterThanOrEqual(AmountOfSubstance left, AmountOfSubstance right);
    public static override bool op_LessThan(AmountOfSubstance left, AmountOfSubstance right);
    public static override bool op_GreaterThan(AmountOfSubstance left, AmountOfSubstance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(AmountOfSubstance other, AmountOfSubstance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(AmountOfSubstance left, AmountOfSubstance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(AmountOfSubstance other, AmountOfSubstance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(AmountOfSubstance left, AmountOfSubstance right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(AmountOfSubstance other, AmountOfSubstance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(AmountOfSubstance other, AmountOfSubstance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(AmountOfSubstance other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(AmountOfSubstance other);
    [ObsoleteAttribute("Use Equals(AmountOfSubstance other, AmountOfSubstance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(AmountOfSubstance other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(AmountOfSubstance other, AmountOfSubstance tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(AmountOfSubstanceUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public AmountOfSubstance ToUnit(AmountOfSubstanceUnit unit);
    public AmountOfSubstance ToUnit(AmountOfSubstanceUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(AmountOfSubstanceUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public AmountOfSubstance ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<AmountOfSubstanceUnit> UnitsNet.IQuantity<UnitsNet.Units.AmountOfSubstanceUnit>.ToUnit(AmountOfSubstanceUnit unit);
    private sealed virtual override IQuantity`1<AmountOfSubstanceUnit> UnitsNet.IQuantity<UnitsNet.Units.AmountOfSubstanceUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.AmplitudeRatio : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<AmplitudeRatioUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<AmplitudeRatioUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmplitudeRatioUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmplitudeRatioUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static AmplitudeRatio <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<AmplitudeRatioUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static AmplitudeRatioUnit BaseUnit { get; }
    public static AmplitudeRatioUnit[] Units { get; }
    public static AmplitudeRatio Zero { get; }
    public static AmplitudeRatio AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public AmplitudeRatioUnit Unit { get; }
    public QuantityInfo`1<AmplitudeRatioUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double DecibelMicrovolts { get; }
    public double DecibelMillivolts { get; }
    public double DecibelsUnloaded { get; }
    public double DecibelVolts { get; }
    public AmplitudeRatio(ElectricPotential voltage);
    private static AmplitudeRatio();
    public AmplitudeRatio(double value, AmplitudeRatioUnit unit);
    public AmplitudeRatio(double value, UnitSystem unitSystem);
    public ElectricPotential ToElectricPotential();
    public PowerRatio ToPowerRatio(ElectricResistance impedance);
    public static AmplitudeRatio FromElectricPotential(ElectricPotential voltage);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<AmplitudeRatioUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static AmplitudeRatioUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static AmplitudeRatioUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override AmplitudeRatio get_Zero();
    public static override AmplitudeRatio get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual AmplitudeRatioUnit get_Unit();
    public sealed virtual QuantityInfo`1<AmplitudeRatioUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_DecibelMicrovolts();
    public double get_DecibelMillivolts();
    public double get_DecibelsUnloaded();
    public double get_DecibelVolts();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(AmplitudeRatioUnit unit);
    public static string GetAbbreviation(AmplitudeRatioUnit unit, IFormatProvider provider);
    public static AmplitudeRatio FromDecibelMicrovolts(double value);
    public static AmplitudeRatio FromDecibelMillivolts(double value);
    public static AmplitudeRatio FromDecibelsUnloaded(double value);
    public static AmplitudeRatio FromDecibelVolts(double value);
    public static AmplitudeRatio From(double value, AmplitudeRatioUnit fromUnit);
    public static AmplitudeRatio Parse(string str);
    public static override AmplitudeRatio Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, AmplitudeRatio& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, AmplitudeRatio& result);
    public static AmplitudeRatioUnit ParseUnit(string str);
    public static AmplitudeRatioUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, AmplitudeRatioUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, AmplitudeRatioUnit& unit);
    public static override AmplitudeRatio op_UnaryNegation(AmplitudeRatio right);
    public static override AmplitudeRatio op_Addition(AmplitudeRatio left, AmplitudeRatio right);
    public static override AmplitudeRatio op_Subtraction(AmplitudeRatio left, AmplitudeRatio right);
    public static AmplitudeRatio op_Multiply(double left, AmplitudeRatio right);
    public static override AmplitudeRatio op_Multiply(AmplitudeRatio left, double right);
    public static override AmplitudeRatio op_Division(AmplitudeRatio left, double right);
    public static double op_Division(AmplitudeRatio left, AmplitudeRatio right);
    public static override bool op_LessThanOrEqual(AmplitudeRatio left, AmplitudeRatio right);
    public static override bool op_GreaterThanOrEqual(AmplitudeRatio left, AmplitudeRatio right);
    public static override bool op_LessThan(AmplitudeRatio left, AmplitudeRatio right);
    public static override bool op_GreaterThan(AmplitudeRatio left, AmplitudeRatio right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(AmplitudeRatio other, AmplitudeRatio tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(AmplitudeRatio left, AmplitudeRatio right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(AmplitudeRatio other, AmplitudeRatio tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(AmplitudeRatio left, AmplitudeRatio right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(AmplitudeRatio other, AmplitudeRatio tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(AmplitudeRatio other, AmplitudeRatio tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(AmplitudeRatio other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(AmplitudeRatio other);
    [ObsoleteAttribute("Use Equals(AmplitudeRatio other, AmplitudeRatio tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(AmplitudeRatio other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(AmplitudeRatio other, AmplitudeRatio tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(AmplitudeRatioUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public AmplitudeRatio ToUnit(AmplitudeRatioUnit unit);
    public AmplitudeRatio ToUnit(AmplitudeRatioUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(AmplitudeRatioUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public AmplitudeRatio ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<AmplitudeRatioUnit> UnitsNet.IQuantity<UnitsNet.Units.AmplitudeRatioUnit>.ToUnit(AmplitudeRatioUnit unit);
    private sealed virtual override IQuantity`1<AmplitudeRatioUnit> UnitsNet.IQuantity<UnitsNet.Units.AmplitudeRatioUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Angle : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<AngleUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<AngleUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static AngleUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static AngleUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Angle <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<AngleUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static AngleUnit BaseUnit { get; }
    public static AngleUnit[] Units { get; }
    public static Angle Zero { get; }
    public static Angle AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public AngleUnit Unit { get; }
    public QuantityInfo`1<AngleUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Arcminutes { get; }
    public double Arcseconds { get; }
    public double Centiradians { get; }
    public double Deciradians { get; }
    public double Degrees { get; }
    public double Gradians { get; }
    public double Microdegrees { get; }
    public double Microradians { get; }
    public double Millidegrees { get; }
    public double Milliradians { get; }
    public double Nanodegrees { get; }
    public double Nanoradians { get; }
    public double NatoMils { get; }
    public double Radians { get; }
    public double Revolutions { get; }
    public double Tilt { get; }
    private static Angle();
    public Angle(double value, AngleUnit unit);
    public Angle(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<AngleUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static AngleUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static AngleUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Angle get_Zero();
    public static override Angle get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual AngleUnit get_Unit();
    public sealed virtual QuantityInfo`1<AngleUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Arcminutes();
    public double get_Arcseconds();
    public double get_Centiradians();
    public double get_Deciradians();
    public double get_Degrees();
    public double get_Gradians();
    public double get_Microdegrees();
    public double get_Microradians();
    public double get_Millidegrees();
    public double get_Milliradians();
    public double get_Nanodegrees();
    public double get_Nanoradians();
    public double get_NatoMils();
    public double get_Radians();
    public double get_Revolutions();
    public double get_Tilt();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(AngleUnit unit);
    public static string GetAbbreviation(AngleUnit unit, IFormatProvider provider);
    public static Angle FromArcminutes(double value);
    public static Angle FromArcseconds(double value);
    public static Angle FromCentiradians(double value);
    public static Angle FromDeciradians(double value);
    public static Angle FromDegrees(double value);
    public static Angle FromGradians(double value);
    public static Angle FromMicrodegrees(double value);
    public static Angle FromMicroradians(double value);
    public static Angle FromMillidegrees(double value);
    public static Angle FromMilliradians(double value);
    public static Angle FromNanodegrees(double value);
    public static Angle FromNanoradians(double value);
    public static Angle FromNatoMils(double value);
    public static Angle FromRadians(double value);
    public static Angle FromRevolutions(double value);
    public static Angle FromTilt(double value);
    public static Angle From(double value, AngleUnit fromUnit);
    public static Angle Parse(string str);
    public static override Angle Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Angle& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Angle& result);
    public static AngleUnit ParseUnit(string str);
    public static AngleUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, AngleUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, AngleUnit& unit);
    public static override Angle op_UnaryNegation(Angle right);
    public static override Angle op_Addition(Angle left, Angle right);
    public static override Angle op_Subtraction(Angle left, Angle right);
    public static Angle op_Multiply(double left, Angle right);
    public static override Angle op_Multiply(Angle left, double right);
    public static override Angle op_Division(Angle left, double right);
    public static double op_Division(Angle left, Angle right);
    public static override Duration op_Division(Angle angle, RotationalSpeed rotationalSpeed);
    public static override RotationalSpeed op_Division(Angle angle, Duration duration);
    public static override Torque op_Multiply(Angle angle, RotationalStiffness rotationalStiffness);
    public static override bool op_LessThanOrEqual(Angle left, Angle right);
    public static override bool op_GreaterThanOrEqual(Angle left, Angle right);
    public static override bool op_LessThan(Angle left, Angle right);
    public static override bool op_GreaterThan(Angle left, Angle right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Angle other, Angle tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Angle left, Angle right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Angle other, Angle tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Angle left, Angle right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Angle other, Angle tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Angle other, Angle tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Angle other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Angle other);
    [ObsoleteAttribute("Use Equals(Angle other, Angle tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Angle other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Angle other, Angle tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(AngleUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Angle ToUnit(AngleUnit unit);
    public Angle ToUnit(AngleUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(AngleUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Angle ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<AngleUnit> UnitsNet.IQuantity<UnitsNet.Units.AngleUnit>.ToUnit(AngleUnit unit);
    private sealed virtual override IQuantity`1<AngleUnit> UnitsNet.IQuantity<UnitsNet.Units.AngleUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ApparentEnergy : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ApparentEnergyUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ApparentEnergyUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ApparentEnergyUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ApparentEnergyUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ApparentEnergy <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ApparentEnergyUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ApparentEnergyUnit BaseUnit { get; }
    public static ApparentEnergyUnit[] Units { get; }
    public static ApparentEnergy Zero { get; }
    public static ApparentEnergy AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ApparentEnergyUnit Unit { get; }
    public QuantityInfo`1<ApparentEnergyUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double KilovoltampereHours { get; }
    public double MegavoltampereHours { get; }
    public double VoltampereHours { get; }
    private static ApparentEnergy();
    public ApparentEnergy(double value, ApparentEnergyUnit unit);
    public ApparentEnergy(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ApparentEnergyUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ApparentEnergyUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ApparentEnergyUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ApparentEnergy get_Zero();
    public static override ApparentEnergy get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ApparentEnergyUnit get_Unit();
    public sealed virtual QuantityInfo`1<ApparentEnergyUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_KilovoltampereHours();
    public double get_MegavoltampereHours();
    public double get_VoltampereHours();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ApparentEnergyUnit unit);
    public static string GetAbbreviation(ApparentEnergyUnit unit, IFormatProvider provider);
    public static ApparentEnergy FromKilovoltampereHours(double value);
    public static ApparentEnergy FromMegavoltampereHours(double value);
    public static ApparentEnergy FromVoltampereHours(double value);
    public static ApparentEnergy From(double value, ApparentEnergyUnit fromUnit);
    public static ApparentEnergy Parse(string str);
    public static override ApparentEnergy Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ApparentEnergy& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ApparentEnergy& result);
    public static ApparentEnergyUnit ParseUnit(string str);
    public static ApparentEnergyUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ApparentEnergyUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ApparentEnergyUnit& unit);
    public static override ApparentEnergy op_UnaryNegation(ApparentEnergy right);
    public static override ApparentEnergy op_Addition(ApparentEnergy left, ApparentEnergy right);
    public static override ApparentEnergy op_Subtraction(ApparentEnergy left, ApparentEnergy right);
    public static ApparentEnergy op_Multiply(double left, ApparentEnergy right);
    public static override ApparentEnergy op_Multiply(ApparentEnergy left, double right);
    public static override ApparentEnergy op_Division(ApparentEnergy left, double right);
    public static double op_Division(ApparentEnergy left, ApparentEnergy right);
    public static override bool op_LessThanOrEqual(ApparentEnergy left, ApparentEnergy right);
    public static override bool op_GreaterThanOrEqual(ApparentEnergy left, ApparentEnergy right);
    public static override bool op_LessThan(ApparentEnergy left, ApparentEnergy right);
    public static override bool op_GreaterThan(ApparentEnergy left, ApparentEnergy right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ApparentEnergy other, ApparentEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ApparentEnergy left, ApparentEnergy right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ApparentEnergy other, ApparentEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ApparentEnergy left, ApparentEnergy right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ApparentEnergy other, ApparentEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ApparentEnergy other, ApparentEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ApparentEnergy other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ApparentEnergy other);
    [ObsoleteAttribute("Use Equals(ApparentEnergy other, ApparentEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ApparentEnergy other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ApparentEnergy other, ApparentEnergy tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ApparentEnergyUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ApparentEnergy ToUnit(ApparentEnergyUnit unit);
    public ApparentEnergy ToUnit(ApparentEnergyUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ApparentEnergyUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ApparentEnergy ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ApparentEnergyUnit> UnitsNet.IQuantity<UnitsNet.Units.ApparentEnergyUnit>.ToUnit(ApparentEnergyUnit unit);
    private sealed virtual override IQuantity`1<ApparentEnergyUnit> UnitsNet.IQuantity<UnitsNet.Units.ApparentEnergyUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ApparentPower : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ApparentPowerUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ApparentPowerUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ApparentPowerUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ApparentPowerUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ApparentPower <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ApparentPowerUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ApparentPowerUnit BaseUnit { get; }
    public static ApparentPowerUnit[] Units { get; }
    public static ApparentPower Zero { get; }
    public static ApparentPower AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ApparentPowerUnit Unit { get; }
    public QuantityInfo`1<ApparentPowerUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Gigavoltamperes { get; }
    public double Kilovoltamperes { get; }
    public double Megavoltamperes { get; }
    public double Microvoltamperes { get; }
    public double Millivoltamperes { get; }
    public double Voltamperes { get; }
    private static ApparentPower();
    public ApparentPower(double value, ApparentPowerUnit unit);
    public ApparentPower(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ApparentPowerUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ApparentPowerUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ApparentPowerUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ApparentPower get_Zero();
    public static override ApparentPower get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ApparentPowerUnit get_Unit();
    public sealed virtual QuantityInfo`1<ApparentPowerUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Gigavoltamperes();
    public double get_Kilovoltamperes();
    public double get_Megavoltamperes();
    public double get_Microvoltamperes();
    public double get_Millivoltamperes();
    public double get_Voltamperes();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ApparentPowerUnit unit);
    public static string GetAbbreviation(ApparentPowerUnit unit, IFormatProvider provider);
    public static ApparentPower FromGigavoltamperes(double value);
    public static ApparentPower FromKilovoltamperes(double value);
    public static ApparentPower FromMegavoltamperes(double value);
    public static ApparentPower FromMicrovoltamperes(double value);
    public static ApparentPower FromMillivoltamperes(double value);
    public static ApparentPower FromVoltamperes(double value);
    public static ApparentPower From(double value, ApparentPowerUnit fromUnit);
    public static ApparentPower Parse(string str);
    public static override ApparentPower Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ApparentPower& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ApparentPower& result);
    public static ApparentPowerUnit ParseUnit(string str);
    public static ApparentPowerUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ApparentPowerUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ApparentPowerUnit& unit);
    public static override ApparentPower op_UnaryNegation(ApparentPower right);
    public static override ApparentPower op_Addition(ApparentPower left, ApparentPower right);
    public static override ApparentPower op_Subtraction(ApparentPower left, ApparentPower right);
    public static ApparentPower op_Multiply(double left, ApparentPower right);
    public static override ApparentPower op_Multiply(ApparentPower left, double right);
    public static override ApparentPower op_Division(ApparentPower left, double right);
    public static double op_Division(ApparentPower left, ApparentPower right);
    public static override bool op_LessThanOrEqual(ApparentPower left, ApparentPower right);
    public static override bool op_GreaterThanOrEqual(ApparentPower left, ApparentPower right);
    public static override bool op_LessThan(ApparentPower left, ApparentPower right);
    public static override bool op_GreaterThan(ApparentPower left, ApparentPower right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ApparentPower other, ApparentPower tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ApparentPower left, ApparentPower right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ApparentPower other, ApparentPower tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ApparentPower left, ApparentPower right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ApparentPower other, ApparentPower tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ApparentPower other, ApparentPower tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ApparentPower other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ApparentPower other);
    [ObsoleteAttribute("Use Equals(ApparentPower other, ApparentPower tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ApparentPower other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ApparentPower other, ApparentPower tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ApparentPowerUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ApparentPower ToUnit(ApparentPowerUnit unit);
    public ApparentPower ToUnit(ApparentPowerUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ApparentPowerUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ApparentPower ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ApparentPowerUnit> UnitsNet.IQuantity<UnitsNet.Units.ApparentPowerUnit>.ToUnit(ApparentPowerUnit unit);
    private sealed virtual override IQuantity`1<ApparentPowerUnit> UnitsNet.IQuantity<UnitsNet.Units.ApparentPowerUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Area : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<AreaUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<AreaUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static AreaUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static AreaUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Area <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<AreaUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static AreaUnit BaseUnit { get; }
    public static AreaUnit[] Units { get; }
    public static Area Zero { get; }
    public static Area AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public AreaUnit Unit { get; }
    public QuantityInfo`1<AreaUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Acres { get; }
    public double Hectares { get; }
    public double SquareCentimeters { get; }
    public double SquareDecimeters { get; }
    public double SquareFeet { get; }
    public double SquareInches { get; }
    public double SquareKilometers { get; }
    public double SquareMeters { get; }
    public double SquareMicrometers { get; }
    public double SquareMiles { get; }
    public double SquareMillimeters { get; }
    public double SquareNauticalMiles { get; }
    public double SquareYards { get; }
    public double UsSurveySquareFeet { get; }
    private static Area();
    public Area(double value, AreaUnit unit);
    public Area(double value, UnitSystem unitSystem);
    public static Area FromCircleDiameter(Length diameter);
    public static Area FromCircleRadius(Length radius);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<AreaUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static AreaUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static AreaUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Area get_Zero();
    public static override Area get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual AreaUnit get_Unit();
    public sealed virtual QuantityInfo`1<AreaUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Acres();
    public double get_Hectares();
    public double get_SquareCentimeters();
    public double get_SquareDecimeters();
    public double get_SquareFeet();
    public double get_SquareInches();
    public double get_SquareKilometers();
    public double get_SquareMeters();
    public double get_SquareMicrometers();
    public double get_SquareMiles();
    public double get_SquareMillimeters();
    public double get_SquareNauticalMiles();
    public double get_SquareYards();
    public double get_UsSurveySquareFeet();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(AreaUnit unit);
    public static string GetAbbreviation(AreaUnit unit, IFormatProvider provider);
    public static Area FromAcres(double value);
    public static Area FromHectares(double value);
    public static Area FromSquareCentimeters(double value);
    public static Area FromSquareDecimeters(double value);
    public static Area FromSquareFeet(double value);
    public static Area FromSquareInches(double value);
    public static Area FromSquareKilometers(double value);
    public static Area FromSquareMeters(double value);
    public static Area FromSquareMicrometers(double value);
    public static Area FromSquareMiles(double value);
    public static Area FromSquareMillimeters(double value);
    public static Area FromSquareNauticalMiles(double value);
    public static Area FromSquareYards(double value);
    public static Area FromUsSurveySquareFeet(double value);
    public static Area From(double value, AreaUnit fromUnit);
    public static Area Parse(string str);
    public static override Area Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Area& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Area& result);
    public static AreaUnit ParseUnit(string str);
    public static AreaUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, AreaUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, AreaUnit& unit);
    public static override Area op_UnaryNegation(Area right);
    public static override Area op_Addition(Area left, Area right);
    public static override Area op_Subtraction(Area left, Area right);
    public static Area op_Multiply(double left, Area right);
    public static override Area op_Multiply(Area left, double right);
    public static override Area op_Division(Area left, double right);
    public static double op_Division(Area left, Area right);
    public ReciprocalArea Inverse();
    public static override Duration op_Division(Area area, KinematicViscosity kinematicViscosity);
    public static override Force op_Multiply(Area area, Pressure pressure);
    public static override ForcePerLength op_Multiply(Area area, SpecificWeight specificWeight);
    public static override KinematicViscosity op_Division(Area area, Duration duration);
    public static override Length op_Multiply(Area area, ReciprocalLength reciprocalLength);
    public static override Length op_Division(Area area, Length length);
    public static override LinearDensity op_Multiply(Area area, Density density);
    public static override LuminousIntensity op_Multiply(Area area, Luminance luminance);
    public static override Mass op_Multiply(Area area, AreaDensity areaDensity);
    public static override MassFlow op_Multiply(Area area, MassFlux massFlux);
    public static override Power op_Multiply(Area area, HeatFlux heatFlux);
    public static override Ratio op_Multiply(Area area, ReciprocalArea reciprocalArea);
    public static override ReciprocalLength op_Division(Area area, Volume volume);
    public static override Torque op_Multiply(Area area, ForcePerLength forcePerLength);
    public static override Volume op_Multiply(Area area, Length length);
    public static override Volume op_Division(Area area, ReciprocalLength reciprocalLength);
    public static override VolumeFlow op_Multiply(Area area, Speed speed);
    public static override bool op_LessThanOrEqual(Area left, Area right);
    public static override bool op_GreaterThanOrEqual(Area left, Area right);
    public static override bool op_LessThan(Area left, Area right);
    public static override bool op_GreaterThan(Area left, Area right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Area other, Area tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Area left, Area right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Area other, Area tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Area left, Area right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Area other, Area tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Area other, Area tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Area other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Area other);
    [ObsoleteAttribute("Use Equals(Area other, Area tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Area other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Area other, Area tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(AreaUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Area ToUnit(AreaUnit unit);
    public Area ToUnit(AreaUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(AreaUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Area ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<AreaUnit> UnitsNet.IQuantity<UnitsNet.Units.AreaUnit>.ToUnit(AreaUnit unit);
    private sealed virtual override IQuantity`1<AreaUnit> UnitsNet.IQuantity<UnitsNet.Units.AreaUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.AreaDensity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<AreaDensityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<AreaDensityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static AreaDensityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static AreaDensityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static AreaDensity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<AreaDensityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static AreaDensityUnit BaseUnit { get; }
    public static AreaDensityUnit[] Units { get; }
    public static AreaDensity Zero { get; }
    public static AreaDensity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public AreaDensityUnit Unit { get; }
    public QuantityInfo`1<AreaDensityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double GramsPerSquareMeter { get; }
    public double KilogramsPerSquareMeter { get; }
    public double MilligramsPerSquareMeter { get; }
    private static AreaDensity();
    public AreaDensity(double value, AreaDensityUnit unit);
    public AreaDensity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<AreaDensityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static AreaDensityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static AreaDensityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override AreaDensity get_Zero();
    public static override AreaDensity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual AreaDensityUnit get_Unit();
    public sealed virtual QuantityInfo`1<AreaDensityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_GramsPerSquareMeter();
    public double get_KilogramsPerSquareMeter();
    public double get_MilligramsPerSquareMeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(AreaDensityUnit unit);
    public static string GetAbbreviation(AreaDensityUnit unit, IFormatProvider provider);
    public static AreaDensity FromGramsPerSquareMeter(double value);
    public static AreaDensity FromKilogramsPerSquareMeter(double value);
    public static AreaDensity FromMilligramsPerSquareMeter(double value);
    public static AreaDensity From(double value, AreaDensityUnit fromUnit);
    public static AreaDensity Parse(string str);
    public static override AreaDensity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, AreaDensity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, AreaDensity& result);
    public static AreaDensityUnit ParseUnit(string str);
    public static AreaDensityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, AreaDensityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, AreaDensityUnit& unit);
    public static override AreaDensity op_UnaryNegation(AreaDensity right);
    public static override AreaDensity op_Addition(AreaDensity left, AreaDensity right);
    public static override AreaDensity op_Subtraction(AreaDensity left, AreaDensity right);
    public static AreaDensity op_Multiply(double left, AreaDensity right);
    public static override AreaDensity op_Multiply(AreaDensity left, double right);
    public static override AreaDensity op_Division(AreaDensity left, double right);
    public static double op_Division(AreaDensity left, AreaDensity right);
    public static override Mass op_Multiply(AreaDensity areaDensity, Area area);
    public static override bool op_LessThanOrEqual(AreaDensity left, AreaDensity right);
    public static override bool op_GreaterThanOrEqual(AreaDensity left, AreaDensity right);
    public static override bool op_LessThan(AreaDensity left, AreaDensity right);
    public static override bool op_GreaterThan(AreaDensity left, AreaDensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(AreaDensity other, AreaDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(AreaDensity left, AreaDensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(AreaDensity other, AreaDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(AreaDensity left, AreaDensity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(AreaDensity other, AreaDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(AreaDensity other, AreaDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(AreaDensity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(AreaDensity other);
    [ObsoleteAttribute("Use Equals(AreaDensity other, AreaDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(AreaDensity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(AreaDensity other, AreaDensity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(AreaDensityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public AreaDensity ToUnit(AreaDensityUnit unit);
    public AreaDensity ToUnit(AreaDensityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(AreaDensityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public AreaDensity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<AreaDensityUnit> UnitsNet.IQuantity<UnitsNet.Units.AreaDensityUnit>.ToUnit(AreaDensityUnit unit);
    private sealed virtual override IQuantity`1<AreaDensityUnit> UnitsNet.IQuantity<UnitsNet.Units.AreaDensityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.AreaMomentOfInertia : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<AreaMomentOfInertiaUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<AreaMomentOfInertiaUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static AreaMomentOfInertiaUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static AreaMomentOfInertiaUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static AreaMomentOfInertia <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<AreaMomentOfInertiaUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static AreaMomentOfInertiaUnit BaseUnit { get; }
    public static AreaMomentOfInertiaUnit[] Units { get; }
    public static AreaMomentOfInertia Zero { get; }
    public static AreaMomentOfInertia AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public AreaMomentOfInertiaUnit Unit { get; }
    public QuantityInfo`1<AreaMomentOfInertiaUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentimetersToTheFourth { get; }
    public double DecimetersToTheFourth { get; }
    public double FeetToTheFourth { get; }
    public double InchesToTheFourth { get; }
    public double MetersToTheFourth { get; }
    public double MillimetersToTheFourth { get; }
    private static AreaMomentOfInertia();
    public AreaMomentOfInertia(double value, AreaMomentOfInertiaUnit unit);
    public AreaMomentOfInertia(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<AreaMomentOfInertiaUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static AreaMomentOfInertiaUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static AreaMomentOfInertiaUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override AreaMomentOfInertia get_Zero();
    public static override AreaMomentOfInertia get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual AreaMomentOfInertiaUnit get_Unit();
    public sealed virtual QuantityInfo`1<AreaMomentOfInertiaUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentimetersToTheFourth();
    public double get_DecimetersToTheFourth();
    public double get_FeetToTheFourth();
    public double get_InchesToTheFourth();
    public double get_MetersToTheFourth();
    public double get_MillimetersToTheFourth();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(AreaMomentOfInertiaUnit unit);
    public static string GetAbbreviation(AreaMomentOfInertiaUnit unit, IFormatProvider provider);
    public static AreaMomentOfInertia FromCentimetersToTheFourth(double value);
    public static AreaMomentOfInertia FromDecimetersToTheFourth(double value);
    public static AreaMomentOfInertia FromFeetToTheFourth(double value);
    public static AreaMomentOfInertia FromInchesToTheFourth(double value);
    public static AreaMomentOfInertia FromMetersToTheFourth(double value);
    public static AreaMomentOfInertia FromMillimetersToTheFourth(double value);
    public static AreaMomentOfInertia From(double value, AreaMomentOfInertiaUnit fromUnit);
    public static AreaMomentOfInertia Parse(string str);
    public static override AreaMomentOfInertia Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, AreaMomentOfInertia& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, AreaMomentOfInertia& result);
    public static AreaMomentOfInertiaUnit ParseUnit(string str);
    public static AreaMomentOfInertiaUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, AreaMomentOfInertiaUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, AreaMomentOfInertiaUnit& unit);
    public static override AreaMomentOfInertia op_UnaryNegation(AreaMomentOfInertia right);
    public static override AreaMomentOfInertia op_Addition(AreaMomentOfInertia left, AreaMomentOfInertia right);
    public static override AreaMomentOfInertia op_Subtraction(AreaMomentOfInertia left, AreaMomentOfInertia right);
    public static AreaMomentOfInertia op_Multiply(double left, AreaMomentOfInertia right);
    public static override AreaMomentOfInertia op_Multiply(AreaMomentOfInertia left, double right);
    public static override AreaMomentOfInertia op_Division(AreaMomentOfInertia left, double right);
    public static double op_Division(AreaMomentOfInertia left, AreaMomentOfInertia right);
    public static override Length op_Division(AreaMomentOfInertia areaMomentOfInertia, Volume volume);
    public static override Volume op_Division(AreaMomentOfInertia areaMomentOfInertia, Length length);
    public static override bool op_LessThanOrEqual(AreaMomentOfInertia left, AreaMomentOfInertia right);
    public static override bool op_GreaterThanOrEqual(AreaMomentOfInertia left, AreaMomentOfInertia right);
    public static override bool op_LessThan(AreaMomentOfInertia left, AreaMomentOfInertia right);
    public static override bool op_GreaterThan(AreaMomentOfInertia left, AreaMomentOfInertia right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(AreaMomentOfInertia other, AreaMomentOfInertia tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(AreaMomentOfInertia left, AreaMomentOfInertia right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(AreaMomentOfInertia other, AreaMomentOfInertia tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(AreaMomentOfInertia left, AreaMomentOfInertia right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(AreaMomentOfInertia other, AreaMomentOfInertia tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(AreaMomentOfInertia other, AreaMomentOfInertia tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(AreaMomentOfInertia other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(AreaMomentOfInertia other);
    [ObsoleteAttribute("Use Equals(AreaMomentOfInertia other, AreaMomentOfInertia tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(AreaMomentOfInertia other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(AreaMomentOfInertia other, AreaMomentOfInertia tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(AreaMomentOfInertiaUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public AreaMomentOfInertia ToUnit(AreaMomentOfInertiaUnit unit);
    public AreaMomentOfInertia ToUnit(AreaMomentOfInertiaUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(AreaMomentOfInertiaUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public AreaMomentOfInertia ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<AreaMomentOfInertiaUnit> UnitsNet.IQuantity<UnitsNet.Units.AreaMomentOfInertiaUnit>.ToUnit(AreaMomentOfInertiaUnit unit);
    private sealed virtual override IQuantity`1<AreaMomentOfInertiaUnit> UnitsNet.IQuantity<UnitsNet.Units.AreaMomentOfInertiaUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.BaseDimensions : object {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Mass>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Temperature>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Amount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LuminousIntensity>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <Dimensionless>k__BackingField;
    public int Length { get; }
    public int Mass { get; }
    public int Time { get; }
    public int Current { get; }
    public int Temperature { get; }
    public int Amount { get; }
    public int LuminousIntensity { get; }
    public static BaseDimensions Dimensionless { get; }
    public BaseDimensions(int length, int mass, int time, int current, int temperature, int amount, int luminousIntensity);
    private static BaseDimensions();
    public bool IsBaseQuantity();
    public bool IsDerivedQuantity();
    public bool IsDimensionless();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public BaseDimensions Multiply(BaseDimensions right);
    public BaseDimensions Divide(BaseDimensions right);
    [NullableContextAttribute("2")]
public static bool op_Equality(BaseDimensions left, BaseDimensions right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(BaseDimensions left, BaseDimensions right);
    public static BaseDimensions op_Multiply(BaseDimensions left, BaseDimensions right);
    public static BaseDimensions op_Division(BaseDimensions left, BaseDimensions right);
    public virtual string ToString();
    private static void AppendDimensionString(StringBuilder sb, string name, int value);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public int get_Mass();
    [CompilerGeneratedAttribute]
public int get_Time();
    [CompilerGeneratedAttribute]
public int get_Current();
    [CompilerGeneratedAttribute]
public int get_Temperature();
    [CompilerGeneratedAttribute]
public int get_Amount();
    [CompilerGeneratedAttribute]
public int get_LuminousIntensity();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_Dimensionless();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.BaseUnits : object {
    [CompilerGeneratedAttribute]
private static BaseUnits <Undefined>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LengthUnit> <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<MassUnit> <Mass>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DurationUnit> <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ElectricCurrentUnit> <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TemperatureUnit> <Temperature>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<AmountOfSubstanceUnit> <Amount>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<LuminousIntensityUnit> <LuminousIntensity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFullyDefined>k__BackingField;
    public static BaseUnits Undefined { get; }
    public Nullable`1<LengthUnit> Length { get; }
    public Nullable`1<MassUnit> Mass { get; }
    public Nullable`1<DurationUnit> Time { get; }
    public Nullable`1<ElectricCurrentUnit> Current { get; }
    public Nullable`1<TemperatureUnit> Temperature { get; }
    public Nullable`1<AmountOfSubstanceUnit> Amount { get; }
    public Nullable`1<LuminousIntensityUnit> LuminousIntensity { get; }
    public bool IsFullyDefined { get; }
    public BaseUnits(Nullable`1<LengthUnit> length, Nullable`1<MassUnit> mass, Nullable`1<DurationUnit> time, Nullable`1<ElectricCurrentUnit> current, Nullable`1<TemperatureUnit> temperature, Nullable`1<AmountOfSubstanceUnit> amount, Nullable`1<LuminousIntensityUnit> luminousIntensity);
    private static BaseUnits();
    [CompilerGeneratedAttribute]
public static BaseUnits get_Undefined();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(BaseUnits other);
    public bool IsSubsetOf(BaseUnits other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(BaseUnits left, BaseUnits right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(BaseUnits left, BaseUnits right);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public Nullable`1<LengthUnit> get_Length();
    [CompilerGeneratedAttribute]
public Nullable`1<MassUnit> get_Mass();
    [CompilerGeneratedAttribute]
public Nullable`1<DurationUnit> get_Time();
    [CompilerGeneratedAttribute]
public Nullable`1<ElectricCurrentUnit> get_Current();
    [CompilerGeneratedAttribute]
public Nullable`1<TemperatureUnit> get_Temperature();
    [CompilerGeneratedAttribute]
public Nullable`1<AmountOfSubstanceUnit> get_Amount();
    [CompilerGeneratedAttribute]
public Nullable`1<LuminousIntensityUnit> get_LuminousIntensity();
    [CompilerGeneratedAttribute]
public bool get_IsFullyDefined();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static string <ToString>g__GetDefaultAbbreviation|10_0(Nullable`1<TUnitType> unitOrNull);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.BitRate : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<BitRateUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<BitRateUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static BitRateUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static BitRateUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static BitRate <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<BitRateUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static BitRateUnit BaseUnit { get; }
    public static BitRateUnit[] Units { get; }
    public static BitRate Zero { get; }
    public static BitRate AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public BitRateUnit Unit { get; }
    public QuantityInfo`1<BitRateUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double BitsPerSecond { get; }
    public double BytesPerSecond { get; }
    public double ExabitsPerSecond { get; }
    public double ExabytesPerSecond { get; }
    public double ExbibitsPerSecond { get; }
    public double ExbibytesPerSecond { get; }
    public double GibibitsPerSecond { get; }
    public double GibibytesPerSecond { get; }
    public double GigabitsPerSecond { get; }
    public double GigabytesPerSecond { get; }
    public double KibibitsPerSecond { get; }
    public double KibibytesPerSecond { get; }
    public double KilobitsPerSecond { get; }
    public double KilobytesPerSecond { get; }
    public double MebibitsPerSecond { get; }
    public double MebibytesPerSecond { get; }
    public double MegabitsPerSecond { get; }
    public double MegabytesPerSecond { get; }
    public double PebibitsPerSecond { get; }
    public double PebibytesPerSecond { get; }
    public double PetabitsPerSecond { get; }
    public double PetabytesPerSecond { get; }
    public double TebibitsPerSecond { get; }
    public double TebibytesPerSecond { get; }
    public double TerabitsPerSecond { get; }
    public double TerabytesPerSecond { get; }
    private static BitRate();
    public BitRate(double value, BitRateUnit unit);
    public BitRate(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<BitRateUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static BitRateUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static BitRateUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override BitRate get_Zero();
    public static override BitRate get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual BitRateUnit get_Unit();
    public sealed virtual QuantityInfo`1<BitRateUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_BitsPerSecond();
    public double get_BytesPerSecond();
    public double get_ExabitsPerSecond();
    public double get_ExabytesPerSecond();
    public double get_ExbibitsPerSecond();
    public double get_ExbibytesPerSecond();
    public double get_GibibitsPerSecond();
    public double get_GibibytesPerSecond();
    public double get_GigabitsPerSecond();
    public double get_GigabytesPerSecond();
    public double get_KibibitsPerSecond();
    public double get_KibibytesPerSecond();
    public double get_KilobitsPerSecond();
    public double get_KilobytesPerSecond();
    public double get_MebibitsPerSecond();
    public double get_MebibytesPerSecond();
    public double get_MegabitsPerSecond();
    public double get_MegabytesPerSecond();
    public double get_PebibitsPerSecond();
    public double get_PebibytesPerSecond();
    public double get_PetabitsPerSecond();
    public double get_PetabytesPerSecond();
    public double get_TebibitsPerSecond();
    public double get_TebibytesPerSecond();
    public double get_TerabitsPerSecond();
    public double get_TerabytesPerSecond();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(BitRateUnit unit);
    public static string GetAbbreviation(BitRateUnit unit, IFormatProvider provider);
    public static BitRate FromBitsPerSecond(double value);
    public static BitRate FromBytesPerSecond(double value);
    public static BitRate FromExabitsPerSecond(double value);
    public static BitRate FromExabytesPerSecond(double value);
    public static BitRate FromExbibitsPerSecond(double value);
    public static BitRate FromExbibytesPerSecond(double value);
    public static BitRate FromGibibitsPerSecond(double value);
    public static BitRate FromGibibytesPerSecond(double value);
    public static BitRate FromGigabitsPerSecond(double value);
    public static BitRate FromGigabytesPerSecond(double value);
    public static BitRate FromKibibitsPerSecond(double value);
    public static BitRate FromKibibytesPerSecond(double value);
    public static BitRate FromKilobitsPerSecond(double value);
    public static BitRate FromKilobytesPerSecond(double value);
    public static BitRate FromMebibitsPerSecond(double value);
    public static BitRate FromMebibytesPerSecond(double value);
    public static BitRate FromMegabitsPerSecond(double value);
    public static BitRate FromMegabytesPerSecond(double value);
    public static BitRate FromPebibitsPerSecond(double value);
    public static BitRate FromPebibytesPerSecond(double value);
    public static BitRate FromPetabitsPerSecond(double value);
    public static BitRate FromPetabytesPerSecond(double value);
    public static BitRate FromTebibitsPerSecond(double value);
    public static BitRate FromTebibytesPerSecond(double value);
    public static BitRate FromTerabitsPerSecond(double value);
    public static BitRate FromTerabytesPerSecond(double value);
    public static BitRate From(double value, BitRateUnit fromUnit);
    public static BitRate Parse(string str);
    public static override BitRate Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, BitRate& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, BitRate& result);
    public static BitRateUnit ParseUnit(string str);
    public static BitRateUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, BitRateUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, BitRateUnit& unit);
    public static override BitRate op_UnaryNegation(BitRate right);
    public static override BitRate op_Addition(BitRate left, BitRate right);
    public static override BitRate op_Subtraction(BitRate left, BitRate right);
    public static BitRate op_Multiply(double left, BitRate right);
    public static override BitRate op_Multiply(BitRate left, double right);
    public static override BitRate op_Division(BitRate left, double right);
    public static double op_Division(BitRate left, BitRate right);
    public static override bool op_LessThanOrEqual(BitRate left, BitRate right);
    public static override bool op_GreaterThanOrEqual(BitRate left, BitRate right);
    public static override bool op_LessThan(BitRate left, BitRate right);
    public static override bool op_GreaterThan(BitRate left, BitRate right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(BitRate other, BitRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(BitRate left, BitRate right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(BitRate other, BitRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(BitRate left, BitRate right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(BitRate other, BitRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(BitRate other, BitRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(BitRate other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(BitRate other);
    [ObsoleteAttribute("Use Equals(BitRate other, BitRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(BitRate other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(BitRate other, BitRate tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(BitRateUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public BitRate ToUnit(BitRateUnit unit);
    public BitRate ToUnit(BitRateUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(BitRateUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public BitRate ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<BitRateUnit> UnitsNet.IQuantity<UnitsNet.Units.BitRateUnit>.ToUnit(BitRateUnit unit);
    private sealed virtual override IQuantity`1<BitRateUnit> UnitsNet.IQuantity<UnitsNet.Units.BitRateUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.BrakeSpecificFuelConsumption : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<BrakeSpecificFuelConsumptionUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<BrakeSpecificFuelConsumptionUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static BrakeSpecificFuelConsumptionUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static BrakeSpecificFuelConsumptionUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static BrakeSpecificFuelConsumption <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<BrakeSpecificFuelConsumptionUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static BrakeSpecificFuelConsumptionUnit BaseUnit { get; }
    public static BrakeSpecificFuelConsumptionUnit[] Units { get; }
    public static BrakeSpecificFuelConsumption Zero { get; }
    public static BrakeSpecificFuelConsumption AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public BrakeSpecificFuelConsumptionUnit Unit { get; }
    public QuantityInfo`1<BrakeSpecificFuelConsumptionUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double GramsPerKiloWattHour { get; }
    public double KilogramsPerJoule { get; }
    public double PoundsPerMechanicalHorsepowerHour { get; }
    private static BrakeSpecificFuelConsumption();
    public BrakeSpecificFuelConsumption(double value, BrakeSpecificFuelConsumptionUnit unit);
    public BrakeSpecificFuelConsumption(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<BrakeSpecificFuelConsumptionUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static BrakeSpecificFuelConsumptionUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static BrakeSpecificFuelConsumptionUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override BrakeSpecificFuelConsumption get_Zero();
    public static override BrakeSpecificFuelConsumption get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual BrakeSpecificFuelConsumptionUnit get_Unit();
    public sealed virtual QuantityInfo`1<BrakeSpecificFuelConsumptionUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_GramsPerKiloWattHour();
    public double get_KilogramsPerJoule();
    public double get_PoundsPerMechanicalHorsepowerHour();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(BrakeSpecificFuelConsumptionUnit unit);
    public static string GetAbbreviation(BrakeSpecificFuelConsumptionUnit unit, IFormatProvider provider);
    public static BrakeSpecificFuelConsumption FromGramsPerKiloWattHour(double value);
    public static BrakeSpecificFuelConsumption FromKilogramsPerJoule(double value);
    public static BrakeSpecificFuelConsumption FromPoundsPerMechanicalHorsepowerHour(double value);
    public static BrakeSpecificFuelConsumption From(double value, BrakeSpecificFuelConsumptionUnit fromUnit);
    public static BrakeSpecificFuelConsumption Parse(string str);
    public static override BrakeSpecificFuelConsumption Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, BrakeSpecificFuelConsumption& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, BrakeSpecificFuelConsumption& result);
    public static BrakeSpecificFuelConsumptionUnit ParseUnit(string str);
    public static BrakeSpecificFuelConsumptionUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, BrakeSpecificFuelConsumptionUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, BrakeSpecificFuelConsumptionUnit& unit);
    public static override BrakeSpecificFuelConsumption op_UnaryNegation(BrakeSpecificFuelConsumption right);
    public static override BrakeSpecificFuelConsumption op_Addition(BrakeSpecificFuelConsumption left, BrakeSpecificFuelConsumption right);
    public static override BrakeSpecificFuelConsumption op_Subtraction(BrakeSpecificFuelConsumption left, BrakeSpecificFuelConsumption right);
    public static BrakeSpecificFuelConsumption op_Multiply(double left, BrakeSpecificFuelConsumption right);
    public static override BrakeSpecificFuelConsumption op_Multiply(BrakeSpecificFuelConsumption left, double right);
    public static override BrakeSpecificFuelConsumption op_Division(BrakeSpecificFuelConsumption left, double right);
    public static double op_Division(BrakeSpecificFuelConsumption left, BrakeSpecificFuelConsumption right);
    public static override MassFlow op_Multiply(BrakeSpecificFuelConsumption brakeSpecificFuelConsumption, Power power);
    public static SpecificEnergy op_Division(double value, BrakeSpecificFuelConsumption brakeSpecificFuelConsumption);
    public static override double op_Multiply(BrakeSpecificFuelConsumption brakeSpecificFuelConsumption, SpecificEnergy specificEnergy);
    public static override bool op_LessThanOrEqual(BrakeSpecificFuelConsumption left, BrakeSpecificFuelConsumption right);
    public static override bool op_GreaterThanOrEqual(BrakeSpecificFuelConsumption left, BrakeSpecificFuelConsumption right);
    public static override bool op_LessThan(BrakeSpecificFuelConsumption left, BrakeSpecificFuelConsumption right);
    public static override bool op_GreaterThan(BrakeSpecificFuelConsumption left, BrakeSpecificFuelConsumption right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(BrakeSpecificFuelConsumption other, BrakeSpecificFuelConsumption tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(BrakeSpecificFuelConsumption left, BrakeSpecificFuelConsumption right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(BrakeSpecificFuelConsumption other, BrakeSpecificFuelConsumption tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(BrakeSpecificFuelConsumption left, BrakeSpecificFuelConsumption right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(BrakeSpecificFuelConsumption other, BrakeSpecificFuelConsumption tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(BrakeSpecificFuelConsumption other, BrakeSpecificFuelConsumption tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(BrakeSpecificFuelConsumption other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(BrakeSpecificFuelConsumption other);
    [ObsoleteAttribute("Use Equals(BrakeSpecificFuelConsumption other, BrakeSpecificFuelConsumption tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(BrakeSpecificFuelConsumption other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(BrakeSpecificFuelConsumption other, BrakeSpecificFuelConsumption tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(BrakeSpecificFuelConsumptionUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public BrakeSpecificFuelConsumption ToUnit(BrakeSpecificFuelConsumptionUnit unit);
    public BrakeSpecificFuelConsumption ToUnit(BrakeSpecificFuelConsumptionUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(BrakeSpecificFuelConsumptionUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public BrakeSpecificFuelConsumption ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<BrakeSpecificFuelConsumptionUnit> UnitsNet.IQuantity<UnitsNet.Units.BrakeSpecificFuelConsumptionUnit>.ToUnit(BrakeSpecificFuelConsumptionUnit unit);
    private sealed virtual override IQuantity`1<BrakeSpecificFuelConsumptionUnit> UnitsNet.IQuantity<UnitsNet.Units.BrakeSpecificFuelConsumptionUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Capacitance : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<CapacitanceUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<CapacitanceUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static CapacitanceUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static CapacitanceUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Capacitance <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<CapacitanceUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static CapacitanceUnit BaseUnit { get; }
    public static CapacitanceUnit[] Units { get; }
    public static Capacitance Zero { get; }
    public static Capacitance AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public CapacitanceUnit Unit { get; }
    public QuantityInfo`1<CapacitanceUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Farads { get; }
    public double Kilofarads { get; }
    public double Megafarads { get; }
    public double Microfarads { get; }
    public double Millifarads { get; }
    public double Nanofarads { get; }
    public double Picofarads { get; }
    private static Capacitance();
    public Capacitance(double value, CapacitanceUnit unit);
    public Capacitance(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<CapacitanceUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static CapacitanceUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static CapacitanceUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Capacitance get_Zero();
    public static override Capacitance get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual CapacitanceUnit get_Unit();
    public sealed virtual QuantityInfo`1<CapacitanceUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Farads();
    public double get_Kilofarads();
    public double get_Megafarads();
    public double get_Microfarads();
    public double get_Millifarads();
    public double get_Nanofarads();
    public double get_Picofarads();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(CapacitanceUnit unit);
    public static string GetAbbreviation(CapacitanceUnit unit, IFormatProvider provider);
    public static Capacitance FromFarads(double value);
    public static Capacitance FromKilofarads(double value);
    public static Capacitance FromMegafarads(double value);
    public static Capacitance FromMicrofarads(double value);
    public static Capacitance FromMillifarads(double value);
    public static Capacitance FromNanofarads(double value);
    public static Capacitance FromPicofarads(double value);
    public static Capacitance From(double value, CapacitanceUnit fromUnit);
    public static Capacitance Parse(string str);
    public static override Capacitance Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Capacitance& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Capacitance& result);
    public static CapacitanceUnit ParseUnit(string str);
    public static CapacitanceUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, CapacitanceUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, CapacitanceUnit& unit);
    public static override Capacitance op_UnaryNegation(Capacitance right);
    public static override Capacitance op_Addition(Capacitance left, Capacitance right);
    public static override Capacitance op_Subtraction(Capacitance left, Capacitance right);
    public static Capacitance op_Multiply(double left, Capacitance right);
    public static override Capacitance op_Multiply(Capacitance left, double right);
    public static override Capacitance op_Division(Capacitance left, double right);
    public static double op_Division(Capacitance left, Capacitance right);
    public static override bool op_LessThanOrEqual(Capacitance left, Capacitance right);
    public static override bool op_GreaterThanOrEqual(Capacitance left, Capacitance right);
    public static override bool op_LessThan(Capacitance left, Capacitance right);
    public static override bool op_GreaterThan(Capacitance left, Capacitance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Capacitance other, Capacitance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Capacitance left, Capacitance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Capacitance other, Capacitance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Capacitance left, Capacitance right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Capacitance other, Capacitance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Capacitance other, Capacitance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Capacitance other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Capacitance other);
    [ObsoleteAttribute("Use Equals(Capacitance other, Capacitance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Capacitance other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Capacitance other, Capacitance tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(CapacitanceUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Capacitance ToUnit(CapacitanceUnit unit);
    public Capacitance ToUnit(CapacitanceUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(CapacitanceUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Capacitance ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<CapacitanceUnit> UnitsNet.IQuantity<UnitsNet.Units.CapacitanceUnit>.ToUnit(CapacitanceUnit unit);
    private sealed virtual override IQuantity`1<CapacitanceUnit> UnitsNet.IQuantity<UnitsNet.Units.CapacitanceUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.CoefficientOfThermalExpansion : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<CoefficientOfThermalExpansionUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<CoefficientOfThermalExpansionUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static CoefficientOfThermalExpansionUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static CoefficientOfThermalExpansionUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static CoefficientOfThermalExpansion <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<CoefficientOfThermalExpansionUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static CoefficientOfThermalExpansionUnit BaseUnit { get; }
    public static CoefficientOfThermalExpansionUnit[] Units { get; }
    public static CoefficientOfThermalExpansion Zero { get; }
    public static CoefficientOfThermalExpansion AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public CoefficientOfThermalExpansionUnit Unit { get; }
    public QuantityInfo`1<CoefficientOfThermalExpansionUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double PerDegreeCelsius { get; }
    public double PerDegreeFahrenheit { get; }
    public double PerKelvin { get; }
    public double PpmPerDegreeCelsius { get; }
    public double PpmPerDegreeFahrenheit { get; }
    public double PpmPerKelvin { get; }
    private static CoefficientOfThermalExpansion();
    public CoefficientOfThermalExpansion(double value, CoefficientOfThermalExpansionUnit unit);
    public CoefficientOfThermalExpansion(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<CoefficientOfThermalExpansionUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static CoefficientOfThermalExpansionUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static CoefficientOfThermalExpansionUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override CoefficientOfThermalExpansion get_Zero();
    public static override CoefficientOfThermalExpansion get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual CoefficientOfThermalExpansionUnit get_Unit();
    public sealed virtual QuantityInfo`1<CoefficientOfThermalExpansionUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_PerDegreeCelsius();
    public double get_PerDegreeFahrenheit();
    public double get_PerKelvin();
    public double get_PpmPerDegreeCelsius();
    public double get_PpmPerDegreeFahrenheit();
    public double get_PpmPerKelvin();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(CoefficientOfThermalExpansionUnit unit);
    public static string GetAbbreviation(CoefficientOfThermalExpansionUnit unit, IFormatProvider provider);
    public static CoefficientOfThermalExpansion FromPerDegreeCelsius(double value);
    public static CoefficientOfThermalExpansion FromPerDegreeFahrenheit(double value);
    public static CoefficientOfThermalExpansion FromPerKelvin(double value);
    public static CoefficientOfThermalExpansion FromPpmPerDegreeCelsius(double value);
    public static CoefficientOfThermalExpansion FromPpmPerDegreeFahrenheit(double value);
    public static CoefficientOfThermalExpansion FromPpmPerKelvin(double value);
    public static CoefficientOfThermalExpansion From(double value, CoefficientOfThermalExpansionUnit fromUnit);
    public static CoefficientOfThermalExpansion Parse(string str);
    public static override CoefficientOfThermalExpansion Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, CoefficientOfThermalExpansion& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, CoefficientOfThermalExpansion& result);
    public static CoefficientOfThermalExpansionUnit ParseUnit(string str);
    public static CoefficientOfThermalExpansionUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, CoefficientOfThermalExpansionUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, CoefficientOfThermalExpansionUnit& unit);
    public static override CoefficientOfThermalExpansion op_UnaryNegation(CoefficientOfThermalExpansion right);
    public static override CoefficientOfThermalExpansion op_Addition(CoefficientOfThermalExpansion left, CoefficientOfThermalExpansion right);
    public static override CoefficientOfThermalExpansion op_Subtraction(CoefficientOfThermalExpansion left, CoefficientOfThermalExpansion right);
    public static CoefficientOfThermalExpansion op_Multiply(double left, CoefficientOfThermalExpansion right);
    public static override CoefficientOfThermalExpansion op_Multiply(CoefficientOfThermalExpansion left, double right);
    public static override CoefficientOfThermalExpansion op_Division(CoefficientOfThermalExpansion left, double right);
    public static double op_Division(CoefficientOfThermalExpansion left, CoefficientOfThermalExpansion right);
    public static TemperatureDelta op_Division(double value, CoefficientOfThermalExpansion coefficientOfThermalExpansion);
    public static override double op_Multiply(CoefficientOfThermalExpansion coefficientOfThermalExpansion, TemperatureDelta temperatureDelta);
    public static override bool op_LessThanOrEqual(CoefficientOfThermalExpansion left, CoefficientOfThermalExpansion right);
    public static override bool op_GreaterThanOrEqual(CoefficientOfThermalExpansion left, CoefficientOfThermalExpansion right);
    public static override bool op_LessThan(CoefficientOfThermalExpansion left, CoefficientOfThermalExpansion right);
    public static override bool op_GreaterThan(CoefficientOfThermalExpansion left, CoefficientOfThermalExpansion right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(CoefficientOfThermalExpansion other, CoefficientOfThermalExpansion tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(CoefficientOfThermalExpansion left, CoefficientOfThermalExpansion right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(CoefficientOfThermalExpansion other, CoefficientOfThermalExpansion tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(CoefficientOfThermalExpansion left, CoefficientOfThermalExpansion right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(CoefficientOfThermalExpansion other, CoefficientOfThermalExpansion tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(CoefficientOfThermalExpansion other, CoefficientOfThermalExpansion tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(CoefficientOfThermalExpansion other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(CoefficientOfThermalExpansion other);
    [ObsoleteAttribute("Use Equals(CoefficientOfThermalExpansion other, CoefficientOfThermalExpansion tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(CoefficientOfThermalExpansion other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(CoefficientOfThermalExpansion other, CoefficientOfThermalExpansion tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(CoefficientOfThermalExpansionUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public CoefficientOfThermalExpansion ToUnit(CoefficientOfThermalExpansionUnit unit);
    public CoefficientOfThermalExpansion ToUnit(CoefficientOfThermalExpansionUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(CoefficientOfThermalExpansionUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public CoefficientOfThermalExpansion ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<CoefficientOfThermalExpansionUnit> UnitsNet.IQuantity<UnitsNet.Units.CoefficientOfThermalExpansionUnit>.ToUnit(CoefficientOfThermalExpansionUnit unit);
    private sealed virtual override IQuantity`1<CoefficientOfThermalExpansionUnit> UnitsNet.IQuantity<UnitsNet.Units.CoefficientOfThermalExpansionUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
public static class UnitsNet.Comparison : object {
    public static bool Equals(double referenceValue, double otherValue, double tolerance, ComparisonType comparisonType);
    public static bool EqualsRelative(double referenceValue, double otherValue, double tolerance);
    public static bool EqualsAbsolute(double value1, double value2, double tolerance);
}
public enum UnitsNet.ComparisonType : Enum {
    public int value__;
    public static ComparisonType Relative;
    public static ComparisonType Absolute;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class UnitsNet.CompiledLambdas : object {
    internal static T Multiply(T left, T right);
    internal static TResult Multiply(TLeft left, TRight right);
    internal static T Divide(T left, T right);
    internal static TResult Divide(TLeft left, TRight right);
    internal static T Add(T left, T right);
    internal static TResult Add(TLeft left, TRight right);
    internal static T Subtract(T left, T right);
    internal static TResult Subtract(TLeft left, TRight right);
    internal static T Modulo(T left, T right);
    internal static TResult Modulo(TLeft left, TRight right);
    internal static bool Equal(T left, T right);
    internal static bool Equal(TLeft left, TRight right);
    internal static bool NotEqual(T left, T right);
    internal static bool NotEqual(TLeft left, TRight right);
    internal static bool LessThan(TLeft left, TRight right);
    internal static bool LessThanOrEqual(TLeft left, TRight right);
    internal static bool GreaterThan(TLeft left, TRight right);
    internal static bool GreaterThanOrEqual(TLeft left, TRight right);
    [NullableContextAttribute("2")]
private static Func`3<TLeft, TRight, TResult> CreateBinaryFunction(Func`3<Expression, Expression, BinaryExpression> expressionCreationFunction);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Compressibility : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<CompressibilityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<CompressibilityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static CompressibilityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static CompressibilityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Compressibility <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<CompressibilityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static CompressibilityUnit BaseUnit { get; }
    public static CompressibilityUnit[] Units { get; }
    public static Compressibility Zero { get; }
    public static Compressibility AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public CompressibilityUnit Unit { get; }
    public QuantityInfo`1<CompressibilityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double InverseAtmospheres { get; }
    public double InverseBars { get; }
    public double InverseKilopascals { get; }
    public double InverseMegapascals { get; }
    public double InverseMillibars { get; }
    public double InversePascals { get; }
    public double InversePoundsForcePerSquareInch { get; }
    private static Compressibility();
    public Compressibility(double value, CompressibilityUnit unit);
    public Compressibility(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<CompressibilityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static CompressibilityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static CompressibilityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Compressibility get_Zero();
    public static override Compressibility get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual CompressibilityUnit get_Unit();
    public sealed virtual QuantityInfo`1<CompressibilityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_InverseAtmospheres();
    public double get_InverseBars();
    public double get_InverseKilopascals();
    public double get_InverseMegapascals();
    public double get_InverseMillibars();
    public double get_InversePascals();
    public double get_InversePoundsForcePerSquareInch();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(CompressibilityUnit unit);
    public static string GetAbbreviation(CompressibilityUnit unit, IFormatProvider provider);
    public static Compressibility FromInverseAtmospheres(double value);
    public static Compressibility FromInverseBars(double value);
    public static Compressibility FromInverseKilopascals(double value);
    public static Compressibility FromInverseMegapascals(double value);
    public static Compressibility FromInverseMillibars(double value);
    public static Compressibility FromInversePascals(double value);
    public static Compressibility FromInversePoundsForcePerSquareInch(double value);
    public static Compressibility From(double value, CompressibilityUnit fromUnit);
    public static Compressibility Parse(string str);
    public static override Compressibility Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Compressibility& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Compressibility& result);
    public static CompressibilityUnit ParseUnit(string str);
    public static CompressibilityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, CompressibilityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, CompressibilityUnit& unit);
    public static override Compressibility op_UnaryNegation(Compressibility right);
    public static override Compressibility op_Addition(Compressibility left, Compressibility right);
    public static override Compressibility op_Subtraction(Compressibility left, Compressibility right);
    public static Compressibility op_Multiply(double left, Compressibility right);
    public static override Compressibility op_Multiply(Compressibility left, double right);
    public static override Compressibility op_Division(Compressibility left, double right);
    public static double op_Division(Compressibility left, Compressibility right);
    public static override bool op_LessThanOrEqual(Compressibility left, Compressibility right);
    public static override bool op_GreaterThanOrEqual(Compressibility left, Compressibility right);
    public static override bool op_LessThan(Compressibility left, Compressibility right);
    public static override bool op_GreaterThan(Compressibility left, Compressibility right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Compressibility other, Compressibility tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Compressibility left, Compressibility right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Compressibility other, Compressibility tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Compressibility left, Compressibility right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Compressibility other, Compressibility tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Compressibility other, Compressibility tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Compressibility other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Compressibility other);
    [ObsoleteAttribute("Use Equals(Compressibility other, Compressibility tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Compressibility other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Compressibility other, Compressibility tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(CompressibilityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Compressibility ToUnit(CompressibilityUnit unit);
    public Compressibility ToUnit(CompressibilityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(CompressibilityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Compressibility ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<CompressibilityUnit> UnitsNet.IQuantity<UnitsNet.Units.CompressibilityUnit>.ToUnit(CompressibilityUnit unit);
    private sealed virtual override IQuantity`1<CompressibilityUnit> UnitsNet.IQuantity<UnitsNet.Units.CompressibilityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
public class UnitsNet.ConversionFunction : MulticastDelegate {
    public ConversionFunction(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IQuantity Invoke(IQuantity inputValue);
    public virtual IAsyncResult BeginInvoke(IQuantity inputValue, AsyncCallback callback, object object);
    public virtual IQuantity EndInvoke(IAsyncResult result);
}
public class UnitsNet.ConversionFunction`1 : MulticastDelegate {
    public ConversionFunction`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TQuantity Invoke(TQuantity inputValue);
    public virtual IAsyncResult BeginInvoke(TQuantity inputValue, AsyncCallback callback, object object);
    public virtual TQuantity EndInvoke(IAsyncResult result);
}
public class UnitsNet.ConvertToUnitAttribute : DefaultUnitAttribute {
    [NullableContextAttribute("2")]
public ConvertToUnitAttribute(object unitType);
}
public enum UnitsNet.CustomCode.Units.PressureReference : Enum {
    public int value__;
    public static PressureReference Absolute;
    public static PressureReference Gauge;
    public static PressureReference Vacuum;
}
public class UnitsNet.DefaultUnitAttribute : UnitAttributeBase {
    [NullableContextAttribute("2")]
public DefaultUnitAttribute(object unitType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Density : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<DensityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<DensityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static DensityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static DensityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Density <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<DensityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static DensityUnit BaseUnit { get; }
    public static DensityUnit[] Units { get; }
    public static Density Zero { get; }
    public static Density AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public DensityUnit Unit { get; }
    public QuantityInfo`1<DensityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentigramsPerDeciliter { get; }
    public double CentigramsPerLiter { get; }
    public double CentigramsPerMilliliter { get; }
    public double DecigramsPerDeciliter { get; }
    public double DecigramsPerLiter { get; }
    public double DecigramsPerMilliliter { get; }
    public double FemtogramsPerDeciliter { get; }
    public double FemtogramsPerLiter { get; }
    public double FemtogramsPerMilliliter { get; }
    public double GramsPerCubicCentimeter { get; }
    public double GramsPerCubicFoot { get; }
    public double GramsPerCubicInch { get; }
    public double GramsPerCubicMeter { get; }
    public double GramsPerCubicMillimeter { get; }
    public double GramsPerDeciliter { get; }
    public double GramsPerLiter { get; }
    public double GramsPerMilliliter { get; }
    public double KilogramsPerCubicCentimeter { get; }
    public double KilogramsPerCubicMeter { get; }
    public double KilogramsPerCubicMillimeter { get; }
    public double KilogramsPerLiter { get; }
    public double KilopoundsPerCubicFoot { get; }
    public double KilopoundsPerCubicInch { get; }
    public double KilopoundsPerCubicYard { get; }
    public double MicrogramsPerCubicMeter { get; }
    public double MicrogramsPerDeciliter { get; }
    public double MicrogramsPerLiter { get; }
    public double MicrogramsPerMilliliter { get; }
    public double MilligramsPerCubicMeter { get; }
    public double MilligramsPerDeciliter { get; }
    public double MilligramsPerLiter { get; }
    public double MilligramsPerMilliliter { get; }
    public double NanogramsPerDeciliter { get; }
    public double NanogramsPerLiter { get; }
    public double NanogramsPerMilliliter { get; }
    public double PicogramsPerDeciliter { get; }
    public double PicogramsPerLiter { get; }
    public double PicogramsPerMilliliter { get; }
    public double PoundsPerCubicCentimeter { get; }
    public double PoundsPerCubicFoot { get; }
    public double PoundsPerCubicInch { get; }
    public double PoundsPerCubicMeter { get; }
    public double PoundsPerCubicMillimeter { get; }
    public double PoundsPerCubicYard { get; }
    public double PoundsPerImperialGallon { get; }
    public double PoundsPerUSGallon { get; }
    public double SlugsPerCubicCentimeter { get; }
    public double SlugsPerCubicFoot { get; }
    public double SlugsPerCubicInch { get; }
    public double SlugsPerCubicMeter { get; }
    public double SlugsPerCubicMillimeter { get; }
    public double TonnesPerCubicCentimeter { get; }
    public double TonnesPerCubicFoot { get; }
    public double TonnesPerCubicInch { get; }
    public double TonnesPerCubicMeter { get; }
    public double TonnesPerCubicMillimeter { get; }
    private static Density();
    public Density(double value, DensityUnit unit);
    public Density(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<DensityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static DensityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static DensityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Density get_Zero();
    public static override Density get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual DensityUnit get_Unit();
    public sealed virtual QuantityInfo`1<DensityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentigramsPerDeciliter();
    public double get_CentigramsPerLiter();
    public double get_CentigramsPerMilliliter();
    public double get_DecigramsPerDeciliter();
    public double get_DecigramsPerLiter();
    public double get_DecigramsPerMilliliter();
    public double get_FemtogramsPerDeciliter();
    public double get_FemtogramsPerLiter();
    public double get_FemtogramsPerMilliliter();
    public double get_GramsPerCubicCentimeter();
    public double get_GramsPerCubicFoot();
    public double get_GramsPerCubicInch();
    public double get_GramsPerCubicMeter();
    public double get_GramsPerCubicMillimeter();
    public double get_GramsPerDeciliter();
    public double get_GramsPerLiter();
    public double get_GramsPerMilliliter();
    public double get_KilogramsPerCubicCentimeter();
    public double get_KilogramsPerCubicMeter();
    public double get_KilogramsPerCubicMillimeter();
    public double get_KilogramsPerLiter();
    public double get_KilopoundsPerCubicFoot();
    public double get_KilopoundsPerCubicInch();
    public double get_KilopoundsPerCubicYard();
    public double get_MicrogramsPerCubicMeter();
    public double get_MicrogramsPerDeciliter();
    public double get_MicrogramsPerLiter();
    public double get_MicrogramsPerMilliliter();
    public double get_MilligramsPerCubicMeter();
    public double get_MilligramsPerDeciliter();
    public double get_MilligramsPerLiter();
    public double get_MilligramsPerMilliliter();
    public double get_NanogramsPerDeciliter();
    public double get_NanogramsPerLiter();
    public double get_NanogramsPerMilliliter();
    public double get_PicogramsPerDeciliter();
    public double get_PicogramsPerLiter();
    public double get_PicogramsPerMilliliter();
    public double get_PoundsPerCubicCentimeter();
    public double get_PoundsPerCubicFoot();
    public double get_PoundsPerCubicInch();
    public double get_PoundsPerCubicMeter();
    public double get_PoundsPerCubicMillimeter();
    public double get_PoundsPerCubicYard();
    public double get_PoundsPerImperialGallon();
    public double get_PoundsPerUSGallon();
    public double get_SlugsPerCubicCentimeter();
    public double get_SlugsPerCubicFoot();
    public double get_SlugsPerCubicInch();
    public double get_SlugsPerCubicMeter();
    public double get_SlugsPerCubicMillimeter();
    public double get_TonnesPerCubicCentimeter();
    public double get_TonnesPerCubicFoot();
    public double get_TonnesPerCubicInch();
    public double get_TonnesPerCubicMeter();
    public double get_TonnesPerCubicMillimeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(DensityUnit unit);
    public static string GetAbbreviation(DensityUnit unit, IFormatProvider provider);
    public static Density FromCentigramsPerDeciliter(double value);
    public static Density FromCentigramsPerLiter(double value);
    public static Density FromCentigramsPerMilliliter(double value);
    public static Density FromDecigramsPerDeciliter(double value);
    public static Density FromDecigramsPerLiter(double value);
    public static Density FromDecigramsPerMilliliter(double value);
    public static Density FromFemtogramsPerDeciliter(double value);
    public static Density FromFemtogramsPerLiter(double value);
    public static Density FromFemtogramsPerMilliliter(double value);
    public static Density FromGramsPerCubicCentimeter(double value);
    public static Density FromGramsPerCubicFoot(double value);
    public static Density FromGramsPerCubicInch(double value);
    public static Density FromGramsPerCubicMeter(double value);
    public static Density FromGramsPerCubicMillimeter(double value);
    public static Density FromGramsPerDeciliter(double value);
    public static Density FromGramsPerLiter(double value);
    public static Density FromGramsPerMilliliter(double value);
    public static Density FromKilogramsPerCubicCentimeter(double value);
    public static Density FromKilogramsPerCubicMeter(double value);
    public static Density FromKilogramsPerCubicMillimeter(double value);
    public static Density FromKilogramsPerLiter(double value);
    public static Density FromKilopoundsPerCubicFoot(double value);
    public static Density FromKilopoundsPerCubicInch(double value);
    public static Density FromKilopoundsPerCubicYard(double value);
    public static Density FromMicrogramsPerCubicMeter(double value);
    public static Density FromMicrogramsPerDeciliter(double value);
    public static Density FromMicrogramsPerLiter(double value);
    public static Density FromMicrogramsPerMilliliter(double value);
    public static Density FromMilligramsPerCubicMeter(double value);
    public static Density FromMilligramsPerDeciliter(double value);
    public static Density FromMilligramsPerLiter(double value);
    public static Density FromMilligramsPerMilliliter(double value);
    public static Density FromNanogramsPerDeciliter(double value);
    public static Density FromNanogramsPerLiter(double value);
    public static Density FromNanogramsPerMilliliter(double value);
    public static Density FromPicogramsPerDeciliter(double value);
    public static Density FromPicogramsPerLiter(double value);
    public static Density FromPicogramsPerMilliliter(double value);
    public static Density FromPoundsPerCubicCentimeter(double value);
    public static Density FromPoundsPerCubicFoot(double value);
    public static Density FromPoundsPerCubicInch(double value);
    public static Density FromPoundsPerCubicMeter(double value);
    public static Density FromPoundsPerCubicMillimeter(double value);
    public static Density FromPoundsPerCubicYard(double value);
    public static Density FromPoundsPerImperialGallon(double value);
    public static Density FromPoundsPerUSGallon(double value);
    public static Density FromSlugsPerCubicCentimeter(double value);
    public static Density FromSlugsPerCubicFoot(double value);
    public static Density FromSlugsPerCubicInch(double value);
    public static Density FromSlugsPerCubicMeter(double value);
    public static Density FromSlugsPerCubicMillimeter(double value);
    public static Density FromTonnesPerCubicCentimeter(double value);
    public static Density FromTonnesPerCubicFoot(double value);
    public static Density FromTonnesPerCubicInch(double value);
    public static Density FromTonnesPerCubicMeter(double value);
    public static Density FromTonnesPerCubicMillimeter(double value);
    public static Density From(double value, DensityUnit fromUnit);
    public static Density Parse(string str);
    public static override Density Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Density& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Density& result);
    public static DensityUnit ParseUnit(string str);
    public static DensityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, DensityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, DensityUnit& unit);
    public static override Density op_UnaryNegation(Density right);
    public static override Density op_Addition(Density left, Density right);
    public static override Density op_Subtraction(Density left, Density right);
    public static Density op_Multiply(double left, Density right);
    public static override Density op_Multiply(Density left, double right);
    public static override Density op_Division(Density left, double right);
    public static double op_Division(Density left, Density right);
    public static override DynamicViscosity op_Multiply(Density density, KinematicViscosity kinematicViscosity);
    public static override LinearDensity op_Multiply(Density density, Area area);
    public static override Mass op_Multiply(Density density, Volume volume);
    public static override MassConcentration op_Multiply(Density density, VolumeConcentration volumeConcentration);
    public static override MassFlow op_Multiply(Density density, VolumeFlow volumeFlow);
    public static override MassFlux op_Multiply(Density density, Speed speed);
    public static SpecificVolume op_Division(double value, Density density);
    public static override SpecificWeight op_Multiply(Density density, Acceleration acceleration);
    public static override double op_Multiply(Density density, SpecificVolume specificVolume);
    public static override bool op_LessThanOrEqual(Density left, Density right);
    public static override bool op_GreaterThanOrEqual(Density left, Density right);
    public static override bool op_LessThan(Density left, Density right);
    public static override bool op_GreaterThan(Density left, Density right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Density other, Density tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Density left, Density right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Density other, Density tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Density left, Density right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Density other, Density tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Density other, Density tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Density other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Density other);
    [ObsoleteAttribute("Use Equals(Density other, Density tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Density other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Density other, Density tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(DensityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Density ToUnit(DensityUnit unit);
    public Density ToUnit(DensityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(DensityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Density ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<DensityUnit> UnitsNet.IQuantity<UnitsNet.Units.DensityUnit>.ToUnit(DensityUnit unit);
    private sealed virtual override IQuantity`1<DensityUnit> UnitsNet.IQuantity<UnitsNet.Units.DensityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.DisplayAsUnitAttribute : DefaultUnitAttribute {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    public string Format { get; public set; }
    public DisplayAsUnitAttribute(object unitType, string format);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Duration : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<DurationUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<DurationUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static DurationUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static DurationUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Duration <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<DurationUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static DurationUnit BaseUnit { get; }
    public static DurationUnit[] Units { get; }
    public static Duration Zero { get; }
    public static Duration AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public DurationUnit Unit { get; }
    public QuantityInfo`1<DurationUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Days { get; }
    public double Hours { get; }
    public double JulianYears { get; }
    public double Microseconds { get; }
    public double Milliseconds { get; }
    public double Minutes { get; }
    public double Months30 { get; }
    public double Nanoseconds { get; }
    public double Seconds { get; }
    public double Sols { get; }
    public double Weeks { get; }
    public double Years365 { get; }
    private static Duration();
    public Duration(double value, DurationUnit unit);
    public Duration(double value, UnitSystem unitSystem);
    public TimeSpan ToTimeSpan();
    public static DateTime op_Addition(DateTime time, Duration duration);
    public static DateTime op_Subtraction(DateTime time, Duration duration);
    public static TimeSpan op_Implicit(Duration duration);
    public static Duration op_Implicit(TimeSpan duration);
    public static bool op_LessThan(Duration duration, TimeSpan timeSpan);
    public static bool op_GreaterThan(Duration duration, TimeSpan timeSpan);
    public static bool op_LessThanOrEqual(Duration duration, TimeSpan timeSpan);
    public static bool op_GreaterThanOrEqual(Duration duration, TimeSpan timeSpan);
    public static bool op_LessThan(TimeSpan timeSpan, Duration duration);
    public static bool op_GreaterThan(TimeSpan timeSpan, Duration duration);
    public static bool op_LessThanOrEqual(TimeSpan timeSpan, Duration duration);
    public static bool op_GreaterThanOrEqual(TimeSpan timeSpan, Duration duration);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<DurationUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static DurationUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static DurationUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Duration get_Zero();
    public static override Duration get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual DurationUnit get_Unit();
    public sealed virtual QuantityInfo`1<DurationUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Days();
    public double get_Hours();
    public double get_JulianYears();
    public double get_Microseconds();
    public double get_Milliseconds();
    public double get_Minutes();
    public double get_Months30();
    public double get_Nanoseconds();
    public double get_Seconds();
    public double get_Sols();
    public double get_Weeks();
    public double get_Years365();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(DurationUnit unit);
    public static string GetAbbreviation(DurationUnit unit, IFormatProvider provider);
    public static Duration FromDays(double value);
    public static Duration FromHours(double value);
    public static Duration FromJulianYears(double value);
    public static Duration FromMicroseconds(double value);
    public static Duration FromMilliseconds(double value);
    public static Duration FromMinutes(double value);
    public static Duration FromMonths30(double value);
    public static Duration FromNanoseconds(double value);
    public static Duration FromSeconds(double value);
    public static Duration FromSols(double value);
    public static Duration FromWeeks(double value);
    public static Duration FromYears365(double value);
    public static Duration From(double value, DurationUnit fromUnit);
    public static Duration Parse(string str);
    public static override Duration Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Duration& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Duration& result);
    public static DurationUnit ParseUnit(string str);
    public static DurationUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, DurationUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, DurationUnit& unit);
    public static override Duration op_UnaryNegation(Duration right);
    public static override Duration op_Addition(Duration left, Duration right);
    public static override Duration op_Subtraction(Duration left, Duration right);
    public static Duration op_Multiply(double left, Duration right);
    public static override Duration op_Multiply(Duration left, double right);
    public static override Duration op_Division(Duration left, double right);
    public static double op_Division(Duration left, Duration right);
    public static override Acceleration op_Multiply(Duration duration, Jerk jerk);
    public static override AmountOfSubstance op_Multiply(Duration duration, MolarFlow molarFlow);
    public static override Angle op_Multiply(Duration duration, RotationalSpeed rotationalSpeed);
    public static override Area op_Multiply(Duration duration, KinematicViscosity kinematicViscosity);
    public static override ElectricCharge op_Multiply(Duration duration, ElectricCurrent electricCurrent);
    public static override ElectricCurrent op_Multiply(Duration duration, ElectricCurrentGradient electricCurrentGradient);
    public static override Energy op_Multiply(Duration duration, Power power);
    public static override Force op_Multiply(Duration duration, ForceChangeRate forceChangeRate);
    public static override Length op_Multiply(Duration duration, Speed speed);
    public static override Mass op_Multiply(Duration duration, MassFlow massFlow);
    public static override Pressure op_Multiply(Duration duration, PressureChangeRate pressureChangeRate);
    public static override Speed op_Multiply(Duration duration, Acceleration acceleration);
    public static override TemperatureDelta op_Multiply(Duration duration, TemperatureChangeRate temperatureChangeRate);
    public static override Volume op_Multiply(Duration duration, VolumeFlow volumeFlow);
    public static override bool op_LessThanOrEqual(Duration left, Duration right);
    public static override bool op_GreaterThanOrEqual(Duration left, Duration right);
    public static override bool op_LessThan(Duration left, Duration right);
    public static override bool op_GreaterThan(Duration left, Duration right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Duration other, Duration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Duration left, Duration right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Duration other, Duration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Duration left, Duration right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Duration other, Duration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Duration other, Duration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Duration other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Duration other);
    [ObsoleteAttribute("Use Equals(Duration other, Duration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Duration other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Duration other, Duration tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(DurationUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Duration ToUnit(DurationUnit unit);
    public Duration ToUnit(DurationUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(DurationUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Duration ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<DurationUnit> UnitsNet.IQuantity<UnitsNet.Units.DurationUnit>.ToUnit(DurationUnit unit);
    private sealed virtual override IQuantity`1<DurationUnit> UnitsNet.IQuantity<UnitsNet.Units.DurationUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.DynamicViscosity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<DynamicViscosityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<DynamicViscosityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static DynamicViscosityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static DynamicViscosityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static DynamicViscosity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<DynamicViscosityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static DynamicViscosityUnit BaseUnit { get; }
    public static DynamicViscosityUnit[] Units { get; }
    public static DynamicViscosity Zero { get; }
    public static DynamicViscosity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public DynamicViscosityUnit Unit { get; }
    public QuantityInfo`1<DynamicViscosityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Centipoise { get; }
    public double MicropascalSeconds { get; }
    public double MillipascalSeconds { get; }
    public double NewtonSecondsPerMeterSquared { get; }
    public double PascalSeconds { get; }
    public double Poise { get; }
    public double PoundsForceSecondPerSquareFoot { get; }
    public double PoundsForceSecondPerSquareInch { get; }
    public double PoundsPerFootSecond { get; }
    public double Reyns { get; }
    private static DynamicViscosity();
    public DynamicViscosity(double value, DynamicViscosityUnit unit);
    public DynamicViscosity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<DynamicViscosityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static DynamicViscosityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static DynamicViscosityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override DynamicViscosity get_Zero();
    public static override DynamicViscosity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual DynamicViscosityUnit get_Unit();
    public sealed virtual QuantityInfo`1<DynamicViscosityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Centipoise();
    public double get_MicropascalSeconds();
    public double get_MillipascalSeconds();
    public double get_NewtonSecondsPerMeterSquared();
    public double get_PascalSeconds();
    public double get_Poise();
    public double get_PoundsForceSecondPerSquareFoot();
    public double get_PoundsForceSecondPerSquareInch();
    public double get_PoundsPerFootSecond();
    public double get_Reyns();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(DynamicViscosityUnit unit);
    public static string GetAbbreviation(DynamicViscosityUnit unit, IFormatProvider provider);
    public static DynamicViscosity FromCentipoise(double value);
    public static DynamicViscosity FromMicropascalSeconds(double value);
    public static DynamicViscosity FromMillipascalSeconds(double value);
    public static DynamicViscosity FromNewtonSecondsPerMeterSquared(double value);
    public static DynamicViscosity FromPascalSeconds(double value);
    public static DynamicViscosity FromPoise(double value);
    public static DynamicViscosity FromPoundsForceSecondPerSquareFoot(double value);
    public static DynamicViscosity FromPoundsForceSecondPerSquareInch(double value);
    public static DynamicViscosity FromPoundsPerFootSecond(double value);
    public static DynamicViscosity FromReyns(double value);
    public static DynamicViscosity From(double value, DynamicViscosityUnit fromUnit);
    public static DynamicViscosity Parse(string str);
    public static override DynamicViscosity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, DynamicViscosity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, DynamicViscosity& result);
    public static DynamicViscosityUnit ParseUnit(string str);
    public static DynamicViscosityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, DynamicViscosityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, DynamicViscosityUnit& unit);
    public static override DynamicViscosity op_UnaryNegation(DynamicViscosity right);
    public static override DynamicViscosity op_Addition(DynamicViscosity left, DynamicViscosity right);
    public static override DynamicViscosity op_Subtraction(DynamicViscosity left, DynamicViscosity right);
    public static DynamicViscosity op_Multiply(double left, DynamicViscosity right);
    public static override DynamicViscosity op_Multiply(DynamicViscosity left, double right);
    public static override DynamicViscosity op_Division(DynamicViscosity left, double right);
    public static double op_Division(DynamicViscosity left, DynamicViscosity right);
    public static override Density op_Division(DynamicViscosity dynamicViscosity, KinematicViscosity kinematicViscosity);
    public static override KinematicViscosity op_Division(DynamicViscosity dynamicViscosity, Density density);
    public static override bool op_LessThanOrEqual(DynamicViscosity left, DynamicViscosity right);
    public static override bool op_GreaterThanOrEqual(DynamicViscosity left, DynamicViscosity right);
    public static override bool op_LessThan(DynamicViscosity left, DynamicViscosity right);
    public static override bool op_GreaterThan(DynamicViscosity left, DynamicViscosity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(DynamicViscosity other, DynamicViscosity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(DynamicViscosity left, DynamicViscosity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(DynamicViscosity other, DynamicViscosity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(DynamicViscosity left, DynamicViscosity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(DynamicViscosity other, DynamicViscosity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(DynamicViscosity other, DynamicViscosity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(DynamicViscosity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(DynamicViscosity other);
    [ObsoleteAttribute("Use Equals(DynamicViscosity other, DynamicViscosity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(DynamicViscosity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(DynamicViscosity other, DynamicViscosity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(DynamicViscosityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public DynamicViscosity ToUnit(DynamicViscosityUnit unit);
    public DynamicViscosity ToUnit(DynamicViscosityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(DynamicViscosityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public DynamicViscosity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<DynamicViscosityUnit> UnitsNet.IQuantity<UnitsNet.Units.DynamicViscosityUnit>.ToUnit(DynamicViscosityUnit unit);
    private sealed virtual override IQuantity`1<DynamicViscosityUnit> UnitsNet.IQuantity<UnitsNet.Units.DynamicViscosityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricAdmittance : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricAdmittanceUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricAdmittanceUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricAdmittanceUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricAdmittanceUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricAdmittance <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricAdmittanceUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricAdmittanceUnit BaseUnit { get; }
    public static ElectricAdmittanceUnit[] Units { get; }
    public static ElectricAdmittance Zero { get; }
    public static ElectricAdmittance AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricAdmittanceUnit Unit { get; }
    public QuantityInfo`1<ElectricAdmittanceUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Microsiemens { get; }
    public double Millisiemens { get; }
    public double Nanosiemens { get; }
    public double Siemens { get; }
    private static ElectricAdmittance();
    public ElectricAdmittance(double value, ElectricAdmittanceUnit unit);
    public ElectricAdmittance(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricAdmittanceUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricAdmittanceUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricAdmittanceUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricAdmittance get_Zero();
    public static override ElectricAdmittance get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricAdmittanceUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricAdmittanceUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Microsiemens();
    public double get_Millisiemens();
    public double get_Nanosiemens();
    public double get_Siemens();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricAdmittanceUnit unit);
    public static string GetAbbreviation(ElectricAdmittanceUnit unit, IFormatProvider provider);
    public static ElectricAdmittance FromMicrosiemens(double value);
    public static ElectricAdmittance FromMillisiemens(double value);
    public static ElectricAdmittance FromNanosiemens(double value);
    public static ElectricAdmittance FromSiemens(double value);
    public static ElectricAdmittance From(double value, ElectricAdmittanceUnit fromUnit);
    public static ElectricAdmittance Parse(string str);
    public static override ElectricAdmittance Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricAdmittance& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricAdmittance& result);
    public static ElectricAdmittanceUnit ParseUnit(string str);
    public static ElectricAdmittanceUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricAdmittanceUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricAdmittanceUnit& unit);
    public static override ElectricAdmittance op_UnaryNegation(ElectricAdmittance right);
    public static override ElectricAdmittance op_Addition(ElectricAdmittance left, ElectricAdmittance right);
    public static override ElectricAdmittance op_Subtraction(ElectricAdmittance left, ElectricAdmittance right);
    public static ElectricAdmittance op_Multiply(double left, ElectricAdmittance right);
    public static override ElectricAdmittance op_Multiply(ElectricAdmittance left, double right);
    public static override ElectricAdmittance op_Division(ElectricAdmittance left, double right);
    public static double op_Division(ElectricAdmittance left, ElectricAdmittance right);
    public static override bool op_LessThanOrEqual(ElectricAdmittance left, ElectricAdmittance right);
    public static override bool op_GreaterThanOrEqual(ElectricAdmittance left, ElectricAdmittance right);
    public static override bool op_LessThan(ElectricAdmittance left, ElectricAdmittance right);
    public static override bool op_GreaterThan(ElectricAdmittance left, ElectricAdmittance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricAdmittance other, ElectricAdmittance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricAdmittance left, ElectricAdmittance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricAdmittance other, ElectricAdmittance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricAdmittance left, ElectricAdmittance right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricAdmittance other, ElectricAdmittance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricAdmittance other, ElectricAdmittance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricAdmittance other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricAdmittance other);
    [ObsoleteAttribute("Use Equals(ElectricAdmittance other, ElectricAdmittance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricAdmittance other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricAdmittance other, ElectricAdmittance tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricAdmittanceUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricAdmittance ToUnit(ElectricAdmittanceUnit unit);
    public ElectricAdmittance ToUnit(ElectricAdmittanceUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricAdmittanceUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricAdmittance ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricAdmittanceUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricAdmittanceUnit>.ToUnit(ElectricAdmittanceUnit unit);
    private sealed virtual override IQuantity`1<ElectricAdmittanceUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricAdmittanceUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricCharge : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricChargeUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricChargeUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricChargeUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricChargeUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricCharge <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricChargeUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricChargeUnit BaseUnit { get; }
    public static ElectricChargeUnit[] Units { get; }
    public static ElectricCharge Zero { get; }
    public static ElectricCharge AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricChargeUnit Unit { get; }
    public QuantityInfo`1<ElectricChargeUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double AmpereHours { get; }
    public double Coulombs { get; }
    public double KiloampereHours { get; }
    public double Kilocoulombs { get; }
    public double MegaampereHours { get; }
    public double Megacoulombs { get; }
    public double Microcoulombs { get; }
    public double MilliampereHours { get; }
    public double Millicoulombs { get; }
    public double Nanocoulombs { get; }
    public double Picocoulombs { get; }
    private static ElectricCharge();
    public ElectricCharge(double value, ElectricChargeUnit unit);
    public ElectricCharge(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricChargeUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricChargeUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricChargeUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricCharge get_Zero();
    public static override ElectricCharge get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricChargeUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricChargeUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_AmpereHours();
    public double get_Coulombs();
    public double get_KiloampereHours();
    public double get_Kilocoulombs();
    public double get_MegaampereHours();
    public double get_Megacoulombs();
    public double get_Microcoulombs();
    public double get_MilliampereHours();
    public double get_Millicoulombs();
    public double get_Nanocoulombs();
    public double get_Picocoulombs();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricChargeUnit unit);
    public static string GetAbbreviation(ElectricChargeUnit unit, IFormatProvider provider);
    public static ElectricCharge FromAmpereHours(double value);
    public static ElectricCharge FromCoulombs(double value);
    public static ElectricCharge FromKiloampereHours(double value);
    public static ElectricCharge FromKilocoulombs(double value);
    public static ElectricCharge FromMegaampereHours(double value);
    public static ElectricCharge FromMegacoulombs(double value);
    public static ElectricCharge FromMicrocoulombs(double value);
    public static ElectricCharge FromMilliampereHours(double value);
    public static ElectricCharge FromMillicoulombs(double value);
    public static ElectricCharge FromNanocoulombs(double value);
    public static ElectricCharge FromPicocoulombs(double value);
    public static ElectricCharge From(double value, ElectricChargeUnit fromUnit);
    public static ElectricCharge Parse(string str);
    public static override ElectricCharge Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricCharge& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricCharge& result);
    public static ElectricChargeUnit ParseUnit(string str);
    public static ElectricChargeUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricChargeUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricChargeUnit& unit);
    public static override ElectricCharge op_UnaryNegation(ElectricCharge right);
    public static override ElectricCharge op_Addition(ElectricCharge left, ElectricCharge right);
    public static override ElectricCharge op_Subtraction(ElectricCharge left, ElectricCharge right);
    public static ElectricCharge op_Multiply(double left, ElectricCharge right);
    public static override ElectricCharge op_Multiply(ElectricCharge left, double right);
    public static override ElectricCharge op_Division(ElectricCharge left, double right);
    public static double op_Division(ElectricCharge left, ElectricCharge right);
    public static override Duration op_Division(ElectricCharge electricCharge, ElectricCurrent electricCurrent);
    public static override ElectricCurrent op_Division(ElectricCharge electricCharge, Duration duration);
    public static override Energy op_Multiply(ElectricCharge electricCharge, ElectricPotential electricPotential);
    public static override bool op_LessThanOrEqual(ElectricCharge left, ElectricCharge right);
    public static override bool op_GreaterThanOrEqual(ElectricCharge left, ElectricCharge right);
    public static override bool op_LessThan(ElectricCharge left, ElectricCharge right);
    public static override bool op_GreaterThan(ElectricCharge left, ElectricCharge right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricCharge other, ElectricCharge tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricCharge left, ElectricCharge right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricCharge other, ElectricCharge tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricCharge left, ElectricCharge right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricCharge other, ElectricCharge tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricCharge other, ElectricCharge tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricCharge other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricCharge other);
    [ObsoleteAttribute("Use Equals(ElectricCharge other, ElectricCharge tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricCharge other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricCharge other, ElectricCharge tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricChargeUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricCharge ToUnit(ElectricChargeUnit unit);
    public ElectricCharge ToUnit(ElectricChargeUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricChargeUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricCharge ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricChargeUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricChargeUnit>.ToUnit(ElectricChargeUnit unit);
    private sealed virtual override IQuantity`1<ElectricChargeUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricChargeUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricChargeDensity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricChargeDensityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricChargeDensityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricChargeDensityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricChargeDensityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricChargeDensity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricChargeDensityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricChargeDensityUnit BaseUnit { get; }
    public static ElectricChargeDensityUnit[] Units { get; }
    public static ElectricChargeDensity Zero { get; }
    public static ElectricChargeDensity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricChargeDensityUnit Unit { get; }
    public QuantityInfo`1<ElectricChargeDensityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CoulombsPerCubicMeter { get; }
    private static ElectricChargeDensity();
    public ElectricChargeDensity(double value, ElectricChargeDensityUnit unit);
    public ElectricChargeDensity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricChargeDensityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricChargeDensityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricChargeDensityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricChargeDensity get_Zero();
    public static override ElectricChargeDensity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricChargeDensityUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricChargeDensityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CoulombsPerCubicMeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricChargeDensityUnit unit);
    public static string GetAbbreviation(ElectricChargeDensityUnit unit, IFormatProvider provider);
    public static ElectricChargeDensity FromCoulombsPerCubicMeter(double value);
    public static ElectricChargeDensity From(double value, ElectricChargeDensityUnit fromUnit);
    public static ElectricChargeDensity Parse(string str);
    public static override ElectricChargeDensity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricChargeDensity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricChargeDensity& result);
    public static ElectricChargeDensityUnit ParseUnit(string str);
    public static ElectricChargeDensityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricChargeDensityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricChargeDensityUnit& unit);
    public static override ElectricChargeDensity op_UnaryNegation(ElectricChargeDensity right);
    public static override ElectricChargeDensity op_Addition(ElectricChargeDensity left, ElectricChargeDensity right);
    public static override ElectricChargeDensity op_Subtraction(ElectricChargeDensity left, ElectricChargeDensity right);
    public static ElectricChargeDensity op_Multiply(double left, ElectricChargeDensity right);
    public static override ElectricChargeDensity op_Multiply(ElectricChargeDensity left, double right);
    public static override ElectricChargeDensity op_Division(ElectricChargeDensity left, double right);
    public static double op_Division(ElectricChargeDensity left, ElectricChargeDensity right);
    public static override bool op_LessThanOrEqual(ElectricChargeDensity left, ElectricChargeDensity right);
    public static override bool op_GreaterThanOrEqual(ElectricChargeDensity left, ElectricChargeDensity right);
    public static override bool op_LessThan(ElectricChargeDensity left, ElectricChargeDensity right);
    public static override bool op_GreaterThan(ElectricChargeDensity left, ElectricChargeDensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricChargeDensity other, ElectricChargeDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricChargeDensity left, ElectricChargeDensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricChargeDensity other, ElectricChargeDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricChargeDensity left, ElectricChargeDensity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricChargeDensity other, ElectricChargeDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricChargeDensity other, ElectricChargeDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricChargeDensity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricChargeDensity other);
    [ObsoleteAttribute("Use Equals(ElectricChargeDensity other, ElectricChargeDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricChargeDensity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricChargeDensity other, ElectricChargeDensity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricChargeDensityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricChargeDensity ToUnit(ElectricChargeDensityUnit unit);
    public ElectricChargeDensity ToUnit(ElectricChargeDensityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricChargeDensityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricChargeDensity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricChargeDensityUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricChargeDensityUnit>.ToUnit(ElectricChargeDensityUnit unit);
    private sealed virtual override IQuantity`1<ElectricChargeDensityUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricChargeDensityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricConductance : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricConductanceUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricConductanceUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricConductanceUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricConductanceUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricConductance <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricConductanceUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricConductanceUnit BaseUnit { get; }
    public static ElectricConductanceUnit[] Units { get; }
    public static ElectricConductance Zero { get; }
    public static ElectricConductance AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricConductanceUnit Unit { get; }
    public QuantityInfo`1<ElectricConductanceUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Kilosiemens { get; }
    public double Microsiemens { get; }
    public double Millisiemens { get; }
    public double Nanosiemens { get; }
    public double Siemens { get; }
    private static ElectricConductance();
    public ElectricConductance(double value, ElectricConductanceUnit unit);
    public ElectricConductance(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricConductanceUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricConductanceUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricConductanceUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricConductance get_Zero();
    public static override ElectricConductance get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricConductanceUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricConductanceUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Kilosiemens();
    public double get_Microsiemens();
    public double get_Millisiemens();
    public double get_Nanosiemens();
    public double get_Siemens();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricConductanceUnit unit);
    public static string GetAbbreviation(ElectricConductanceUnit unit, IFormatProvider provider);
    public static ElectricConductance FromKilosiemens(double value);
    public static ElectricConductance FromMicrosiemens(double value);
    public static ElectricConductance FromMillisiemens(double value);
    public static ElectricConductance FromNanosiemens(double value);
    public static ElectricConductance FromSiemens(double value);
    public static ElectricConductance From(double value, ElectricConductanceUnit fromUnit);
    public static ElectricConductance Parse(string str);
    public static override ElectricConductance Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricConductance& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricConductance& result);
    public static ElectricConductanceUnit ParseUnit(string str);
    public static ElectricConductanceUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricConductanceUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricConductanceUnit& unit);
    public static override ElectricConductance op_UnaryNegation(ElectricConductance right);
    public static override ElectricConductance op_Addition(ElectricConductance left, ElectricConductance right);
    public static override ElectricConductance op_Subtraction(ElectricConductance left, ElectricConductance right);
    public static ElectricConductance op_Multiply(double left, ElectricConductance right);
    public static override ElectricConductance op_Multiply(ElectricConductance left, double right);
    public static override ElectricConductance op_Division(ElectricConductance left, double right);
    public static double op_Division(ElectricConductance left, ElectricConductance right);
    public static override bool op_LessThanOrEqual(ElectricConductance left, ElectricConductance right);
    public static override bool op_GreaterThanOrEqual(ElectricConductance left, ElectricConductance right);
    public static override bool op_LessThan(ElectricConductance left, ElectricConductance right);
    public static override bool op_GreaterThan(ElectricConductance left, ElectricConductance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricConductance other, ElectricConductance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricConductance left, ElectricConductance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricConductance other, ElectricConductance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricConductance left, ElectricConductance right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricConductance other, ElectricConductance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricConductance other, ElectricConductance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricConductance other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricConductance other);
    [ObsoleteAttribute("Use Equals(ElectricConductance other, ElectricConductance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricConductance other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricConductance other, ElectricConductance tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricConductanceUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricConductance ToUnit(ElectricConductanceUnit unit);
    public ElectricConductance ToUnit(ElectricConductanceUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricConductanceUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricConductance ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricConductanceUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricConductanceUnit>.ToUnit(ElectricConductanceUnit unit);
    private sealed virtual override IQuantity`1<ElectricConductanceUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricConductanceUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricConductivity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricConductivityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricConductivityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricConductivityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricConductivityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricConductivity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricConductivityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricConductivityUnit BaseUnit { get; }
    public static ElectricConductivityUnit[] Units { get; }
    public static ElectricConductivity Zero { get; }
    public static ElectricConductivity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricConductivityUnit Unit { get; }
    public QuantityInfo`1<ElectricConductivityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double MicrosiemensPerCentimeter { get; }
    public double MillisiemensPerCentimeter { get; }
    public double SiemensPerCentimeter { get; }
    public double SiemensPerFoot { get; }
    public double SiemensPerInch { get; }
    public double SiemensPerMeter { get; }
    private static ElectricConductivity();
    public ElectricConductivity(double value, ElectricConductivityUnit unit);
    public ElectricConductivity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricConductivityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricConductivityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricConductivityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricConductivity get_Zero();
    public static override ElectricConductivity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricConductivityUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricConductivityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_MicrosiemensPerCentimeter();
    public double get_MillisiemensPerCentimeter();
    public double get_SiemensPerCentimeter();
    public double get_SiemensPerFoot();
    public double get_SiemensPerInch();
    public double get_SiemensPerMeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricConductivityUnit unit);
    public static string GetAbbreviation(ElectricConductivityUnit unit, IFormatProvider provider);
    public static ElectricConductivity FromMicrosiemensPerCentimeter(double value);
    public static ElectricConductivity FromMillisiemensPerCentimeter(double value);
    public static ElectricConductivity FromSiemensPerCentimeter(double value);
    public static ElectricConductivity FromSiemensPerFoot(double value);
    public static ElectricConductivity FromSiemensPerInch(double value);
    public static ElectricConductivity FromSiemensPerMeter(double value);
    public static ElectricConductivity From(double value, ElectricConductivityUnit fromUnit);
    public static ElectricConductivity Parse(string str);
    public static override ElectricConductivity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricConductivity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricConductivity& result);
    public static ElectricConductivityUnit ParseUnit(string str);
    public static ElectricConductivityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricConductivityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricConductivityUnit& unit);
    public static override ElectricConductivity op_UnaryNegation(ElectricConductivity right);
    public static override ElectricConductivity op_Addition(ElectricConductivity left, ElectricConductivity right);
    public static override ElectricConductivity op_Subtraction(ElectricConductivity left, ElectricConductivity right);
    public static ElectricConductivity op_Multiply(double left, ElectricConductivity right);
    public static override ElectricConductivity op_Multiply(ElectricConductivity left, double right);
    public static override ElectricConductivity op_Division(ElectricConductivity left, double right);
    public static double op_Division(ElectricConductivity left, ElectricConductivity right);
    public ElectricResistivity Inverse();
    public static override bool op_LessThanOrEqual(ElectricConductivity left, ElectricConductivity right);
    public static override bool op_GreaterThanOrEqual(ElectricConductivity left, ElectricConductivity right);
    public static override bool op_LessThan(ElectricConductivity left, ElectricConductivity right);
    public static override bool op_GreaterThan(ElectricConductivity left, ElectricConductivity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricConductivity other, ElectricConductivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricConductivity left, ElectricConductivity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricConductivity other, ElectricConductivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricConductivity left, ElectricConductivity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricConductivity other, ElectricConductivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricConductivity other, ElectricConductivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricConductivity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricConductivity other);
    [ObsoleteAttribute("Use Equals(ElectricConductivity other, ElectricConductivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricConductivity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricConductivity other, ElectricConductivity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricConductivityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricConductivity ToUnit(ElectricConductivityUnit unit);
    public ElectricConductivity ToUnit(ElectricConductivityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricConductivityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricConductivity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricConductivityUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricConductivityUnit>.ToUnit(ElectricConductivityUnit unit);
    private sealed virtual override IQuantity`1<ElectricConductivityUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricConductivityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricCurrent : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricCurrentUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricCurrentUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricCurrentUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricCurrentUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricCurrent <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricCurrentUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricCurrentUnit BaseUnit { get; }
    public static ElectricCurrentUnit[] Units { get; }
    public static ElectricCurrent Zero { get; }
    public static ElectricCurrent AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricCurrentUnit Unit { get; }
    public QuantityInfo`1<ElectricCurrentUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Amperes { get; }
    public double Centiamperes { get; }
    public double Femtoamperes { get; }
    public double Kiloamperes { get; }
    public double Megaamperes { get; }
    public double Microamperes { get; }
    public double Milliamperes { get; }
    public double Nanoamperes { get; }
    public double Picoamperes { get; }
    private static ElectricCurrent();
    public ElectricCurrent(double value, ElectricCurrentUnit unit);
    public ElectricCurrent(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricCurrentUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricCurrentUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricCurrentUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricCurrent get_Zero();
    public static override ElectricCurrent get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricCurrentUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricCurrentUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Amperes();
    public double get_Centiamperes();
    public double get_Femtoamperes();
    public double get_Kiloamperes();
    public double get_Megaamperes();
    public double get_Microamperes();
    public double get_Milliamperes();
    public double get_Nanoamperes();
    public double get_Picoamperes();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricCurrentUnit unit);
    public static string GetAbbreviation(ElectricCurrentUnit unit, IFormatProvider provider);
    public static ElectricCurrent FromAmperes(double value);
    public static ElectricCurrent FromCentiamperes(double value);
    public static ElectricCurrent FromFemtoamperes(double value);
    public static ElectricCurrent FromKiloamperes(double value);
    public static ElectricCurrent FromMegaamperes(double value);
    public static ElectricCurrent FromMicroamperes(double value);
    public static ElectricCurrent FromMilliamperes(double value);
    public static ElectricCurrent FromNanoamperes(double value);
    public static ElectricCurrent FromPicoamperes(double value);
    public static ElectricCurrent From(double value, ElectricCurrentUnit fromUnit);
    public static ElectricCurrent Parse(string str);
    public static override ElectricCurrent Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricCurrent& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricCurrent& result);
    public static ElectricCurrentUnit ParseUnit(string str);
    public static ElectricCurrentUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricCurrentUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricCurrentUnit& unit);
    public static override ElectricCurrent op_UnaryNegation(ElectricCurrent right);
    public static override ElectricCurrent op_Addition(ElectricCurrent left, ElectricCurrent right);
    public static override ElectricCurrent op_Subtraction(ElectricCurrent left, ElectricCurrent right);
    public static ElectricCurrent op_Multiply(double left, ElectricCurrent right);
    public static override ElectricCurrent op_Multiply(ElectricCurrent left, double right);
    public static override ElectricCurrent op_Division(ElectricCurrent left, double right);
    public static double op_Division(ElectricCurrent left, ElectricCurrent right);
    public static override Duration op_Division(ElectricCurrent electricCurrent, ElectricCurrentGradient electricCurrentGradient);
    public static override ElectricCharge op_Multiply(ElectricCurrent electricCurrent, Duration duration);
    public static override ElectricCurrentGradient op_Division(ElectricCurrent electricCurrent, Duration duration);
    public static override ElectricPotential op_Multiply(ElectricCurrent electricCurrent, ElectricResistance electricResistance);
    public static override Power op_Multiply(ElectricCurrent electricCurrent, ElectricPotential electricPotential);
    public static override bool op_LessThanOrEqual(ElectricCurrent left, ElectricCurrent right);
    public static override bool op_GreaterThanOrEqual(ElectricCurrent left, ElectricCurrent right);
    public static override bool op_LessThan(ElectricCurrent left, ElectricCurrent right);
    public static override bool op_GreaterThan(ElectricCurrent left, ElectricCurrent right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricCurrent other, ElectricCurrent tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricCurrent left, ElectricCurrent right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricCurrent other, ElectricCurrent tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricCurrent left, ElectricCurrent right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricCurrent other, ElectricCurrent tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricCurrent other, ElectricCurrent tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricCurrent other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricCurrent other);
    [ObsoleteAttribute("Use Equals(ElectricCurrent other, ElectricCurrent tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricCurrent other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricCurrent other, ElectricCurrent tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricCurrentUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricCurrent ToUnit(ElectricCurrentUnit unit);
    public ElectricCurrent ToUnit(ElectricCurrentUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricCurrentUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricCurrent ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricCurrentUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricCurrentUnit>.ToUnit(ElectricCurrentUnit unit);
    private sealed virtual override IQuantity`1<ElectricCurrentUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricCurrentUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricCurrentDensity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricCurrentDensityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricCurrentDensityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricCurrentDensityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricCurrentDensityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricCurrentDensity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricCurrentDensityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricCurrentDensityUnit BaseUnit { get; }
    public static ElectricCurrentDensityUnit[] Units { get; }
    public static ElectricCurrentDensity Zero { get; }
    public static ElectricCurrentDensity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricCurrentDensityUnit Unit { get; }
    public QuantityInfo`1<ElectricCurrentDensityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double AmperesPerSquareFoot { get; }
    public double AmperesPerSquareInch { get; }
    public double AmperesPerSquareMeter { get; }
    private static ElectricCurrentDensity();
    public ElectricCurrentDensity(double value, ElectricCurrentDensityUnit unit);
    public ElectricCurrentDensity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricCurrentDensityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricCurrentDensityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricCurrentDensityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricCurrentDensity get_Zero();
    public static override ElectricCurrentDensity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricCurrentDensityUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricCurrentDensityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_AmperesPerSquareFoot();
    public double get_AmperesPerSquareInch();
    public double get_AmperesPerSquareMeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricCurrentDensityUnit unit);
    public static string GetAbbreviation(ElectricCurrentDensityUnit unit, IFormatProvider provider);
    public static ElectricCurrentDensity FromAmperesPerSquareFoot(double value);
    public static ElectricCurrentDensity FromAmperesPerSquareInch(double value);
    public static ElectricCurrentDensity FromAmperesPerSquareMeter(double value);
    public static ElectricCurrentDensity From(double value, ElectricCurrentDensityUnit fromUnit);
    public static ElectricCurrentDensity Parse(string str);
    public static override ElectricCurrentDensity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricCurrentDensity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricCurrentDensity& result);
    public static ElectricCurrentDensityUnit ParseUnit(string str);
    public static ElectricCurrentDensityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricCurrentDensityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricCurrentDensityUnit& unit);
    public static override ElectricCurrentDensity op_UnaryNegation(ElectricCurrentDensity right);
    public static override ElectricCurrentDensity op_Addition(ElectricCurrentDensity left, ElectricCurrentDensity right);
    public static override ElectricCurrentDensity op_Subtraction(ElectricCurrentDensity left, ElectricCurrentDensity right);
    public static ElectricCurrentDensity op_Multiply(double left, ElectricCurrentDensity right);
    public static override ElectricCurrentDensity op_Multiply(ElectricCurrentDensity left, double right);
    public static override ElectricCurrentDensity op_Division(ElectricCurrentDensity left, double right);
    public static double op_Division(ElectricCurrentDensity left, ElectricCurrentDensity right);
    public static override bool op_LessThanOrEqual(ElectricCurrentDensity left, ElectricCurrentDensity right);
    public static override bool op_GreaterThanOrEqual(ElectricCurrentDensity left, ElectricCurrentDensity right);
    public static override bool op_LessThan(ElectricCurrentDensity left, ElectricCurrentDensity right);
    public static override bool op_GreaterThan(ElectricCurrentDensity left, ElectricCurrentDensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricCurrentDensity other, ElectricCurrentDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricCurrentDensity left, ElectricCurrentDensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricCurrentDensity other, ElectricCurrentDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricCurrentDensity left, ElectricCurrentDensity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricCurrentDensity other, ElectricCurrentDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricCurrentDensity other, ElectricCurrentDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricCurrentDensity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricCurrentDensity other);
    [ObsoleteAttribute("Use Equals(ElectricCurrentDensity other, ElectricCurrentDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricCurrentDensity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricCurrentDensity other, ElectricCurrentDensity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricCurrentDensityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricCurrentDensity ToUnit(ElectricCurrentDensityUnit unit);
    public ElectricCurrentDensity ToUnit(ElectricCurrentDensityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricCurrentDensityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricCurrentDensity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricCurrentDensityUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricCurrentDensityUnit>.ToUnit(ElectricCurrentDensityUnit unit);
    private sealed virtual override IQuantity`1<ElectricCurrentDensityUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricCurrentDensityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricCurrentGradient : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricCurrentGradientUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricCurrentGradientUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricCurrentGradientUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricCurrentGradientUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricCurrentGradient <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricCurrentGradientUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricCurrentGradientUnit BaseUnit { get; }
    public static ElectricCurrentGradientUnit[] Units { get; }
    public static ElectricCurrentGradient Zero { get; }
    public static ElectricCurrentGradient AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricCurrentGradientUnit Unit { get; }
    public QuantityInfo`1<ElectricCurrentGradientUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double AmperesPerMicrosecond { get; }
    public double AmperesPerMillisecond { get; }
    public double AmperesPerMinute { get; }
    public double AmperesPerNanosecond { get; }
    public double AmperesPerSecond { get; }
    public double MilliamperesPerMinute { get; }
    public double MilliamperesPerSecond { get; }
    private static ElectricCurrentGradient();
    public ElectricCurrentGradient(double value, ElectricCurrentGradientUnit unit);
    public ElectricCurrentGradient(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricCurrentGradientUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricCurrentGradientUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricCurrentGradientUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricCurrentGradient get_Zero();
    public static override ElectricCurrentGradient get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricCurrentGradientUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricCurrentGradientUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_AmperesPerMicrosecond();
    public double get_AmperesPerMillisecond();
    public double get_AmperesPerMinute();
    public double get_AmperesPerNanosecond();
    public double get_AmperesPerSecond();
    public double get_MilliamperesPerMinute();
    public double get_MilliamperesPerSecond();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricCurrentGradientUnit unit);
    public static string GetAbbreviation(ElectricCurrentGradientUnit unit, IFormatProvider provider);
    public static ElectricCurrentGradient FromAmperesPerMicrosecond(double value);
    public static ElectricCurrentGradient FromAmperesPerMillisecond(double value);
    public static ElectricCurrentGradient FromAmperesPerMinute(double value);
    public static ElectricCurrentGradient FromAmperesPerNanosecond(double value);
    public static ElectricCurrentGradient FromAmperesPerSecond(double value);
    public static ElectricCurrentGradient FromMilliamperesPerMinute(double value);
    public static ElectricCurrentGradient FromMilliamperesPerSecond(double value);
    public static ElectricCurrentGradient From(double value, ElectricCurrentGradientUnit fromUnit);
    public static ElectricCurrentGradient Parse(string str);
    public static override ElectricCurrentGradient Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricCurrentGradient& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricCurrentGradient& result);
    public static ElectricCurrentGradientUnit ParseUnit(string str);
    public static ElectricCurrentGradientUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricCurrentGradientUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricCurrentGradientUnit& unit);
    public static override ElectricCurrentGradient op_UnaryNegation(ElectricCurrentGradient right);
    public static override ElectricCurrentGradient op_Addition(ElectricCurrentGradient left, ElectricCurrentGradient right);
    public static override ElectricCurrentGradient op_Subtraction(ElectricCurrentGradient left, ElectricCurrentGradient right);
    public static ElectricCurrentGradient op_Multiply(double left, ElectricCurrentGradient right);
    public static override ElectricCurrentGradient op_Multiply(ElectricCurrentGradient left, double right);
    public static override ElectricCurrentGradient op_Division(ElectricCurrentGradient left, double right);
    public static double op_Division(ElectricCurrentGradient left, ElectricCurrentGradient right);
    public static override ElectricCurrent op_Multiply(ElectricCurrentGradient electricCurrentGradient, Duration duration);
    public static override bool op_LessThanOrEqual(ElectricCurrentGradient left, ElectricCurrentGradient right);
    public static override bool op_GreaterThanOrEqual(ElectricCurrentGradient left, ElectricCurrentGradient right);
    public static override bool op_LessThan(ElectricCurrentGradient left, ElectricCurrentGradient right);
    public static override bool op_GreaterThan(ElectricCurrentGradient left, ElectricCurrentGradient right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricCurrentGradient other, ElectricCurrentGradient tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricCurrentGradient left, ElectricCurrentGradient right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricCurrentGradient other, ElectricCurrentGradient tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricCurrentGradient left, ElectricCurrentGradient right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricCurrentGradient other, ElectricCurrentGradient tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricCurrentGradient other, ElectricCurrentGradient tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricCurrentGradient other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricCurrentGradient other);
    [ObsoleteAttribute("Use Equals(ElectricCurrentGradient other, ElectricCurrentGradient tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricCurrentGradient other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricCurrentGradient other, ElectricCurrentGradient tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricCurrentGradientUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricCurrentGradient ToUnit(ElectricCurrentGradientUnit unit);
    public ElectricCurrentGradient ToUnit(ElectricCurrentGradientUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricCurrentGradientUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricCurrentGradient ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricCurrentGradientUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricCurrentGradientUnit>.ToUnit(ElectricCurrentGradientUnit unit);
    private sealed virtual override IQuantity`1<ElectricCurrentGradientUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricCurrentGradientUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricField : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricFieldUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricFieldUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricFieldUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricFieldUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricField <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricFieldUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricFieldUnit BaseUnit { get; }
    public static ElectricFieldUnit[] Units { get; }
    public static ElectricField Zero { get; }
    public static ElectricField AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricFieldUnit Unit { get; }
    public QuantityInfo`1<ElectricFieldUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double VoltsPerMeter { get; }
    private static ElectricField();
    public ElectricField(double value, ElectricFieldUnit unit);
    public ElectricField(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricFieldUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricFieldUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricFieldUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricField get_Zero();
    public static override ElectricField get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricFieldUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricFieldUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_VoltsPerMeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricFieldUnit unit);
    public static string GetAbbreviation(ElectricFieldUnit unit, IFormatProvider provider);
    public static ElectricField FromVoltsPerMeter(double value);
    public static ElectricField From(double value, ElectricFieldUnit fromUnit);
    public static ElectricField Parse(string str);
    public static override ElectricField Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricField& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricField& result);
    public static ElectricFieldUnit ParseUnit(string str);
    public static ElectricFieldUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricFieldUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricFieldUnit& unit);
    public static override ElectricField op_UnaryNegation(ElectricField right);
    public static override ElectricField op_Addition(ElectricField left, ElectricField right);
    public static override ElectricField op_Subtraction(ElectricField left, ElectricField right);
    public static ElectricField op_Multiply(double left, ElectricField right);
    public static override ElectricField op_Multiply(ElectricField left, double right);
    public static override ElectricField op_Division(ElectricField left, double right);
    public static double op_Division(ElectricField left, ElectricField right);
    public static override bool op_LessThanOrEqual(ElectricField left, ElectricField right);
    public static override bool op_GreaterThanOrEqual(ElectricField left, ElectricField right);
    public static override bool op_LessThan(ElectricField left, ElectricField right);
    public static override bool op_GreaterThan(ElectricField left, ElectricField right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricField other, ElectricField tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricField left, ElectricField right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricField other, ElectricField tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricField left, ElectricField right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricField other, ElectricField tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricField other, ElectricField tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricField other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricField other);
    [ObsoleteAttribute("Use Equals(ElectricField other, ElectricField tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricField other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricField other, ElectricField tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricFieldUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricField ToUnit(ElectricFieldUnit unit);
    public ElectricField ToUnit(ElectricFieldUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricFieldUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricField ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricFieldUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricFieldUnit>.ToUnit(ElectricFieldUnit unit);
    private sealed virtual override IQuantity`1<ElectricFieldUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricFieldUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricInductance : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricInductanceUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricInductanceUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricInductanceUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricInductanceUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricInductance <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricInductanceUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricInductanceUnit BaseUnit { get; }
    public static ElectricInductanceUnit[] Units { get; }
    public static ElectricInductance Zero { get; }
    public static ElectricInductance AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricInductanceUnit Unit { get; }
    public QuantityInfo`1<ElectricInductanceUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Henries { get; }
    public double Microhenries { get; }
    public double Millihenries { get; }
    public double Nanohenries { get; }
    public double Picohenries { get; }
    private static ElectricInductance();
    public ElectricInductance(double value, ElectricInductanceUnit unit);
    public ElectricInductance(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricInductanceUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricInductanceUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricInductanceUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricInductance get_Zero();
    public static override ElectricInductance get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricInductanceUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricInductanceUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Henries();
    public double get_Microhenries();
    public double get_Millihenries();
    public double get_Nanohenries();
    public double get_Picohenries();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricInductanceUnit unit);
    public static string GetAbbreviation(ElectricInductanceUnit unit, IFormatProvider provider);
    public static ElectricInductance FromHenries(double value);
    public static ElectricInductance FromMicrohenries(double value);
    public static ElectricInductance FromMillihenries(double value);
    public static ElectricInductance FromNanohenries(double value);
    public static ElectricInductance FromPicohenries(double value);
    public static ElectricInductance From(double value, ElectricInductanceUnit fromUnit);
    public static ElectricInductance Parse(string str);
    public static override ElectricInductance Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricInductance& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricInductance& result);
    public static ElectricInductanceUnit ParseUnit(string str);
    public static ElectricInductanceUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricInductanceUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricInductanceUnit& unit);
    public static override ElectricInductance op_UnaryNegation(ElectricInductance right);
    public static override ElectricInductance op_Addition(ElectricInductance left, ElectricInductance right);
    public static override ElectricInductance op_Subtraction(ElectricInductance left, ElectricInductance right);
    public static ElectricInductance op_Multiply(double left, ElectricInductance right);
    public static override ElectricInductance op_Multiply(ElectricInductance left, double right);
    public static override ElectricInductance op_Division(ElectricInductance left, double right);
    public static double op_Division(ElectricInductance left, ElectricInductance right);
    public static override bool op_LessThanOrEqual(ElectricInductance left, ElectricInductance right);
    public static override bool op_GreaterThanOrEqual(ElectricInductance left, ElectricInductance right);
    public static override bool op_LessThan(ElectricInductance left, ElectricInductance right);
    public static override bool op_GreaterThan(ElectricInductance left, ElectricInductance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricInductance other, ElectricInductance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricInductance left, ElectricInductance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricInductance other, ElectricInductance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricInductance left, ElectricInductance right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricInductance other, ElectricInductance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricInductance other, ElectricInductance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricInductance other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricInductance other);
    [ObsoleteAttribute("Use Equals(ElectricInductance other, ElectricInductance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricInductance other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricInductance other, ElectricInductance tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricInductanceUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricInductance ToUnit(ElectricInductanceUnit unit);
    public ElectricInductance ToUnit(ElectricInductanceUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricInductanceUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricInductance ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricInductanceUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricInductanceUnit>.ToUnit(ElectricInductanceUnit unit);
    private sealed virtual override IQuantity`1<ElectricInductanceUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricInductanceUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricPotential : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricPotentialUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricPotentialUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricPotentialUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricPotentialUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricPotential <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricPotentialUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricPotentialUnit BaseUnit { get; }
    public static ElectricPotentialUnit[] Units { get; }
    public static ElectricPotential Zero { get; }
    public static ElectricPotential AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricPotentialUnit Unit { get; }
    public QuantityInfo`1<ElectricPotentialUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Kilovolts { get; }
    public double Megavolts { get; }
    public double Microvolts { get; }
    public double Millivolts { get; }
    public double Nanovolts { get; }
    public double Volts { get; }
    private static ElectricPotential();
    public ElectricPotential(double value, ElectricPotentialUnit unit);
    public ElectricPotential(double value, UnitSystem unitSystem);
    public AmplitudeRatio ToAmplitudeRatio();
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricPotentialUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricPotentialUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricPotentialUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricPotential get_Zero();
    public static override ElectricPotential get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricPotentialUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricPotentialUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Kilovolts();
    public double get_Megavolts();
    public double get_Microvolts();
    public double get_Millivolts();
    public double get_Nanovolts();
    public double get_Volts();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricPotentialUnit unit);
    public static string GetAbbreviation(ElectricPotentialUnit unit, IFormatProvider provider);
    public static ElectricPotential FromKilovolts(double value);
    public static ElectricPotential FromMegavolts(double value);
    public static ElectricPotential FromMicrovolts(double value);
    public static ElectricPotential FromMillivolts(double value);
    public static ElectricPotential FromNanovolts(double value);
    public static ElectricPotential FromVolts(double value);
    public static ElectricPotential From(double value, ElectricPotentialUnit fromUnit);
    public static ElectricPotential Parse(string str);
    public static override ElectricPotential Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricPotential& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricPotential& result);
    public static ElectricPotentialUnit ParseUnit(string str);
    public static ElectricPotentialUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricPotentialUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricPotentialUnit& unit);
    public static override ElectricPotential op_UnaryNegation(ElectricPotential right);
    public static override ElectricPotential op_Addition(ElectricPotential left, ElectricPotential right);
    public static override ElectricPotential op_Subtraction(ElectricPotential left, ElectricPotential right);
    public static ElectricPotential op_Multiply(double left, ElectricPotential right);
    public static override ElectricPotential op_Multiply(ElectricPotential left, double right);
    public static override ElectricPotential op_Division(ElectricPotential left, double right);
    public static double op_Division(ElectricPotential left, ElectricPotential right);
    public static override ElectricCurrent op_Division(ElectricPotential electricPotential, ElectricResistance electricResistance);
    public static override ElectricResistance op_Division(ElectricPotential electricPotential, ElectricCurrent electricCurrent);
    public static override Energy op_Multiply(ElectricPotential electricPotential, ElectricCharge electricCharge);
    public static override Power op_Multiply(ElectricPotential electricPotential, ElectricCurrent electricCurrent);
    public static override bool op_LessThanOrEqual(ElectricPotential left, ElectricPotential right);
    public static override bool op_GreaterThanOrEqual(ElectricPotential left, ElectricPotential right);
    public static override bool op_LessThan(ElectricPotential left, ElectricPotential right);
    public static override bool op_GreaterThan(ElectricPotential left, ElectricPotential right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricPotential other, ElectricPotential tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricPotential left, ElectricPotential right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricPotential other, ElectricPotential tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricPotential left, ElectricPotential right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricPotential other, ElectricPotential tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricPotential other, ElectricPotential tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricPotential other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricPotential other);
    [ObsoleteAttribute("Use Equals(ElectricPotential other, ElectricPotential tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricPotential other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricPotential other, ElectricPotential tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricPotentialUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricPotential ToUnit(ElectricPotentialUnit unit);
    public ElectricPotential ToUnit(ElectricPotentialUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricPotentialUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricPotential ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricPotentialUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricPotentialUnit>.ToUnit(ElectricPotentialUnit unit);
    private sealed virtual override IQuantity`1<ElectricPotentialUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricPotentialUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricPotentialAc : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricPotentialAcUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricPotentialAcUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricPotentialAcUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricPotentialAcUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricPotentialAc <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricPotentialAcUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricPotentialAcUnit BaseUnit { get; }
    public static ElectricPotentialAcUnit[] Units { get; }
    public static ElectricPotentialAc Zero { get; }
    public static ElectricPotentialAc AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricPotentialAcUnit Unit { get; }
    public QuantityInfo`1<ElectricPotentialAcUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double KilovoltsAc { get; }
    public double MegavoltsAc { get; }
    public double MicrovoltsAc { get; }
    public double MillivoltsAc { get; }
    public double VoltsAc { get; }
    private static ElectricPotentialAc();
    public ElectricPotentialAc(double value, ElectricPotentialAcUnit unit);
    public ElectricPotentialAc(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricPotentialAcUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricPotentialAcUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricPotentialAcUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricPotentialAc get_Zero();
    public static override ElectricPotentialAc get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricPotentialAcUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricPotentialAcUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_KilovoltsAc();
    public double get_MegavoltsAc();
    public double get_MicrovoltsAc();
    public double get_MillivoltsAc();
    public double get_VoltsAc();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricPotentialAcUnit unit);
    public static string GetAbbreviation(ElectricPotentialAcUnit unit, IFormatProvider provider);
    public static ElectricPotentialAc FromKilovoltsAc(double value);
    public static ElectricPotentialAc FromMegavoltsAc(double value);
    public static ElectricPotentialAc FromMicrovoltsAc(double value);
    public static ElectricPotentialAc FromMillivoltsAc(double value);
    public static ElectricPotentialAc FromVoltsAc(double value);
    public static ElectricPotentialAc From(double value, ElectricPotentialAcUnit fromUnit);
    public static ElectricPotentialAc Parse(string str);
    public static override ElectricPotentialAc Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricPotentialAc& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricPotentialAc& result);
    public static ElectricPotentialAcUnit ParseUnit(string str);
    public static ElectricPotentialAcUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricPotentialAcUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricPotentialAcUnit& unit);
    public static override ElectricPotentialAc op_UnaryNegation(ElectricPotentialAc right);
    public static override ElectricPotentialAc op_Addition(ElectricPotentialAc left, ElectricPotentialAc right);
    public static override ElectricPotentialAc op_Subtraction(ElectricPotentialAc left, ElectricPotentialAc right);
    public static ElectricPotentialAc op_Multiply(double left, ElectricPotentialAc right);
    public static override ElectricPotentialAc op_Multiply(ElectricPotentialAc left, double right);
    public static override ElectricPotentialAc op_Division(ElectricPotentialAc left, double right);
    public static double op_Division(ElectricPotentialAc left, ElectricPotentialAc right);
    public static override bool op_LessThanOrEqual(ElectricPotentialAc left, ElectricPotentialAc right);
    public static override bool op_GreaterThanOrEqual(ElectricPotentialAc left, ElectricPotentialAc right);
    public static override bool op_LessThan(ElectricPotentialAc left, ElectricPotentialAc right);
    public static override bool op_GreaterThan(ElectricPotentialAc left, ElectricPotentialAc right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricPotentialAc other, ElectricPotentialAc tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricPotentialAc left, ElectricPotentialAc right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricPotentialAc other, ElectricPotentialAc tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricPotentialAc left, ElectricPotentialAc right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricPotentialAc other, ElectricPotentialAc tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricPotentialAc other, ElectricPotentialAc tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricPotentialAc other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricPotentialAc other);
    [ObsoleteAttribute("Use Equals(ElectricPotentialAc other, ElectricPotentialAc tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricPotentialAc other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricPotentialAc other, ElectricPotentialAc tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricPotentialAcUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricPotentialAc ToUnit(ElectricPotentialAcUnit unit);
    public ElectricPotentialAc ToUnit(ElectricPotentialAcUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricPotentialAcUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricPotentialAc ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricPotentialAcUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricPotentialAcUnit>.ToUnit(ElectricPotentialAcUnit unit);
    private sealed virtual override IQuantity`1<ElectricPotentialAcUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricPotentialAcUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricPotentialChangeRate : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricPotentialChangeRateUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricPotentialChangeRateUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricPotentialChangeRateUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricPotentialChangeRateUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricPotentialChangeRate <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricPotentialChangeRateUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricPotentialChangeRateUnit BaseUnit { get; }
    public static ElectricPotentialChangeRateUnit[] Units { get; }
    public static ElectricPotentialChangeRate Zero { get; }
    public static ElectricPotentialChangeRate AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricPotentialChangeRateUnit Unit { get; }
    public QuantityInfo`1<ElectricPotentialChangeRateUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double KilovoltsPerHour { get; }
    public double KilovoltsPerMicrosecond { get; }
    public double KilovoltsPerMinute { get; }
    public double KilovoltsPerSecond { get; }
    public double MegavoltsPerHour { get; }
    public double MegavoltsPerMicrosecond { get; }
    public double MegavoltsPerMinute { get; }
    public double MegavoltsPerSecond { get; }
    public double MicrovoltsPerHour { get; }
    public double MicrovoltsPerMicrosecond { get; }
    public double MicrovoltsPerMinute { get; }
    public double MicrovoltsPerSecond { get; }
    public double MillivoltsPerHour { get; }
    public double MillivoltsPerMicrosecond { get; }
    public double MillivoltsPerMinute { get; }
    public double MillivoltsPerSecond { get; }
    public double VoltsPerHour { get; }
    public double VoltsPerMicrosecond { get; }
    public double VoltsPerMinute { get; }
    public double VoltsPerSecond { get; }
    private static ElectricPotentialChangeRate();
    public ElectricPotentialChangeRate(double value, ElectricPotentialChangeRateUnit unit);
    public ElectricPotentialChangeRate(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricPotentialChangeRateUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricPotentialChangeRateUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricPotentialChangeRateUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricPotentialChangeRate get_Zero();
    public static override ElectricPotentialChangeRate get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricPotentialChangeRateUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricPotentialChangeRateUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_KilovoltsPerHour();
    public double get_KilovoltsPerMicrosecond();
    public double get_KilovoltsPerMinute();
    public double get_KilovoltsPerSecond();
    public double get_MegavoltsPerHour();
    public double get_MegavoltsPerMicrosecond();
    public double get_MegavoltsPerMinute();
    public double get_MegavoltsPerSecond();
    public double get_MicrovoltsPerHour();
    public double get_MicrovoltsPerMicrosecond();
    public double get_MicrovoltsPerMinute();
    public double get_MicrovoltsPerSecond();
    public double get_MillivoltsPerHour();
    public double get_MillivoltsPerMicrosecond();
    public double get_MillivoltsPerMinute();
    public double get_MillivoltsPerSecond();
    public double get_VoltsPerHour();
    public double get_VoltsPerMicrosecond();
    public double get_VoltsPerMinute();
    public double get_VoltsPerSecond();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricPotentialChangeRateUnit unit);
    public static string GetAbbreviation(ElectricPotentialChangeRateUnit unit, IFormatProvider provider);
    public static ElectricPotentialChangeRate FromKilovoltsPerHour(double value);
    public static ElectricPotentialChangeRate FromKilovoltsPerMicrosecond(double value);
    public static ElectricPotentialChangeRate FromKilovoltsPerMinute(double value);
    public static ElectricPotentialChangeRate FromKilovoltsPerSecond(double value);
    public static ElectricPotentialChangeRate FromMegavoltsPerHour(double value);
    public static ElectricPotentialChangeRate FromMegavoltsPerMicrosecond(double value);
    public static ElectricPotentialChangeRate FromMegavoltsPerMinute(double value);
    public static ElectricPotentialChangeRate FromMegavoltsPerSecond(double value);
    public static ElectricPotentialChangeRate FromMicrovoltsPerHour(double value);
    public static ElectricPotentialChangeRate FromMicrovoltsPerMicrosecond(double value);
    public static ElectricPotentialChangeRate FromMicrovoltsPerMinute(double value);
    public static ElectricPotentialChangeRate FromMicrovoltsPerSecond(double value);
    public static ElectricPotentialChangeRate FromMillivoltsPerHour(double value);
    public static ElectricPotentialChangeRate FromMillivoltsPerMicrosecond(double value);
    public static ElectricPotentialChangeRate FromMillivoltsPerMinute(double value);
    public static ElectricPotentialChangeRate FromMillivoltsPerSecond(double value);
    public static ElectricPotentialChangeRate FromVoltsPerHour(double value);
    public static ElectricPotentialChangeRate FromVoltsPerMicrosecond(double value);
    public static ElectricPotentialChangeRate FromVoltsPerMinute(double value);
    public static ElectricPotentialChangeRate FromVoltsPerSecond(double value);
    public static ElectricPotentialChangeRate From(double value, ElectricPotentialChangeRateUnit fromUnit);
    public static ElectricPotentialChangeRate Parse(string str);
    public static override ElectricPotentialChangeRate Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricPotentialChangeRate& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricPotentialChangeRate& result);
    public static ElectricPotentialChangeRateUnit ParseUnit(string str);
    public static ElectricPotentialChangeRateUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricPotentialChangeRateUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricPotentialChangeRateUnit& unit);
    public static override ElectricPotentialChangeRate op_UnaryNegation(ElectricPotentialChangeRate right);
    public static override ElectricPotentialChangeRate op_Addition(ElectricPotentialChangeRate left, ElectricPotentialChangeRate right);
    public static override ElectricPotentialChangeRate op_Subtraction(ElectricPotentialChangeRate left, ElectricPotentialChangeRate right);
    public static ElectricPotentialChangeRate op_Multiply(double left, ElectricPotentialChangeRate right);
    public static override ElectricPotentialChangeRate op_Multiply(ElectricPotentialChangeRate left, double right);
    public static override ElectricPotentialChangeRate op_Division(ElectricPotentialChangeRate left, double right);
    public static double op_Division(ElectricPotentialChangeRate left, ElectricPotentialChangeRate right);
    public static override bool op_LessThanOrEqual(ElectricPotentialChangeRate left, ElectricPotentialChangeRate right);
    public static override bool op_GreaterThanOrEqual(ElectricPotentialChangeRate left, ElectricPotentialChangeRate right);
    public static override bool op_LessThan(ElectricPotentialChangeRate left, ElectricPotentialChangeRate right);
    public static override bool op_GreaterThan(ElectricPotentialChangeRate left, ElectricPotentialChangeRate right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricPotentialChangeRate other, ElectricPotentialChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricPotentialChangeRate left, ElectricPotentialChangeRate right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricPotentialChangeRate other, ElectricPotentialChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricPotentialChangeRate left, ElectricPotentialChangeRate right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricPotentialChangeRate other, ElectricPotentialChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricPotentialChangeRate other, ElectricPotentialChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricPotentialChangeRate other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricPotentialChangeRate other);
    [ObsoleteAttribute("Use Equals(ElectricPotentialChangeRate other, ElectricPotentialChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricPotentialChangeRate other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricPotentialChangeRate other, ElectricPotentialChangeRate tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricPotentialChangeRateUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricPotentialChangeRate ToUnit(ElectricPotentialChangeRateUnit unit);
    public ElectricPotentialChangeRate ToUnit(ElectricPotentialChangeRateUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricPotentialChangeRateUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricPotentialChangeRate ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricPotentialChangeRateUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricPotentialChangeRateUnit>.ToUnit(ElectricPotentialChangeRateUnit unit);
    private sealed virtual override IQuantity`1<ElectricPotentialChangeRateUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricPotentialChangeRateUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricPotentialDc : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricPotentialDcUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricPotentialDcUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricPotentialDcUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricPotentialDcUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricPotentialDc <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricPotentialDcUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricPotentialDcUnit BaseUnit { get; }
    public static ElectricPotentialDcUnit[] Units { get; }
    public static ElectricPotentialDc Zero { get; }
    public static ElectricPotentialDc AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricPotentialDcUnit Unit { get; }
    public QuantityInfo`1<ElectricPotentialDcUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double KilovoltsDc { get; }
    public double MegavoltsDc { get; }
    public double MicrovoltsDc { get; }
    public double MillivoltsDc { get; }
    public double VoltsDc { get; }
    private static ElectricPotentialDc();
    public ElectricPotentialDc(double value, ElectricPotentialDcUnit unit);
    public ElectricPotentialDc(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricPotentialDcUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricPotentialDcUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricPotentialDcUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricPotentialDc get_Zero();
    public static override ElectricPotentialDc get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricPotentialDcUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricPotentialDcUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_KilovoltsDc();
    public double get_MegavoltsDc();
    public double get_MicrovoltsDc();
    public double get_MillivoltsDc();
    public double get_VoltsDc();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricPotentialDcUnit unit);
    public static string GetAbbreviation(ElectricPotentialDcUnit unit, IFormatProvider provider);
    public static ElectricPotentialDc FromKilovoltsDc(double value);
    public static ElectricPotentialDc FromMegavoltsDc(double value);
    public static ElectricPotentialDc FromMicrovoltsDc(double value);
    public static ElectricPotentialDc FromMillivoltsDc(double value);
    public static ElectricPotentialDc FromVoltsDc(double value);
    public static ElectricPotentialDc From(double value, ElectricPotentialDcUnit fromUnit);
    public static ElectricPotentialDc Parse(string str);
    public static override ElectricPotentialDc Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricPotentialDc& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricPotentialDc& result);
    public static ElectricPotentialDcUnit ParseUnit(string str);
    public static ElectricPotentialDcUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricPotentialDcUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricPotentialDcUnit& unit);
    public static override ElectricPotentialDc op_UnaryNegation(ElectricPotentialDc right);
    public static override ElectricPotentialDc op_Addition(ElectricPotentialDc left, ElectricPotentialDc right);
    public static override ElectricPotentialDc op_Subtraction(ElectricPotentialDc left, ElectricPotentialDc right);
    public static ElectricPotentialDc op_Multiply(double left, ElectricPotentialDc right);
    public static override ElectricPotentialDc op_Multiply(ElectricPotentialDc left, double right);
    public static override ElectricPotentialDc op_Division(ElectricPotentialDc left, double right);
    public static double op_Division(ElectricPotentialDc left, ElectricPotentialDc right);
    public static override bool op_LessThanOrEqual(ElectricPotentialDc left, ElectricPotentialDc right);
    public static override bool op_GreaterThanOrEqual(ElectricPotentialDc left, ElectricPotentialDc right);
    public static override bool op_LessThan(ElectricPotentialDc left, ElectricPotentialDc right);
    public static override bool op_GreaterThan(ElectricPotentialDc left, ElectricPotentialDc right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricPotentialDc other, ElectricPotentialDc tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricPotentialDc left, ElectricPotentialDc right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricPotentialDc other, ElectricPotentialDc tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricPotentialDc left, ElectricPotentialDc right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricPotentialDc other, ElectricPotentialDc tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricPotentialDc other, ElectricPotentialDc tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricPotentialDc other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricPotentialDc other);
    [ObsoleteAttribute("Use Equals(ElectricPotentialDc other, ElectricPotentialDc tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricPotentialDc other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricPotentialDc other, ElectricPotentialDc tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricPotentialDcUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricPotentialDc ToUnit(ElectricPotentialDcUnit unit);
    public ElectricPotentialDc ToUnit(ElectricPotentialDcUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricPotentialDcUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricPotentialDc ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricPotentialDcUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricPotentialDcUnit>.ToUnit(ElectricPotentialDcUnit unit);
    private sealed virtual override IQuantity`1<ElectricPotentialDcUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricPotentialDcUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricResistance : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricResistanceUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricResistanceUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricResistanceUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricResistanceUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricResistance <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricResistanceUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricResistanceUnit BaseUnit { get; }
    public static ElectricResistanceUnit[] Units { get; }
    public static ElectricResistance Zero { get; }
    public static ElectricResistance AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricResistanceUnit Unit { get; }
    public QuantityInfo`1<ElectricResistanceUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Gigaohms { get; }
    public double Kiloohms { get; }
    public double Megaohms { get; }
    public double Microohms { get; }
    public double Milliohms { get; }
    public double Ohms { get; }
    public double Teraohms { get; }
    private static ElectricResistance();
    public ElectricResistance(double value, ElectricResistanceUnit unit);
    public ElectricResistance(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricResistanceUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricResistanceUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricResistanceUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricResistance get_Zero();
    public static override ElectricResistance get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricResistanceUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricResistanceUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Gigaohms();
    public double get_Kiloohms();
    public double get_Megaohms();
    public double get_Microohms();
    public double get_Milliohms();
    public double get_Ohms();
    public double get_Teraohms();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricResistanceUnit unit);
    public static string GetAbbreviation(ElectricResistanceUnit unit, IFormatProvider provider);
    public static ElectricResistance FromGigaohms(double value);
    public static ElectricResistance FromKiloohms(double value);
    public static ElectricResistance FromMegaohms(double value);
    public static ElectricResistance FromMicroohms(double value);
    public static ElectricResistance FromMilliohms(double value);
    public static ElectricResistance FromOhms(double value);
    public static ElectricResistance FromTeraohms(double value);
    public static ElectricResistance From(double value, ElectricResistanceUnit fromUnit);
    public static ElectricResistance Parse(string str);
    public static override ElectricResistance Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricResistance& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricResistance& result);
    public static ElectricResistanceUnit ParseUnit(string str);
    public static ElectricResistanceUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricResistanceUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricResistanceUnit& unit);
    public static override ElectricResistance op_UnaryNegation(ElectricResistance right);
    public static override ElectricResistance op_Addition(ElectricResistance left, ElectricResistance right);
    public static override ElectricResistance op_Subtraction(ElectricResistance left, ElectricResistance right);
    public static ElectricResistance op_Multiply(double left, ElectricResistance right);
    public static override ElectricResistance op_Multiply(ElectricResistance left, double right);
    public static override ElectricResistance op_Division(ElectricResistance left, double right);
    public static double op_Division(ElectricResistance left, ElectricResistance right);
    public static override ElectricPotential op_Multiply(ElectricResistance electricResistance, ElectricCurrent electricCurrent);
    public static override bool op_LessThanOrEqual(ElectricResistance left, ElectricResistance right);
    public static override bool op_GreaterThanOrEqual(ElectricResistance left, ElectricResistance right);
    public static override bool op_LessThan(ElectricResistance left, ElectricResistance right);
    public static override bool op_GreaterThan(ElectricResistance left, ElectricResistance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricResistance other, ElectricResistance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricResistance left, ElectricResistance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricResistance other, ElectricResistance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricResistance left, ElectricResistance right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricResistance other, ElectricResistance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricResistance other, ElectricResistance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricResistance other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricResistance other);
    [ObsoleteAttribute("Use Equals(ElectricResistance other, ElectricResistance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricResistance other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricResistance other, ElectricResistance tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricResistanceUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricResistance ToUnit(ElectricResistanceUnit unit);
    public ElectricResistance ToUnit(ElectricResistanceUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricResistanceUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricResistance ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricResistanceUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricResistanceUnit>.ToUnit(ElectricResistanceUnit unit);
    private sealed virtual override IQuantity`1<ElectricResistanceUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricResistanceUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricResistivity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricResistivityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricResistivityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricResistivityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricResistivityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricResistivity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricResistivityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricResistivityUnit BaseUnit { get; }
    public static ElectricResistivityUnit[] Units { get; }
    public static ElectricResistivity Zero { get; }
    public static ElectricResistivity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricResistivityUnit Unit { get; }
    public QuantityInfo`1<ElectricResistivityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double KiloohmsCentimeter { get; }
    public double KiloohmMeters { get; }
    public double MegaohmsCentimeter { get; }
    public double MegaohmMeters { get; }
    public double MicroohmsCentimeter { get; }
    public double MicroohmMeters { get; }
    public double MilliohmsCentimeter { get; }
    public double MilliohmMeters { get; }
    public double NanoohmsCentimeter { get; }
    public double NanoohmMeters { get; }
    public double OhmsCentimeter { get; }
    public double OhmMeters { get; }
    public double PicoohmsCentimeter { get; }
    public double PicoohmMeters { get; }
    private static ElectricResistivity();
    public ElectricResistivity(double value, ElectricResistivityUnit unit);
    public ElectricResistivity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricResistivityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricResistivityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricResistivityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricResistivity get_Zero();
    public static override ElectricResistivity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricResistivityUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricResistivityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_KiloohmsCentimeter();
    public double get_KiloohmMeters();
    public double get_MegaohmsCentimeter();
    public double get_MegaohmMeters();
    public double get_MicroohmsCentimeter();
    public double get_MicroohmMeters();
    public double get_MilliohmsCentimeter();
    public double get_MilliohmMeters();
    public double get_NanoohmsCentimeter();
    public double get_NanoohmMeters();
    public double get_OhmsCentimeter();
    public double get_OhmMeters();
    public double get_PicoohmsCentimeter();
    public double get_PicoohmMeters();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricResistivityUnit unit);
    public static string GetAbbreviation(ElectricResistivityUnit unit, IFormatProvider provider);
    public static ElectricResistivity FromKiloohmsCentimeter(double value);
    public static ElectricResistivity FromKiloohmMeters(double value);
    public static ElectricResistivity FromMegaohmsCentimeter(double value);
    public static ElectricResistivity FromMegaohmMeters(double value);
    public static ElectricResistivity FromMicroohmsCentimeter(double value);
    public static ElectricResistivity FromMicroohmMeters(double value);
    public static ElectricResistivity FromMilliohmsCentimeter(double value);
    public static ElectricResistivity FromMilliohmMeters(double value);
    public static ElectricResistivity FromNanoohmsCentimeter(double value);
    public static ElectricResistivity FromNanoohmMeters(double value);
    public static ElectricResistivity FromOhmsCentimeter(double value);
    public static ElectricResistivity FromOhmMeters(double value);
    public static ElectricResistivity FromPicoohmsCentimeter(double value);
    public static ElectricResistivity FromPicoohmMeters(double value);
    public static ElectricResistivity From(double value, ElectricResistivityUnit fromUnit);
    public static ElectricResistivity Parse(string str);
    public static override ElectricResistivity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricResistivity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricResistivity& result);
    public static ElectricResistivityUnit ParseUnit(string str);
    public static ElectricResistivityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricResistivityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricResistivityUnit& unit);
    public static override ElectricResistivity op_UnaryNegation(ElectricResistivity right);
    public static override ElectricResistivity op_Addition(ElectricResistivity left, ElectricResistivity right);
    public static override ElectricResistivity op_Subtraction(ElectricResistivity left, ElectricResistivity right);
    public static ElectricResistivity op_Multiply(double left, ElectricResistivity right);
    public static override ElectricResistivity op_Multiply(ElectricResistivity left, double right);
    public static override ElectricResistivity op_Division(ElectricResistivity left, double right);
    public static double op_Division(ElectricResistivity left, ElectricResistivity right);
    public ElectricConductivity Inverse();
    public static override bool op_LessThanOrEqual(ElectricResistivity left, ElectricResistivity right);
    public static override bool op_GreaterThanOrEqual(ElectricResistivity left, ElectricResistivity right);
    public static override bool op_LessThan(ElectricResistivity left, ElectricResistivity right);
    public static override bool op_GreaterThan(ElectricResistivity left, ElectricResistivity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricResistivity other, ElectricResistivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricResistivity left, ElectricResistivity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricResistivity other, ElectricResistivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricResistivity left, ElectricResistivity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricResistivity other, ElectricResistivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricResistivity other, ElectricResistivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricResistivity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricResistivity other);
    [ObsoleteAttribute("Use Equals(ElectricResistivity other, ElectricResistivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricResistivity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricResistivity other, ElectricResistivity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricResistivityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricResistivity ToUnit(ElectricResistivityUnit unit);
    public ElectricResistivity ToUnit(ElectricResistivityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricResistivityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricResistivity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricResistivityUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricResistivityUnit>.ToUnit(ElectricResistivityUnit unit);
    private sealed virtual override IQuantity`1<ElectricResistivityUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricResistivityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ElectricSurfaceChargeDensity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ElectricSurfaceChargeDensityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ElectricSurfaceChargeDensityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricSurfaceChargeDensityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricSurfaceChargeDensityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ElectricSurfaceChargeDensity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ElectricSurfaceChargeDensityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ElectricSurfaceChargeDensityUnit BaseUnit { get; }
    public static ElectricSurfaceChargeDensityUnit[] Units { get; }
    public static ElectricSurfaceChargeDensity Zero { get; }
    public static ElectricSurfaceChargeDensity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ElectricSurfaceChargeDensityUnit Unit { get; }
    public QuantityInfo`1<ElectricSurfaceChargeDensityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CoulombsPerSquareCentimeter { get; }
    public double CoulombsPerSquareInch { get; }
    public double CoulombsPerSquareMeter { get; }
    private static ElectricSurfaceChargeDensity();
    public ElectricSurfaceChargeDensity(double value, ElectricSurfaceChargeDensityUnit unit);
    public ElectricSurfaceChargeDensity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ElectricSurfaceChargeDensityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ElectricSurfaceChargeDensityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ElectricSurfaceChargeDensityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ElectricSurfaceChargeDensity get_Zero();
    public static override ElectricSurfaceChargeDensity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ElectricSurfaceChargeDensityUnit get_Unit();
    public sealed virtual QuantityInfo`1<ElectricSurfaceChargeDensityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CoulombsPerSquareCentimeter();
    public double get_CoulombsPerSquareInch();
    public double get_CoulombsPerSquareMeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ElectricSurfaceChargeDensityUnit unit);
    public static string GetAbbreviation(ElectricSurfaceChargeDensityUnit unit, IFormatProvider provider);
    public static ElectricSurfaceChargeDensity FromCoulombsPerSquareCentimeter(double value);
    public static ElectricSurfaceChargeDensity FromCoulombsPerSquareInch(double value);
    public static ElectricSurfaceChargeDensity FromCoulombsPerSquareMeter(double value);
    public static ElectricSurfaceChargeDensity From(double value, ElectricSurfaceChargeDensityUnit fromUnit);
    public static ElectricSurfaceChargeDensity Parse(string str);
    public static override ElectricSurfaceChargeDensity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ElectricSurfaceChargeDensity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ElectricSurfaceChargeDensity& result);
    public static ElectricSurfaceChargeDensityUnit ParseUnit(string str);
    public static ElectricSurfaceChargeDensityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ElectricSurfaceChargeDensityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ElectricSurfaceChargeDensityUnit& unit);
    public static override ElectricSurfaceChargeDensity op_UnaryNegation(ElectricSurfaceChargeDensity right);
    public static override ElectricSurfaceChargeDensity op_Addition(ElectricSurfaceChargeDensity left, ElectricSurfaceChargeDensity right);
    public static override ElectricSurfaceChargeDensity op_Subtraction(ElectricSurfaceChargeDensity left, ElectricSurfaceChargeDensity right);
    public static ElectricSurfaceChargeDensity op_Multiply(double left, ElectricSurfaceChargeDensity right);
    public static override ElectricSurfaceChargeDensity op_Multiply(ElectricSurfaceChargeDensity left, double right);
    public static override ElectricSurfaceChargeDensity op_Division(ElectricSurfaceChargeDensity left, double right);
    public static double op_Division(ElectricSurfaceChargeDensity left, ElectricSurfaceChargeDensity right);
    public static override bool op_LessThanOrEqual(ElectricSurfaceChargeDensity left, ElectricSurfaceChargeDensity right);
    public static override bool op_GreaterThanOrEqual(ElectricSurfaceChargeDensity left, ElectricSurfaceChargeDensity right);
    public static override bool op_LessThan(ElectricSurfaceChargeDensity left, ElectricSurfaceChargeDensity right);
    public static override bool op_GreaterThan(ElectricSurfaceChargeDensity left, ElectricSurfaceChargeDensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricSurfaceChargeDensity other, ElectricSurfaceChargeDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ElectricSurfaceChargeDensity left, ElectricSurfaceChargeDensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ElectricSurfaceChargeDensity other, ElectricSurfaceChargeDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ElectricSurfaceChargeDensity left, ElectricSurfaceChargeDensity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ElectricSurfaceChargeDensity other, ElectricSurfaceChargeDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ElectricSurfaceChargeDensity other, ElectricSurfaceChargeDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ElectricSurfaceChargeDensity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ElectricSurfaceChargeDensity other);
    [ObsoleteAttribute("Use Equals(ElectricSurfaceChargeDensity other, ElectricSurfaceChargeDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ElectricSurfaceChargeDensity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ElectricSurfaceChargeDensity other, ElectricSurfaceChargeDensity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ElectricSurfaceChargeDensityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ElectricSurfaceChargeDensity ToUnit(ElectricSurfaceChargeDensityUnit unit);
    public ElectricSurfaceChargeDensity ToUnit(ElectricSurfaceChargeDensityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ElectricSurfaceChargeDensityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ElectricSurfaceChargeDensity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ElectricSurfaceChargeDensityUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricSurfaceChargeDensityUnit>.ToUnit(ElectricSurfaceChargeDensityUnit unit);
    private sealed virtual override IQuantity`1<ElectricSurfaceChargeDensityUnit> UnitsNet.IQuantity<UnitsNet.Units.ElectricSurfaceChargeDensityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Energy : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<EnergyUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<EnergyUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnergyUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnergyUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Energy <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<EnergyUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static EnergyUnit BaseUnit { get; }
    public static EnergyUnit[] Units { get; }
    public static Energy Zero { get; }
    public static Energy AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public EnergyUnit Unit { get; }
    public QuantityInfo`1<EnergyUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double BritishThermalUnits { get; }
    public double Calories { get; }
    public double DecathermsEc { get; }
    public double DecathermsImperial { get; }
    public double DecathermsUs { get; }
    public double ElectronVolts { get; }
    public double Ergs { get; }
    public double FootPounds { get; }
    public double GigabritishThermalUnits { get; }
    public double GigaelectronVolts { get; }
    public double Gigajoules { get; }
    public double GigawattDays { get; }
    public double GigawattHours { get; }
    public double HorsepowerHours { get; }
    public double Joules { get; }
    public double KilobritishThermalUnits { get; }
    public double Kilocalories { get; }
    public double KiloelectronVolts { get; }
    public double Kilojoules { get; }
    public double KilowattDays { get; }
    public double KilowattHours { get; }
    public double MegabritishThermalUnits { get; }
    public double Megacalories { get; }
    public double MegaelectronVolts { get; }
    public double Megajoules { get; }
    public double MegawattDays { get; }
    public double MegawattHours { get; }
    public double Microjoules { get; }
    public double Millijoules { get; }
    public double Nanojoules { get; }
    public double Petajoules { get; }
    public double TeraelectronVolts { get; }
    public double Terajoules { get; }
    public double TerawattDays { get; }
    public double TerawattHours { get; }
    public double ThermsEc { get; }
    public double ThermsImperial { get; }
    public double ThermsUs { get; }
    public double WattDays { get; }
    public double WattHours { get; }
    private static Energy();
    public Energy(double value, EnergyUnit unit);
    public Energy(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<EnergyUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static EnergyUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static EnergyUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Energy get_Zero();
    public static override Energy get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual EnergyUnit get_Unit();
    public sealed virtual QuantityInfo`1<EnergyUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_BritishThermalUnits();
    public double get_Calories();
    public double get_DecathermsEc();
    public double get_DecathermsImperial();
    public double get_DecathermsUs();
    public double get_ElectronVolts();
    public double get_Ergs();
    public double get_FootPounds();
    public double get_GigabritishThermalUnits();
    public double get_GigaelectronVolts();
    public double get_Gigajoules();
    public double get_GigawattDays();
    public double get_GigawattHours();
    public double get_HorsepowerHours();
    public double get_Joules();
    public double get_KilobritishThermalUnits();
    public double get_Kilocalories();
    public double get_KiloelectronVolts();
    public double get_Kilojoules();
    public double get_KilowattDays();
    public double get_KilowattHours();
    public double get_MegabritishThermalUnits();
    public double get_Megacalories();
    public double get_MegaelectronVolts();
    public double get_Megajoules();
    public double get_MegawattDays();
    public double get_MegawattHours();
    public double get_Microjoules();
    public double get_Millijoules();
    public double get_Nanojoules();
    public double get_Petajoules();
    public double get_TeraelectronVolts();
    public double get_Terajoules();
    public double get_TerawattDays();
    public double get_TerawattHours();
    public double get_ThermsEc();
    public double get_ThermsImperial();
    public double get_ThermsUs();
    public double get_WattDays();
    public double get_WattHours();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(EnergyUnit unit);
    public static string GetAbbreviation(EnergyUnit unit, IFormatProvider provider);
    public static Energy FromBritishThermalUnits(double value);
    public static Energy FromCalories(double value);
    public static Energy FromDecathermsEc(double value);
    public static Energy FromDecathermsImperial(double value);
    public static Energy FromDecathermsUs(double value);
    public static Energy FromElectronVolts(double value);
    public static Energy FromErgs(double value);
    public static Energy FromFootPounds(double value);
    public static Energy FromGigabritishThermalUnits(double value);
    public static Energy FromGigaelectronVolts(double value);
    public static Energy FromGigajoules(double value);
    public static Energy FromGigawattDays(double value);
    public static Energy FromGigawattHours(double value);
    public static Energy FromHorsepowerHours(double value);
    public static Energy FromJoules(double value);
    public static Energy FromKilobritishThermalUnits(double value);
    public static Energy FromKilocalories(double value);
    public static Energy FromKiloelectronVolts(double value);
    public static Energy FromKilojoules(double value);
    public static Energy FromKilowattDays(double value);
    public static Energy FromKilowattHours(double value);
    public static Energy FromMegabritishThermalUnits(double value);
    public static Energy FromMegacalories(double value);
    public static Energy FromMegaelectronVolts(double value);
    public static Energy FromMegajoules(double value);
    public static Energy FromMegawattDays(double value);
    public static Energy FromMegawattHours(double value);
    public static Energy FromMicrojoules(double value);
    public static Energy FromMillijoules(double value);
    public static Energy FromNanojoules(double value);
    public static Energy FromPetajoules(double value);
    public static Energy FromTeraelectronVolts(double value);
    public static Energy FromTerajoules(double value);
    public static Energy FromTerawattDays(double value);
    public static Energy FromTerawattHours(double value);
    public static Energy FromThermsEc(double value);
    public static Energy FromThermsImperial(double value);
    public static Energy FromThermsUs(double value);
    public static Energy FromWattDays(double value);
    public static Energy FromWattHours(double value);
    public static Energy From(double value, EnergyUnit fromUnit);
    public static Energy Parse(string str);
    public static override Energy Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Energy& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Energy& result);
    public static EnergyUnit ParseUnit(string str);
    public static EnergyUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, EnergyUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, EnergyUnit& unit);
    public static override Energy op_UnaryNegation(Energy right);
    public static override Energy op_Addition(Energy left, Energy right);
    public static override Energy op_Subtraction(Energy left, Energy right);
    public static Energy op_Multiply(double left, Energy right);
    public static override Energy op_Multiply(Energy left, double right);
    public static override Energy op_Division(Energy left, double right);
    public static double op_Division(Energy left, Energy right);
    public static override Duration op_Division(Energy energy, Power power);
    public static override ElectricCharge op_Division(Energy energy, ElectricPotential electricPotential);
    public static override ElectricPotential op_Division(Energy energy, ElectricCharge electricCharge);
    public static override EnergyDensity op_Division(Energy energy, Volume volume);
    public static override Entropy op_Division(Energy energy, TemperatureDelta temperatureDelta);
    public static override Mass op_Division(Energy energy, SpecificEnergy specificEnergy);
    public static override Power op_Multiply(Energy energy, Frequency frequency);
    public static override Power op_Division(Energy energy, Duration duration);
    public static override SpecificEnergy op_Division(Energy energy, Mass mass);
    public static override TemperatureDelta op_Division(Energy energy, Entropy entropy);
    public static override Volume op_Division(Energy energy, EnergyDensity energyDensity);
    public static override bool op_LessThanOrEqual(Energy left, Energy right);
    public static override bool op_GreaterThanOrEqual(Energy left, Energy right);
    public static override bool op_LessThan(Energy left, Energy right);
    public static override bool op_GreaterThan(Energy left, Energy right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Energy other, Energy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Energy left, Energy right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Energy other, Energy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Energy left, Energy right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Energy other, Energy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Energy other, Energy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Energy other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Energy other);
    [ObsoleteAttribute("Use Equals(Energy other, Energy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Energy other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Energy other, Energy tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(EnergyUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Energy ToUnit(EnergyUnit unit);
    public Energy ToUnit(EnergyUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(EnergyUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Energy ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<EnergyUnit> UnitsNet.IQuantity<UnitsNet.Units.EnergyUnit>.ToUnit(EnergyUnit unit);
    private sealed virtual override IQuantity`1<EnergyUnit> UnitsNet.IQuantity<UnitsNet.Units.EnergyUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.EnergyDensity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<EnergyDensityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<EnergyDensityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnergyDensityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnergyDensityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static EnergyDensity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<EnergyDensityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static EnergyDensityUnit BaseUnit { get; }
    public static EnergyDensityUnit[] Units { get; }
    public static EnergyDensity Zero { get; }
    public static EnergyDensity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public EnergyDensityUnit Unit { get; }
    public QuantityInfo`1<EnergyDensityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double GigajoulesPerCubicMeter { get; }
    public double GigawattHoursPerCubicMeter { get; }
    public double JoulesPerCubicMeter { get; }
    public double KilojoulesPerCubicMeter { get; }
    public double KilowattHoursPerCubicMeter { get; }
    public double MegajoulesPerCubicMeter { get; }
    public double MegawattHoursPerCubicMeter { get; }
    public double PetajoulesPerCubicMeter { get; }
    public double PetawattHoursPerCubicMeter { get; }
    public double TerajoulesPerCubicMeter { get; }
    public double TerawattHoursPerCubicMeter { get; }
    public double WattHoursPerCubicMeter { get; }
    private static EnergyDensity();
    public EnergyDensity(double value, EnergyDensityUnit unit);
    public EnergyDensity(double value, UnitSystem unitSystem);
    public static Energy CombustionEnergy(EnergyDensity energyDensity, Volume volume, Ratio conversionFactor);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<EnergyDensityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static EnergyDensityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static EnergyDensityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override EnergyDensity get_Zero();
    public static override EnergyDensity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual EnergyDensityUnit get_Unit();
    public sealed virtual QuantityInfo`1<EnergyDensityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_GigajoulesPerCubicMeter();
    public double get_GigawattHoursPerCubicMeter();
    public double get_JoulesPerCubicMeter();
    public double get_KilojoulesPerCubicMeter();
    public double get_KilowattHoursPerCubicMeter();
    public double get_MegajoulesPerCubicMeter();
    public double get_MegawattHoursPerCubicMeter();
    public double get_PetajoulesPerCubicMeter();
    public double get_PetawattHoursPerCubicMeter();
    public double get_TerajoulesPerCubicMeter();
    public double get_TerawattHoursPerCubicMeter();
    public double get_WattHoursPerCubicMeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(EnergyDensityUnit unit);
    public static string GetAbbreviation(EnergyDensityUnit unit, IFormatProvider provider);
    public static EnergyDensity FromGigajoulesPerCubicMeter(double value);
    public static EnergyDensity FromGigawattHoursPerCubicMeter(double value);
    public static EnergyDensity FromJoulesPerCubicMeter(double value);
    public static EnergyDensity FromKilojoulesPerCubicMeter(double value);
    public static EnergyDensity FromKilowattHoursPerCubicMeter(double value);
    public static EnergyDensity FromMegajoulesPerCubicMeter(double value);
    public static EnergyDensity FromMegawattHoursPerCubicMeter(double value);
    public static EnergyDensity FromPetajoulesPerCubicMeter(double value);
    public static EnergyDensity FromPetawattHoursPerCubicMeter(double value);
    public static EnergyDensity FromTerajoulesPerCubicMeter(double value);
    public static EnergyDensity FromTerawattHoursPerCubicMeter(double value);
    public static EnergyDensity FromWattHoursPerCubicMeter(double value);
    public static EnergyDensity From(double value, EnergyDensityUnit fromUnit);
    public static EnergyDensity Parse(string str);
    public static override EnergyDensity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, EnergyDensity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, EnergyDensity& result);
    public static EnergyDensityUnit ParseUnit(string str);
    public static EnergyDensityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, EnergyDensityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, EnergyDensityUnit& unit);
    public static override EnergyDensity op_UnaryNegation(EnergyDensity right);
    public static override EnergyDensity op_Addition(EnergyDensity left, EnergyDensity right);
    public static override EnergyDensity op_Subtraction(EnergyDensity left, EnergyDensity right);
    public static EnergyDensity op_Multiply(double left, EnergyDensity right);
    public static override EnergyDensity op_Multiply(EnergyDensity left, double right);
    public static override EnergyDensity op_Division(EnergyDensity left, double right);
    public static double op_Division(EnergyDensity left, EnergyDensity right);
    public static override Energy op_Multiply(EnergyDensity energyDensity, Volume volume);
    public static override bool op_LessThanOrEqual(EnergyDensity left, EnergyDensity right);
    public static override bool op_GreaterThanOrEqual(EnergyDensity left, EnergyDensity right);
    public static override bool op_LessThan(EnergyDensity left, EnergyDensity right);
    public static override bool op_GreaterThan(EnergyDensity left, EnergyDensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(EnergyDensity other, EnergyDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(EnergyDensity left, EnergyDensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(EnergyDensity other, EnergyDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(EnergyDensity left, EnergyDensity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(EnergyDensity other, EnergyDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(EnergyDensity other, EnergyDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(EnergyDensity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(EnergyDensity other);
    [ObsoleteAttribute("Use Equals(EnergyDensity other, EnergyDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(EnergyDensity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(EnergyDensity other, EnergyDensity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(EnergyDensityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public EnergyDensity ToUnit(EnergyDensityUnit unit);
    public EnergyDensity ToUnit(EnergyDensityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(EnergyDensityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public EnergyDensity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<EnergyDensityUnit> UnitsNet.IQuantity<UnitsNet.Units.EnergyDensityUnit>.ToUnit(EnergyDensityUnit unit);
    private sealed virtual override IQuantity`1<EnergyDensityUnit> UnitsNet.IQuantity<UnitsNet.Units.EnergyDensityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Entropy : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<EntropyUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<EntropyUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static EntropyUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static EntropyUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Entropy <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<EntropyUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static EntropyUnit BaseUnit { get; }
    public static EntropyUnit[] Units { get; }
    public static Entropy Zero { get; }
    public static Entropy AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public EntropyUnit Unit { get; }
    public QuantityInfo`1<EntropyUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CaloriesPerKelvin { get; }
    public double JoulesPerDegreeCelsius { get; }
    public double JoulesPerKelvin { get; }
    public double KilocaloriesPerKelvin { get; }
    public double KilojoulesPerDegreeCelsius { get; }
    public double KilojoulesPerKelvin { get; }
    public double MegajoulesPerKelvin { get; }
    private static Entropy();
    public Entropy(double value, EntropyUnit unit);
    public Entropy(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<EntropyUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static EntropyUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static EntropyUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Entropy get_Zero();
    public static override Entropy get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual EntropyUnit get_Unit();
    public sealed virtual QuantityInfo`1<EntropyUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CaloriesPerKelvin();
    public double get_JoulesPerDegreeCelsius();
    public double get_JoulesPerKelvin();
    public double get_KilocaloriesPerKelvin();
    public double get_KilojoulesPerDegreeCelsius();
    public double get_KilojoulesPerKelvin();
    public double get_MegajoulesPerKelvin();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(EntropyUnit unit);
    public static string GetAbbreviation(EntropyUnit unit, IFormatProvider provider);
    public static Entropy FromCaloriesPerKelvin(double value);
    public static Entropy FromJoulesPerDegreeCelsius(double value);
    public static Entropy FromJoulesPerKelvin(double value);
    public static Entropy FromKilocaloriesPerKelvin(double value);
    public static Entropy FromKilojoulesPerDegreeCelsius(double value);
    public static Entropy FromKilojoulesPerKelvin(double value);
    public static Entropy FromMegajoulesPerKelvin(double value);
    public static Entropy From(double value, EntropyUnit fromUnit);
    public static Entropy Parse(string str);
    public static override Entropy Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Entropy& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Entropy& result);
    public static EntropyUnit ParseUnit(string str);
    public static EntropyUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, EntropyUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, EntropyUnit& unit);
    public static override Entropy op_UnaryNegation(Entropy right);
    public static override Entropy op_Addition(Entropy left, Entropy right);
    public static override Entropy op_Subtraction(Entropy left, Entropy right);
    public static Entropy op_Multiply(double left, Entropy right);
    public static override Entropy op_Multiply(Entropy left, double right);
    public static override Entropy op_Division(Entropy left, double right);
    public static double op_Division(Entropy left, Entropy right);
    public static override Energy op_Multiply(Entropy entropy, TemperatureDelta temperatureDelta);
    public static override Mass op_Division(Entropy entropy, SpecificEntropy specificEntropy);
    public static override SpecificEntropy op_Division(Entropy entropy, Mass mass);
    public static override bool op_LessThanOrEqual(Entropy left, Entropy right);
    public static override bool op_GreaterThanOrEqual(Entropy left, Entropy right);
    public static override bool op_LessThan(Entropy left, Entropy right);
    public static override bool op_GreaterThan(Entropy left, Entropy right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Entropy other, Entropy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Entropy left, Entropy right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Entropy other, Entropy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Entropy left, Entropy right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Entropy other, Entropy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Entropy other, Entropy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Entropy other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Entropy other);
    [ObsoleteAttribute("Use Equals(Entropy other, Entropy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Entropy other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Entropy other, Entropy tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(EntropyUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Entropy ToUnit(EntropyUnit unit);
    public Entropy ToUnit(EntropyUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(EntropyUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Entropy ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<EntropyUnit> UnitsNet.IQuantity<UnitsNet.Units.EntropyUnit>.ToUnit(EntropyUnit unit);
    private sealed virtual override IQuantity`1<EntropyUnit> UnitsNet.IQuantity<UnitsNet.Units.EntropyUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.FeetInches : object {
    [CompilerGeneratedAttribute]
private double <Feet>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Inches>k__BackingField;
    public double Feet { get; }
    public double Inches { get; }
    public FeetInches(double feet, double inches);
    [CompilerGeneratedAttribute]
public double get_Feet();
    [CompilerGeneratedAttribute]
public double get_Inches();
    public virtual string ToString();
    public string ToString(IFormatProvider cultureInfo);
    public string ToArchitecturalString(int fractionDenominator);
    [CompilerGeneratedAttribute]
internal static int <ToArchitecturalString>g__GreatestCommonDivisor|9_0(int a, int b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Force : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ForceUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ForceUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ForceUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ForceUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Force <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ForceUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ForceUnit BaseUnit { get; }
    public static ForceUnit[] Units { get; }
    public static Force Zero { get; }
    public static Force AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ForceUnit Unit { get; }
    public QuantityInfo`1<ForceUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Decanewtons { get; }
    public double Dyne { get; }
    public double KilogramsForce { get; }
    public double Kilonewtons { get; }
    public double KiloPonds { get; }
    public double KilopoundsForce { get; }
    public double Meganewtons { get; }
    public double Micronewtons { get; }
    public double Millinewtons { get; }
    public double Newtons { get; }
    public double OunceForce { get; }
    public double Poundals { get; }
    public double PoundsForce { get; }
    public double ShortTonsForce { get; }
    public double TonnesForce { get; }
    private static Force();
    public Force(double value, ForceUnit unit);
    public Force(double value, UnitSystem unitSystem);
    public static Force FromPressureByArea(Pressure p, Area area);
    public static Force FromMassByAcceleration(Mass mass, Acceleration acceleration);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ForceUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ForceUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ForceUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Force get_Zero();
    public static override Force get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ForceUnit get_Unit();
    public sealed virtual QuantityInfo`1<ForceUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Decanewtons();
    public double get_Dyne();
    public double get_KilogramsForce();
    public double get_Kilonewtons();
    public double get_KiloPonds();
    public double get_KilopoundsForce();
    public double get_Meganewtons();
    public double get_Micronewtons();
    public double get_Millinewtons();
    public double get_Newtons();
    public double get_OunceForce();
    public double get_Poundals();
    public double get_PoundsForce();
    public double get_ShortTonsForce();
    public double get_TonnesForce();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ForceUnit unit);
    public static string GetAbbreviation(ForceUnit unit, IFormatProvider provider);
    public static Force FromDecanewtons(double value);
    public static Force FromDyne(double value);
    public static Force FromKilogramsForce(double value);
    public static Force FromKilonewtons(double value);
    public static Force FromKiloPonds(double value);
    public static Force FromKilopoundsForce(double value);
    public static Force FromMeganewtons(double value);
    public static Force FromMicronewtons(double value);
    public static Force FromMillinewtons(double value);
    public static Force FromNewtons(double value);
    public static Force FromOunceForce(double value);
    public static Force FromPoundals(double value);
    public static Force FromPoundsForce(double value);
    public static Force FromShortTonsForce(double value);
    public static Force FromTonnesForce(double value);
    public static Force From(double value, ForceUnit fromUnit);
    public static Force Parse(string str);
    public static override Force Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Force& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Force& result);
    public static ForceUnit ParseUnit(string str);
    public static ForceUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ForceUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ForceUnit& unit);
    public static override Force op_UnaryNegation(Force right);
    public static override Force op_Addition(Force left, Force right);
    public static override Force op_Subtraction(Force left, Force right);
    public static Force op_Multiply(double left, Force right);
    public static override Force op_Multiply(Force left, double right);
    public static override Force op_Division(Force left, double right);
    public static double op_Division(Force left, Force right);
    public static override Acceleration op_Division(Force force, Mass mass);
    public static override Area op_Division(Force force, Pressure pressure);
    public static override Duration op_Division(Force force, ForceChangeRate forceChangeRate);
    public static override ForceChangeRate op_Division(Force force, Duration duration);
    public static override ForcePerLength op_Multiply(Force force, ReciprocalLength reciprocalLength);
    public static override ForcePerLength op_Division(Force force, Length length);
    public static override Length op_Division(Force force, ForcePerLength forcePerLength);
    public static override Mass op_Division(Force force, Acceleration acceleration);
    public static override Power op_Multiply(Force force, Speed speed);
    public static override Pressure op_Multiply(Force force, ReciprocalArea reciprocalArea);
    public static override Pressure op_Division(Force force, Area area);
    public static override Torque op_Multiply(Force force, Length length);
    public static override bool op_LessThanOrEqual(Force left, Force right);
    public static override bool op_GreaterThanOrEqual(Force left, Force right);
    public static override bool op_LessThan(Force left, Force right);
    public static override bool op_GreaterThan(Force left, Force right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Force other, Force tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Force left, Force right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Force other, Force tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Force left, Force right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Force other, Force tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Force other, Force tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Force other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Force other);
    [ObsoleteAttribute("Use Equals(Force other, Force tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Force other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Force other, Force tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ForceUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Force ToUnit(ForceUnit unit);
    public Force ToUnit(ForceUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ForceUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Force ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ForceUnit> UnitsNet.IQuantity<UnitsNet.Units.ForceUnit>.ToUnit(ForceUnit unit);
    private sealed virtual override IQuantity`1<ForceUnit> UnitsNet.IQuantity<UnitsNet.Units.ForceUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ForceChangeRate : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ForceChangeRateUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ForceChangeRateUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ForceChangeRateUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ForceChangeRateUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ForceChangeRate <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ForceChangeRateUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ForceChangeRateUnit BaseUnit { get; }
    public static ForceChangeRateUnit[] Units { get; }
    public static ForceChangeRate Zero { get; }
    public static ForceChangeRate AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ForceChangeRateUnit Unit { get; }
    public QuantityInfo`1<ForceChangeRateUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentinewtonsPerSecond { get; }
    public double DecanewtonsPerMinute { get; }
    public double DecanewtonsPerSecond { get; }
    public double DecinewtonsPerSecond { get; }
    public double KilonewtonsPerMinute { get; }
    public double KilonewtonsPerSecond { get; }
    public double KilopoundsForcePerMinute { get; }
    public double KilopoundsForcePerSecond { get; }
    public double MicronewtonsPerSecond { get; }
    public double MillinewtonsPerSecond { get; }
    public double NanonewtonsPerSecond { get; }
    public double NewtonsPerMinute { get; }
    public double NewtonsPerSecond { get; }
    public double PoundsForcePerMinute { get; }
    public double PoundsForcePerSecond { get; }
    private static ForceChangeRate();
    public ForceChangeRate(double value, ForceChangeRateUnit unit);
    public ForceChangeRate(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ForceChangeRateUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ForceChangeRateUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ForceChangeRateUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ForceChangeRate get_Zero();
    public static override ForceChangeRate get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ForceChangeRateUnit get_Unit();
    public sealed virtual QuantityInfo`1<ForceChangeRateUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentinewtonsPerSecond();
    public double get_DecanewtonsPerMinute();
    public double get_DecanewtonsPerSecond();
    public double get_DecinewtonsPerSecond();
    public double get_KilonewtonsPerMinute();
    public double get_KilonewtonsPerSecond();
    public double get_KilopoundsForcePerMinute();
    public double get_KilopoundsForcePerSecond();
    public double get_MicronewtonsPerSecond();
    public double get_MillinewtonsPerSecond();
    public double get_NanonewtonsPerSecond();
    public double get_NewtonsPerMinute();
    public double get_NewtonsPerSecond();
    public double get_PoundsForcePerMinute();
    public double get_PoundsForcePerSecond();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ForceChangeRateUnit unit);
    public static string GetAbbreviation(ForceChangeRateUnit unit, IFormatProvider provider);
    public static ForceChangeRate FromCentinewtonsPerSecond(double value);
    public static ForceChangeRate FromDecanewtonsPerMinute(double value);
    public static ForceChangeRate FromDecanewtonsPerSecond(double value);
    public static ForceChangeRate FromDecinewtonsPerSecond(double value);
    public static ForceChangeRate FromKilonewtonsPerMinute(double value);
    public static ForceChangeRate FromKilonewtonsPerSecond(double value);
    public static ForceChangeRate FromKilopoundsForcePerMinute(double value);
    public static ForceChangeRate FromKilopoundsForcePerSecond(double value);
    public static ForceChangeRate FromMicronewtonsPerSecond(double value);
    public static ForceChangeRate FromMillinewtonsPerSecond(double value);
    public static ForceChangeRate FromNanonewtonsPerSecond(double value);
    public static ForceChangeRate FromNewtonsPerMinute(double value);
    public static ForceChangeRate FromNewtonsPerSecond(double value);
    public static ForceChangeRate FromPoundsForcePerMinute(double value);
    public static ForceChangeRate FromPoundsForcePerSecond(double value);
    public static ForceChangeRate From(double value, ForceChangeRateUnit fromUnit);
    public static ForceChangeRate Parse(string str);
    public static override ForceChangeRate Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ForceChangeRate& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ForceChangeRate& result);
    public static ForceChangeRateUnit ParseUnit(string str);
    public static ForceChangeRateUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ForceChangeRateUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ForceChangeRateUnit& unit);
    public static override ForceChangeRate op_UnaryNegation(ForceChangeRate right);
    public static override ForceChangeRate op_Addition(ForceChangeRate left, ForceChangeRate right);
    public static override ForceChangeRate op_Subtraction(ForceChangeRate left, ForceChangeRate right);
    public static ForceChangeRate op_Multiply(double left, ForceChangeRate right);
    public static override ForceChangeRate op_Multiply(ForceChangeRate left, double right);
    public static override ForceChangeRate op_Division(ForceChangeRate left, double right);
    public static double op_Division(ForceChangeRate left, ForceChangeRate right);
    public static override Force op_Multiply(ForceChangeRate forceChangeRate, Duration duration);
    public static override bool op_LessThanOrEqual(ForceChangeRate left, ForceChangeRate right);
    public static override bool op_GreaterThanOrEqual(ForceChangeRate left, ForceChangeRate right);
    public static override bool op_LessThan(ForceChangeRate left, ForceChangeRate right);
    public static override bool op_GreaterThan(ForceChangeRate left, ForceChangeRate right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ForceChangeRate other, ForceChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ForceChangeRate left, ForceChangeRate right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ForceChangeRate other, ForceChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ForceChangeRate left, ForceChangeRate right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ForceChangeRate other, ForceChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ForceChangeRate other, ForceChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ForceChangeRate other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ForceChangeRate other);
    [ObsoleteAttribute("Use Equals(ForceChangeRate other, ForceChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ForceChangeRate other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ForceChangeRate other, ForceChangeRate tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ForceChangeRateUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ForceChangeRate ToUnit(ForceChangeRateUnit unit);
    public ForceChangeRate ToUnit(ForceChangeRateUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ForceChangeRateUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ForceChangeRate ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ForceChangeRateUnit> UnitsNet.IQuantity<UnitsNet.Units.ForceChangeRateUnit>.ToUnit(ForceChangeRateUnit unit);
    private sealed virtual override IQuantity`1<ForceChangeRateUnit> UnitsNet.IQuantity<UnitsNet.Units.ForceChangeRateUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ForcePerLength : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ForcePerLengthUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ForcePerLengthUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ForcePerLengthUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ForcePerLengthUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ForcePerLength <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ForcePerLengthUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ForcePerLengthUnit BaseUnit { get; }
    public static ForcePerLengthUnit[] Units { get; }
    public static ForcePerLength Zero { get; }
    public static ForcePerLength AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ForcePerLengthUnit Unit { get; }
    public QuantityInfo`1<ForcePerLengthUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentinewtonsPerCentimeter { get; }
    public double CentinewtonsPerMeter { get; }
    public double CentinewtonsPerMillimeter { get; }
    public double DecanewtonsPerCentimeter { get; }
    public double DecanewtonsPerMeter { get; }
    public double DecanewtonsPerMillimeter { get; }
    public double DecinewtonsPerCentimeter { get; }
    public double DecinewtonsPerMeter { get; }
    public double DecinewtonsPerMillimeter { get; }
    public double KilogramsForcePerCentimeter { get; }
    public double KilogramsForcePerMeter { get; }
    public double KilogramsForcePerMillimeter { get; }
    public double KilonewtonsPerCentimeter { get; }
    public double KilonewtonsPerMeter { get; }
    public double KilonewtonsPerMillimeter { get; }
    public double KilopoundsForcePerFoot { get; }
    public double KilopoundsForcePerInch { get; }
    public double MeganewtonsPerCentimeter { get; }
    public double MeganewtonsPerMeter { get; }
    public double MeganewtonsPerMillimeter { get; }
    public double MicronewtonsPerCentimeter { get; }
    public double MicronewtonsPerMeter { get; }
    public double MicronewtonsPerMillimeter { get; }
    public double MillinewtonsPerCentimeter { get; }
    public double MillinewtonsPerMeter { get; }
    public double MillinewtonsPerMillimeter { get; }
    public double NanonewtonsPerCentimeter { get; }
    public double NanonewtonsPerMeter { get; }
    public double NanonewtonsPerMillimeter { get; }
    public double NewtonsPerCentimeter { get; }
    public double NewtonsPerMeter { get; }
    public double NewtonsPerMillimeter { get; }
    public double PoundsForcePerFoot { get; }
    public double PoundsForcePerInch { get; }
    public double PoundsForcePerYard { get; }
    public double TonnesForcePerCentimeter { get; }
    public double TonnesForcePerMeter { get; }
    public double TonnesForcePerMillimeter { get; }
    private static ForcePerLength();
    public ForcePerLength(double value, ForcePerLengthUnit unit);
    public ForcePerLength(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ForcePerLengthUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ForcePerLengthUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ForcePerLengthUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ForcePerLength get_Zero();
    public static override ForcePerLength get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ForcePerLengthUnit get_Unit();
    public sealed virtual QuantityInfo`1<ForcePerLengthUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentinewtonsPerCentimeter();
    public double get_CentinewtonsPerMeter();
    public double get_CentinewtonsPerMillimeter();
    public double get_DecanewtonsPerCentimeter();
    public double get_DecanewtonsPerMeter();
    public double get_DecanewtonsPerMillimeter();
    public double get_DecinewtonsPerCentimeter();
    public double get_DecinewtonsPerMeter();
    public double get_DecinewtonsPerMillimeter();
    public double get_KilogramsForcePerCentimeter();
    public double get_KilogramsForcePerMeter();
    public double get_KilogramsForcePerMillimeter();
    public double get_KilonewtonsPerCentimeter();
    public double get_KilonewtonsPerMeter();
    public double get_KilonewtonsPerMillimeter();
    public double get_KilopoundsForcePerFoot();
    public double get_KilopoundsForcePerInch();
    public double get_MeganewtonsPerCentimeter();
    public double get_MeganewtonsPerMeter();
    public double get_MeganewtonsPerMillimeter();
    public double get_MicronewtonsPerCentimeter();
    public double get_MicronewtonsPerMeter();
    public double get_MicronewtonsPerMillimeter();
    public double get_MillinewtonsPerCentimeter();
    public double get_MillinewtonsPerMeter();
    public double get_MillinewtonsPerMillimeter();
    public double get_NanonewtonsPerCentimeter();
    public double get_NanonewtonsPerMeter();
    public double get_NanonewtonsPerMillimeter();
    public double get_NewtonsPerCentimeter();
    public double get_NewtonsPerMeter();
    public double get_NewtonsPerMillimeter();
    public double get_PoundsForcePerFoot();
    public double get_PoundsForcePerInch();
    public double get_PoundsForcePerYard();
    public double get_TonnesForcePerCentimeter();
    public double get_TonnesForcePerMeter();
    public double get_TonnesForcePerMillimeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ForcePerLengthUnit unit);
    public static string GetAbbreviation(ForcePerLengthUnit unit, IFormatProvider provider);
    public static ForcePerLength FromCentinewtonsPerCentimeter(double value);
    public static ForcePerLength FromCentinewtonsPerMeter(double value);
    public static ForcePerLength FromCentinewtonsPerMillimeter(double value);
    public static ForcePerLength FromDecanewtonsPerCentimeter(double value);
    public static ForcePerLength FromDecanewtonsPerMeter(double value);
    public static ForcePerLength FromDecanewtonsPerMillimeter(double value);
    public static ForcePerLength FromDecinewtonsPerCentimeter(double value);
    public static ForcePerLength FromDecinewtonsPerMeter(double value);
    public static ForcePerLength FromDecinewtonsPerMillimeter(double value);
    public static ForcePerLength FromKilogramsForcePerCentimeter(double value);
    public static ForcePerLength FromKilogramsForcePerMeter(double value);
    public static ForcePerLength FromKilogramsForcePerMillimeter(double value);
    public static ForcePerLength FromKilonewtonsPerCentimeter(double value);
    public static ForcePerLength FromKilonewtonsPerMeter(double value);
    public static ForcePerLength FromKilonewtonsPerMillimeter(double value);
    public static ForcePerLength FromKilopoundsForcePerFoot(double value);
    public static ForcePerLength FromKilopoundsForcePerInch(double value);
    public static ForcePerLength FromMeganewtonsPerCentimeter(double value);
    public static ForcePerLength FromMeganewtonsPerMeter(double value);
    public static ForcePerLength FromMeganewtonsPerMillimeter(double value);
    public static ForcePerLength FromMicronewtonsPerCentimeter(double value);
    public static ForcePerLength FromMicronewtonsPerMeter(double value);
    public static ForcePerLength FromMicronewtonsPerMillimeter(double value);
    public static ForcePerLength FromMillinewtonsPerCentimeter(double value);
    public static ForcePerLength FromMillinewtonsPerMeter(double value);
    public static ForcePerLength FromMillinewtonsPerMillimeter(double value);
    public static ForcePerLength FromNanonewtonsPerCentimeter(double value);
    public static ForcePerLength FromNanonewtonsPerMeter(double value);
    public static ForcePerLength FromNanonewtonsPerMillimeter(double value);
    public static ForcePerLength FromNewtonsPerCentimeter(double value);
    public static ForcePerLength FromNewtonsPerMeter(double value);
    public static ForcePerLength FromNewtonsPerMillimeter(double value);
    public static ForcePerLength FromPoundsForcePerFoot(double value);
    public static ForcePerLength FromPoundsForcePerInch(double value);
    public static ForcePerLength FromPoundsForcePerYard(double value);
    public static ForcePerLength FromTonnesForcePerCentimeter(double value);
    public static ForcePerLength FromTonnesForcePerMeter(double value);
    public static ForcePerLength FromTonnesForcePerMillimeter(double value);
    public static ForcePerLength From(double value, ForcePerLengthUnit fromUnit);
    public static ForcePerLength Parse(string str);
    public static override ForcePerLength Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ForcePerLength& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ForcePerLength& result);
    public static ForcePerLengthUnit ParseUnit(string str);
    public static ForcePerLengthUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ForcePerLengthUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ForcePerLengthUnit& unit);
    public static override ForcePerLength op_UnaryNegation(ForcePerLength right);
    public static override ForcePerLength op_Addition(ForcePerLength left, ForcePerLength right);
    public static override ForcePerLength op_Subtraction(ForcePerLength left, ForcePerLength right);
    public static ForcePerLength op_Multiply(double left, ForcePerLength right);
    public static override ForcePerLength op_Multiply(ForcePerLength left, double right);
    public static override ForcePerLength op_Division(ForcePerLength left, double right);
    public static double op_Division(ForcePerLength left, ForcePerLength right);
    public static override Area op_Division(ForcePerLength forcePerLength, SpecificWeight specificWeight);
    public static override Force op_Multiply(ForcePerLength forcePerLength, Length length);
    public static override Force op_Division(ForcePerLength forcePerLength, ReciprocalLength reciprocalLength);
    public static override Length op_Division(ForcePerLength forcePerLength, Pressure pressure);
    public static override Pressure op_Multiply(ForcePerLength forcePerLength, ReciprocalLength reciprocalLength);
    public static override Pressure op_Division(ForcePerLength forcePerLength, Length length);
    public static override ReciprocalLength op_Division(ForcePerLength forcePerLength, Force force);
    public static override SpecificWeight op_Division(ForcePerLength forcePerLength, Area area);
    public static override Torque op_Multiply(ForcePerLength forcePerLength, Area area);
    public static override bool op_LessThanOrEqual(ForcePerLength left, ForcePerLength right);
    public static override bool op_GreaterThanOrEqual(ForcePerLength left, ForcePerLength right);
    public static override bool op_LessThan(ForcePerLength left, ForcePerLength right);
    public static override bool op_GreaterThan(ForcePerLength left, ForcePerLength right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ForcePerLength other, ForcePerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ForcePerLength left, ForcePerLength right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ForcePerLength other, ForcePerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ForcePerLength left, ForcePerLength right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ForcePerLength other, ForcePerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ForcePerLength other, ForcePerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ForcePerLength other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ForcePerLength other);
    [ObsoleteAttribute("Use Equals(ForcePerLength other, ForcePerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ForcePerLength other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ForcePerLength other, ForcePerLength tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ForcePerLengthUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ForcePerLength ToUnit(ForcePerLengthUnit unit);
    public ForcePerLength ToUnit(ForcePerLengthUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ForcePerLengthUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ForcePerLength ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ForcePerLengthUnit> UnitsNet.IQuantity<UnitsNet.Units.ForcePerLengthUnit>.ToUnit(ForcePerLengthUnit unit);
    private sealed virtual override IQuantity`1<ForcePerLengthUnit> UnitsNet.IQuantity<UnitsNet.Units.ForcePerLengthUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Frequency : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<FrequencyUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<FrequencyUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static FrequencyUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static FrequencyUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Frequency <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<FrequencyUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static FrequencyUnit BaseUnit { get; }
    public static FrequencyUnit[] Units { get; }
    public static Frequency Zero { get; }
    public static Frequency AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public FrequencyUnit Unit { get; }
    public QuantityInfo`1<FrequencyUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double BeatsPerMinute { get; }
    public double BUnits { get; }
    public double CyclesPerHour { get; }
    public double CyclesPerMinute { get; }
    public double Gigahertz { get; }
    public double Hertz { get; }
    public double Kilohertz { get; }
    public double Megahertz { get; }
    public double Microhertz { get; }
    public double Millihertz { get; }
    public double PerSecond { get; }
    public double RadiansPerSecond { get; }
    public double Terahertz { get; }
    private static Frequency();
    public Frequency(double value, FrequencyUnit unit);
    public Frequency(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<FrequencyUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static FrequencyUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static FrequencyUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Frequency get_Zero();
    public static override Frequency get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual FrequencyUnit get_Unit();
    public sealed virtual QuantityInfo`1<FrequencyUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_BeatsPerMinute();
    public double get_BUnits();
    public double get_CyclesPerHour();
    public double get_CyclesPerMinute();
    public double get_Gigahertz();
    public double get_Hertz();
    public double get_Kilohertz();
    public double get_Megahertz();
    public double get_Microhertz();
    public double get_Millihertz();
    public double get_PerSecond();
    public double get_RadiansPerSecond();
    public double get_Terahertz();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(FrequencyUnit unit);
    public static string GetAbbreviation(FrequencyUnit unit, IFormatProvider provider);
    public static Frequency FromBeatsPerMinute(double value);
    public static Frequency FromBUnits(double value);
    public static Frequency FromCyclesPerHour(double value);
    public static Frequency FromCyclesPerMinute(double value);
    public static Frequency FromGigahertz(double value);
    public static Frequency FromHertz(double value);
    public static Frequency FromKilohertz(double value);
    public static Frequency FromMegahertz(double value);
    public static Frequency FromMicrohertz(double value);
    public static Frequency FromMillihertz(double value);
    public static Frequency FromPerSecond(double value);
    public static Frequency FromRadiansPerSecond(double value);
    public static Frequency FromTerahertz(double value);
    public static Frequency From(double value, FrequencyUnit fromUnit);
    public static Frequency Parse(string str);
    public static override Frequency Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Frequency& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Frequency& result);
    public static FrequencyUnit ParseUnit(string str);
    public static FrequencyUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, FrequencyUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, FrequencyUnit& unit);
    public static override Frequency op_UnaryNegation(Frequency right);
    public static override Frequency op_Addition(Frequency left, Frequency right);
    public static override Frequency op_Subtraction(Frequency left, Frequency right);
    public static Frequency op_Multiply(double left, Frequency right);
    public static override Frequency op_Multiply(Frequency left, double right);
    public static override Frequency op_Division(Frequency left, double right);
    public static double op_Division(Frequency left, Frequency right);
    public static override Power op_Multiply(Frequency frequency, Energy energy);
    public static override bool op_LessThanOrEqual(Frequency left, Frequency right);
    public static override bool op_GreaterThanOrEqual(Frequency left, Frequency right);
    public static override bool op_LessThan(Frequency left, Frequency right);
    public static override bool op_GreaterThan(Frequency left, Frequency right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Frequency other, Frequency tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Frequency left, Frequency right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Frequency other, Frequency tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Frequency left, Frequency right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Frequency other, Frequency tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Frequency other, Frequency tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Frequency other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Frequency other);
    [ObsoleteAttribute("Use Equals(Frequency other, Frequency tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Frequency other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Frequency other, Frequency tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(FrequencyUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Frequency ToUnit(FrequencyUnit unit);
    public Frequency ToUnit(FrequencyUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(FrequencyUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Frequency ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<FrequencyUnit> UnitsNet.IQuantity<UnitsNet.Units.FrequencyUnit>.ToUnit(FrequencyUnit unit);
    private sealed virtual override IQuantity`1<FrequencyUnit> UnitsNet.IQuantity<UnitsNet.Units.FrequencyUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.FuelEfficiency : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<FuelEfficiencyUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<FuelEfficiencyUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static FuelEfficiencyUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static FuelEfficiencyUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static FuelEfficiency <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<FuelEfficiencyUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static FuelEfficiencyUnit BaseUnit { get; }
    public static FuelEfficiencyUnit[] Units { get; }
    public static FuelEfficiency Zero { get; }
    public static FuelEfficiency AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public FuelEfficiencyUnit Unit { get; }
    public QuantityInfo`1<FuelEfficiencyUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double KilometersPerLiter { get; }
    public double LitersPer100Kilometers { get; }
    public double MilesPerUkGallon { get; }
    public double MilesPerUsGallon { get; }
    private static FuelEfficiency();
    public FuelEfficiency(double value, FuelEfficiencyUnit unit);
    public FuelEfficiency(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<FuelEfficiencyUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static FuelEfficiencyUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static FuelEfficiencyUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override FuelEfficiency get_Zero();
    public static override FuelEfficiency get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual FuelEfficiencyUnit get_Unit();
    public sealed virtual QuantityInfo`1<FuelEfficiencyUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_KilometersPerLiter();
    public double get_LitersPer100Kilometers();
    public double get_MilesPerUkGallon();
    public double get_MilesPerUsGallon();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(FuelEfficiencyUnit unit);
    public static string GetAbbreviation(FuelEfficiencyUnit unit, IFormatProvider provider);
    public static FuelEfficiency FromKilometersPerLiter(double value);
    public static FuelEfficiency FromLitersPer100Kilometers(double value);
    public static FuelEfficiency FromMilesPerUkGallon(double value);
    public static FuelEfficiency FromMilesPerUsGallon(double value);
    public static FuelEfficiency From(double value, FuelEfficiencyUnit fromUnit);
    public static FuelEfficiency Parse(string str);
    public static override FuelEfficiency Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, FuelEfficiency& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, FuelEfficiency& result);
    public static FuelEfficiencyUnit ParseUnit(string str);
    public static FuelEfficiencyUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, FuelEfficiencyUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, FuelEfficiencyUnit& unit);
    public static override FuelEfficiency op_UnaryNegation(FuelEfficiency right);
    public static override FuelEfficiency op_Addition(FuelEfficiency left, FuelEfficiency right);
    public static override FuelEfficiency op_Subtraction(FuelEfficiency left, FuelEfficiency right);
    public static FuelEfficiency op_Multiply(double left, FuelEfficiency right);
    public static override FuelEfficiency op_Multiply(FuelEfficiency left, double right);
    public static override FuelEfficiency op_Division(FuelEfficiency left, double right);
    public static double op_Division(FuelEfficiency left, FuelEfficiency right);
    public static override bool op_LessThanOrEqual(FuelEfficiency left, FuelEfficiency right);
    public static override bool op_GreaterThanOrEqual(FuelEfficiency left, FuelEfficiency right);
    public static override bool op_LessThan(FuelEfficiency left, FuelEfficiency right);
    public static override bool op_GreaterThan(FuelEfficiency left, FuelEfficiency right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(FuelEfficiency other, FuelEfficiency tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(FuelEfficiency left, FuelEfficiency right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(FuelEfficiency other, FuelEfficiency tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(FuelEfficiency left, FuelEfficiency right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(FuelEfficiency other, FuelEfficiency tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(FuelEfficiency other, FuelEfficiency tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(FuelEfficiency other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(FuelEfficiency other);
    [ObsoleteAttribute("Use Equals(FuelEfficiency other, FuelEfficiency tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(FuelEfficiency other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(FuelEfficiency other, FuelEfficiency tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(FuelEfficiencyUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public FuelEfficiency ToUnit(FuelEfficiencyUnit unit);
    public FuelEfficiency ToUnit(FuelEfficiencyUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(FuelEfficiencyUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public FuelEfficiency ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<FuelEfficiencyUnit> UnitsNet.IQuantity<UnitsNet.Units.FuelEfficiencyUnit>.ToUnit(FuelEfficiencyUnit unit);
    private sealed virtual override IQuantity`1<FuelEfficiencyUnit> UnitsNet.IQuantity<UnitsNet.Units.FuelEfficiencyUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class UnitsNet.GenericMath.GenericMathExtensions : object {
    [ExtensionAttribute]
public static T Sum(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T Average(IEnumerable`1<T> source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.HeatFlux : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<HeatFluxUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<HeatFluxUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static HeatFluxUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static HeatFluxUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static HeatFlux <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<HeatFluxUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static HeatFluxUnit BaseUnit { get; }
    public static HeatFluxUnit[] Units { get; }
    public static HeatFlux Zero { get; }
    public static HeatFlux AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public HeatFluxUnit Unit { get; }
    public QuantityInfo`1<HeatFluxUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double BtusPerHourSquareFoot { get; }
    public double BtusPerMinuteSquareFoot { get; }
    public double BtusPerSecondSquareFoot { get; }
    public double BtusPerSecondSquareInch { get; }
    public double CaloriesPerSecondSquareCentimeter { get; }
    public double CentiwattsPerSquareMeter { get; }
    public double DeciwattsPerSquareMeter { get; }
    public double KilocaloriesPerHourSquareMeter { get; }
    public double KilocaloriesPerSecondSquareCentimeter { get; }
    public double KilowattsPerSquareMeter { get; }
    public double MicrowattsPerSquareMeter { get; }
    public double MilliwattsPerSquareMeter { get; }
    public double NanowattsPerSquareMeter { get; }
    public double PoundsForcePerFootSecond { get; }
    public double PoundsPerSecondCubed { get; }
    public double WattsPerSquareFoot { get; }
    public double WattsPerSquareInch { get; }
    public double WattsPerSquareMeter { get; }
    private static HeatFlux();
    public HeatFlux(double value, HeatFluxUnit unit);
    public HeatFlux(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<HeatFluxUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static HeatFluxUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static HeatFluxUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override HeatFlux get_Zero();
    public static override HeatFlux get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual HeatFluxUnit get_Unit();
    public sealed virtual QuantityInfo`1<HeatFluxUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_BtusPerHourSquareFoot();
    public double get_BtusPerMinuteSquareFoot();
    public double get_BtusPerSecondSquareFoot();
    public double get_BtusPerSecondSquareInch();
    public double get_CaloriesPerSecondSquareCentimeter();
    public double get_CentiwattsPerSquareMeter();
    public double get_DeciwattsPerSquareMeter();
    public double get_KilocaloriesPerHourSquareMeter();
    public double get_KilocaloriesPerSecondSquareCentimeter();
    public double get_KilowattsPerSquareMeter();
    public double get_MicrowattsPerSquareMeter();
    public double get_MilliwattsPerSquareMeter();
    public double get_NanowattsPerSquareMeter();
    public double get_PoundsForcePerFootSecond();
    public double get_PoundsPerSecondCubed();
    public double get_WattsPerSquareFoot();
    public double get_WattsPerSquareInch();
    public double get_WattsPerSquareMeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(HeatFluxUnit unit);
    public static string GetAbbreviation(HeatFluxUnit unit, IFormatProvider provider);
    public static HeatFlux FromBtusPerHourSquareFoot(double value);
    public static HeatFlux FromBtusPerMinuteSquareFoot(double value);
    public static HeatFlux FromBtusPerSecondSquareFoot(double value);
    public static HeatFlux FromBtusPerSecondSquareInch(double value);
    public static HeatFlux FromCaloriesPerSecondSquareCentimeter(double value);
    public static HeatFlux FromCentiwattsPerSquareMeter(double value);
    public static HeatFlux FromDeciwattsPerSquareMeter(double value);
    public static HeatFlux FromKilocaloriesPerHourSquareMeter(double value);
    public static HeatFlux FromKilocaloriesPerSecondSquareCentimeter(double value);
    public static HeatFlux FromKilowattsPerSquareMeter(double value);
    public static HeatFlux FromMicrowattsPerSquareMeter(double value);
    public static HeatFlux FromMilliwattsPerSquareMeter(double value);
    public static HeatFlux FromNanowattsPerSquareMeter(double value);
    public static HeatFlux FromPoundsForcePerFootSecond(double value);
    public static HeatFlux FromPoundsPerSecondCubed(double value);
    public static HeatFlux FromWattsPerSquareFoot(double value);
    public static HeatFlux FromWattsPerSquareInch(double value);
    public static HeatFlux FromWattsPerSquareMeter(double value);
    public static HeatFlux From(double value, HeatFluxUnit fromUnit);
    public static HeatFlux Parse(string str);
    public static override HeatFlux Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, HeatFlux& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, HeatFlux& result);
    public static HeatFluxUnit ParseUnit(string str);
    public static HeatFluxUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, HeatFluxUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, HeatFluxUnit& unit);
    public static override HeatFlux op_UnaryNegation(HeatFlux right);
    public static override HeatFlux op_Addition(HeatFlux left, HeatFlux right);
    public static override HeatFlux op_Subtraction(HeatFlux left, HeatFlux right);
    public static HeatFlux op_Multiply(double left, HeatFlux right);
    public static override HeatFlux op_Multiply(HeatFlux left, double right);
    public static override HeatFlux op_Division(HeatFlux left, double right);
    public static double op_Division(HeatFlux left, HeatFlux right);
    public static override Power op_Multiply(HeatFlux heatFlux, Area area);
    public static override bool op_LessThanOrEqual(HeatFlux left, HeatFlux right);
    public static override bool op_GreaterThanOrEqual(HeatFlux left, HeatFlux right);
    public static override bool op_LessThan(HeatFlux left, HeatFlux right);
    public static override bool op_GreaterThan(HeatFlux left, HeatFlux right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(HeatFlux other, HeatFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(HeatFlux left, HeatFlux right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(HeatFlux other, HeatFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(HeatFlux left, HeatFlux right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(HeatFlux other, HeatFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(HeatFlux other, HeatFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(HeatFlux other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(HeatFlux other);
    [ObsoleteAttribute("Use Equals(HeatFlux other, HeatFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(HeatFlux other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(HeatFlux other, HeatFlux tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(HeatFluxUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public HeatFlux ToUnit(HeatFluxUnit unit);
    public HeatFlux ToUnit(HeatFluxUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(HeatFluxUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public HeatFlux ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<HeatFluxUnit> UnitsNet.IQuantity<UnitsNet.Units.HeatFluxUnit>.ToUnit(HeatFluxUnit unit);
    private sealed virtual override IQuantity`1<HeatFluxUnit> UnitsNet.IQuantity<UnitsNet.Units.HeatFluxUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.HeatTransferCoefficient : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<HeatTransferCoefficientUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<HeatTransferCoefficientUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static HeatTransferCoefficientUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static HeatTransferCoefficientUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static HeatTransferCoefficient <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<HeatTransferCoefficientUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static HeatTransferCoefficientUnit BaseUnit { get; }
    public static HeatTransferCoefficientUnit[] Units { get; }
    public static HeatTransferCoefficient Zero { get; }
    public static HeatTransferCoefficient AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public HeatTransferCoefficientUnit Unit { get; }
    public QuantityInfo`1<HeatTransferCoefficientUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double BtusPerHourSquareFootDegreeFahrenheit { get; }
    public double CaloriesPerHourSquareMeterDegreeCelsius { get; }
    public double KilocaloriesPerHourSquareMeterDegreeCelsius { get; }
    public double WattsPerSquareMeterCelsius { get; }
    public double WattsPerSquareMeterKelvin { get; }
    private static HeatTransferCoefficient();
    public HeatTransferCoefficient(double value, HeatTransferCoefficientUnit unit);
    public HeatTransferCoefficient(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<HeatTransferCoefficientUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static HeatTransferCoefficientUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static HeatTransferCoefficientUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override HeatTransferCoefficient get_Zero();
    public static override HeatTransferCoefficient get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual HeatTransferCoefficientUnit get_Unit();
    public sealed virtual QuantityInfo`1<HeatTransferCoefficientUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_BtusPerHourSquareFootDegreeFahrenheit();
    public double get_CaloriesPerHourSquareMeterDegreeCelsius();
    public double get_KilocaloriesPerHourSquareMeterDegreeCelsius();
    public double get_WattsPerSquareMeterCelsius();
    public double get_WattsPerSquareMeterKelvin();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(HeatTransferCoefficientUnit unit);
    public static string GetAbbreviation(HeatTransferCoefficientUnit unit, IFormatProvider provider);
    public static HeatTransferCoefficient FromBtusPerHourSquareFootDegreeFahrenheit(double value);
    public static HeatTransferCoefficient FromCaloriesPerHourSquareMeterDegreeCelsius(double value);
    public static HeatTransferCoefficient FromKilocaloriesPerHourSquareMeterDegreeCelsius(double value);
    public static HeatTransferCoefficient FromWattsPerSquareMeterCelsius(double value);
    public static HeatTransferCoefficient FromWattsPerSquareMeterKelvin(double value);
    public static HeatTransferCoefficient From(double value, HeatTransferCoefficientUnit fromUnit);
    public static HeatTransferCoefficient Parse(string str);
    public static override HeatTransferCoefficient Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, HeatTransferCoefficient& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, HeatTransferCoefficient& result);
    public static HeatTransferCoefficientUnit ParseUnit(string str);
    public static HeatTransferCoefficientUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, HeatTransferCoefficientUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, HeatTransferCoefficientUnit& unit);
    public static override HeatTransferCoefficient op_UnaryNegation(HeatTransferCoefficient right);
    public static override HeatTransferCoefficient op_Addition(HeatTransferCoefficient left, HeatTransferCoefficient right);
    public static override HeatTransferCoefficient op_Subtraction(HeatTransferCoefficient left, HeatTransferCoefficient right);
    public static HeatTransferCoefficient op_Multiply(double left, HeatTransferCoefficient right);
    public static override HeatTransferCoefficient op_Multiply(HeatTransferCoefficient left, double right);
    public static override HeatTransferCoefficient op_Division(HeatTransferCoefficient left, double right);
    public static double op_Division(HeatTransferCoefficient left, HeatTransferCoefficient right);
    public static override bool op_LessThanOrEqual(HeatTransferCoefficient left, HeatTransferCoefficient right);
    public static override bool op_GreaterThanOrEqual(HeatTransferCoefficient left, HeatTransferCoefficient right);
    public static override bool op_LessThan(HeatTransferCoefficient left, HeatTransferCoefficient right);
    public static override bool op_GreaterThan(HeatTransferCoefficient left, HeatTransferCoefficient right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(HeatTransferCoefficient other, HeatTransferCoefficient tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(HeatTransferCoefficient left, HeatTransferCoefficient right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(HeatTransferCoefficient other, HeatTransferCoefficient tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(HeatTransferCoefficient left, HeatTransferCoefficient right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(HeatTransferCoefficient other, HeatTransferCoefficient tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(HeatTransferCoefficient other, HeatTransferCoefficient tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(HeatTransferCoefficient other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(HeatTransferCoefficient other);
    [ObsoleteAttribute("Use Equals(HeatTransferCoefficient other, HeatTransferCoefficient tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(HeatTransferCoefficient other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(HeatTransferCoefficient other, HeatTransferCoefficient tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(HeatTransferCoefficientUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public HeatTransferCoefficient ToUnit(HeatTransferCoefficientUnit unit);
    public HeatTransferCoefficient ToUnit(HeatTransferCoefficientUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(HeatTransferCoefficientUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public HeatTransferCoefficient ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<HeatTransferCoefficientUnit> UnitsNet.IQuantity<UnitsNet.Units.HeatTransferCoefficientUnit>.ToUnit(HeatTransferCoefficientUnit unit);
    private sealed virtual override IQuantity`1<HeatTransferCoefficientUnit> UnitsNet.IQuantity<UnitsNet.Units.HeatTransferCoefficientUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
public interface UnitsNet.IArithmeticQuantity`2 {
    [NullableAttribute("1")]
public static TSelf Zero { get; }
    [NullableContextAttribute("1")]
public static abstract virtual TSelf get_Zero();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Illuminance : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<IlluminanceUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<IlluminanceUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static IlluminanceUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static IlluminanceUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Illuminance <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<IlluminanceUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static IlluminanceUnit BaseUnit { get; }
    public static IlluminanceUnit[] Units { get; }
    public static Illuminance Zero { get; }
    public static Illuminance AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public IlluminanceUnit Unit { get; }
    public QuantityInfo`1<IlluminanceUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Kilolux { get; }
    public double Lux { get; }
    public double Megalux { get; }
    public double Millilux { get; }
    private static Illuminance();
    public Illuminance(double value, IlluminanceUnit unit);
    public Illuminance(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<IlluminanceUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static IlluminanceUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static IlluminanceUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Illuminance get_Zero();
    public static override Illuminance get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual IlluminanceUnit get_Unit();
    public sealed virtual QuantityInfo`1<IlluminanceUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Kilolux();
    public double get_Lux();
    public double get_Megalux();
    public double get_Millilux();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(IlluminanceUnit unit);
    public static string GetAbbreviation(IlluminanceUnit unit, IFormatProvider provider);
    public static Illuminance FromKilolux(double value);
    public static Illuminance FromLux(double value);
    public static Illuminance FromMegalux(double value);
    public static Illuminance FromMillilux(double value);
    public static Illuminance From(double value, IlluminanceUnit fromUnit);
    public static Illuminance Parse(string str);
    public static override Illuminance Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Illuminance& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Illuminance& result);
    public static IlluminanceUnit ParseUnit(string str);
    public static IlluminanceUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, IlluminanceUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, IlluminanceUnit& unit);
    public static override Illuminance op_UnaryNegation(Illuminance right);
    public static override Illuminance op_Addition(Illuminance left, Illuminance right);
    public static override Illuminance op_Subtraction(Illuminance left, Illuminance right);
    public static Illuminance op_Multiply(double left, Illuminance right);
    public static override Illuminance op_Multiply(Illuminance left, double right);
    public static override Illuminance op_Division(Illuminance left, double right);
    public static double op_Division(Illuminance left, Illuminance right);
    public static override bool op_LessThanOrEqual(Illuminance left, Illuminance right);
    public static override bool op_GreaterThanOrEqual(Illuminance left, Illuminance right);
    public static override bool op_LessThan(Illuminance left, Illuminance right);
    public static override bool op_GreaterThan(Illuminance left, Illuminance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Illuminance other, Illuminance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Illuminance left, Illuminance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Illuminance other, Illuminance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Illuminance left, Illuminance right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Illuminance other, Illuminance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Illuminance other, Illuminance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Illuminance other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Illuminance other);
    [ObsoleteAttribute("Use Equals(Illuminance other, Illuminance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Illuminance other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Illuminance other, Illuminance tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(IlluminanceUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Illuminance ToUnit(IlluminanceUnit unit);
    public Illuminance ToUnit(IlluminanceUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(IlluminanceUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Illuminance ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<IlluminanceUnit> UnitsNet.IQuantity<UnitsNet.Units.IlluminanceUnit>.ToUnit(IlluminanceUnit unit);
    private sealed virtual override IQuantity`1<IlluminanceUnit> UnitsNet.IQuantity<UnitsNet.Units.IlluminanceUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Impulse : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ImpulseUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ImpulseUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImpulseUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImpulseUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Impulse <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ImpulseUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ImpulseUnit BaseUnit { get; }
    public static ImpulseUnit[] Units { get; }
    public static Impulse Zero { get; }
    public static Impulse AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ImpulseUnit Unit { get; }
    public QuantityInfo`1<ImpulseUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentinewtonSeconds { get; }
    public double DecanewtonSeconds { get; }
    public double DecinewtonSeconds { get; }
    public double KilogramMetersPerSecond { get; }
    public double KilonewtonSeconds { get; }
    public double MeganewtonSeconds { get; }
    public double MicronewtonSeconds { get; }
    public double MillinewtonSeconds { get; }
    public double NanonewtonSeconds { get; }
    public double NewtonSeconds { get; }
    public double PoundFeetPerSecond { get; }
    public double PoundForceSeconds { get; }
    public double SlugFeetPerSecond { get; }
    private static Impulse();
    public Impulse(double value, ImpulseUnit unit);
    public Impulse(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ImpulseUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ImpulseUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ImpulseUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Impulse get_Zero();
    public static override Impulse get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ImpulseUnit get_Unit();
    public sealed virtual QuantityInfo`1<ImpulseUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentinewtonSeconds();
    public double get_DecanewtonSeconds();
    public double get_DecinewtonSeconds();
    public double get_KilogramMetersPerSecond();
    public double get_KilonewtonSeconds();
    public double get_MeganewtonSeconds();
    public double get_MicronewtonSeconds();
    public double get_MillinewtonSeconds();
    public double get_NanonewtonSeconds();
    public double get_NewtonSeconds();
    public double get_PoundFeetPerSecond();
    public double get_PoundForceSeconds();
    public double get_SlugFeetPerSecond();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ImpulseUnit unit);
    public static string GetAbbreviation(ImpulseUnit unit, IFormatProvider provider);
    public static Impulse FromCentinewtonSeconds(double value);
    public static Impulse FromDecanewtonSeconds(double value);
    public static Impulse FromDecinewtonSeconds(double value);
    public static Impulse FromKilogramMetersPerSecond(double value);
    public static Impulse FromKilonewtonSeconds(double value);
    public static Impulse FromMeganewtonSeconds(double value);
    public static Impulse FromMicronewtonSeconds(double value);
    public static Impulse FromMillinewtonSeconds(double value);
    public static Impulse FromNanonewtonSeconds(double value);
    public static Impulse FromNewtonSeconds(double value);
    public static Impulse FromPoundFeetPerSecond(double value);
    public static Impulse FromPoundForceSeconds(double value);
    public static Impulse FromSlugFeetPerSecond(double value);
    public static Impulse From(double value, ImpulseUnit fromUnit);
    public static Impulse Parse(string str);
    public static override Impulse Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Impulse& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Impulse& result);
    public static ImpulseUnit ParseUnit(string str);
    public static ImpulseUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ImpulseUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ImpulseUnit& unit);
    public static override Impulse op_UnaryNegation(Impulse right);
    public static override Impulse op_Addition(Impulse left, Impulse right);
    public static override Impulse op_Subtraction(Impulse left, Impulse right);
    public static Impulse op_Multiply(double left, Impulse right);
    public static override Impulse op_Multiply(Impulse left, double right);
    public static override Impulse op_Division(Impulse left, double right);
    public static double op_Division(Impulse left, Impulse right);
    public static override bool op_LessThanOrEqual(Impulse left, Impulse right);
    public static override bool op_GreaterThanOrEqual(Impulse left, Impulse right);
    public static override bool op_LessThan(Impulse left, Impulse right);
    public static override bool op_GreaterThan(Impulse left, Impulse right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Impulse other, Impulse tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Impulse left, Impulse right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Impulse other, Impulse tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Impulse left, Impulse right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Impulse other, Impulse tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Impulse other, Impulse tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Impulse other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Impulse other);
    [ObsoleteAttribute("Use Equals(Impulse other, Impulse tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Impulse other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Impulse other, Impulse tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ImpulseUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Impulse ToUnit(ImpulseUnit unit);
    public Impulse ToUnit(ImpulseUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ImpulseUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Impulse ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ImpulseUnit> UnitsNet.IQuantity<UnitsNet.Units.ImpulseUnit>.ToUnit(ImpulseUnit unit);
    private sealed virtual override IQuantity`1<ImpulseUnit> UnitsNet.IQuantity<UnitsNet.Units.ImpulseUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Information : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<InformationUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<InformationUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static InformationUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static InformationUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Information <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<InformationUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static InformationUnit BaseUnit { get; }
    public static InformationUnit[] Units { get; }
    public static Information Zero { get; }
    public static Information AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public InformationUnit Unit { get; }
    public QuantityInfo`1<InformationUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Bits { get; }
    public double Bytes { get; }
    public double Exabits { get; }
    public double Exabytes { get; }
    public double Exbibits { get; }
    public double Exbibytes { get; }
    public double Gibibits { get; }
    public double Gibibytes { get; }
    public double Gigabits { get; }
    public double Gigabytes { get; }
    public double Kibibits { get; }
    public double Kibibytes { get; }
    public double Kilobits { get; }
    public double Kilobytes { get; }
    public double Mebibits { get; }
    public double Mebibytes { get; }
    public double Megabits { get; }
    public double Megabytes { get; }
    public double Pebibits { get; }
    public double Pebibytes { get; }
    public double Petabits { get; }
    public double Petabytes { get; }
    public double Tebibits { get; }
    public double Tebibytes { get; }
    public double Terabits { get; }
    public double Terabytes { get; }
    private static Information();
    public Information(double value, InformationUnit unit);
    public Information(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<InformationUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static InformationUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static InformationUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Information get_Zero();
    public static override Information get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual InformationUnit get_Unit();
    public sealed virtual QuantityInfo`1<InformationUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Bits();
    public double get_Bytes();
    public double get_Exabits();
    public double get_Exabytes();
    public double get_Exbibits();
    public double get_Exbibytes();
    public double get_Gibibits();
    public double get_Gibibytes();
    public double get_Gigabits();
    public double get_Gigabytes();
    public double get_Kibibits();
    public double get_Kibibytes();
    public double get_Kilobits();
    public double get_Kilobytes();
    public double get_Mebibits();
    public double get_Mebibytes();
    public double get_Megabits();
    public double get_Megabytes();
    public double get_Pebibits();
    public double get_Pebibytes();
    public double get_Petabits();
    public double get_Petabytes();
    public double get_Tebibits();
    public double get_Tebibytes();
    public double get_Terabits();
    public double get_Terabytes();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(InformationUnit unit);
    public static string GetAbbreviation(InformationUnit unit, IFormatProvider provider);
    public static Information FromBits(double value);
    public static Information FromBytes(double value);
    public static Information FromExabits(double value);
    public static Information FromExabytes(double value);
    public static Information FromExbibits(double value);
    public static Information FromExbibytes(double value);
    public static Information FromGibibits(double value);
    public static Information FromGibibytes(double value);
    public static Information FromGigabits(double value);
    public static Information FromGigabytes(double value);
    public static Information FromKibibits(double value);
    public static Information FromKibibytes(double value);
    public static Information FromKilobits(double value);
    public static Information FromKilobytes(double value);
    public static Information FromMebibits(double value);
    public static Information FromMebibytes(double value);
    public static Information FromMegabits(double value);
    public static Information FromMegabytes(double value);
    public static Information FromPebibits(double value);
    public static Information FromPebibytes(double value);
    public static Information FromPetabits(double value);
    public static Information FromPetabytes(double value);
    public static Information FromTebibits(double value);
    public static Information FromTebibytes(double value);
    public static Information FromTerabits(double value);
    public static Information FromTerabytes(double value);
    public static Information From(double value, InformationUnit fromUnit);
    public static Information Parse(string str);
    public static override Information Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Information& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Information& result);
    public static InformationUnit ParseUnit(string str);
    public static InformationUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, InformationUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, InformationUnit& unit);
    public static override Information op_UnaryNegation(Information right);
    public static override Information op_Addition(Information left, Information right);
    public static override Information op_Subtraction(Information left, Information right);
    public static Information op_Multiply(double left, Information right);
    public static override Information op_Multiply(Information left, double right);
    public static override Information op_Division(Information left, double right);
    public static double op_Division(Information left, Information right);
    public static override bool op_LessThanOrEqual(Information left, Information right);
    public static override bool op_GreaterThanOrEqual(Information left, Information right);
    public static override bool op_LessThan(Information left, Information right);
    public static override bool op_GreaterThan(Information left, Information right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Information other, Information tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Information left, Information right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Information other, Information tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Information left, Information right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Information other, Information tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Information other, Information tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Information other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Information other);
    [ObsoleteAttribute("Use Equals(Information other, Information tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Information other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Information other, Information tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(InformationUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Information ToUnit(InformationUnit unit);
    public Information ToUnit(InformationUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(InformationUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Information ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<InformationUnit> UnitsNet.IQuantity<UnitsNet.Units.InformationUnit>.ToUnit(InformationUnit unit);
    private sealed virtual override IQuantity`1<InformationUnit> UnitsNet.IQuantity<UnitsNet.Units.InformationUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
internal static class UnitsNet.InternalHelpers.BytesUtility : object {
    internal static Byte[] GetBytes(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class UnitsNet.InternalHelpers.CultureHelper : object {
    private static ConcurrentDictionary`2<string, CultureInfo> CultureCache;
    private static CultureHelper();
    internal static CultureInfo GetCultureOrInvariant(string cultureName);
}
[NullableContextAttribute("1")]
public interface UnitsNet.IQuantity {
    public BaseDimensions Dimensions { get; }
    public QuantityInfo QuantityInfo { get; }
    public Enum Unit { get; }
    public double Value { get; }
    public abstract virtual BaseDimensions get_Dimensions();
    public abstract virtual QuantityInfo get_QuantityInfo();
    public abstract virtual double As(Enum unit);
    public abstract virtual double As(UnitSystem unitSystem);
    public abstract virtual bool Equals(IQuantity other, IQuantity tolerance);
    public abstract virtual Enum get_Unit();
    public abstract virtual double get_Value();
    public abstract virtual IQuantity ToUnit(Enum unit);
    public abstract virtual IQuantity ToUnit(UnitSystem unitSystem);
    public abstract virtual string ToString(IFormatProvider provider);
}
[NullableContextAttribute("1")]
public interface UnitsNet.IQuantity`1 {
    public TUnitType Unit { get; }
    public QuantityInfo`1<TUnitType> QuantityInfo { get; }
    public abstract virtual double As(TUnitType unit);
    public abstract virtual TUnitType get_Unit();
    public abstract virtual QuantityInfo`1<TUnitType> get_QuantityInfo();
    public abstract virtual IQuantity`1<TUnitType> ToUnit(TUnitType unit);
    public abstract virtual IQuantity`1<TUnitType> ToUnit(UnitSystem unitSystem);
}
public interface UnitsNet.IQuantity`2 {
    [NullableContextAttribute("1")]
public abstract virtual bool Equals(TSelf other, TSelf tolerance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Irradiance : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<IrradianceUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<IrradianceUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static IrradianceUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static IrradianceUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Irradiance <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<IrradianceUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static IrradianceUnit BaseUnit { get; }
    public static IrradianceUnit[] Units { get; }
    public static Irradiance Zero { get; }
    public static Irradiance AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public IrradianceUnit Unit { get; }
    public QuantityInfo`1<IrradianceUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double KilowattsPerSquareCentimeter { get; }
    public double KilowattsPerSquareMeter { get; }
    public double MegawattsPerSquareCentimeter { get; }
    public double MegawattsPerSquareMeter { get; }
    public double MicrowattsPerSquareCentimeter { get; }
    public double MicrowattsPerSquareMeter { get; }
    public double MilliwattsPerSquareCentimeter { get; }
    public double MilliwattsPerSquareMeter { get; }
    public double NanowattsPerSquareCentimeter { get; }
    public double NanowattsPerSquareMeter { get; }
    public double PicowattsPerSquareCentimeter { get; }
    public double PicowattsPerSquareMeter { get; }
    public double WattsPerSquareCentimeter { get; }
    public double WattsPerSquareMeter { get; }
    private static Irradiance();
    public Irradiance(double value, IrradianceUnit unit);
    public Irradiance(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<IrradianceUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static IrradianceUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static IrradianceUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Irradiance get_Zero();
    public static override Irradiance get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual IrradianceUnit get_Unit();
    public sealed virtual QuantityInfo`1<IrradianceUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_KilowattsPerSquareCentimeter();
    public double get_KilowattsPerSquareMeter();
    public double get_MegawattsPerSquareCentimeter();
    public double get_MegawattsPerSquareMeter();
    public double get_MicrowattsPerSquareCentimeter();
    public double get_MicrowattsPerSquareMeter();
    public double get_MilliwattsPerSquareCentimeter();
    public double get_MilliwattsPerSquareMeter();
    public double get_NanowattsPerSquareCentimeter();
    public double get_NanowattsPerSquareMeter();
    public double get_PicowattsPerSquareCentimeter();
    public double get_PicowattsPerSquareMeter();
    public double get_WattsPerSquareCentimeter();
    public double get_WattsPerSquareMeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(IrradianceUnit unit);
    public static string GetAbbreviation(IrradianceUnit unit, IFormatProvider provider);
    public static Irradiance FromKilowattsPerSquareCentimeter(double value);
    public static Irradiance FromKilowattsPerSquareMeter(double value);
    public static Irradiance FromMegawattsPerSquareCentimeter(double value);
    public static Irradiance FromMegawattsPerSquareMeter(double value);
    public static Irradiance FromMicrowattsPerSquareCentimeter(double value);
    public static Irradiance FromMicrowattsPerSquareMeter(double value);
    public static Irradiance FromMilliwattsPerSquareCentimeter(double value);
    public static Irradiance FromMilliwattsPerSquareMeter(double value);
    public static Irradiance FromNanowattsPerSquareCentimeter(double value);
    public static Irradiance FromNanowattsPerSquareMeter(double value);
    public static Irradiance FromPicowattsPerSquareCentimeter(double value);
    public static Irradiance FromPicowattsPerSquareMeter(double value);
    public static Irradiance FromWattsPerSquareCentimeter(double value);
    public static Irradiance FromWattsPerSquareMeter(double value);
    public static Irradiance From(double value, IrradianceUnit fromUnit);
    public static Irradiance Parse(string str);
    public static override Irradiance Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Irradiance& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Irradiance& result);
    public static IrradianceUnit ParseUnit(string str);
    public static IrradianceUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, IrradianceUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, IrradianceUnit& unit);
    public static override Irradiance op_UnaryNegation(Irradiance right);
    public static override Irradiance op_Addition(Irradiance left, Irradiance right);
    public static override Irradiance op_Subtraction(Irradiance left, Irradiance right);
    public static Irradiance op_Multiply(double left, Irradiance right);
    public static override Irradiance op_Multiply(Irradiance left, double right);
    public static override Irradiance op_Division(Irradiance left, double right);
    public static double op_Division(Irradiance left, Irradiance right);
    public static override bool op_LessThanOrEqual(Irradiance left, Irradiance right);
    public static override bool op_GreaterThanOrEqual(Irradiance left, Irradiance right);
    public static override bool op_LessThan(Irradiance left, Irradiance right);
    public static override bool op_GreaterThan(Irradiance left, Irradiance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Irradiance other, Irradiance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Irradiance left, Irradiance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Irradiance other, Irradiance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Irradiance left, Irradiance right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Irradiance other, Irradiance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Irradiance other, Irradiance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Irradiance other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Irradiance other);
    [ObsoleteAttribute("Use Equals(Irradiance other, Irradiance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Irradiance other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Irradiance other, Irradiance tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(IrradianceUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Irradiance ToUnit(IrradianceUnit unit);
    public Irradiance ToUnit(IrradianceUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(IrradianceUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Irradiance ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<IrradianceUnit> UnitsNet.IQuantity<UnitsNet.Units.IrradianceUnit>.ToUnit(IrradianceUnit unit);
    private sealed virtual override IQuantity`1<IrradianceUnit> UnitsNet.IQuantity<UnitsNet.Units.IrradianceUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Irradiation : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<IrradiationUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<IrradiationUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static IrradiationUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static IrradiationUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Irradiation <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<IrradiationUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static IrradiationUnit BaseUnit { get; }
    public static IrradiationUnit[] Units { get; }
    public static Irradiation Zero { get; }
    public static Irradiation AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public IrradiationUnit Unit { get; }
    public QuantityInfo`1<IrradiationUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double BtusPerSquareFoot { get; }
    public double JoulesPerSquareCentimeter { get; }
    public double JoulesPerSquareMeter { get; }
    public double JoulesPerSquareMillimeter { get; }
    public double KilobtusPerSquareFoot { get; }
    public double KilojoulesPerSquareMeter { get; }
    public double KilowattHoursPerSquareMeter { get; }
    public double MillijoulesPerSquareCentimeter { get; }
    public double WattHoursPerSquareMeter { get; }
    private static Irradiation();
    public Irradiation(double value, IrradiationUnit unit);
    public Irradiation(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<IrradiationUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static IrradiationUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static IrradiationUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Irradiation get_Zero();
    public static override Irradiation get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual IrradiationUnit get_Unit();
    public sealed virtual QuantityInfo`1<IrradiationUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_BtusPerSquareFoot();
    public double get_JoulesPerSquareCentimeter();
    public double get_JoulesPerSquareMeter();
    public double get_JoulesPerSquareMillimeter();
    public double get_KilobtusPerSquareFoot();
    public double get_KilojoulesPerSquareMeter();
    public double get_KilowattHoursPerSquareMeter();
    public double get_MillijoulesPerSquareCentimeter();
    public double get_WattHoursPerSquareMeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(IrradiationUnit unit);
    public static string GetAbbreviation(IrradiationUnit unit, IFormatProvider provider);
    public static Irradiation FromBtusPerSquareFoot(double value);
    public static Irradiation FromJoulesPerSquareCentimeter(double value);
    public static Irradiation FromJoulesPerSquareMeter(double value);
    public static Irradiation FromJoulesPerSquareMillimeter(double value);
    public static Irradiation FromKilobtusPerSquareFoot(double value);
    public static Irradiation FromKilojoulesPerSquareMeter(double value);
    public static Irradiation FromKilowattHoursPerSquareMeter(double value);
    public static Irradiation FromMillijoulesPerSquareCentimeter(double value);
    public static Irradiation FromWattHoursPerSquareMeter(double value);
    public static Irradiation From(double value, IrradiationUnit fromUnit);
    public static Irradiation Parse(string str);
    public static override Irradiation Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Irradiation& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Irradiation& result);
    public static IrradiationUnit ParseUnit(string str);
    public static IrradiationUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, IrradiationUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, IrradiationUnit& unit);
    public static override Irradiation op_UnaryNegation(Irradiation right);
    public static override Irradiation op_Addition(Irradiation left, Irradiation right);
    public static override Irradiation op_Subtraction(Irradiation left, Irradiation right);
    public static Irradiation op_Multiply(double left, Irradiation right);
    public static override Irradiation op_Multiply(Irradiation left, double right);
    public static override Irradiation op_Division(Irradiation left, double right);
    public static double op_Division(Irradiation left, Irradiation right);
    public static override bool op_LessThanOrEqual(Irradiation left, Irradiation right);
    public static override bool op_GreaterThanOrEqual(Irradiation left, Irradiation right);
    public static override bool op_LessThan(Irradiation left, Irradiation right);
    public static override bool op_GreaterThan(Irradiation left, Irradiation right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Irradiation other, Irradiation tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Irradiation left, Irradiation right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Irradiation other, Irradiation tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Irradiation left, Irradiation right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Irradiation other, Irradiation tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Irradiation other, Irradiation tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Irradiation other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Irradiation other);
    [ObsoleteAttribute("Use Equals(Irradiation other, Irradiation tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Irradiation other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Irradiation other, Irradiation tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(IrradiationUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Irradiation ToUnit(IrradiationUnit unit);
    public Irradiation ToUnit(IrradiationUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(IrradiationUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Irradiation ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<IrradiationUnit> UnitsNet.IQuantity<UnitsNet.Units.IrradiationUnit>.ToUnit(IrradiationUnit unit);
    private sealed virtual override IQuantity`1<IrradiationUnit> UnitsNet.IQuantity<UnitsNet.Units.IrradiationUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Jerk : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<JerkUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<JerkUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static JerkUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static JerkUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Jerk <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<JerkUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static JerkUnit BaseUnit { get; }
    public static JerkUnit[] Units { get; }
    public static Jerk Zero { get; }
    public static Jerk AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public JerkUnit Unit { get; }
    public QuantityInfo`1<JerkUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentimetersPerSecondCubed { get; }
    public double DecimetersPerSecondCubed { get; }
    public double FeetPerSecondCubed { get; }
    public double InchesPerSecondCubed { get; }
    public double KilometersPerSecondCubed { get; }
    public double MetersPerSecondCubed { get; }
    public double MicrometersPerSecondCubed { get; }
    public double MillimetersPerSecondCubed { get; }
    public double MillistandardGravitiesPerSecond { get; }
    public double NanometersPerSecondCubed { get; }
    public double StandardGravitiesPerSecond { get; }
    private static Jerk();
    public Jerk(double value, JerkUnit unit);
    public Jerk(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<JerkUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static JerkUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static JerkUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Jerk get_Zero();
    public static override Jerk get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual JerkUnit get_Unit();
    public sealed virtual QuantityInfo`1<JerkUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentimetersPerSecondCubed();
    public double get_DecimetersPerSecondCubed();
    public double get_FeetPerSecondCubed();
    public double get_InchesPerSecondCubed();
    public double get_KilometersPerSecondCubed();
    public double get_MetersPerSecondCubed();
    public double get_MicrometersPerSecondCubed();
    public double get_MillimetersPerSecondCubed();
    public double get_MillistandardGravitiesPerSecond();
    public double get_NanometersPerSecondCubed();
    public double get_StandardGravitiesPerSecond();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(JerkUnit unit);
    public static string GetAbbreviation(JerkUnit unit, IFormatProvider provider);
    public static Jerk FromCentimetersPerSecondCubed(double value);
    public static Jerk FromDecimetersPerSecondCubed(double value);
    public static Jerk FromFeetPerSecondCubed(double value);
    public static Jerk FromInchesPerSecondCubed(double value);
    public static Jerk FromKilometersPerSecondCubed(double value);
    public static Jerk FromMetersPerSecondCubed(double value);
    public static Jerk FromMicrometersPerSecondCubed(double value);
    public static Jerk FromMillimetersPerSecondCubed(double value);
    public static Jerk FromMillistandardGravitiesPerSecond(double value);
    public static Jerk FromNanometersPerSecondCubed(double value);
    public static Jerk FromStandardGravitiesPerSecond(double value);
    public static Jerk From(double value, JerkUnit fromUnit);
    public static Jerk Parse(string str);
    public static override Jerk Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Jerk& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Jerk& result);
    public static JerkUnit ParseUnit(string str);
    public static JerkUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, JerkUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, JerkUnit& unit);
    public static override Jerk op_UnaryNegation(Jerk right);
    public static override Jerk op_Addition(Jerk left, Jerk right);
    public static override Jerk op_Subtraction(Jerk left, Jerk right);
    public static Jerk op_Multiply(double left, Jerk right);
    public static override Jerk op_Multiply(Jerk left, double right);
    public static override Jerk op_Division(Jerk left, double right);
    public static double op_Division(Jerk left, Jerk right);
    public static override Acceleration op_Multiply(Jerk jerk, Duration duration);
    public static override bool op_LessThanOrEqual(Jerk left, Jerk right);
    public static override bool op_GreaterThanOrEqual(Jerk left, Jerk right);
    public static override bool op_LessThan(Jerk left, Jerk right);
    public static override bool op_GreaterThan(Jerk left, Jerk right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Jerk other, Jerk tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Jerk left, Jerk right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Jerk other, Jerk tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Jerk left, Jerk right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Jerk other, Jerk tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Jerk other, Jerk tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Jerk other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Jerk other);
    [ObsoleteAttribute("Use Equals(Jerk other, Jerk tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Jerk other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Jerk other, Jerk tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(JerkUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Jerk ToUnit(JerkUnit unit);
    public Jerk ToUnit(JerkUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(JerkUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Jerk ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<JerkUnit> UnitsNet.IQuantity<UnitsNet.Units.JerkUnit>.ToUnit(JerkUnit unit);
    private sealed virtual override IQuantity`1<JerkUnit> UnitsNet.IQuantity<UnitsNet.Units.JerkUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.KinematicViscosity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<KinematicViscosityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<KinematicViscosityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static KinematicViscosityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static KinematicViscosityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static KinematicViscosity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<KinematicViscosityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static KinematicViscosityUnit BaseUnit { get; }
    public static KinematicViscosityUnit[] Units { get; }
    public static KinematicViscosity Zero { get; }
    public static KinematicViscosity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public KinematicViscosityUnit Unit { get; }
    public QuantityInfo`1<KinematicViscosityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Centistokes { get; }
    public double Decistokes { get; }
    public double Kilostokes { get; }
    public double Microstokes { get; }
    public double Millistokes { get; }
    public double Nanostokes { get; }
    public double SquareFeetPerSecond { get; }
    public double SquareMetersPerSecond { get; }
    public double Stokes { get; }
    private static KinematicViscosity();
    public KinematicViscosity(double value, KinematicViscosityUnit unit);
    public KinematicViscosity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<KinematicViscosityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static KinematicViscosityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static KinematicViscosityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override KinematicViscosity get_Zero();
    public static override KinematicViscosity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual KinematicViscosityUnit get_Unit();
    public sealed virtual QuantityInfo`1<KinematicViscosityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Centistokes();
    public double get_Decistokes();
    public double get_Kilostokes();
    public double get_Microstokes();
    public double get_Millistokes();
    public double get_Nanostokes();
    public double get_SquareFeetPerSecond();
    public double get_SquareMetersPerSecond();
    public double get_Stokes();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(KinematicViscosityUnit unit);
    public static string GetAbbreviation(KinematicViscosityUnit unit, IFormatProvider provider);
    public static KinematicViscosity FromCentistokes(double value);
    public static KinematicViscosity FromDecistokes(double value);
    public static KinematicViscosity FromKilostokes(double value);
    public static KinematicViscosity FromMicrostokes(double value);
    public static KinematicViscosity FromMillistokes(double value);
    public static KinematicViscosity FromNanostokes(double value);
    public static KinematicViscosity FromSquareFeetPerSecond(double value);
    public static KinematicViscosity FromSquareMetersPerSecond(double value);
    public static KinematicViscosity FromStokes(double value);
    public static KinematicViscosity From(double value, KinematicViscosityUnit fromUnit);
    public static KinematicViscosity Parse(string str);
    public static override KinematicViscosity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, KinematicViscosity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, KinematicViscosity& result);
    public static KinematicViscosityUnit ParseUnit(string str);
    public static KinematicViscosityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, KinematicViscosityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, KinematicViscosityUnit& unit);
    public static override KinematicViscosity op_UnaryNegation(KinematicViscosity right);
    public static override KinematicViscosity op_Addition(KinematicViscosity left, KinematicViscosity right);
    public static override KinematicViscosity op_Subtraction(KinematicViscosity left, KinematicViscosity right);
    public static KinematicViscosity op_Multiply(double left, KinematicViscosity right);
    public static override KinematicViscosity op_Multiply(KinematicViscosity left, double right);
    public static override KinematicViscosity op_Division(KinematicViscosity left, double right);
    public static double op_Division(KinematicViscosity left, KinematicViscosity right);
    public static override Area op_Multiply(KinematicViscosity kinematicViscosity, Duration duration);
    public static override DynamicViscosity op_Multiply(KinematicViscosity kinematicViscosity, Density density);
    public static override Length op_Division(KinematicViscosity kinematicViscosity, Speed speed);
    public static override Speed op_Division(KinematicViscosity kinematicViscosity, Length length);
    public static override bool op_LessThanOrEqual(KinematicViscosity left, KinematicViscosity right);
    public static override bool op_GreaterThanOrEqual(KinematicViscosity left, KinematicViscosity right);
    public static override bool op_LessThan(KinematicViscosity left, KinematicViscosity right);
    public static override bool op_GreaterThan(KinematicViscosity left, KinematicViscosity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(KinematicViscosity other, KinematicViscosity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(KinematicViscosity left, KinematicViscosity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(KinematicViscosity other, KinematicViscosity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(KinematicViscosity left, KinematicViscosity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(KinematicViscosity other, KinematicViscosity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(KinematicViscosity other, KinematicViscosity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(KinematicViscosity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(KinematicViscosity other);
    [ObsoleteAttribute("Use Equals(KinematicViscosity other, KinematicViscosity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(KinematicViscosity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(KinematicViscosity other, KinematicViscosity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(KinematicViscosityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public KinematicViscosity ToUnit(KinematicViscosityUnit unit);
    public KinematicViscosity ToUnit(KinematicViscosityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(KinematicViscosityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public KinematicViscosity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<KinematicViscosityUnit> UnitsNet.IQuantity<UnitsNet.Units.KinematicViscosityUnit>.ToUnit(KinematicViscosityUnit unit);
    private sealed virtual override IQuantity`1<KinematicViscosityUnit> UnitsNet.IQuantity<UnitsNet.Units.KinematicViscosityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.LeakRate : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<LeakRateUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<LeakRateUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static LeakRateUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static LeakRateUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static LeakRate <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<LeakRateUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static LeakRateUnit BaseUnit { get; }
    public static LeakRateUnit[] Units { get; }
    public static LeakRate Zero { get; }
    public static LeakRate AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public LeakRateUnit Unit { get; }
    public QuantityInfo`1<LeakRateUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double MillibarLitersPerSecond { get; }
    public double PascalCubicMetersPerSecond { get; }
    public double TorrLitersPerSecond { get; }
    private static LeakRate();
    public LeakRate(double value, LeakRateUnit unit);
    public LeakRate(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<LeakRateUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static LeakRateUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static LeakRateUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override LeakRate get_Zero();
    public static override LeakRate get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual LeakRateUnit get_Unit();
    public sealed virtual QuantityInfo`1<LeakRateUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_MillibarLitersPerSecond();
    public double get_PascalCubicMetersPerSecond();
    public double get_TorrLitersPerSecond();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(LeakRateUnit unit);
    public static string GetAbbreviation(LeakRateUnit unit, IFormatProvider provider);
    public static LeakRate FromMillibarLitersPerSecond(double value);
    public static LeakRate FromPascalCubicMetersPerSecond(double value);
    public static LeakRate FromTorrLitersPerSecond(double value);
    public static LeakRate From(double value, LeakRateUnit fromUnit);
    public static LeakRate Parse(string str);
    public static override LeakRate Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, LeakRate& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, LeakRate& result);
    public static LeakRateUnit ParseUnit(string str);
    public static LeakRateUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, LeakRateUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, LeakRateUnit& unit);
    public static override LeakRate op_UnaryNegation(LeakRate right);
    public static override LeakRate op_Addition(LeakRate left, LeakRate right);
    public static override LeakRate op_Subtraction(LeakRate left, LeakRate right);
    public static LeakRate op_Multiply(double left, LeakRate right);
    public static override LeakRate op_Multiply(LeakRate left, double right);
    public static override LeakRate op_Division(LeakRate left, double right);
    public static double op_Division(LeakRate left, LeakRate right);
    public static override bool op_LessThanOrEqual(LeakRate left, LeakRate right);
    public static override bool op_GreaterThanOrEqual(LeakRate left, LeakRate right);
    public static override bool op_LessThan(LeakRate left, LeakRate right);
    public static override bool op_GreaterThan(LeakRate left, LeakRate right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(LeakRate other, LeakRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(LeakRate left, LeakRate right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(LeakRate other, LeakRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(LeakRate left, LeakRate right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(LeakRate other, LeakRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(LeakRate other, LeakRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(LeakRate other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(LeakRate other);
    [ObsoleteAttribute("Use Equals(LeakRate other, LeakRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(LeakRate other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(LeakRate other, LeakRate tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(LeakRateUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public LeakRate ToUnit(LeakRateUnit unit);
    public LeakRate ToUnit(LeakRateUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(LeakRateUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public LeakRate ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<LeakRateUnit> UnitsNet.IQuantity<UnitsNet.Units.LeakRateUnit>.ToUnit(LeakRateUnit unit);
    private sealed virtual override IQuantity`1<LeakRateUnit> UnitsNet.IQuantity<UnitsNet.Units.LeakRateUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Length : ValueType {
    private static double InchesInOneFoot;
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<LengthUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<LengthUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static LengthUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static LengthUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Length <Zero>k__BackingField;
    public FeetInches FeetInches { get; }
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<LengthUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static LengthUnit BaseUnit { get; }
    public static LengthUnit[] Units { get; }
    public static Length Zero { get; }
    public static Length AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public LengthUnit Unit { get; }
    public QuantityInfo`1<LengthUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Angstroms { get; }
    public double AstronomicalUnits { get; }
    public double Centimeters { get; }
    public double Chains { get; }
    public double DataMiles { get; }
    public double Decameters { get; }
    public double Decimeters { get; }
    public double DtpPicas { get; }
    public double DtpPoints { get; }
    public double Fathoms { get; }
    public double Femtometers { get; }
    public double Feet { get; }
    public double Gigameters { get; }
    public double Hands { get; }
    public double Hectometers { get; }
    public double Inches { get; }
    public double Kilofeet { get; }
    public double KilolightYears { get; }
    public double Kilometers { get; }
    public double Kiloparsecs { get; }
    public double Kiloyards { get; }
    public double LightYears { get; }
    public double MegalightYears { get; }
    public double Megameters { get; }
    public double Megaparsecs { get; }
    public double Meters { get; }
    public double Microinches { get; }
    public double Micrometers { get; }
    public double Mils { get; }
    public double Miles { get; }
    public double Millimeters { get; }
    public double Nanometers { get; }
    public double NauticalMiles { get; }
    public double Parsecs { get; }
    public double Picometers { get; }
    public double PrinterPicas { get; }
    public double PrinterPoints { get; }
    public double Shackles { get; }
    public double SolarRadiuses { get; }
    public double Twips { get; }
    public double UsSurveyFeet { get; }
    public double Yards { get; }
    private static Length();
    public Length(double value, LengthUnit unit);
    public Length(double value, UnitSystem unitSystem);
    public FeetInches get_FeetInches();
    public static Length FromFeetInches(double feet, double inches);
    public static Length ParseFeetInches(string str, IFormatProvider formatProvider);
    [NullableContextAttribute("2")]
public static bool TryParseFeetInches(string str, Length& result, IFormatProvider formatProvider);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<LengthUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static LengthUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static LengthUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Length get_Zero();
    public static override Length get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual LengthUnit get_Unit();
    public sealed virtual QuantityInfo`1<LengthUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Angstroms();
    public double get_AstronomicalUnits();
    public double get_Centimeters();
    public double get_Chains();
    public double get_DataMiles();
    public double get_Decameters();
    public double get_Decimeters();
    public double get_DtpPicas();
    public double get_DtpPoints();
    public double get_Fathoms();
    public double get_Femtometers();
    public double get_Feet();
    public double get_Gigameters();
    public double get_Hands();
    public double get_Hectometers();
    public double get_Inches();
    public double get_Kilofeet();
    public double get_KilolightYears();
    public double get_Kilometers();
    public double get_Kiloparsecs();
    public double get_Kiloyards();
    public double get_LightYears();
    public double get_MegalightYears();
    public double get_Megameters();
    public double get_Megaparsecs();
    public double get_Meters();
    public double get_Microinches();
    public double get_Micrometers();
    public double get_Mils();
    public double get_Miles();
    public double get_Millimeters();
    public double get_Nanometers();
    public double get_NauticalMiles();
    public double get_Parsecs();
    public double get_Picometers();
    public double get_PrinterPicas();
    public double get_PrinterPoints();
    public double get_Shackles();
    public double get_SolarRadiuses();
    public double get_Twips();
    public double get_UsSurveyFeet();
    public double get_Yards();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(LengthUnit unit);
    public static string GetAbbreviation(LengthUnit unit, IFormatProvider provider);
    public static Length FromAngstroms(double value);
    public static Length FromAstronomicalUnits(double value);
    public static Length FromCentimeters(double value);
    public static Length FromChains(double value);
    public static Length FromDataMiles(double value);
    public static Length FromDecameters(double value);
    public static Length FromDecimeters(double value);
    public static Length FromDtpPicas(double value);
    public static Length FromDtpPoints(double value);
    public static Length FromFathoms(double value);
    public static Length FromFemtometers(double value);
    public static Length FromFeet(double value);
    public static Length FromGigameters(double value);
    public static Length FromHands(double value);
    public static Length FromHectometers(double value);
    public static Length FromInches(double value);
    public static Length FromKilofeet(double value);
    public static Length FromKilolightYears(double value);
    public static Length FromKilometers(double value);
    public static Length FromKiloparsecs(double value);
    public static Length FromKiloyards(double value);
    public static Length FromLightYears(double value);
    public static Length FromMegalightYears(double value);
    public static Length FromMegameters(double value);
    public static Length FromMegaparsecs(double value);
    public static Length FromMeters(double value);
    public static Length FromMicroinches(double value);
    public static Length FromMicrometers(double value);
    public static Length FromMils(double value);
    public static Length FromMiles(double value);
    public static Length FromMillimeters(double value);
    public static Length FromNanometers(double value);
    public static Length FromNauticalMiles(double value);
    public static Length FromParsecs(double value);
    public static Length FromPicometers(double value);
    public static Length FromPrinterPicas(double value);
    public static Length FromPrinterPoints(double value);
    public static Length FromShackles(double value);
    public static Length FromSolarRadiuses(double value);
    public static Length FromTwips(double value);
    public static Length FromUsSurveyFeet(double value);
    public static Length FromYards(double value);
    public static Length From(double value, LengthUnit fromUnit);
    public static Length Parse(string str);
    public static override Length Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Length& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Length& result);
    public static LengthUnit ParseUnit(string str);
    public static LengthUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, LengthUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, LengthUnit& unit);
    public static override Length op_UnaryNegation(Length right);
    public static override Length op_Addition(Length left, Length right);
    public static override Length op_Subtraction(Length left, Length right);
    public static Length op_Multiply(double left, Length right);
    public static override Length op_Multiply(Length left, double right);
    public static override Length op_Division(Length left, double right);
    public static double op_Division(Length left, Length right);
    public ReciprocalLength Inverse();
    public static override Area op_Multiply(Length left, Length right);
    public static override Area op_Division(Length length, ReciprocalLength reciprocalLength);
    public static override AreaMomentOfInertia op_Multiply(Length length, Volume volume);
    public static override Duration op_Division(Length length, Speed speed);
    public static override Force op_Multiply(Length length, ForcePerLength forcePerLength);
    public static override ForcePerLength op_Multiply(Length length, Pressure pressure);
    public static override KinematicViscosity op_Multiply(Length length, Speed speed);
    public static override Mass op_Multiply(Length length, LinearDensity linearDensity);
    public static override Pressure op_Multiply(Length length, SpecificWeight specificWeight);
    public static override ReciprocalArea op_Division(Length length, Volume volume);
    public static override ReciprocalLength op_Multiply(Length length, ReciprocalArea reciprocalArea);
    public static override ReciprocalLength op_Division(Length length, Area area);
    public static override RotationalStiffness op_Multiply(Length length, RotationalStiffnessPerLength rotationalStiffnessPerLength);
    public static override Speed op_Division(Length length, Duration duration);
    public static override TemperatureDelta op_Multiply(Length length, TemperatureGradient temperatureGradient);
    public static override Torque op_Multiply(Length length, Force force);
    public static override Volume op_Multiply(Length length, Area area);
    public static override Volume op_Division(Length length, ReciprocalArea reciprocalArea);
    public static override bool op_LessThanOrEqual(Length left, Length right);
    public static override bool op_GreaterThanOrEqual(Length left, Length right);
    public static override bool op_LessThan(Length left, Length right);
    public static override bool op_GreaterThan(Length left, Length right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Length other, Length tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Length left, Length right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Length other, Length tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Length left, Length right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Length other, Length tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Length other, Length tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Length other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Length other);
    [ObsoleteAttribute("Use Equals(Length other, Length tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Length other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Length other, Length tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(LengthUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Length ToUnit(LengthUnit unit);
    public Length ToUnit(LengthUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(LengthUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Length ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<LengthUnit> UnitsNet.IQuantity<UnitsNet.Units.LengthUnit>.ToUnit(LengthUnit unit);
    private sealed virtual override IQuantity`1<LengthUnit> UnitsNet.IQuantity<UnitsNet.Units.LengthUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Level : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<LevelUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<LevelUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static LevelUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static LevelUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Level <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<LevelUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static LevelUnit BaseUnit { get; }
    public static LevelUnit[] Units { get; }
    public static Level Zero { get; }
    public static Level AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public LevelUnit Unit { get; }
    public QuantityInfo`1<LevelUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Decibels { get; }
    public double Nepers { get; }
    public Level(double quantity, double reference);
    private static Level();
    public Level(double value, LevelUnit unit);
    public Level(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<LevelUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static LevelUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static LevelUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Level get_Zero();
    public static override Level get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual LevelUnit get_Unit();
    public sealed virtual QuantityInfo`1<LevelUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Decibels();
    public double get_Nepers();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(LevelUnit unit);
    public static string GetAbbreviation(LevelUnit unit, IFormatProvider provider);
    public static Level FromDecibels(double value);
    public static Level FromNepers(double value);
    public static Level From(double value, LevelUnit fromUnit);
    public static Level Parse(string str);
    public static override Level Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Level& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Level& result);
    public static LevelUnit ParseUnit(string str);
    public static LevelUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, LevelUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, LevelUnit& unit);
    public static override Level op_UnaryNegation(Level right);
    public static override Level op_Addition(Level left, Level right);
    public static override Level op_Subtraction(Level left, Level right);
    public static Level op_Multiply(double left, Level right);
    public static override Level op_Multiply(Level left, double right);
    public static override Level op_Division(Level left, double right);
    public static double op_Division(Level left, Level right);
    public static override bool op_LessThanOrEqual(Level left, Level right);
    public static override bool op_GreaterThanOrEqual(Level left, Level right);
    public static override bool op_LessThan(Level left, Level right);
    public static override bool op_GreaterThan(Level left, Level right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Level other, Level tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Level left, Level right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Level other, Level tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Level left, Level right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Level other, Level tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Level other, Level tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Level other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Level other);
    [ObsoleteAttribute("Use Equals(Level other, Level tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Level other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Level other, Level tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(LevelUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Level ToUnit(LevelUnit unit);
    public Level ToUnit(LevelUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(LevelUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Level ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<LevelUnit> UnitsNet.IQuantity<UnitsNet.Units.LevelUnit>.ToUnit(LevelUnit unit);
    private sealed virtual override IQuantity`1<LevelUnit> UnitsNet.IQuantity<UnitsNet.Units.LevelUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.LinearDensity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<LinearDensityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<LinearDensityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static LinearDensityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static LinearDensityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static LinearDensity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<LinearDensityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static LinearDensityUnit BaseUnit { get; }
    public static LinearDensityUnit[] Units { get; }
    public static LinearDensity Zero { get; }
    public static LinearDensity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public LinearDensityUnit Unit { get; }
    public QuantityInfo`1<LinearDensityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double GramsPerCentimeter { get; }
    public double GramsPerFoot { get; }
    public double GramsPerMeter { get; }
    public double GramsPerMillimeter { get; }
    public double KilogramsPerCentimeter { get; }
    public double KilogramsPerFoot { get; }
    public double KilogramsPerMeter { get; }
    public double KilogramsPerMillimeter { get; }
    public double MicrogramsPerCentimeter { get; }
    public double MicrogramsPerFoot { get; }
    public double MicrogramsPerMeter { get; }
    public double MicrogramsPerMillimeter { get; }
    public double MilligramsPerCentimeter { get; }
    public double MilligramsPerFoot { get; }
    public double MilligramsPerMeter { get; }
    public double MilligramsPerMillimeter { get; }
    public double PoundsPerFoot { get; }
    public double PoundsPerInch { get; }
    private static LinearDensity();
    public LinearDensity(double value, LinearDensityUnit unit);
    public LinearDensity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<LinearDensityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static LinearDensityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static LinearDensityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override LinearDensity get_Zero();
    public static override LinearDensity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual LinearDensityUnit get_Unit();
    public sealed virtual QuantityInfo`1<LinearDensityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_GramsPerCentimeter();
    public double get_GramsPerFoot();
    public double get_GramsPerMeter();
    public double get_GramsPerMillimeter();
    public double get_KilogramsPerCentimeter();
    public double get_KilogramsPerFoot();
    public double get_KilogramsPerMeter();
    public double get_KilogramsPerMillimeter();
    public double get_MicrogramsPerCentimeter();
    public double get_MicrogramsPerFoot();
    public double get_MicrogramsPerMeter();
    public double get_MicrogramsPerMillimeter();
    public double get_MilligramsPerCentimeter();
    public double get_MilligramsPerFoot();
    public double get_MilligramsPerMeter();
    public double get_MilligramsPerMillimeter();
    public double get_PoundsPerFoot();
    public double get_PoundsPerInch();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(LinearDensityUnit unit);
    public static string GetAbbreviation(LinearDensityUnit unit, IFormatProvider provider);
    public static LinearDensity FromGramsPerCentimeter(double value);
    public static LinearDensity FromGramsPerFoot(double value);
    public static LinearDensity FromGramsPerMeter(double value);
    public static LinearDensity FromGramsPerMillimeter(double value);
    public static LinearDensity FromKilogramsPerCentimeter(double value);
    public static LinearDensity FromKilogramsPerFoot(double value);
    public static LinearDensity FromKilogramsPerMeter(double value);
    public static LinearDensity FromKilogramsPerMillimeter(double value);
    public static LinearDensity FromMicrogramsPerCentimeter(double value);
    public static LinearDensity FromMicrogramsPerFoot(double value);
    public static LinearDensity FromMicrogramsPerMeter(double value);
    public static LinearDensity FromMicrogramsPerMillimeter(double value);
    public static LinearDensity FromMilligramsPerCentimeter(double value);
    public static LinearDensity FromMilligramsPerFoot(double value);
    public static LinearDensity FromMilligramsPerMeter(double value);
    public static LinearDensity FromMilligramsPerMillimeter(double value);
    public static LinearDensity FromPoundsPerFoot(double value);
    public static LinearDensity FromPoundsPerInch(double value);
    public static LinearDensity From(double value, LinearDensityUnit fromUnit);
    public static LinearDensity Parse(string str);
    public static override LinearDensity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, LinearDensity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, LinearDensity& result);
    public static LinearDensityUnit ParseUnit(string str);
    public static LinearDensityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, LinearDensityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, LinearDensityUnit& unit);
    public static override LinearDensity op_UnaryNegation(LinearDensity right);
    public static override LinearDensity op_Addition(LinearDensity left, LinearDensity right);
    public static override LinearDensity op_Subtraction(LinearDensity left, LinearDensity right);
    public static LinearDensity op_Multiply(double left, LinearDensity right);
    public static override LinearDensity op_Multiply(LinearDensity left, double right);
    public static override LinearDensity op_Division(LinearDensity left, double right);
    public static double op_Division(LinearDensity left, LinearDensity right);
    public static override Area op_Division(LinearDensity linearDensity, Density density);
    public static override Density op_Division(LinearDensity linearDensity, Area area);
    public static override Mass op_Multiply(LinearDensity linearDensity, Length length);
    public static override bool op_LessThanOrEqual(LinearDensity left, LinearDensity right);
    public static override bool op_GreaterThanOrEqual(LinearDensity left, LinearDensity right);
    public static override bool op_LessThan(LinearDensity left, LinearDensity right);
    public static override bool op_GreaterThan(LinearDensity left, LinearDensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(LinearDensity other, LinearDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(LinearDensity left, LinearDensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(LinearDensity other, LinearDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(LinearDensity left, LinearDensity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(LinearDensity other, LinearDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(LinearDensity other, LinearDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(LinearDensity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(LinearDensity other);
    [ObsoleteAttribute("Use Equals(LinearDensity other, LinearDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(LinearDensity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(LinearDensity other, LinearDensity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(LinearDensityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public LinearDensity ToUnit(LinearDensityUnit unit);
    public LinearDensity ToUnit(LinearDensityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(LinearDensityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public LinearDensity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<LinearDensityUnit> UnitsNet.IQuantity<UnitsNet.Units.LinearDensityUnit>.ToUnit(LinearDensityUnit unit);
    private sealed virtual override IQuantity`1<LinearDensityUnit> UnitsNet.IQuantity<UnitsNet.Units.LinearDensityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.LinearPowerDensity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<LinearPowerDensityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<LinearPowerDensityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static LinearPowerDensityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static LinearPowerDensityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static LinearPowerDensity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<LinearPowerDensityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static LinearPowerDensityUnit BaseUnit { get; }
    public static LinearPowerDensityUnit[] Units { get; }
    public static LinearPowerDensity Zero { get; }
    public static LinearPowerDensity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public LinearPowerDensityUnit Unit { get; }
    public QuantityInfo`1<LinearPowerDensityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double GigawattsPerCentimeter { get; }
    public double GigawattsPerFoot { get; }
    public double GigawattsPerInch { get; }
    public double GigawattsPerMeter { get; }
    public double GigawattsPerMillimeter { get; }
    public double KilowattsPerCentimeter { get; }
    public double KilowattsPerFoot { get; }
    public double KilowattsPerInch { get; }
    public double KilowattsPerMeter { get; }
    public double KilowattsPerMillimeter { get; }
    public double MegawattsPerCentimeter { get; }
    public double MegawattsPerFoot { get; }
    public double MegawattsPerInch { get; }
    public double MegawattsPerMeter { get; }
    public double MegawattsPerMillimeter { get; }
    public double MilliwattsPerCentimeter { get; }
    public double MilliwattsPerFoot { get; }
    public double MilliwattsPerInch { get; }
    public double MilliwattsPerMeter { get; }
    public double MilliwattsPerMillimeter { get; }
    public double WattsPerCentimeter { get; }
    public double WattsPerFoot { get; }
    public double WattsPerInch { get; }
    public double WattsPerMeter { get; }
    public double WattsPerMillimeter { get; }
    private static LinearPowerDensity();
    public LinearPowerDensity(double value, LinearPowerDensityUnit unit);
    public LinearPowerDensity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<LinearPowerDensityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static LinearPowerDensityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static LinearPowerDensityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override LinearPowerDensity get_Zero();
    public static override LinearPowerDensity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual LinearPowerDensityUnit get_Unit();
    public sealed virtual QuantityInfo`1<LinearPowerDensityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_GigawattsPerCentimeter();
    public double get_GigawattsPerFoot();
    public double get_GigawattsPerInch();
    public double get_GigawattsPerMeter();
    public double get_GigawattsPerMillimeter();
    public double get_KilowattsPerCentimeter();
    public double get_KilowattsPerFoot();
    public double get_KilowattsPerInch();
    public double get_KilowattsPerMeter();
    public double get_KilowattsPerMillimeter();
    public double get_MegawattsPerCentimeter();
    public double get_MegawattsPerFoot();
    public double get_MegawattsPerInch();
    public double get_MegawattsPerMeter();
    public double get_MegawattsPerMillimeter();
    public double get_MilliwattsPerCentimeter();
    public double get_MilliwattsPerFoot();
    public double get_MilliwattsPerInch();
    public double get_MilliwattsPerMeter();
    public double get_MilliwattsPerMillimeter();
    public double get_WattsPerCentimeter();
    public double get_WattsPerFoot();
    public double get_WattsPerInch();
    public double get_WattsPerMeter();
    public double get_WattsPerMillimeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(LinearPowerDensityUnit unit);
    public static string GetAbbreviation(LinearPowerDensityUnit unit, IFormatProvider provider);
    public static LinearPowerDensity FromGigawattsPerCentimeter(double value);
    public static LinearPowerDensity FromGigawattsPerFoot(double value);
    public static LinearPowerDensity FromGigawattsPerInch(double value);
    public static LinearPowerDensity FromGigawattsPerMeter(double value);
    public static LinearPowerDensity FromGigawattsPerMillimeter(double value);
    public static LinearPowerDensity FromKilowattsPerCentimeter(double value);
    public static LinearPowerDensity FromKilowattsPerFoot(double value);
    public static LinearPowerDensity FromKilowattsPerInch(double value);
    public static LinearPowerDensity FromKilowattsPerMeter(double value);
    public static LinearPowerDensity FromKilowattsPerMillimeter(double value);
    public static LinearPowerDensity FromMegawattsPerCentimeter(double value);
    public static LinearPowerDensity FromMegawattsPerFoot(double value);
    public static LinearPowerDensity FromMegawattsPerInch(double value);
    public static LinearPowerDensity FromMegawattsPerMeter(double value);
    public static LinearPowerDensity FromMegawattsPerMillimeter(double value);
    public static LinearPowerDensity FromMilliwattsPerCentimeter(double value);
    public static LinearPowerDensity FromMilliwattsPerFoot(double value);
    public static LinearPowerDensity FromMilliwattsPerInch(double value);
    public static LinearPowerDensity FromMilliwattsPerMeter(double value);
    public static LinearPowerDensity FromMilliwattsPerMillimeter(double value);
    public static LinearPowerDensity FromWattsPerCentimeter(double value);
    public static LinearPowerDensity FromWattsPerFoot(double value);
    public static LinearPowerDensity FromWattsPerInch(double value);
    public static LinearPowerDensity FromWattsPerMeter(double value);
    public static LinearPowerDensity FromWattsPerMillimeter(double value);
    public static LinearPowerDensity From(double value, LinearPowerDensityUnit fromUnit);
    public static LinearPowerDensity Parse(string str);
    public static override LinearPowerDensity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, LinearPowerDensity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, LinearPowerDensity& result);
    public static LinearPowerDensityUnit ParseUnit(string str);
    public static LinearPowerDensityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, LinearPowerDensityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, LinearPowerDensityUnit& unit);
    public static override LinearPowerDensity op_UnaryNegation(LinearPowerDensity right);
    public static override LinearPowerDensity op_Addition(LinearPowerDensity left, LinearPowerDensity right);
    public static override LinearPowerDensity op_Subtraction(LinearPowerDensity left, LinearPowerDensity right);
    public static LinearPowerDensity op_Multiply(double left, LinearPowerDensity right);
    public static override LinearPowerDensity op_Multiply(LinearPowerDensity left, double right);
    public static override LinearPowerDensity op_Division(LinearPowerDensity left, double right);
    public static double op_Division(LinearPowerDensity left, LinearPowerDensity right);
    public static override bool op_LessThanOrEqual(LinearPowerDensity left, LinearPowerDensity right);
    public static override bool op_GreaterThanOrEqual(LinearPowerDensity left, LinearPowerDensity right);
    public static override bool op_LessThan(LinearPowerDensity left, LinearPowerDensity right);
    public static override bool op_GreaterThan(LinearPowerDensity left, LinearPowerDensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(LinearPowerDensity other, LinearPowerDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(LinearPowerDensity left, LinearPowerDensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(LinearPowerDensity other, LinearPowerDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(LinearPowerDensity left, LinearPowerDensity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(LinearPowerDensity other, LinearPowerDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(LinearPowerDensity other, LinearPowerDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(LinearPowerDensity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(LinearPowerDensity other);
    [ObsoleteAttribute("Use Equals(LinearPowerDensity other, LinearPowerDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(LinearPowerDensity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(LinearPowerDensity other, LinearPowerDensity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(LinearPowerDensityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public LinearPowerDensity ToUnit(LinearPowerDensityUnit unit);
    public LinearPowerDensity ToUnit(LinearPowerDensityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(LinearPowerDensityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public LinearPowerDensity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<LinearPowerDensityUnit> UnitsNet.IQuantity<UnitsNet.Units.LinearPowerDensityUnit>.ToUnit(LinearPowerDensityUnit unit);
    private sealed virtual override IQuantity`1<LinearPowerDensityUnit> UnitsNet.IQuantity<UnitsNet.Units.LinearPowerDensityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Luminance : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<LuminanceUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<LuminanceUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static LuminanceUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static LuminanceUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Luminance <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<LuminanceUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static LuminanceUnit BaseUnit { get; }
    public static LuminanceUnit[] Units { get; }
    public static Luminance Zero { get; }
    public static Luminance AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public LuminanceUnit Unit { get; }
    public QuantityInfo`1<LuminanceUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CandelasPerSquareFoot { get; }
    public double CandelasPerSquareInch { get; }
    public double CandelasPerSquareMeter { get; }
    public double CenticandelasPerSquareMeter { get; }
    public double DecicandelasPerSquareMeter { get; }
    public double KilocandelasPerSquareMeter { get; }
    public double MicrocandelasPerSquareMeter { get; }
    public double MillicandelasPerSquareMeter { get; }
    public double NanocandelasPerSquareMeter { get; }
    public double Nits { get; }
    private static Luminance();
    public Luminance(double value, LuminanceUnit unit);
    public Luminance(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<LuminanceUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static LuminanceUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static LuminanceUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Luminance get_Zero();
    public static override Luminance get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual LuminanceUnit get_Unit();
    public sealed virtual QuantityInfo`1<LuminanceUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CandelasPerSquareFoot();
    public double get_CandelasPerSquareInch();
    public double get_CandelasPerSquareMeter();
    public double get_CenticandelasPerSquareMeter();
    public double get_DecicandelasPerSquareMeter();
    public double get_KilocandelasPerSquareMeter();
    public double get_MicrocandelasPerSquareMeter();
    public double get_MillicandelasPerSquareMeter();
    public double get_NanocandelasPerSquareMeter();
    public double get_Nits();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(LuminanceUnit unit);
    public static string GetAbbreviation(LuminanceUnit unit, IFormatProvider provider);
    public static Luminance FromCandelasPerSquareFoot(double value);
    public static Luminance FromCandelasPerSquareInch(double value);
    public static Luminance FromCandelasPerSquareMeter(double value);
    public static Luminance FromCenticandelasPerSquareMeter(double value);
    public static Luminance FromDecicandelasPerSquareMeter(double value);
    public static Luminance FromKilocandelasPerSquareMeter(double value);
    public static Luminance FromMicrocandelasPerSquareMeter(double value);
    public static Luminance FromMillicandelasPerSquareMeter(double value);
    public static Luminance FromNanocandelasPerSquareMeter(double value);
    public static Luminance FromNits(double value);
    public static Luminance From(double value, LuminanceUnit fromUnit);
    public static Luminance Parse(string str);
    public static override Luminance Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Luminance& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Luminance& result);
    public static LuminanceUnit ParseUnit(string str);
    public static LuminanceUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, LuminanceUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, LuminanceUnit& unit);
    public static override Luminance op_UnaryNegation(Luminance right);
    public static override Luminance op_Addition(Luminance left, Luminance right);
    public static override Luminance op_Subtraction(Luminance left, Luminance right);
    public static Luminance op_Multiply(double left, Luminance right);
    public static override Luminance op_Multiply(Luminance left, double right);
    public static override Luminance op_Division(Luminance left, double right);
    public static double op_Division(Luminance left, Luminance right);
    public static override LuminousIntensity op_Multiply(Luminance luminance, Area area);
    public static override bool op_LessThanOrEqual(Luminance left, Luminance right);
    public static override bool op_GreaterThanOrEqual(Luminance left, Luminance right);
    public static override bool op_LessThan(Luminance left, Luminance right);
    public static override bool op_GreaterThan(Luminance left, Luminance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Luminance other, Luminance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Luminance left, Luminance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Luminance other, Luminance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Luminance left, Luminance right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Luminance other, Luminance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Luminance other, Luminance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Luminance other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Luminance other);
    [ObsoleteAttribute("Use Equals(Luminance other, Luminance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Luminance other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Luminance other, Luminance tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(LuminanceUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Luminance ToUnit(LuminanceUnit unit);
    public Luminance ToUnit(LuminanceUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(LuminanceUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Luminance ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<LuminanceUnit> UnitsNet.IQuantity<UnitsNet.Units.LuminanceUnit>.ToUnit(LuminanceUnit unit);
    private sealed virtual override IQuantity`1<LuminanceUnit> UnitsNet.IQuantity<UnitsNet.Units.LuminanceUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Luminosity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<LuminosityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<LuminosityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static LuminosityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static LuminosityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Luminosity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<LuminosityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static LuminosityUnit BaseUnit { get; }
    public static LuminosityUnit[] Units { get; }
    public static Luminosity Zero { get; }
    public static Luminosity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public LuminosityUnit Unit { get; }
    public QuantityInfo`1<LuminosityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Decawatts { get; }
    public double Deciwatts { get; }
    public double Femtowatts { get; }
    public double Gigawatts { get; }
    public double Kilowatts { get; }
    public double Megawatts { get; }
    public double Microwatts { get; }
    public double Milliwatts { get; }
    public double Nanowatts { get; }
    public double Petawatts { get; }
    public double Picowatts { get; }
    public double SolarLuminosities { get; }
    public double Terawatts { get; }
    public double Watts { get; }
    private static Luminosity();
    public Luminosity(double value, LuminosityUnit unit);
    public Luminosity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<LuminosityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static LuminosityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static LuminosityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Luminosity get_Zero();
    public static override Luminosity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual LuminosityUnit get_Unit();
    public sealed virtual QuantityInfo`1<LuminosityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Decawatts();
    public double get_Deciwatts();
    public double get_Femtowatts();
    public double get_Gigawatts();
    public double get_Kilowatts();
    public double get_Megawatts();
    public double get_Microwatts();
    public double get_Milliwatts();
    public double get_Nanowatts();
    public double get_Petawatts();
    public double get_Picowatts();
    public double get_SolarLuminosities();
    public double get_Terawatts();
    public double get_Watts();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(LuminosityUnit unit);
    public static string GetAbbreviation(LuminosityUnit unit, IFormatProvider provider);
    public static Luminosity FromDecawatts(double value);
    public static Luminosity FromDeciwatts(double value);
    public static Luminosity FromFemtowatts(double value);
    public static Luminosity FromGigawatts(double value);
    public static Luminosity FromKilowatts(double value);
    public static Luminosity FromMegawatts(double value);
    public static Luminosity FromMicrowatts(double value);
    public static Luminosity FromMilliwatts(double value);
    public static Luminosity FromNanowatts(double value);
    public static Luminosity FromPetawatts(double value);
    public static Luminosity FromPicowatts(double value);
    public static Luminosity FromSolarLuminosities(double value);
    public static Luminosity FromTerawatts(double value);
    public static Luminosity FromWatts(double value);
    public static Luminosity From(double value, LuminosityUnit fromUnit);
    public static Luminosity Parse(string str);
    public static override Luminosity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Luminosity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Luminosity& result);
    public static LuminosityUnit ParseUnit(string str);
    public static LuminosityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, LuminosityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, LuminosityUnit& unit);
    public static override Luminosity op_UnaryNegation(Luminosity right);
    public static override Luminosity op_Addition(Luminosity left, Luminosity right);
    public static override Luminosity op_Subtraction(Luminosity left, Luminosity right);
    public static Luminosity op_Multiply(double left, Luminosity right);
    public static override Luminosity op_Multiply(Luminosity left, double right);
    public static override Luminosity op_Division(Luminosity left, double right);
    public static double op_Division(Luminosity left, Luminosity right);
    public static override bool op_LessThanOrEqual(Luminosity left, Luminosity right);
    public static override bool op_GreaterThanOrEqual(Luminosity left, Luminosity right);
    public static override bool op_LessThan(Luminosity left, Luminosity right);
    public static override bool op_GreaterThan(Luminosity left, Luminosity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Luminosity other, Luminosity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Luminosity left, Luminosity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Luminosity other, Luminosity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Luminosity left, Luminosity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Luminosity other, Luminosity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Luminosity other, Luminosity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Luminosity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Luminosity other);
    [ObsoleteAttribute("Use Equals(Luminosity other, Luminosity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Luminosity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Luminosity other, Luminosity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(LuminosityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Luminosity ToUnit(LuminosityUnit unit);
    public Luminosity ToUnit(LuminosityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(LuminosityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Luminosity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<LuminosityUnit> UnitsNet.IQuantity<UnitsNet.Units.LuminosityUnit>.ToUnit(LuminosityUnit unit);
    private sealed virtual override IQuantity`1<LuminosityUnit> UnitsNet.IQuantity<UnitsNet.Units.LuminosityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.LuminousFlux : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<LuminousFluxUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<LuminousFluxUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static LuminousFluxUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static LuminousFluxUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static LuminousFlux <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<LuminousFluxUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static LuminousFluxUnit BaseUnit { get; }
    public static LuminousFluxUnit[] Units { get; }
    public static LuminousFlux Zero { get; }
    public static LuminousFlux AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public LuminousFluxUnit Unit { get; }
    public QuantityInfo`1<LuminousFluxUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Lumens { get; }
    private static LuminousFlux();
    public LuminousFlux(double value, LuminousFluxUnit unit);
    public LuminousFlux(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<LuminousFluxUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static LuminousFluxUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static LuminousFluxUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override LuminousFlux get_Zero();
    public static override LuminousFlux get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual LuminousFluxUnit get_Unit();
    public sealed virtual QuantityInfo`1<LuminousFluxUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Lumens();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(LuminousFluxUnit unit);
    public static string GetAbbreviation(LuminousFluxUnit unit, IFormatProvider provider);
    public static LuminousFlux FromLumens(double value);
    public static LuminousFlux From(double value, LuminousFluxUnit fromUnit);
    public static LuminousFlux Parse(string str);
    public static override LuminousFlux Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, LuminousFlux& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, LuminousFlux& result);
    public static LuminousFluxUnit ParseUnit(string str);
    public static LuminousFluxUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, LuminousFluxUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, LuminousFluxUnit& unit);
    public static override LuminousFlux op_UnaryNegation(LuminousFlux right);
    public static override LuminousFlux op_Addition(LuminousFlux left, LuminousFlux right);
    public static override LuminousFlux op_Subtraction(LuminousFlux left, LuminousFlux right);
    public static LuminousFlux op_Multiply(double left, LuminousFlux right);
    public static override LuminousFlux op_Multiply(LuminousFlux left, double right);
    public static override LuminousFlux op_Division(LuminousFlux left, double right);
    public static double op_Division(LuminousFlux left, LuminousFlux right);
    public static override bool op_LessThanOrEqual(LuminousFlux left, LuminousFlux right);
    public static override bool op_GreaterThanOrEqual(LuminousFlux left, LuminousFlux right);
    public static override bool op_LessThan(LuminousFlux left, LuminousFlux right);
    public static override bool op_GreaterThan(LuminousFlux left, LuminousFlux right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(LuminousFlux other, LuminousFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(LuminousFlux left, LuminousFlux right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(LuminousFlux other, LuminousFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(LuminousFlux left, LuminousFlux right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(LuminousFlux other, LuminousFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(LuminousFlux other, LuminousFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(LuminousFlux other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(LuminousFlux other);
    [ObsoleteAttribute("Use Equals(LuminousFlux other, LuminousFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(LuminousFlux other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(LuminousFlux other, LuminousFlux tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(LuminousFluxUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public LuminousFlux ToUnit(LuminousFluxUnit unit);
    public LuminousFlux ToUnit(LuminousFluxUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(LuminousFluxUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public LuminousFlux ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<LuminousFluxUnit> UnitsNet.IQuantity<UnitsNet.Units.LuminousFluxUnit>.ToUnit(LuminousFluxUnit unit);
    private sealed virtual override IQuantity`1<LuminousFluxUnit> UnitsNet.IQuantity<UnitsNet.Units.LuminousFluxUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.LuminousIntensity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<LuminousIntensityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<LuminousIntensityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static LuminousIntensityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static LuminousIntensityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static LuminousIntensity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<LuminousIntensityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static LuminousIntensityUnit BaseUnit { get; }
    public static LuminousIntensityUnit[] Units { get; }
    public static LuminousIntensity Zero { get; }
    public static LuminousIntensity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public LuminousIntensityUnit Unit { get; }
    public QuantityInfo`1<LuminousIntensityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Candela { get; }
    private static LuminousIntensity();
    public LuminousIntensity(double value, LuminousIntensityUnit unit);
    public LuminousIntensity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<LuminousIntensityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static LuminousIntensityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static LuminousIntensityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override LuminousIntensity get_Zero();
    public static override LuminousIntensity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual LuminousIntensityUnit get_Unit();
    public sealed virtual QuantityInfo`1<LuminousIntensityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Candela();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(LuminousIntensityUnit unit);
    public static string GetAbbreviation(LuminousIntensityUnit unit, IFormatProvider provider);
    public static LuminousIntensity FromCandela(double value);
    public static LuminousIntensity From(double value, LuminousIntensityUnit fromUnit);
    public static LuminousIntensity Parse(string str);
    public static override LuminousIntensity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, LuminousIntensity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, LuminousIntensity& result);
    public static LuminousIntensityUnit ParseUnit(string str);
    public static LuminousIntensityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, LuminousIntensityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, LuminousIntensityUnit& unit);
    public static override LuminousIntensity op_UnaryNegation(LuminousIntensity right);
    public static override LuminousIntensity op_Addition(LuminousIntensity left, LuminousIntensity right);
    public static override LuminousIntensity op_Subtraction(LuminousIntensity left, LuminousIntensity right);
    public static LuminousIntensity op_Multiply(double left, LuminousIntensity right);
    public static override LuminousIntensity op_Multiply(LuminousIntensity left, double right);
    public static override LuminousIntensity op_Division(LuminousIntensity left, double right);
    public static double op_Division(LuminousIntensity left, LuminousIntensity right);
    public static override Area op_Division(LuminousIntensity luminousIntensity, Luminance luminance);
    public static override Luminance op_Division(LuminousIntensity luminousIntensity, Area area);
    public static override bool op_LessThanOrEqual(LuminousIntensity left, LuminousIntensity right);
    public static override bool op_GreaterThanOrEqual(LuminousIntensity left, LuminousIntensity right);
    public static override bool op_LessThan(LuminousIntensity left, LuminousIntensity right);
    public static override bool op_GreaterThan(LuminousIntensity left, LuminousIntensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(LuminousIntensity other, LuminousIntensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(LuminousIntensity left, LuminousIntensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(LuminousIntensity other, LuminousIntensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(LuminousIntensity left, LuminousIntensity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(LuminousIntensity other, LuminousIntensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(LuminousIntensity other, LuminousIntensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(LuminousIntensity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(LuminousIntensity other);
    [ObsoleteAttribute("Use Equals(LuminousIntensity other, LuminousIntensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(LuminousIntensity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(LuminousIntensity other, LuminousIntensity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(LuminousIntensityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public LuminousIntensity ToUnit(LuminousIntensityUnit unit);
    public LuminousIntensity ToUnit(LuminousIntensityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(LuminousIntensityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public LuminousIntensity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<LuminousIntensityUnit> UnitsNet.IQuantity<UnitsNet.Units.LuminousIntensityUnit>.ToUnit(LuminousIntensityUnit unit);
    private sealed virtual override IQuantity`1<LuminousIntensityUnit> UnitsNet.IQuantity<UnitsNet.Units.LuminousIntensityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.MagneticField : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<MagneticFieldUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<MagneticFieldUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static MagneticFieldUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static MagneticFieldUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static MagneticField <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<MagneticFieldUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static MagneticFieldUnit BaseUnit { get; }
    public static MagneticFieldUnit[] Units { get; }
    public static MagneticField Zero { get; }
    public static MagneticField AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public MagneticFieldUnit Unit { get; }
    public QuantityInfo`1<MagneticFieldUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Gausses { get; }
    public double Microteslas { get; }
    public double Milligausses { get; }
    public double Milliteslas { get; }
    public double Nanoteslas { get; }
    public double Teslas { get; }
    private static MagneticField();
    public MagneticField(double value, MagneticFieldUnit unit);
    public MagneticField(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<MagneticFieldUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static MagneticFieldUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static MagneticFieldUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override MagneticField get_Zero();
    public static override MagneticField get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual MagneticFieldUnit get_Unit();
    public sealed virtual QuantityInfo`1<MagneticFieldUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Gausses();
    public double get_Microteslas();
    public double get_Milligausses();
    public double get_Milliteslas();
    public double get_Nanoteslas();
    public double get_Teslas();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(MagneticFieldUnit unit);
    public static string GetAbbreviation(MagneticFieldUnit unit, IFormatProvider provider);
    public static MagneticField FromGausses(double value);
    public static MagneticField FromMicroteslas(double value);
    public static MagneticField FromMilligausses(double value);
    public static MagneticField FromMilliteslas(double value);
    public static MagneticField FromNanoteslas(double value);
    public static MagneticField FromTeslas(double value);
    public static MagneticField From(double value, MagneticFieldUnit fromUnit);
    public static MagneticField Parse(string str);
    public static override MagneticField Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, MagneticField& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, MagneticField& result);
    public static MagneticFieldUnit ParseUnit(string str);
    public static MagneticFieldUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, MagneticFieldUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, MagneticFieldUnit& unit);
    public static override MagneticField op_UnaryNegation(MagneticField right);
    public static override MagneticField op_Addition(MagneticField left, MagneticField right);
    public static override MagneticField op_Subtraction(MagneticField left, MagneticField right);
    public static MagneticField op_Multiply(double left, MagneticField right);
    public static override MagneticField op_Multiply(MagneticField left, double right);
    public static override MagneticField op_Division(MagneticField left, double right);
    public static double op_Division(MagneticField left, MagneticField right);
    public static override bool op_LessThanOrEqual(MagneticField left, MagneticField right);
    public static override bool op_GreaterThanOrEqual(MagneticField left, MagneticField right);
    public static override bool op_LessThan(MagneticField left, MagneticField right);
    public static override bool op_GreaterThan(MagneticField left, MagneticField right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MagneticField other, MagneticField tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(MagneticField left, MagneticField right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MagneticField other, MagneticField tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(MagneticField left, MagneticField right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(MagneticField other, MagneticField tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(MagneticField other, MagneticField tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(MagneticField other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(MagneticField other);
    [ObsoleteAttribute("Use Equals(MagneticField other, MagneticField tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(MagneticField other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(MagneticField other, MagneticField tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(MagneticFieldUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public MagneticField ToUnit(MagneticFieldUnit unit);
    public MagneticField ToUnit(MagneticFieldUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(MagneticFieldUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public MagneticField ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<MagneticFieldUnit> UnitsNet.IQuantity<UnitsNet.Units.MagneticFieldUnit>.ToUnit(MagneticFieldUnit unit);
    private sealed virtual override IQuantity`1<MagneticFieldUnit> UnitsNet.IQuantity<UnitsNet.Units.MagneticFieldUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.MagneticFlux : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<MagneticFluxUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<MagneticFluxUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static MagneticFluxUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static MagneticFluxUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static MagneticFlux <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<MagneticFluxUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static MagneticFluxUnit BaseUnit { get; }
    public static MagneticFluxUnit[] Units { get; }
    public static MagneticFlux Zero { get; }
    public static MagneticFlux AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public MagneticFluxUnit Unit { get; }
    public QuantityInfo`1<MagneticFluxUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Webers { get; }
    private static MagneticFlux();
    public MagneticFlux(double value, MagneticFluxUnit unit);
    public MagneticFlux(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<MagneticFluxUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static MagneticFluxUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static MagneticFluxUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override MagneticFlux get_Zero();
    public static override MagneticFlux get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual MagneticFluxUnit get_Unit();
    public sealed virtual QuantityInfo`1<MagneticFluxUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Webers();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(MagneticFluxUnit unit);
    public static string GetAbbreviation(MagneticFluxUnit unit, IFormatProvider provider);
    public static MagneticFlux FromWebers(double value);
    public static MagneticFlux From(double value, MagneticFluxUnit fromUnit);
    public static MagneticFlux Parse(string str);
    public static override MagneticFlux Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, MagneticFlux& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, MagneticFlux& result);
    public static MagneticFluxUnit ParseUnit(string str);
    public static MagneticFluxUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, MagneticFluxUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, MagneticFluxUnit& unit);
    public static override MagneticFlux op_UnaryNegation(MagneticFlux right);
    public static override MagneticFlux op_Addition(MagneticFlux left, MagneticFlux right);
    public static override MagneticFlux op_Subtraction(MagneticFlux left, MagneticFlux right);
    public static MagneticFlux op_Multiply(double left, MagneticFlux right);
    public static override MagneticFlux op_Multiply(MagneticFlux left, double right);
    public static override MagneticFlux op_Division(MagneticFlux left, double right);
    public static double op_Division(MagneticFlux left, MagneticFlux right);
    public static override bool op_LessThanOrEqual(MagneticFlux left, MagneticFlux right);
    public static override bool op_GreaterThanOrEqual(MagneticFlux left, MagneticFlux right);
    public static override bool op_LessThan(MagneticFlux left, MagneticFlux right);
    public static override bool op_GreaterThan(MagneticFlux left, MagneticFlux right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MagneticFlux other, MagneticFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(MagneticFlux left, MagneticFlux right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MagneticFlux other, MagneticFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(MagneticFlux left, MagneticFlux right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(MagneticFlux other, MagneticFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(MagneticFlux other, MagneticFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(MagneticFlux other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(MagneticFlux other);
    [ObsoleteAttribute("Use Equals(MagneticFlux other, MagneticFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(MagneticFlux other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(MagneticFlux other, MagneticFlux tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(MagneticFluxUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public MagneticFlux ToUnit(MagneticFluxUnit unit);
    public MagneticFlux ToUnit(MagneticFluxUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(MagneticFluxUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public MagneticFlux ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<MagneticFluxUnit> UnitsNet.IQuantity<UnitsNet.Units.MagneticFluxUnit>.ToUnit(MagneticFluxUnit unit);
    private sealed virtual override IQuantity`1<MagneticFluxUnit> UnitsNet.IQuantity<UnitsNet.Units.MagneticFluxUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Magnetization : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<MagnetizationUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<MagnetizationUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static MagnetizationUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static MagnetizationUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Magnetization <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<MagnetizationUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static MagnetizationUnit BaseUnit { get; }
    public static MagnetizationUnit[] Units { get; }
    public static Magnetization Zero { get; }
    public static Magnetization AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public MagnetizationUnit Unit { get; }
    public QuantityInfo`1<MagnetizationUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double AmperesPerMeter { get; }
    private static Magnetization();
    public Magnetization(double value, MagnetizationUnit unit);
    public Magnetization(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<MagnetizationUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static MagnetizationUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static MagnetizationUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Magnetization get_Zero();
    public static override Magnetization get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual MagnetizationUnit get_Unit();
    public sealed virtual QuantityInfo`1<MagnetizationUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_AmperesPerMeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(MagnetizationUnit unit);
    public static string GetAbbreviation(MagnetizationUnit unit, IFormatProvider provider);
    public static Magnetization FromAmperesPerMeter(double value);
    public static Magnetization From(double value, MagnetizationUnit fromUnit);
    public static Magnetization Parse(string str);
    public static override Magnetization Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Magnetization& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Magnetization& result);
    public static MagnetizationUnit ParseUnit(string str);
    public static MagnetizationUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, MagnetizationUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, MagnetizationUnit& unit);
    public static override Magnetization op_UnaryNegation(Magnetization right);
    public static override Magnetization op_Addition(Magnetization left, Magnetization right);
    public static override Magnetization op_Subtraction(Magnetization left, Magnetization right);
    public static Magnetization op_Multiply(double left, Magnetization right);
    public static override Magnetization op_Multiply(Magnetization left, double right);
    public static override Magnetization op_Division(Magnetization left, double right);
    public static double op_Division(Magnetization left, Magnetization right);
    public static override bool op_LessThanOrEqual(Magnetization left, Magnetization right);
    public static override bool op_GreaterThanOrEqual(Magnetization left, Magnetization right);
    public static override bool op_LessThan(Magnetization left, Magnetization right);
    public static override bool op_GreaterThan(Magnetization left, Magnetization right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Magnetization other, Magnetization tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Magnetization left, Magnetization right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Magnetization other, Magnetization tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Magnetization left, Magnetization right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Magnetization other, Magnetization tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Magnetization other, Magnetization tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Magnetization other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Magnetization other);
    [ObsoleteAttribute("Use Equals(Magnetization other, Magnetization tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Magnetization other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Magnetization other, Magnetization tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(MagnetizationUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Magnetization ToUnit(MagnetizationUnit unit);
    public Magnetization ToUnit(MagnetizationUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(MagnetizationUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Magnetization ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<MagnetizationUnit> UnitsNet.IQuantity<UnitsNet.Units.MagnetizationUnit>.ToUnit(MagnetizationUnit unit);
    private sealed virtual override IQuantity`1<MagnetizationUnit> UnitsNet.IQuantity<UnitsNet.Units.MagnetizationUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Mass : ValueType {
    private static double StonesInOnePound;
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<MassUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<MassUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Mass <Zero>k__BackingField;
    public StonePounds StonePounds { get; }
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<MassUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static MassUnit BaseUnit { get; }
    public static MassUnit[] Units { get; }
    public static Mass Zero { get; }
    public static Mass AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public MassUnit Unit { get; }
    public QuantityInfo`1<MassUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Centigrams { get; }
    public double Decagrams { get; }
    public double Decigrams { get; }
    public double EarthMasses { get; }
    public double Femtograms { get; }
    public double Grains { get; }
    public double Grams { get; }
    public double Hectograms { get; }
    public double Kilograms { get; }
    public double Kilopounds { get; }
    public double Kilotonnes { get; }
    public double LongHundredweight { get; }
    public double LongTons { get; }
    public double Megapounds { get; }
    public double Megatonnes { get; }
    public double Micrograms { get; }
    public double Milligrams { get; }
    public double Nanograms { get; }
    public double Ounces { get; }
    public double Picograms { get; }
    public double Pounds { get; }
    public double ShortHundredweight { get; }
    public double ShortTons { get; }
    public double Slugs { get; }
    public double SolarMasses { get; }
    public double Stone { get; }
    public double Tonnes { get; }
    private static Mass();
    public Mass(double value, MassUnit unit);
    public Mass(double value, UnitSystem unitSystem);
    public static Mass FromGravitationalForce(Force f);
    public StonePounds get_StonePounds();
    public static Mass FromStonePounds(double stone, double pounds);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<MassUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static MassUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static MassUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Mass get_Zero();
    public static override Mass get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual MassUnit get_Unit();
    public sealed virtual QuantityInfo`1<MassUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Centigrams();
    public double get_Decagrams();
    public double get_Decigrams();
    public double get_EarthMasses();
    public double get_Femtograms();
    public double get_Grains();
    public double get_Grams();
    public double get_Hectograms();
    public double get_Kilograms();
    public double get_Kilopounds();
    public double get_Kilotonnes();
    public double get_LongHundredweight();
    public double get_LongTons();
    public double get_Megapounds();
    public double get_Megatonnes();
    public double get_Micrograms();
    public double get_Milligrams();
    public double get_Nanograms();
    public double get_Ounces();
    public double get_Picograms();
    public double get_Pounds();
    public double get_ShortHundredweight();
    public double get_ShortTons();
    public double get_Slugs();
    public double get_SolarMasses();
    public double get_Stone();
    public double get_Tonnes();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(MassUnit unit);
    public static string GetAbbreviation(MassUnit unit, IFormatProvider provider);
    public static Mass FromCentigrams(double value);
    public static Mass FromDecagrams(double value);
    public static Mass FromDecigrams(double value);
    public static Mass FromEarthMasses(double value);
    public static Mass FromFemtograms(double value);
    public static Mass FromGrains(double value);
    public static Mass FromGrams(double value);
    public static Mass FromHectograms(double value);
    public static Mass FromKilograms(double value);
    public static Mass FromKilopounds(double value);
    public static Mass FromKilotonnes(double value);
    public static Mass FromLongHundredweight(double value);
    public static Mass FromLongTons(double value);
    public static Mass FromMegapounds(double value);
    public static Mass FromMegatonnes(double value);
    public static Mass FromMicrograms(double value);
    public static Mass FromMilligrams(double value);
    public static Mass FromNanograms(double value);
    public static Mass FromOunces(double value);
    public static Mass FromPicograms(double value);
    public static Mass FromPounds(double value);
    public static Mass FromShortHundredweight(double value);
    public static Mass FromShortTons(double value);
    public static Mass FromSlugs(double value);
    public static Mass FromSolarMasses(double value);
    public static Mass FromStone(double value);
    public static Mass FromTonnes(double value);
    public static Mass From(double value, MassUnit fromUnit);
    public static Mass Parse(string str);
    public static override Mass Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Mass& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Mass& result);
    public static MassUnit ParseUnit(string str);
    public static MassUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, MassUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, MassUnit& unit);
    public static override Mass op_UnaryNegation(Mass right);
    public static override Mass op_Addition(Mass left, Mass right);
    public static override Mass op_Subtraction(Mass left, Mass right);
    public static Mass op_Multiply(double left, Mass right);
    public static override Mass op_Multiply(Mass left, double right);
    public static override Mass op_Division(Mass left, double right);
    public static double op_Division(Mass left, Mass right);
    public static override AmountOfSubstance op_Division(Mass mass, MolarMass molarMass);
    public static override Area op_Division(Mass mass, AreaDensity areaDensity);
    public static override AreaDensity op_Division(Mass mass, Area area);
    public static override Density op_Division(Mass mass, Volume volume);
    public static override Duration op_Division(Mass mass, MassFlow massFlow);
    public static override Energy op_Multiply(Mass mass, SpecificEnergy specificEnergy);
    public static override Entropy op_Multiply(Mass mass, SpecificEntropy specificEntropy);
    public static override Force op_Multiply(Mass mass, Acceleration acceleration);
    public static override Length op_Division(Mass mass, LinearDensity linearDensity);
    public static override LinearDensity op_Division(Mass mass, Length length);
    public static override Mass op_Multiply(Mass mass, MassFraction massFraction);
    public static override Mass op_Division(Mass mass, MassFraction massFraction);
    public static override MassFlow op_Division(Mass mass, Duration duration);
    public static override MolarMass op_Division(Mass mass, AmountOfSubstance amountOfSubstance);
    public static override Volume op_Multiply(Mass mass, SpecificVolume specificVolume);
    public static override Volume op_Division(Mass mass, Density density);
    public static override bool op_LessThanOrEqual(Mass left, Mass right);
    public static override bool op_GreaterThanOrEqual(Mass left, Mass right);
    public static override bool op_LessThan(Mass left, Mass right);
    public static override bool op_GreaterThan(Mass left, Mass right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Mass other, Mass tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Mass left, Mass right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Mass other, Mass tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Mass left, Mass right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Mass other, Mass tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Mass other, Mass tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Mass other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Mass other);
    [ObsoleteAttribute("Use Equals(Mass other, Mass tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Mass other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Mass other, Mass tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(MassUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Mass ToUnit(MassUnit unit);
    public Mass ToUnit(MassUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(MassUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Mass ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<MassUnit> UnitsNet.IQuantity<UnitsNet.Units.MassUnit>.ToUnit(MassUnit unit);
    private sealed virtual override IQuantity`1<MassUnit> UnitsNet.IQuantity<UnitsNet.Units.MassUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.MassConcentration : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<MassConcentrationUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<MassConcentrationUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassConcentrationUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassConcentrationUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassConcentration <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<MassConcentrationUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static MassConcentrationUnit BaseUnit { get; }
    public static MassConcentrationUnit[] Units { get; }
    public static MassConcentration Zero { get; }
    public static MassConcentration AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public MassConcentrationUnit Unit { get; }
    public QuantityInfo`1<MassConcentrationUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentigramsPerDeciliter { get; }
    public double CentigramsPerLiter { get; }
    public double CentigramsPerMicroliter { get; }
    public double CentigramsPerMilliliter { get; }
    public double DecigramsPerDeciliter { get; }
    public double DecigramsPerLiter { get; }
    public double DecigramsPerMicroliter { get; }
    public double DecigramsPerMilliliter { get; }
    public double GramsPerCubicCentimeter { get; }
    public double GramsPerCubicMeter { get; }
    public double GramsPerCubicMillimeter { get; }
    public double GramsPerDeciliter { get; }
    public double GramsPerLiter { get; }
    public double GramsPerMicroliter { get; }
    public double GramsPerMilliliter { get; }
    public double KilogramsPerCubicCentimeter { get; }
    public double KilogramsPerCubicMeter { get; }
    public double KilogramsPerCubicMillimeter { get; }
    public double KilogramsPerLiter { get; }
    public double KilopoundsPerCubicFoot { get; }
    public double KilopoundsPerCubicInch { get; }
    public double MicrogramsPerCubicMeter { get; }
    public double MicrogramsPerDeciliter { get; }
    public double MicrogramsPerLiter { get; }
    public double MicrogramsPerMicroliter { get; }
    public double MicrogramsPerMilliliter { get; }
    public double MilligramsPerCubicMeter { get; }
    public double MilligramsPerDeciliter { get; }
    public double MilligramsPerLiter { get; }
    public double MilligramsPerMicroliter { get; }
    public double MilligramsPerMilliliter { get; }
    public double NanogramsPerDeciliter { get; }
    public double NanogramsPerLiter { get; }
    public double NanogramsPerMicroliter { get; }
    public double NanogramsPerMilliliter { get; }
    public double OuncesPerImperialGallon { get; }
    public double OuncesPerUSGallon { get; }
    public double PicogramsPerDeciliter { get; }
    public double PicogramsPerLiter { get; }
    public double PicogramsPerMicroliter { get; }
    public double PicogramsPerMilliliter { get; }
    public double PoundsPerCubicFoot { get; }
    public double PoundsPerCubicInch { get; }
    public double PoundsPerImperialGallon { get; }
    public double PoundsPerUSGallon { get; }
    public double SlugsPerCubicFoot { get; }
    public double TonnesPerCubicCentimeter { get; }
    public double TonnesPerCubicMeter { get; }
    public double TonnesPerCubicMillimeter { get; }
    private static MassConcentration();
    public MassConcentration(double value, MassConcentrationUnit unit);
    public MassConcentration(double value, UnitSystem unitSystem);
    public Molarity ToMolarity(MolarMass molecularWeight);
    public VolumeConcentration ToVolumeConcentration(Density componentDensity);
    public static MassConcentration FromMolarity(Molarity molarity, MolarMass mass);
    public static MassConcentration FromVolumeConcentration(VolumeConcentration volumeConcentration, Density componentDensity);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<MassConcentrationUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static MassConcentrationUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static MassConcentrationUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override MassConcentration get_Zero();
    public static override MassConcentration get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual MassConcentrationUnit get_Unit();
    public sealed virtual QuantityInfo`1<MassConcentrationUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentigramsPerDeciliter();
    public double get_CentigramsPerLiter();
    public double get_CentigramsPerMicroliter();
    public double get_CentigramsPerMilliliter();
    public double get_DecigramsPerDeciliter();
    public double get_DecigramsPerLiter();
    public double get_DecigramsPerMicroliter();
    public double get_DecigramsPerMilliliter();
    public double get_GramsPerCubicCentimeter();
    public double get_GramsPerCubicMeter();
    public double get_GramsPerCubicMillimeter();
    public double get_GramsPerDeciliter();
    public double get_GramsPerLiter();
    public double get_GramsPerMicroliter();
    public double get_GramsPerMilliliter();
    public double get_KilogramsPerCubicCentimeter();
    public double get_KilogramsPerCubicMeter();
    public double get_KilogramsPerCubicMillimeter();
    public double get_KilogramsPerLiter();
    public double get_KilopoundsPerCubicFoot();
    public double get_KilopoundsPerCubicInch();
    public double get_MicrogramsPerCubicMeter();
    public double get_MicrogramsPerDeciliter();
    public double get_MicrogramsPerLiter();
    public double get_MicrogramsPerMicroliter();
    public double get_MicrogramsPerMilliliter();
    public double get_MilligramsPerCubicMeter();
    public double get_MilligramsPerDeciliter();
    public double get_MilligramsPerLiter();
    public double get_MilligramsPerMicroliter();
    public double get_MilligramsPerMilliliter();
    public double get_NanogramsPerDeciliter();
    public double get_NanogramsPerLiter();
    public double get_NanogramsPerMicroliter();
    public double get_NanogramsPerMilliliter();
    public double get_OuncesPerImperialGallon();
    public double get_OuncesPerUSGallon();
    public double get_PicogramsPerDeciliter();
    public double get_PicogramsPerLiter();
    public double get_PicogramsPerMicroliter();
    public double get_PicogramsPerMilliliter();
    public double get_PoundsPerCubicFoot();
    public double get_PoundsPerCubicInch();
    public double get_PoundsPerImperialGallon();
    public double get_PoundsPerUSGallon();
    public double get_SlugsPerCubicFoot();
    public double get_TonnesPerCubicCentimeter();
    public double get_TonnesPerCubicMeter();
    public double get_TonnesPerCubicMillimeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(MassConcentrationUnit unit);
    public static string GetAbbreviation(MassConcentrationUnit unit, IFormatProvider provider);
    public static MassConcentration FromCentigramsPerDeciliter(double value);
    public static MassConcentration FromCentigramsPerLiter(double value);
    public static MassConcentration FromCentigramsPerMicroliter(double value);
    public static MassConcentration FromCentigramsPerMilliliter(double value);
    public static MassConcentration FromDecigramsPerDeciliter(double value);
    public static MassConcentration FromDecigramsPerLiter(double value);
    public static MassConcentration FromDecigramsPerMicroliter(double value);
    public static MassConcentration FromDecigramsPerMilliliter(double value);
    public static MassConcentration FromGramsPerCubicCentimeter(double value);
    public static MassConcentration FromGramsPerCubicMeter(double value);
    public static MassConcentration FromGramsPerCubicMillimeter(double value);
    public static MassConcentration FromGramsPerDeciliter(double value);
    public static MassConcentration FromGramsPerLiter(double value);
    public static MassConcentration FromGramsPerMicroliter(double value);
    public static MassConcentration FromGramsPerMilliliter(double value);
    public static MassConcentration FromKilogramsPerCubicCentimeter(double value);
    public static MassConcentration FromKilogramsPerCubicMeter(double value);
    public static MassConcentration FromKilogramsPerCubicMillimeter(double value);
    public static MassConcentration FromKilogramsPerLiter(double value);
    public static MassConcentration FromKilopoundsPerCubicFoot(double value);
    public static MassConcentration FromKilopoundsPerCubicInch(double value);
    public static MassConcentration FromMicrogramsPerCubicMeter(double value);
    public static MassConcentration FromMicrogramsPerDeciliter(double value);
    public static MassConcentration FromMicrogramsPerLiter(double value);
    public static MassConcentration FromMicrogramsPerMicroliter(double value);
    public static MassConcentration FromMicrogramsPerMilliliter(double value);
    public static MassConcentration FromMilligramsPerCubicMeter(double value);
    public static MassConcentration FromMilligramsPerDeciliter(double value);
    public static MassConcentration FromMilligramsPerLiter(double value);
    public static MassConcentration FromMilligramsPerMicroliter(double value);
    public static MassConcentration FromMilligramsPerMilliliter(double value);
    public static MassConcentration FromNanogramsPerDeciliter(double value);
    public static MassConcentration FromNanogramsPerLiter(double value);
    public static MassConcentration FromNanogramsPerMicroliter(double value);
    public static MassConcentration FromNanogramsPerMilliliter(double value);
    public static MassConcentration FromOuncesPerImperialGallon(double value);
    public static MassConcentration FromOuncesPerUSGallon(double value);
    public static MassConcentration FromPicogramsPerDeciliter(double value);
    public static MassConcentration FromPicogramsPerLiter(double value);
    public static MassConcentration FromPicogramsPerMicroliter(double value);
    public static MassConcentration FromPicogramsPerMilliliter(double value);
    public static MassConcentration FromPoundsPerCubicFoot(double value);
    public static MassConcentration FromPoundsPerCubicInch(double value);
    public static MassConcentration FromPoundsPerImperialGallon(double value);
    public static MassConcentration FromPoundsPerUSGallon(double value);
    public static MassConcentration FromSlugsPerCubicFoot(double value);
    public static MassConcentration FromTonnesPerCubicCentimeter(double value);
    public static MassConcentration FromTonnesPerCubicMeter(double value);
    public static MassConcentration FromTonnesPerCubicMillimeter(double value);
    public static MassConcentration From(double value, MassConcentrationUnit fromUnit);
    public static MassConcentration Parse(string str);
    public static override MassConcentration Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, MassConcentration& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, MassConcentration& result);
    public static MassConcentrationUnit ParseUnit(string str);
    public static MassConcentrationUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, MassConcentrationUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, MassConcentrationUnit& unit);
    public static override MassConcentration op_UnaryNegation(MassConcentration right);
    public static override MassConcentration op_Addition(MassConcentration left, MassConcentration right);
    public static override MassConcentration op_Subtraction(MassConcentration left, MassConcentration right);
    public static MassConcentration op_Multiply(double left, MassConcentration right);
    public static override MassConcentration op_Multiply(MassConcentration left, double right);
    public static override MassConcentration op_Division(MassConcentration left, double right);
    public static double op_Division(MassConcentration left, MassConcentration right);
    public static override Density op_Division(MassConcentration massConcentration, VolumeConcentration volumeConcentration);
    public static override Mass op_Multiply(MassConcentration massConcentration, Volume volume);
    public static override MolarMass op_Division(MassConcentration massConcentration, Molarity molarity);
    public static override Molarity op_Division(MassConcentration massConcentration, MolarMass molarMass);
    public static override VolumeConcentration op_Division(MassConcentration massConcentration, Density density);
    public static override bool op_LessThanOrEqual(MassConcentration left, MassConcentration right);
    public static override bool op_GreaterThanOrEqual(MassConcentration left, MassConcentration right);
    public static override bool op_LessThan(MassConcentration left, MassConcentration right);
    public static override bool op_GreaterThan(MassConcentration left, MassConcentration right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MassConcentration other, MassConcentration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(MassConcentration left, MassConcentration right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MassConcentration other, MassConcentration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(MassConcentration left, MassConcentration right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(MassConcentration other, MassConcentration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(MassConcentration other, MassConcentration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(MassConcentration other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(MassConcentration other);
    [ObsoleteAttribute("Use Equals(MassConcentration other, MassConcentration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(MassConcentration other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(MassConcentration other, MassConcentration tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(MassConcentrationUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public MassConcentration ToUnit(MassConcentrationUnit unit);
    public MassConcentration ToUnit(MassConcentrationUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(MassConcentrationUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public MassConcentration ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<MassConcentrationUnit> UnitsNet.IQuantity<UnitsNet.Units.MassConcentrationUnit>.ToUnit(MassConcentrationUnit unit);
    private sealed virtual override IQuantity`1<MassConcentrationUnit> UnitsNet.IQuantity<UnitsNet.Units.MassConcentrationUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.MassFlow : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<MassFlowUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<MassFlowUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassFlowUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassFlowUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassFlow <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<MassFlowUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static MassFlowUnit BaseUnit { get; }
    public static MassFlowUnit[] Units { get; }
    public static MassFlow Zero { get; }
    public static MassFlow AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public MassFlowUnit Unit { get; }
    public QuantityInfo`1<MassFlowUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentigramsPerDay { get; }
    public double CentigramsPerSecond { get; }
    public double DecagramsPerDay { get; }
    public double DecagramsPerSecond { get; }
    public double DecigramsPerDay { get; }
    public double DecigramsPerSecond { get; }
    public double GramsPerDay { get; }
    public double GramsPerHour { get; }
    public double GramsPerSecond { get; }
    public double HectogramsPerDay { get; }
    public double HectogramsPerSecond { get; }
    public double KilogramsPerDay { get; }
    public double KilogramsPerHour { get; }
    public double KilogramsPerMinute { get; }
    public double KilogramsPerSecond { get; }
    public double MegagramsPerDay { get; }
    public double MegapoundsPerDay { get; }
    public double MegapoundsPerHour { get; }
    public double MegapoundsPerMinute { get; }
    public double MegapoundsPerSecond { get; }
    public double MicrogramsPerDay { get; }
    public double MicrogramsPerSecond { get; }
    public double MilligramsPerDay { get; }
    public double MilligramsPerSecond { get; }
    public double NanogramsPerDay { get; }
    public double NanogramsPerSecond { get; }
    public double PoundsPerDay { get; }
    public double PoundsPerHour { get; }
    public double PoundsPerMinute { get; }
    public double PoundsPerSecond { get; }
    public double ShortTonsPerHour { get; }
    public double TonnesPerDay { get; }
    public double TonnesPerHour { get; }
    private static MassFlow();
    public MassFlow(double value, MassFlowUnit unit);
    public MassFlow(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<MassFlowUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static MassFlowUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static MassFlowUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override MassFlow get_Zero();
    public static override MassFlow get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual MassFlowUnit get_Unit();
    public sealed virtual QuantityInfo`1<MassFlowUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentigramsPerDay();
    public double get_CentigramsPerSecond();
    public double get_DecagramsPerDay();
    public double get_DecagramsPerSecond();
    public double get_DecigramsPerDay();
    public double get_DecigramsPerSecond();
    public double get_GramsPerDay();
    public double get_GramsPerHour();
    public double get_GramsPerSecond();
    public double get_HectogramsPerDay();
    public double get_HectogramsPerSecond();
    public double get_KilogramsPerDay();
    public double get_KilogramsPerHour();
    public double get_KilogramsPerMinute();
    public double get_KilogramsPerSecond();
    public double get_MegagramsPerDay();
    public double get_MegapoundsPerDay();
    public double get_MegapoundsPerHour();
    public double get_MegapoundsPerMinute();
    public double get_MegapoundsPerSecond();
    public double get_MicrogramsPerDay();
    public double get_MicrogramsPerSecond();
    public double get_MilligramsPerDay();
    public double get_MilligramsPerSecond();
    public double get_NanogramsPerDay();
    public double get_NanogramsPerSecond();
    public double get_PoundsPerDay();
    public double get_PoundsPerHour();
    public double get_PoundsPerMinute();
    public double get_PoundsPerSecond();
    public double get_ShortTonsPerHour();
    public double get_TonnesPerDay();
    public double get_TonnesPerHour();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(MassFlowUnit unit);
    public static string GetAbbreviation(MassFlowUnit unit, IFormatProvider provider);
    public static MassFlow FromCentigramsPerDay(double value);
    public static MassFlow FromCentigramsPerSecond(double value);
    public static MassFlow FromDecagramsPerDay(double value);
    public static MassFlow FromDecagramsPerSecond(double value);
    public static MassFlow FromDecigramsPerDay(double value);
    public static MassFlow FromDecigramsPerSecond(double value);
    public static MassFlow FromGramsPerDay(double value);
    public static MassFlow FromGramsPerHour(double value);
    public static MassFlow FromGramsPerSecond(double value);
    public static MassFlow FromHectogramsPerDay(double value);
    public static MassFlow FromHectogramsPerSecond(double value);
    public static MassFlow FromKilogramsPerDay(double value);
    public static MassFlow FromKilogramsPerHour(double value);
    public static MassFlow FromKilogramsPerMinute(double value);
    public static MassFlow FromKilogramsPerSecond(double value);
    public static MassFlow FromMegagramsPerDay(double value);
    public static MassFlow FromMegapoundsPerDay(double value);
    public static MassFlow FromMegapoundsPerHour(double value);
    public static MassFlow FromMegapoundsPerMinute(double value);
    public static MassFlow FromMegapoundsPerSecond(double value);
    public static MassFlow FromMicrogramsPerDay(double value);
    public static MassFlow FromMicrogramsPerSecond(double value);
    public static MassFlow FromMilligramsPerDay(double value);
    public static MassFlow FromMilligramsPerSecond(double value);
    public static MassFlow FromNanogramsPerDay(double value);
    public static MassFlow FromNanogramsPerSecond(double value);
    public static MassFlow FromPoundsPerDay(double value);
    public static MassFlow FromPoundsPerHour(double value);
    public static MassFlow FromPoundsPerMinute(double value);
    public static MassFlow FromPoundsPerSecond(double value);
    public static MassFlow FromShortTonsPerHour(double value);
    public static MassFlow FromTonnesPerDay(double value);
    public static MassFlow FromTonnesPerHour(double value);
    public static MassFlow From(double value, MassFlowUnit fromUnit);
    public static MassFlow Parse(string str);
    public static override MassFlow Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, MassFlow& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, MassFlow& result);
    public static MassFlowUnit ParseUnit(string str);
    public static MassFlowUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, MassFlowUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, MassFlowUnit& unit);
    public static override MassFlow op_UnaryNegation(MassFlow right);
    public static override MassFlow op_Addition(MassFlow left, MassFlow right);
    public static override MassFlow op_Subtraction(MassFlow left, MassFlow right);
    public static MassFlow op_Multiply(double left, MassFlow right);
    public static override MassFlow op_Multiply(MassFlow left, double right);
    public static override MassFlow op_Division(MassFlow left, double right);
    public static double op_Division(MassFlow left, MassFlow right);
    public static override Area op_Division(MassFlow massFlow, MassFlux massFlux);
    public static override BrakeSpecificFuelConsumption op_Division(MassFlow massFlow, Power power);
    public static override Density op_Division(MassFlow massFlow, VolumeFlow volumeFlow);
    public static override Mass op_Multiply(MassFlow massFlow, Duration duration);
    public static override MassFlux op_Division(MassFlow massFlow, Area area);
    public static override MolarFlow op_Division(MassFlow massFlow, MolarMass molarMass);
    public static override MolarMass op_Division(MassFlow massFlow, MolarFlow molarFlow);
    public static override Power op_Multiply(MassFlow massFlow, SpecificEnergy specificEnergy);
    public static override Power op_Division(MassFlow massFlow, BrakeSpecificFuelConsumption brakeSpecificFuelConsumption);
    public static override VolumeFlow op_Division(MassFlow massFlow, Density density);
    public static override bool op_LessThanOrEqual(MassFlow left, MassFlow right);
    public static override bool op_GreaterThanOrEqual(MassFlow left, MassFlow right);
    public static override bool op_LessThan(MassFlow left, MassFlow right);
    public static override bool op_GreaterThan(MassFlow left, MassFlow right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MassFlow other, MassFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(MassFlow left, MassFlow right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MassFlow other, MassFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(MassFlow left, MassFlow right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(MassFlow other, MassFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(MassFlow other, MassFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(MassFlow other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(MassFlow other);
    [ObsoleteAttribute("Use Equals(MassFlow other, MassFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(MassFlow other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(MassFlow other, MassFlow tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(MassFlowUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public MassFlow ToUnit(MassFlowUnit unit);
    public MassFlow ToUnit(MassFlowUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(MassFlowUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public MassFlow ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<MassFlowUnit> UnitsNet.IQuantity<UnitsNet.Units.MassFlowUnit>.ToUnit(MassFlowUnit unit);
    private sealed virtual override IQuantity`1<MassFlowUnit> UnitsNet.IQuantity<UnitsNet.Units.MassFlowUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.MassFlux : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<MassFluxUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<MassFluxUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassFluxUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassFluxUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassFlux <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<MassFluxUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static MassFluxUnit BaseUnit { get; }
    public static MassFluxUnit[] Units { get; }
    public static MassFlux Zero { get; }
    public static MassFlux AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public MassFluxUnit Unit { get; }
    public QuantityInfo`1<MassFluxUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double GramsPerHourPerSquareCentimeter { get; }
    public double GramsPerHourPerSquareMeter { get; }
    public double GramsPerHourPerSquareMillimeter { get; }
    public double GramsPerSecondPerSquareCentimeter { get; }
    public double GramsPerSecondPerSquareMeter { get; }
    public double GramsPerSecondPerSquareMillimeter { get; }
    public double KilogramsPerHourPerSquareCentimeter { get; }
    public double KilogramsPerHourPerSquareMeter { get; }
    public double KilogramsPerHourPerSquareMillimeter { get; }
    public double KilogramsPerSecondPerSquareCentimeter { get; }
    public double KilogramsPerSecondPerSquareMeter { get; }
    public double KilogramsPerSecondPerSquareMillimeter { get; }
    private static MassFlux();
    public MassFlux(double value, MassFluxUnit unit);
    public MassFlux(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<MassFluxUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static MassFluxUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static MassFluxUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override MassFlux get_Zero();
    public static override MassFlux get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual MassFluxUnit get_Unit();
    public sealed virtual QuantityInfo`1<MassFluxUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_GramsPerHourPerSquareCentimeter();
    public double get_GramsPerHourPerSquareMeter();
    public double get_GramsPerHourPerSquareMillimeter();
    public double get_GramsPerSecondPerSquareCentimeter();
    public double get_GramsPerSecondPerSquareMeter();
    public double get_GramsPerSecondPerSquareMillimeter();
    public double get_KilogramsPerHourPerSquareCentimeter();
    public double get_KilogramsPerHourPerSquareMeter();
    public double get_KilogramsPerHourPerSquareMillimeter();
    public double get_KilogramsPerSecondPerSquareCentimeter();
    public double get_KilogramsPerSecondPerSquareMeter();
    public double get_KilogramsPerSecondPerSquareMillimeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(MassFluxUnit unit);
    public static string GetAbbreviation(MassFluxUnit unit, IFormatProvider provider);
    public static MassFlux FromGramsPerHourPerSquareCentimeter(double value);
    public static MassFlux FromGramsPerHourPerSquareMeter(double value);
    public static MassFlux FromGramsPerHourPerSquareMillimeter(double value);
    public static MassFlux FromGramsPerSecondPerSquareCentimeter(double value);
    public static MassFlux FromGramsPerSecondPerSquareMeter(double value);
    public static MassFlux FromGramsPerSecondPerSquareMillimeter(double value);
    public static MassFlux FromKilogramsPerHourPerSquareCentimeter(double value);
    public static MassFlux FromKilogramsPerHourPerSquareMeter(double value);
    public static MassFlux FromKilogramsPerHourPerSquareMillimeter(double value);
    public static MassFlux FromKilogramsPerSecondPerSquareCentimeter(double value);
    public static MassFlux FromKilogramsPerSecondPerSquareMeter(double value);
    public static MassFlux FromKilogramsPerSecondPerSquareMillimeter(double value);
    public static MassFlux From(double value, MassFluxUnit fromUnit);
    public static MassFlux Parse(string str);
    public static override MassFlux Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, MassFlux& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, MassFlux& result);
    public static MassFluxUnit ParseUnit(string str);
    public static MassFluxUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, MassFluxUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, MassFluxUnit& unit);
    public static override MassFlux op_UnaryNegation(MassFlux right);
    public static override MassFlux op_Addition(MassFlux left, MassFlux right);
    public static override MassFlux op_Subtraction(MassFlux left, MassFlux right);
    public static MassFlux op_Multiply(double left, MassFlux right);
    public static override MassFlux op_Multiply(MassFlux left, double right);
    public static override MassFlux op_Division(MassFlux left, double right);
    public static double op_Division(MassFlux left, MassFlux right);
    public static override Density op_Division(MassFlux massFlux, Speed speed);
    public static override MassFlow op_Multiply(MassFlux massFlux, Area area);
    public static override Speed op_Division(MassFlux massFlux, Density density);
    public static override bool op_LessThanOrEqual(MassFlux left, MassFlux right);
    public static override bool op_GreaterThanOrEqual(MassFlux left, MassFlux right);
    public static override bool op_LessThan(MassFlux left, MassFlux right);
    public static override bool op_GreaterThan(MassFlux left, MassFlux right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MassFlux other, MassFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(MassFlux left, MassFlux right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MassFlux other, MassFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(MassFlux left, MassFlux right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(MassFlux other, MassFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(MassFlux other, MassFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(MassFlux other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(MassFlux other);
    [ObsoleteAttribute("Use Equals(MassFlux other, MassFlux tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(MassFlux other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(MassFlux other, MassFlux tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(MassFluxUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public MassFlux ToUnit(MassFluxUnit unit);
    public MassFlux ToUnit(MassFluxUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(MassFluxUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public MassFlux ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<MassFluxUnit> UnitsNet.IQuantity<UnitsNet.Units.MassFluxUnit>.ToUnit(MassFluxUnit unit);
    private sealed virtual override IQuantity`1<MassFluxUnit> UnitsNet.IQuantity<UnitsNet.Units.MassFluxUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.MassFraction : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<MassFractionUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<MassFractionUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassFractionUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassFractionUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassFraction <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<MassFractionUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static MassFractionUnit BaseUnit { get; }
    public static MassFractionUnit[] Units { get; }
    public static MassFraction Zero { get; }
    public static MassFraction AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public MassFractionUnit Unit { get; }
    public QuantityInfo`1<MassFractionUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentigramsPerGram { get; }
    public double CentigramsPerKilogram { get; }
    public double DecagramsPerGram { get; }
    public double DecagramsPerKilogram { get; }
    public double DecigramsPerGram { get; }
    public double DecigramsPerKilogram { get; }
    public double DecimalFractions { get; }
    public double GramsPerGram { get; }
    public double GramsPerKilogram { get; }
    public double HectogramsPerGram { get; }
    public double HectogramsPerKilogram { get; }
    public double KilogramsPerGram { get; }
    public double KilogramsPerKilogram { get; }
    public double MicrogramsPerGram { get; }
    public double MicrogramsPerKilogram { get; }
    public double MilligramsPerGram { get; }
    public double MilligramsPerKilogram { get; }
    public double NanogramsPerGram { get; }
    public double NanogramsPerKilogram { get; }
    public double PartsPerBillion { get; }
    public double PartsPerMillion { get; }
    public double PartsPerThousand { get; }
    public double PartsPerTrillion { get; }
    public double Percent { get; }
    private static MassFraction();
    public MassFraction(double value, MassFractionUnit unit);
    public MassFraction(double value, UnitSystem unitSystem);
    public Mass GetComponentMass(Mass totalMass);
    public Mass GetTotalMass(Mass componentMass);
    public static MassFraction FromMasses(Mass componentMass, Mass mixtureMass);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<MassFractionUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static MassFractionUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static MassFractionUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override MassFraction get_Zero();
    public static override MassFraction get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual MassFractionUnit get_Unit();
    public sealed virtual QuantityInfo`1<MassFractionUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentigramsPerGram();
    public double get_CentigramsPerKilogram();
    public double get_DecagramsPerGram();
    public double get_DecagramsPerKilogram();
    public double get_DecigramsPerGram();
    public double get_DecigramsPerKilogram();
    public double get_DecimalFractions();
    public double get_GramsPerGram();
    public double get_GramsPerKilogram();
    public double get_HectogramsPerGram();
    public double get_HectogramsPerKilogram();
    public double get_KilogramsPerGram();
    public double get_KilogramsPerKilogram();
    public double get_MicrogramsPerGram();
    public double get_MicrogramsPerKilogram();
    public double get_MilligramsPerGram();
    public double get_MilligramsPerKilogram();
    public double get_NanogramsPerGram();
    public double get_NanogramsPerKilogram();
    public double get_PartsPerBillion();
    public double get_PartsPerMillion();
    public double get_PartsPerThousand();
    public double get_PartsPerTrillion();
    public double get_Percent();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(MassFractionUnit unit);
    public static string GetAbbreviation(MassFractionUnit unit, IFormatProvider provider);
    public static MassFraction FromCentigramsPerGram(double value);
    public static MassFraction FromCentigramsPerKilogram(double value);
    public static MassFraction FromDecagramsPerGram(double value);
    public static MassFraction FromDecagramsPerKilogram(double value);
    public static MassFraction FromDecigramsPerGram(double value);
    public static MassFraction FromDecigramsPerKilogram(double value);
    public static MassFraction FromDecimalFractions(double value);
    public static MassFraction FromGramsPerGram(double value);
    public static MassFraction FromGramsPerKilogram(double value);
    public static MassFraction FromHectogramsPerGram(double value);
    public static MassFraction FromHectogramsPerKilogram(double value);
    public static MassFraction FromKilogramsPerGram(double value);
    public static MassFraction FromKilogramsPerKilogram(double value);
    public static MassFraction FromMicrogramsPerGram(double value);
    public static MassFraction FromMicrogramsPerKilogram(double value);
    public static MassFraction FromMilligramsPerGram(double value);
    public static MassFraction FromMilligramsPerKilogram(double value);
    public static MassFraction FromNanogramsPerGram(double value);
    public static MassFraction FromNanogramsPerKilogram(double value);
    public static MassFraction FromPartsPerBillion(double value);
    public static MassFraction FromPartsPerMillion(double value);
    public static MassFraction FromPartsPerThousand(double value);
    public static MassFraction FromPartsPerTrillion(double value);
    public static MassFraction FromPercent(double value);
    public static MassFraction From(double value, MassFractionUnit fromUnit);
    public static MassFraction Parse(string str);
    public static override MassFraction Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, MassFraction& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, MassFraction& result);
    public static MassFractionUnit ParseUnit(string str);
    public static MassFractionUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, MassFractionUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, MassFractionUnit& unit);
    public static override MassFraction op_UnaryNegation(MassFraction right);
    public static override MassFraction op_Addition(MassFraction left, MassFraction right);
    public static override MassFraction op_Subtraction(MassFraction left, MassFraction right);
    public static MassFraction op_Multiply(double left, MassFraction right);
    public static override MassFraction op_Multiply(MassFraction left, double right);
    public static override MassFraction op_Division(MassFraction left, double right);
    public static double op_Division(MassFraction left, MassFraction right);
    public static override Mass op_Multiply(MassFraction massFraction, Mass mass);
    public static override bool op_LessThanOrEqual(MassFraction left, MassFraction right);
    public static override bool op_GreaterThanOrEqual(MassFraction left, MassFraction right);
    public static override bool op_LessThan(MassFraction left, MassFraction right);
    public static override bool op_GreaterThan(MassFraction left, MassFraction right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MassFraction other, MassFraction tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(MassFraction left, MassFraction right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MassFraction other, MassFraction tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(MassFraction left, MassFraction right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(MassFraction other, MassFraction tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(MassFraction other, MassFraction tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(MassFraction other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(MassFraction other);
    [ObsoleteAttribute("Use Equals(MassFraction other, MassFraction tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(MassFraction other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(MassFraction other, MassFraction tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(MassFractionUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public MassFraction ToUnit(MassFractionUnit unit);
    public MassFraction ToUnit(MassFractionUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(MassFractionUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public MassFraction ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<MassFractionUnit> UnitsNet.IQuantity<UnitsNet.Units.MassFractionUnit>.ToUnit(MassFractionUnit unit);
    private sealed virtual override IQuantity`1<MassFractionUnit> UnitsNet.IQuantity<UnitsNet.Units.MassFractionUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.MassMomentOfInertia : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<MassMomentOfInertiaUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<MassMomentOfInertiaUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassMomentOfInertiaUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassMomentOfInertiaUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static MassMomentOfInertia <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<MassMomentOfInertiaUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static MassMomentOfInertiaUnit BaseUnit { get; }
    public static MassMomentOfInertiaUnit[] Units { get; }
    public static MassMomentOfInertia Zero { get; }
    public static MassMomentOfInertia AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public MassMomentOfInertiaUnit Unit { get; }
    public QuantityInfo`1<MassMomentOfInertiaUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double GramSquareCentimeters { get; }
    public double GramSquareDecimeters { get; }
    public double GramSquareMeters { get; }
    public double GramSquareMillimeters { get; }
    public double KilogramSquareCentimeters { get; }
    public double KilogramSquareDecimeters { get; }
    public double KilogramSquareMeters { get; }
    public double KilogramSquareMillimeters { get; }
    public double KilotonneSquareCentimeters { get; }
    public double KilotonneSquareDecimeters { get; }
    public double KilotonneSquareMeters { get; }
    public double KilotonneSquareMilimeters { get; }
    public double MegatonneSquareCentimeters { get; }
    public double MegatonneSquareDecimeters { get; }
    public double MegatonneSquareMeters { get; }
    public double MegatonneSquareMilimeters { get; }
    public double MilligramSquareCentimeters { get; }
    public double MilligramSquareDecimeters { get; }
    public double MilligramSquareMeters { get; }
    public double MilligramSquareMillimeters { get; }
    public double PoundSquareFeet { get; }
    public double PoundSquareInches { get; }
    public double SlugSquareFeet { get; }
    public double SlugSquareInches { get; }
    public double TonneSquareCentimeters { get; }
    public double TonneSquareDecimeters { get; }
    public double TonneSquareMeters { get; }
    public double TonneSquareMilimeters { get; }
    private static MassMomentOfInertia();
    public MassMomentOfInertia(double value, MassMomentOfInertiaUnit unit);
    public MassMomentOfInertia(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<MassMomentOfInertiaUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static MassMomentOfInertiaUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static MassMomentOfInertiaUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override MassMomentOfInertia get_Zero();
    public static override MassMomentOfInertia get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual MassMomentOfInertiaUnit get_Unit();
    public sealed virtual QuantityInfo`1<MassMomentOfInertiaUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_GramSquareCentimeters();
    public double get_GramSquareDecimeters();
    public double get_GramSquareMeters();
    public double get_GramSquareMillimeters();
    public double get_KilogramSquareCentimeters();
    public double get_KilogramSquareDecimeters();
    public double get_KilogramSquareMeters();
    public double get_KilogramSquareMillimeters();
    public double get_KilotonneSquareCentimeters();
    public double get_KilotonneSquareDecimeters();
    public double get_KilotonneSquareMeters();
    public double get_KilotonneSquareMilimeters();
    public double get_MegatonneSquareCentimeters();
    public double get_MegatonneSquareDecimeters();
    public double get_MegatonneSquareMeters();
    public double get_MegatonneSquareMilimeters();
    public double get_MilligramSquareCentimeters();
    public double get_MilligramSquareDecimeters();
    public double get_MilligramSquareMeters();
    public double get_MilligramSquareMillimeters();
    public double get_PoundSquareFeet();
    public double get_PoundSquareInches();
    public double get_SlugSquareFeet();
    public double get_SlugSquareInches();
    public double get_TonneSquareCentimeters();
    public double get_TonneSquareDecimeters();
    public double get_TonneSquareMeters();
    public double get_TonneSquareMilimeters();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(MassMomentOfInertiaUnit unit);
    public static string GetAbbreviation(MassMomentOfInertiaUnit unit, IFormatProvider provider);
    public static MassMomentOfInertia FromGramSquareCentimeters(double value);
    public static MassMomentOfInertia FromGramSquareDecimeters(double value);
    public static MassMomentOfInertia FromGramSquareMeters(double value);
    public static MassMomentOfInertia FromGramSquareMillimeters(double value);
    public static MassMomentOfInertia FromKilogramSquareCentimeters(double value);
    public static MassMomentOfInertia FromKilogramSquareDecimeters(double value);
    public static MassMomentOfInertia FromKilogramSquareMeters(double value);
    public static MassMomentOfInertia FromKilogramSquareMillimeters(double value);
    public static MassMomentOfInertia FromKilotonneSquareCentimeters(double value);
    public static MassMomentOfInertia FromKilotonneSquareDecimeters(double value);
    public static MassMomentOfInertia FromKilotonneSquareMeters(double value);
    public static MassMomentOfInertia FromKilotonneSquareMilimeters(double value);
    public static MassMomentOfInertia FromMegatonneSquareCentimeters(double value);
    public static MassMomentOfInertia FromMegatonneSquareDecimeters(double value);
    public static MassMomentOfInertia FromMegatonneSquareMeters(double value);
    public static MassMomentOfInertia FromMegatonneSquareMilimeters(double value);
    public static MassMomentOfInertia FromMilligramSquareCentimeters(double value);
    public static MassMomentOfInertia FromMilligramSquareDecimeters(double value);
    public static MassMomentOfInertia FromMilligramSquareMeters(double value);
    public static MassMomentOfInertia FromMilligramSquareMillimeters(double value);
    public static MassMomentOfInertia FromPoundSquareFeet(double value);
    public static MassMomentOfInertia FromPoundSquareInches(double value);
    public static MassMomentOfInertia FromSlugSquareFeet(double value);
    public static MassMomentOfInertia FromSlugSquareInches(double value);
    public static MassMomentOfInertia FromTonneSquareCentimeters(double value);
    public static MassMomentOfInertia FromTonneSquareDecimeters(double value);
    public static MassMomentOfInertia FromTonneSquareMeters(double value);
    public static MassMomentOfInertia FromTonneSquareMilimeters(double value);
    public static MassMomentOfInertia From(double value, MassMomentOfInertiaUnit fromUnit);
    public static MassMomentOfInertia Parse(string str);
    public static override MassMomentOfInertia Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, MassMomentOfInertia& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, MassMomentOfInertia& result);
    public static MassMomentOfInertiaUnit ParseUnit(string str);
    public static MassMomentOfInertiaUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, MassMomentOfInertiaUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, MassMomentOfInertiaUnit& unit);
    public static override MassMomentOfInertia op_UnaryNegation(MassMomentOfInertia right);
    public static override MassMomentOfInertia op_Addition(MassMomentOfInertia left, MassMomentOfInertia right);
    public static override MassMomentOfInertia op_Subtraction(MassMomentOfInertia left, MassMomentOfInertia right);
    public static MassMomentOfInertia op_Multiply(double left, MassMomentOfInertia right);
    public static override MassMomentOfInertia op_Multiply(MassMomentOfInertia left, double right);
    public static override MassMomentOfInertia op_Division(MassMomentOfInertia left, double right);
    public static double op_Division(MassMomentOfInertia left, MassMomentOfInertia right);
    public static override bool op_LessThanOrEqual(MassMomentOfInertia left, MassMomentOfInertia right);
    public static override bool op_GreaterThanOrEqual(MassMomentOfInertia left, MassMomentOfInertia right);
    public static override bool op_LessThan(MassMomentOfInertia left, MassMomentOfInertia right);
    public static override bool op_GreaterThan(MassMomentOfInertia left, MassMomentOfInertia right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MassMomentOfInertia other, MassMomentOfInertia tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(MassMomentOfInertia left, MassMomentOfInertia right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MassMomentOfInertia other, MassMomentOfInertia tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(MassMomentOfInertia left, MassMomentOfInertia right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(MassMomentOfInertia other, MassMomentOfInertia tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(MassMomentOfInertia other, MassMomentOfInertia tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(MassMomentOfInertia other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(MassMomentOfInertia other);
    [ObsoleteAttribute("Use Equals(MassMomentOfInertia other, MassMomentOfInertia tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(MassMomentOfInertia other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(MassMomentOfInertia other, MassMomentOfInertia tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(MassMomentOfInertiaUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public MassMomentOfInertia ToUnit(MassMomentOfInertiaUnit unit);
    public MassMomentOfInertia ToUnit(MassMomentOfInertiaUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(MassMomentOfInertiaUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public MassMomentOfInertia ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<MassMomentOfInertiaUnit> UnitsNet.IQuantity<UnitsNet.Units.MassMomentOfInertiaUnit>.ToUnit(MassMomentOfInertiaUnit unit);
    private sealed virtual override IQuantity`1<MassMomentOfInertiaUnit> UnitsNet.IQuantity<UnitsNet.Units.MassMomentOfInertiaUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Molality : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<MolalityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<MolalityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static MolalityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static MolalityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Molality <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<MolalityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static MolalityUnit BaseUnit { get; }
    public static MolalityUnit[] Units { get; }
    public static Molality Zero { get; }
    public static Molality AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public MolalityUnit Unit { get; }
    public QuantityInfo`1<MolalityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double MillimolesPerKilogram { get; }
    public double MolesPerGram { get; }
    public double MolesPerKilogram { get; }
    private static Molality();
    public Molality(double value, MolalityUnit unit);
    public Molality(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<MolalityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static MolalityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static MolalityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Molality get_Zero();
    public static override Molality get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual MolalityUnit get_Unit();
    public sealed virtual QuantityInfo`1<MolalityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_MillimolesPerKilogram();
    public double get_MolesPerGram();
    public double get_MolesPerKilogram();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(MolalityUnit unit);
    public static string GetAbbreviation(MolalityUnit unit, IFormatProvider provider);
    public static Molality FromMillimolesPerKilogram(double value);
    public static Molality FromMolesPerGram(double value);
    public static Molality FromMolesPerKilogram(double value);
    public static Molality From(double value, MolalityUnit fromUnit);
    public static Molality Parse(string str);
    public static override Molality Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Molality& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Molality& result);
    public static MolalityUnit ParseUnit(string str);
    public static MolalityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, MolalityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, MolalityUnit& unit);
    public static override Molality op_UnaryNegation(Molality right);
    public static override Molality op_Addition(Molality left, Molality right);
    public static override Molality op_Subtraction(Molality left, Molality right);
    public static Molality op_Multiply(double left, Molality right);
    public static override Molality op_Multiply(Molality left, double right);
    public static override Molality op_Division(Molality left, double right);
    public static double op_Division(Molality left, Molality right);
    public static override bool op_LessThanOrEqual(Molality left, Molality right);
    public static override bool op_GreaterThanOrEqual(Molality left, Molality right);
    public static override bool op_LessThan(Molality left, Molality right);
    public static override bool op_GreaterThan(Molality left, Molality right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Molality other, Molality tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Molality left, Molality right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Molality other, Molality tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Molality left, Molality right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Molality other, Molality tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Molality other, Molality tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Molality other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Molality other);
    [ObsoleteAttribute("Use Equals(Molality other, Molality tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Molality other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Molality other, Molality tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(MolalityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Molality ToUnit(MolalityUnit unit);
    public Molality ToUnit(MolalityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(MolalityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Molality ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<MolalityUnit> UnitsNet.IQuantity<UnitsNet.Units.MolalityUnit>.ToUnit(MolalityUnit unit);
    private sealed virtual override IQuantity`1<MolalityUnit> UnitsNet.IQuantity<UnitsNet.Units.MolalityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.MolarEnergy : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<MolarEnergyUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<MolarEnergyUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static MolarEnergyUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static MolarEnergyUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static MolarEnergy <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<MolarEnergyUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static MolarEnergyUnit BaseUnit { get; }
    public static MolarEnergyUnit[] Units { get; }
    public static MolarEnergy Zero { get; }
    public static MolarEnergy AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public MolarEnergyUnit Unit { get; }
    public QuantityInfo`1<MolarEnergyUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double JoulesPerMole { get; }
    public double KilojoulesPerMole { get; }
    public double MegajoulesPerMole { get; }
    private static MolarEnergy();
    public MolarEnergy(double value, MolarEnergyUnit unit);
    public MolarEnergy(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<MolarEnergyUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static MolarEnergyUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static MolarEnergyUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override MolarEnergy get_Zero();
    public static override MolarEnergy get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual MolarEnergyUnit get_Unit();
    public sealed virtual QuantityInfo`1<MolarEnergyUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_JoulesPerMole();
    public double get_KilojoulesPerMole();
    public double get_MegajoulesPerMole();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(MolarEnergyUnit unit);
    public static string GetAbbreviation(MolarEnergyUnit unit, IFormatProvider provider);
    public static MolarEnergy FromJoulesPerMole(double value);
    public static MolarEnergy FromKilojoulesPerMole(double value);
    public static MolarEnergy FromMegajoulesPerMole(double value);
    public static MolarEnergy From(double value, MolarEnergyUnit fromUnit);
    public static MolarEnergy Parse(string str);
    public static override MolarEnergy Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, MolarEnergy& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, MolarEnergy& result);
    public static MolarEnergyUnit ParseUnit(string str);
    public static MolarEnergyUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, MolarEnergyUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, MolarEnergyUnit& unit);
    public static override MolarEnergy op_UnaryNegation(MolarEnergy right);
    public static override MolarEnergy op_Addition(MolarEnergy left, MolarEnergy right);
    public static override MolarEnergy op_Subtraction(MolarEnergy left, MolarEnergy right);
    public static MolarEnergy op_Multiply(double left, MolarEnergy right);
    public static override MolarEnergy op_Multiply(MolarEnergy left, double right);
    public static override MolarEnergy op_Division(MolarEnergy left, double right);
    public static double op_Division(MolarEnergy left, MolarEnergy right);
    public static override bool op_LessThanOrEqual(MolarEnergy left, MolarEnergy right);
    public static override bool op_GreaterThanOrEqual(MolarEnergy left, MolarEnergy right);
    public static override bool op_LessThan(MolarEnergy left, MolarEnergy right);
    public static override bool op_GreaterThan(MolarEnergy left, MolarEnergy right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MolarEnergy other, MolarEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(MolarEnergy left, MolarEnergy right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MolarEnergy other, MolarEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(MolarEnergy left, MolarEnergy right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(MolarEnergy other, MolarEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(MolarEnergy other, MolarEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(MolarEnergy other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(MolarEnergy other);
    [ObsoleteAttribute("Use Equals(MolarEnergy other, MolarEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(MolarEnergy other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(MolarEnergy other, MolarEnergy tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(MolarEnergyUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public MolarEnergy ToUnit(MolarEnergyUnit unit);
    public MolarEnergy ToUnit(MolarEnergyUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(MolarEnergyUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public MolarEnergy ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<MolarEnergyUnit> UnitsNet.IQuantity<UnitsNet.Units.MolarEnergyUnit>.ToUnit(MolarEnergyUnit unit);
    private sealed virtual override IQuantity`1<MolarEnergyUnit> UnitsNet.IQuantity<UnitsNet.Units.MolarEnergyUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.MolarEntropy : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<MolarEntropyUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<MolarEntropyUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static MolarEntropyUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static MolarEntropyUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static MolarEntropy <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<MolarEntropyUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static MolarEntropyUnit BaseUnit { get; }
    public static MolarEntropyUnit[] Units { get; }
    public static MolarEntropy Zero { get; }
    public static MolarEntropy AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public MolarEntropyUnit Unit { get; }
    public QuantityInfo`1<MolarEntropyUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double JoulesPerMoleKelvin { get; }
    public double KilojoulesPerMoleKelvin { get; }
    public double MegajoulesPerMoleKelvin { get; }
    private static MolarEntropy();
    public MolarEntropy(double value, MolarEntropyUnit unit);
    public MolarEntropy(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<MolarEntropyUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static MolarEntropyUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static MolarEntropyUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override MolarEntropy get_Zero();
    public static override MolarEntropy get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual MolarEntropyUnit get_Unit();
    public sealed virtual QuantityInfo`1<MolarEntropyUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_JoulesPerMoleKelvin();
    public double get_KilojoulesPerMoleKelvin();
    public double get_MegajoulesPerMoleKelvin();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(MolarEntropyUnit unit);
    public static string GetAbbreviation(MolarEntropyUnit unit, IFormatProvider provider);
    public static MolarEntropy FromJoulesPerMoleKelvin(double value);
    public static MolarEntropy FromKilojoulesPerMoleKelvin(double value);
    public static MolarEntropy FromMegajoulesPerMoleKelvin(double value);
    public static MolarEntropy From(double value, MolarEntropyUnit fromUnit);
    public static MolarEntropy Parse(string str);
    public static override MolarEntropy Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, MolarEntropy& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, MolarEntropy& result);
    public static MolarEntropyUnit ParseUnit(string str);
    public static MolarEntropyUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, MolarEntropyUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, MolarEntropyUnit& unit);
    public static override MolarEntropy op_UnaryNegation(MolarEntropy right);
    public static override MolarEntropy op_Addition(MolarEntropy left, MolarEntropy right);
    public static override MolarEntropy op_Subtraction(MolarEntropy left, MolarEntropy right);
    public static MolarEntropy op_Multiply(double left, MolarEntropy right);
    public static override MolarEntropy op_Multiply(MolarEntropy left, double right);
    public static override MolarEntropy op_Division(MolarEntropy left, double right);
    public static double op_Division(MolarEntropy left, MolarEntropy right);
    public static override bool op_LessThanOrEqual(MolarEntropy left, MolarEntropy right);
    public static override bool op_GreaterThanOrEqual(MolarEntropy left, MolarEntropy right);
    public static override bool op_LessThan(MolarEntropy left, MolarEntropy right);
    public static override bool op_GreaterThan(MolarEntropy left, MolarEntropy right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MolarEntropy other, MolarEntropy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(MolarEntropy left, MolarEntropy right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MolarEntropy other, MolarEntropy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(MolarEntropy left, MolarEntropy right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(MolarEntropy other, MolarEntropy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(MolarEntropy other, MolarEntropy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(MolarEntropy other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(MolarEntropy other);
    [ObsoleteAttribute("Use Equals(MolarEntropy other, MolarEntropy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(MolarEntropy other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(MolarEntropy other, MolarEntropy tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(MolarEntropyUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public MolarEntropy ToUnit(MolarEntropyUnit unit);
    public MolarEntropy ToUnit(MolarEntropyUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(MolarEntropyUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public MolarEntropy ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<MolarEntropyUnit> UnitsNet.IQuantity<UnitsNet.Units.MolarEntropyUnit>.ToUnit(MolarEntropyUnit unit);
    private sealed virtual override IQuantity`1<MolarEntropyUnit> UnitsNet.IQuantity<UnitsNet.Units.MolarEntropyUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.MolarFlow : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<MolarFlowUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<MolarFlowUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static MolarFlowUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static MolarFlowUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static MolarFlow <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<MolarFlowUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static MolarFlowUnit BaseUnit { get; }
    public static MolarFlowUnit[] Units { get; }
    public static MolarFlow Zero { get; }
    public static MolarFlow AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public MolarFlowUnit Unit { get; }
    public QuantityInfo`1<MolarFlowUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double KilomolesPerHour { get; }
    public double KilomolesPerMinute { get; }
    public double KilomolesPerSecond { get; }
    public double MolesPerHour { get; }
    public double MolesPerMinute { get; }
    public double MolesPerSecond { get; }
    public double PoundMolesPerHour { get; }
    public double PoundMolesPerMinute { get; }
    public double PoundMolesPerSecond { get; }
    private static MolarFlow();
    public MolarFlow(double value, MolarFlowUnit unit);
    public MolarFlow(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<MolarFlowUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static MolarFlowUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static MolarFlowUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override MolarFlow get_Zero();
    public static override MolarFlow get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual MolarFlowUnit get_Unit();
    public sealed virtual QuantityInfo`1<MolarFlowUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_KilomolesPerHour();
    public double get_KilomolesPerMinute();
    public double get_KilomolesPerSecond();
    public double get_MolesPerHour();
    public double get_MolesPerMinute();
    public double get_MolesPerSecond();
    public double get_PoundMolesPerHour();
    public double get_PoundMolesPerMinute();
    public double get_PoundMolesPerSecond();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(MolarFlowUnit unit);
    public static string GetAbbreviation(MolarFlowUnit unit, IFormatProvider provider);
    public static MolarFlow FromKilomolesPerHour(double value);
    public static MolarFlow FromKilomolesPerMinute(double value);
    public static MolarFlow FromKilomolesPerSecond(double value);
    public static MolarFlow FromMolesPerHour(double value);
    public static MolarFlow FromMolesPerMinute(double value);
    public static MolarFlow FromMolesPerSecond(double value);
    public static MolarFlow FromPoundMolesPerHour(double value);
    public static MolarFlow FromPoundMolesPerMinute(double value);
    public static MolarFlow FromPoundMolesPerSecond(double value);
    public static MolarFlow From(double value, MolarFlowUnit fromUnit);
    public static MolarFlow Parse(string str);
    public static override MolarFlow Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, MolarFlow& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, MolarFlow& result);
    public static MolarFlowUnit ParseUnit(string str);
    public static MolarFlowUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, MolarFlowUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, MolarFlowUnit& unit);
    public static override MolarFlow op_UnaryNegation(MolarFlow right);
    public static override MolarFlow op_Addition(MolarFlow left, MolarFlow right);
    public static override MolarFlow op_Subtraction(MolarFlow left, MolarFlow right);
    public static MolarFlow op_Multiply(double left, MolarFlow right);
    public static override MolarFlow op_Multiply(MolarFlow left, double right);
    public static override MolarFlow op_Division(MolarFlow left, double right);
    public static double op_Division(MolarFlow left, MolarFlow right);
    public static override AmountOfSubstance op_Multiply(MolarFlow molarFlow, Duration duration);
    public static override MassFlow op_Multiply(MolarFlow molarFlow, MolarMass molarMass);
    public static override Molarity op_Division(MolarFlow molarFlow, VolumeFlow volumeFlow);
    public static override VolumeFlow op_Division(MolarFlow molarFlow, Molarity molarity);
    public static override bool op_LessThanOrEqual(MolarFlow left, MolarFlow right);
    public static override bool op_GreaterThanOrEqual(MolarFlow left, MolarFlow right);
    public static override bool op_LessThan(MolarFlow left, MolarFlow right);
    public static override bool op_GreaterThan(MolarFlow left, MolarFlow right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MolarFlow other, MolarFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(MolarFlow left, MolarFlow right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MolarFlow other, MolarFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(MolarFlow left, MolarFlow right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(MolarFlow other, MolarFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(MolarFlow other, MolarFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(MolarFlow other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(MolarFlow other);
    [ObsoleteAttribute("Use Equals(MolarFlow other, MolarFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(MolarFlow other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(MolarFlow other, MolarFlow tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(MolarFlowUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public MolarFlow ToUnit(MolarFlowUnit unit);
    public MolarFlow ToUnit(MolarFlowUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(MolarFlowUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public MolarFlow ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<MolarFlowUnit> UnitsNet.IQuantity<UnitsNet.Units.MolarFlowUnit>.ToUnit(MolarFlowUnit unit);
    private sealed virtual override IQuantity`1<MolarFlowUnit> UnitsNet.IQuantity<UnitsNet.Units.MolarFlowUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Molarity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<MolarityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<MolarityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static MolarityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static MolarityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Molarity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<MolarityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static MolarityUnit BaseUnit { get; }
    public static MolarityUnit[] Units { get; }
    public static Molarity Zero { get; }
    public static Molarity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public MolarityUnit Unit { get; }
    public QuantityInfo`1<MolarityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentimolesPerLiter { get; }
    public double DecimolesPerLiter { get; }
    public double FemtomolesPerLiter { get; }
    public double KilomolesPerCubicMeter { get; }
    public double MicromolesPerLiter { get; }
    public double MillimolesPerLiter { get; }
    public double MolesPerCubicMeter { get; }
    public double MolesPerLiter { get; }
    public double NanomolesPerLiter { get; }
    public double PicomolesPerLiter { get; }
    public double PoundMolesPerCubicFoot { get; }
    private static Molarity();
    public Molarity(double value, MolarityUnit unit);
    public Molarity(double value, UnitSystem unitSystem);
    public MassConcentration ToMassConcentration(MolarMass molecularWeight);
    public VolumeConcentration ToVolumeConcentration(Density componentDensity, MolarMass componentMass);
    public static Molarity FromVolumeConcentration(VolumeConcentration volumeConcentration, Density componentDensity, MolarMass componentMass);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<MolarityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static MolarityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static MolarityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Molarity get_Zero();
    public static override Molarity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual MolarityUnit get_Unit();
    public sealed virtual QuantityInfo`1<MolarityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentimolesPerLiter();
    public double get_DecimolesPerLiter();
    public double get_FemtomolesPerLiter();
    public double get_KilomolesPerCubicMeter();
    public double get_MicromolesPerLiter();
    public double get_MillimolesPerLiter();
    public double get_MolesPerCubicMeter();
    public double get_MolesPerLiter();
    public double get_NanomolesPerLiter();
    public double get_PicomolesPerLiter();
    public double get_PoundMolesPerCubicFoot();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(MolarityUnit unit);
    public static string GetAbbreviation(MolarityUnit unit, IFormatProvider provider);
    public static Molarity FromCentimolesPerLiter(double value);
    public static Molarity FromDecimolesPerLiter(double value);
    public static Molarity FromFemtomolesPerLiter(double value);
    public static Molarity FromKilomolesPerCubicMeter(double value);
    public static Molarity FromMicromolesPerLiter(double value);
    public static Molarity FromMillimolesPerLiter(double value);
    public static Molarity FromMolesPerCubicMeter(double value);
    public static Molarity FromMolesPerLiter(double value);
    public static Molarity FromNanomolesPerLiter(double value);
    public static Molarity FromPicomolesPerLiter(double value);
    public static Molarity FromPoundMolesPerCubicFoot(double value);
    public static Molarity From(double value, MolarityUnit fromUnit);
    public static Molarity Parse(string str);
    public static override Molarity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Molarity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Molarity& result);
    public static MolarityUnit ParseUnit(string str);
    public static MolarityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, MolarityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, MolarityUnit& unit);
    public static override Molarity op_UnaryNegation(Molarity right);
    public static override Molarity op_Addition(Molarity left, Molarity right);
    public static override Molarity op_Subtraction(Molarity left, Molarity right);
    public static Molarity op_Multiply(double left, Molarity right);
    public static override Molarity op_Multiply(Molarity left, double right);
    public static override Molarity op_Division(Molarity left, double right);
    public static double op_Division(Molarity left, Molarity right);
    public static override AmountOfSubstance op_Multiply(Molarity molarity, Volume volume);
    public static override MassConcentration op_Multiply(Molarity molarity, MolarMass molarMass);
    public static override MolarFlow op_Multiply(Molarity molarity, VolumeFlow volumeFlow);
    public static override Molarity op_Multiply(Molarity molarity, VolumeConcentration volumeConcentration);
    public static override Molarity op_Division(Molarity molarity, VolumeConcentration volumeConcentration);
    public static override bool op_LessThanOrEqual(Molarity left, Molarity right);
    public static override bool op_GreaterThanOrEqual(Molarity left, Molarity right);
    public static override bool op_LessThan(Molarity left, Molarity right);
    public static override bool op_GreaterThan(Molarity left, Molarity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Molarity other, Molarity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Molarity left, Molarity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Molarity other, Molarity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Molarity left, Molarity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Molarity other, Molarity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Molarity other, Molarity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Molarity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Molarity other);
    [ObsoleteAttribute("Use Equals(Molarity other, Molarity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Molarity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Molarity other, Molarity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(MolarityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Molarity ToUnit(MolarityUnit unit);
    public Molarity ToUnit(MolarityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(MolarityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Molarity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<MolarityUnit> UnitsNet.IQuantity<UnitsNet.Units.MolarityUnit>.ToUnit(MolarityUnit unit);
    private sealed virtual override IQuantity`1<MolarityUnit> UnitsNet.IQuantity<UnitsNet.Units.MolarityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.MolarMass : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<MolarMassUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<MolarMassUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static MolarMassUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static MolarMassUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static MolarMass <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<MolarMassUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static MolarMassUnit BaseUnit { get; }
    public static MolarMassUnit[] Units { get; }
    public static MolarMass Zero { get; }
    public static MolarMass AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public MolarMassUnit Unit { get; }
    public QuantityInfo`1<MolarMassUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentigramsPerMole { get; }
    public double DecagramsPerMole { get; }
    public double DecigramsPerMole { get; }
    public double GramsPerMole { get; }
    public double HectogramsPerMole { get; }
    public double KilogramsPerKilomole { get; }
    public double KilogramsPerMole { get; }
    public double KilopoundsPerMole { get; }
    public double MegapoundsPerMole { get; }
    public double MicrogramsPerMole { get; }
    public double MilligramsPerMole { get; }
    public double NanogramsPerMole { get; }
    public double PoundsPerMole { get; }
    private static MolarMass();
    public MolarMass(double value, MolarMassUnit unit);
    public MolarMass(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<MolarMassUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static MolarMassUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static MolarMassUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override MolarMass get_Zero();
    public static override MolarMass get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual MolarMassUnit get_Unit();
    public sealed virtual QuantityInfo`1<MolarMassUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentigramsPerMole();
    public double get_DecagramsPerMole();
    public double get_DecigramsPerMole();
    public double get_GramsPerMole();
    public double get_HectogramsPerMole();
    public double get_KilogramsPerKilomole();
    public double get_KilogramsPerMole();
    public double get_KilopoundsPerMole();
    public double get_MegapoundsPerMole();
    public double get_MicrogramsPerMole();
    public double get_MilligramsPerMole();
    public double get_NanogramsPerMole();
    public double get_PoundsPerMole();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(MolarMassUnit unit);
    public static string GetAbbreviation(MolarMassUnit unit, IFormatProvider provider);
    public static MolarMass FromCentigramsPerMole(double value);
    public static MolarMass FromDecagramsPerMole(double value);
    public static MolarMass FromDecigramsPerMole(double value);
    public static MolarMass FromGramsPerMole(double value);
    public static MolarMass FromHectogramsPerMole(double value);
    public static MolarMass FromKilogramsPerKilomole(double value);
    public static MolarMass FromKilogramsPerMole(double value);
    public static MolarMass FromKilopoundsPerMole(double value);
    public static MolarMass FromMegapoundsPerMole(double value);
    public static MolarMass FromMicrogramsPerMole(double value);
    public static MolarMass FromMilligramsPerMole(double value);
    public static MolarMass FromNanogramsPerMole(double value);
    public static MolarMass FromPoundsPerMole(double value);
    public static MolarMass From(double value, MolarMassUnit fromUnit);
    public static MolarMass Parse(string str);
    public static override MolarMass Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, MolarMass& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, MolarMass& result);
    public static MolarMassUnit ParseUnit(string str);
    public static MolarMassUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, MolarMassUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, MolarMassUnit& unit);
    public static override MolarMass op_UnaryNegation(MolarMass right);
    public static override MolarMass op_Addition(MolarMass left, MolarMass right);
    public static override MolarMass op_Subtraction(MolarMass left, MolarMass right);
    public static MolarMass op_Multiply(double left, MolarMass right);
    public static override MolarMass op_Multiply(MolarMass left, double right);
    public static override MolarMass op_Division(MolarMass left, double right);
    public static double op_Division(MolarMass left, MolarMass right);
    public static override Mass op_Multiply(MolarMass molarMass, AmountOfSubstance amountOfSubstance);
    public static override MassConcentration op_Multiply(MolarMass molarMass, Molarity molarity);
    public static override MassFlow op_Multiply(MolarMass molarMass, MolarFlow molarFlow);
    public static override bool op_LessThanOrEqual(MolarMass left, MolarMass right);
    public static override bool op_GreaterThanOrEqual(MolarMass left, MolarMass right);
    public static override bool op_LessThan(MolarMass left, MolarMass right);
    public static override bool op_GreaterThan(MolarMass left, MolarMass right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MolarMass other, MolarMass tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(MolarMass left, MolarMass right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(MolarMass other, MolarMass tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(MolarMass left, MolarMass right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(MolarMass other, MolarMass tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(MolarMass other, MolarMass tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(MolarMass other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(MolarMass other);
    [ObsoleteAttribute("Use Equals(MolarMass other, MolarMass tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(MolarMass other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(MolarMass other, MolarMass tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(MolarMassUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public MolarMass ToUnit(MolarMassUnit unit);
    public MolarMass ToUnit(MolarMassUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(MolarMassUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public MolarMass ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<MolarMassUnit> UnitsNet.IQuantity<UnitsNet.Units.MolarMassUnit>.ToUnit(MolarMassUnit unit);
    private sealed virtual override IQuantity`1<MolarMassUnit> UnitsNet.IQuantity<UnitsNet.Units.MolarMassUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Permeability : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<PermeabilityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<PermeabilityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static PermeabilityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static PermeabilityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Permeability <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<PermeabilityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static PermeabilityUnit BaseUnit { get; }
    public static PermeabilityUnit[] Units { get; }
    public static Permeability Zero { get; }
    public static Permeability AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public PermeabilityUnit Unit { get; }
    public QuantityInfo`1<PermeabilityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double HenriesPerMeter { get; }
    private static Permeability();
    public Permeability(double value, PermeabilityUnit unit);
    public Permeability(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<PermeabilityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static PermeabilityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static PermeabilityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Permeability get_Zero();
    public static override Permeability get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual PermeabilityUnit get_Unit();
    public sealed virtual QuantityInfo`1<PermeabilityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_HenriesPerMeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(PermeabilityUnit unit);
    public static string GetAbbreviation(PermeabilityUnit unit, IFormatProvider provider);
    public static Permeability FromHenriesPerMeter(double value);
    public static Permeability From(double value, PermeabilityUnit fromUnit);
    public static Permeability Parse(string str);
    public static override Permeability Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Permeability& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Permeability& result);
    public static PermeabilityUnit ParseUnit(string str);
    public static PermeabilityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, PermeabilityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, PermeabilityUnit& unit);
    public static override Permeability op_UnaryNegation(Permeability right);
    public static override Permeability op_Addition(Permeability left, Permeability right);
    public static override Permeability op_Subtraction(Permeability left, Permeability right);
    public static Permeability op_Multiply(double left, Permeability right);
    public static override Permeability op_Multiply(Permeability left, double right);
    public static override Permeability op_Division(Permeability left, double right);
    public static double op_Division(Permeability left, Permeability right);
    public static override bool op_LessThanOrEqual(Permeability left, Permeability right);
    public static override bool op_GreaterThanOrEqual(Permeability left, Permeability right);
    public static override bool op_LessThan(Permeability left, Permeability right);
    public static override bool op_GreaterThan(Permeability left, Permeability right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Permeability other, Permeability tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Permeability left, Permeability right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Permeability other, Permeability tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Permeability left, Permeability right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Permeability other, Permeability tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Permeability other, Permeability tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Permeability other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Permeability other);
    [ObsoleteAttribute("Use Equals(Permeability other, Permeability tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Permeability other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Permeability other, Permeability tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(PermeabilityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Permeability ToUnit(PermeabilityUnit unit);
    public Permeability ToUnit(PermeabilityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(PermeabilityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Permeability ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<PermeabilityUnit> UnitsNet.IQuantity<UnitsNet.Units.PermeabilityUnit>.ToUnit(PermeabilityUnit unit);
    private sealed virtual override IQuantity`1<PermeabilityUnit> UnitsNet.IQuantity<UnitsNet.Units.PermeabilityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Permittivity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<PermittivityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<PermittivityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static PermittivityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static PermittivityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Permittivity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<PermittivityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static PermittivityUnit BaseUnit { get; }
    public static PermittivityUnit[] Units { get; }
    public static Permittivity Zero { get; }
    public static Permittivity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public PermittivityUnit Unit { get; }
    public QuantityInfo`1<PermittivityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double FaradsPerMeter { get; }
    private static Permittivity();
    public Permittivity(double value, PermittivityUnit unit);
    public Permittivity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<PermittivityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static PermittivityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static PermittivityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Permittivity get_Zero();
    public static override Permittivity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual PermittivityUnit get_Unit();
    public sealed virtual QuantityInfo`1<PermittivityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_FaradsPerMeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(PermittivityUnit unit);
    public static string GetAbbreviation(PermittivityUnit unit, IFormatProvider provider);
    public static Permittivity FromFaradsPerMeter(double value);
    public static Permittivity From(double value, PermittivityUnit fromUnit);
    public static Permittivity Parse(string str);
    public static override Permittivity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Permittivity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Permittivity& result);
    public static PermittivityUnit ParseUnit(string str);
    public static PermittivityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, PermittivityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, PermittivityUnit& unit);
    public static override Permittivity op_UnaryNegation(Permittivity right);
    public static override Permittivity op_Addition(Permittivity left, Permittivity right);
    public static override Permittivity op_Subtraction(Permittivity left, Permittivity right);
    public static Permittivity op_Multiply(double left, Permittivity right);
    public static override Permittivity op_Multiply(Permittivity left, double right);
    public static override Permittivity op_Division(Permittivity left, double right);
    public static double op_Division(Permittivity left, Permittivity right);
    public static override bool op_LessThanOrEqual(Permittivity left, Permittivity right);
    public static override bool op_GreaterThanOrEqual(Permittivity left, Permittivity right);
    public static override bool op_LessThan(Permittivity left, Permittivity right);
    public static override bool op_GreaterThan(Permittivity left, Permittivity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Permittivity other, Permittivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Permittivity left, Permittivity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Permittivity other, Permittivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Permittivity left, Permittivity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Permittivity other, Permittivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Permittivity other, Permittivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Permittivity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Permittivity other);
    [ObsoleteAttribute("Use Equals(Permittivity other, Permittivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Permittivity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Permittivity other, Permittivity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(PermittivityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Permittivity ToUnit(PermittivityUnit unit);
    public Permittivity ToUnit(PermittivityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(PermittivityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Permittivity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<PermittivityUnit> UnitsNet.IQuantity<UnitsNet.Units.PermittivityUnit>.ToUnit(PermittivityUnit unit);
    private sealed virtual override IQuantity`1<PermittivityUnit> UnitsNet.IQuantity<UnitsNet.Units.PermittivityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.PorousMediumPermeability : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<PorousMediumPermeabilityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<PorousMediumPermeabilityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static PorousMediumPermeabilityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static PorousMediumPermeabilityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static PorousMediumPermeability <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<PorousMediumPermeabilityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static PorousMediumPermeabilityUnit BaseUnit { get; }
    public static PorousMediumPermeabilityUnit[] Units { get; }
    public static PorousMediumPermeability Zero { get; }
    public static PorousMediumPermeability AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public PorousMediumPermeabilityUnit Unit { get; }
    public QuantityInfo`1<PorousMediumPermeabilityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Darcys { get; }
    public double Microdarcys { get; }
    public double Millidarcys { get; }
    public double SquareCentimeters { get; }
    public double SquareMeters { get; }
    private static PorousMediumPermeability();
    public PorousMediumPermeability(double value, PorousMediumPermeabilityUnit unit);
    public PorousMediumPermeability(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<PorousMediumPermeabilityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static PorousMediumPermeabilityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static PorousMediumPermeabilityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override PorousMediumPermeability get_Zero();
    public static override PorousMediumPermeability get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual PorousMediumPermeabilityUnit get_Unit();
    public sealed virtual QuantityInfo`1<PorousMediumPermeabilityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Darcys();
    public double get_Microdarcys();
    public double get_Millidarcys();
    public double get_SquareCentimeters();
    public double get_SquareMeters();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(PorousMediumPermeabilityUnit unit);
    public static string GetAbbreviation(PorousMediumPermeabilityUnit unit, IFormatProvider provider);
    public static PorousMediumPermeability FromDarcys(double value);
    public static PorousMediumPermeability FromMicrodarcys(double value);
    public static PorousMediumPermeability FromMillidarcys(double value);
    public static PorousMediumPermeability FromSquareCentimeters(double value);
    public static PorousMediumPermeability FromSquareMeters(double value);
    public static PorousMediumPermeability From(double value, PorousMediumPermeabilityUnit fromUnit);
    public static PorousMediumPermeability Parse(string str);
    public static override PorousMediumPermeability Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, PorousMediumPermeability& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, PorousMediumPermeability& result);
    public static PorousMediumPermeabilityUnit ParseUnit(string str);
    public static PorousMediumPermeabilityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, PorousMediumPermeabilityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, PorousMediumPermeabilityUnit& unit);
    public static override PorousMediumPermeability op_UnaryNegation(PorousMediumPermeability right);
    public static override PorousMediumPermeability op_Addition(PorousMediumPermeability left, PorousMediumPermeability right);
    public static override PorousMediumPermeability op_Subtraction(PorousMediumPermeability left, PorousMediumPermeability right);
    public static PorousMediumPermeability op_Multiply(double left, PorousMediumPermeability right);
    public static override PorousMediumPermeability op_Multiply(PorousMediumPermeability left, double right);
    public static override PorousMediumPermeability op_Division(PorousMediumPermeability left, double right);
    public static double op_Division(PorousMediumPermeability left, PorousMediumPermeability right);
    public static override bool op_LessThanOrEqual(PorousMediumPermeability left, PorousMediumPermeability right);
    public static override bool op_GreaterThanOrEqual(PorousMediumPermeability left, PorousMediumPermeability right);
    public static override bool op_LessThan(PorousMediumPermeability left, PorousMediumPermeability right);
    public static override bool op_GreaterThan(PorousMediumPermeability left, PorousMediumPermeability right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(PorousMediumPermeability other, PorousMediumPermeability tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(PorousMediumPermeability left, PorousMediumPermeability right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(PorousMediumPermeability other, PorousMediumPermeability tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(PorousMediumPermeability left, PorousMediumPermeability right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(PorousMediumPermeability other, PorousMediumPermeability tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(PorousMediumPermeability other, PorousMediumPermeability tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(PorousMediumPermeability other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(PorousMediumPermeability other);
    [ObsoleteAttribute("Use Equals(PorousMediumPermeability other, PorousMediumPermeability tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(PorousMediumPermeability other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(PorousMediumPermeability other, PorousMediumPermeability tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(PorousMediumPermeabilityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public PorousMediumPermeability ToUnit(PorousMediumPermeabilityUnit unit);
    public PorousMediumPermeability ToUnit(PorousMediumPermeabilityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(PorousMediumPermeabilityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public PorousMediumPermeability ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<PorousMediumPermeabilityUnit> UnitsNet.IQuantity<UnitsNet.Units.PorousMediumPermeabilityUnit>.ToUnit(PorousMediumPermeabilityUnit unit);
    private sealed virtual override IQuantity`1<PorousMediumPermeabilityUnit> UnitsNet.IQuantity<UnitsNet.Units.PorousMediumPermeabilityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Power : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<PowerUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<PowerUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static PowerUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static PowerUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Power <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<PowerUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static PowerUnit BaseUnit { get; }
    public static PowerUnit[] Units { get; }
    public static Power Zero { get; }
    public static Power AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public PowerUnit Unit { get; }
    public QuantityInfo`1<PowerUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double BoilerHorsepower { get; }
    public double BritishThermalUnitsPerHour { get; }
    public double Decawatts { get; }
    public double Deciwatts { get; }
    public double ElectricalHorsepower { get; }
    public double Femtowatts { get; }
    public double GigajoulesPerHour { get; }
    public double Gigawatts { get; }
    public double HydraulicHorsepower { get; }
    public double JoulesPerHour { get; }
    public double KilobritishThermalUnitsPerHour { get; }
    public double KilojoulesPerHour { get; }
    public double Kilowatts { get; }
    public double MechanicalHorsepower { get; }
    public double MegabritishThermalUnitsPerHour { get; }
    public double MegajoulesPerHour { get; }
    public double Megawatts { get; }
    public double MetricHorsepower { get; }
    public double Microwatts { get; }
    public double MillijoulesPerHour { get; }
    public double Milliwatts { get; }
    public double Nanowatts { get; }
    public double Petawatts { get; }
    public double Picowatts { get; }
    public double Terawatts { get; }
    public double TonsOfRefrigeration { get; }
    public double Watts { get; }
    private static Power();
    public Power(double value, PowerUnit unit);
    public Power(double value, UnitSystem unitSystem);
    public PowerRatio ToPowerRatio();
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<PowerUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static PowerUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static PowerUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Power get_Zero();
    public static override Power get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual PowerUnit get_Unit();
    public sealed virtual QuantityInfo`1<PowerUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_BoilerHorsepower();
    public double get_BritishThermalUnitsPerHour();
    public double get_Decawatts();
    public double get_Deciwatts();
    public double get_ElectricalHorsepower();
    public double get_Femtowatts();
    public double get_GigajoulesPerHour();
    public double get_Gigawatts();
    public double get_HydraulicHorsepower();
    public double get_JoulesPerHour();
    public double get_KilobritishThermalUnitsPerHour();
    public double get_KilojoulesPerHour();
    public double get_Kilowatts();
    public double get_MechanicalHorsepower();
    public double get_MegabritishThermalUnitsPerHour();
    public double get_MegajoulesPerHour();
    public double get_Megawatts();
    public double get_MetricHorsepower();
    public double get_Microwatts();
    public double get_MillijoulesPerHour();
    public double get_Milliwatts();
    public double get_Nanowatts();
    public double get_Petawatts();
    public double get_Picowatts();
    public double get_Terawatts();
    public double get_TonsOfRefrigeration();
    public double get_Watts();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(PowerUnit unit);
    public static string GetAbbreviation(PowerUnit unit, IFormatProvider provider);
    public static Power FromBoilerHorsepower(double value);
    public static Power FromBritishThermalUnitsPerHour(double value);
    public static Power FromDecawatts(double value);
    public static Power FromDeciwatts(double value);
    public static Power FromElectricalHorsepower(double value);
    public static Power FromFemtowatts(double value);
    public static Power FromGigajoulesPerHour(double value);
    public static Power FromGigawatts(double value);
    public static Power FromHydraulicHorsepower(double value);
    public static Power FromJoulesPerHour(double value);
    public static Power FromKilobritishThermalUnitsPerHour(double value);
    public static Power FromKilojoulesPerHour(double value);
    public static Power FromKilowatts(double value);
    public static Power FromMechanicalHorsepower(double value);
    public static Power FromMegabritishThermalUnitsPerHour(double value);
    public static Power FromMegajoulesPerHour(double value);
    public static Power FromMegawatts(double value);
    public static Power FromMetricHorsepower(double value);
    public static Power FromMicrowatts(double value);
    public static Power FromMillijoulesPerHour(double value);
    public static Power FromMilliwatts(double value);
    public static Power FromNanowatts(double value);
    public static Power FromPetawatts(double value);
    public static Power FromPicowatts(double value);
    public static Power FromTerawatts(double value);
    public static Power FromTonsOfRefrigeration(double value);
    public static Power FromWatts(double value);
    public static Power From(double value, PowerUnit fromUnit);
    public static Power Parse(string str);
    public static override Power Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Power& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Power& result);
    public static PowerUnit ParseUnit(string str);
    public static PowerUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, PowerUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, PowerUnit& unit);
    public static override Power op_UnaryNegation(Power right);
    public static override Power op_Addition(Power left, Power right);
    public static override Power op_Subtraction(Power left, Power right);
    public static Power op_Multiply(double left, Power right);
    public static override Power op_Multiply(Power left, double right);
    public static override Power op_Division(Power left, double right);
    public static double op_Division(Power left, Power right);
    public static override Area op_Division(Power power, HeatFlux heatFlux);
    public static override ElectricCurrent op_Division(Power power, ElectricPotential electricPotential);
    public static override ElectricPotential op_Division(Power power, ElectricCurrent electricCurrent);
    public static override Energy op_Multiply(Power power, Duration duration);
    public static override Energy op_Division(Power power, Frequency frequency);
    public static override Force op_Division(Power power, Speed speed);
    public static override Frequency op_Division(Power power, Energy energy);
    public static override HeatFlux op_Division(Power power, Area area);
    public static override MassFlow op_Multiply(Power power, BrakeSpecificFuelConsumption brakeSpecificFuelConsumption);
    public static override MassFlow op_Division(Power power, SpecificEnergy specificEnergy);
    public static override RotationalSpeed op_Division(Power power, Torque torque);
    public static override SpecificEnergy op_Division(Power power, MassFlow massFlow);
    public static override Speed op_Division(Power power, Force force);
    public static override Torque op_Division(Power power, RotationalSpeed rotationalSpeed);
    public static override bool op_LessThanOrEqual(Power left, Power right);
    public static override bool op_GreaterThanOrEqual(Power left, Power right);
    public static override bool op_LessThan(Power left, Power right);
    public static override bool op_GreaterThan(Power left, Power right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Power other, Power tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Power left, Power right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Power other, Power tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Power left, Power right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Power other, Power tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Power other, Power tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Power other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Power other);
    [ObsoleteAttribute("Use Equals(Power other, Power tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Power other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Power other, Power tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(PowerUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Power ToUnit(PowerUnit unit);
    public Power ToUnit(PowerUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(PowerUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Power ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<PowerUnit> UnitsNet.IQuantity<UnitsNet.Units.PowerUnit>.ToUnit(PowerUnit unit);
    private sealed virtual override IQuantity`1<PowerUnit> UnitsNet.IQuantity<UnitsNet.Units.PowerUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.PowerDensity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<PowerDensityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<PowerDensityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static PowerDensityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static PowerDensityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static PowerDensity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<PowerDensityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static PowerDensityUnit BaseUnit { get; }
    public static PowerDensityUnit[] Units { get; }
    public static PowerDensity Zero { get; }
    public static PowerDensity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public PowerDensityUnit Unit { get; }
    public QuantityInfo`1<PowerDensityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double DecawattsPerCubicFoot { get; }
    public double DecawattsPerCubicInch { get; }
    public double DecawattsPerCubicMeter { get; }
    public double DecawattsPerLiter { get; }
    public double DeciwattsPerCubicFoot { get; }
    public double DeciwattsPerCubicInch { get; }
    public double DeciwattsPerCubicMeter { get; }
    public double DeciwattsPerLiter { get; }
    public double GigawattsPerCubicFoot { get; }
    public double GigawattsPerCubicInch { get; }
    public double GigawattsPerCubicMeter { get; }
    public double GigawattsPerLiter { get; }
    public double KilowattsPerCubicFoot { get; }
    public double KilowattsPerCubicInch { get; }
    public double KilowattsPerCubicMeter { get; }
    public double KilowattsPerLiter { get; }
    public double MegawattsPerCubicFoot { get; }
    public double MegawattsPerCubicInch { get; }
    public double MegawattsPerCubicMeter { get; }
    public double MegawattsPerLiter { get; }
    public double MicrowattsPerCubicFoot { get; }
    public double MicrowattsPerCubicInch { get; }
    public double MicrowattsPerCubicMeter { get; }
    public double MicrowattsPerLiter { get; }
    public double MilliwattsPerCubicFoot { get; }
    public double MilliwattsPerCubicInch { get; }
    public double MilliwattsPerCubicMeter { get; }
    public double MilliwattsPerLiter { get; }
    public double NanowattsPerCubicFoot { get; }
    public double NanowattsPerCubicInch { get; }
    public double NanowattsPerCubicMeter { get; }
    public double NanowattsPerLiter { get; }
    public double PicowattsPerCubicFoot { get; }
    public double PicowattsPerCubicInch { get; }
    public double PicowattsPerCubicMeter { get; }
    public double PicowattsPerLiter { get; }
    public double TerawattsPerCubicFoot { get; }
    public double TerawattsPerCubicInch { get; }
    public double TerawattsPerCubicMeter { get; }
    public double TerawattsPerLiter { get; }
    public double WattsPerCubicFoot { get; }
    public double WattsPerCubicInch { get; }
    public double WattsPerCubicMeter { get; }
    public double WattsPerLiter { get; }
    private static PowerDensity();
    public PowerDensity(double value, PowerDensityUnit unit);
    public PowerDensity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<PowerDensityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static PowerDensityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static PowerDensityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override PowerDensity get_Zero();
    public static override PowerDensity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual PowerDensityUnit get_Unit();
    public sealed virtual QuantityInfo`1<PowerDensityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_DecawattsPerCubicFoot();
    public double get_DecawattsPerCubicInch();
    public double get_DecawattsPerCubicMeter();
    public double get_DecawattsPerLiter();
    public double get_DeciwattsPerCubicFoot();
    public double get_DeciwattsPerCubicInch();
    public double get_DeciwattsPerCubicMeter();
    public double get_DeciwattsPerLiter();
    public double get_GigawattsPerCubicFoot();
    public double get_GigawattsPerCubicInch();
    public double get_GigawattsPerCubicMeter();
    public double get_GigawattsPerLiter();
    public double get_KilowattsPerCubicFoot();
    public double get_KilowattsPerCubicInch();
    public double get_KilowattsPerCubicMeter();
    public double get_KilowattsPerLiter();
    public double get_MegawattsPerCubicFoot();
    public double get_MegawattsPerCubicInch();
    public double get_MegawattsPerCubicMeter();
    public double get_MegawattsPerLiter();
    public double get_MicrowattsPerCubicFoot();
    public double get_MicrowattsPerCubicInch();
    public double get_MicrowattsPerCubicMeter();
    public double get_MicrowattsPerLiter();
    public double get_MilliwattsPerCubicFoot();
    public double get_MilliwattsPerCubicInch();
    public double get_MilliwattsPerCubicMeter();
    public double get_MilliwattsPerLiter();
    public double get_NanowattsPerCubicFoot();
    public double get_NanowattsPerCubicInch();
    public double get_NanowattsPerCubicMeter();
    public double get_NanowattsPerLiter();
    public double get_PicowattsPerCubicFoot();
    public double get_PicowattsPerCubicInch();
    public double get_PicowattsPerCubicMeter();
    public double get_PicowattsPerLiter();
    public double get_TerawattsPerCubicFoot();
    public double get_TerawattsPerCubicInch();
    public double get_TerawattsPerCubicMeter();
    public double get_TerawattsPerLiter();
    public double get_WattsPerCubicFoot();
    public double get_WattsPerCubicInch();
    public double get_WattsPerCubicMeter();
    public double get_WattsPerLiter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(PowerDensityUnit unit);
    public static string GetAbbreviation(PowerDensityUnit unit, IFormatProvider provider);
    public static PowerDensity FromDecawattsPerCubicFoot(double value);
    public static PowerDensity FromDecawattsPerCubicInch(double value);
    public static PowerDensity FromDecawattsPerCubicMeter(double value);
    public static PowerDensity FromDecawattsPerLiter(double value);
    public static PowerDensity FromDeciwattsPerCubicFoot(double value);
    public static PowerDensity FromDeciwattsPerCubicInch(double value);
    public static PowerDensity FromDeciwattsPerCubicMeter(double value);
    public static PowerDensity FromDeciwattsPerLiter(double value);
    public static PowerDensity FromGigawattsPerCubicFoot(double value);
    public static PowerDensity FromGigawattsPerCubicInch(double value);
    public static PowerDensity FromGigawattsPerCubicMeter(double value);
    public static PowerDensity FromGigawattsPerLiter(double value);
    public static PowerDensity FromKilowattsPerCubicFoot(double value);
    public static PowerDensity FromKilowattsPerCubicInch(double value);
    public static PowerDensity FromKilowattsPerCubicMeter(double value);
    public static PowerDensity FromKilowattsPerLiter(double value);
    public static PowerDensity FromMegawattsPerCubicFoot(double value);
    public static PowerDensity FromMegawattsPerCubicInch(double value);
    public static PowerDensity FromMegawattsPerCubicMeter(double value);
    public static PowerDensity FromMegawattsPerLiter(double value);
    public static PowerDensity FromMicrowattsPerCubicFoot(double value);
    public static PowerDensity FromMicrowattsPerCubicInch(double value);
    public static PowerDensity FromMicrowattsPerCubicMeter(double value);
    public static PowerDensity FromMicrowattsPerLiter(double value);
    public static PowerDensity FromMilliwattsPerCubicFoot(double value);
    public static PowerDensity FromMilliwattsPerCubicInch(double value);
    public static PowerDensity FromMilliwattsPerCubicMeter(double value);
    public static PowerDensity FromMilliwattsPerLiter(double value);
    public static PowerDensity FromNanowattsPerCubicFoot(double value);
    public static PowerDensity FromNanowattsPerCubicInch(double value);
    public static PowerDensity FromNanowattsPerCubicMeter(double value);
    public static PowerDensity FromNanowattsPerLiter(double value);
    public static PowerDensity FromPicowattsPerCubicFoot(double value);
    public static PowerDensity FromPicowattsPerCubicInch(double value);
    public static PowerDensity FromPicowattsPerCubicMeter(double value);
    public static PowerDensity FromPicowattsPerLiter(double value);
    public static PowerDensity FromTerawattsPerCubicFoot(double value);
    public static PowerDensity FromTerawattsPerCubicInch(double value);
    public static PowerDensity FromTerawattsPerCubicMeter(double value);
    public static PowerDensity FromTerawattsPerLiter(double value);
    public static PowerDensity FromWattsPerCubicFoot(double value);
    public static PowerDensity FromWattsPerCubicInch(double value);
    public static PowerDensity FromWattsPerCubicMeter(double value);
    public static PowerDensity FromWattsPerLiter(double value);
    public static PowerDensity From(double value, PowerDensityUnit fromUnit);
    public static PowerDensity Parse(string str);
    public static override PowerDensity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, PowerDensity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, PowerDensity& result);
    public static PowerDensityUnit ParseUnit(string str);
    public static PowerDensityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, PowerDensityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, PowerDensityUnit& unit);
    public static override PowerDensity op_UnaryNegation(PowerDensity right);
    public static override PowerDensity op_Addition(PowerDensity left, PowerDensity right);
    public static override PowerDensity op_Subtraction(PowerDensity left, PowerDensity right);
    public static PowerDensity op_Multiply(double left, PowerDensity right);
    public static override PowerDensity op_Multiply(PowerDensity left, double right);
    public static override PowerDensity op_Division(PowerDensity left, double right);
    public static double op_Division(PowerDensity left, PowerDensity right);
    public static override bool op_LessThanOrEqual(PowerDensity left, PowerDensity right);
    public static override bool op_GreaterThanOrEqual(PowerDensity left, PowerDensity right);
    public static override bool op_LessThan(PowerDensity left, PowerDensity right);
    public static override bool op_GreaterThan(PowerDensity left, PowerDensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(PowerDensity other, PowerDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(PowerDensity left, PowerDensity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(PowerDensity other, PowerDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(PowerDensity left, PowerDensity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(PowerDensity other, PowerDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(PowerDensity other, PowerDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(PowerDensity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(PowerDensity other);
    [ObsoleteAttribute("Use Equals(PowerDensity other, PowerDensity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(PowerDensity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(PowerDensity other, PowerDensity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(PowerDensityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public PowerDensity ToUnit(PowerDensityUnit unit);
    public PowerDensity ToUnit(PowerDensityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(PowerDensityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public PowerDensity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<PowerDensityUnit> UnitsNet.IQuantity<UnitsNet.Units.PowerDensityUnit>.ToUnit(PowerDensityUnit unit);
    private sealed virtual override IQuantity`1<PowerDensityUnit> UnitsNet.IQuantity<UnitsNet.Units.PowerDensityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.PowerRatio : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<PowerRatioUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<PowerRatioUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static PowerRatioUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static PowerRatioUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static PowerRatio <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<PowerRatioUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static PowerRatioUnit BaseUnit { get; }
    public static PowerRatioUnit[] Units { get; }
    public static PowerRatio Zero { get; }
    public static PowerRatio AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public PowerRatioUnit Unit { get; }
    public QuantityInfo`1<PowerRatioUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double DecibelMilliwatts { get; }
    public double DecibelWatts { get; }
    public PowerRatio(Power power);
    private static PowerRatio();
    public PowerRatio(double value, PowerRatioUnit unit);
    public PowerRatio(double value, UnitSystem unitSystem);
    public Power ToPower();
    public AmplitudeRatio ToAmplitudeRatio(ElectricResistance impedance);
    public static PowerRatio FromPower(Power power);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<PowerRatioUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static PowerRatioUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static PowerRatioUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override PowerRatio get_Zero();
    public static override PowerRatio get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual PowerRatioUnit get_Unit();
    public sealed virtual QuantityInfo`1<PowerRatioUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_DecibelMilliwatts();
    public double get_DecibelWatts();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(PowerRatioUnit unit);
    public static string GetAbbreviation(PowerRatioUnit unit, IFormatProvider provider);
    public static PowerRatio FromDecibelMilliwatts(double value);
    public static PowerRatio FromDecibelWatts(double value);
    public static PowerRatio From(double value, PowerRatioUnit fromUnit);
    public static PowerRatio Parse(string str);
    public static override PowerRatio Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, PowerRatio& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, PowerRatio& result);
    public static PowerRatioUnit ParseUnit(string str);
    public static PowerRatioUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, PowerRatioUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, PowerRatioUnit& unit);
    public static override PowerRatio op_UnaryNegation(PowerRatio right);
    public static override PowerRatio op_Addition(PowerRatio left, PowerRatio right);
    public static override PowerRatio op_Subtraction(PowerRatio left, PowerRatio right);
    public static PowerRatio op_Multiply(double left, PowerRatio right);
    public static override PowerRatio op_Multiply(PowerRatio left, double right);
    public static override PowerRatio op_Division(PowerRatio left, double right);
    public static double op_Division(PowerRatio left, PowerRatio right);
    public static override bool op_LessThanOrEqual(PowerRatio left, PowerRatio right);
    public static override bool op_GreaterThanOrEqual(PowerRatio left, PowerRatio right);
    public static override bool op_LessThan(PowerRatio left, PowerRatio right);
    public static override bool op_GreaterThan(PowerRatio left, PowerRatio right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(PowerRatio other, PowerRatio tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(PowerRatio left, PowerRatio right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(PowerRatio other, PowerRatio tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(PowerRatio left, PowerRatio right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(PowerRatio other, PowerRatio tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(PowerRatio other, PowerRatio tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(PowerRatio other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(PowerRatio other);
    [ObsoleteAttribute("Use Equals(PowerRatio other, PowerRatio tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(PowerRatio other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(PowerRatio other, PowerRatio tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(PowerRatioUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public PowerRatio ToUnit(PowerRatioUnit unit);
    public PowerRatio ToUnit(PowerRatioUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(PowerRatioUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public PowerRatio ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<PowerRatioUnit> UnitsNet.IQuantity<UnitsNet.Units.PowerRatioUnit>.ToUnit(PowerRatioUnit unit);
    private sealed virtual override IQuantity`1<PowerRatioUnit> UnitsNet.IQuantity<UnitsNet.Units.PowerRatioUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Pressure : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<PressureUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<PressureUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static PressureUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static PressureUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Pressure <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<PressureUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static PressureUnit BaseUnit { get; }
    public static PressureUnit[] Units { get; }
    public static Pressure Zero { get; }
    public static Pressure AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public PressureUnit Unit { get; }
    public QuantityInfo`1<PressureUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Atmospheres { get; }
    public double Bars { get; }
    public double Centibars { get; }
    public double CentimetersOfWaterColumn { get; }
    public double Decapascals { get; }
    public double Decibars { get; }
    public double DynesPerSquareCentimeter { get; }
    public double FeetOfElevation { get; }
    public double FeetOfHead { get; }
    public double Gigapascals { get; }
    public double Hectopascals { get; }
    public double InchesOfMercury { get; }
    public double InchesOfWaterColumn { get; }
    public double Kilobars { get; }
    public double KilogramsForcePerSquareCentimeter { get; }
    public double KilogramsForcePerSquareMeter { get; }
    public double KilogramsForcePerSquareMillimeter { get; }
    public double KilonewtonsPerSquareCentimeter { get; }
    public double KilonewtonsPerSquareMeter { get; }
    public double KilonewtonsPerSquareMillimeter { get; }
    public double Kilopascals { get; }
    public double KilopoundsForcePerSquareFoot { get; }
    public double KilopoundsForcePerSquareInch { get; }
    public double KilopoundsForcePerSquareMil { get; }
    public double Megabars { get; }
    public double MeganewtonsPerSquareMeter { get; }
    public double Megapascals { get; }
    public double MetersOfElevation { get; }
    public double MetersOfHead { get; }
    public double MetersOfWaterColumn { get; }
    public double Microbars { get; }
    public double Micropascals { get; }
    public double Millibars { get; }
    public double MillimetersOfMercury { get; }
    public double MillimetersOfWaterColumn { get; }
    public double Millipascals { get; }
    public double NewtonsPerSquareCentimeter { get; }
    public double NewtonsPerSquareMeter { get; }
    public double NewtonsPerSquareMillimeter { get; }
    public double Pascals { get; }
    public double PoundsForcePerSquareFoot { get; }
    public double PoundsForcePerSquareInch { get; }
    public double PoundsForcePerSquareMil { get; }
    public double PoundsPerInchSecondSquared { get; }
    public double TechnicalAtmospheres { get; }
    public double TonnesForcePerSquareCentimeter { get; }
    public double TonnesForcePerSquareMeter { get; }
    public double TonnesForcePerSquareMillimeter { get; }
    public double Torrs { get; }
    private static Pressure();
    public Pressure(double value, PressureUnit unit);
    public Pressure(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<PressureUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static PressureUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static PressureUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Pressure get_Zero();
    public static override Pressure get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual PressureUnit get_Unit();
    public sealed virtual QuantityInfo`1<PressureUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Atmospheres();
    public double get_Bars();
    public double get_Centibars();
    public double get_CentimetersOfWaterColumn();
    public double get_Decapascals();
    public double get_Decibars();
    public double get_DynesPerSquareCentimeter();
    public double get_FeetOfElevation();
    public double get_FeetOfHead();
    public double get_Gigapascals();
    public double get_Hectopascals();
    public double get_InchesOfMercury();
    public double get_InchesOfWaterColumn();
    public double get_Kilobars();
    public double get_KilogramsForcePerSquareCentimeter();
    public double get_KilogramsForcePerSquareMeter();
    public double get_KilogramsForcePerSquareMillimeter();
    public double get_KilonewtonsPerSquareCentimeter();
    public double get_KilonewtonsPerSquareMeter();
    public double get_KilonewtonsPerSquareMillimeter();
    public double get_Kilopascals();
    public double get_KilopoundsForcePerSquareFoot();
    public double get_KilopoundsForcePerSquareInch();
    public double get_KilopoundsForcePerSquareMil();
    public double get_Megabars();
    public double get_MeganewtonsPerSquareMeter();
    public double get_Megapascals();
    public double get_MetersOfElevation();
    public double get_MetersOfHead();
    public double get_MetersOfWaterColumn();
    public double get_Microbars();
    public double get_Micropascals();
    public double get_Millibars();
    public double get_MillimetersOfMercury();
    public double get_MillimetersOfWaterColumn();
    public double get_Millipascals();
    public double get_NewtonsPerSquareCentimeter();
    public double get_NewtonsPerSquareMeter();
    public double get_NewtonsPerSquareMillimeter();
    public double get_Pascals();
    public double get_PoundsForcePerSquareFoot();
    public double get_PoundsForcePerSquareInch();
    public double get_PoundsForcePerSquareMil();
    public double get_PoundsPerInchSecondSquared();
    public double get_TechnicalAtmospheres();
    public double get_TonnesForcePerSquareCentimeter();
    public double get_TonnesForcePerSquareMeter();
    public double get_TonnesForcePerSquareMillimeter();
    public double get_Torrs();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(PressureUnit unit);
    public static string GetAbbreviation(PressureUnit unit, IFormatProvider provider);
    public static Pressure FromAtmospheres(double value);
    public static Pressure FromBars(double value);
    public static Pressure FromCentibars(double value);
    public static Pressure FromCentimetersOfWaterColumn(double value);
    public static Pressure FromDecapascals(double value);
    public static Pressure FromDecibars(double value);
    public static Pressure FromDynesPerSquareCentimeter(double value);
    public static Pressure FromFeetOfElevation(double value);
    public static Pressure FromFeetOfHead(double value);
    public static Pressure FromGigapascals(double value);
    public static Pressure FromHectopascals(double value);
    public static Pressure FromInchesOfMercury(double value);
    public static Pressure FromInchesOfWaterColumn(double value);
    public static Pressure FromKilobars(double value);
    public static Pressure FromKilogramsForcePerSquareCentimeter(double value);
    public static Pressure FromKilogramsForcePerSquareMeter(double value);
    public static Pressure FromKilogramsForcePerSquareMillimeter(double value);
    public static Pressure FromKilonewtonsPerSquareCentimeter(double value);
    public static Pressure FromKilonewtonsPerSquareMeter(double value);
    public static Pressure FromKilonewtonsPerSquareMillimeter(double value);
    public static Pressure FromKilopascals(double value);
    public static Pressure FromKilopoundsForcePerSquareFoot(double value);
    public static Pressure FromKilopoundsForcePerSquareInch(double value);
    public static Pressure FromKilopoundsForcePerSquareMil(double value);
    public static Pressure FromMegabars(double value);
    public static Pressure FromMeganewtonsPerSquareMeter(double value);
    public static Pressure FromMegapascals(double value);
    public static Pressure FromMetersOfElevation(double value);
    public static Pressure FromMetersOfHead(double value);
    public static Pressure FromMetersOfWaterColumn(double value);
    public static Pressure FromMicrobars(double value);
    public static Pressure FromMicropascals(double value);
    public static Pressure FromMillibars(double value);
    public static Pressure FromMillimetersOfMercury(double value);
    public static Pressure FromMillimetersOfWaterColumn(double value);
    public static Pressure FromMillipascals(double value);
    public static Pressure FromNewtonsPerSquareCentimeter(double value);
    public static Pressure FromNewtonsPerSquareMeter(double value);
    public static Pressure FromNewtonsPerSquareMillimeter(double value);
    public static Pressure FromPascals(double value);
    public static Pressure FromPoundsForcePerSquareFoot(double value);
    public static Pressure FromPoundsForcePerSquareInch(double value);
    public static Pressure FromPoundsForcePerSquareMil(double value);
    public static Pressure FromPoundsPerInchSecondSquared(double value);
    public static Pressure FromTechnicalAtmospheres(double value);
    public static Pressure FromTonnesForcePerSquareCentimeter(double value);
    public static Pressure FromTonnesForcePerSquareMeter(double value);
    public static Pressure FromTonnesForcePerSquareMillimeter(double value);
    public static Pressure FromTorrs(double value);
    public static Pressure From(double value, PressureUnit fromUnit);
    public static Pressure Parse(string str);
    public static override Pressure Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Pressure& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Pressure& result);
    public static PressureUnit ParseUnit(string str);
    public static PressureUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, PressureUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, PressureUnit& unit);
    public static override Pressure op_UnaryNegation(Pressure right);
    public static override Pressure op_Addition(Pressure left, Pressure right);
    public static override Pressure op_Subtraction(Pressure left, Pressure right);
    public static Pressure op_Multiply(double left, Pressure right);
    public static override Pressure op_Multiply(Pressure left, double right);
    public static override Pressure op_Division(Pressure left, double right);
    public static double op_Division(Pressure left, Pressure right);
    public static override Duration op_Division(Pressure pressure, PressureChangeRate pressureChangeRate);
    public static override Force op_Division(Pressure pressure, ReciprocalArea reciprocalArea);
    public static override Force op_Multiply(Pressure pressure, Area area);
    public static override ForcePerLength op_Multiply(Pressure pressure, Length length);
    public static override ForcePerLength op_Division(Pressure pressure, ReciprocalLength reciprocalLength);
    public static override Length op_Division(Pressure pressure, SpecificWeight specificWeight);
    public static override PressureChangeRate op_Division(Pressure pressure, Duration duration);
    public static override ReciprocalArea op_Division(Pressure pressure, Force force);
    public static override ReciprocalLength op_Division(Pressure pressure, ForcePerLength forcePerLength);
    public static override SpecificWeight op_Division(Pressure pressure, Length length);
    public static override bool op_LessThanOrEqual(Pressure left, Pressure right);
    public static override bool op_GreaterThanOrEqual(Pressure left, Pressure right);
    public static override bool op_LessThan(Pressure left, Pressure right);
    public static override bool op_GreaterThan(Pressure left, Pressure right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Pressure other, Pressure tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Pressure left, Pressure right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Pressure other, Pressure tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Pressure left, Pressure right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Pressure other, Pressure tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Pressure other, Pressure tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Pressure other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Pressure other);
    [ObsoleteAttribute("Use Equals(Pressure other, Pressure tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Pressure other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Pressure other, Pressure tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(PressureUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Pressure ToUnit(PressureUnit unit);
    public Pressure ToUnit(PressureUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(PressureUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Pressure ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<PressureUnit> UnitsNet.IQuantity<UnitsNet.Units.PressureUnit>.ToUnit(PressureUnit unit);
    private sealed virtual override IQuantity`1<PressureUnit> UnitsNet.IQuantity<UnitsNet.Units.PressureUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.PressureChangeRate : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<PressureChangeRateUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<PressureChangeRateUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static PressureChangeRateUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static PressureChangeRateUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static PressureChangeRate <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<PressureChangeRateUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static PressureChangeRateUnit BaseUnit { get; }
    public static PressureChangeRateUnit[] Units { get; }
    public static PressureChangeRate Zero { get; }
    public static PressureChangeRate AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public PressureChangeRateUnit Unit { get; }
    public QuantityInfo`1<PressureChangeRateUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double AtmospheresPerSecond { get; }
    public double BarsPerMinute { get; }
    public double BarsPerSecond { get; }
    public double KilopascalsPerMinute { get; }
    public double KilopascalsPerSecond { get; }
    public double KilopoundsForcePerSquareInchPerMinute { get; }
    public double KilopoundsForcePerSquareInchPerSecond { get; }
    public double MegapascalsPerMinute { get; }
    public double MegapascalsPerSecond { get; }
    public double MegapoundsForcePerSquareInchPerMinute { get; }
    public double MegapoundsForcePerSquareInchPerSecond { get; }
    public double MillibarsPerMinute { get; }
    public double MillibarsPerSecond { get; }
    public double MillimetersOfMercuryPerSecond { get; }
    public double PascalsPerMinute { get; }
    public double PascalsPerSecond { get; }
    public double PoundsForcePerSquareInchPerMinute { get; }
    public double PoundsForcePerSquareInchPerSecond { get; }
    private static PressureChangeRate();
    public PressureChangeRate(double value, PressureChangeRateUnit unit);
    public PressureChangeRate(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<PressureChangeRateUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static PressureChangeRateUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static PressureChangeRateUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override PressureChangeRate get_Zero();
    public static override PressureChangeRate get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual PressureChangeRateUnit get_Unit();
    public sealed virtual QuantityInfo`1<PressureChangeRateUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_AtmospheresPerSecond();
    public double get_BarsPerMinute();
    public double get_BarsPerSecond();
    public double get_KilopascalsPerMinute();
    public double get_KilopascalsPerSecond();
    public double get_KilopoundsForcePerSquareInchPerMinute();
    public double get_KilopoundsForcePerSquareInchPerSecond();
    public double get_MegapascalsPerMinute();
    public double get_MegapascalsPerSecond();
    public double get_MegapoundsForcePerSquareInchPerMinute();
    public double get_MegapoundsForcePerSquareInchPerSecond();
    public double get_MillibarsPerMinute();
    public double get_MillibarsPerSecond();
    public double get_MillimetersOfMercuryPerSecond();
    public double get_PascalsPerMinute();
    public double get_PascalsPerSecond();
    public double get_PoundsForcePerSquareInchPerMinute();
    public double get_PoundsForcePerSquareInchPerSecond();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(PressureChangeRateUnit unit);
    public static string GetAbbreviation(PressureChangeRateUnit unit, IFormatProvider provider);
    public static PressureChangeRate FromAtmospheresPerSecond(double value);
    public static PressureChangeRate FromBarsPerMinute(double value);
    public static PressureChangeRate FromBarsPerSecond(double value);
    public static PressureChangeRate FromKilopascalsPerMinute(double value);
    public static PressureChangeRate FromKilopascalsPerSecond(double value);
    public static PressureChangeRate FromKilopoundsForcePerSquareInchPerMinute(double value);
    public static PressureChangeRate FromKilopoundsForcePerSquareInchPerSecond(double value);
    public static PressureChangeRate FromMegapascalsPerMinute(double value);
    public static PressureChangeRate FromMegapascalsPerSecond(double value);
    public static PressureChangeRate FromMegapoundsForcePerSquareInchPerMinute(double value);
    public static PressureChangeRate FromMegapoundsForcePerSquareInchPerSecond(double value);
    public static PressureChangeRate FromMillibarsPerMinute(double value);
    public static PressureChangeRate FromMillibarsPerSecond(double value);
    public static PressureChangeRate FromMillimetersOfMercuryPerSecond(double value);
    public static PressureChangeRate FromPascalsPerMinute(double value);
    public static PressureChangeRate FromPascalsPerSecond(double value);
    public static PressureChangeRate FromPoundsForcePerSquareInchPerMinute(double value);
    public static PressureChangeRate FromPoundsForcePerSquareInchPerSecond(double value);
    public static PressureChangeRate From(double value, PressureChangeRateUnit fromUnit);
    public static PressureChangeRate Parse(string str);
    public static override PressureChangeRate Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, PressureChangeRate& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, PressureChangeRate& result);
    public static PressureChangeRateUnit ParseUnit(string str);
    public static PressureChangeRateUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, PressureChangeRateUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, PressureChangeRateUnit& unit);
    public static override PressureChangeRate op_UnaryNegation(PressureChangeRate right);
    public static override PressureChangeRate op_Addition(PressureChangeRate left, PressureChangeRate right);
    public static override PressureChangeRate op_Subtraction(PressureChangeRate left, PressureChangeRate right);
    public static PressureChangeRate op_Multiply(double left, PressureChangeRate right);
    public static override PressureChangeRate op_Multiply(PressureChangeRate left, double right);
    public static override PressureChangeRate op_Division(PressureChangeRate left, double right);
    public static double op_Division(PressureChangeRate left, PressureChangeRate right);
    public static override Pressure op_Multiply(PressureChangeRate pressureChangeRate, Duration duration);
    public static override bool op_LessThanOrEqual(PressureChangeRate left, PressureChangeRate right);
    public static override bool op_GreaterThanOrEqual(PressureChangeRate left, PressureChangeRate right);
    public static override bool op_LessThan(PressureChangeRate left, PressureChangeRate right);
    public static override bool op_GreaterThan(PressureChangeRate left, PressureChangeRate right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(PressureChangeRate other, PressureChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(PressureChangeRate left, PressureChangeRate right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(PressureChangeRate other, PressureChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(PressureChangeRate left, PressureChangeRate right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(PressureChangeRate other, PressureChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(PressureChangeRate other, PressureChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(PressureChangeRate other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(PressureChangeRate other);
    [ObsoleteAttribute("Use Equals(PressureChangeRate other, PressureChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(PressureChangeRate other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(PressureChangeRate other, PressureChangeRate tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(PressureChangeRateUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public PressureChangeRate ToUnit(PressureChangeRateUnit unit);
    public PressureChangeRate ToUnit(PressureChangeRateUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(PressureChangeRateUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public PressureChangeRate ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<PressureChangeRateUnit> UnitsNet.IQuantity<UnitsNet.Units.PressureChangeRateUnit>.ToUnit(PressureChangeRateUnit unit);
    private sealed virtual override IQuantity`1<PressureChangeRateUnit> UnitsNet.IQuantity<UnitsNet.Units.PressureChangeRateUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.Quantity : object {
    public static IDictionary`2<string, QuantityInfo> ByName;
    private static QuantityInfoLookup Default { get; }
    public static String[] Names { get; }
    public static QuantityInfo[] Infos { get; }
    private static Quantity();
    private static QuantityInfoLookup get_Default();
    public static String[] get_Names();
    public static QuantityInfo[] get_Infos();
    public static UnitInfo GetUnitInfo(Enum unitEnum);
    public static bool TryGetUnitInfo(Enum unitEnum, UnitInfo& unitInfo);
    public static void AddUnitInfo(Enum unit, UnitInfo unitInfo);
    public static IQuantity From(double value, Enum unit);
    public static IQuantity From(double value, string quantityName, string unitName);
    public static IQuantity FromUnitAbbreviation(double value, string unitAbbreviation);
    public static IQuantity FromUnitAbbreviation(IFormatProvider formatProvider, double value, string unitAbbreviation);
    public static bool TryFrom(double value, string quantityName, string unitName, IQuantity& quantity);
    public static bool TryFromUnitAbbreviation(double value, string unitAbbreviation, IQuantity& quantity);
    [NullableContextAttribute("2")]
public static bool TryFromUnitAbbreviation(IFormatProvider formatProvider, double value, string unitAbbreviation, IQuantity& quantity);
    public static IQuantity Parse(Type quantityType, string quantityString);
    public static IQuantity Parse(IFormatProvider formatProvider, Type quantityType, string quantityString);
    public static bool TryParse(Type quantityType, string quantityString, IQuantity& quantity);
    public static IEnumerable`1<QuantityInfo> GetQuantitiesWithBaseDimensions(BaseDimensions baseDimensions);
    private static List`1<Enum> GetUnitsForAbbreviation(IFormatProvider formatProvider, string unitAbbreviation);
    public static IQuantity FromQuantityInfo(QuantityInfo quantityInfo, double value);
    [NullableContextAttribute("2")]
public static bool TryFrom(double value, Enum unit, IQuantity& quantity);
    public static bool TryParse(IFormatProvider formatProvider, Type quantityType, string quantityString, IQuantity& quantity);
    [IteratorStateMachineAttribute("UnitsNet.Quantity/<GetQuantityTypes>d__25")]
internal static IEnumerable`1<Type> GetQuantityTypes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class UnitsNet.QuantityDisplay : ValueType {
    [CompilerGeneratedAttribute]
private IQuantity <quantity>P;
    public UnitDisplay Unit { get; }
    public AbbreviationDisplay UnitAbbreviation { get; }
    public ValueDisplay Value { get; }
    public QuantityConvertor ValueConvertor { get; }
    public QuantityDisplay(IQuantity quantity);
    public UnitDisplay get_Unit();
    public AbbreviationDisplay get_UnitAbbreviation();
    public ValueDisplay get_Value();
    public QuantityConvertor get_ValueConvertor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.QuantityFormatter : object {
    private static Char[] UnitsNetFormatSpecifiers;
    private static QuantityFormatter();
    public static string Format(IQuantity`1<TUnitType> quantity, string format);
    public static string Format(IQuantity`1<TUnitType> quantity, string format, IFormatProvider formatProvider);
    private static string FormatUntrimmed(IQuantity`1<TUnitType> quantity, string format, IFormatProvider formatProvider);
    private static string ToStringWithSignificantDigitsAfterRadix(IQuantity`1<TUnitType> quantity, IFormatProvider formatProvider, int number);
}
public class UnitsNet.QuantityFromDelegate`2 : MulticastDelegate {
    public QuantityFromDelegate`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TQuantity Invoke(double value, TUnitType fromUnit);
    public virtual IAsyncResult BeginInvoke(double value, TUnitType fromUnit, AsyncCallback callback, object object);
    public virtual TQuantity EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.QuantityInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private UnitInfo[] <UnitInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private UnitInfo <BaseUnitInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IQuantity <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <UnitType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseDimensions <BaseDimensions>k__BackingField;
    public string Name { get; }
    public UnitInfo[] UnitInfos { get; }
    public UnitInfo BaseUnitInfo { get; }
    public IQuantity Zero { get; }
    public Type UnitType { get; }
    public Type ValueType { get; }
    public BaseDimensions BaseDimensions { get; }
    public QuantityInfo(string name, Type unitType, UnitInfo[] unitInfos, Enum baseUnit, IQuantity zero, BaseDimensions baseDimensions);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public UnitInfo[] get_UnitInfos();
    [CompilerGeneratedAttribute]
public UnitInfo get_BaseUnitInfo();
    [CompilerGeneratedAttribute]
public IQuantity get_Zero();
    [CompilerGeneratedAttribute]
public Type get_UnitType();
    [CompilerGeneratedAttribute]
public Type get_ValueType();
    [CompilerGeneratedAttribute]
public BaseDimensions get_BaseDimensions();
    public UnitInfo GetUnitInfoFor(BaseUnits baseUnits);
    public IEnumerable`1<UnitInfo> GetUnitInfosFor(BaseUnits baseUnits);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.QuantityInfo`1 : QuantityInfo {
    [CompilerGeneratedAttribute]
private UnitInfo`1[] <UnitInfos>k__BackingField;
    [CompilerGeneratedAttribute]
private UnitInfo`1<TUnit> <BaseUnitInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IQuantity`1<TUnit> <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private TUnit <UnitType>k__BackingField;
    public UnitInfo`1[] UnitInfos { get; }
    public UnitInfo`1<TUnit> BaseUnitInfo { get; }
    public IQuantity`1<TUnit> Zero { get; }
    public TUnit UnitType { get; }
    public QuantityInfo`1(string name, UnitInfo`1[] unitInfos, TUnit baseUnit, IQuantity`1<TUnit> zero, BaseDimensions baseDimensions);
    [CompilerGeneratedAttribute]
public UnitInfo`1[] get_UnitInfos();
    [CompilerGeneratedAttribute]
public UnitInfo`1<TUnit> get_BaseUnitInfo();
    [CompilerGeneratedAttribute]
public IQuantity`1<TUnit> get_Zero();
    [CompilerGeneratedAttribute]
public TUnit get_UnitType();
    public UnitInfo`1<TUnit> GetUnitInfoFor(BaseUnits baseUnits);
    public IEnumerable`1<UnitInfo`1<TUnit>> GetUnitInfosFor(BaseUnits baseUnits);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class UnitsNet.QuantityInfoLookup : object {
    private Lazy`1<QuantityInfo[]> _infosLazy;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<Dictionary`2<ValueTuple`2<Type, string>, UnitInfo>> _unitTypeAndNameToUnitInfoLazy;
    [CompilerGeneratedAttribute]
private String[] <Names>k__BackingField;
    public String[] Names { get; }
    public QuantityInfo[] Infos { get; }
    public QuantityInfoLookup(ICollection`1<QuantityInfo> quantityInfos);
    [CompilerGeneratedAttribute]
public String[] get_Names();
    public QuantityInfo[] get_Infos();
    public QuantityInfo GetQuantityInfo(UnitInfo unitInfo);
    public bool TryGetQuantityInfo(UnitInfo unitInfo, QuantityInfo& quantityInfo);
    public UnitInfo GetUnitInfo(Enum unitEnum);
    public bool TryGetUnitInfo(Enum unitEnum, UnitInfo& unitInfo);
    public void AddUnitInfo(Enum unit, UnitInfo unitInfo);
    public IQuantity From(double value, Enum unit);
    public bool TryFrom(double value, Enum unit, IQuantity& quantity);
    public IQuantity Parse(Type quantityType, string quantityString);
    public IQuantity Parse(IFormatProvider formatProvider, Type quantityType, string quantityString);
    public bool TryParse(Type quantityType, string quantityString, IQuantity& quantity);
    public IEnumerable`1<QuantityInfo> GetQuantitiesWithBaseDimensions(BaseDimensions baseDimensions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.QuantityParser : object {
    private static NumberStyles ParseNumberStyles;
    private UnitAbbreviationsCache _unitAbbreviationsCache;
    private UnitParser _unitParser;
    [ObsoleteAttribute("Use UnitsNetSetup.Default.QuantityParser instead.")]
public static QuantityParser Default { get; }
    [NullableContextAttribute("2")]
public QuantityParser(UnitAbbreviationsCache unitAbbreviationsCache);
    public static QuantityParser get_Default();
    public TQuantity Parse(string str, IFormatProvider formatProvider, QuantityFromDelegate`2<TQuantity, TUnitType> fromDelegate);
    [NullableContextAttribute("0")]
public bool TryParse(string str, IFormatProvider formatProvider, QuantityFromDelegate`2<TQuantity, TUnitType> fromDelegate, TQuantity& result);
    public bool TryParse(string str, IFormatProvider formatProvider, QuantityFromDelegate`2<TQuantity, TUnitType> fromDelegate, IQuantity& result);
    internal string CreateRegexPatternForUnit(TUnitType unit, IFormatProvider formatProvider, bool matchEntireString);
    private static string GetRegexPatternForUnitAbbreviations(IEnumerable`1<string> abbreviations);
    private TQuantity ParseWithRegex(string valueString, string unitString, QuantityFromDelegate`2<TQuantity, TUnitType> fromDelegate, IFormatProvider formatProvider);
    [NullableContextAttribute("0")]
private bool TryParseWithRegex(string valueString, string unitString, QuantityFromDelegate`2<TQuantity, TUnitType> fromDelegate, IFormatProvider formatProvider, TQuantity& result);
    private static bool TryExtractValueAndUnit(Regex regex, string str, String& valueString, String& unitString);
    private string CreateRegexPatternForQuantity(IFormatProvider formatProvider);
    private Regex CreateRegexForQuantity(IFormatProvider formatProvider);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class UnitsNet.QuantityTypeConverter`1 : TypeConverter {
    [NullableContextAttribute("1")]
public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    private static TAttribute GetAttribute(ITypeDescriptorContext context);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
    public virtual bool CanConvertTo(ITypeDescriptorContext context, Type destinationType);
    public virtual object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.RadiationEquivalentDose : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<RadiationEquivalentDoseUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<RadiationEquivalentDoseUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static RadiationEquivalentDoseUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static RadiationEquivalentDoseUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static RadiationEquivalentDose <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<RadiationEquivalentDoseUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static RadiationEquivalentDoseUnit BaseUnit { get; }
    public static RadiationEquivalentDoseUnit[] Units { get; }
    public static RadiationEquivalentDose Zero { get; }
    public static RadiationEquivalentDose AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public RadiationEquivalentDoseUnit Unit { get; }
    public QuantityInfo`1<RadiationEquivalentDoseUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Microsieverts { get; }
    public double MilliroentgensEquivalentMan { get; }
    public double Millisieverts { get; }
    public double Nanosieverts { get; }
    public double RoentgensEquivalentMan { get; }
    public double Sieverts { get; }
    private static RadiationEquivalentDose();
    public RadiationEquivalentDose(double value, RadiationEquivalentDoseUnit unit);
    public RadiationEquivalentDose(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<RadiationEquivalentDoseUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static RadiationEquivalentDoseUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static RadiationEquivalentDoseUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override RadiationEquivalentDose get_Zero();
    public static override RadiationEquivalentDose get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual RadiationEquivalentDoseUnit get_Unit();
    public sealed virtual QuantityInfo`1<RadiationEquivalentDoseUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Microsieverts();
    public double get_MilliroentgensEquivalentMan();
    public double get_Millisieverts();
    public double get_Nanosieverts();
    public double get_RoentgensEquivalentMan();
    public double get_Sieverts();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(RadiationEquivalentDoseUnit unit);
    public static string GetAbbreviation(RadiationEquivalentDoseUnit unit, IFormatProvider provider);
    public static RadiationEquivalentDose FromMicrosieverts(double value);
    public static RadiationEquivalentDose FromMilliroentgensEquivalentMan(double value);
    public static RadiationEquivalentDose FromMillisieverts(double value);
    public static RadiationEquivalentDose FromNanosieverts(double value);
    public static RadiationEquivalentDose FromRoentgensEquivalentMan(double value);
    public static RadiationEquivalentDose FromSieverts(double value);
    public static RadiationEquivalentDose From(double value, RadiationEquivalentDoseUnit fromUnit);
    public static RadiationEquivalentDose Parse(string str);
    public static override RadiationEquivalentDose Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, RadiationEquivalentDose& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, RadiationEquivalentDose& result);
    public static RadiationEquivalentDoseUnit ParseUnit(string str);
    public static RadiationEquivalentDoseUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, RadiationEquivalentDoseUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, RadiationEquivalentDoseUnit& unit);
    public static override RadiationEquivalentDose op_UnaryNegation(RadiationEquivalentDose right);
    public static override RadiationEquivalentDose op_Addition(RadiationEquivalentDose left, RadiationEquivalentDose right);
    public static override RadiationEquivalentDose op_Subtraction(RadiationEquivalentDose left, RadiationEquivalentDose right);
    public static RadiationEquivalentDose op_Multiply(double left, RadiationEquivalentDose right);
    public static override RadiationEquivalentDose op_Multiply(RadiationEquivalentDose left, double right);
    public static override RadiationEquivalentDose op_Division(RadiationEquivalentDose left, double right);
    public static double op_Division(RadiationEquivalentDose left, RadiationEquivalentDose right);
    public static override bool op_LessThanOrEqual(RadiationEquivalentDose left, RadiationEquivalentDose right);
    public static override bool op_GreaterThanOrEqual(RadiationEquivalentDose left, RadiationEquivalentDose right);
    public static override bool op_LessThan(RadiationEquivalentDose left, RadiationEquivalentDose right);
    public static override bool op_GreaterThan(RadiationEquivalentDose left, RadiationEquivalentDose right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(RadiationEquivalentDose other, RadiationEquivalentDose tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(RadiationEquivalentDose left, RadiationEquivalentDose right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(RadiationEquivalentDose other, RadiationEquivalentDose tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(RadiationEquivalentDose left, RadiationEquivalentDose right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(RadiationEquivalentDose other, RadiationEquivalentDose tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(RadiationEquivalentDose other, RadiationEquivalentDose tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(RadiationEquivalentDose other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(RadiationEquivalentDose other);
    [ObsoleteAttribute("Use Equals(RadiationEquivalentDose other, RadiationEquivalentDose tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(RadiationEquivalentDose other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(RadiationEquivalentDose other, RadiationEquivalentDose tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(RadiationEquivalentDoseUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public RadiationEquivalentDose ToUnit(RadiationEquivalentDoseUnit unit);
    public RadiationEquivalentDose ToUnit(RadiationEquivalentDoseUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(RadiationEquivalentDoseUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public RadiationEquivalentDose ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<RadiationEquivalentDoseUnit> UnitsNet.IQuantity<UnitsNet.Units.RadiationEquivalentDoseUnit>.ToUnit(RadiationEquivalentDoseUnit unit);
    private sealed virtual override IQuantity`1<RadiationEquivalentDoseUnit> UnitsNet.IQuantity<UnitsNet.Units.RadiationEquivalentDoseUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.RadiationExposure : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<RadiationExposureUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<RadiationExposureUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static RadiationExposureUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static RadiationExposureUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static RadiationExposure <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<RadiationExposureUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static RadiationExposureUnit BaseUnit { get; }
    public static RadiationExposureUnit[] Units { get; }
    public static RadiationExposure Zero { get; }
    public static RadiationExposure AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public RadiationExposureUnit Unit { get; }
    public QuantityInfo`1<RadiationExposureUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CoulombsPerKilogram { get; }
    public double MicrocoulombsPerKilogram { get; }
    public double Microroentgens { get; }
    public double MillicoulombsPerKilogram { get; }
    public double Milliroentgens { get; }
    public double NanocoulombsPerKilogram { get; }
    public double PicocoulombsPerKilogram { get; }
    public double Roentgens { get; }
    private static RadiationExposure();
    public RadiationExposure(double value, RadiationExposureUnit unit);
    public RadiationExposure(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<RadiationExposureUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static RadiationExposureUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static RadiationExposureUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override RadiationExposure get_Zero();
    public static override RadiationExposure get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual RadiationExposureUnit get_Unit();
    public sealed virtual QuantityInfo`1<RadiationExposureUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CoulombsPerKilogram();
    public double get_MicrocoulombsPerKilogram();
    public double get_Microroentgens();
    public double get_MillicoulombsPerKilogram();
    public double get_Milliroentgens();
    public double get_NanocoulombsPerKilogram();
    public double get_PicocoulombsPerKilogram();
    public double get_Roentgens();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(RadiationExposureUnit unit);
    public static string GetAbbreviation(RadiationExposureUnit unit, IFormatProvider provider);
    public static RadiationExposure FromCoulombsPerKilogram(double value);
    public static RadiationExposure FromMicrocoulombsPerKilogram(double value);
    public static RadiationExposure FromMicroroentgens(double value);
    public static RadiationExposure FromMillicoulombsPerKilogram(double value);
    public static RadiationExposure FromMilliroentgens(double value);
    public static RadiationExposure FromNanocoulombsPerKilogram(double value);
    public static RadiationExposure FromPicocoulombsPerKilogram(double value);
    public static RadiationExposure FromRoentgens(double value);
    public static RadiationExposure From(double value, RadiationExposureUnit fromUnit);
    public static RadiationExposure Parse(string str);
    public static override RadiationExposure Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, RadiationExposure& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, RadiationExposure& result);
    public static RadiationExposureUnit ParseUnit(string str);
    public static RadiationExposureUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, RadiationExposureUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, RadiationExposureUnit& unit);
    public static override RadiationExposure op_UnaryNegation(RadiationExposure right);
    public static override RadiationExposure op_Addition(RadiationExposure left, RadiationExposure right);
    public static override RadiationExposure op_Subtraction(RadiationExposure left, RadiationExposure right);
    public static RadiationExposure op_Multiply(double left, RadiationExposure right);
    public static override RadiationExposure op_Multiply(RadiationExposure left, double right);
    public static override RadiationExposure op_Division(RadiationExposure left, double right);
    public static double op_Division(RadiationExposure left, RadiationExposure right);
    public static override bool op_LessThanOrEqual(RadiationExposure left, RadiationExposure right);
    public static override bool op_GreaterThanOrEqual(RadiationExposure left, RadiationExposure right);
    public static override bool op_LessThan(RadiationExposure left, RadiationExposure right);
    public static override bool op_GreaterThan(RadiationExposure left, RadiationExposure right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(RadiationExposure other, RadiationExposure tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(RadiationExposure left, RadiationExposure right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(RadiationExposure other, RadiationExposure tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(RadiationExposure left, RadiationExposure right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(RadiationExposure other, RadiationExposure tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(RadiationExposure other, RadiationExposure tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(RadiationExposure other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(RadiationExposure other);
    [ObsoleteAttribute("Use Equals(RadiationExposure other, RadiationExposure tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(RadiationExposure other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(RadiationExposure other, RadiationExposure tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(RadiationExposureUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public RadiationExposure ToUnit(RadiationExposureUnit unit);
    public RadiationExposure ToUnit(RadiationExposureUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(RadiationExposureUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public RadiationExposure ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<RadiationExposureUnit> UnitsNet.IQuantity<UnitsNet.Units.RadiationExposureUnit>.ToUnit(RadiationExposureUnit unit);
    private sealed virtual override IQuantity`1<RadiationExposureUnit> UnitsNet.IQuantity<UnitsNet.Units.RadiationExposureUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Radioactivity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<RadioactivityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<RadioactivityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static RadioactivityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static RadioactivityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Radioactivity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<RadioactivityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static RadioactivityUnit BaseUnit { get; }
    public static RadioactivityUnit[] Units { get; }
    public static Radioactivity Zero { get; }
    public static Radioactivity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public RadioactivityUnit Unit { get; }
    public QuantityInfo`1<RadioactivityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Becquerels { get; }
    public double Curies { get; }
    public double Exabecquerels { get; }
    public double Gigabecquerels { get; }
    public double Gigacuries { get; }
    public double Gigarutherfords { get; }
    public double Kilobecquerels { get; }
    public double Kilocuries { get; }
    public double Kilorutherfords { get; }
    public double Megabecquerels { get; }
    public double Megacuries { get; }
    public double Megarutherfords { get; }
    public double Microbecquerels { get; }
    public double Microcuries { get; }
    public double Microrutherfords { get; }
    public double Millibecquerels { get; }
    public double Millicuries { get; }
    public double Millirutherfords { get; }
    public double Nanobecquerels { get; }
    public double Nanocuries { get; }
    public double Nanorutherfords { get; }
    public double Petabecquerels { get; }
    public double Picobecquerels { get; }
    public double Picocuries { get; }
    public double Picorutherfords { get; }
    public double Rutherfords { get; }
    public double Terabecquerels { get; }
    public double Teracuries { get; }
    public double Terarutherfords { get; }
    private static Radioactivity();
    public Radioactivity(double value, RadioactivityUnit unit);
    public Radioactivity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<RadioactivityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static RadioactivityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static RadioactivityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Radioactivity get_Zero();
    public static override Radioactivity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual RadioactivityUnit get_Unit();
    public sealed virtual QuantityInfo`1<RadioactivityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Becquerels();
    public double get_Curies();
    public double get_Exabecquerels();
    public double get_Gigabecquerels();
    public double get_Gigacuries();
    public double get_Gigarutherfords();
    public double get_Kilobecquerels();
    public double get_Kilocuries();
    public double get_Kilorutherfords();
    public double get_Megabecquerels();
    public double get_Megacuries();
    public double get_Megarutherfords();
    public double get_Microbecquerels();
    public double get_Microcuries();
    public double get_Microrutherfords();
    public double get_Millibecquerels();
    public double get_Millicuries();
    public double get_Millirutherfords();
    public double get_Nanobecquerels();
    public double get_Nanocuries();
    public double get_Nanorutherfords();
    public double get_Petabecquerels();
    public double get_Picobecquerels();
    public double get_Picocuries();
    public double get_Picorutherfords();
    public double get_Rutherfords();
    public double get_Terabecquerels();
    public double get_Teracuries();
    public double get_Terarutherfords();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(RadioactivityUnit unit);
    public static string GetAbbreviation(RadioactivityUnit unit, IFormatProvider provider);
    public static Radioactivity FromBecquerels(double value);
    public static Radioactivity FromCuries(double value);
    public static Radioactivity FromExabecquerels(double value);
    public static Radioactivity FromGigabecquerels(double value);
    public static Radioactivity FromGigacuries(double value);
    public static Radioactivity FromGigarutherfords(double value);
    public static Radioactivity FromKilobecquerels(double value);
    public static Radioactivity FromKilocuries(double value);
    public static Radioactivity FromKilorutherfords(double value);
    public static Radioactivity FromMegabecquerels(double value);
    public static Radioactivity FromMegacuries(double value);
    public static Radioactivity FromMegarutherfords(double value);
    public static Radioactivity FromMicrobecquerels(double value);
    public static Radioactivity FromMicrocuries(double value);
    public static Radioactivity FromMicrorutherfords(double value);
    public static Radioactivity FromMillibecquerels(double value);
    public static Radioactivity FromMillicuries(double value);
    public static Radioactivity FromMillirutherfords(double value);
    public static Radioactivity FromNanobecquerels(double value);
    public static Radioactivity FromNanocuries(double value);
    public static Radioactivity FromNanorutherfords(double value);
    public static Radioactivity FromPetabecquerels(double value);
    public static Radioactivity FromPicobecquerels(double value);
    public static Radioactivity FromPicocuries(double value);
    public static Radioactivity FromPicorutherfords(double value);
    public static Radioactivity FromRutherfords(double value);
    public static Radioactivity FromTerabecquerels(double value);
    public static Radioactivity FromTeracuries(double value);
    public static Radioactivity FromTerarutherfords(double value);
    public static Radioactivity From(double value, RadioactivityUnit fromUnit);
    public static Radioactivity Parse(string str);
    public static override Radioactivity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Radioactivity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Radioactivity& result);
    public static RadioactivityUnit ParseUnit(string str);
    public static RadioactivityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, RadioactivityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, RadioactivityUnit& unit);
    public static override Radioactivity op_UnaryNegation(Radioactivity right);
    public static override Radioactivity op_Addition(Radioactivity left, Radioactivity right);
    public static override Radioactivity op_Subtraction(Radioactivity left, Radioactivity right);
    public static Radioactivity op_Multiply(double left, Radioactivity right);
    public static override Radioactivity op_Multiply(Radioactivity left, double right);
    public static override Radioactivity op_Division(Radioactivity left, double right);
    public static double op_Division(Radioactivity left, Radioactivity right);
    public static override bool op_LessThanOrEqual(Radioactivity left, Radioactivity right);
    public static override bool op_GreaterThanOrEqual(Radioactivity left, Radioactivity right);
    public static override bool op_LessThan(Radioactivity left, Radioactivity right);
    public static override bool op_GreaterThan(Radioactivity left, Radioactivity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Radioactivity other, Radioactivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Radioactivity left, Radioactivity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Radioactivity other, Radioactivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Radioactivity left, Radioactivity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Radioactivity other, Radioactivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Radioactivity other, Radioactivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Radioactivity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Radioactivity other);
    [ObsoleteAttribute("Use Equals(Radioactivity other, Radioactivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Radioactivity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Radioactivity other, Radioactivity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(RadioactivityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Radioactivity ToUnit(RadioactivityUnit unit);
    public Radioactivity ToUnit(RadioactivityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(RadioactivityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Radioactivity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<RadioactivityUnit> UnitsNet.IQuantity<UnitsNet.Units.RadioactivityUnit>.ToUnit(RadioactivityUnit unit);
    private sealed virtual override IQuantity`1<RadioactivityUnit> UnitsNet.IQuantity<UnitsNet.Units.RadioactivityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Ratio : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<RatioUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<RatioUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static RatioUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static RatioUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Ratio <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<RatioUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static RatioUnit BaseUnit { get; }
    public static RatioUnit[] Units { get; }
    public static Ratio Zero { get; }
    public static Ratio AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public RatioUnit Unit { get; }
    public QuantityInfo`1<RatioUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double DecimalFractions { get; }
    public double PartsPerBillion { get; }
    public double PartsPerMillion { get; }
    public double PartsPerThousand { get; }
    public double PartsPerTrillion { get; }
    public double Percent { get; }
    private static Ratio();
    public Ratio(double value, RatioUnit unit);
    public Ratio(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<RatioUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static RatioUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static RatioUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Ratio get_Zero();
    public static override Ratio get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual RatioUnit get_Unit();
    public sealed virtual QuantityInfo`1<RatioUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_DecimalFractions();
    public double get_PartsPerBillion();
    public double get_PartsPerMillion();
    public double get_PartsPerThousand();
    public double get_PartsPerTrillion();
    public double get_Percent();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(RatioUnit unit);
    public static string GetAbbreviation(RatioUnit unit, IFormatProvider provider);
    public static Ratio FromDecimalFractions(double value);
    public static Ratio FromPartsPerBillion(double value);
    public static Ratio FromPartsPerMillion(double value);
    public static Ratio FromPartsPerThousand(double value);
    public static Ratio FromPartsPerTrillion(double value);
    public static Ratio FromPercent(double value);
    public static Ratio From(double value, RatioUnit fromUnit);
    public static Ratio Parse(string str);
    public static override Ratio Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Ratio& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Ratio& result);
    public static RatioUnit ParseUnit(string str);
    public static RatioUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, RatioUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, RatioUnit& unit);
    public static override Ratio op_UnaryNegation(Ratio right);
    public static override Ratio op_Addition(Ratio left, Ratio right);
    public static override Ratio op_Subtraction(Ratio left, Ratio right);
    public static Ratio op_Multiply(double left, Ratio right);
    public static override Ratio op_Multiply(Ratio left, double right);
    public static override Ratio op_Division(Ratio left, double right);
    public static double op_Division(Ratio left, Ratio right);
    public static override Area op_Division(Ratio ratio, ReciprocalArea reciprocalArea);
    public static override ReciprocalArea op_Division(Ratio ratio, Area area);
    public static override bool op_LessThanOrEqual(Ratio left, Ratio right);
    public static override bool op_GreaterThanOrEqual(Ratio left, Ratio right);
    public static override bool op_LessThan(Ratio left, Ratio right);
    public static override bool op_GreaterThan(Ratio left, Ratio right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Ratio other, Ratio tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Ratio left, Ratio right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Ratio other, Ratio tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Ratio left, Ratio right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Ratio other, Ratio tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Ratio other, Ratio tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Ratio other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Ratio other);
    [ObsoleteAttribute("Use Equals(Ratio other, Ratio tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Ratio other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Ratio other, Ratio tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(RatioUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Ratio ToUnit(RatioUnit unit);
    public Ratio ToUnit(RatioUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(RatioUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Ratio ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<RatioUnit> UnitsNet.IQuantity<UnitsNet.Units.RatioUnit>.ToUnit(RatioUnit unit);
    private sealed virtual override IQuantity`1<RatioUnit> UnitsNet.IQuantity<UnitsNet.Units.RatioUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.RatioChangeRate : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<RatioChangeRateUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<RatioChangeRateUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static RatioChangeRateUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static RatioChangeRateUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static RatioChangeRate <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<RatioChangeRateUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static RatioChangeRateUnit BaseUnit { get; }
    public static RatioChangeRateUnit[] Units { get; }
    public static RatioChangeRate Zero { get; }
    public static RatioChangeRate AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public RatioChangeRateUnit Unit { get; }
    public QuantityInfo`1<RatioChangeRateUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double DecimalFractionsPerSecond { get; }
    public double PercentsPerSecond { get; }
    private static RatioChangeRate();
    public RatioChangeRate(double value, RatioChangeRateUnit unit);
    public RatioChangeRate(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<RatioChangeRateUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static RatioChangeRateUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static RatioChangeRateUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override RatioChangeRate get_Zero();
    public static override RatioChangeRate get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual RatioChangeRateUnit get_Unit();
    public sealed virtual QuantityInfo`1<RatioChangeRateUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_DecimalFractionsPerSecond();
    public double get_PercentsPerSecond();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(RatioChangeRateUnit unit);
    public static string GetAbbreviation(RatioChangeRateUnit unit, IFormatProvider provider);
    public static RatioChangeRate FromDecimalFractionsPerSecond(double value);
    public static RatioChangeRate FromPercentsPerSecond(double value);
    public static RatioChangeRate From(double value, RatioChangeRateUnit fromUnit);
    public static RatioChangeRate Parse(string str);
    public static override RatioChangeRate Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, RatioChangeRate& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, RatioChangeRate& result);
    public static RatioChangeRateUnit ParseUnit(string str);
    public static RatioChangeRateUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, RatioChangeRateUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, RatioChangeRateUnit& unit);
    public static override RatioChangeRate op_UnaryNegation(RatioChangeRate right);
    public static override RatioChangeRate op_Addition(RatioChangeRate left, RatioChangeRate right);
    public static override RatioChangeRate op_Subtraction(RatioChangeRate left, RatioChangeRate right);
    public static RatioChangeRate op_Multiply(double left, RatioChangeRate right);
    public static override RatioChangeRate op_Multiply(RatioChangeRate left, double right);
    public static override RatioChangeRate op_Division(RatioChangeRate left, double right);
    public static double op_Division(RatioChangeRate left, RatioChangeRate right);
    public static override bool op_LessThanOrEqual(RatioChangeRate left, RatioChangeRate right);
    public static override bool op_GreaterThanOrEqual(RatioChangeRate left, RatioChangeRate right);
    public static override bool op_LessThan(RatioChangeRate left, RatioChangeRate right);
    public static override bool op_GreaterThan(RatioChangeRate left, RatioChangeRate right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(RatioChangeRate other, RatioChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(RatioChangeRate left, RatioChangeRate right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(RatioChangeRate other, RatioChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(RatioChangeRate left, RatioChangeRate right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(RatioChangeRate other, RatioChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(RatioChangeRate other, RatioChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(RatioChangeRate other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(RatioChangeRate other);
    [ObsoleteAttribute("Use Equals(RatioChangeRate other, RatioChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(RatioChangeRate other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(RatioChangeRate other, RatioChangeRate tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(RatioChangeRateUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public RatioChangeRate ToUnit(RatioChangeRateUnit unit);
    public RatioChangeRate ToUnit(RatioChangeRateUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(RatioChangeRateUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public RatioChangeRate ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<RatioChangeRateUnit> UnitsNet.IQuantity<UnitsNet.Units.RatioChangeRateUnit>.ToUnit(RatioChangeRateUnit unit);
    private sealed virtual override IQuantity`1<RatioChangeRateUnit> UnitsNet.IQuantity<UnitsNet.Units.RatioChangeRateUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ReactiveEnergy : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ReactiveEnergyUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ReactiveEnergyUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ReactiveEnergyUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ReactiveEnergyUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ReactiveEnergy <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ReactiveEnergyUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ReactiveEnergyUnit BaseUnit { get; }
    public static ReactiveEnergyUnit[] Units { get; }
    public static ReactiveEnergy Zero { get; }
    public static ReactiveEnergy AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ReactiveEnergyUnit Unit { get; }
    public QuantityInfo`1<ReactiveEnergyUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double KilovoltampereReactiveHours { get; }
    public double MegavoltampereReactiveHours { get; }
    public double VoltampereReactiveHours { get; }
    private static ReactiveEnergy();
    public ReactiveEnergy(double value, ReactiveEnergyUnit unit);
    public ReactiveEnergy(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ReactiveEnergyUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ReactiveEnergyUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ReactiveEnergyUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ReactiveEnergy get_Zero();
    public static override ReactiveEnergy get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ReactiveEnergyUnit get_Unit();
    public sealed virtual QuantityInfo`1<ReactiveEnergyUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_KilovoltampereReactiveHours();
    public double get_MegavoltampereReactiveHours();
    public double get_VoltampereReactiveHours();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ReactiveEnergyUnit unit);
    public static string GetAbbreviation(ReactiveEnergyUnit unit, IFormatProvider provider);
    public static ReactiveEnergy FromKilovoltampereReactiveHours(double value);
    public static ReactiveEnergy FromMegavoltampereReactiveHours(double value);
    public static ReactiveEnergy FromVoltampereReactiveHours(double value);
    public static ReactiveEnergy From(double value, ReactiveEnergyUnit fromUnit);
    public static ReactiveEnergy Parse(string str);
    public static override ReactiveEnergy Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ReactiveEnergy& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ReactiveEnergy& result);
    public static ReactiveEnergyUnit ParseUnit(string str);
    public static ReactiveEnergyUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ReactiveEnergyUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ReactiveEnergyUnit& unit);
    public static override ReactiveEnergy op_UnaryNegation(ReactiveEnergy right);
    public static override ReactiveEnergy op_Addition(ReactiveEnergy left, ReactiveEnergy right);
    public static override ReactiveEnergy op_Subtraction(ReactiveEnergy left, ReactiveEnergy right);
    public static ReactiveEnergy op_Multiply(double left, ReactiveEnergy right);
    public static override ReactiveEnergy op_Multiply(ReactiveEnergy left, double right);
    public static override ReactiveEnergy op_Division(ReactiveEnergy left, double right);
    public static double op_Division(ReactiveEnergy left, ReactiveEnergy right);
    public static override bool op_LessThanOrEqual(ReactiveEnergy left, ReactiveEnergy right);
    public static override bool op_GreaterThanOrEqual(ReactiveEnergy left, ReactiveEnergy right);
    public static override bool op_LessThan(ReactiveEnergy left, ReactiveEnergy right);
    public static override bool op_GreaterThan(ReactiveEnergy left, ReactiveEnergy right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ReactiveEnergy other, ReactiveEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ReactiveEnergy left, ReactiveEnergy right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ReactiveEnergy other, ReactiveEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ReactiveEnergy left, ReactiveEnergy right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ReactiveEnergy other, ReactiveEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ReactiveEnergy other, ReactiveEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ReactiveEnergy other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ReactiveEnergy other);
    [ObsoleteAttribute("Use Equals(ReactiveEnergy other, ReactiveEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ReactiveEnergy other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ReactiveEnergy other, ReactiveEnergy tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ReactiveEnergyUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ReactiveEnergy ToUnit(ReactiveEnergyUnit unit);
    public ReactiveEnergy ToUnit(ReactiveEnergyUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ReactiveEnergyUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ReactiveEnergy ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ReactiveEnergyUnit> UnitsNet.IQuantity<UnitsNet.Units.ReactiveEnergyUnit>.ToUnit(ReactiveEnergyUnit unit);
    private sealed virtual override IQuantity`1<ReactiveEnergyUnit> UnitsNet.IQuantity<UnitsNet.Units.ReactiveEnergyUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ReactivePower : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ReactivePowerUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ReactivePowerUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ReactivePowerUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ReactivePowerUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ReactivePower <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ReactivePowerUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ReactivePowerUnit BaseUnit { get; }
    public static ReactivePowerUnit[] Units { get; }
    public static ReactivePower Zero { get; }
    public static ReactivePower AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ReactivePowerUnit Unit { get; }
    public QuantityInfo`1<ReactivePowerUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double GigavoltamperesReactive { get; }
    public double KilovoltamperesReactive { get; }
    public double MegavoltamperesReactive { get; }
    public double VoltamperesReactive { get; }
    private static ReactivePower();
    public ReactivePower(double value, ReactivePowerUnit unit);
    public ReactivePower(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ReactivePowerUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ReactivePowerUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ReactivePowerUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ReactivePower get_Zero();
    public static override ReactivePower get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ReactivePowerUnit get_Unit();
    public sealed virtual QuantityInfo`1<ReactivePowerUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_GigavoltamperesReactive();
    public double get_KilovoltamperesReactive();
    public double get_MegavoltamperesReactive();
    public double get_VoltamperesReactive();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ReactivePowerUnit unit);
    public static string GetAbbreviation(ReactivePowerUnit unit, IFormatProvider provider);
    public static ReactivePower FromGigavoltamperesReactive(double value);
    public static ReactivePower FromKilovoltamperesReactive(double value);
    public static ReactivePower FromMegavoltamperesReactive(double value);
    public static ReactivePower FromVoltamperesReactive(double value);
    public static ReactivePower From(double value, ReactivePowerUnit fromUnit);
    public static ReactivePower Parse(string str);
    public static override ReactivePower Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ReactivePower& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ReactivePower& result);
    public static ReactivePowerUnit ParseUnit(string str);
    public static ReactivePowerUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ReactivePowerUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ReactivePowerUnit& unit);
    public static override ReactivePower op_UnaryNegation(ReactivePower right);
    public static override ReactivePower op_Addition(ReactivePower left, ReactivePower right);
    public static override ReactivePower op_Subtraction(ReactivePower left, ReactivePower right);
    public static ReactivePower op_Multiply(double left, ReactivePower right);
    public static override ReactivePower op_Multiply(ReactivePower left, double right);
    public static override ReactivePower op_Division(ReactivePower left, double right);
    public static double op_Division(ReactivePower left, ReactivePower right);
    public static override bool op_LessThanOrEqual(ReactivePower left, ReactivePower right);
    public static override bool op_GreaterThanOrEqual(ReactivePower left, ReactivePower right);
    public static override bool op_LessThan(ReactivePower left, ReactivePower right);
    public static override bool op_GreaterThan(ReactivePower left, ReactivePower right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ReactivePower other, ReactivePower tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ReactivePower left, ReactivePower right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ReactivePower other, ReactivePower tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ReactivePower left, ReactivePower right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ReactivePower other, ReactivePower tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ReactivePower other, ReactivePower tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ReactivePower other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ReactivePower other);
    [ObsoleteAttribute("Use Equals(ReactivePower other, ReactivePower tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ReactivePower other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ReactivePower other, ReactivePower tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ReactivePowerUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ReactivePower ToUnit(ReactivePowerUnit unit);
    public ReactivePower ToUnit(ReactivePowerUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ReactivePowerUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ReactivePower ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ReactivePowerUnit> UnitsNet.IQuantity<UnitsNet.Units.ReactivePowerUnit>.ToUnit(ReactivePowerUnit unit);
    private sealed virtual override IQuantity`1<ReactivePowerUnit> UnitsNet.IQuantity<UnitsNet.Units.ReactivePowerUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ReciprocalArea : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ReciprocalAreaUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ReciprocalAreaUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ReciprocalAreaUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ReciprocalAreaUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ReciprocalArea <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ReciprocalAreaUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ReciprocalAreaUnit BaseUnit { get; }
    public static ReciprocalAreaUnit[] Units { get; }
    public static ReciprocalArea Zero { get; }
    public static ReciprocalArea AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ReciprocalAreaUnit Unit { get; }
    public QuantityInfo`1<ReciprocalAreaUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double InverseSquareCentimeters { get; }
    public double InverseSquareDecimeters { get; }
    public double InverseSquareFeet { get; }
    public double InverseSquareInches { get; }
    public double InverseSquareKilometers { get; }
    public double InverseSquareMeters { get; }
    public double InverseSquareMicrometers { get; }
    public double InverseSquareMiles { get; }
    public double InverseSquareMillimeters { get; }
    public double InverseSquareYards { get; }
    public double InverseUsSurveySquareFeet { get; }
    private static ReciprocalArea();
    public ReciprocalArea(double value, ReciprocalAreaUnit unit);
    public ReciprocalArea(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ReciprocalAreaUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ReciprocalAreaUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ReciprocalAreaUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ReciprocalArea get_Zero();
    public static override ReciprocalArea get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ReciprocalAreaUnit get_Unit();
    public sealed virtual QuantityInfo`1<ReciprocalAreaUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_InverseSquareCentimeters();
    public double get_InverseSquareDecimeters();
    public double get_InverseSquareFeet();
    public double get_InverseSquareInches();
    public double get_InverseSquareKilometers();
    public double get_InverseSquareMeters();
    public double get_InverseSquareMicrometers();
    public double get_InverseSquareMiles();
    public double get_InverseSquareMillimeters();
    public double get_InverseSquareYards();
    public double get_InverseUsSurveySquareFeet();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ReciprocalAreaUnit unit);
    public static string GetAbbreviation(ReciprocalAreaUnit unit, IFormatProvider provider);
    public static ReciprocalArea FromInverseSquareCentimeters(double value);
    public static ReciprocalArea FromInverseSquareDecimeters(double value);
    public static ReciprocalArea FromInverseSquareFeet(double value);
    public static ReciprocalArea FromInverseSquareInches(double value);
    public static ReciprocalArea FromInverseSquareKilometers(double value);
    public static ReciprocalArea FromInverseSquareMeters(double value);
    public static ReciprocalArea FromInverseSquareMicrometers(double value);
    public static ReciprocalArea FromInverseSquareMiles(double value);
    public static ReciprocalArea FromInverseSquareMillimeters(double value);
    public static ReciprocalArea FromInverseSquareYards(double value);
    public static ReciprocalArea FromInverseUsSurveySquareFeet(double value);
    public static ReciprocalArea From(double value, ReciprocalAreaUnit fromUnit);
    public static ReciprocalArea Parse(string str);
    public static override ReciprocalArea Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ReciprocalArea& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ReciprocalArea& result);
    public static ReciprocalAreaUnit ParseUnit(string str);
    public static ReciprocalAreaUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ReciprocalAreaUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ReciprocalAreaUnit& unit);
    public static override ReciprocalArea op_UnaryNegation(ReciprocalArea right);
    public static override ReciprocalArea op_Addition(ReciprocalArea left, ReciprocalArea right);
    public static override ReciprocalArea op_Subtraction(ReciprocalArea left, ReciprocalArea right);
    public static ReciprocalArea op_Multiply(double left, ReciprocalArea right);
    public static override ReciprocalArea op_Multiply(ReciprocalArea left, double right);
    public static override ReciprocalArea op_Division(ReciprocalArea left, double right);
    public static double op_Division(ReciprocalArea left, ReciprocalArea right);
    public Area Inverse();
    public static override Length op_Multiply(ReciprocalArea reciprocalArea, Volume volume);
    public static override Pressure op_Multiply(ReciprocalArea reciprocalArea, Force force);
    public static override Ratio op_Multiply(ReciprocalArea reciprocalArea, Area area);
    public static override ReciprocalLength op_Multiply(ReciprocalArea reciprocalArea, Length length);
    public static override ReciprocalLength op_Division(ReciprocalArea reciprocalArea, ReciprocalLength reciprocalLength);
    public static override bool op_LessThanOrEqual(ReciprocalArea left, ReciprocalArea right);
    public static override bool op_GreaterThanOrEqual(ReciprocalArea left, ReciprocalArea right);
    public static override bool op_LessThan(ReciprocalArea left, ReciprocalArea right);
    public static override bool op_GreaterThan(ReciprocalArea left, ReciprocalArea right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ReciprocalArea other, ReciprocalArea tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ReciprocalArea left, ReciprocalArea right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ReciprocalArea other, ReciprocalArea tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ReciprocalArea left, ReciprocalArea right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ReciprocalArea other, ReciprocalArea tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ReciprocalArea other, ReciprocalArea tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ReciprocalArea other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ReciprocalArea other);
    [ObsoleteAttribute("Use Equals(ReciprocalArea other, ReciprocalArea tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ReciprocalArea other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ReciprocalArea other, ReciprocalArea tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ReciprocalAreaUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ReciprocalArea ToUnit(ReciprocalAreaUnit unit);
    public ReciprocalArea ToUnit(ReciprocalAreaUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ReciprocalAreaUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ReciprocalArea ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ReciprocalAreaUnit> UnitsNet.IQuantity<UnitsNet.Units.ReciprocalAreaUnit>.ToUnit(ReciprocalAreaUnit unit);
    private sealed virtual override IQuantity`1<ReciprocalAreaUnit> UnitsNet.IQuantity<UnitsNet.Units.ReciprocalAreaUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ReciprocalLength : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ReciprocalLengthUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ReciprocalLengthUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ReciprocalLengthUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ReciprocalLengthUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ReciprocalLength <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ReciprocalLengthUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ReciprocalLengthUnit BaseUnit { get; }
    public static ReciprocalLengthUnit[] Units { get; }
    public static ReciprocalLength Zero { get; }
    public static ReciprocalLength AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ReciprocalLengthUnit Unit { get; }
    public QuantityInfo`1<ReciprocalLengthUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double InverseCentimeters { get; }
    public double InverseFeet { get; }
    public double InverseInches { get; }
    public double InverseMeters { get; }
    public double InverseMicroinches { get; }
    public double InverseMils { get; }
    public double InverseMiles { get; }
    public double InverseMillimeters { get; }
    public double InverseUsSurveyFeet { get; }
    public double InverseYards { get; }
    private static ReciprocalLength();
    public ReciprocalLength(double value, ReciprocalLengthUnit unit);
    public ReciprocalLength(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ReciprocalLengthUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ReciprocalLengthUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ReciprocalLengthUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ReciprocalLength get_Zero();
    public static override ReciprocalLength get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ReciprocalLengthUnit get_Unit();
    public sealed virtual QuantityInfo`1<ReciprocalLengthUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_InverseCentimeters();
    public double get_InverseFeet();
    public double get_InverseInches();
    public double get_InverseMeters();
    public double get_InverseMicroinches();
    public double get_InverseMils();
    public double get_InverseMiles();
    public double get_InverseMillimeters();
    public double get_InverseUsSurveyFeet();
    public double get_InverseYards();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ReciprocalLengthUnit unit);
    public static string GetAbbreviation(ReciprocalLengthUnit unit, IFormatProvider provider);
    public static ReciprocalLength FromInverseCentimeters(double value);
    public static ReciprocalLength FromInverseFeet(double value);
    public static ReciprocalLength FromInverseInches(double value);
    public static ReciprocalLength FromInverseMeters(double value);
    public static ReciprocalLength FromInverseMicroinches(double value);
    public static ReciprocalLength FromInverseMils(double value);
    public static ReciprocalLength FromInverseMiles(double value);
    public static ReciprocalLength FromInverseMillimeters(double value);
    public static ReciprocalLength FromInverseUsSurveyFeet(double value);
    public static ReciprocalLength FromInverseYards(double value);
    public static ReciprocalLength From(double value, ReciprocalLengthUnit fromUnit);
    public static ReciprocalLength Parse(string str);
    public static override ReciprocalLength Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ReciprocalLength& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ReciprocalLength& result);
    public static ReciprocalLengthUnit ParseUnit(string str);
    public static ReciprocalLengthUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ReciprocalLengthUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ReciprocalLengthUnit& unit);
    public static override ReciprocalLength op_UnaryNegation(ReciprocalLength right);
    public static override ReciprocalLength op_Addition(ReciprocalLength left, ReciprocalLength right);
    public static override ReciprocalLength op_Subtraction(ReciprocalLength left, ReciprocalLength right);
    public static ReciprocalLength op_Multiply(double left, ReciprocalLength right);
    public static override ReciprocalLength op_Multiply(ReciprocalLength left, double right);
    public static override ReciprocalLength op_Division(ReciprocalLength left, double right);
    public static double op_Division(ReciprocalLength left, ReciprocalLength right);
    public Length Inverse();
    public static override Area op_Multiply(ReciprocalLength reciprocalLength, Volume volume);
    public static override ForcePerLength op_Multiply(ReciprocalLength reciprocalLength, Force force);
    public static override Length op_Multiply(ReciprocalLength reciprocalLength, Area area);
    public static override Length op_Division(ReciprocalLength reciprocalLength, ReciprocalArea reciprocalArea);
    public static override Pressure op_Multiply(ReciprocalLength reciprocalLength, ForcePerLength forcePerLength);
    public static override ReciprocalArea op_Multiply(ReciprocalLength left, ReciprocalLength right);
    public static override ReciprocalArea op_Division(ReciprocalLength reciprocalLength, Length length);
    public static override bool op_LessThanOrEqual(ReciprocalLength left, ReciprocalLength right);
    public static override bool op_GreaterThanOrEqual(ReciprocalLength left, ReciprocalLength right);
    public static override bool op_LessThan(ReciprocalLength left, ReciprocalLength right);
    public static override bool op_GreaterThan(ReciprocalLength left, ReciprocalLength right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ReciprocalLength other, ReciprocalLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ReciprocalLength left, ReciprocalLength right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ReciprocalLength other, ReciprocalLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ReciprocalLength left, ReciprocalLength right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ReciprocalLength other, ReciprocalLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ReciprocalLength other, ReciprocalLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ReciprocalLength other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ReciprocalLength other);
    [ObsoleteAttribute("Use Equals(ReciprocalLength other, ReciprocalLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ReciprocalLength other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ReciprocalLength other, ReciprocalLength tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ReciprocalLengthUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ReciprocalLength ToUnit(ReciprocalLengthUnit unit);
    public ReciprocalLength ToUnit(ReciprocalLengthUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ReciprocalLengthUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ReciprocalLength ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ReciprocalLengthUnit> UnitsNet.IQuantity<UnitsNet.Units.ReciprocalLengthUnit>.ToUnit(ReciprocalLengthUnit unit);
    private sealed virtual override IQuantity`1<ReciprocalLengthUnit> UnitsNet.IQuantity<UnitsNet.Units.ReciprocalLengthUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.RelativeHumidity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<RelativeHumidityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<RelativeHumidityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static RelativeHumidityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static RelativeHumidityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static RelativeHumidity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<RelativeHumidityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static RelativeHumidityUnit BaseUnit { get; }
    public static RelativeHumidityUnit[] Units { get; }
    public static RelativeHumidity Zero { get; }
    public static RelativeHumidity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public RelativeHumidityUnit Unit { get; }
    public QuantityInfo`1<RelativeHumidityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Percent { get; }
    private static RelativeHumidity();
    public RelativeHumidity(double value, RelativeHumidityUnit unit);
    public RelativeHumidity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<RelativeHumidityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static RelativeHumidityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static RelativeHumidityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override RelativeHumidity get_Zero();
    public static override RelativeHumidity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual RelativeHumidityUnit get_Unit();
    public sealed virtual QuantityInfo`1<RelativeHumidityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Percent();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(RelativeHumidityUnit unit);
    public static string GetAbbreviation(RelativeHumidityUnit unit, IFormatProvider provider);
    public static RelativeHumidity FromPercent(double value);
    public static RelativeHumidity From(double value, RelativeHumidityUnit fromUnit);
    public static RelativeHumidity Parse(string str);
    public static override RelativeHumidity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, RelativeHumidity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, RelativeHumidity& result);
    public static RelativeHumidityUnit ParseUnit(string str);
    public static RelativeHumidityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, RelativeHumidityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, RelativeHumidityUnit& unit);
    public static override RelativeHumidity op_UnaryNegation(RelativeHumidity right);
    public static override RelativeHumidity op_Addition(RelativeHumidity left, RelativeHumidity right);
    public static override RelativeHumidity op_Subtraction(RelativeHumidity left, RelativeHumidity right);
    public static RelativeHumidity op_Multiply(double left, RelativeHumidity right);
    public static override RelativeHumidity op_Multiply(RelativeHumidity left, double right);
    public static override RelativeHumidity op_Division(RelativeHumidity left, double right);
    public static double op_Division(RelativeHumidity left, RelativeHumidity right);
    public static override bool op_LessThanOrEqual(RelativeHumidity left, RelativeHumidity right);
    public static override bool op_GreaterThanOrEqual(RelativeHumidity left, RelativeHumidity right);
    public static override bool op_LessThan(RelativeHumidity left, RelativeHumidity right);
    public static override bool op_GreaterThan(RelativeHumidity left, RelativeHumidity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(RelativeHumidity other, RelativeHumidity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(RelativeHumidity left, RelativeHumidity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(RelativeHumidity other, RelativeHumidity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(RelativeHumidity left, RelativeHumidity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(RelativeHumidity other, RelativeHumidity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(RelativeHumidity other, RelativeHumidity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(RelativeHumidity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(RelativeHumidity other);
    [ObsoleteAttribute("Use Equals(RelativeHumidity other, RelativeHumidity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(RelativeHumidity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(RelativeHumidity other, RelativeHumidity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(RelativeHumidityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public RelativeHumidity ToUnit(RelativeHumidityUnit unit);
    public RelativeHumidity ToUnit(RelativeHumidityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(RelativeHumidityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public RelativeHumidity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<RelativeHumidityUnit> UnitsNet.IQuantity<UnitsNet.Units.RelativeHumidityUnit>.ToUnit(RelativeHumidityUnit unit);
    private sealed virtual override IQuantity`1<RelativeHumidityUnit> UnitsNet.IQuantity<UnitsNet.Units.RelativeHumidityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.RotationalAcceleration : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<RotationalAccelerationUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<RotationalAccelerationUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static RotationalAccelerationUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static RotationalAccelerationUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static RotationalAcceleration <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<RotationalAccelerationUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static RotationalAccelerationUnit BaseUnit { get; }
    public static RotationalAccelerationUnit[] Units { get; }
    public static RotationalAcceleration Zero { get; }
    public static RotationalAcceleration AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public RotationalAccelerationUnit Unit { get; }
    public QuantityInfo`1<RotationalAccelerationUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double DegreesPerSecondSquared { get; }
    public double RadiansPerSecondSquared { get; }
    public double RevolutionsPerMinutePerSecond { get; }
    public double RevolutionsPerSecondSquared { get; }
    private static RotationalAcceleration();
    public RotationalAcceleration(double value, RotationalAccelerationUnit unit);
    public RotationalAcceleration(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<RotationalAccelerationUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static RotationalAccelerationUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static RotationalAccelerationUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override RotationalAcceleration get_Zero();
    public static override RotationalAcceleration get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual RotationalAccelerationUnit get_Unit();
    public sealed virtual QuantityInfo`1<RotationalAccelerationUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_DegreesPerSecondSquared();
    public double get_RadiansPerSecondSquared();
    public double get_RevolutionsPerMinutePerSecond();
    public double get_RevolutionsPerSecondSquared();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(RotationalAccelerationUnit unit);
    public static string GetAbbreviation(RotationalAccelerationUnit unit, IFormatProvider provider);
    public static RotationalAcceleration FromDegreesPerSecondSquared(double value);
    public static RotationalAcceleration FromRadiansPerSecondSquared(double value);
    public static RotationalAcceleration FromRevolutionsPerMinutePerSecond(double value);
    public static RotationalAcceleration FromRevolutionsPerSecondSquared(double value);
    public static RotationalAcceleration From(double value, RotationalAccelerationUnit fromUnit);
    public static RotationalAcceleration Parse(string str);
    public static override RotationalAcceleration Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, RotationalAcceleration& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, RotationalAcceleration& result);
    public static RotationalAccelerationUnit ParseUnit(string str);
    public static RotationalAccelerationUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, RotationalAccelerationUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, RotationalAccelerationUnit& unit);
    public static override RotationalAcceleration op_UnaryNegation(RotationalAcceleration right);
    public static override RotationalAcceleration op_Addition(RotationalAcceleration left, RotationalAcceleration right);
    public static override RotationalAcceleration op_Subtraction(RotationalAcceleration left, RotationalAcceleration right);
    public static RotationalAcceleration op_Multiply(double left, RotationalAcceleration right);
    public static override RotationalAcceleration op_Multiply(RotationalAcceleration left, double right);
    public static override RotationalAcceleration op_Division(RotationalAcceleration left, double right);
    public static double op_Division(RotationalAcceleration left, RotationalAcceleration right);
    public static override bool op_LessThanOrEqual(RotationalAcceleration left, RotationalAcceleration right);
    public static override bool op_GreaterThanOrEqual(RotationalAcceleration left, RotationalAcceleration right);
    public static override bool op_LessThan(RotationalAcceleration left, RotationalAcceleration right);
    public static override bool op_GreaterThan(RotationalAcceleration left, RotationalAcceleration right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(RotationalAcceleration other, RotationalAcceleration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(RotationalAcceleration left, RotationalAcceleration right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(RotationalAcceleration other, RotationalAcceleration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(RotationalAcceleration left, RotationalAcceleration right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(RotationalAcceleration other, RotationalAcceleration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(RotationalAcceleration other, RotationalAcceleration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(RotationalAcceleration other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(RotationalAcceleration other);
    [ObsoleteAttribute("Use Equals(RotationalAcceleration other, RotationalAcceleration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(RotationalAcceleration other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(RotationalAcceleration other, RotationalAcceleration tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(RotationalAccelerationUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public RotationalAcceleration ToUnit(RotationalAccelerationUnit unit);
    public RotationalAcceleration ToUnit(RotationalAccelerationUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(RotationalAccelerationUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public RotationalAcceleration ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<RotationalAccelerationUnit> UnitsNet.IQuantity<UnitsNet.Units.RotationalAccelerationUnit>.ToUnit(RotationalAccelerationUnit unit);
    private sealed virtual override IQuantity`1<RotationalAccelerationUnit> UnitsNet.IQuantity<UnitsNet.Units.RotationalAccelerationUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.RotationalSpeed : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<RotationalSpeedUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<RotationalSpeedUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static RotationalSpeedUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static RotationalSpeedUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static RotationalSpeed <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<RotationalSpeedUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static RotationalSpeedUnit BaseUnit { get; }
    public static RotationalSpeedUnit[] Units { get; }
    public static RotationalSpeed Zero { get; }
    public static RotationalSpeed AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public RotationalSpeedUnit Unit { get; }
    public QuantityInfo`1<RotationalSpeedUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentiradiansPerSecond { get; }
    public double DeciradiansPerSecond { get; }
    public double DegreesPerMinute { get; }
    public double DegreesPerSecond { get; }
    public double MicrodegreesPerSecond { get; }
    public double MicroradiansPerSecond { get; }
    public double MillidegreesPerSecond { get; }
    public double MilliradiansPerSecond { get; }
    public double NanodegreesPerSecond { get; }
    public double NanoradiansPerSecond { get; }
    public double RadiansPerSecond { get; }
    public double RevolutionsPerMinute { get; }
    public double RevolutionsPerSecond { get; }
    private static RotationalSpeed();
    public RotationalSpeed(double value, RotationalSpeedUnit unit);
    public RotationalSpeed(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<RotationalSpeedUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static RotationalSpeedUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static RotationalSpeedUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override RotationalSpeed get_Zero();
    public static override RotationalSpeed get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual RotationalSpeedUnit get_Unit();
    public sealed virtual QuantityInfo`1<RotationalSpeedUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentiradiansPerSecond();
    public double get_DeciradiansPerSecond();
    public double get_DegreesPerMinute();
    public double get_DegreesPerSecond();
    public double get_MicrodegreesPerSecond();
    public double get_MicroradiansPerSecond();
    public double get_MillidegreesPerSecond();
    public double get_MilliradiansPerSecond();
    public double get_NanodegreesPerSecond();
    public double get_NanoradiansPerSecond();
    public double get_RadiansPerSecond();
    public double get_RevolutionsPerMinute();
    public double get_RevolutionsPerSecond();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(RotationalSpeedUnit unit);
    public static string GetAbbreviation(RotationalSpeedUnit unit, IFormatProvider provider);
    public static RotationalSpeed FromCentiradiansPerSecond(double value);
    public static RotationalSpeed FromDeciradiansPerSecond(double value);
    public static RotationalSpeed FromDegreesPerMinute(double value);
    public static RotationalSpeed FromDegreesPerSecond(double value);
    public static RotationalSpeed FromMicrodegreesPerSecond(double value);
    public static RotationalSpeed FromMicroradiansPerSecond(double value);
    public static RotationalSpeed FromMillidegreesPerSecond(double value);
    public static RotationalSpeed FromMilliradiansPerSecond(double value);
    public static RotationalSpeed FromNanodegreesPerSecond(double value);
    public static RotationalSpeed FromNanoradiansPerSecond(double value);
    public static RotationalSpeed FromRadiansPerSecond(double value);
    public static RotationalSpeed FromRevolutionsPerMinute(double value);
    public static RotationalSpeed FromRevolutionsPerSecond(double value);
    public static RotationalSpeed From(double value, RotationalSpeedUnit fromUnit);
    public static RotationalSpeed Parse(string str);
    public static override RotationalSpeed Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, RotationalSpeed& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, RotationalSpeed& result);
    public static RotationalSpeedUnit ParseUnit(string str);
    public static RotationalSpeedUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, RotationalSpeedUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, RotationalSpeedUnit& unit);
    public static override RotationalSpeed op_UnaryNegation(RotationalSpeed right);
    public static override RotationalSpeed op_Addition(RotationalSpeed left, RotationalSpeed right);
    public static override RotationalSpeed op_Subtraction(RotationalSpeed left, RotationalSpeed right);
    public static RotationalSpeed op_Multiply(double left, RotationalSpeed right);
    public static override RotationalSpeed op_Multiply(RotationalSpeed left, double right);
    public static override RotationalSpeed op_Division(RotationalSpeed left, double right);
    public static double op_Division(RotationalSpeed left, RotationalSpeed right);
    public static override Angle op_Multiply(RotationalSpeed rotationalSpeed, Duration duration);
    public static override Power op_Multiply(RotationalSpeed rotationalSpeed, Torque torque);
    public static override bool op_LessThanOrEqual(RotationalSpeed left, RotationalSpeed right);
    public static override bool op_GreaterThanOrEqual(RotationalSpeed left, RotationalSpeed right);
    public static override bool op_LessThan(RotationalSpeed left, RotationalSpeed right);
    public static override bool op_GreaterThan(RotationalSpeed left, RotationalSpeed right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(RotationalSpeed other, RotationalSpeed tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(RotationalSpeed left, RotationalSpeed right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(RotationalSpeed other, RotationalSpeed tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(RotationalSpeed left, RotationalSpeed right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(RotationalSpeed other, RotationalSpeed tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(RotationalSpeed other, RotationalSpeed tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(RotationalSpeed other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(RotationalSpeed other);
    [ObsoleteAttribute("Use Equals(RotationalSpeed other, RotationalSpeed tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(RotationalSpeed other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(RotationalSpeed other, RotationalSpeed tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(RotationalSpeedUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public RotationalSpeed ToUnit(RotationalSpeedUnit unit);
    public RotationalSpeed ToUnit(RotationalSpeedUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(RotationalSpeedUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public RotationalSpeed ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<RotationalSpeedUnit> UnitsNet.IQuantity<UnitsNet.Units.RotationalSpeedUnit>.ToUnit(RotationalSpeedUnit unit);
    private sealed virtual override IQuantity`1<RotationalSpeedUnit> UnitsNet.IQuantity<UnitsNet.Units.RotationalSpeedUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.RotationalStiffness : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<RotationalStiffnessUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<RotationalStiffnessUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static RotationalStiffnessUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static RotationalStiffnessUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static RotationalStiffness <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<RotationalStiffnessUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static RotationalStiffnessUnit BaseUnit { get; }
    public static RotationalStiffnessUnit[] Units { get; }
    public static RotationalStiffness Zero { get; }
    public static RotationalStiffness AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public RotationalStiffnessUnit Unit { get; }
    public QuantityInfo`1<RotationalStiffnessUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentinewtonMetersPerDegree { get; }
    public double CentinewtonMillimetersPerDegree { get; }
    public double CentinewtonMillimetersPerRadian { get; }
    public double DecanewtonMetersPerDegree { get; }
    public double DecanewtonMillimetersPerDegree { get; }
    public double DecanewtonMillimetersPerRadian { get; }
    public double DecinewtonMetersPerDegree { get; }
    public double DecinewtonMillimetersPerDegree { get; }
    public double DecinewtonMillimetersPerRadian { get; }
    public double KilonewtonMetersPerDegree { get; }
    public double KilonewtonMetersPerRadian { get; }
    public double KilonewtonMillimetersPerDegree { get; }
    public double KilonewtonMillimetersPerRadian { get; }
    public double KilopoundForceFeetPerDegrees { get; }
    public double MeganewtonMetersPerDegree { get; }
    public double MeganewtonMetersPerRadian { get; }
    public double MeganewtonMillimetersPerDegree { get; }
    public double MeganewtonMillimetersPerRadian { get; }
    public double MicronewtonMetersPerDegree { get; }
    public double MicronewtonMillimetersPerDegree { get; }
    public double MicronewtonMillimetersPerRadian { get; }
    public double MillinewtonMetersPerDegree { get; }
    public double MillinewtonMillimetersPerDegree { get; }
    public double MillinewtonMillimetersPerRadian { get; }
    public double NanonewtonMetersPerDegree { get; }
    public double NanonewtonMillimetersPerDegree { get; }
    public double NanonewtonMillimetersPerRadian { get; }
    public double NewtonMetersPerDegree { get; }
    public double NewtonMetersPerRadian { get; }
    public double NewtonMillimetersPerDegree { get; }
    public double NewtonMillimetersPerRadian { get; }
    public double PoundForceFeetPerRadian { get; }
    public double PoundForceFeetPerDegrees { get; }
    private static RotationalStiffness();
    public RotationalStiffness(double value, RotationalStiffnessUnit unit);
    public RotationalStiffness(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<RotationalStiffnessUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static RotationalStiffnessUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static RotationalStiffnessUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override RotationalStiffness get_Zero();
    public static override RotationalStiffness get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual RotationalStiffnessUnit get_Unit();
    public sealed virtual QuantityInfo`1<RotationalStiffnessUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentinewtonMetersPerDegree();
    public double get_CentinewtonMillimetersPerDegree();
    public double get_CentinewtonMillimetersPerRadian();
    public double get_DecanewtonMetersPerDegree();
    public double get_DecanewtonMillimetersPerDegree();
    public double get_DecanewtonMillimetersPerRadian();
    public double get_DecinewtonMetersPerDegree();
    public double get_DecinewtonMillimetersPerDegree();
    public double get_DecinewtonMillimetersPerRadian();
    public double get_KilonewtonMetersPerDegree();
    public double get_KilonewtonMetersPerRadian();
    public double get_KilonewtonMillimetersPerDegree();
    public double get_KilonewtonMillimetersPerRadian();
    public double get_KilopoundForceFeetPerDegrees();
    public double get_MeganewtonMetersPerDegree();
    public double get_MeganewtonMetersPerRadian();
    public double get_MeganewtonMillimetersPerDegree();
    public double get_MeganewtonMillimetersPerRadian();
    public double get_MicronewtonMetersPerDegree();
    public double get_MicronewtonMillimetersPerDegree();
    public double get_MicronewtonMillimetersPerRadian();
    public double get_MillinewtonMetersPerDegree();
    public double get_MillinewtonMillimetersPerDegree();
    public double get_MillinewtonMillimetersPerRadian();
    public double get_NanonewtonMetersPerDegree();
    public double get_NanonewtonMillimetersPerDegree();
    public double get_NanonewtonMillimetersPerRadian();
    public double get_NewtonMetersPerDegree();
    public double get_NewtonMetersPerRadian();
    public double get_NewtonMillimetersPerDegree();
    public double get_NewtonMillimetersPerRadian();
    public double get_PoundForceFeetPerRadian();
    public double get_PoundForceFeetPerDegrees();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(RotationalStiffnessUnit unit);
    public static string GetAbbreviation(RotationalStiffnessUnit unit, IFormatProvider provider);
    public static RotationalStiffness FromCentinewtonMetersPerDegree(double value);
    public static RotationalStiffness FromCentinewtonMillimetersPerDegree(double value);
    public static RotationalStiffness FromCentinewtonMillimetersPerRadian(double value);
    public static RotationalStiffness FromDecanewtonMetersPerDegree(double value);
    public static RotationalStiffness FromDecanewtonMillimetersPerDegree(double value);
    public static RotationalStiffness FromDecanewtonMillimetersPerRadian(double value);
    public static RotationalStiffness FromDecinewtonMetersPerDegree(double value);
    public static RotationalStiffness FromDecinewtonMillimetersPerDegree(double value);
    public static RotationalStiffness FromDecinewtonMillimetersPerRadian(double value);
    public static RotationalStiffness FromKilonewtonMetersPerDegree(double value);
    public static RotationalStiffness FromKilonewtonMetersPerRadian(double value);
    public static RotationalStiffness FromKilonewtonMillimetersPerDegree(double value);
    public static RotationalStiffness FromKilonewtonMillimetersPerRadian(double value);
    public static RotationalStiffness FromKilopoundForceFeetPerDegrees(double value);
    public static RotationalStiffness FromMeganewtonMetersPerDegree(double value);
    public static RotationalStiffness FromMeganewtonMetersPerRadian(double value);
    public static RotationalStiffness FromMeganewtonMillimetersPerDegree(double value);
    public static RotationalStiffness FromMeganewtonMillimetersPerRadian(double value);
    public static RotationalStiffness FromMicronewtonMetersPerDegree(double value);
    public static RotationalStiffness FromMicronewtonMillimetersPerDegree(double value);
    public static RotationalStiffness FromMicronewtonMillimetersPerRadian(double value);
    public static RotationalStiffness FromMillinewtonMetersPerDegree(double value);
    public static RotationalStiffness FromMillinewtonMillimetersPerDegree(double value);
    public static RotationalStiffness FromMillinewtonMillimetersPerRadian(double value);
    public static RotationalStiffness FromNanonewtonMetersPerDegree(double value);
    public static RotationalStiffness FromNanonewtonMillimetersPerDegree(double value);
    public static RotationalStiffness FromNanonewtonMillimetersPerRadian(double value);
    public static RotationalStiffness FromNewtonMetersPerDegree(double value);
    public static RotationalStiffness FromNewtonMetersPerRadian(double value);
    public static RotationalStiffness FromNewtonMillimetersPerDegree(double value);
    public static RotationalStiffness FromNewtonMillimetersPerRadian(double value);
    public static RotationalStiffness FromPoundForceFeetPerRadian(double value);
    public static RotationalStiffness FromPoundForceFeetPerDegrees(double value);
    public static RotationalStiffness From(double value, RotationalStiffnessUnit fromUnit);
    public static RotationalStiffness Parse(string str);
    public static override RotationalStiffness Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, RotationalStiffness& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, RotationalStiffness& result);
    public static RotationalStiffnessUnit ParseUnit(string str);
    public static RotationalStiffnessUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, RotationalStiffnessUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, RotationalStiffnessUnit& unit);
    public static override RotationalStiffness op_UnaryNegation(RotationalStiffness right);
    public static override RotationalStiffness op_Addition(RotationalStiffness left, RotationalStiffness right);
    public static override RotationalStiffness op_Subtraction(RotationalStiffness left, RotationalStiffness right);
    public static RotationalStiffness op_Multiply(double left, RotationalStiffness right);
    public static override RotationalStiffness op_Multiply(RotationalStiffness left, double right);
    public static override RotationalStiffness op_Division(RotationalStiffness left, double right);
    public static double op_Division(RotationalStiffness left, RotationalStiffness right);
    public static override Length op_Division(RotationalStiffness rotationalStiffness, RotationalStiffnessPerLength rotationalStiffnessPerLength);
    public static override RotationalStiffnessPerLength op_Division(RotationalStiffness rotationalStiffness, Length length);
    public static override Torque op_Multiply(RotationalStiffness rotationalStiffness, Angle angle);
    public static override bool op_LessThanOrEqual(RotationalStiffness left, RotationalStiffness right);
    public static override bool op_GreaterThanOrEqual(RotationalStiffness left, RotationalStiffness right);
    public static override bool op_LessThan(RotationalStiffness left, RotationalStiffness right);
    public static override bool op_GreaterThan(RotationalStiffness left, RotationalStiffness right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(RotationalStiffness other, RotationalStiffness tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(RotationalStiffness left, RotationalStiffness right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(RotationalStiffness other, RotationalStiffness tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(RotationalStiffness left, RotationalStiffness right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(RotationalStiffness other, RotationalStiffness tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(RotationalStiffness other, RotationalStiffness tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(RotationalStiffness other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(RotationalStiffness other);
    [ObsoleteAttribute("Use Equals(RotationalStiffness other, RotationalStiffness tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(RotationalStiffness other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(RotationalStiffness other, RotationalStiffness tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(RotationalStiffnessUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public RotationalStiffness ToUnit(RotationalStiffnessUnit unit);
    public RotationalStiffness ToUnit(RotationalStiffnessUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(RotationalStiffnessUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public RotationalStiffness ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<RotationalStiffnessUnit> UnitsNet.IQuantity<UnitsNet.Units.RotationalStiffnessUnit>.ToUnit(RotationalStiffnessUnit unit);
    private sealed virtual override IQuantity`1<RotationalStiffnessUnit> UnitsNet.IQuantity<UnitsNet.Units.RotationalStiffnessUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.RotationalStiffnessPerLength : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<RotationalStiffnessPerLengthUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<RotationalStiffnessPerLengthUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static RotationalStiffnessPerLengthUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static RotationalStiffnessPerLengthUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static RotationalStiffnessPerLength <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<RotationalStiffnessPerLengthUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static RotationalStiffnessPerLengthUnit BaseUnit { get; }
    public static RotationalStiffnessPerLengthUnit[] Units { get; }
    public static RotationalStiffnessPerLength Zero { get; }
    public static RotationalStiffnessPerLength AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public RotationalStiffnessPerLengthUnit Unit { get; }
    public QuantityInfo`1<RotationalStiffnessPerLengthUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double KilonewtonMetersPerRadianPerMeter { get; }
    public double KilopoundForceFeetPerDegreesPerFeet { get; }
    public double MeganewtonMetersPerRadianPerMeter { get; }
    public double NewtonMetersPerRadianPerMeter { get; }
    public double PoundForceFeetPerDegreesPerFeet { get; }
    private static RotationalStiffnessPerLength();
    public RotationalStiffnessPerLength(double value, RotationalStiffnessPerLengthUnit unit);
    public RotationalStiffnessPerLength(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<RotationalStiffnessPerLengthUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static RotationalStiffnessPerLengthUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static RotationalStiffnessPerLengthUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override RotationalStiffnessPerLength get_Zero();
    public static override RotationalStiffnessPerLength get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual RotationalStiffnessPerLengthUnit get_Unit();
    public sealed virtual QuantityInfo`1<RotationalStiffnessPerLengthUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_KilonewtonMetersPerRadianPerMeter();
    public double get_KilopoundForceFeetPerDegreesPerFeet();
    public double get_MeganewtonMetersPerRadianPerMeter();
    public double get_NewtonMetersPerRadianPerMeter();
    public double get_PoundForceFeetPerDegreesPerFeet();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(RotationalStiffnessPerLengthUnit unit);
    public static string GetAbbreviation(RotationalStiffnessPerLengthUnit unit, IFormatProvider provider);
    public static RotationalStiffnessPerLength FromKilonewtonMetersPerRadianPerMeter(double value);
    public static RotationalStiffnessPerLength FromKilopoundForceFeetPerDegreesPerFeet(double value);
    public static RotationalStiffnessPerLength FromMeganewtonMetersPerRadianPerMeter(double value);
    public static RotationalStiffnessPerLength FromNewtonMetersPerRadianPerMeter(double value);
    public static RotationalStiffnessPerLength FromPoundForceFeetPerDegreesPerFeet(double value);
    public static RotationalStiffnessPerLength From(double value, RotationalStiffnessPerLengthUnit fromUnit);
    public static RotationalStiffnessPerLength Parse(string str);
    public static override RotationalStiffnessPerLength Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, RotationalStiffnessPerLength& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, RotationalStiffnessPerLength& result);
    public static RotationalStiffnessPerLengthUnit ParseUnit(string str);
    public static RotationalStiffnessPerLengthUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, RotationalStiffnessPerLengthUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, RotationalStiffnessPerLengthUnit& unit);
    public static override RotationalStiffnessPerLength op_UnaryNegation(RotationalStiffnessPerLength right);
    public static override RotationalStiffnessPerLength op_Addition(RotationalStiffnessPerLength left, RotationalStiffnessPerLength right);
    public static override RotationalStiffnessPerLength op_Subtraction(RotationalStiffnessPerLength left, RotationalStiffnessPerLength right);
    public static RotationalStiffnessPerLength op_Multiply(double left, RotationalStiffnessPerLength right);
    public static override RotationalStiffnessPerLength op_Multiply(RotationalStiffnessPerLength left, double right);
    public static override RotationalStiffnessPerLength op_Division(RotationalStiffnessPerLength left, double right);
    public static double op_Division(RotationalStiffnessPerLength left, RotationalStiffnessPerLength right);
    public static override RotationalStiffness op_Multiply(RotationalStiffnessPerLength rotationalStiffnessPerLength, Length length);
    public static override bool op_LessThanOrEqual(RotationalStiffnessPerLength left, RotationalStiffnessPerLength right);
    public static override bool op_GreaterThanOrEqual(RotationalStiffnessPerLength left, RotationalStiffnessPerLength right);
    public static override bool op_LessThan(RotationalStiffnessPerLength left, RotationalStiffnessPerLength right);
    public static override bool op_GreaterThan(RotationalStiffnessPerLength left, RotationalStiffnessPerLength right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(RotationalStiffnessPerLength other, RotationalStiffnessPerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(RotationalStiffnessPerLength left, RotationalStiffnessPerLength right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(RotationalStiffnessPerLength other, RotationalStiffnessPerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(RotationalStiffnessPerLength left, RotationalStiffnessPerLength right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(RotationalStiffnessPerLength other, RotationalStiffnessPerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(RotationalStiffnessPerLength other, RotationalStiffnessPerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(RotationalStiffnessPerLength other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(RotationalStiffnessPerLength other);
    [ObsoleteAttribute("Use Equals(RotationalStiffnessPerLength other, RotationalStiffnessPerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(RotationalStiffnessPerLength other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(RotationalStiffnessPerLength other, RotationalStiffnessPerLength tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(RotationalStiffnessPerLengthUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public RotationalStiffnessPerLength ToUnit(RotationalStiffnessPerLengthUnit unit);
    public RotationalStiffnessPerLength ToUnit(RotationalStiffnessPerLengthUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(RotationalStiffnessPerLengthUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public RotationalStiffnessPerLength ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<RotationalStiffnessPerLengthUnit> UnitsNet.IQuantity<UnitsNet.Units.RotationalStiffnessPerLengthUnit>.ToUnit(RotationalStiffnessPerLengthUnit unit);
    private sealed virtual override IQuantity`1<RotationalStiffnessPerLengthUnit> UnitsNet.IQuantity<UnitsNet.Units.RotationalStiffnessPerLengthUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Scalar : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ScalarUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ScalarUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ScalarUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ScalarUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Scalar <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ScalarUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ScalarUnit BaseUnit { get; }
    public static ScalarUnit[] Units { get; }
    public static Scalar Zero { get; }
    public static Scalar AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ScalarUnit Unit { get; }
    public QuantityInfo`1<ScalarUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Amount { get; }
    private static Scalar();
    public Scalar(double value, ScalarUnit unit);
    public Scalar(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ScalarUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ScalarUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ScalarUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Scalar get_Zero();
    public static override Scalar get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ScalarUnit get_Unit();
    public sealed virtual QuantityInfo`1<ScalarUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Amount();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ScalarUnit unit);
    public static string GetAbbreviation(ScalarUnit unit, IFormatProvider provider);
    public static Scalar FromAmount(double value);
    public static Scalar From(double value, ScalarUnit fromUnit);
    public static Scalar Parse(string str);
    public static override Scalar Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Scalar& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Scalar& result);
    public static ScalarUnit ParseUnit(string str);
    public static ScalarUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ScalarUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ScalarUnit& unit);
    public static override Scalar op_UnaryNegation(Scalar right);
    public static override Scalar op_Addition(Scalar left, Scalar right);
    public static override Scalar op_Subtraction(Scalar left, Scalar right);
    public static Scalar op_Multiply(double left, Scalar right);
    public static override Scalar op_Multiply(Scalar left, double right);
    public static override Scalar op_Division(Scalar left, double right);
    public static double op_Division(Scalar left, Scalar right);
    public static override bool op_LessThanOrEqual(Scalar left, Scalar right);
    public static override bool op_GreaterThanOrEqual(Scalar left, Scalar right);
    public static override bool op_LessThan(Scalar left, Scalar right);
    public static override bool op_GreaterThan(Scalar left, Scalar right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Scalar other, Scalar tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Scalar left, Scalar right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Scalar other, Scalar tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Scalar left, Scalar right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Scalar other, Scalar tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Scalar other, Scalar tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Scalar other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Scalar other);
    [ObsoleteAttribute("Use Equals(Scalar other, Scalar tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Scalar other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Scalar other, Scalar tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ScalarUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Scalar ToUnit(ScalarUnit unit);
    public Scalar ToUnit(ScalarUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ScalarUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Scalar ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ScalarUnit> UnitsNet.IQuantity<UnitsNet.Units.ScalarUnit>.ToUnit(ScalarUnit unit);
    private sealed virtual override IQuantity`1<ScalarUnit> UnitsNet.IQuantity<UnitsNet.Units.ScalarUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.SolidAngle : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<SolidAngleUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<SolidAngleUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static SolidAngleUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static SolidAngleUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static SolidAngle <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<SolidAngleUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static SolidAngleUnit BaseUnit { get; }
    public static SolidAngleUnit[] Units { get; }
    public static SolidAngle Zero { get; }
    public static SolidAngle AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public SolidAngleUnit Unit { get; }
    public QuantityInfo`1<SolidAngleUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double Steradians { get; }
    private static SolidAngle();
    public SolidAngle(double value, SolidAngleUnit unit);
    public SolidAngle(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<SolidAngleUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static SolidAngleUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static SolidAngleUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override SolidAngle get_Zero();
    public static override SolidAngle get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual SolidAngleUnit get_Unit();
    public sealed virtual QuantityInfo`1<SolidAngleUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_Steradians();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(SolidAngleUnit unit);
    public static string GetAbbreviation(SolidAngleUnit unit, IFormatProvider provider);
    public static SolidAngle FromSteradians(double value);
    public static SolidAngle From(double value, SolidAngleUnit fromUnit);
    public static SolidAngle Parse(string str);
    public static override SolidAngle Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, SolidAngle& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, SolidAngle& result);
    public static SolidAngleUnit ParseUnit(string str);
    public static SolidAngleUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, SolidAngleUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, SolidAngleUnit& unit);
    public static override SolidAngle op_UnaryNegation(SolidAngle right);
    public static override SolidAngle op_Addition(SolidAngle left, SolidAngle right);
    public static override SolidAngle op_Subtraction(SolidAngle left, SolidAngle right);
    public static SolidAngle op_Multiply(double left, SolidAngle right);
    public static override SolidAngle op_Multiply(SolidAngle left, double right);
    public static override SolidAngle op_Division(SolidAngle left, double right);
    public static double op_Division(SolidAngle left, SolidAngle right);
    public static override bool op_LessThanOrEqual(SolidAngle left, SolidAngle right);
    public static override bool op_GreaterThanOrEqual(SolidAngle left, SolidAngle right);
    public static override bool op_LessThan(SolidAngle left, SolidAngle right);
    public static override bool op_GreaterThan(SolidAngle left, SolidAngle right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(SolidAngle other, SolidAngle tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(SolidAngle left, SolidAngle right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(SolidAngle other, SolidAngle tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(SolidAngle left, SolidAngle right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(SolidAngle other, SolidAngle tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(SolidAngle other, SolidAngle tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(SolidAngle other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(SolidAngle other);
    [ObsoleteAttribute("Use Equals(SolidAngle other, SolidAngle tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(SolidAngle other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(SolidAngle other, SolidAngle tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(SolidAngleUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public SolidAngle ToUnit(SolidAngleUnit unit);
    public SolidAngle ToUnit(SolidAngleUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(SolidAngleUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public SolidAngle ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<SolidAngleUnit> UnitsNet.IQuantity<UnitsNet.Units.SolidAngleUnit>.ToUnit(SolidAngleUnit unit);
    private sealed virtual override IQuantity`1<SolidAngleUnit> UnitsNet.IQuantity<UnitsNet.Units.SolidAngleUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.SpecificEnergy : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<SpecificEnergyUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<SpecificEnergyUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpecificEnergyUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpecificEnergyUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpecificEnergy <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<SpecificEnergyUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static SpecificEnergyUnit BaseUnit { get; }
    public static SpecificEnergyUnit[] Units { get; }
    public static SpecificEnergy Zero { get; }
    public static SpecificEnergy AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public SpecificEnergyUnit Unit { get; }
    public QuantityInfo`1<SpecificEnergyUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double BtuPerPound { get; }
    public double CaloriesPerGram { get; }
    public double GigawattDaysPerKilogram { get; }
    public double GigawattDaysPerShortTon { get; }
    public double GigawattDaysPerTonne { get; }
    public double GigawattHoursPerKilogram { get; }
    public double GigawattHoursPerPound { get; }
    public double JoulesPerKilogram { get; }
    public double KilocaloriesPerGram { get; }
    public double KilojoulesPerKilogram { get; }
    public double KilowattDaysPerKilogram { get; }
    public double KilowattDaysPerShortTon { get; }
    public double KilowattDaysPerTonne { get; }
    public double KilowattHoursPerKilogram { get; }
    public double KilowattHoursPerPound { get; }
    public double MegajoulesPerKilogram { get; }
    public double MegaJoulesPerTonne { get; }
    public double MegawattDaysPerKilogram { get; }
    public double MegawattDaysPerShortTon { get; }
    public double MegawattDaysPerTonne { get; }
    public double MegawattHoursPerKilogram { get; }
    public double MegawattHoursPerPound { get; }
    public double TerawattDaysPerKilogram { get; }
    public double TerawattDaysPerShortTon { get; }
    public double TerawattDaysPerTonne { get; }
    public double WattDaysPerKilogram { get; }
    public double WattDaysPerShortTon { get; }
    public double WattDaysPerTonne { get; }
    public double WattHoursPerKilogram { get; }
    public double WattHoursPerPound { get; }
    private static SpecificEnergy();
    public SpecificEnergy(double value, SpecificEnergyUnit unit);
    public SpecificEnergy(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<SpecificEnergyUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static SpecificEnergyUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static SpecificEnergyUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override SpecificEnergy get_Zero();
    public static override SpecificEnergy get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual SpecificEnergyUnit get_Unit();
    public sealed virtual QuantityInfo`1<SpecificEnergyUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_BtuPerPound();
    public double get_CaloriesPerGram();
    public double get_GigawattDaysPerKilogram();
    public double get_GigawattDaysPerShortTon();
    public double get_GigawattDaysPerTonne();
    public double get_GigawattHoursPerKilogram();
    public double get_GigawattHoursPerPound();
    public double get_JoulesPerKilogram();
    public double get_KilocaloriesPerGram();
    public double get_KilojoulesPerKilogram();
    public double get_KilowattDaysPerKilogram();
    public double get_KilowattDaysPerShortTon();
    public double get_KilowattDaysPerTonne();
    public double get_KilowattHoursPerKilogram();
    public double get_KilowattHoursPerPound();
    public double get_MegajoulesPerKilogram();
    public double get_MegaJoulesPerTonne();
    public double get_MegawattDaysPerKilogram();
    public double get_MegawattDaysPerShortTon();
    public double get_MegawattDaysPerTonne();
    public double get_MegawattHoursPerKilogram();
    public double get_MegawattHoursPerPound();
    public double get_TerawattDaysPerKilogram();
    public double get_TerawattDaysPerShortTon();
    public double get_TerawattDaysPerTonne();
    public double get_WattDaysPerKilogram();
    public double get_WattDaysPerShortTon();
    public double get_WattDaysPerTonne();
    public double get_WattHoursPerKilogram();
    public double get_WattHoursPerPound();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(SpecificEnergyUnit unit);
    public static string GetAbbreviation(SpecificEnergyUnit unit, IFormatProvider provider);
    public static SpecificEnergy FromBtuPerPound(double value);
    public static SpecificEnergy FromCaloriesPerGram(double value);
    public static SpecificEnergy FromGigawattDaysPerKilogram(double value);
    public static SpecificEnergy FromGigawattDaysPerShortTon(double value);
    public static SpecificEnergy FromGigawattDaysPerTonne(double value);
    public static SpecificEnergy FromGigawattHoursPerKilogram(double value);
    public static SpecificEnergy FromGigawattHoursPerPound(double value);
    public static SpecificEnergy FromJoulesPerKilogram(double value);
    public static SpecificEnergy FromKilocaloriesPerGram(double value);
    public static SpecificEnergy FromKilojoulesPerKilogram(double value);
    public static SpecificEnergy FromKilowattDaysPerKilogram(double value);
    public static SpecificEnergy FromKilowattDaysPerShortTon(double value);
    public static SpecificEnergy FromKilowattDaysPerTonne(double value);
    public static SpecificEnergy FromKilowattHoursPerKilogram(double value);
    public static SpecificEnergy FromKilowattHoursPerPound(double value);
    public static SpecificEnergy FromMegajoulesPerKilogram(double value);
    public static SpecificEnergy FromMegaJoulesPerTonne(double value);
    public static SpecificEnergy FromMegawattDaysPerKilogram(double value);
    public static SpecificEnergy FromMegawattDaysPerShortTon(double value);
    public static SpecificEnergy FromMegawattDaysPerTonne(double value);
    public static SpecificEnergy FromMegawattHoursPerKilogram(double value);
    public static SpecificEnergy FromMegawattHoursPerPound(double value);
    public static SpecificEnergy FromTerawattDaysPerKilogram(double value);
    public static SpecificEnergy FromTerawattDaysPerShortTon(double value);
    public static SpecificEnergy FromTerawattDaysPerTonne(double value);
    public static SpecificEnergy FromWattDaysPerKilogram(double value);
    public static SpecificEnergy FromWattDaysPerShortTon(double value);
    public static SpecificEnergy FromWattDaysPerTonne(double value);
    public static SpecificEnergy FromWattHoursPerKilogram(double value);
    public static SpecificEnergy FromWattHoursPerPound(double value);
    public static SpecificEnergy From(double value, SpecificEnergyUnit fromUnit);
    public static SpecificEnergy Parse(string str);
    public static override SpecificEnergy Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, SpecificEnergy& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, SpecificEnergy& result);
    public static SpecificEnergyUnit ParseUnit(string str);
    public static SpecificEnergyUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, SpecificEnergyUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, SpecificEnergyUnit& unit);
    public static override SpecificEnergy op_UnaryNegation(SpecificEnergy right);
    public static override SpecificEnergy op_Addition(SpecificEnergy left, SpecificEnergy right);
    public static override SpecificEnergy op_Subtraction(SpecificEnergy left, SpecificEnergy right);
    public static SpecificEnergy op_Multiply(double left, SpecificEnergy right);
    public static override SpecificEnergy op_Multiply(SpecificEnergy left, double right);
    public static override SpecificEnergy op_Division(SpecificEnergy left, double right);
    public static double op_Division(SpecificEnergy left, SpecificEnergy right);
    public static BrakeSpecificFuelConsumption op_Division(double value, SpecificEnergy specificEnergy);
    public static override Energy op_Multiply(SpecificEnergy specificEnergy, Mass mass);
    public static override Power op_Multiply(SpecificEnergy specificEnergy, MassFlow massFlow);
    public static override SpecificEntropy op_Division(SpecificEnergy specificEnergy, TemperatureDelta temperatureDelta);
    public static override Speed op_Division(SpecificEnergy specificEnergy, Speed speed);
    public static override TemperatureDelta op_Division(SpecificEnergy specificEnergy, SpecificEntropy specificEntropy);
    public static override double op_Multiply(SpecificEnergy specificEnergy, BrakeSpecificFuelConsumption brakeSpecificFuelConsumption);
    public static override bool op_LessThanOrEqual(SpecificEnergy left, SpecificEnergy right);
    public static override bool op_GreaterThanOrEqual(SpecificEnergy left, SpecificEnergy right);
    public static override bool op_LessThan(SpecificEnergy left, SpecificEnergy right);
    public static override bool op_GreaterThan(SpecificEnergy left, SpecificEnergy right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(SpecificEnergy other, SpecificEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(SpecificEnergy left, SpecificEnergy right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(SpecificEnergy other, SpecificEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(SpecificEnergy left, SpecificEnergy right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(SpecificEnergy other, SpecificEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(SpecificEnergy other, SpecificEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(SpecificEnergy other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(SpecificEnergy other);
    [ObsoleteAttribute("Use Equals(SpecificEnergy other, SpecificEnergy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(SpecificEnergy other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(SpecificEnergy other, SpecificEnergy tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(SpecificEnergyUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public SpecificEnergy ToUnit(SpecificEnergyUnit unit);
    public SpecificEnergy ToUnit(SpecificEnergyUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(SpecificEnergyUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public SpecificEnergy ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<SpecificEnergyUnit> UnitsNet.IQuantity<UnitsNet.Units.SpecificEnergyUnit>.ToUnit(SpecificEnergyUnit unit);
    private sealed virtual override IQuantity`1<SpecificEnergyUnit> UnitsNet.IQuantity<UnitsNet.Units.SpecificEnergyUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.SpecificEntropy : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<SpecificEntropyUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<SpecificEntropyUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpecificEntropyUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpecificEntropyUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpecificEntropy <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<SpecificEntropyUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static SpecificEntropyUnit BaseUnit { get; }
    public static SpecificEntropyUnit[] Units { get; }
    public static SpecificEntropy Zero { get; }
    public static SpecificEntropy AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public SpecificEntropyUnit Unit { get; }
    public QuantityInfo`1<SpecificEntropyUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double BtusPerPoundFahrenheit { get; }
    public double CaloriesPerGramKelvin { get; }
    public double JoulesPerKilogramDegreeCelsius { get; }
    public double JoulesPerKilogramKelvin { get; }
    public double KilocaloriesPerGramKelvin { get; }
    public double KilojoulesPerKilogramDegreeCelsius { get; }
    public double KilojoulesPerKilogramKelvin { get; }
    public double MegajoulesPerKilogramDegreeCelsius { get; }
    public double MegajoulesPerKilogramKelvin { get; }
    private static SpecificEntropy();
    public SpecificEntropy(double value, SpecificEntropyUnit unit);
    public SpecificEntropy(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<SpecificEntropyUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static SpecificEntropyUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static SpecificEntropyUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override SpecificEntropy get_Zero();
    public static override SpecificEntropy get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual SpecificEntropyUnit get_Unit();
    public sealed virtual QuantityInfo`1<SpecificEntropyUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_BtusPerPoundFahrenheit();
    public double get_CaloriesPerGramKelvin();
    public double get_JoulesPerKilogramDegreeCelsius();
    public double get_JoulesPerKilogramKelvin();
    public double get_KilocaloriesPerGramKelvin();
    public double get_KilojoulesPerKilogramDegreeCelsius();
    public double get_KilojoulesPerKilogramKelvin();
    public double get_MegajoulesPerKilogramDegreeCelsius();
    public double get_MegajoulesPerKilogramKelvin();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(SpecificEntropyUnit unit);
    public static string GetAbbreviation(SpecificEntropyUnit unit, IFormatProvider provider);
    public static SpecificEntropy FromBtusPerPoundFahrenheit(double value);
    public static SpecificEntropy FromCaloriesPerGramKelvin(double value);
    public static SpecificEntropy FromJoulesPerKilogramDegreeCelsius(double value);
    public static SpecificEntropy FromJoulesPerKilogramKelvin(double value);
    public static SpecificEntropy FromKilocaloriesPerGramKelvin(double value);
    public static SpecificEntropy FromKilojoulesPerKilogramDegreeCelsius(double value);
    public static SpecificEntropy FromKilojoulesPerKilogramKelvin(double value);
    public static SpecificEntropy FromMegajoulesPerKilogramDegreeCelsius(double value);
    public static SpecificEntropy FromMegajoulesPerKilogramKelvin(double value);
    public static SpecificEntropy From(double value, SpecificEntropyUnit fromUnit);
    public static SpecificEntropy Parse(string str);
    public static override SpecificEntropy Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, SpecificEntropy& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, SpecificEntropy& result);
    public static SpecificEntropyUnit ParseUnit(string str);
    public static SpecificEntropyUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, SpecificEntropyUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, SpecificEntropyUnit& unit);
    public static override SpecificEntropy op_UnaryNegation(SpecificEntropy right);
    public static override SpecificEntropy op_Addition(SpecificEntropy left, SpecificEntropy right);
    public static override SpecificEntropy op_Subtraction(SpecificEntropy left, SpecificEntropy right);
    public static SpecificEntropy op_Multiply(double left, SpecificEntropy right);
    public static override SpecificEntropy op_Multiply(SpecificEntropy left, double right);
    public static override SpecificEntropy op_Division(SpecificEntropy left, double right);
    public static double op_Division(SpecificEntropy left, SpecificEntropy right);
    public static override Entropy op_Multiply(SpecificEntropy specificEntropy, Mass mass);
    public static override SpecificEnergy op_Multiply(SpecificEntropy specificEntropy, TemperatureDelta temperatureDelta);
    public static override bool op_LessThanOrEqual(SpecificEntropy left, SpecificEntropy right);
    public static override bool op_GreaterThanOrEqual(SpecificEntropy left, SpecificEntropy right);
    public static override bool op_LessThan(SpecificEntropy left, SpecificEntropy right);
    public static override bool op_GreaterThan(SpecificEntropy left, SpecificEntropy right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(SpecificEntropy other, SpecificEntropy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(SpecificEntropy left, SpecificEntropy right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(SpecificEntropy other, SpecificEntropy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(SpecificEntropy left, SpecificEntropy right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(SpecificEntropy other, SpecificEntropy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(SpecificEntropy other, SpecificEntropy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(SpecificEntropy other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(SpecificEntropy other);
    [ObsoleteAttribute("Use Equals(SpecificEntropy other, SpecificEntropy tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(SpecificEntropy other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(SpecificEntropy other, SpecificEntropy tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(SpecificEntropyUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public SpecificEntropy ToUnit(SpecificEntropyUnit unit);
    public SpecificEntropy ToUnit(SpecificEntropyUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(SpecificEntropyUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public SpecificEntropy ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<SpecificEntropyUnit> UnitsNet.IQuantity<UnitsNet.Units.SpecificEntropyUnit>.ToUnit(SpecificEntropyUnit unit);
    private sealed virtual override IQuantity`1<SpecificEntropyUnit> UnitsNet.IQuantity<UnitsNet.Units.SpecificEntropyUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.SpecificFuelConsumption : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<SpecificFuelConsumptionUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<SpecificFuelConsumptionUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpecificFuelConsumptionUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpecificFuelConsumptionUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpecificFuelConsumption <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<SpecificFuelConsumptionUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static SpecificFuelConsumptionUnit BaseUnit { get; }
    public static SpecificFuelConsumptionUnit[] Units { get; }
    public static SpecificFuelConsumption Zero { get; }
    public static SpecificFuelConsumption AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public SpecificFuelConsumptionUnit Unit { get; }
    public QuantityInfo`1<SpecificFuelConsumptionUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double GramsPerKiloNewtonSecond { get; }
    public double KilogramsPerKilogramForceHour { get; }
    public double KilogramsPerKiloNewtonSecond { get; }
    public double PoundsMassPerPoundForceHour { get; }
    private static SpecificFuelConsumption();
    public SpecificFuelConsumption(double value, SpecificFuelConsumptionUnit unit);
    public SpecificFuelConsumption(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<SpecificFuelConsumptionUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static SpecificFuelConsumptionUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static SpecificFuelConsumptionUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override SpecificFuelConsumption get_Zero();
    public static override SpecificFuelConsumption get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual SpecificFuelConsumptionUnit get_Unit();
    public sealed virtual QuantityInfo`1<SpecificFuelConsumptionUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_GramsPerKiloNewtonSecond();
    public double get_KilogramsPerKilogramForceHour();
    public double get_KilogramsPerKiloNewtonSecond();
    public double get_PoundsMassPerPoundForceHour();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(SpecificFuelConsumptionUnit unit);
    public static string GetAbbreviation(SpecificFuelConsumptionUnit unit, IFormatProvider provider);
    public static SpecificFuelConsumption FromGramsPerKiloNewtonSecond(double value);
    public static SpecificFuelConsumption FromKilogramsPerKilogramForceHour(double value);
    public static SpecificFuelConsumption FromKilogramsPerKiloNewtonSecond(double value);
    public static SpecificFuelConsumption FromPoundsMassPerPoundForceHour(double value);
    public static SpecificFuelConsumption From(double value, SpecificFuelConsumptionUnit fromUnit);
    public static SpecificFuelConsumption Parse(string str);
    public static override SpecificFuelConsumption Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, SpecificFuelConsumption& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, SpecificFuelConsumption& result);
    public static SpecificFuelConsumptionUnit ParseUnit(string str);
    public static SpecificFuelConsumptionUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, SpecificFuelConsumptionUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, SpecificFuelConsumptionUnit& unit);
    public static override SpecificFuelConsumption op_UnaryNegation(SpecificFuelConsumption right);
    public static override SpecificFuelConsumption op_Addition(SpecificFuelConsumption left, SpecificFuelConsumption right);
    public static override SpecificFuelConsumption op_Subtraction(SpecificFuelConsumption left, SpecificFuelConsumption right);
    public static SpecificFuelConsumption op_Multiply(double left, SpecificFuelConsumption right);
    public static override SpecificFuelConsumption op_Multiply(SpecificFuelConsumption left, double right);
    public static override SpecificFuelConsumption op_Division(SpecificFuelConsumption left, double right);
    public static double op_Division(SpecificFuelConsumption left, SpecificFuelConsumption right);
    public static override bool op_LessThanOrEqual(SpecificFuelConsumption left, SpecificFuelConsumption right);
    public static override bool op_GreaterThanOrEqual(SpecificFuelConsumption left, SpecificFuelConsumption right);
    public static override bool op_LessThan(SpecificFuelConsumption left, SpecificFuelConsumption right);
    public static override bool op_GreaterThan(SpecificFuelConsumption left, SpecificFuelConsumption right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(SpecificFuelConsumption other, SpecificFuelConsumption tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(SpecificFuelConsumption left, SpecificFuelConsumption right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(SpecificFuelConsumption other, SpecificFuelConsumption tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(SpecificFuelConsumption left, SpecificFuelConsumption right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(SpecificFuelConsumption other, SpecificFuelConsumption tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(SpecificFuelConsumption other, SpecificFuelConsumption tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(SpecificFuelConsumption other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(SpecificFuelConsumption other);
    [ObsoleteAttribute("Use Equals(SpecificFuelConsumption other, SpecificFuelConsumption tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(SpecificFuelConsumption other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(SpecificFuelConsumption other, SpecificFuelConsumption tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(SpecificFuelConsumptionUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public SpecificFuelConsumption ToUnit(SpecificFuelConsumptionUnit unit);
    public SpecificFuelConsumption ToUnit(SpecificFuelConsumptionUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(SpecificFuelConsumptionUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public SpecificFuelConsumption ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<SpecificFuelConsumptionUnit> UnitsNet.IQuantity<UnitsNet.Units.SpecificFuelConsumptionUnit>.ToUnit(SpecificFuelConsumptionUnit unit);
    private sealed virtual override IQuantity`1<SpecificFuelConsumptionUnit> UnitsNet.IQuantity<UnitsNet.Units.SpecificFuelConsumptionUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.SpecificVolume : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<SpecificVolumeUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<SpecificVolumeUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpecificVolumeUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpecificVolumeUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpecificVolume <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<SpecificVolumeUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static SpecificVolumeUnit BaseUnit { get; }
    public static SpecificVolumeUnit[] Units { get; }
    public static SpecificVolume Zero { get; }
    public static SpecificVolume AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public SpecificVolumeUnit Unit { get; }
    public QuantityInfo`1<SpecificVolumeUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CubicFeetPerPound { get; }
    public double CubicMetersPerKilogram { get; }
    public double MillicubicMetersPerKilogram { get; }
    private static SpecificVolume();
    public SpecificVolume(double value, SpecificVolumeUnit unit);
    public SpecificVolume(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<SpecificVolumeUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static SpecificVolumeUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static SpecificVolumeUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override SpecificVolume get_Zero();
    public static override SpecificVolume get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual SpecificVolumeUnit get_Unit();
    public sealed virtual QuantityInfo`1<SpecificVolumeUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CubicFeetPerPound();
    public double get_CubicMetersPerKilogram();
    public double get_MillicubicMetersPerKilogram();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(SpecificVolumeUnit unit);
    public static string GetAbbreviation(SpecificVolumeUnit unit, IFormatProvider provider);
    public static SpecificVolume FromCubicFeetPerPound(double value);
    public static SpecificVolume FromCubicMetersPerKilogram(double value);
    public static SpecificVolume FromMillicubicMetersPerKilogram(double value);
    public static SpecificVolume From(double value, SpecificVolumeUnit fromUnit);
    public static SpecificVolume Parse(string str);
    public static override SpecificVolume Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, SpecificVolume& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, SpecificVolume& result);
    public static SpecificVolumeUnit ParseUnit(string str);
    public static SpecificVolumeUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, SpecificVolumeUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, SpecificVolumeUnit& unit);
    public static override SpecificVolume op_UnaryNegation(SpecificVolume right);
    public static override SpecificVolume op_Addition(SpecificVolume left, SpecificVolume right);
    public static override SpecificVolume op_Subtraction(SpecificVolume left, SpecificVolume right);
    public static SpecificVolume op_Multiply(double left, SpecificVolume right);
    public static override SpecificVolume op_Multiply(SpecificVolume left, double right);
    public static override SpecificVolume op_Division(SpecificVolume left, double right);
    public static double op_Division(SpecificVolume left, SpecificVolume right);
    public static Density op_Division(double value, SpecificVolume specificVolume);
    public static override Volume op_Multiply(SpecificVolume specificVolume, Mass mass);
    public static override double op_Multiply(SpecificVolume specificVolume, Density density);
    public static override bool op_LessThanOrEqual(SpecificVolume left, SpecificVolume right);
    public static override bool op_GreaterThanOrEqual(SpecificVolume left, SpecificVolume right);
    public static override bool op_LessThan(SpecificVolume left, SpecificVolume right);
    public static override bool op_GreaterThan(SpecificVolume left, SpecificVolume right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(SpecificVolume other, SpecificVolume tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(SpecificVolume left, SpecificVolume right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(SpecificVolume other, SpecificVolume tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(SpecificVolume left, SpecificVolume right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(SpecificVolume other, SpecificVolume tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(SpecificVolume other, SpecificVolume tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(SpecificVolume other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(SpecificVolume other);
    [ObsoleteAttribute("Use Equals(SpecificVolume other, SpecificVolume tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(SpecificVolume other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(SpecificVolume other, SpecificVolume tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(SpecificVolumeUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public SpecificVolume ToUnit(SpecificVolumeUnit unit);
    public SpecificVolume ToUnit(SpecificVolumeUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(SpecificVolumeUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public SpecificVolume ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<SpecificVolumeUnit> UnitsNet.IQuantity<UnitsNet.Units.SpecificVolumeUnit>.ToUnit(SpecificVolumeUnit unit);
    private sealed virtual override IQuantity`1<SpecificVolumeUnit> UnitsNet.IQuantity<UnitsNet.Units.SpecificVolumeUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.SpecificWeight : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<SpecificWeightUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<SpecificWeightUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpecificWeightUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpecificWeightUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpecificWeight <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<SpecificWeightUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static SpecificWeightUnit BaseUnit { get; }
    public static SpecificWeightUnit[] Units { get; }
    public static SpecificWeight Zero { get; }
    public static SpecificWeight AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public SpecificWeightUnit Unit { get; }
    public QuantityInfo`1<SpecificWeightUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double KilogramsForcePerCubicCentimeter { get; }
    public double KilogramsForcePerCubicMeter { get; }
    public double KilogramsForcePerCubicMillimeter { get; }
    public double KilonewtonsPerCubicCentimeter { get; }
    public double KilonewtonsPerCubicMeter { get; }
    public double KilonewtonsPerCubicMillimeter { get; }
    public double KilopoundsForcePerCubicFoot { get; }
    public double KilopoundsForcePerCubicInch { get; }
    public double MeganewtonsPerCubicMeter { get; }
    public double NewtonsPerCubicCentimeter { get; }
    public double NewtonsPerCubicMeter { get; }
    public double NewtonsPerCubicMillimeter { get; }
    public double PoundsForcePerCubicFoot { get; }
    public double PoundsForcePerCubicInch { get; }
    public double TonnesForcePerCubicCentimeter { get; }
    public double TonnesForcePerCubicMeter { get; }
    public double TonnesForcePerCubicMillimeter { get; }
    private static SpecificWeight();
    public SpecificWeight(double value, SpecificWeightUnit unit);
    public SpecificWeight(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<SpecificWeightUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static SpecificWeightUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static SpecificWeightUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override SpecificWeight get_Zero();
    public static override SpecificWeight get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual SpecificWeightUnit get_Unit();
    public sealed virtual QuantityInfo`1<SpecificWeightUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_KilogramsForcePerCubicCentimeter();
    public double get_KilogramsForcePerCubicMeter();
    public double get_KilogramsForcePerCubicMillimeter();
    public double get_KilonewtonsPerCubicCentimeter();
    public double get_KilonewtonsPerCubicMeter();
    public double get_KilonewtonsPerCubicMillimeter();
    public double get_KilopoundsForcePerCubicFoot();
    public double get_KilopoundsForcePerCubicInch();
    public double get_MeganewtonsPerCubicMeter();
    public double get_NewtonsPerCubicCentimeter();
    public double get_NewtonsPerCubicMeter();
    public double get_NewtonsPerCubicMillimeter();
    public double get_PoundsForcePerCubicFoot();
    public double get_PoundsForcePerCubicInch();
    public double get_TonnesForcePerCubicCentimeter();
    public double get_TonnesForcePerCubicMeter();
    public double get_TonnesForcePerCubicMillimeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(SpecificWeightUnit unit);
    public static string GetAbbreviation(SpecificWeightUnit unit, IFormatProvider provider);
    public static SpecificWeight FromKilogramsForcePerCubicCentimeter(double value);
    public static SpecificWeight FromKilogramsForcePerCubicMeter(double value);
    public static SpecificWeight FromKilogramsForcePerCubicMillimeter(double value);
    public static SpecificWeight FromKilonewtonsPerCubicCentimeter(double value);
    public static SpecificWeight FromKilonewtonsPerCubicMeter(double value);
    public static SpecificWeight FromKilonewtonsPerCubicMillimeter(double value);
    public static SpecificWeight FromKilopoundsForcePerCubicFoot(double value);
    public static SpecificWeight FromKilopoundsForcePerCubicInch(double value);
    public static SpecificWeight FromMeganewtonsPerCubicMeter(double value);
    public static SpecificWeight FromNewtonsPerCubicCentimeter(double value);
    public static SpecificWeight FromNewtonsPerCubicMeter(double value);
    public static SpecificWeight FromNewtonsPerCubicMillimeter(double value);
    public static SpecificWeight FromPoundsForcePerCubicFoot(double value);
    public static SpecificWeight FromPoundsForcePerCubicInch(double value);
    public static SpecificWeight FromTonnesForcePerCubicCentimeter(double value);
    public static SpecificWeight FromTonnesForcePerCubicMeter(double value);
    public static SpecificWeight FromTonnesForcePerCubicMillimeter(double value);
    public static SpecificWeight From(double value, SpecificWeightUnit fromUnit);
    public static SpecificWeight Parse(string str);
    public static override SpecificWeight Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, SpecificWeight& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, SpecificWeight& result);
    public static SpecificWeightUnit ParseUnit(string str);
    public static SpecificWeightUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, SpecificWeightUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, SpecificWeightUnit& unit);
    public static override SpecificWeight op_UnaryNegation(SpecificWeight right);
    public static override SpecificWeight op_Addition(SpecificWeight left, SpecificWeight right);
    public static override SpecificWeight op_Subtraction(SpecificWeight left, SpecificWeight right);
    public static SpecificWeight op_Multiply(double left, SpecificWeight right);
    public static override SpecificWeight op_Multiply(SpecificWeight left, double right);
    public static override SpecificWeight op_Division(SpecificWeight left, double right);
    public static double op_Division(SpecificWeight left, SpecificWeight right);
    public static override Acceleration op_Division(SpecificWeight specificWeight, Density density);
    public static override Density op_Division(SpecificWeight specificWeight, Acceleration acceleration);
    public static override ForcePerLength op_Multiply(SpecificWeight specificWeight, Area area);
    public static override Pressure op_Multiply(SpecificWeight specificWeight, Length length);
    public static override bool op_LessThanOrEqual(SpecificWeight left, SpecificWeight right);
    public static override bool op_GreaterThanOrEqual(SpecificWeight left, SpecificWeight right);
    public static override bool op_LessThan(SpecificWeight left, SpecificWeight right);
    public static override bool op_GreaterThan(SpecificWeight left, SpecificWeight right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(SpecificWeight other, SpecificWeight tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(SpecificWeight left, SpecificWeight right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(SpecificWeight other, SpecificWeight tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(SpecificWeight left, SpecificWeight right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(SpecificWeight other, SpecificWeight tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(SpecificWeight other, SpecificWeight tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(SpecificWeight other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(SpecificWeight other);
    [ObsoleteAttribute("Use Equals(SpecificWeight other, SpecificWeight tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(SpecificWeight other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(SpecificWeight other, SpecificWeight tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(SpecificWeightUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public SpecificWeight ToUnit(SpecificWeightUnit unit);
    public SpecificWeight ToUnit(SpecificWeightUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(SpecificWeightUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public SpecificWeight ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<SpecificWeightUnit> UnitsNet.IQuantity<UnitsNet.Units.SpecificWeightUnit>.ToUnit(SpecificWeightUnit unit);
    private sealed virtual override IQuantity`1<SpecificWeightUnit> UnitsNet.IQuantity<UnitsNet.Units.SpecificWeightUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Speed : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<SpeedUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<SpeedUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpeedUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static SpeedUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Speed <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<SpeedUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static SpeedUnit BaseUnit { get; }
    public static SpeedUnit[] Units { get; }
    public static Speed Zero { get; }
    public static Speed AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public SpeedUnit Unit { get; }
    public QuantityInfo`1<SpeedUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentimetersPerHour { get; }
    public double CentimetersPerMinute { get; }
    public double CentimetersPerSecond { get; }
    public double DecimetersPerMinute { get; }
    public double DecimetersPerSecond { get; }
    public double FeetPerHour { get; }
    public double FeetPerMinute { get; }
    public double FeetPerSecond { get; }
    public double InchesPerHour { get; }
    public double InchesPerMinute { get; }
    public double InchesPerSecond { get; }
    public double KilometersPerHour { get; }
    public double KilometersPerMinute { get; }
    public double KilometersPerSecond { get; }
    public double Knots { get; }
    public double Mach { get; }
    public double MetersPerHour { get; }
    public double MetersPerMinute { get; }
    public double MetersPerSecond { get; }
    public double MicrometersPerMinute { get; }
    public double MicrometersPerSecond { get; }
    public double MilesPerHour { get; }
    public double MillimetersPerHour { get; }
    public double MillimetersPerMinute { get; }
    public double MillimetersPerSecond { get; }
    public double NanometersPerMinute { get; }
    public double NanometersPerSecond { get; }
    public double UsSurveyFeetPerHour { get; }
    public double UsSurveyFeetPerMinute { get; }
    public double UsSurveyFeetPerSecond { get; }
    public double YardsPerHour { get; }
    public double YardsPerMinute { get; }
    public double YardsPerSecond { get; }
    private static Speed();
    public Speed(double value, SpeedUnit unit);
    public Speed(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<SpeedUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static SpeedUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static SpeedUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Speed get_Zero();
    public static override Speed get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual SpeedUnit get_Unit();
    public sealed virtual QuantityInfo`1<SpeedUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentimetersPerHour();
    public double get_CentimetersPerMinute();
    public double get_CentimetersPerSecond();
    public double get_DecimetersPerMinute();
    public double get_DecimetersPerSecond();
    public double get_FeetPerHour();
    public double get_FeetPerMinute();
    public double get_FeetPerSecond();
    public double get_InchesPerHour();
    public double get_InchesPerMinute();
    public double get_InchesPerSecond();
    public double get_KilometersPerHour();
    public double get_KilometersPerMinute();
    public double get_KilometersPerSecond();
    public double get_Knots();
    public double get_Mach();
    public double get_MetersPerHour();
    public double get_MetersPerMinute();
    public double get_MetersPerSecond();
    public double get_MicrometersPerMinute();
    public double get_MicrometersPerSecond();
    public double get_MilesPerHour();
    public double get_MillimetersPerHour();
    public double get_MillimetersPerMinute();
    public double get_MillimetersPerSecond();
    public double get_NanometersPerMinute();
    public double get_NanometersPerSecond();
    public double get_UsSurveyFeetPerHour();
    public double get_UsSurveyFeetPerMinute();
    public double get_UsSurveyFeetPerSecond();
    public double get_YardsPerHour();
    public double get_YardsPerMinute();
    public double get_YardsPerSecond();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(SpeedUnit unit);
    public static string GetAbbreviation(SpeedUnit unit, IFormatProvider provider);
    public static Speed FromCentimetersPerHour(double value);
    public static Speed FromCentimetersPerMinute(double value);
    public static Speed FromCentimetersPerSecond(double value);
    public static Speed FromDecimetersPerMinute(double value);
    public static Speed FromDecimetersPerSecond(double value);
    public static Speed FromFeetPerHour(double value);
    public static Speed FromFeetPerMinute(double value);
    public static Speed FromFeetPerSecond(double value);
    public static Speed FromInchesPerHour(double value);
    public static Speed FromInchesPerMinute(double value);
    public static Speed FromInchesPerSecond(double value);
    public static Speed FromKilometersPerHour(double value);
    public static Speed FromKilometersPerMinute(double value);
    public static Speed FromKilometersPerSecond(double value);
    public static Speed FromKnots(double value);
    public static Speed FromMach(double value);
    public static Speed FromMetersPerHour(double value);
    public static Speed FromMetersPerMinute(double value);
    public static Speed FromMetersPerSecond(double value);
    public static Speed FromMicrometersPerMinute(double value);
    public static Speed FromMicrometersPerSecond(double value);
    public static Speed FromMilesPerHour(double value);
    public static Speed FromMillimetersPerHour(double value);
    public static Speed FromMillimetersPerMinute(double value);
    public static Speed FromMillimetersPerSecond(double value);
    public static Speed FromNanometersPerMinute(double value);
    public static Speed FromNanometersPerSecond(double value);
    public static Speed FromUsSurveyFeetPerHour(double value);
    public static Speed FromUsSurveyFeetPerMinute(double value);
    public static Speed FromUsSurveyFeetPerSecond(double value);
    public static Speed FromYardsPerHour(double value);
    public static Speed FromYardsPerMinute(double value);
    public static Speed FromYardsPerSecond(double value);
    public static Speed From(double value, SpeedUnit fromUnit);
    public static Speed Parse(string str);
    public static override Speed Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Speed& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Speed& result);
    public static SpeedUnit ParseUnit(string str);
    public static SpeedUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, SpeedUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, SpeedUnit& unit);
    public static override Speed op_UnaryNegation(Speed right);
    public static override Speed op_Addition(Speed left, Speed right);
    public static override Speed op_Subtraction(Speed left, Speed right);
    public static Speed op_Multiply(double left, Speed right);
    public static override Speed op_Multiply(Speed left, double right);
    public static override Speed op_Division(Speed left, double right);
    public static double op_Division(Speed left, Speed right);
    public static override Acceleration op_Division(Speed speed, Duration duration);
    public static override Duration op_Division(Speed speed, Acceleration acceleration);
    public static override KinematicViscosity op_Multiply(Speed speed, Length length);
    public static override Length op_Multiply(Speed speed, Duration duration);
    public static override MassFlux op_Multiply(Speed speed, Density density);
    public static override Power op_Multiply(Speed speed, Force force);
    public static override SpecificEnergy op_Multiply(Speed left, Speed right);
    public static override VolumeFlow op_Multiply(Speed speed, Area area);
    public static override bool op_LessThanOrEqual(Speed left, Speed right);
    public static override bool op_GreaterThanOrEqual(Speed left, Speed right);
    public static override bool op_LessThan(Speed left, Speed right);
    public static override bool op_GreaterThan(Speed left, Speed right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Speed other, Speed tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Speed left, Speed right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Speed other, Speed tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Speed left, Speed right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Speed other, Speed tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Speed other, Speed tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Speed other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Speed other);
    [ObsoleteAttribute("Use Equals(Speed other, Speed tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Speed other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Speed other, Speed tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(SpeedUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Speed ToUnit(SpeedUnit unit);
    public Speed ToUnit(SpeedUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(SpeedUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Speed ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<SpeedUnit> UnitsNet.IQuantity<UnitsNet.Units.SpeedUnit>.ToUnit(SpeedUnit unit);
    private sealed virtual override IQuantity`1<SpeedUnit> UnitsNet.IQuantity<UnitsNet.Units.SpeedUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.StandardVolumeFlow : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<StandardVolumeFlowUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<StandardVolumeFlowUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static StandardVolumeFlowUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static StandardVolumeFlowUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static StandardVolumeFlow <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<StandardVolumeFlowUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static StandardVolumeFlowUnit BaseUnit { get; }
    public static StandardVolumeFlowUnit[] Units { get; }
    public static StandardVolumeFlow Zero { get; }
    public static StandardVolumeFlow AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public StandardVolumeFlowUnit Unit { get; }
    public QuantityInfo`1<StandardVolumeFlowUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double StandardCubicCentimetersPerMinute { get; }
    public double StandardCubicFeetPerHour { get; }
    public double StandardCubicFeetPerMinute { get; }
    public double StandardCubicFeetPerSecond { get; }
    public double StandardCubicMetersPerDay { get; }
    public double StandardCubicMetersPerHour { get; }
    public double StandardCubicMetersPerMinute { get; }
    public double StandardCubicMetersPerSecond { get; }
    public double StandardLitersPerMinute { get; }
    private static StandardVolumeFlow();
    public StandardVolumeFlow(double value, StandardVolumeFlowUnit unit);
    public StandardVolumeFlow(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<StandardVolumeFlowUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static StandardVolumeFlowUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static StandardVolumeFlowUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override StandardVolumeFlow get_Zero();
    public static override StandardVolumeFlow get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual StandardVolumeFlowUnit get_Unit();
    public sealed virtual QuantityInfo`1<StandardVolumeFlowUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_StandardCubicCentimetersPerMinute();
    public double get_StandardCubicFeetPerHour();
    public double get_StandardCubicFeetPerMinute();
    public double get_StandardCubicFeetPerSecond();
    public double get_StandardCubicMetersPerDay();
    public double get_StandardCubicMetersPerHour();
    public double get_StandardCubicMetersPerMinute();
    public double get_StandardCubicMetersPerSecond();
    public double get_StandardLitersPerMinute();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(StandardVolumeFlowUnit unit);
    public static string GetAbbreviation(StandardVolumeFlowUnit unit, IFormatProvider provider);
    public static StandardVolumeFlow FromStandardCubicCentimetersPerMinute(double value);
    public static StandardVolumeFlow FromStandardCubicFeetPerHour(double value);
    public static StandardVolumeFlow FromStandardCubicFeetPerMinute(double value);
    public static StandardVolumeFlow FromStandardCubicFeetPerSecond(double value);
    public static StandardVolumeFlow FromStandardCubicMetersPerDay(double value);
    public static StandardVolumeFlow FromStandardCubicMetersPerHour(double value);
    public static StandardVolumeFlow FromStandardCubicMetersPerMinute(double value);
    public static StandardVolumeFlow FromStandardCubicMetersPerSecond(double value);
    public static StandardVolumeFlow FromStandardLitersPerMinute(double value);
    public static StandardVolumeFlow From(double value, StandardVolumeFlowUnit fromUnit);
    public static StandardVolumeFlow Parse(string str);
    public static override StandardVolumeFlow Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, StandardVolumeFlow& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, StandardVolumeFlow& result);
    public static StandardVolumeFlowUnit ParseUnit(string str);
    public static StandardVolumeFlowUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, StandardVolumeFlowUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, StandardVolumeFlowUnit& unit);
    public static override StandardVolumeFlow op_UnaryNegation(StandardVolumeFlow right);
    public static override StandardVolumeFlow op_Addition(StandardVolumeFlow left, StandardVolumeFlow right);
    public static override StandardVolumeFlow op_Subtraction(StandardVolumeFlow left, StandardVolumeFlow right);
    public static StandardVolumeFlow op_Multiply(double left, StandardVolumeFlow right);
    public static override StandardVolumeFlow op_Multiply(StandardVolumeFlow left, double right);
    public static override StandardVolumeFlow op_Division(StandardVolumeFlow left, double right);
    public static double op_Division(StandardVolumeFlow left, StandardVolumeFlow right);
    public static override bool op_LessThanOrEqual(StandardVolumeFlow left, StandardVolumeFlow right);
    public static override bool op_GreaterThanOrEqual(StandardVolumeFlow left, StandardVolumeFlow right);
    public static override bool op_LessThan(StandardVolumeFlow left, StandardVolumeFlow right);
    public static override bool op_GreaterThan(StandardVolumeFlow left, StandardVolumeFlow right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(StandardVolumeFlow other, StandardVolumeFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(StandardVolumeFlow left, StandardVolumeFlow right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(StandardVolumeFlow other, StandardVolumeFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(StandardVolumeFlow left, StandardVolumeFlow right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(StandardVolumeFlow other, StandardVolumeFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(StandardVolumeFlow other, StandardVolumeFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(StandardVolumeFlow other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(StandardVolumeFlow other);
    [ObsoleteAttribute("Use Equals(StandardVolumeFlow other, StandardVolumeFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(StandardVolumeFlow other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(StandardVolumeFlow other, StandardVolumeFlow tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(StandardVolumeFlowUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public StandardVolumeFlow ToUnit(StandardVolumeFlowUnit unit);
    public StandardVolumeFlow ToUnit(StandardVolumeFlowUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(StandardVolumeFlowUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public StandardVolumeFlow ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<StandardVolumeFlowUnit> UnitsNet.IQuantity<UnitsNet.Units.StandardVolumeFlowUnit>.ToUnit(StandardVolumeFlowUnit unit);
    private sealed virtual override IQuantity`1<StandardVolumeFlowUnit> UnitsNet.IQuantity<UnitsNet.Units.StandardVolumeFlowUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.StonePounds : object {
    [CompilerGeneratedAttribute]
private double <Stone>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Pounds>k__BackingField;
    public double Stone { get; }
    public double Pounds { get; }
    public StonePounds(double stone, double pounds);
    [CompilerGeneratedAttribute]
public double get_Stone();
    [CompilerGeneratedAttribute]
public double get_Pounds();
    public virtual string ToString();
    public string ToString(IFormatProvider cultureInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Temperature : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<TemperatureUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<TemperatureUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static TemperatureUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static TemperatureUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Temperature <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<TemperatureUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static TemperatureUnit BaseUnit { get; }
    public static TemperatureUnit[] Units { get; }
    public static Temperature Zero { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public TemperatureUnit Unit { get; }
    public QuantityInfo`1<TemperatureUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double DegreesCelsius { get; }
    public double DegreesDelisle { get; }
    public double DegreesFahrenheit { get; }
    public double DegreesNewton { get; }
    public double DegreesRankine { get; }
    public double DegreesReaumur { get; }
    public double DegreesRoemer { get; }
    public double Kelvins { get; }
    public double MillidegreesCelsius { get; }
    public double SolarTemperatures { get; }
    private static Temperature();
    public Temperature(double value, TemperatureUnit unit);
    public Temperature(double value, UnitSystem unitSystem);
    public static Temperature op_Addition(Temperature left, TemperatureDelta right);
    public static Temperature op_Addition(TemperatureDelta left, Temperature right);
    public static Temperature op_Subtraction(Temperature left, TemperatureDelta right);
    public static TemperatureDelta op_Subtraction(Temperature left, Temperature right);
    public Temperature Multiply(double factor, TemperatureUnit unit);
    public Temperature Divide(double divisor, TemperatureUnit unit);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<TemperatureUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static TemperatureUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static TemperatureUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static Temperature get_Zero();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual TemperatureUnit get_Unit();
    public sealed virtual QuantityInfo`1<TemperatureUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_DegreesCelsius();
    public double get_DegreesDelisle();
    public double get_DegreesFahrenheit();
    public double get_DegreesNewton();
    public double get_DegreesRankine();
    public double get_DegreesReaumur();
    public double get_DegreesRoemer();
    public double get_Kelvins();
    public double get_MillidegreesCelsius();
    public double get_SolarTemperatures();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(TemperatureUnit unit);
    public static string GetAbbreviation(TemperatureUnit unit, IFormatProvider provider);
    public static Temperature FromDegreesCelsius(double value);
    public static Temperature FromDegreesDelisle(double value);
    public static Temperature FromDegreesFahrenheit(double value);
    public static Temperature FromDegreesNewton(double value);
    public static Temperature FromDegreesRankine(double value);
    public static Temperature FromDegreesReaumur(double value);
    public static Temperature FromDegreesRoemer(double value);
    public static Temperature FromKelvins(double value);
    public static Temperature FromMillidegreesCelsius(double value);
    public static Temperature FromSolarTemperatures(double value);
    public static Temperature From(double value, TemperatureUnit fromUnit);
    public static Temperature Parse(string str);
    public static override Temperature Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Temperature& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Temperature& result);
    public static TemperatureUnit ParseUnit(string str);
    public static TemperatureUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, TemperatureUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, TemperatureUnit& unit);
    public static override bool op_LessThanOrEqual(Temperature left, Temperature right);
    public static override bool op_GreaterThanOrEqual(Temperature left, Temperature right);
    public static override bool op_LessThan(Temperature left, Temperature right);
    public static override bool op_GreaterThan(Temperature left, Temperature right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Temperature other, Temperature tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Temperature left, Temperature right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Temperature other, Temperature tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Temperature left, Temperature right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Temperature other, Temperature tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Temperature other, Temperature tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Temperature other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Temperature other);
    [ObsoleteAttribute("Use Equals(Temperature other, Temperature tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Temperature other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Temperature other, Temperature tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(TemperatureUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Temperature ToUnit(TemperatureUnit unit);
    public Temperature ToUnit(TemperatureUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(TemperatureUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Temperature ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<TemperatureUnit> UnitsNet.IQuantity<UnitsNet.Units.TemperatureUnit>.ToUnit(TemperatureUnit unit);
    private sealed virtual override IQuantity`1<TemperatureUnit> UnitsNet.IQuantity<UnitsNet.Units.TemperatureUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.TemperatureChangeRate : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<TemperatureChangeRateUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<TemperatureChangeRateUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static TemperatureChangeRateUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static TemperatureChangeRateUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static TemperatureChangeRate <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<TemperatureChangeRateUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static TemperatureChangeRateUnit BaseUnit { get; }
    public static TemperatureChangeRateUnit[] Units { get; }
    public static TemperatureChangeRate Zero { get; }
    public static TemperatureChangeRate AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public TemperatureChangeRateUnit Unit { get; }
    public QuantityInfo`1<TemperatureChangeRateUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentidegreesCelsiusPerSecond { get; }
    public double DecadegreesCelsiusPerSecond { get; }
    public double DecidegreesCelsiusPerSecond { get; }
    public double DegreesCelsiusPerMinute { get; }
    public double DegreesCelsiusPerSecond { get; }
    public double HectodegreesCelsiusPerSecond { get; }
    public double KilodegreesCelsiusPerSecond { get; }
    public double MicrodegreesCelsiusPerSecond { get; }
    public double MillidegreesCelsiusPerSecond { get; }
    public double NanodegreesCelsiusPerSecond { get; }
    private static TemperatureChangeRate();
    public TemperatureChangeRate(double value, TemperatureChangeRateUnit unit);
    public TemperatureChangeRate(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<TemperatureChangeRateUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static TemperatureChangeRateUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static TemperatureChangeRateUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override TemperatureChangeRate get_Zero();
    public static override TemperatureChangeRate get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual TemperatureChangeRateUnit get_Unit();
    public sealed virtual QuantityInfo`1<TemperatureChangeRateUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentidegreesCelsiusPerSecond();
    public double get_DecadegreesCelsiusPerSecond();
    public double get_DecidegreesCelsiusPerSecond();
    public double get_DegreesCelsiusPerMinute();
    public double get_DegreesCelsiusPerSecond();
    public double get_HectodegreesCelsiusPerSecond();
    public double get_KilodegreesCelsiusPerSecond();
    public double get_MicrodegreesCelsiusPerSecond();
    public double get_MillidegreesCelsiusPerSecond();
    public double get_NanodegreesCelsiusPerSecond();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(TemperatureChangeRateUnit unit);
    public static string GetAbbreviation(TemperatureChangeRateUnit unit, IFormatProvider provider);
    public static TemperatureChangeRate FromCentidegreesCelsiusPerSecond(double value);
    public static TemperatureChangeRate FromDecadegreesCelsiusPerSecond(double value);
    public static TemperatureChangeRate FromDecidegreesCelsiusPerSecond(double value);
    public static TemperatureChangeRate FromDegreesCelsiusPerMinute(double value);
    public static TemperatureChangeRate FromDegreesCelsiusPerSecond(double value);
    public static TemperatureChangeRate FromHectodegreesCelsiusPerSecond(double value);
    public static TemperatureChangeRate FromKilodegreesCelsiusPerSecond(double value);
    public static TemperatureChangeRate FromMicrodegreesCelsiusPerSecond(double value);
    public static TemperatureChangeRate FromMillidegreesCelsiusPerSecond(double value);
    public static TemperatureChangeRate FromNanodegreesCelsiusPerSecond(double value);
    public static TemperatureChangeRate From(double value, TemperatureChangeRateUnit fromUnit);
    public static TemperatureChangeRate Parse(string str);
    public static override TemperatureChangeRate Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, TemperatureChangeRate& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, TemperatureChangeRate& result);
    public static TemperatureChangeRateUnit ParseUnit(string str);
    public static TemperatureChangeRateUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, TemperatureChangeRateUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, TemperatureChangeRateUnit& unit);
    public static override TemperatureChangeRate op_UnaryNegation(TemperatureChangeRate right);
    public static override TemperatureChangeRate op_Addition(TemperatureChangeRate left, TemperatureChangeRate right);
    public static override TemperatureChangeRate op_Subtraction(TemperatureChangeRate left, TemperatureChangeRate right);
    public static TemperatureChangeRate op_Multiply(double left, TemperatureChangeRate right);
    public static override TemperatureChangeRate op_Multiply(TemperatureChangeRate left, double right);
    public static override TemperatureChangeRate op_Division(TemperatureChangeRate left, double right);
    public static double op_Division(TemperatureChangeRate left, TemperatureChangeRate right);
    public static override TemperatureDelta op_Multiply(TemperatureChangeRate temperatureChangeRate, Duration duration);
    public static override bool op_LessThanOrEqual(TemperatureChangeRate left, TemperatureChangeRate right);
    public static override bool op_GreaterThanOrEqual(TemperatureChangeRate left, TemperatureChangeRate right);
    public static override bool op_LessThan(TemperatureChangeRate left, TemperatureChangeRate right);
    public static override bool op_GreaterThan(TemperatureChangeRate left, TemperatureChangeRate right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(TemperatureChangeRate other, TemperatureChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(TemperatureChangeRate left, TemperatureChangeRate right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(TemperatureChangeRate other, TemperatureChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(TemperatureChangeRate left, TemperatureChangeRate right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(TemperatureChangeRate other, TemperatureChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(TemperatureChangeRate other, TemperatureChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(TemperatureChangeRate other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(TemperatureChangeRate other);
    [ObsoleteAttribute("Use Equals(TemperatureChangeRate other, TemperatureChangeRate tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(TemperatureChangeRate other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(TemperatureChangeRate other, TemperatureChangeRate tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(TemperatureChangeRateUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public TemperatureChangeRate ToUnit(TemperatureChangeRateUnit unit);
    public TemperatureChangeRate ToUnit(TemperatureChangeRateUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(TemperatureChangeRateUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public TemperatureChangeRate ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<TemperatureChangeRateUnit> UnitsNet.IQuantity<UnitsNet.Units.TemperatureChangeRateUnit>.ToUnit(TemperatureChangeRateUnit unit);
    private sealed virtual override IQuantity`1<TemperatureChangeRateUnit> UnitsNet.IQuantity<UnitsNet.Units.TemperatureChangeRateUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.TemperatureDelta : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<TemperatureDeltaUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<TemperatureDeltaUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static TemperatureDeltaUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static TemperatureDeltaUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static TemperatureDelta <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<TemperatureDeltaUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static TemperatureDeltaUnit BaseUnit { get; }
    public static TemperatureDeltaUnit[] Units { get; }
    public static TemperatureDelta Zero { get; }
    public static TemperatureDelta AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public TemperatureDeltaUnit Unit { get; }
    public QuantityInfo`1<TemperatureDeltaUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double DegreesCelsius { get; }
    public double DegreesDelisle { get; }
    public double DegreesFahrenheit { get; }
    public double DegreesNewton { get; }
    public double DegreesRankine { get; }
    public double DegreesReaumur { get; }
    public double DegreesRoemer { get; }
    public double Kelvins { get; }
    public double MillidegreesCelsius { get; }
    private static TemperatureDelta();
    public TemperatureDelta(double value, TemperatureDeltaUnit unit);
    public TemperatureDelta(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<TemperatureDeltaUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static TemperatureDeltaUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static TemperatureDeltaUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override TemperatureDelta get_Zero();
    public static override TemperatureDelta get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual TemperatureDeltaUnit get_Unit();
    public sealed virtual QuantityInfo`1<TemperatureDeltaUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_DegreesCelsius();
    public double get_DegreesDelisle();
    public double get_DegreesFahrenheit();
    public double get_DegreesNewton();
    public double get_DegreesRankine();
    public double get_DegreesReaumur();
    public double get_DegreesRoemer();
    public double get_Kelvins();
    public double get_MillidegreesCelsius();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(TemperatureDeltaUnit unit);
    public static string GetAbbreviation(TemperatureDeltaUnit unit, IFormatProvider provider);
    public static TemperatureDelta FromDegreesCelsius(double value);
    public static TemperatureDelta FromDegreesDelisle(double value);
    public static TemperatureDelta FromDegreesFahrenheit(double value);
    public static TemperatureDelta FromDegreesNewton(double value);
    public static TemperatureDelta FromDegreesRankine(double value);
    public static TemperatureDelta FromDegreesReaumur(double value);
    public static TemperatureDelta FromDegreesRoemer(double value);
    public static TemperatureDelta FromKelvins(double value);
    public static TemperatureDelta FromMillidegreesCelsius(double value);
    public static TemperatureDelta From(double value, TemperatureDeltaUnit fromUnit);
    public static TemperatureDelta Parse(string str);
    public static override TemperatureDelta Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, TemperatureDelta& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, TemperatureDelta& result);
    public static TemperatureDeltaUnit ParseUnit(string str);
    public static TemperatureDeltaUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, TemperatureDeltaUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, TemperatureDeltaUnit& unit);
    public static override TemperatureDelta op_UnaryNegation(TemperatureDelta right);
    public static override TemperatureDelta op_Addition(TemperatureDelta left, TemperatureDelta right);
    public static override TemperatureDelta op_Subtraction(TemperatureDelta left, TemperatureDelta right);
    public static TemperatureDelta op_Multiply(double left, TemperatureDelta right);
    public static override TemperatureDelta op_Multiply(TemperatureDelta left, double right);
    public static override TemperatureDelta op_Division(TemperatureDelta left, double right);
    public static double op_Division(TemperatureDelta left, TemperatureDelta right);
    public static CoefficientOfThermalExpansion op_Division(double value, TemperatureDelta temperatureDelta);
    public static override Duration op_Division(TemperatureDelta temperatureDelta, TemperatureChangeRate temperatureChangeRate);
    public static override Energy op_Multiply(TemperatureDelta temperatureDelta, Entropy entropy);
    public static override Length op_Division(TemperatureDelta temperatureDelta, TemperatureGradient temperatureGradient);
    public static override SpecificEnergy op_Multiply(TemperatureDelta temperatureDelta, SpecificEntropy specificEntropy);
    public static override TemperatureChangeRate op_Division(TemperatureDelta temperatureDelta, Duration duration);
    public static override TemperatureGradient op_Division(TemperatureDelta temperatureDelta, Length length);
    public static override double op_Multiply(TemperatureDelta temperatureDelta, CoefficientOfThermalExpansion coefficientOfThermalExpansion);
    public static override bool op_LessThanOrEqual(TemperatureDelta left, TemperatureDelta right);
    public static override bool op_GreaterThanOrEqual(TemperatureDelta left, TemperatureDelta right);
    public static override bool op_LessThan(TemperatureDelta left, TemperatureDelta right);
    public static override bool op_GreaterThan(TemperatureDelta left, TemperatureDelta right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(TemperatureDelta other, TemperatureDelta tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(TemperatureDelta left, TemperatureDelta right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(TemperatureDelta other, TemperatureDelta tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(TemperatureDelta left, TemperatureDelta right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(TemperatureDelta other, TemperatureDelta tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(TemperatureDelta other, TemperatureDelta tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(TemperatureDelta other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(TemperatureDelta other);
    [ObsoleteAttribute("Use Equals(TemperatureDelta other, TemperatureDelta tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(TemperatureDelta other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(TemperatureDelta other, TemperatureDelta tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(TemperatureDeltaUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public TemperatureDelta ToUnit(TemperatureDeltaUnit unit);
    public TemperatureDelta ToUnit(TemperatureDeltaUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(TemperatureDeltaUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public TemperatureDelta ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<TemperatureDeltaUnit> UnitsNet.IQuantity<UnitsNet.Units.TemperatureDeltaUnit>.ToUnit(TemperatureDeltaUnit unit);
    private sealed virtual override IQuantity`1<TemperatureDeltaUnit> UnitsNet.IQuantity<UnitsNet.Units.TemperatureDeltaUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.TemperatureGradient : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<TemperatureGradientUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<TemperatureGradientUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static TemperatureGradientUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static TemperatureGradientUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static TemperatureGradient <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<TemperatureGradientUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static TemperatureGradientUnit BaseUnit { get; }
    public static TemperatureGradientUnit[] Units { get; }
    public static TemperatureGradient Zero { get; }
    public static TemperatureGradient AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public TemperatureGradientUnit Unit { get; }
    public QuantityInfo`1<TemperatureGradientUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double DegreesCelsiusPerKilometer { get; }
    public double DegreesCelsiusPerMeter { get; }
    public double DegreesFahrenheitPerFoot { get; }
    public double KelvinsPerMeter { get; }
    private static TemperatureGradient();
    public TemperatureGradient(double value, TemperatureGradientUnit unit);
    public TemperatureGradient(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<TemperatureGradientUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static TemperatureGradientUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static TemperatureGradientUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override TemperatureGradient get_Zero();
    public static override TemperatureGradient get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual TemperatureGradientUnit get_Unit();
    public sealed virtual QuantityInfo`1<TemperatureGradientUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_DegreesCelsiusPerKilometer();
    public double get_DegreesCelsiusPerMeter();
    public double get_DegreesFahrenheitPerFoot();
    public double get_KelvinsPerMeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(TemperatureGradientUnit unit);
    public static string GetAbbreviation(TemperatureGradientUnit unit, IFormatProvider provider);
    public static TemperatureGradient FromDegreesCelsiusPerKilometer(double value);
    public static TemperatureGradient FromDegreesCelsiusPerMeter(double value);
    public static TemperatureGradient FromDegreesFahrenheitPerFoot(double value);
    public static TemperatureGradient FromKelvinsPerMeter(double value);
    public static TemperatureGradient From(double value, TemperatureGradientUnit fromUnit);
    public static TemperatureGradient Parse(string str);
    public static override TemperatureGradient Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, TemperatureGradient& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, TemperatureGradient& result);
    public static TemperatureGradientUnit ParseUnit(string str);
    public static TemperatureGradientUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, TemperatureGradientUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, TemperatureGradientUnit& unit);
    public static override TemperatureGradient op_UnaryNegation(TemperatureGradient right);
    public static override TemperatureGradient op_Addition(TemperatureGradient left, TemperatureGradient right);
    public static override TemperatureGradient op_Subtraction(TemperatureGradient left, TemperatureGradient right);
    public static TemperatureGradient op_Multiply(double left, TemperatureGradient right);
    public static override TemperatureGradient op_Multiply(TemperatureGradient left, double right);
    public static override TemperatureGradient op_Division(TemperatureGradient left, double right);
    public static double op_Division(TemperatureGradient left, TemperatureGradient right);
    public static override TemperatureDelta op_Multiply(TemperatureGradient temperatureGradient, Length length);
    public static override bool op_LessThanOrEqual(TemperatureGradient left, TemperatureGradient right);
    public static override bool op_GreaterThanOrEqual(TemperatureGradient left, TemperatureGradient right);
    public static override bool op_LessThan(TemperatureGradient left, TemperatureGradient right);
    public static override bool op_GreaterThan(TemperatureGradient left, TemperatureGradient right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(TemperatureGradient other, TemperatureGradient tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(TemperatureGradient left, TemperatureGradient right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(TemperatureGradient other, TemperatureGradient tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(TemperatureGradient left, TemperatureGradient right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(TemperatureGradient other, TemperatureGradient tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(TemperatureGradient other, TemperatureGradient tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(TemperatureGradient other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(TemperatureGradient other);
    [ObsoleteAttribute("Use Equals(TemperatureGradient other, TemperatureGradient tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(TemperatureGradient other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(TemperatureGradient other, TemperatureGradient tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(TemperatureGradientUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public TemperatureGradient ToUnit(TemperatureGradientUnit unit);
    public TemperatureGradient ToUnit(TemperatureGradientUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(TemperatureGradientUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public TemperatureGradient ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<TemperatureGradientUnit> UnitsNet.IQuantity<UnitsNet.Units.TemperatureGradientUnit>.ToUnit(TemperatureGradientUnit unit);
    private sealed virtual override IQuantity`1<TemperatureGradientUnit> UnitsNet.IQuantity<UnitsNet.Units.TemperatureGradientUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ThermalConductivity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ThermalConductivityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ThermalConductivityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ThermalConductivityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ThermalConductivityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ThermalConductivity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ThermalConductivityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ThermalConductivityUnit BaseUnit { get; }
    public static ThermalConductivityUnit[] Units { get; }
    public static ThermalConductivity Zero { get; }
    public static ThermalConductivity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ThermalConductivityUnit Unit { get; }
    public QuantityInfo`1<ThermalConductivityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double BtusPerHourFootFahrenheit { get; }
    public double WattsPerMeterKelvin { get; }
    private static ThermalConductivity();
    public ThermalConductivity(double value, ThermalConductivityUnit unit);
    public ThermalConductivity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ThermalConductivityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ThermalConductivityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ThermalConductivityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ThermalConductivity get_Zero();
    public static override ThermalConductivity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ThermalConductivityUnit get_Unit();
    public sealed virtual QuantityInfo`1<ThermalConductivityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_BtusPerHourFootFahrenheit();
    public double get_WattsPerMeterKelvin();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ThermalConductivityUnit unit);
    public static string GetAbbreviation(ThermalConductivityUnit unit, IFormatProvider provider);
    public static ThermalConductivity FromBtusPerHourFootFahrenheit(double value);
    public static ThermalConductivity FromWattsPerMeterKelvin(double value);
    public static ThermalConductivity From(double value, ThermalConductivityUnit fromUnit);
    public static ThermalConductivity Parse(string str);
    public static override ThermalConductivity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ThermalConductivity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ThermalConductivity& result);
    public static ThermalConductivityUnit ParseUnit(string str);
    public static ThermalConductivityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ThermalConductivityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ThermalConductivityUnit& unit);
    public static override ThermalConductivity op_UnaryNegation(ThermalConductivity right);
    public static override ThermalConductivity op_Addition(ThermalConductivity left, ThermalConductivity right);
    public static override ThermalConductivity op_Subtraction(ThermalConductivity left, ThermalConductivity right);
    public static ThermalConductivity op_Multiply(double left, ThermalConductivity right);
    public static override ThermalConductivity op_Multiply(ThermalConductivity left, double right);
    public static override ThermalConductivity op_Division(ThermalConductivity left, double right);
    public static double op_Division(ThermalConductivity left, ThermalConductivity right);
    public static override bool op_LessThanOrEqual(ThermalConductivity left, ThermalConductivity right);
    public static override bool op_GreaterThanOrEqual(ThermalConductivity left, ThermalConductivity right);
    public static override bool op_LessThan(ThermalConductivity left, ThermalConductivity right);
    public static override bool op_GreaterThan(ThermalConductivity left, ThermalConductivity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ThermalConductivity other, ThermalConductivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ThermalConductivity left, ThermalConductivity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ThermalConductivity other, ThermalConductivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ThermalConductivity left, ThermalConductivity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ThermalConductivity other, ThermalConductivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ThermalConductivity other, ThermalConductivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ThermalConductivity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ThermalConductivity other);
    [ObsoleteAttribute("Use Equals(ThermalConductivity other, ThermalConductivity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ThermalConductivity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ThermalConductivity other, ThermalConductivity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ThermalConductivityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ThermalConductivity ToUnit(ThermalConductivityUnit unit);
    public ThermalConductivity ToUnit(ThermalConductivityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ThermalConductivityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ThermalConductivity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ThermalConductivityUnit> UnitsNet.IQuantity<UnitsNet.Units.ThermalConductivityUnit>.ToUnit(ThermalConductivityUnit unit);
    private sealed virtual override IQuantity`1<ThermalConductivityUnit> UnitsNet.IQuantity<UnitsNet.Units.ThermalConductivityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.ThermalResistance : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<ThermalResistanceUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<ThermalResistanceUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static ThermalResistanceUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static ThermalResistanceUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static ThermalResistance <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<ThermalResistanceUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static ThermalResistanceUnit BaseUnit { get; }
    public static ThermalResistanceUnit[] Units { get; }
    public static ThermalResistance Zero { get; }
    public static ThermalResistance AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public ThermalResistanceUnit Unit { get; }
    public QuantityInfo`1<ThermalResistanceUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double HourSquareFeetDegreesFahrenheitPerBtu { get; }
    public double SquareCentimeterHourDegreesCelsiusPerKilocalorie { get; }
    public double SquareCentimeterKelvinsPerWatt { get; }
    public double SquareMeterDegreesCelsiusPerWatt { get; }
    public double SquareMeterKelvinsPerKilowatt { get; }
    public double SquareMeterKelvinsPerWatt { get; }
    private static ThermalResistance();
    public ThermalResistance(double value, ThermalResistanceUnit unit);
    public ThermalResistance(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<ThermalResistanceUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static ThermalResistanceUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static ThermalResistanceUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override ThermalResistance get_Zero();
    public static override ThermalResistance get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual ThermalResistanceUnit get_Unit();
    public sealed virtual QuantityInfo`1<ThermalResistanceUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_HourSquareFeetDegreesFahrenheitPerBtu();
    public double get_SquareCentimeterHourDegreesCelsiusPerKilocalorie();
    public double get_SquareCentimeterKelvinsPerWatt();
    public double get_SquareMeterDegreesCelsiusPerWatt();
    public double get_SquareMeterKelvinsPerKilowatt();
    public double get_SquareMeterKelvinsPerWatt();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(ThermalResistanceUnit unit);
    public static string GetAbbreviation(ThermalResistanceUnit unit, IFormatProvider provider);
    public static ThermalResistance FromHourSquareFeetDegreesFahrenheitPerBtu(double value);
    public static ThermalResistance FromSquareCentimeterHourDegreesCelsiusPerKilocalorie(double value);
    public static ThermalResistance FromSquareCentimeterKelvinsPerWatt(double value);
    public static ThermalResistance FromSquareMeterDegreesCelsiusPerWatt(double value);
    public static ThermalResistance FromSquareMeterKelvinsPerKilowatt(double value);
    public static ThermalResistance FromSquareMeterKelvinsPerWatt(double value);
    public static ThermalResistance From(double value, ThermalResistanceUnit fromUnit);
    public static ThermalResistance Parse(string str);
    public static override ThermalResistance Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, ThermalResistance& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, ThermalResistance& result);
    public static ThermalResistanceUnit ParseUnit(string str);
    public static ThermalResistanceUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, ThermalResistanceUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, ThermalResistanceUnit& unit);
    public static override ThermalResistance op_UnaryNegation(ThermalResistance right);
    public static override ThermalResistance op_Addition(ThermalResistance left, ThermalResistance right);
    public static override ThermalResistance op_Subtraction(ThermalResistance left, ThermalResistance right);
    public static ThermalResistance op_Multiply(double left, ThermalResistance right);
    public static override ThermalResistance op_Multiply(ThermalResistance left, double right);
    public static override ThermalResistance op_Division(ThermalResistance left, double right);
    public static double op_Division(ThermalResistance left, ThermalResistance right);
    public static override bool op_LessThanOrEqual(ThermalResistance left, ThermalResistance right);
    public static override bool op_GreaterThanOrEqual(ThermalResistance left, ThermalResistance right);
    public static override bool op_LessThan(ThermalResistance left, ThermalResistance right);
    public static override bool op_GreaterThan(ThermalResistance left, ThermalResistance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ThermalResistance other, ThermalResistance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(ThermalResistance left, ThermalResistance right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(ThermalResistance other, ThermalResistance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(ThermalResistance left, ThermalResistance right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(ThermalResistance other, ThermalResistance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(ThermalResistance other, ThermalResistance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(ThermalResistance other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(ThermalResistance other);
    [ObsoleteAttribute("Use Equals(ThermalResistance other, ThermalResistance tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(ThermalResistance other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(ThermalResistance other, ThermalResistance tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(ThermalResistanceUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public ThermalResistance ToUnit(ThermalResistanceUnit unit);
    public ThermalResistance ToUnit(ThermalResistanceUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(ThermalResistanceUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public ThermalResistance ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<ThermalResistanceUnit> UnitsNet.IQuantity<UnitsNet.Units.ThermalResistanceUnit>.ToUnit(ThermalResistanceUnit unit);
    private sealed virtual override IQuantity`1<ThermalResistanceUnit> UnitsNet.IQuantity<UnitsNet.Units.ThermalResistanceUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Torque : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<TorqueUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<TorqueUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static TorqueUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static TorqueUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Torque <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<TorqueUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static TorqueUnit BaseUnit { get; }
    public static TorqueUnit[] Units { get; }
    public static Torque Zero { get; }
    public static Torque AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public TorqueUnit Unit { get; }
    public QuantityInfo`1<TorqueUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double GramForceCentimeters { get; }
    public double GramForceMeters { get; }
    public double GramForceMillimeters { get; }
    public double KilogramForceCentimeters { get; }
    public double KilogramForceMeters { get; }
    public double KilogramForceMillimeters { get; }
    public double KilonewtonCentimeters { get; }
    public double KilonewtonMeters { get; }
    public double KilonewtonMillimeters { get; }
    public double KilopoundForceFeet { get; }
    public double KilopoundForceInches { get; }
    public double MeganewtonCentimeters { get; }
    public double MeganewtonMeters { get; }
    public double MeganewtonMillimeters { get; }
    public double MegapoundForceFeet { get; }
    public double MegapoundForceInches { get; }
    public double NewtonCentimeters { get; }
    public double NewtonMeters { get; }
    public double NewtonMillimeters { get; }
    public double PoundalFeet { get; }
    public double PoundForceFeet { get; }
    public double PoundForceInches { get; }
    public double TonneForceCentimeters { get; }
    public double TonneForceMeters { get; }
    public double TonneForceMillimeters { get; }
    private static Torque();
    public Torque(double value, TorqueUnit unit);
    public Torque(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<TorqueUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static TorqueUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static TorqueUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Torque get_Zero();
    public static override Torque get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual TorqueUnit get_Unit();
    public sealed virtual QuantityInfo`1<TorqueUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_GramForceCentimeters();
    public double get_GramForceMeters();
    public double get_GramForceMillimeters();
    public double get_KilogramForceCentimeters();
    public double get_KilogramForceMeters();
    public double get_KilogramForceMillimeters();
    public double get_KilonewtonCentimeters();
    public double get_KilonewtonMeters();
    public double get_KilonewtonMillimeters();
    public double get_KilopoundForceFeet();
    public double get_KilopoundForceInches();
    public double get_MeganewtonCentimeters();
    public double get_MeganewtonMeters();
    public double get_MeganewtonMillimeters();
    public double get_MegapoundForceFeet();
    public double get_MegapoundForceInches();
    public double get_NewtonCentimeters();
    public double get_NewtonMeters();
    public double get_NewtonMillimeters();
    public double get_PoundalFeet();
    public double get_PoundForceFeet();
    public double get_PoundForceInches();
    public double get_TonneForceCentimeters();
    public double get_TonneForceMeters();
    public double get_TonneForceMillimeters();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(TorqueUnit unit);
    public static string GetAbbreviation(TorqueUnit unit, IFormatProvider provider);
    public static Torque FromGramForceCentimeters(double value);
    public static Torque FromGramForceMeters(double value);
    public static Torque FromGramForceMillimeters(double value);
    public static Torque FromKilogramForceCentimeters(double value);
    public static Torque FromKilogramForceMeters(double value);
    public static Torque FromKilogramForceMillimeters(double value);
    public static Torque FromKilonewtonCentimeters(double value);
    public static Torque FromKilonewtonMeters(double value);
    public static Torque FromKilonewtonMillimeters(double value);
    public static Torque FromKilopoundForceFeet(double value);
    public static Torque FromKilopoundForceInches(double value);
    public static Torque FromMeganewtonCentimeters(double value);
    public static Torque FromMeganewtonMeters(double value);
    public static Torque FromMeganewtonMillimeters(double value);
    public static Torque FromMegapoundForceFeet(double value);
    public static Torque FromMegapoundForceInches(double value);
    public static Torque FromNewtonCentimeters(double value);
    public static Torque FromNewtonMeters(double value);
    public static Torque FromNewtonMillimeters(double value);
    public static Torque FromPoundalFeet(double value);
    public static Torque FromPoundForceFeet(double value);
    public static Torque FromPoundForceInches(double value);
    public static Torque FromTonneForceCentimeters(double value);
    public static Torque FromTonneForceMeters(double value);
    public static Torque FromTonneForceMillimeters(double value);
    public static Torque From(double value, TorqueUnit fromUnit);
    public static Torque Parse(string str);
    public static override Torque Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Torque& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Torque& result);
    public static TorqueUnit ParseUnit(string str);
    public static TorqueUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, TorqueUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, TorqueUnit& unit);
    public static override Torque op_UnaryNegation(Torque right);
    public static override Torque op_Addition(Torque left, Torque right);
    public static override Torque op_Subtraction(Torque left, Torque right);
    public static Torque op_Multiply(double left, Torque right);
    public static override Torque op_Multiply(Torque left, double right);
    public static override Torque op_Division(Torque left, double right);
    public static double op_Division(Torque left, Torque right);
    public static override Angle op_Division(Torque torque, RotationalStiffness rotationalStiffness);
    public static override Area op_Division(Torque torque, ForcePerLength forcePerLength);
    public static override Force op_Division(Torque torque, Length length);
    public static override ForcePerLength op_Division(Torque torque, Area area);
    public static override Length op_Division(Torque torque, Force force);
    public static override Power op_Multiply(Torque torque, RotationalSpeed rotationalSpeed);
    public static override RotationalStiffness op_Division(Torque torque, Angle angle);
    public static override bool op_LessThanOrEqual(Torque left, Torque right);
    public static override bool op_GreaterThanOrEqual(Torque left, Torque right);
    public static override bool op_LessThan(Torque left, Torque right);
    public static override bool op_GreaterThan(Torque left, Torque right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Torque other, Torque tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Torque left, Torque right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Torque other, Torque tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Torque left, Torque right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Torque other, Torque tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Torque other, Torque tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Torque other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Torque other);
    [ObsoleteAttribute("Use Equals(Torque other, Torque tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Torque other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Torque other, Torque tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(TorqueUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Torque ToUnit(TorqueUnit unit);
    public Torque ToUnit(TorqueUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(TorqueUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Torque ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<TorqueUnit> UnitsNet.IQuantity<UnitsNet.Units.TorqueUnit>.ToUnit(TorqueUnit unit);
    private sealed virtual override IQuantity`1<TorqueUnit> UnitsNet.IQuantity<UnitsNet.Units.TorqueUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.TorquePerLength : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<TorquePerLengthUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<TorquePerLengthUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static TorquePerLengthUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static TorquePerLengthUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static TorquePerLength <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<TorquePerLengthUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static TorquePerLengthUnit BaseUnit { get; }
    public static TorquePerLengthUnit[] Units { get; }
    public static TorquePerLength Zero { get; }
    public static TorquePerLength AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public TorquePerLengthUnit Unit { get; }
    public QuantityInfo`1<TorquePerLengthUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double KilogramForceCentimetersPerMeter { get; }
    public double KilogramForceMetersPerMeter { get; }
    public double KilogramForceMillimetersPerMeter { get; }
    public double KilonewtonCentimetersPerMeter { get; }
    public double KilonewtonMetersPerMeter { get; }
    public double KilonewtonMillimetersPerMeter { get; }
    public double KilopoundForceFeetPerFoot { get; }
    public double KilopoundForceInchesPerFoot { get; }
    public double MeganewtonCentimetersPerMeter { get; }
    public double MeganewtonMetersPerMeter { get; }
    public double MeganewtonMillimetersPerMeter { get; }
    public double MegapoundForceFeetPerFoot { get; }
    public double MegapoundForceInchesPerFoot { get; }
    public double NewtonCentimetersPerMeter { get; }
    public double NewtonMetersPerMeter { get; }
    public double NewtonMillimetersPerMeter { get; }
    public double PoundForceFeetPerFoot { get; }
    public double PoundForceInchesPerFoot { get; }
    public double TonneForceCentimetersPerMeter { get; }
    public double TonneForceMetersPerMeter { get; }
    public double TonneForceMillimetersPerMeter { get; }
    private static TorquePerLength();
    public TorquePerLength(double value, TorquePerLengthUnit unit);
    public TorquePerLength(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<TorquePerLengthUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static TorquePerLengthUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static TorquePerLengthUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override TorquePerLength get_Zero();
    public static override TorquePerLength get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual TorquePerLengthUnit get_Unit();
    public sealed virtual QuantityInfo`1<TorquePerLengthUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_KilogramForceCentimetersPerMeter();
    public double get_KilogramForceMetersPerMeter();
    public double get_KilogramForceMillimetersPerMeter();
    public double get_KilonewtonCentimetersPerMeter();
    public double get_KilonewtonMetersPerMeter();
    public double get_KilonewtonMillimetersPerMeter();
    public double get_KilopoundForceFeetPerFoot();
    public double get_KilopoundForceInchesPerFoot();
    public double get_MeganewtonCentimetersPerMeter();
    public double get_MeganewtonMetersPerMeter();
    public double get_MeganewtonMillimetersPerMeter();
    public double get_MegapoundForceFeetPerFoot();
    public double get_MegapoundForceInchesPerFoot();
    public double get_NewtonCentimetersPerMeter();
    public double get_NewtonMetersPerMeter();
    public double get_NewtonMillimetersPerMeter();
    public double get_PoundForceFeetPerFoot();
    public double get_PoundForceInchesPerFoot();
    public double get_TonneForceCentimetersPerMeter();
    public double get_TonneForceMetersPerMeter();
    public double get_TonneForceMillimetersPerMeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(TorquePerLengthUnit unit);
    public static string GetAbbreviation(TorquePerLengthUnit unit, IFormatProvider provider);
    public static TorquePerLength FromKilogramForceCentimetersPerMeter(double value);
    public static TorquePerLength FromKilogramForceMetersPerMeter(double value);
    public static TorquePerLength FromKilogramForceMillimetersPerMeter(double value);
    public static TorquePerLength FromKilonewtonCentimetersPerMeter(double value);
    public static TorquePerLength FromKilonewtonMetersPerMeter(double value);
    public static TorquePerLength FromKilonewtonMillimetersPerMeter(double value);
    public static TorquePerLength FromKilopoundForceFeetPerFoot(double value);
    public static TorquePerLength FromKilopoundForceInchesPerFoot(double value);
    public static TorquePerLength FromMeganewtonCentimetersPerMeter(double value);
    public static TorquePerLength FromMeganewtonMetersPerMeter(double value);
    public static TorquePerLength FromMeganewtonMillimetersPerMeter(double value);
    public static TorquePerLength FromMegapoundForceFeetPerFoot(double value);
    public static TorquePerLength FromMegapoundForceInchesPerFoot(double value);
    public static TorquePerLength FromNewtonCentimetersPerMeter(double value);
    public static TorquePerLength FromNewtonMetersPerMeter(double value);
    public static TorquePerLength FromNewtonMillimetersPerMeter(double value);
    public static TorquePerLength FromPoundForceFeetPerFoot(double value);
    public static TorquePerLength FromPoundForceInchesPerFoot(double value);
    public static TorquePerLength FromTonneForceCentimetersPerMeter(double value);
    public static TorquePerLength FromTonneForceMetersPerMeter(double value);
    public static TorquePerLength FromTonneForceMillimetersPerMeter(double value);
    public static TorquePerLength From(double value, TorquePerLengthUnit fromUnit);
    public static TorquePerLength Parse(string str);
    public static override TorquePerLength Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, TorquePerLength& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, TorquePerLength& result);
    public static TorquePerLengthUnit ParseUnit(string str);
    public static TorquePerLengthUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, TorquePerLengthUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, TorquePerLengthUnit& unit);
    public static override TorquePerLength op_UnaryNegation(TorquePerLength right);
    public static override TorquePerLength op_Addition(TorquePerLength left, TorquePerLength right);
    public static override TorquePerLength op_Subtraction(TorquePerLength left, TorquePerLength right);
    public static TorquePerLength op_Multiply(double left, TorquePerLength right);
    public static override TorquePerLength op_Multiply(TorquePerLength left, double right);
    public static override TorquePerLength op_Division(TorquePerLength left, double right);
    public static double op_Division(TorquePerLength left, TorquePerLength right);
    public static override bool op_LessThanOrEqual(TorquePerLength left, TorquePerLength right);
    public static override bool op_GreaterThanOrEqual(TorquePerLength left, TorquePerLength right);
    public static override bool op_LessThan(TorquePerLength left, TorquePerLength right);
    public static override bool op_GreaterThan(TorquePerLength left, TorquePerLength right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(TorquePerLength other, TorquePerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(TorquePerLength left, TorquePerLength right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(TorquePerLength other, TorquePerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(TorquePerLength left, TorquePerLength right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(TorquePerLength other, TorquePerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(TorquePerLength other, TorquePerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(TorquePerLength other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(TorquePerLength other);
    [ObsoleteAttribute("Use Equals(TorquePerLength other, TorquePerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(TorquePerLength other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(TorquePerLength other, TorquePerLength tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(TorquePerLengthUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public TorquePerLength ToUnit(TorquePerLengthUnit unit);
    public TorquePerLength ToUnit(TorquePerLengthUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(TorquePerLengthUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public TorquePerLength ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<TorquePerLengthUnit> UnitsNet.IQuantity<UnitsNet.Units.TorquePerLengthUnit>.ToUnit(TorquePerLengthUnit unit);
    private sealed virtual override IQuantity`1<TorquePerLengthUnit> UnitsNet.IQuantity<UnitsNet.Units.TorquePerLengthUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Turbidity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<TurbidityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<TurbidityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static TurbidityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static TurbidityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Turbidity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<TurbidityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static TurbidityUnit BaseUnit { get; }
    public static TurbidityUnit[] Units { get; }
    public static Turbidity Zero { get; }
    public static Turbidity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public TurbidityUnit Unit { get; }
    public QuantityInfo`1<TurbidityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double NTU { get; }
    private static Turbidity();
    public Turbidity(double value, TurbidityUnit unit);
    public Turbidity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<TurbidityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static TurbidityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static TurbidityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Turbidity get_Zero();
    public static override Turbidity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual TurbidityUnit get_Unit();
    public sealed virtual QuantityInfo`1<TurbidityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_NTU();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(TurbidityUnit unit);
    public static string GetAbbreviation(TurbidityUnit unit, IFormatProvider provider);
    public static Turbidity FromNTU(double value);
    public static Turbidity From(double value, TurbidityUnit fromUnit);
    public static Turbidity Parse(string str);
    public static override Turbidity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Turbidity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Turbidity& result);
    public static TurbidityUnit ParseUnit(string str);
    public static TurbidityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, TurbidityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, TurbidityUnit& unit);
    public static override Turbidity op_UnaryNegation(Turbidity right);
    public static override Turbidity op_Addition(Turbidity left, Turbidity right);
    public static override Turbidity op_Subtraction(Turbidity left, Turbidity right);
    public static Turbidity op_Multiply(double left, Turbidity right);
    public static override Turbidity op_Multiply(Turbidity left, double right);
    public static override Turbidity op_Division(Turbidity left, double right);
    public static double op_Division(Turbidity left, Turbidity right);
    public static override bool op_LessThanOrEqual(Turbidity left, Turbidity right);
    public static override bool op_GreaterThanOrEqual(Turbidity left, Turbidity right);
    public static override bool op_LessThan(Turbidity left, Turbidity right);
    public static override bool op_GreaterThan(Turbidity left, Turbidity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Turbidity other, Turbidity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Turbidity left, Turbidity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Turbidity other, Turbidity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Turbidity left, Turbidity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Turbidity other, Turbidity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Turbidity other, Turbidity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Turbidity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Turbidity other);
    [ObsoleteAttribute("Use Equals(Turbidity other, Turbidity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Turbidity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Turbidity other, Turbidity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(TurbidityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Turbidity ToUnit(TurbidityUnit unit);
    public Turbidity ToUnit(TurbidityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(TurbidityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Turbidity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<TurbidityUnit> UnitsNet.IQuantity<UnitsNet.Units.TurbidityUnit>.ToUnit(TurbidityUnit unit);
    private sealed virtual override IQuantity`1<TurbidityUnit> UnitsNet.IQuantity<UnitsNet.Units.TurbidityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.UnitAbbreviationsCache : object {
    internal static CultureInfo FallbackCulture;
    [CompilerGeneratedAttribute]
private QuantityInfoLookup <QuantityInfoLookup>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<AbbreviationMapKey, IReadOnlyList`1<string>> <AbbreviationsMap>k__BackingField;
    [ObsoleteAttribute("Use UnitsNetSetup.Default.UnitAbbreviations instead.")]
public static UnitAbbreviationsCache Default { get; }
    private QuantityInfoLookup QuantityInfoLookup { get; }
    private ConcurrentDictionary`2<AbbreviationMapKey, IReadOnlyList`1<string>> AbbreviationsMap { get; }
    internal UnitAbbreviationsCache(QuantityInfoLookup quantityInfoLookup);
    private static UnitAbbreviationsCache();
    public static UnitAbbreviationsCache get_Default();
    [CompilerGeneratedAttribute]
private QuantityInfoLookup get_QuantityInfoLookup();
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<AbbreviationMapKey, IReadOnlyList`1<string>> get_AbbreviationsMap();
    public static UnitAbbreviationsCache CreateEmpty();
    public static UnitAbbreviationsCache CreateDefault();
    public void MapUnitToAbbreviation(TUnitType unit, String[] abbreviations);
    public void MapUnitToDefaultAbbreviation(TUnitType unit, string abbreviation);
    public void MapUnitToAbbreviation(TUnitType unit, IFormatProvider formatProvider, String[] abbreviations);
    public void MapUnitToDefaultAbbreviation(TUnitType unit, IFormatProvider formatProvider, string abbreviation);
    public void MapUnitToAbbreviation(Type unitType, int unitValue, IFormatProvider formatProvider, String[] abbreviations);
    public void MapUnitToDefaultAbbreviation(Type unitType, int unitValue, IFormatProvider formatProvider, string abbreviation);
    private void PerformAbbreviationMapping(Enum unitValue, IFormatProvider formatProvider, bool setAsDefault, String[] abbreviations);
    public string GetDefaultAbbreviation(TUnitType unit, IFormatProvider formatProvider);
    public string GetDefaultAbbreviation(Type unitType, int unitValue, IFormatProvider formatProvider);
    public String[] GetUnitAbbreviations(TUnitType unit, IFormatProvider formatProvider);
    public String[] GetUnitAbbreviations(Type unitType, int unitValue, IFormatProvider formatProvider);
    private bool TryGetUnitAbbreviations(Type unitType, int unitValue, IFormatProvider formatProvider, String[]& abbreviations);
    public IReadOnlyList`1<string> GetAllUnitAbbreviationsForQuantity(Type unitEnumType, IFormatProvider formatProvider);
    internal List`1<ValueTuple`2<string, Enum>> GetStringUnitPairs(IEnumerable`1<Enum> enumValues, IFormatProvider formatProvider);
    public IReadOnlyList`1<string> GetAbbreviations(UnitInfo unitInfo, IFormatProvider formatProvider);
    private void AddAbbreviation(UnitInfo unitInfo, IFormatProvider formatProvider, bool setAsDefault, String[] newAbbreviations);
    private static IReadOnlyList`1<string> AddAbbreviationsToList(bool setAsDefault, List`1<string> list, IEnumerable`1<string> abbreviations);
    private static AbbreviationMapKey GetAbbreviationMapKey(UnitInfo unitInfo, string cultureName);
    private static string GetCultureNameOrEnglish(CultureInfo culture);
    private IReadOnlyList`1<string> ReadAbbreviationsFromResourceFile(string quantityName, string unitPluralName, CultureInfo culture);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("128")]
public abstract class UnitsNet.UnitAttributeBase : Attribute {
    [CompilerGeneratedAttribute]
private Enum <UnitType>k__BackingField;
    public Enum UnitType { get; public set; }
    public UnitAttributeBase(object unitType);
    [CompilerGeneratedAttribute]
public Enum get_UnitType();
    [CompilerGeneratedAttribute]
public void set_UnitType(Enum value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.UnitConverter : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ConcurrentDictionary`2<ValueTuple`4<Type, Enum, Type, Enum>, ConversionFunction> <ConversionFunctions>k__BackingField;
    [ObsoleteAttribute("Use UnitsNetSetup.Default.UnitConverter instead.")]
public static UnitConverter Default { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ValueTuple`4<Type, Enum, Type, Enum>, ConversionFunction> ConversionFunctions { get; }
    public UnitConverter(UnitConverter other);
    public static UnitConverter get_Default();
    public static UnitConverter CreateDefault();
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<ValueTuple`4<Type, Enum, Type, Enum>, ConversionFunction> get_ConversionFunctions();
    public static void RegisterDefaultConversions(UnitConverter unitConverter);
    public void SetConversionFunction(Enum from, Enum to, ConversionFunction`1<TQuantity> conversionFunction);
    public void SetConversionFunction(Enum from, Enum to, ConversionFunction conversionFunction);
    public void SetConversionFunction(Type fromType, Enum from, Type toType, Enum to, ConversionFunction conversionFunction);
    internal void SetConversionFunction(ValueTuple`4<Type, Enum, Type, Enum> lookupKey, ConversionFunction conversionFunction);
    internal void SetConversionFunction(ValueTuple`4<Type, Enum, Type, Enum> conversionLookup, ConversionFunction`1<TQuantity> conversionFunction);
    public ConversionFunction GetConversionFunction(Enum from, Enum to);
    public ConversionFunction GetConversionFunction(Enum from, Enum to);
    public ConversionFunction GetConversionFunction(Type fromType, Enum from, Type toType, Enum to);
    internal ConversionFunction GetConversionFunction(ValueTuple`4<Type, Enum, Type, Enum> lookupKey);
    public bool TryGetConversionFunction(Enum from, Enum to, ConversionFunction& conversionFunction);
    public bool TryGetConversionFunction(Enum from, Enum to, ConversionFunction& conversionFunction);
    public bool TryGetConversionFunction(Type fromType, Enum from, Type toType, Enum to, ConversionFunction& conversionFunction);
    [NullableContextAttribute("2")]
public bool TryGetConversionFunction(ValueTuple`4<Type, Enum, Type, Enum> lookupKey, ConversionFunction& conversionFunction);
    public static double Convert(double fromValue, Enum fromUnitValue, Enum toUnitValue);
    public static bool TryConvert(double fromValue, Enum fromUnitValue, Enum toUnitValue, Double& convertedValue);
    public static double ConvertByName(double fromValue, string quantityName, string fromUnit, string toUnit);
    public static bool TryConvertByName(double inputValue, string quantityName, string fromUnit, string toUnit, Double& result);
    public static double ConvertByAbbreviation(double fromValue, string quantityName, string fromUnitAbbrev, string toUnitAbbrev);
    public static double ConvertByAbbreviation(double fromValue, string quantityName, string fromUnitAbbrev, string toUnitAbbrev, string culture);
    public static bool TryConvertByAbbreviation(double fromValue, string quantityName, string fromUnitAbbrev, string toUnitAbbrev, Double& result);
    public static bool TryConvertByAbbreviation(double fromValue, string quantityName, string fromUnitAbbrev, string toUnitAbbrev, Double& result, string culture);
    internal static bool TryParseUnit(Type unitType, string unitName, Enum& unitValue);
    internal static bool TryParseUnit(string quantityName, string unitName, Enum& unitValue);
    internal static bool TryGetUnitType(string quantityName, Type& unitType);
    [CompilerGeneratedAttribute]
internal static IQuantity <GetConversionFunction>g__EchoFunction|17_0(IQuantity fromQuantity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class UnitsNet.UnitFormatter : object {
    public static string GetFormat(double value, int significantDigitsAfterRadix);
    private static bool NearlyEqual(double a, double b);
    public static Object[] GetFormatArgs(TUnitType unit, double value, IFormatProvider culture, IEnumerable`1<object> args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.UnitInfo : object {
    [CompilerGeneratedAttribute]
private Enum <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PluralName>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseUnits <BaseUnits>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <QuantityName>k__BackingField;
    public Enum Value { get; }
    public string Name { get; }
    public string PluralName { get; }
    public BaseUnits BaseUnits { get; }
    [NullableAttribute("2")]
public string QuantityName { get; }
    public UnitInfo(Enum value, string pluralName, BaseUnits baseUnits);
    internal UnitInfo(Enum value, string pluralName, BaseUnits baseUnits, string quantityName);
    [CompilerGeneratedAttribute]
public Enum get_Value();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_PluralName();
    [CompilerGeneratedAttribute]
public BaseUnits get_BaseUnits();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_QuantityName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.UnitInfo`1 : UnitInfo {
    [CompilerGeneratedAttribute]
private TUnit <Value>k__BackingField;
    public TUnit Value { get; }
    public UnitInfo`1(TUnit value, string pluralName, BaseUnits baseUnits);
    internal UnitInfo`1(TUnit value, string pluralName, BaseUnits baseUnits, string quantityName);
    [CompilerGeneratedAttribute]
public TUnit get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class UnitsNet.UnitMath : object {
    [ExtensionAttribute]
public static TQuantity Abs(TQuantity value);
    [ExtensionAttribute]
public static TQuantity Sum(IEnumerable`1<TQuantity> source, TUnitType unitType);
    [ExtensionAttribute]
public static TQuantity Sum(IEnumerable`1<TSource> source, Func`2<TSource, TQuantity> selector, TUnitType unitType);
    public static TQuantity Min(TQuantity val1, TQuantity val2);
    [ExtensionAttribute]
public static TQuantity Min(IEnumerable`1<TQuantity> source, TUnitType unitType);
    [ExtensionAttribute]
public static TQuantity Min(IEnumerable`1<TSource> source, Func`2<TSource, TQuantity> selector, TUnitType unitType);
    public static TQuantity Max(TQuantity val1, TQuantity val2);
    [ExtensionAttribute]
public static TQuantity Max(IEnumerable`1<TQuantity> source, TUnitType unitType);
    [ExtensionAttribute]
public static TQuantity Max(IEnumerable`1<TSource> source, Func`2<TSource, TQuantity> selector, TUnitType unitType);
    [ExtensionAttribute]
public static TQuantity Average(IEnumerable`1<TQuantity> source, TUnitType unitType);
    [ExtensionAttribute]
public static TQuantity Average(IEnumerable`1<TSource> source, Func`2<TSource, TQuantity> selector, TUnitType unitType);
    public static TQuantity Clamp(TQuantity value, TQuantity min, TQuantity max);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.UnitNotFoundException : UnitsNetException {
    public UnitNotFoundException(string message);
    public UnitNotFoundException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.UnitParser : object {
    private UnitAbbreviationsCache _unitAbbreviationsCache;
    [ObsoleteAttribute("Use UnitsNetSetup.Default.UnitParser instead.")]
public static UnitParser Default { get; }
    [NullableContextAttribute("2")]
public UnitParser(UnitAbbreviationsCache unitAbbreviationsCache);
    public static UnitParser get_Default();
    public TUnitType Parse(string unitAbbreviation, IFormatProvider formatProvider);
    public Enum Parse(string unitAbbreviation, Type unitType, IFormatProvider formatProvider);
    internal static string NormalizeUnitString(string unitAbbreviation);
    [NullableContextAttribute("0")]
public bool TryParse(string unitAbbreviation, TUnitType& unit);
    [NullableContextAttribute("0")]
public bool TryParse(string unitAbbreviation, IFormatProvider formatProvider, TUnitType& unit);
    public bool TryParse(string unitAbbreviation, Type unitType, Enum& unit);
    [NullableContextAttribute("2")]
public bool TryParse(string unitAbbreviation, Type unitType, IFormatProvider formatProvider, Enum& unit);
}
public enum UnitsNet.Units.AbsorbedDoseOfIonizingRadiationUnit : Enum {
    public int value__;
    public static AbsorbedDoseOfIonizingRadiationUnit Centigray;
    public static AbsorbedDoseOfIonizingRadiationUnit Femtogray;
    public static AbsorbedDoseOfIonizingRadiationUnit Gigagray;
    public static AbsorbedDoseOfIonizingRadiationUnit Gray;
    public static AbsorbedDoseOfIonizingRadiationUnit Kilogray;
    public static AbsorbedDoseOfIonizingRadiationUnit Kilorad;
    public static AbsorbedDoseOfIonizingRadiationUnit Megagray;
    public static AbsorbedDoseOfIonizingRadiationUnit Megarad;
    public static AbsorbedDoseOfIonizingRadiationUnit Microgray;
    public static AbsorbedDoseOfIonizingRadiationUnit Milligray;
    public static AbsorbedDoseOfIonizingRadiationUnit Millirad;
    public static AbsorbedDoseOfIonizingRadiationUnit Nanogray;
    public static AbsorbedDoseOfIonizingRadiationUnit Petagray;
    public static AbsorbedDoseOfIonizingRadiationUnit Picogray;
    public static AbsorbedDoseOfIonizingRadiationUnit Rad;
    public static AbsorbedDoseOfIonizingRadiationUnit Teragray;
}
public enum UnitsNet.Units.AccelerationUnit : Enum {
    public int value__;
    public static AccelerationUnit CentimeterPerSecondSquared;
    public static AccelerationUnit DecimeterPerSecondSquared;
    public static AccelerationUnit FootPerSecondSquared;
    public static AccelerationUnit InchPerSecondSquared;
    public static AccelerationUnit KilometerPerSecondSquared;
    public static AccelerationUnit KnotPerHour;
    public static AccelerationUnit KnotPerMinute;
    public static AccelerationUnit KnotPerSecond;
    public static AccelerationUnit MeterPerSecondSquared;
    public static AccelerationUnit MicrometerPerSecondSquared;
    public static AccelerationUnit MillimeterPerSecondSquared;
    public static AccelerationUnit MillistandardGravity;
    public static AccelerationUnit NanometerPerSecondSquared;
    public static AccelerationUnit StandardGravity;
}
public enum UnitsNet.Units.AmountOfSubstanceUnit : Enum {
    public int value__;
    public static AmountOfSubstanceUnit Centimole;
    public static AmountOfSubstanceUnit CentipoundMole;
    public static AmountOfSubstanceUnit Decimole;
    public static AmountOfSubstanceUnit DecipoundMole;
    public static AmountOfSubstanceUnit Femtomole;
    public static AmountOfSubstanceUnit Kilomole;
    public static AmountOfSubstanceUnit KilopoundMole;
    public static AmountOfSubstanceUnit Megamole;
    public static AmountOfSubstanceUnit Micromole;
    public static AmountOfSubstanceUnit MicropoundMole;
    public static AmountOfSubstanceUnit Millimole;
    public static AmountOfSubstanceUnit MillipoundMole;
    public static AmountOfSubstanceUnit Mole;
    public static AmountOfSubstanceUnit Nanomole;
    public static AmountOfSubstanceUnit NanopoundMole;
    public static AmountOfSubstanceUnit Picomole;
    public static AmountOfSubstanceUnit PoundMole;
}
public enum UnitsNet.Units.AmplitudeRatioUnit : Enum {
    public int value__;
    public static AmplitudeRatioUnit DecibelMicrovolt;
    public static AmplitudeRatioUnit DecibelMillivolt;
    public static AmplitudeRatioUnit DecibelUnloaded;
    public static AmplitudeRatioUnit DecibelVolt;
}
public enum UnitsNet.Units.AngleUnit : Enum {
    public int value__;
    public static AngleUnit Arcminute;
    public static AngleUnit Arcsecond;
    public static AngleUnit Centiradian;
    public static AngleUnit Deciradian;
    public static AngleUnit Degree;
    public static AngleUnit Gradian;
    public static AngleUnit Microdegree;
    public static AngleUnit Microradian;
    public static AngleUnit Millidegree;
    public static AngleUnit Milliradian;
    public static AngleUnit Nanodegree;
    public static AngleUnit Nanoradian;
    public static AngleUnit NatoMil;
    public static AngleUnit Radian;
    public static AngleUnit Revolution;
    public static AngleUnit Tilt;
}
public enum UnitsNet.Units.ApparentEnergyUnit : Enum {
    public int value__;
    public static ApparentEnergyUnit KilovoltampereHour;
    public static ApparentEnergyUnit MegavoltampereHour;
    public static ApparentEnergyUnit VoltampereHour;
}
public enum UnitsNet.Units.ApparentPowerUnit : Enum {
    public int value__;
    public static ApparentPowerUnit Gigavoltampere;
    public static ApparentPowerUnit Kilovoltampere;
    public static ApparentPowerUnit Megavoltampere;
    public static ApparentPowerUnit Microvoltampere;
    public static ApparentPowerUnit Millivoltampere;
    public static ApparentPowerUnit Voltampere;
}
public enum UnitsNet.Units.AreaDensityUnit : Enum {
    public int value__;
    public static AreaDensityUnit GramPerSquareMeter;
    public static AreaDensityUnit KilogramPerSquareMeter;
    public static AreaDensityUnit MilligramPerSquareMeter;
}
public enum UnitsNet.Units.AreaMomentOfInertiaUnit : Enum {
    public int value__;
    public static AreaMomentOfInertiaUnit CentimeterToTheFourth;
    public static AreaMomentOfInertiaUnit DecimeterToTheFourth;
    public static AreaMomentOfInertiaUnit FootToTheFourth;
    public static AreaMomentOfInertiaUnit InchToTheFourth;
    public static AreaMomentOfInertiaUnit MeterToTheFourth;
    public static AreaMomentOfInertiaUnit MillimeterToTheFourth;
}
public enum UnitsNet.Units.AreaUnit : Enum {
    public int value__;
    public static AreaUnit Acre;
    public static AreaUnit Hectare;
    public static AreaUnit SquareCentimeter;
    public static AreaUnit SquareDecimeter;
    public static AreaUnit SquareFoot;
    public static AreaUnit SquareInch;
    public static AreaUnit SquareKilometer;
    public static AreaUnit SquareMeter;
    public static AreaUnit SquareMicrometer;
    public static AreaUnit SquareMile;
    public static AreaUnit SquareMillimeter;
    public static AreaUnit SquareNauticalMile;
    public static AreaUnit SquareYard;
    public static AreaUnit UsSurveySquareFoot;
}
public enum UnitsNet.Units.BitRateUnit : Enum {
    public int value__;
    public static BitRateUnit BitPerSecond;
    public static BitRateUnit BytePerSecond;
    public static BitRateUnit ExabitPerSecond;
    public static BitRateUnit ExabytePerSecond;
    public static BitRateUnit ExbibitPerSecond;
    public static BitRateUnit ExbibytePerSecond;
    public static BitRateUnit GibibitPerSecond;
    public static BitRateUnit GibibytePerSecond;
    public static BitRateUnit GigabitPerSecond;
    public static BitRateUnit GigabytePerSecond;
    public static BitRateUnit KibibitPerSecond;
    public static BitRateUnit KibibytePerSecond;
    public static BitRateUnit KilobitPerSecond;
    public static BitRateUnit KilobytePerSecond;
    public static BitRateUnit MebibitPerSecond;
    public static BitRateUnit MebibytePerSecond;
    public static BitRateUnit MegabitPerSecond;
    public static BitRateUnit MegabytePerSecond;
    public static BitRateUnit PebibitPerSecond;
    public static BitRateUnit PebibytePerSecond;
    public static BitRateUnit PetabitPerSecond;
    public static BitRateUnit PetabytePerSecond;
    public static BitRateUnit TebibitPerSecond;
    public static BitRateUnit TebibytePerSecond;
    public static BitRateUnit TerabitPerSecond;
    public static BitRateUnit TerabytePerSecond;
}
public enum UnitsNet.Units.BrakeSpecificFuelConsumptionUnit : Enum {
    public int value__;
    public static BrakeSpecificFuelConsumptionUnit GramPerKiloWattHour;
    public static BrakeSpecificFuelConsumptionUnit KilogramPerJoule;
    public static BrakeSpecificFuelConsumptionUnit PoundPerMechanicalHorsepowerHour;
}
public enum UnitsNet.Units.CapacitanceUnit : Enum {
    public int value__;
    public static CapacitanceUnit Farad;
    public static CapacitanceUnit Kilofarad;
    public static CapacitanceUnit Megafarad;
    public static CapacitanceUnit Microfarad;
    public static CapacitanceUnit Millifarad;
    public static CapacitanceUnit Nanofarad;
    public static CapacitanceUnit Picofarad;
}
public enum UnitsNet.Units.CoefficientOfThermalExpansionUnit : Enum {
    public int value__;
    public static CoefficientOfThermalExpansionUnit PerDegreeCelsius;
    public static CoefficientOfThermalExpansionUnit PerDegreeFahrenheit;
    public static CoefficientOfThermalExpansionUnit PerKelvin;
    public static CoefficientOfThermalExpansionUnit PpmPerDegreeCelsius;
    public static CoefficientOfThermalExpansionUnit PpmPerDegreeFahrenheit;
    public static CoefficientOfThermalExpansionUnit PpmPerKelvin;
}
public enum UnitsNet.Units.CompressibilityUnit : Enum {
    public int value__;
    public static CompressibilityUnit InverseAtmosphere;
    public static CompressibilityUnit InverseBar;
    public static CompressibilityUnit InverseKilopascal;
    public static CompressibilityUnit InverseMegapascal;
    public static CompressibilityUnit InverseMillibar;
    public static CompressibilityUnit InversePascal;
    public static CompressibilityUnit InversePoundForcePerSquareInch;
}
public enum UnitsNet.Units.DensityUnit : Enum {
    public int value__;
    public static DensityUnit CentigramPerDeciliter;
    public static DensityUnit CentigramPerLiter;
    public static DensityUnit CentigramPerMilliliter;
    public static DensityUnit DecigramPerDeciliter;
    public static DensityUnit DecigramPerLiter;
    public static DensityUnit DecigramPerMilliliter;
    public static DensityUnit FemtogramPerDeciliter;
    public static DensityUnit FemtogramPerLiter;
    public static DensityUnit FemtogramPerMilliliter;
    public static DensityUnit GramPerCubicCentimeter;
    public static DensityUnit GramPerCubicFoot;
    public static DensityUnit GramPerCubicInch;
    public static DensityUnit GramPerCubicMeter;
    public static DensityUnit GramPerCubicMillimeter;
    public static DensityUnit GramPerDeciliter;
    public static DensityUnit GramPerLiter;
    public static DensityUnit GramPerMilliliter;
    public static DensityUnit KilogramPerCubicCentimeter;
    public static DensityUnit KilogramPerCubicMeter;
    public static DensityUnit KilogramPerCubicMillimeter;
    public static DensityUnit KilogramPerLiter;
    public static DensityUnit KilopoundPerCubicFoot;
    public static DensityUnit KilopoundPerCubicInch;
    public static DensityUnit KilopoundPerCubicYard;
    public static DensityUnit MicrogramPerCubicMeter;
    public static DensityUnit MicrogramPerDeciliter;
    public static DensityUnit MicrogramPerLiter;
    public static DensityUnit MicrogramPerMilliliter;
    public static DensityUnit MilligramPerCubicMeter;
    public static DensityUnit MilligramPerDeciliter;
    public static DensityUnit MilligramPerLiter;
    public static DensityUnit MilligramPerMilliliter;
    public static DensityUnit NanogramPerDeciliter;
    public static DensityUnit NanogramPerLiter;
    public static DensityUnit NanogramPerMilliliter;
    public static DensityUnit PicogramPerDeciliter;
    public static DensityUnit PicogramPerLiter;
    public static DensityUnit PicogramPerMilliliter;
    public static DensityUnit PoundPerCubicCentimeter;
    public static DensityUnit PoundPerCubicFoot;
    public static DensityUnit PoundPerCubicInch;
    public static DensityUnit PoundPerCubicMeter;
    public static DensityUnit PoundPerCubicMillimeter;
    public static DensityUnit PoundPerCubicYard;
    public static DensityUnit PoundPerImperialGallon;
    public static DensityUnit PoundPerUSGallon;
    public static DensityUnit SlugPerCubicCentimeter;
    public static DensityUnit SlugPerCubicFoot;
    public static DensityUnit SlugPerCubicInch;
    public static DensityUnit SlugPerCubicMeter;
    public static DensityUnit SlugPerCubicMillimeter;
    public static DensityUnit TonnePerCubicCentimeter;
    public static DensityUnit TonnePerCubicFoot;
    public static DensityUnit TonnePerCubicInch;
    public static DensityUnit TonnePerCubicMeter;
    public static DensityUnit TonnePerCubicMillimeter;
}
public enum UnitsNet.Units.DurationUnit : Enum {
    public int value__;
    public static DurationUnit Day;
    public static DurationUnit Hour;
    public static DurationUnit JulianYear;
    public static DurationUnit Microsecond;
    public static DurationUnit Millisecond;
    public static DurationUnit Minute;
    public static DurationUnit Month30;
    public static DurationUnit Nanosecond;
    public static DurationUnit Second;
    public static DurationUnit Sol;
    public static DurationUnit Week;
    public static DurationUnit Year365;
}
public enum UnitsNet.Units.DynamicViscosityUnit : Enum {
    public int value__;
    public static DynamicViscosityUnit Centipoise;
    public static DynamicViscosityUnit MicropascalSecond;
    public static DynamicViscosityUnit MillipascalSecond;
    public static DynamicViscosityUnit NewtonSecondPerMeterSquared;
    public static DynamicViscosityUnit PascalSecond;
    public static DynamicViscosityUnit Poise;
    public static DynamicViscosityUnit PoundForceSecondPerSquareFoot;
    public static DynamicViscosityUnit PoundForceSecondPerSquareInch;
    public static DynamicViscosityUnit PoundPerFootSecond;
    public static DynamicViscosityUnit Reyn;
}
public enum UnitsNet.Units.ElectricAdmittanceUnit : Enum {
    public int value__;
    public static ElectricAdmittanceUnit Microsiemens;
    public static ElectricAdmittanceUnit Millisiemens;
    public static ElectricAdmittanceUnit Nanosiemens;
    public static ElectricAdmittanceUnit Siemens;
}
public enum UnitsNet.Units.ElectricChargeDensityUnit : Enum {
    public int value__;
    public static ElectricChargeDensityUnit CoulombPerCubicMeter;
}
public enum UnitsNet.Units.ElectricChargeUnit : Enum {
    public int value__;
    public static ElectricChargeUnit AmpereHour;
    public static ElectricChargeUnit Coulomb;
    public static ElectricChargeUnit KiloampereHour;
    public static ElectricChargeUnit Kilocoulomb;
    public static ElectricChargeUnit MegaampereHour;
    public static ElectricChargeUnit Megacoulomb;
    public static ElectricChargeUnit Microcoulomb;
    public static ElectricChargeUnit MilliampereHour;
    public static ElectricChargeUnit Millicoulomb;
    public static ElectricChargeUnit Nanocoulomb;
    public static ElectricChargeUnit Picocoulomb;
}
public enum UnitsNet.Units.ElectricConductanceUnit : Enum {
    public int value__;
    public static ElectricConductanceUnit Kilosiemens;
    public static ElectricConductanceUnit Microsiemens;
    public static ElectricConductanceUnit Millisiemens;
    public static ElectricConductanceUnit Nanosiemens;
    public static ElectricConductanceUnit Siemens;
}
public enum UnitsNet.Units.ElectricConductivityUnit : Enum {
    public int value__;
    public static ElectricConductivityUnit MicrosiemensPerCentimeter;
    public static ElectricConductivityUnit MillisiemensPerCentimeter;
    public static ElectricConductivityUnit SiemensPerCentimeter;
    public static ElectricConductivityUnit SiemensPerFoot;
    public static ElectricConductivityUnit SiemensPerInch;
    public static ElectricConductivityUnit SiemensPerMeter;
}
public enum UnitsNet.Units.ElectricCurrentDensityUnit : Enum {
    public int value__;
    public static ElectricCurrentDensityUnit AmperePerSquareFoot;
    public static ElectricCurrentDensityUnit AmperePerSquareInch;
    public static ElectricCurrentDensityUnit AmperePerSquareMeter;
}
public enum UnitsNet.Units.ElectricCurrentGradientUnit : Enum {
    public int value__;
    public static ElectricCurrentGradientUnit AmperePerMicrosecond;
    public static ElectricCurrentGradientUnit AmperePerMillisecond;
    public static ElectricCurrentGradientUnit AmperePerMinute;
    public static ElectricCurrentGradientUnit AmperePerNanosecond;
    public static ElectricCurrentGradientUnit AmperePerSecond;
    public static ElectricCurrentGradientUnit MilliamperePerMinute;
    public static ElectricCurrentGradientUnit MilliamperePerSecond;
}
public enum UnitsNet.Units.ElectricCurrentUnit : Enum {
    public int value__;
    public static ElectricCurrentUnit Ampere;
    public static ElectricCurrentUnit Centiampere;
    public static ElectricCurrentUnit Femtoampere;
    public static ElectricCurrentUnit Kiloampere;
    public static ElectricCurrentUnit Megaampere;
    public static ElectricCurrentUnit Microampere;
    public static ElectricCurrentUnit Milliampere;
    public static ElectricCurrentUnit Nanoampere;
    public static ElectricCurrentUnit Picoampere;
}
public enum UnitsNet.Units.ElectricFieldUnit : Enum {
    public int value__;
    public static ElectricFieldUnit VoltPerMeter;
}
public enum UnitsNet.Units.ElectricInductanceUnit : Enum {
    public int value__;
    public static ElectricInductanceUnit Henry;
    public static ElectricInductanceUnit Microhenry;
    public static ElectricInductanceUnit Millihenry;
    public static ElectricInductanceUnit Nanohenry;
    public static ElectricInductanceUnit Picohenry;
}
public enum UnitsNet.Units.ElectricPotentialAcUnit : Enum {
    public int value__;
    public static ElectricPotentialAcUnit KilovoltAc;
    public static ElectricPotentialAcUnit MegavoltAc;
    public static ElectricPotentialAcUnit MicrovoltAc;
    public static ElectricPotentialAcUnit MillivoltAc;
    public static ElectricPotentialAcUnit VoltAc;
}
public enum UnitsNet.Units.ElectricPotentialChangeRateUnit : Enum {
    public int value__;
    public static ElectricPotentialChangeRateUnit KilovoltPerHour;
    public static ElectricPotentialChangeRateUnit KilovoltPerMicrosecond;
    public static ElectricPotentialChangeRateUnit KilovoltPerMinute;
    public static ElectricPotentialChangeRateUnit KilovoltPerSecond;
    public static ElectricPotentialChangeRateUnit MegavoltPerHour;
    public static ElectricPotentialChangeRateUnit MegavoltPerMicrosecond;
    public static ElectricPotentialChangeRateUnit MegavoltPerMinute;
    public static ElectricPotentialChangeRateUnit MegavoltPerSecond;
    public static ElectricPotentialChangeRateUnit MicrovoltPerHour;
    public static ElectricPotentialChangeRateUnit MicrovoltPerMicrosecond;
    public static ElectricPotentialChangeRateUnit MicrovoltPerMinute;
    public static ElectricPotentialChangeRateUnit MicrovoltPerSecond;
    public static ElectricPotentialChangeRateUnit MillivoltPerHour;
    public static ElectricPotentialChangeRateUnit MillivoltPerMicrosecond;
    public static ElectricPotentialChangeRateUnit MillivoltPerMinute;
    public static ElectricPotentialChangeRateUnit MillivoltPerSecond;
    public static ElectricPotentialChangeRateUnit VoltPerHour;
    public static ElectricPotentialChangeRateUnit VoltPerMicrosecond;
    public static ElectricPotentialChangeRateUnit VoltPerMinute;
    public static ElectricPotentialChangeRateUnit VoltPerSecond;
}
public enum UnitsNet.Units.ElectricPotentialDcUnit : Enum {
    public int value__;
    public static ElectricPotentialDcUnit KilovoltDc;
    public static ElectricPotentialDcUnit MegavoltDc;
    public static ElectricPotentialDcUnit MicrovoltDc;
    public static ElectricPotentialDcUnit MillivoltDc;
    public static ElectricPotentialDcUnit VoltDc;
}
public enum UnitsNet.Units.ElectricPotentialUnit : Enum {
    public int value__;
    public static ElectricPotentialUnit Kilovolt;
    public static ElectricPotentialUnit Megavolt;
    public static ElectricPotentialUnit Microvolt;
    public static ElectricPotentialUnit Millivolt;
    public static ElectricPotentialUnit Nanovolt;
    public static ElectricPotentialUnit Volt;
}
public enum UnitsNet.Units.ElectricResistanceUnit : Enum {
    public int value__;
    public static ElectricResistanceUnit Gigaohm;
    public static ElectricResistanceUnit Kiloohm;
    public static ElectricResistanceUnit Megaohm;
    public static ElectricResistanceUnit Microohm;
    public static ElectricResistanceUnit Milliohm;
    public static ElectricResistanceUnit Ohm;
    public static ElectricResistanceUnit Teraohm;
}
public enum UnitsNet.Units.ElectricResistivityUnit : Enum {
    public int value__;
    public static ElectricResistivityUnit KiloohmCentimeter;
    public static ElectricResistivityUnit KiloohmMeter;
    public static ElectricResistivityUnit MegaohmCentimeter;
    public static ElectricResistivityUnit MegaohmMeter;
    public static ElectricResistivityUnit MicroohmCentimeter;
    public static ElectricResistivityUnit MicroohmMeter;
    public static ElectricResistivityUnit MilliohmCentimeter;
    public static ElectricResistivityUnit MilliohmMeter;
    public static ElectricResistivityUnit NanoohmCentimeter;
    public static ElectricResistivityUnit NanoohmMeter;
    public static ElectricResistivityUnit OhmCentimeter;
    public static ElectricResistivityUnit OhmMeter;
    public static ElectricResistivityUnit PicoohmCentimeter;
    public static ElectricResistivityUnit PicoohmMeter;
}
public enum UnitsNet.Units.ElectricSurfaceChargeDensityUnit : Enum {
    public int value__;
    public static ElectricSurfaceChargeDensityUnit CoulombPerSquareCentimeter;
    public static ElectricSurfaceChargeDensityUnit CoulombPerSquareInch;
    public static ElectricSurfaceChargeDensityUnit CoulombPerSquareMeter;
}
public enum UnitsNet.Units.EnergyDensityUnit : Enum {
    public int value__;
    public static EnergyDensityUnit GigajoulePerCubicMeter;
    public static EnergyDensityUnit GigawattHourPerCubicMeter;
    public static EnergyDensityUnit JoulePerCubicMeter;
    public static EnergyDensityUnit KilojoulePerCubicMeter;
    public static EnergyDensityUnit KilowattHourPerCubicMeter;
    public static EnergyDensityUnit MegajoulePerCubicMeter;
    public static EnergyDensityUnit MegawattHourPerCubicMeter;
    public static EnergyDensityUnit PetajoulePerCubicMeter;
    public static EnergyDensityUnit PetawattHourPerCubicMeter;
    public static EnergyDensityUnit TerajoulePerCubicMeter;
    public static EnergyDensityUnit TerawattHourPerCubicMeter;
    public static EnergyDensityUnit WattHourPerCubicMeter;
}
public enum UnitsNet.Units.EnergyUnit : Enum {
    public int value__;
    public static EnergyUnit BritishThermalUnit;
    public static EnergyUnit Calorie;
    public static EnergyUnit DecathermEc;
    public static EnergyUnit DecathermImperial;
    public static EnergyUnit DecathermUs;
    public static EnergyUnit ElectronVolt;
    public static EnergyUnit Erg;
    public static EnergyUnit FootPound;
    public static EnergyUnit GigabritishThermalUnit;
    public static EnergyUnit GigaelectronVolt;
    public static EnergyUnit Gigajoule;
    public static EnergyUnit GigawattDay;
    public static EnergyUnit GigawattHour;
    public static EnergyUnit HorsepowerHour;
    public static EnergyUnit Joule;
    public static EnergyUnit KilobritishThermalUnit;
    public static EnergyUnit Kilocalorie;
    public static EnergyUnit KiloelectronVolt;
    public static EnergyUnit Kilojoule;
    public static EnergyUnit KilowattDay;
    public static EnergyUnit KilowattHour;
    public static EnergyUnit MegabritishThermalUnit;
    public static EnergyUnit Megacalorie;
    public static EnergyUnit MegaelectronVolt;
    public static EnergyUnit Megajoule;
    public static EnergyUnit MegawattDay;
    public static EnergyUnit MegawattHour;
    public static EnergyUnit Microjoule;
    public static EnergyUnit Millijoule;
    public static EnergyUnit Nanojoule;
    public static EnergyUnit Petajoule;
    public static EnergyUnit TeraelectronVolt;
    public static EnergyUnit Terajoule;
    public static EnergyUnit TerawattDay;
    public static EnergyUnit TerawattHour;
    public static EnergyUnit ThermEc;
    public static EnergyUnit ThermImperial;
    public static EnergyUnit ThermUs;
    public static EnergyUnit WattDay;
    public static EnergyUnit WattHour;
}
public enum UnitsNet.Units.EntropyUnit : Enum {
    public int value__;
    public static EntropyUnit CaloriePerKelvin;
    public static EntropyUnit JoulePerDegreeCelsius;
    public static EntropyUnit JoulePerKelvin;
    public static EntropyUnit KilocaloriePerKelvin;
    public static EntropyUnit KilojoulePerDegreeCelsius;
    public static EntropyUnit KilojoulePerKelvin;
    public static EntropyUnit MegajoulePerKelvin;
}
public enum UnitsNet.Units.ForceChangeRateUnit : Enum {
    public int value__;
    public static ForceChangeRateUnit CentinewtonPerSecond;
    public static ForceChangeRateUnit DecanewtonPerMinute;
    public static ForceChangeRateUnit DecanewtonPerSecond;
    public static ForceChangeRateUnit DecinewtonPerSecond;
    public static ForceChangeRateUnit KilonewtonPerMinute;
    public static ForceChangeRateUnit KilonewtonPerSecond;
    public static ForceChangeRateUnit KilopoundForcePerMinute;
    public static ForceChangeRateUnit KilopoundForcePerSecond;
    public static ForceChangeRateUnit MicronewtonPerSecond;
    public static ForceChangeRateUnit MillinewtonPerSecond;
    public static ForceChangeRateUnit NanonewtonPerSecond;
    public static ForceChangeRateUnit NewtonPerMinute;
    public static ForceChangeRateUnit NewtonPerSecond;
    public static ForceChangeRateUnit PoundForcePerMinute;
    public static ForceChangeRateUnit PoundForcePerSecond;
}
public enum UnitsNet.Units.ForcePerLengthUnit : Enum {
    public int value__;
    public static ForcePerLengthUnit CentinewtonPerCentimeter;
    public static ForcePerLengthUnit CentinewtonPerMeter;
    public static ForcePerLengthUnit CentinewtonPerMillimeter;
    public static ForcePerLengthUnit DecanewtonPerCentimeter;
    public static ForcePerLengthUnit DecanewtonPerMeter;
    public static ForcePerLengthUnit DecanewtonPerMillimeter;
    public static ForcePerLengthUnit DecinewtonPerCentimeter;
    public static ForcePerLengthUnit DecinewtonPerMeter;
    public static ForcePerLengthUnit DecinewtonPerMillimeter;
    public static ForcePerLengthUnit KilogramForcePerCentimeter;
    public static ForcePerLengthUnit KilogramForcePerMeter;
    public static ForcePerLengthUnit KilogramForcePerMillimeter;
    public static ForcePerLengthUnit KilonewtonPerCentimeter;
    public static ForcePerLengthUnit KilonewtonPerMeter;
    public static ForcePerLengthUnit KilonewtonPerMillimeter;
    public static ForcePerLengthUnit KilopoundForcePerFoot;
    public static ForcePerLengthUnit KilopoundForcePerInch;
    public static ForcePerLengthUnit MeganewtonPerCentimeter;
    public static ForcePerLengthUnit MeganewtonPerMeter;
    public static ForcePerLengthUnit MeganewtonPerMillimeter;
    public static ForcePerLengthUnit MicronewtonPerCentimeter;
    public static ForcePerLengthUnit MicronewtonPerMeter;
    public static ForcePerLengthUnit MicronewtonPerMillimeter;
    public static ForcePerLengthUnit MillinewtonPerCentimeter;
    public static ForcePerLengthUnit MillinewtonPerMeter;
    public static ForcePerLengthUnit MillinewtonPerMillimeter;
    public static ForcePerLengthUnit NanonewtonPerCentimeter;
    public static ForcePerLengthUnit NanonewtonPerMeter;
    public static ForcePerLengthUnit NanonewtonPerMillimeter;
    public static ForcePerLengthUnit NewtonPerCentimeter;
    public static ForcePerLengthUnit NewtonPerMeter;
    public static ForcePerLengthUnit NewtonPerMillimeter;
    public static ForcePerLengthUnit PoundForcePerFoot;
    public static ForcePerLengthUnit PoundForcePerInch;
    public static ForcePerLengthUnit PoundForcePerYard;
    public static ForcePerLengthUnit TonneForcePerCentimeter;
    public static ForcePerLengthUnit TonneForcePerMeter;
    public static ForcePerLengthUnit TonneForcePerMillimeter;
}
public enum UnitsNet.Units.ForceUnit : Enum {
    public int value__;
    public static ForceUnit Decanewton;
    public static ForceUnit Dyn;
    public static ForceUnit KilogramForce;
    public static ForceUnit Kilonewton;
    public static ForceUnit KiloPond;
    public static ForceUnit KilopoundForce;
    public static ForceUnit Meganewton;
    public static ForceUnit Micronewton;
    public static ForceUnit Millinewton;
    public static ForceUnit Newton;
    public static ForceUnit OunceForce;
    public static ForceUnit Poundal;
    public static ForceUnit PoundForce;
    public static ForceUnit ShortTonForce;
    public static ForceUnit TonneForce;
}
public enum UnitsNet.Units.FrequencyUnit : Enum {
    public int value__;
    public static FrequencyUnit BeatPerMinute;
    public static FrequencyUnit BUnit;
    public static FrequencyUnit CyclePerHour;
    public static FrequencyUnit CyclePerMinute;
    public static FrequencyUnit Gigahertz;
    public static FrequencyUnit Hertz;
    public static FrequencyUnit Kilohertz;
    public static FrequencyUnit Megahertz;
    public static FrequencyUnit Microhertz;
    public static FrequencyUnit Millihertz;
    public static FrequencyUnit PerSecond;
    public static FrequencyUnit RadianPerSecond;
    public static FrequencyUnit Terahertz;
}
public enum UnitsNet.Units.FuelEfficiencyUnit : Enum {
    public int value__;
    public static FuelEfficiencyUnit KilometerPerLiter;
    public static FuelEfficiencyUnit LiterPer100Kilometers;
    public static FuelEfficiencyUnit MilePerUkGallon;
    public static FuelEfficiencyUnit MilePerUsGallon;
}
public enum UnitsNet.Units.HeatFluxUnit : Enum {
    public int value__;
    public static HeatFluxUnit BtuPerHourSquareFoot;
    public static HeatFluxUnit BtuPerMinuteSquareFoot;
    public static HeatFluxUnit BtuPerSecondSquareFoot;
    public static HeatFluxUnit BtuPerSecondSquareInch;
    public static HeatFluxUnit CaloriePerSecondSquareCentimeter;
    public static HeatFluxUnit CentiwattPerSquareMeter;
    public static HeatFluxUnit DeciwattPerSquareMeter;
    public static HeatFluxUnit KilocaloriePerHourSquareMeter;
    public static HeatFluxUnit KilocaloriePerSecondSquareCentimeter;
    public static HeatFluxUnit KilowattPerSquareMeter;
    public static HeatFluxUnit MicrowattPerSquareMeter;
    public static HeatFluxUnit MilliwattPerSquareMeter;
    public static HeatFluxUnit NanowattPerSquareMeter;
    public static HeatFluxUnit PoundForcePerFootSecond;
    public static HeatFluxUnit PoundPerSecondCubed;
    public static HeatFluxUnit WattPerSquareFoot;
    public static HeatFluxUnit WattPerSquareInch;
    public static HeatFluxUnit WattPerSquareMeter;
}
public enum UnitsNet.Units.HeatTransferCoefficientUnit : Enum {
    public int value__;
    public static HeatTransferCoefficientUnit BtuPerHourSquareFootDegreeFahrenheit;
    public static HeatTransferCoefficientUnit CaloriePerHourSquareMeterDegreeCelsius;
    public static HeatTransferCoefficientUnit KilocaloriePerHourSquareMeterDegreeCelsius;
    public static HeatTransferCoefficientUnit WattPerSquareMeterCelsius;
    public static HeatTransferCoefficientUnit WattPerSquareMeterKelvin;
}
public enum UnitsNet.Units.IlluminanceUnit : Enum {
    public int value__;
    public static IlluminanceUnit Kilolux;
    public static IlluminanceUnit Lux;
    public static IlluminanceUnit Megalux;
    public static IlluminanceUnit Millilux;
}
public enum UnitsNet.Units.ImpulseUnit : Enum {
    public int value__;
    public static ImpulseUnit CentinewtonSecond;
    public static ImpulseUnit DecanewtonSecond;
    public static ImpulseUnit DecinewtonSecond;
    public static ImpulseUnit KilogramMeterPerSecond;
    public static ImpulseUnit KilonewtonSecond;
    public static ImpulseUnit MeganewtonSecond;
    public static ImpulseUnit MicronewtonSecond;
    public static ImpulseUnit MillinewtonSecond;
    public static ImpulseUnit NanonewtonSecond;
    public static ImpulseUnit NewtonSecond;
    public static ImpulseUnit PoundFootPerSecond;
    public static ImpulseUnit PoundForceSecond;
    public static ImpulseUnit SlugFootPerSecond;
}
public enum UnitsNet.Units.InformationUnit : Enum {
    public int value__;
    public static InformationUnit Bit;
    public static InformationUnit Byte;
    public static InformationUnit Exabit;
    public static InformationUnit Exabyte;
    public static InformationUnit Exbibit;
    public static InformationUnit Exbibyte;
    public static InformationUnit Gibibit;
    public static InformationUnit Gibibyte;
    public static InformationUnit Gigabit;
    public static InformationUnit Gigabyte;
    public static InformationUnit Kibibit;
    public static InformationUnit Kibibyte;
    public static InformationUnit Kilobit;
    public static InformationUnit Kilobyte;
    public static InformationUnit Mebibit;
    public static InformationUnit Mebibyte;
    public static InformationUnit Megabit;
    public static InformationUnit Megabyte;
    public static InformationUnit Pebibit;
    public static InformationUnit Pebibyte;
    public static InformationUnit Petabit;
    public static InformationUnit Petabyte;
    public static InformationUnit Tebibit;
    public static InformationUnit Tebibyte;
    public static InformationUnit Terabit;
    public static InformationUnit Terabyte;
}
public enum UnitsNet.Units.IrradianceUnit : Enum {
    public int value__;
    public static IrradianceUnit KilowattPerSquareCentimeter;
    public static IrradianceUnit KilowattPerSquareMeter;
    public static IrradianceUnit MegawattPerSquareCentimeter;
    public static IrradianceUnit MegawattPerSquareMeter;
    public static IrradianceUnit MicrowattPerSquareCentimeter;
    public static IrradianceUnit MicrowattPerSquareMeter;
    public static IrradianceUnit MilliwattPerSquareCentimeter;
    public static IrradianceUnit MilliwattPerSquareMeter;
    public static IrradianceUnit NanowattPerSquareCentimeter;
    public static IrradianceUnit NanowattPerSquareMeter;
    public static IrradianceUnit PicowattPerSquareCentimeter;
    public static IrradianceUnit PicowattPerSquareMeter;
    public static IrradianceUnit WattPerSquareCentimeter;
    public static IrradianceUnit WattPerSquareMeter;
}
public enum UnitsNet.Units.IrradiationUnit : Enum {
    public int value__;
    public static IrradiationUnit BtuPerSquareFoot;
    public static IrradiationUnit JoulePerSquareCentimeter;
    public static IrradiationUnit JoulePerSquareMeter;
    public static IrradiationUnit JoulePerSquareMillimeter;
    public static IrradiationUnit KilobtuPerSquareFoot;
    public static IrradiationUnit KilojoulePerSquareMeter;
    public static IrradiationUnit KilowattHourPerSquareMeter;
    public static IrradiationUnit MillijoulePerSquareCentimeter;
    public static IrradiationUnit WattHourPerSquareMeter;
}
public enum UnitsNet.Units.JerkUnit : Enum {
    public int value__;
    public static JerkUnit CentimeterPerSecondCubed;
    public static JerkUnit DecimeterPerSecondCubed;
    public static JerkUnit FootPerSecondCubed;
    public static JerkUnit InchPerSecondCubed;
    public static JerkUnit KilometerPerSecondCubed;
    public static JerkUnit MeterPerSecondCubed;
    public static JerkUnit MicrometerPerSecondCubed;
    public static JerkUnit MillimeterPerSecondCubed;
    public static JerkUnit MillistandardGravitiesPerSecond;
    public static JerkUnit NanometerPerSecondCubed;
    public static JerkUnit StandardGravitiesPerSecond;
}
public enum UnitsNet.Units.KinematicViscosityUnit : Enum {
    public int value__;
    public static KinematicViscosityUnit Centistokes;
    public static KinematicViscosityUnit Decistokes;
    public static KinematicViscosityUnit Kilostokes;
    public static KinematicViscosityUnit Microstokes;
    public static KinematicViscosityUnit Millistokes;
    public static KinematicViscosityUnit Nanostokes;
    public static KinematicViscosityUnit SquareFootPerSecond;
    public static KinematicViscosityUnit SquareMeterPerSecond;
    public static KinematicViscosityUnit Stokes;
}
public enum UnitsNet.Units.LeakRateUnit : Enum {
    public int value__;
    public static LeakRateUnit MillibarLiterPerSecond;
    public static LeakRateUnit PascalCubicMeterPerSecond;
    public static LeakRateUnit TorrLiterPerSecond;
}
public enum UnitsNet.Units.LengthUnit : Enum {
    public int value__;
    public static LengthUnit Angstrom;
    public static LengthUnit AstronomicalUnit;
    public static LengthUnit Centimeter;
    public static LengthUnit Chain;
    public static LengthUnit DataMile;
    public static LengthUnit Decameter;
    public static LengthUnit Decimeter;
    public static LengthUnit DtpPica;
    public static LengthUnit DtpPoint;
    public static LengthUnit Fathom;
    public static LengthUnit Femtometer;
    public static LengthUnit Foot;
    public static LengthUnit Gigameter;
    public static LengthUnit Hand;
    public static LengthUnit Hectometer;
    public static LengthUnit Inch;
    public static LengthUnit Kilofoot;
    public static LengthUnit KilolightYear;
    public static LengthUnit Kilometer;
    public static LengthUnit Kiloparsec;
    public static LengthUnit Kiloyard;
    public static LengthUnit LightYear;
    public static LengthUnit MegalightYear;
    public static LengthUnit Megameter;
    public static LengthUnit Megaparsec;
    public static LengthUnit Meter;
    public static LengthUnit Microinch;
    public static LengthUnit Micrometer;
    public static LengthUnit Mil;
    public static LengthUnit Mile;
    public static LengthUnit Millimeter;
    public static LengthUnit Nanometer;
    public static LengthUnit NauticalMile;
    public static LengthUnit Parsec;
    public static LengthUnit Picometer;
    public static LengthUnit PrinterPica;
    public static LengthUnit PrinterPoint;
    public static LengthUnit Shackle;
    public static LengthUnit SolarRadius;
    public static LengthUnit Twip;
    public static LengthUnit UsSurveyFoot;
    public static LengthUnit Yard;
}
public enum UnitsNet.Units.LevelUnit : Enum {
    public int value__;
    public static LevelUnit Decibel;
    public static LevelUnit Neper;
}
public enum UnitsNet.Units.LinearDensityUnit : Enum {
    public int value__;
    public static LinearDensityUnit GramPerCentimeter;
    public static LinearDensityUnit GramPerFoot;
    public static LinearDensityUnit GramPerMeter;
    public static LinearDensityUnit GramPerMillimeter;
    public static LinearDensityUnit KilogramPerCentimeter;
    public static LinearDensityUnit KilogramPerFoot;
    public static LinearDensityUnit KilogramPerMeter;
    public static LinearDensityUnit KilogramPerMillimeter;
    public static LinearDensityUnit MicrogramPerCentimeter;
    public static LinearDensityUnit MicrogramPerFoot;
    public static LinearDensityUnit MicrogramPerMeter;
    public static LinearDensityUnit MicrogramPerMillimeter;
    public static LinearDensityUnit MilligramPerCentimeter;
    public static LinearDensityUnit MilligramPerFoot;
    public static LinearDensityUnit MilligramPerMeter;
    public static LinearDensityUnit MilligramPerMillimeter;
    public static LinearDensityUnit PoundPerFoot;
    public static LinearDensityUnit PoundPerInch;
}
public enum UnitsNet.Units.LinearPowerDensityUnit : Enum {
    public int value__;
    public static LinearPowerDensityUnit GigawattPerCentimeter;
    public static LinearPowerDensityUnit GigawattPerFoot;
    public static LinearPowerDensityUnit GigawattPerInch;
    public static LinearPowerDensityUnit GigawattPerMeter;
    public static LinearPowerDensityUnit GigawattPerMillimeter;
    public static LinearPowerDensityUnit KilowattPerCentimeter;
    public static LinearPowerDensityUnit KilowattPerFoot;
    public static LinearPowerDensityUnit KilowattPerInch;
    public static LinearPowerDensityUnit KilowattPerMeter;
    public static LinearPowerDensityUnit KilowattPerMillimeter;
    public static LinearPowerDensityUnit MegawattPerCentimeter;
    public static LinearPowerDensityUnit MegawattPerFoot;
    public static LinearPowerDensityUnit MegawattPerInch;
    public static LinearPowerDensityUnit MegawattPerMeter;
    public static LinearPowerDensityUnit MegawattPerMillimeter;
    public static LinearPowerDensityUnit MilliwattPerCentimeter;
    public static LinearPowerDensityUnit MilliwattPerFoot;
    public static LinearPowerDensityUnit MilliwattPerInch;
    public static LinearPowerDensityUnit MilliwattPerMeter;
    public static LinearPowerDensityUnit MilliwattPerMillimeter;
    public static LinearPowerDensityUnit WattPerCentimeter;
    public static LinearPowerDensityUnit WattPerFoot;
    public static LinearPowerDensityUnit WattPerInch;
    public static LinearPowerDensityUnit WattPerMeter;
    public static LinearPowerDensityUnit WattPerMillimeter;
}
public enum UnitsNet.Units.LuminanceUnit : Enum {
    public int value__;
    public static LuminanceUnit CandelaPerSquareFoot;
    public static LuminanceUnit CandelaPerSquareInch;
    public static LuminanceUnit CandelaPerSquareMeter;
    public static LuminanceUnit CenticandelaPerSquareMeter;
    public static LuminanceUnit DecicandelaPerSquareMeter;
    public static LuminanceUnit KilocandelaPerSquareMeter;
    public static LuminanceUnit MicrocandelaPerSquareMeter;
    public static LuminanceUnit MillicandelaPerSquareMeter;
    public static LuminanceUnit NanocandelaPerSquareMeter;
    public static LuminanceUnit Nit;
}
public enum UnitsNet.Units.LuminosityUnit : Enum {
    public int value__;
    public static LuminosityUnit Decawatt;
    public static LuminosityUnit Deciwatt;
    public static LuminosityUnit Femtowatt;
    public static LuminosityUnit Gigawatt;
    public static LuminosityUnit Kilowatt;
    public static LuminosityUnit Megawatt;
    public static LuminosityUnit Microwatt;
    public static LuminosityUnit Milliwatt;
    public static LuminosityUnit Nanowatt;
    public static LuminosityUnit Petawatt;
    public static LuminosityUnit Picowatt;
    public static LuminosityUnit SolarLuminosity;
    public static LuminosityUnit Terawatt;
    public static LuminosityUnit Watt;
}
public enum UnitsNet.Units.LuminousFluxUnit : Enum {
    public int value__;
    public static LuminousFluxUnit Lumen;
}
public enum UnitsNet.Units.LuminousIntensityUnit : Enum {
    public int value__;
    public static LuminousIntensityUnit Candela;
}
public enum UnitsNet.Units.MagneticFieldUnit : Enum {
    public int value__;
    public static MagneticFieldUnit Gauss;
    public static MagneticFieldUnit Microtesla;
    public static MagneticFieldUnit Milligauss;
    public static MagneticFieldUnit Millitesla;
    public static MagneticFieldUnit Nanotesla;
    public static MagneticFieldUnit Tesla;
}
public enum UnitsNet.Units.MagneticFluxUnit : Enum {
    public int value__;
    public static MagneticFluxUnit Weber;
}
public enum UnitsNet.Units.MagnetizationUnit : Enum {
    public int value__;
    public static MagnetizationUnit AmperePerMeter;
}
public enum UnitsNet.Units.MassConcentrationUnit : Enum {
    public int value__;
    public static MassConcentrationUnit CentigramPerDeciliter;
    public static MassConcentrationUnit CentigramPerLiter;
    public static MassConcentrationUnit CentigramPerMicroliter;
    public static MassConcentrationUnit CentigramPerMilliliter;
    public static MassConcentrationUnit DecigramPerDeciliter;
    public static MassConcentrationUnit DecigramPerLiter;
    public static MassConcentrationUnit DecigramPerMicroliter;
    public static MassConcentrationUnit DecigramPerMilliliter;
    public static MassConcentrationUnit GramPerCubicCentimeter;
    public static MassConcentrationUnit GramPerCubicMeter;
    public static MassConcentrationUnit GramPerCubicMillimeter;
    public static MassConcentrationUnit GramPerDeciliter;
    public static MassConcentrationUnit GramPerLiter;
    public static MassConcentrationUnit GramPerMicroliter;
    public static MassConcentrationUnit GramPerMilliliter;
    public static MassConcentrationUnit KilogramPerCubicCentimeter;
    public static MassConcentrationUnit KilogramPerCubicMeter;
    public static MassConcentrationUnit KilogramPerCubicMillimeter;
    public static MassConcentrationUnit KilogramPerLiter;
    public static MassConcentrationUnit KilopoundPerCubicFoot;
    public static MassConcentrationUnit KilopoundPerCubicInch;
    public static MassConcentrationUnit MicrogramPerCubicMeter;
    public static MassConcentrationUnit MicrogramPerDeciliter;
    public static MassConcentrationUnit MicrogramPerLiter;
    public static MassConcentrationUnit MicrogramPerMicroliter;
    public static MassConcentrationUnit MicrogramPerMilliliter;
    public static MassConcentrationUnit MilligramPerCubicMeter;
    public static MassConcentrationUnit MilligramPerDeciliter;
    public static MassConcentrationUnit MilligramPerLiter;
    public static MassConcentrationUnit MilligramPerMicroliter;
    public static MassConcentrationUnit MilligramPerMilliliter;
    public static MassConcentrationUnit NanogramPerDeciliter;
    public static MassConcentrationUnit NanogramPerLiter;
    public static MassConcentrationUnit NanogramPerMicroliter;
    public static MassConcentrationUnit NanogramPerMilliliter;
    public static MassConcentrationUnit OuncePerImperialGallon;
    public static MassConcentrationUnit OuncePerUSGallon;
    public static MassConcentrationUnit PicogramPerDeciliter;
    public static MassConcentrationUnit PicogramPerLiter;
    public static MassConcentrationUnit PicogramPerMicroliter;
    public static MassConcentrationUnit PicogramPerMilliliter;
    public static MassConcentrationUnit PoundPerCubicFoot;
    public static MassConcentrationUnit PoundPerCubicInch;
    public static MassConcentrationUnit PoundPerImperialGallon;
    public static MassConcentrationUnit PoundPerUSGallon;
    public static MassConcentrationUnit SlugPerCubicFoot;
    public static MassConcentrationUnit TonnePerCubicCentimeter;
    public static MassConcentrationUnit TonnePerCubicMeter;
    public static MassConcentrationUnit TonnePerCubicMillimeter;
}
public enum UnitsNet.Units.MassFlowUnit : Enum {
    public int value__;
    public static MassFlowUnit CentigramPerDay;
    public static MassFlowUnit CentigramPerSecond;
    public static MassFlowUnit DecagramPerDay;
    public static MassFlowUnit DecagramPerSecond;
    public static MassFlowUnit DecigramPerDay;
    public static MassFlowUnit DecigramPerSecond;
    public static MassFlowUnit GramPerDay;
    public static MassFlowUnit GramPerHour;
    public static MassFlowUnit GramPerSecond;
    public static MassFlowUnit HectogramPerDay;
    public static MassFlowUnit HectogramPerSecond;
    public static MassFlowUnit KilogramPerDay;
    public static MassFlowUnit KilogramPerHour;
    public static MassFlowUnit KilogramPerMinute;
    public static MassFlowUnit KilogramPerSecond;
    public static MassFlowUnit MegagramPerDay;
    public static MassFlowUnit MegapoundPerDay;
    public static MassFlowUnit MegapoundPerHour;
    public static MassFlowUnit MegapoundPerMinute;
    public static MassFlowUnit MegapoundPerSecond;
    public static MassFlowUnit MicrogramPerDay;
    public static MassFlowUnit MicrogramPerSecond;
    public static MassFlowUnit MilligramPerDay;
    public static MassFlowUnit MilligramPerSecond;
    public static MassFlowUnit NanogramPerDay;
    public static MassFlowUnit NanogramPerSecond;
    public static MassFlowUnit PoundPerDay;
    public static MassFlowUnit PoundPerHour;
    public static MassFlowUnit PoundPerMinute;
    public static MassFlowUnit PoundPerSecond;
    public static MassFlowUnit ShortTonPerHour;
    public static MassFlowUnit TonnePerDay;
    public static MassFlowUnit TonnePerHour;
}
public enum UnitsNet.Units.MassFluxUnit : Enum {
    public int value__;
    public static MassFluxUnit GramPerHourPerSquareCentimeter;
    public static MassFluxUnit GramPerHourPerSquareMeter;
    public static MassFluxUnit GramPerHourPerSquareMillimeter;
    public static MassFluxUnit GramPerSecondPerSquareCentimeter;
    public static MassFluxUnit GramPerSecondPerSquareMeter;
    public static MassFluxUnit GramPerSecondPerSquareMillimeter;
    public static MassFluxUnit KilogramPerHourPerSquareCentimeter;
    public static MassFluxUnit KilogramPerHourPerSquareMeter;
    public static MassFluxUnit KilogramPerHourPerSquareMillimeter;
    public static MassFluxUnit KilogramPerSecondPerSquareCentimeter;
    public static MassFluxUnit KilogramPerSecondPerSquareMeter;
    public static MassFluxUnit KilogramPerSecondPerSquareMillimeter;
}
public enum UnitsNet.Units.MassFractionUnit : Enum {
    public int value__;
    public static MassFractionUnit CentigramPerGram;
    public static MassFractionUnit CentigramPerKilogram;
    public static MassFractionUnit DecagramPerGram;
    public static MassFractionUnit DecagramPerKilogram;
    public static MassFractionUnit DecigramPerGram;
    public static MassFractionUnit DecigramPerKilogram;
    public static MassFractionUnit DecimalFraction;
    public static MassFractionUnit GramPerGram;
    public static MassFractionUnit GramPerKilogram;
    public static MassFractionUnit HectogramPerGram;
    public static MassFractionUnit HectogramPerKilogram;
    public static MassFractionUnit KilogramPerGram;
    public static MassFractionUnit KilogramPerKilogram;
    public static MassFractionUnit MicrogramPerGram;
    public static MassFractionUnit MicrogramPerKilogram;
    public static MassFractionUnit MilligramPerGram;
    public static MassFractionUnit MilligramPerKilogram;
    public static MassFractionUnit NanogramPerGram;
    public static MassFractionUnit NanogramPerKilogram;
    public static MassFractionUnit PartPerBillion;
    public static MassFractionUnit PartPerMillion;
    public static MassFractionUnit PartPerThousand;
    public static MassFractionUnit PartPerTrillion;
    public static MassFractionUnit Percent;
}
public enum UnitsNet.Units.MassMomentOfInertiaUnit : Enum {
    public int value__;
    public static MassMomentOfInertiaUnit GramSquareCentimeter;
    public static MassMomentOfInertiaUnit GramSquareDecimeter;
    public static MassMomentOfInertiaUnit GramSquareMeter;
    public static MassMomentOfInertiaUnit GramSquareMillimeter;
    public static MassMomentOfInertiaUnit KilogramSquareCentimeter;
    public static MassMomentOfInertiaUnit KilogramSquareDecimeter;
    public static MassMomentOfInertiaUnit KilogramSquareMeter;
    public static MassMomentOfInertiaUnit KilogramSquareMillimeter;
    public static MassMomentOfInertiaUnit KilotonneSquareCentimeter;
    public static MassMomentOfInertiaUnit KilotonneSquareDecimeter;
    public static MassMomentOfInertiaUnit KilotonneSquareMeter;
    public static MassMomentOfInertiaUnit KilotonneSquareMilimeter;
    public static MassMomentOfInertiaUnit MegatonneSquareCentimeter;
    public static MassMomentOfInertiaUnit MegatonneSquareDecimeter;
    public static MassMomentOfInertiaUnit MegatonneSquareMeter;
    public static MassMomentOfInertiaUnit MegatonneSquareMilimeter;
    public static MassMomentOfInertiaUnit MilligramSquareCentimeter;
    public static MassMomentOfInertiaUnit MilligramSquareDecimeter;
    public static MassMomentOfInertiaUnit MilligramSquareMeter;
    public static MassMomentOfInertiaUnit MilligramSquareMillimeter;
    public static MassMomentOfInertiaUnit PoundSquareFoot;
    public static MassMomentOfInertiaUnit PoundSquareInch;
    public static MassMomentOfInertiaUnit SlugSquareFoot;
    public static MassMomentOfInertiaUnit SlugSquareInch;
    public static MassMomentOfInertiaUnit TonneSquareCentimeter;
    public static MassMomentOfInertiaUnit TonneSquareDecimeter;
    public static MassMomentOfInertiaUnit TonneSquareMeter;
    public static MassMomentOfInertiaUnit TonneSquareMilimeter;
}
public enum UnitsNet.Units.MassUnit : Enum {
    public int value__;
    public static MassUnit Centigram;
    public static MassUnit Decagram;
    public static MassUnit Decigram;
    public static MassUnit EarthMass;
    public static MassUnit Femtogram;
    public static MassUnit Grain;
    public static MassUnit Gram;
    public static MassUnit Hectogram;
    public static MassUnit Kilogram;
    public static MassUnit Kilopound;
    public static MassUnit Kilotonne;
    public static MassUnit LongHundredweight;
    public static MassUnit LongTon;
    public static MassUnit Megapound;
    public static MassUnit Megatonne;
    public static MassUnit Microgram;
    public static MassUnit Milligram;
    public static MassUnit Nanogram;
    public static MassUnit Ounce;
    public static MassUnit Picogram;
    public static MassUnit Pound;
    public static MassUnit ShortHundredweight;
    public static MassUnit ShortTon;
    public static MassUnit Slug;
    public static MassUnit SolarMass;
    public static MassUnit Stone;
    public static MassUnit Tonne;
}
public enum UnitsNet.Units.MolalityUnit : Enum {
    public int value__;
    public static MolalityUnit MillimolePerKilogram;
    public static MolalityUnit MolePerGram;
    public static MolalityUnit MolePerKilogram;
}
public enum UnitsNet.Units.MolarEnergyUnit : Enum {
    public int value__;
    public static MolarEnergyUnit JoulePerMole;
    public static MolarEnergyUnit KilojoulePerMole;
    public static MolarEnergyUnit MegajoulePerMole;
}
public enum UnitsNet.Units.MolarEntropyUnit : Enum {
    public int value__;
    public static MolarEntropyUnit JoulePerMoleKelvin;
    public static MolarEntropyUnit KilojoulePerMoleKelvin;
    public static MolarEntropyUnit MegajoulePerMoleKelvin;
}
public enum UnitsNet.Units.MolarFlowUnit : Enum {
    public int value__;
    public static MolarFlowUnit KilomolePerHour;
    public static MolarFlowUnit KilomolePerMinute;
    public static MolarFlowUnit KilomolePerSecond;
    public static MolarFlowUnit MolePerHour;
    public static MolarFlowUnit MolePerMinute;
    public static MolarFlowUnit MolePerSecond;
    public static MolarFlowUnit PoundMolePerHour;
    public static MolarFlowUnit PoundMolePerMinute;
    public static MolarFlowUnit PoundMolePerSecond;
}
public enum UnitsNet.Units.MolarityUnit : Enum {
    public int value__;
    public static MolarityUnit CentimolePerLiter;
    public static MolarityUnit DecimolePerLiter;
    public static MolarityUnit FemtomolePerLiter;
    public static MolarityUnit KilomolePerCubicMeter;
    public static MolarityUnit MicromolePerLiter;
    public static MolarityUnit MillimolePerLiter;
    public static MolarityUnit MolePerCubicMeter;
    public static MolarityUnit MolePerLiter;
    public static MolarityUnit NanomolePerLiter;
    public static MolarityUnit PicomolePerLiter;
    public static MolarityUnit PoundMolePerCubicFoot;
}
public enum UnitsNet.Units.MolarMassUnit : Enum {
    public int value__;
    public static MolarMassUnit CentigramPerMole;
    public static MolarMassUnit DecagramPerMole;
    public static MolarMassUnit DecigramPerMole;
    public static MolarMassUnit GramPerMole;
    public static MolarMassUnit HectogramPerMole;
    public static MolarMassUnit KilogramPerKilomole;
    public static MolarMassUnit KilogramPerMole;
    public static MolarMassUnit KilopoundPerMole;
    public static MolarMassUnit MegapoundPerMole;
    public static MolarMassUnit MicrogramPerMole;
    public static MolarMassUnit MilligramPerMole;
    public static MolarMassUnit NanogramPerMole;
    public static MolarMassUnit PoundPerMole;
}
public enum UnitsNet.Units.PermeabilityUnit : Enum {
    public int value__;
    public static PermeabilityUnit HenryPerMeter;
}
public enum UnitsNet.Units.PermittivityUnit : Enum {
    public int value__;
    public static PermittivityUnit FaradPerMeter;
}
public enum UnitsNet.Units.PorousMediumPermeabilityUnit : Enum {
    public int value__;
    public static PorousMediumPermeabilityUnit Darcy;
    public static PorousMediumPermeabilityUnit Microdarcy;
    public static PorousMediumPermeabilityUnit Millidarcy;
    public static PorousMediumPermeabilityUnit SquareCentimeter;
    public static PorousMediumPermeabilityUnit SquareMeter;
}
public enum UnitsNet.Units.PowerDensityUnit : Enum {
    public int value__;
    public static PowerDensityUnit DecawattPerCubicFoot;
    public static PowerDensityUnit DecawattPerCubicInch;
    public static PowerDensityUnit DecawattPerCubicMeter;
    public static PowerDensityUnit DecawattPerLiter;
    public static PowerDensityUnit DeciwattPerCubicFoot;
    public static PowerDensityUnit DeciwattPerCubicInch;
    public static PowerDensityUnit DeciwattPerCubicMeter;
    public static PowerDensityUnit DeciwattPerLiter;
    public static PowerDensityUnit GigawattPerCubicFoot;
    public static PowerDensityUnit GigawattPerCubicInch;
    public static PowerDensityUnit GigawattPerCubicMeter;
    public static PowerDensityUnit GigawattPerLiter;
    public static PowerDensityUnit KilowattPerCubicFoot;
    public static PowerDensityUnit KilowattPerCubicInch;
    public static PowerDensityUnit KilowattPerCubicMeter;
    public static PowerDensityUnit KilowattPerLiter;
    public static PowerDensityUnit MegawattPerCubicFoot;
    public static PowerDensityUnit MegawattPerCubicInch;
    public static PowerDensityUnit MegawattPerCubicMeter;
    public static PowerDensityUnit MegawattPerLiter;
    public static PowerDensityUnit MicrowattPerCubicFoot;
    public static PowerDensityUnit MicrowattPerCubicInch;
    public static PowerDensityUnit MicrowattPerCubicMeter;
    public static PowerDensityUnit MicrowattPerLiter;
    public static PowerDensityUnit MilliwattPerCubicFoot;
    public static PowerDensityUnit MilliwattPerCubicInch;
    public static PowerDensityUnit MilliwattPerCubicMeter;
    public static PowerDensityUnit MilliwattPerLiter;
    public static PowerDensityUnit NanowattPerCubicFoot;
    public static PowerDensityUnit NanowattPerCubicInch;
    public static PowerDensityUnit NanowattPerCubicMeter;
    public static PowerDensityUnit NanowattPerLiter;
    public static PowerDensityUnit PicowattPerCubicFoot;
    public static PowerDensityUnit PicowattPerCubicInch;
    public static PowerDensityUnit PicowattPerCubicMeter;
    public static PowerDensityUnit PicowattPerLiter;
    public static PowerDensityUnit TerawattPerCubicFoot;
    public static PowerDensityUnit TerawattPerCubicInch;
    public static PowerDensityUnit TerawattPerCubicMeter;
    public static PowerDensityUnit TerawattPerLiter;
    public static PowerDensityUnit WattPerCubicFoot;
    public static PowerDensityUnit WattPerCubicInch;
    public static PowerDensityUnit WattPerCubicMeter;
    public static PowerDensityUnit WattPerLiter;
}
public enum UnitsNet.Units.PowerRatioUnit : Enum {
    public int value__;
    public static PowerRatioUnit DecibelMilliwatt;
    public static PowerRatioUnit DecibelWatt;
}
public enum UnitsNet.Units.PowerUnit : Enum {
    public int value__;
    public static PowerUnit BoilerHorsepower;
    public static PowerUnit BritishThermalUnitPerHour;
    public static PowerUnit Decawatt;
    public static PowerUnit Deciwatt;
    public static PowerUnit ElectricalHorsepower;
    public static PowerUnit Femtowatt;
    public static PowerUnit GigajoulePerHour;
    public static PowerUnit Gigawatt;
    public static PowerUnit HydraulicHorsepower;
    public static PowerUnit JoulePerHour;
    public static PowerUnit KilobritishThermalUnitPerHour;
    public static PowerUnit KilojoulePerHour;
    public static PowerUnit Kilowatt;
    public static PowerUnit MechanicalHorsepower;
    public static PowerUnit MegabritishThermalUnitPerHour;
    public static PowerUnit MegajoulePerHour;
    public static PowerUnit Megawatt;
    public static PowerUnit MetricHorsepower;
    public static PowerUnit Microwatt;
    public static PowerUnit MillijoulePerHour;
    public static PowerUnit Milliwatt;
    public static PowerUnit Nanowatt;
    public static PowerUnit Petawatt;
    public static PowerUnit Picowatt;
    public static PowerUnit Terawatt;
    public static PowerUnit TonOfRefrigeration;
    public static PowerUnit Watt;
}
public enum UnitsNet.Units.PressureChangeRateUnit : Enum {
    public int value__;
    public static PressureChangeRateUnit AtmospherePerSecond;
    public static PressureChangeRateUnit BarPerMinute;
    public static PressureChangeRateUnit BarPerSecond;
    public static PressureChangeRateUnit KilopascalPerMinute;
    public static PressureChangeRateUnit KilopascalPerSecond;
    public static PressureChangeRateUnit KilopoundForcePerSquareInchPerMinute;
    public static PressureChangeRateUnit KilopoundForcePerSquareInchPerSecond;
    public static PressureChangeRateUnit MegapascalPerMinute;
    public static PressureChangeRateUnit MegapascalPerSecond;
    public static PressureChangeRateUnit MegapoundForcePerSquareInchPerMinute;
    public static PressureChangeRateUnit MegapoundForcePerSquareInchPerSecond;
    public static PressureChangeRateUnit MillibarPerMinute;
    public static PressureChangeRateUnit MillibarPerSecond;
    public static PressureChangeRateUnit MillimeterOfMercuryPerSecond;
    public static PressureChangeRateUnit PascalPerMinute;
    public static PressureChangeRateUnit PascalPerSecond;
    public static PressureChangeRateUnit PoundForcePerSquareInchPerMinute;
    public static PressureChangeRateUnit PoundForcePerSquareInchPerSecond;
}
public enum UnitsNet.Units.PressureUnit : Enum {
    public int value__;
    public static PressureUnit Atmosphere;
    public static PressureUnit Bar;
    public static PressureUnit Centibar;
    public static PressureUnit CentimeterOfWaterColumn;
    public static PressureUnit Decapascal;
    public static PressureUnit Decibar;
    public static PressureUnit DynePerSquareCentimeter;
    public static PressureUnit FootOfElevation;
    public static PressureUnit FootOfHead;
    public static PressureUnit Gigapascal;
    public static PressureUnit Hectopascal;
    public static PressureUnit InchOfMercury;
    public static PressureUnit InchOfWaterColumn;
    public static PressureUnit Kilobar;
    public static PressureUnit KilogramForcePerSquareCentimeter;
    public static PressureUnit KilogramForcePerSquareMeter;
    public static PressureUnit KilogramForcePerSquareMillimeter;
    public static PressureUnit KilonewtonPerSquareCentimeter;
    public static PressureUnit KilonewtonPerSquareMeter;
    public static PressureUnit KilonewtonPerSquareMillimeter;
    public static PressureUnit Kilopascal;
    public static PressureUnit KilopoundForcePerSquareFoot;
    public static PressureUnit KilopoundForcePerSquareInch;
    public static PressureUnit KilopoundForcePerSquareMil;
    public static PressureUnit Megabar;
    public static PressureUnit MeganewtonPerSquareMeter;
    public static PressureUnit Megapascal;
    public static PressureUnit MeterOfElevation;
    public static PressureUnit MeterOfHead;
    public static PressureUnit MeterOfWaterColumn;
    public static PressureUnit Microbar;
    public static PressureUnit Micropascal;
    public static PressureUnit Millibar;
    public static PressureUnit MillimeterOfMercury;
    public static PressureUnit MillimeterOfWaterColumn;
    public static PressureUnit Millipascal;
    public static PressureUnit NewtonPerSquareCentimeter;
    public static PressureUnit NewtonPerSquareMeter;
    public static PressureUnit NewtonPerSquareMillimeter;
    public static PressureUnit Pascal;
    public static PressureUnit PoundForcePerSquareFoot;
    public static PressureUnit PoundForcePerSquareInch;
    public static PressureUnit PoundForcePerSquareMil;
    public static PressureUnit PoundPerInchSecondSquared;
    public static PressureUnit TechnicalAtmosphere;
    public static PressureUnit TonneForcePerSquareCentimeter;
    public static PressureUnit TonneForcePerSquareMeter;
    public static PressureUnit TonneForcePerSquareMillimeter;
    public static PressureUnit Torr;
}
public enum UnitsNet.Units.RadiationEquivalentDoseUnit : Enum {
    public int value__;
    public static RadiationEquivalentDoseUnit Microsievert;
    public static RadiationEquivalentDoseUnit MilliroentgenEquivalentMan;
    public static RadiationEquivalentDoseUnit Millisievert;
    public static RadiationEquivalentDoseUnit Nanosievert;
    public static RadiationEquivalentDoseUnit RoentgenEquivalentMan;
    public static RadiationEquivalentDoseUnit Sievert;
}
public enum UnitsNet.Units.RadiationExposureUnit : Enum {
    public int value__;
    public static RadiationExposureUnit CoulombPerKilogram;
    public static RadiationExposureUnit MicrocoulombPerKilogram;
    public static RadiationExposureUnit Microroentgen;
    public static RadiationExposureUnit MillicoulombPerKilogram;
    public static RadiationExposureUnit Milliroentgen;
    public static RadiationExposureUnit NanocoulombPerKilogram;
    public static RadiationExposureUnit PicocoulombPerKilogram;
    public static RadiationExposureUnit Roentgen;
}
public enum UnitsNet.Units.RadioactivityUnit : Enum {
    public int value__;
    public static RadioactivityUnit Becquerel;
    public static RadioactivityUnit Curie;
    public static RadioactivityUnit Exabecquerel;
    public static RadioactivityUnit Gigabecquerel;
    public static RadioactivityUnit Gigacurie;
    public static RadioactivityUnit Gigarutherford;
    public static RadioactivityUnit Kilobecquerel;
    public static RadioactivityUnit Kilocurie;
    public static RadioactivityUnit Kilorutherford;
    public static RadioactivityUnit Megabecquerel;
    public static RadioactivityUnit Megacurie;
    public static RadioactivityUnit Megarutherford;
    public static RadioactivityUnit Microbecquerel;
    public static RadioactivityUnit Microcurie;
    public static RadioactivityUnit Microrutherford;
    public static RadioactivityUnit Millibecquerel;
    public static RadioactivityUnit Millicurie;
    public static RadioactivityUnit Millirutherford;
    public static RadioactivityUnit Nanobecquerel;
    public static RadioactivityUnit Nanocurie;
    public static RadioactivityUnit Nanorutherford;
    public static RadioactivityUnit Petabecquerel;
    public static RadioactivityUnit Picobecquerel;
    public static RadioactivityUnit Picocurie;
    public static RadioactivityUnit Picorutherford;
    public static RadioactivityUnit Rutherford;
    public static RadioactivityUnit Terabecquerel;
    public static RadioactivityUnit Teracurie;
    public static RadioactivityUnit Terarutherford;
}
public enum UnitsNet.Units.RatioChangeRateUnit : Enum {
    public int value__;
    public static RatioChangeRateUnit DecimalFractionPerSecond;
    public static RatioChangeRateUnit PercentPerSecond;
}
public enum UnitsNet.Units.RatioUnit : Enum {
    public int value__;
    public static RatioUnit DecimalFraction;
    public static RatioUnit PartPerBillion;
    public static RatioUnit PartPerMillion;
    public static RatioUnit PartPerThousand;
    public static RatioUnit PartPerTrillion;
    public static RatioUnit Percent;
}
public enum UnitsNet.Units.ReactiveEnergyUnit : Enum {
    public int value__;
    public static ReactiveEnergyUnit KilovoltampereReactiveHour;
    public static ReactiveEnergyUnit MegavoltampereReactiveHour;
    public static ReactiveEnergyUnit VoltampereReactiveHour;
}
public enum UnitsNet.Units.ReactivePowerUnit : Enum {
    public int value__;
    public static ReactivePowerUnit GigavoltampereReactive;
    public static ReactivePowerUnit KilovoltampereReactive;
    public static ReactivePowerUnit MegavoltampereReactive;
    public static ReactivePowerUnit VoltampereReactive;
}
public enum UnitsNet.Units.ReciprocalAreaUnit : Enum {
    public int value__;
    public static ReciprocalAreaUnit InverseSquareCentimeter;
    public static ReciprocalAreaUnit InverseSquareDecimeter;
    public static ReciprocalAreaUnit InverseSquareFoot;
    public static ReciprocalAreaUnit InverseSquareInch;
    public static ReciprocalAreaUnit InverseSquareKilometer;
    public static ReciprocalAreaUnit InverseSquareMeter;
    public static ReciprocalAreaUnit InverseSquareMicrometer;
    public static ReciprocalAreaUnit InverseSquareMile;
    public static ReciprocalAreaUnit InverseSquareMillimeter;
    public static ReciprocalAreaUnit InverseSquareYard;
    public static ReciprocalAreaUnit InverseUsSurveySquareFoot;
}
public enum UnitsNet.Units.ReciprocalLengthUnit : Enum {
    public int value__;
    public static ReciprocalLengthUnit InverseCentimeter;
    public static ReciprocalLengthUnit InverseFoot;
    public static ReciprocalLengthUnit InverseInch;
    public static ReciprocalLengthUnit InverseMeter;
    public static ReciprocalLengthUnit InverseMicroinch;
    public static ReciprocalLengthUnit InverseMil;
    public static ReciprocalLengthUnit InverseMile;
    public static ReciprocalLengthUnit InverseMillimeter;
    public static ReciprocalLengthUnit InverseUsSurveyFoot;
    public static ReciprocalLengthUnit InverseYard;
}
public enum UnitsNet.Units.RelativeHumidityUnit : Enum {
    public int value__;
    public static RelativeHumidityUnit Percent;
}
public enum UnitsNet.Units.RotationalAccelerationUnit : Enum {
    public int value__;
    public static RotationalAccelerationUnit DegreePerSecondSquared;
    public static RotationalAccelerationUnit RadianPerSecondSquared;
    public static RotationalAccelerationUnit RevolutionPerMinutePerSecond;
    public static RotationalAccelerationUnit RevolutionPerSecondSquared;
}
public enum UnitsNet.Units.RotationalSpeedUnit : Enum {
    public int value__;
    public static RotationalSpeedUnit CentiradianPerSecond;
    public static RotationalSpeedUnit DeciradianPerSecond;
    public static RotationalSpeedUnit DegreePerMinute;
    public static RotationalSpeedUnit DegreePerSecond;
    public static RotationalSpeedUnit MicrodegreePerSecond;
    public static RotationalSpeedUnit MicroradianPerSecond;
    public static RotationalSpeedUnit MillidegreePerSecond;
    public static RotationalSpeedUnit MilliradianPerSecond;
    public static RotationalSpeedUnit NanodegreePerSecond;
    public static RotationalSpeedUnit NanoradianPerSecond;
    public static RotationalSpeedUnit RadianPerSecond;
    public static RotationalSpeedUnit RevolutionPerMinute;
    public static RotationalSpeedUnit RevolutionPerSecond;
}
public enum UnitsNet.Units.RotationalStiffnessPerLengthUnit : Enum {
    public int value__;
    public static RotationalStiffnessPerLengthUnit KilonewtonMeterPerRadianPerMeter;
    public static RotationalStiffnessPerLengthUnit KilopoundForceFootPerDegreesPerFoot;
    public static RotationalStiffnessPerLengthUnit MeganewtonMeterPerRadianPerMeter;
    public static RotationalStiffnessPerLengthUnit NewtonMeterPerRadianPerMeter;
    public static RotationalStiffnessPerLengthUnit PoundForceFootPerDegreesPerFoot;
}
public enum UnitsNet.Units.RotationalStiffnessUnit : Enum {
    public int value__;
    public static RotationalStiffnessUnit CentinewtonMeterPerDegree;
    public static RotationalStiffnessUnit CentinewtonMillimeterPerDegree;
    public static RotationalStiffnessUnit CentinewtonMillimeterPerRadian;
    public static RotationalStiffnessUnit DecanewtonMeterPerDegree;
    public static RotationalStiffnessUnit DecanewtonMillimeterPerDegree;
    public static RotationalStiffnessUnit DecanewtonMillimeterPerRadian;
    public static RotationalStiffnessUnit DecinewtonMeterPerDegree;
    public static RotationalStiffnessUnit DecinewtonMillimeterPerDegree;
    public static RotationalStiffnessUnit DecinewtonMillimeterPerRadian;
    public static RotationalStiffnessUnit KilonewtonMeterPerDegree;
    public static RotationalStiffnessUnit KilonewtonMeterPerRadian;
    public static RotationalStiffnessUnit KilonewtonMillimeterPerDegree;
    public static RotationalStiffnessUnit KilonewtonMillimeterPerRadian;
    public static RotationalStiffnessUnit KilopoundForceFootPerDegrees;
    public static RotationalStiffnessUnit MeganewtonMeterPerDegree;
    public static RotationalStiffnessUnit MeganewtonMeterPerRadian;
    public static RotationalStiffnessUnit MeganewtonMillimeterPerDegree;
    public static RotationalStiffnessUnit MeganewtonMillimeterPerRadian;
    public static RotationalStiffnessUnit MicronewtonMeterPerDegree;
    public static RotationalStiffnessUnit MicronewtonMillimeterPerDegree;
    public static RotationalStiffnessUnit MicronewtonMillimeterPerRadian;
    public static RotationalStiffnessUnit MillinewtonMeterPerDegree;
    public static RotationalStiffnessUnit MillinewtonMillimeterPerDegree;
    public static RotationalStiffnessUnit MillinewtonMillimeterPerRadian;
    public static RotationalStiffnessUnit NanonewtonMeterPerDegree;
    public static RotationalStiffnessUnit NanonewtonMillimeterPerDegree;
    public static RotationalStiffnessUnit NanonewtonMillimeterPerRadian;
    public static RotationalStiffnessUnit NewtonMeterPerDegree;
    public static RotationalStiffnessUnit NewtonMeterPerRadian;
    public static RotationalStiffnessUnit NewtonMillimeterPerDegree;
    public static RotationalStiffnessUnit NewtonMillimeterPerRadian;
    public static RotationalStiffnessUnit PoundForceFeetPerRadian;
    public static RotationalStiffnessUnit PoundForceFootPerDegrees;
}
public enum UnitsNet.Units.ScalarUnit : Enum {
    public int value__;
    public static ScalarUnit Amount;
}
public enum UnitsNet.Units.SolidAngleUnit : Enum {
    public int value__;
    public static SolidAngleUnit Steradian;
}
public enum UnitsNet.Units.SpecificEnergyUnit : Enum {
    public int value__;
    public static SpecificEnergyUnit BtuPerPound;
    public static SpecificEnergyUnit CaloriePerGram;
    public static SpecificEnergyUnit GigawattDayPerKilogram;
    public static SpecificEnergyUnit GigawattDayPerShortTon;
    public static SpecificEnergyUnit GigawattDayPerTonne;
    public static SpecificEnergyUnit GigawattHourPerKilogram;
    public static SpecificEnergyUnit GigawattHourPerPound;
    public static SpecificEnergyUnit JoulePerKilogram;
    public static SpecificEnergyUnit KilocaloriePerGram;
    public static SpecificEnergyUnit KilojoulePerKilogram;
    public static SpecificEnergyUnit KilowattDayPerKilogram;
    public static SpecificEnergyUnit KilowattDayPerShortTon;
    public static SpecificEnergyUnit KilowattDayPerTonne;
    public static SpecificEnergyUnit KilowattHourPerKilogram;
    public static SpecificEnergyUnit KilowattHourPerPound;
    public static SpecificEnergyUnit MegajoulePerKilogram;
    public static SpecificEnergyUnit MegaJoulePerTonne;
    public static SpecificEnergyUnit MegawattDayPerKilogram;
    public static SpecificEnergyUnit MegawattDayPerShortTon;
    public static SpecificEnergyUnit MegawattDayPerTonne;
    public static SpecificEnergyUnit MegawattHourPerKilogram;
    public static SpecificEnergyUnit MegawattHourPerPound;
    public static SpecificEnergyUnit TerawattDayPerKilogram;
    public static SpecificEnergyUnit TerawattDayPerShortTon;
    public static SpecificEnergyUnit TerawattDayPerTonne;
    public static SpecificEnergyUnit WattDayPerKilogram;
    public static SpecificEnergyUnit WattDayPerShortTon;
    public static SpecificEnergyUnit WattDayPerTonne;
    public static SpecificEnergyUnit WattHourPerKilogram;
    public static SpecificEnergyUnit WattHourPerPound;
}
public enum UnitsNet.Units.SpecificEntropyUnit : Enum {
    public int value__;
    public static SpecificEntropyUnit BtuPerPoundFahrenheit;
    public static SpecificEntropyUnit CaloriePerGramKelvin;
    public static SpecificEntropyUnit JoulePerKilogramDegreeCelsius;
    public static SpecificEntropyUnit JoulePerKilogramKelvin;
    public static SpecificEntropyUnit KilocaloriePerGramKelvin;
    public static SpecificEntropyUnit KilojoulePerKilogramDegreeCelsius;
    public static SpecificEntropyUnit KilojoulePerKilogramKelvin;
    public static SpecificEntropyUnit MegajoulePerKilogramDegreeCelsius;
    public static SpecificEntropyUnit MegajoulePerKilogramKelvin;
}
public enum UnitsNet.Units.SpecificFuelConsumptionUnit : Enum {
    public int value__;
    public static SpecificFuelConsumptionUnit GramPerKiloNewtonSecond;
    public static SpecificFuelConsumptionUnit KilogramPerKilogramForceHour;
    public static SpecificFuelConsumptionUnit KilogramPerKiloNewtonSecond;
    public static SpecificFuelConsumptionUnit PoundMassPerPoundForceHour;
}
public enum UnitsNet.Units.SpecificVolumeUnit : Enum {
    public int value__;
    public static SpecificVolumeUnit CubicFootPerPound;
    public static SpecificVolumeUnit CubicMeterPerKilogram;
    public static SpecificVolumeUnit MillicubicMeterPerKilogram;
}
public enum UnitsNet.Units.SpecificWeightUnit : Enum {
    public int value__;
    public static SpecificWeightUnit KilogramForcePerCubicCentimeter;
    public static SpecificWeightUnit KilogramForcePerCubicMeter;
    public static SpecificWeightUnit KilogramForcePerCubicMillimeter;
    public static SpecificWeightUnit KilonewtonPerCubicCentimeter;
    public static SpecificWeightUnit KilonewtonPerCubicMeter;
    public static SpecificWeightUnit KilonewtonPerCubicMillimeter;
    public static SpecificWeightUnit KilopoundForcePerCubicFoot;
    public static SpecificWeightUnit KilopoundForcePerCubicInch;
    public static SpecificWeightUnit MeganewtonPerCubicMeter;
    public static SpecificWeightUnit NewtonPerCubicCentimeter;
    public static SpecificWeightUnit NewtonPerCubicMeter;
    public static SpecificWeightUnit NewtonPerCubicMillimeter;
    public static SpecificWeightUnit PoundForcePerCubicFoot;
    public static SpecificWeightUnit PoundForcePerCubicInch;
    public static SpecificWeightUnit TonneForcePerCubicCentimeter;
    public static SpecificWeightUnit TonneForcePerCubicMeter;
    public static SpecificWeightUnit TonneForcePerCubicMillimeter;
}
public enum UnitsNet.Units.SpeedUnit : Enum {
    public int value__;
    public static SpeedUnit CentimeterPerHour;
    public static SpeedUnit CentimeterPerMinute;
    public static SpeedUnit CentimeterPerSecond;
    public static SpeedUnit DecimeterPerMinute;
    public static SpeedUnit DecimeterPerSecond;
    public static SpeedUnit FootPerHour;
    public static SpeedUnit FootPerMinute;
    public static SpeedUnit FootPerSecond;
    public static SpeedUnit InchPerHour;
    public static SpeedUnit InchPerMinute;
    public static SpeedUnit InchPerSecond;
    public static SpeedUnit KilometerPerHour;
    public static SpeedUnit KilometerPerMinute;
    public static SpeedUnit KilometerPerSecond;
    public static SpeedUnit Knot;
    public static SpeedUnit Mach;
    public static SpeedUnit MeterPerHour;
    public static SpeedUnit MeterPerMinute;
    public static SpeedUnit MeterPerSecond;
    public static SpeedUnit MicrometerPerMinute;
    public static SpeedUnit MicrometerPerSecond;
    public static SpeedUnit MilePerHour;
    public static SpeedUnit MillimeterPerHour;
    public static SpeedUnit MillimeterPerMinute;
    public static SpeedUnit MillimeterPerSecond;
    public static SpeedUnit NanometerPerMinute;
    public static SpeedUnit NanometerPerSecond;
    public static SpeedUnit UsSurveyFootPerHour;
    public static SpeedUnit UsSurveyFootPerMinute;
    public static SpeedUnit UsSurveyFootPerSecond;
    public static SpeedUnit YardPerHour;
    public static SpeedUnit YardPerMinute;
    public static SpeedUnit YardPerSecond;
}
public enum UnitsNet.Units.StandardVolumeFlowUnit : Enum {
    public int value__;
    public static StandardVolumeFlowUnit StandardCubicCentimeterPerMinute;
    public static StandardVolumeFlowUnit StandardCubicFootPerHour;
    public static StandardVolumeFlowUnit StandardCubicFootPerMinute;
    public static StandardVolumeFlowUnit StandardCubicFootPerSecond;
    public static StandardVolumeFlowUnit StandardCubicMeterPerDay;
    public static StandardVolumeFlowUnit StandardCubicMeterPerHour;
    public static StandardVolumeFlowUnit StandardCubicMeterPerMinute;
    public static StandardVolumeFlowUnit StandardCubicMeterPerSecond;
    public static StandardVolumeFlowUnit StandardLiterPerMinute;
}
public enum UnitsNet.Units.TemperatureChangeRateUnit : Enum {
    public int value__;
    public static TemperatureChangeRateUnit CentidegreeCelsiusPerSecond;
    public static TemperatureChangeRateUnit DecadegreeCelsiusPerSecond;
    public static TemperatureChangeRateUnit DecidegreeCelsiusPerSecond;
    public static TemperatureChangeRateUnit DegreeCelsiusPerMinute;
    public static TemperatureChangeRateUnit DegreeCelsiusPerSecond;
    public static TemperatureChangeRateUnit HectodegreeCelsiusPerSecond;
    public static TemperatureChangeRateUnit KilodegreeCelsiusPerSecond;
    public static TemperatureChangeRateUnit MicrodegreeCelsiusPerSecond;
    public static TemperatureChangeRateUnit MillidegreeCelsiusPerSecond;
    public static TemperatureChangeRateUnit NanodegreeCelsiusPerSecond;
}
public enum UnitsNet.Units.TemperatureDeltaUnit : Enum {
    public int value__;
    public static TemperatureDeltaUnit DegreeCelsius;
    public static TemperatureDeltaUnit DegreeDelisle;
    public static TemperatureDeltaUnit DegreeFahrenheit;
    public static TemperatureDeltaUnit DegreeNewton;
    public static TemperatureDeltaUnit DegreeRankine;
    public static TemperatureDeltaUnit DegreeReaumur;
    public static TemperatureDeltaUnit DegreeRoemer;
    public static TemperatureDeltaUnit Kelvin;
    public static TemperatureDeltaUnit MillidegreeCelsius;
}
public enum UnitsNet.Units.TemperatureGradientUnit : Enum {
    public int value__;
    public static TemperatureGradientUnit DegreeCelsiusPerKilometer;
    public static TemperatureGradientUnit DegreeCelsiusPerMeter;
    public static TemperatureGradientUnit DegreeFahrenheitPerFoot;
    public static TemperatureGradientUnit KelvinPerMeter;
}
public enum UnitsNet.Units.TemperatureUnit : Enum {
    public int value__;
    public static TemperatureUnit DegreeCelsius;
    public static TemperatureUnit DegreeDelisle;
    public static TemperatureUnit DegreeFahrenheit;
    public static TemperatureUnit DegreeNewton;
    public static TemperatureUnit DegreeRankine;
    public static TemperatureUnit DegreeReaumur;
    public static TemperatureUnit DegreeRoemer;
    public static TemperatureUnit Kelvin;
    public static TemperatureUnit MillidegreeCelsius;
    public static TemperatureUnit SolarTemperature;
}
public enum UnitsNet.Units.ThermalConductivityUnit : Enum {
    public int value__;
    public static ThermalConductivityUnit BtuPerHourFootFahrenheit;
    public static ThermalConductivityUnit WattPerMeterKelvin;
}
public enum UnitsNet.Units.ThermalResistanceUnit : Enum {
    public int value__;
    public static ThermalResistanceUnit HourSquareFeetDegreeFahrenheitPerBtu;
    public static ThermalResistanceUnit SquareCentimeterHourDegreeCelsiusPerKilocalorie;
    public static ThermalResistanceUnit SquareCentimeterKelvinPerWatt;
    public static ThermalResistanceUnit SquareMeterDegreeCelsiusPerWatt;
    public static ThermalResistanceUnit SquareMeterKelvinPerKilowatt;
    public static ThermalResistanceUnit SquareMeterKelvinPerWatt;
}
public enum UnitsNet.Units.TorquePerLengthUnit : Enum {
    public int value__;
    public static TorquePerLengthUnit KilogramForceCentimeterPerMeter;
    public static TorquePerLengthUnit KilogramForceMeterPerMeter;
    public static TorquePerLengthUnit KilogramForceMillimeterPerMeter;
    public static TorquePerLengthUnit KilonewtonCentimeterPerMeter;
    public static TorquePerLengthUnit KilonewtonMeterPerMeter;
    public static TorquePerLengthUnit KilonewtonMillimeterPerMeter;
    public static TorquePerLengthUnit KilopoundForceFootPerFoot;
    public static TorquePerLengthUnit KilopoundForceInchPerFoot;
    public static TorquePerLengthUnit MeganewtonCentimeterPerMeter;
    public static TorquePerLengthUnit MeganewtonMeterPerMeter;
    public static TorquePerLengthUnit MeganewtonMillimeterPerMeter;
    public static TorquePerLengthUnit MegapoundForceFootPerFoot;
    public static TorquePerLengthUnit MegapoundForceInchPerFoot;
    public static TorquePerLengthUnit NewtonCentimeterPerMeter;
    public static TorquePerLengthUnit NewtonMeterPerMeter;
    public static TorquePerLengthUnit NewtonMillimeterPerMeter;
    public static TorquePerLengthUnit PoundForceFootPerFoot;
    public static TorquePerLengthUnit PoundForceInchPerFoot;
    public static TorquePerLengthUnit TonneForceCentimeterPerMeter;
    public static TorquePerLengthUnit TonneForceMeterPerMeter;
    public static TorquePerLengthUnit TonneForceMillimeterPerMeter;
}
public enum UnitsNet.Units.TorqueUnit : Enum {
    public int value__;
    public static TorqueUnit GramForceCentimeter;
    public static TorqueUnit GramForceMeter;
    public static TorqueUnit GramForceMillimeter;
    public static TorqueUnit KilogramForceCentimeter;
    public static TorqueUnit KilogramForceMeter;
    public static TorqueUnit KilogramForceMillimeter;
    public static TorqueUnit KilonewtonCentimeter;
    public static TorqueUnit KilonewtonMeter;
    public static TorqueUnit KilonewtonMillimeter;
    public static TorqueUnit KilopoundForceFoot;
    public static TorqueUnit KilopoundForceInch;
    public static TorqueUnit MeganewtonCentimeter;
    public static TorqueUnit MeganewtonMeter;
    public static TorqueUnit MeganewtonMillimeter;
    public static TorqueUnit MegapoundForceFoot;
    public static TorqueUnit MegapoundForceInch;
    public static TorqueUnit NewtonCentimeter;
    public static TorqueUnit NewtonMeter;
    public static TorqueUnit NewtonMillimeter;
    public static TorqueUnit PoundalFoot;
    public static TorqueUnit PoundForceFoot;
    public static TorqueUnit PoundForceInch;
    public static TorqueUnit TonneForceCentimeter;
    public static TorqueUnit TonneForceMeter;
    public static TorqueUnit TonneForceMillimeter;
}
public enum UnitsNet.Units.TurbidityUnit : Enum {
    public int value__;
    public static TurbidityUnit NTU;
}
public enum UnitsNet.Units.VitaminAUnit : Enum {
    public int value__;
    public static VitaminAUnit InternationalUnit;
}
public enum UnitsNet.Units.VolumeConcentrationUnit : Enum {
    public int value__;
    public static VolumeConcentrationUnit CentilitersPerLiter;
    public static VolumeConcentrationUnit CentilitersPerMililiter;
    public static VolumeConcentrationUnit DecilitersPerLiter;
    public static VolumeConcentrationUnit DecilitersPerMililiter;
    public static VolumeConcentrationUnit DecimalFraction;
    public static VolumeConcentrationUnit LitersPerLiter;
    public static VolumeConcentrationUnit LitersPerMililiter;
    public static VolumeConcentrationUnit MicrolitersPerLiter;
    public static VolumeConcentrationUnit MicrolitersPerMililiter;
    public static VolumeConcentrationUnit MillilitersPerLiter;
    public static VolumeConcentrationUnit MillilitersPerMililiter;
    public static VolumeConcentrationUnit NanolitersPerLiter;
    public static VolumeConcentrationUnit NanolitersPerMililiter;
    public static VolumeConcentrationUnit PartPerBillion;
    public static VolumeConcentrationUnit PartPerMillion;
    public static VolumeConcentrationUnit PartPerThousand;
    public static VolumeConcentrationUnit PartPerTrillion;
    public static VolumeConcentrationUnit Percent;
    public static VolumeConcentrationUnit PicolitersPerLiter;
    public static VolumeConcentrationUnit PicolitersPerMililiter;
}
public enum UnitsNet.Units.VolumeFlowPerAreaUnit : Enum {
    public int value__;
    public static VolumeFlowPerAreaUnit CubicFootPerMinutePerSquareFoot;
    public static VolumeFlowPerAreaUnit CubicMeterPerSecondPerSquareMeter;
}
public enum UnitsNet.Units.VolumeFlowUnit : Enum {
    public int value__;
    public static VolumeFlowUnit AcreFootPerDay;
    public static VolumeFlowUnit AcreFootPerHour;
    public static VolumeFlowUnit AcreFootPerMinute;
    public static VolumeFlowUnit AcreFootPerSecond;
    public static VolumeFlowUnit CentiliterPerDay;
    public static VolumeFlowUnit CentiliterPerHour;
    public static VolumeFlowUnit CentiliterPerMinute;
    public static VolumeFlowUnit CentiliterPerSecond;
    public static VolumeFlowUnit CubicCentimeterPerMinute;
    public static VolumeFlowUnit CubicDecimeterPerMinute;
    public static VolumeFlowUnit CubicFootPerHour;
    public static VolumeFlowUnit CubicFootPerMinute;
    public static VolumeFlowUnit CubicFootPerSecond;
    public static VolumeFlowUnit CubicMeterPerDay;
    public static VolumeFlowUnit CubicMeterPerHour;
    public static VolumeFlowUnit CubicMeterPerMinute;
    public static VolumeFlowUnit CubicMeterPerSecond;
    public static VolumeFlowUnit CubicMillimeterPerSecond;
    public static VolumeFlowUnit CubicYardPerDay;
    public static VolumeFlowUnit CubicYardPerHour;
    public static VolumeFlowUnit CubicYardPerMinute;
    public static VolumeFlowUnit CubicYardPerSecond;
    public static VolumeFlowUnit DecaliterPerDay;
    public static VolumeFlowUnit DecaliterPerHour;
    public static VolumeFlowUnit DecaliterPerMinute;
    public static VolumeFlowUnit DecaliterPerSecond;
    public static VolumeFlowUnit DeciliterPerDay;
    public static VolumeFlowUnit DeciliterPerHour;
    public static VolumeFlowUnit DeciliterPerMinute;
    public static VolumeFlowUnit DeciliterPerSecond;
    public static VolumeFlowUnit HectoliterPerDay;
    public static VolumeFlowUnit HectoliterPerHour;
    public static VolumeFlowUnit HectoliterPerMinute;
    public static VolumeFlowUnit HectoliterPerSecond;
    public static VolumeFlowUnit KiloliterPerDay;
    public static VolumeFlowUnit KiloliterPerHour;
    public static VolumeFlowUnit KiloliterPerMinute;
    public static VolumeFlowUnit KiloliterPerSecond;
    public static VolumeFlowUnit KilousGallonPerMinute;
    public static VolumeFlowUnit LiterPerDay;
    public static VolumeFlowUnit LiterPerHour;
    public static VolumeFlowUnit LiterPerMinute;
    public static VolumeFlowUnit LiterPerSecond;
    public static VolumeFlowUnit MegaliterPerDay;
    public static VolumeFlowUnit MegaliterPerHour;
    public static VolumeFlowUnit MegaliterPerMinute;
    public static VolumeFlowUnit MegaliterPerSecond;
    public static VolumeFlowUnit MegaukGallonPerDay;
    public static VolumeFlowUnit MegaukGallonPerSecond;
    public static VolumeFlowUnit MegausGallonPerDay;
    public static VolumeFlowUnit MicroliterPerDay;
    public static VolumeFlowUnit MicroliterPerHour;
    public static VolumeFlowUnit MicroliterPerMinute;
    public static VolumeFlowUnit MicroliterPerSecond;
    public static VolumeFlowUnit MilliliterPerDay;
    public static VolumeFlowUnit MilliliterPerHour;
    public static VolumeFlowUnit MilliliterPerMinute;
    public static VolumeFlowUnit MilliliterPerSecond;
    public static VolumeFlowUnit MillionUsGallonPerDay;
    public static VolumeFlowUnit NanoliterPerDay;
    public static VolumeFlowUnit NanoliterPerHour;
    public static VolumeFlowUnit NanoliterPerMinute;
    public static VolumeFlowUnit NanoliterPerSecond;
    public static VolumeFlowUnit OilBarrelPerDay;
    public static VolumeFlowUnit OilBarrelPerHour;
    public static VolumeFlowUnit OilBarrelPerMinute;
    public static VolumeFlowUnit OilBarrelPerSecond;
    public static VolumeFlowUnit UkGallonPerDay;
    public static VolumeFlowUnit UkGallonPerHour;
    public static VolumeFlowUnit UkGallonPerMinute;
    public static VolumeFlowUnit UkGallonPerSecond;
    public static VolumeFlowUnit UsGallonPerDay;
    public static VolumeFlowUnit UsGallonPerHour;
    public static VolumeFlowUnit UsGallonPerMinute;
    public static VolumeFlowUnit UsGallonPerSecond;
}
public enum UnitsNet.Units.VolumePerLengthUnit : Enum {
    public int value__;
    public static VolumePerLengthUnit CubicMeterPerMeter;
    public static VolumePerLengthUnit CubicYardPerFoot;
    public static VolumePerLengthUnit CubicYardPerUsSurveyFoot;
    public static VolumePerLengthUnit ImperialGallonPerMile;
    public static VolumePerLengthUnit LiterPerKilometer;
    public static VolumePerLengthUnit LiterPerMeter;
    public static VolumePerLengthUnit LiterPerMillimeter;
    public static VolumePerLengthUnit OilBarrelPerFoot;
    public static VolumePerLengthUnit UsGallonPerMile;
}
public enum UnitsNet.Units.VolumetricHeatCapacityUnit : Enum {
    public int value__;
    public static VolumetricHeatCapacityUnit BtuPerCubicFootDegreeFahrenheit;
    public static VolumetricHeatCapacityUnit CaloriePerCubicCentimeterDegreeCelsius;
    public static VolumetricHeatCapacityUnit JoulePerCubicMeterDegreeCelsius;
    public static VolumetricHeatCapacityUnit JoulePerCubicMeterKelvin;
    public static VolumetricHeatCapacityUnit KilocaloriePerCubicCentimeterDegreeCelsius;
    public static VolumetricHeatCapacityUnit KilojoulePerCubicMeterDegreeCelsius;
    public static VolumetricHeatCapacityUnit KilojoulePerCubicMeterKelvin;
    public static VolumetricHeatCapacityUnit MegajoulePerCubicMeterDegreeCelsius;
    public static VolumetricHeatCapacityUnit MegajoulePerCubicMeterKelvin;
}
public enum UnitsNet.Units.VolumeUnit : Enum {
    public int value__;
    public static VolumeUnit AcreFoot;
    public static VolumeUnit AuTablespoon;
    public static VolumeUnit BoardFoot;
    public static VolumeUnit Centiliter;
    public static VolumeUnit CubicCentimeter;
    public static VolumeUnit CubicDecimeter;
    public static VolumeUnit CubicFoot;
    public static VolumeUnit CubicHectometer;
    public static VolumeUnit CubicInch;
    public static VolumeUnit CubicKilometer;
    public static VolumeUnit CubicMeter;
    public static VolumeUnit CubicMicrometer;
    public static VolumeUnit CubicMile;
    public static VolumeUnit CubicMillimeter;
    public static VolumeUnit CubicYard;
    public static VolumeUnit Decaliter;
    public static VolumeUnit DecausGallon;
    public static VolumeUnit Deciliter;
    public static VolumeUnit DeciusGallon;
    public static VolumeUnit HectocubicFoot;
    public static VolumeUnit HectocubicMeter;
    public static VolumeUnit Hectoliter;
    public static VolumeUnit HectousGallon;
    public static VolumeUnit ImperialBeerBarrel;
    public static VolumeUnit ImperialGallon;
    public static VolumeUnit ImperialOunce;
    public static VolumeUnit ImperialPint;
    public static VolumeUnit ImperialQuart;
    public static VolumeUnit KilocubicFoot;
    public static VolumeUnit KilocubicMeter;
    public static VolumeUnit KiloimperialGallon;
    public static VolumeUnit Kiloliter;
    public static VolumeUnit KilousGallon;
    public static VolumeUnit Liter;
    public static VolumeUnit MegacubicFoot;
    public static VolumeUnit MegaimperialGallon;
    public static VolumeUnit Megaliter;
    public static VolumeUnit MegausGallon;
    public static VolumeUnit MetricCup;
    public static VolumeUnit MetricTeaspoon;
    public static VolumeUnit Microliter;
    public static VolumeUnit Milliliter;
    public static VolumeUnit Nanoliter;
    public static VolumeUnit OilBarrel;
    public static VolumeUnit UkTablespoon;
    public static VolumeUnit UsBeerBarrel;
    public static VolumeUnit UsCustomaryCup;
    public static VolumeUnit UsGallon;
    public static VolumeUnit UsLegalCup;
    public static VolumeUnit UsOunce;
    public static VolumeUnit UsPint;
    public static VolumeUnit UsQuart;
    public static VolumeUnit UsTablespoon;
    public static VolumeUnit UsTeaspoon;
}
public enum UnitsNet.Units.WarpingMomentOfInertiaUnit : Enum {
    public int value__;
    public static WarpingMomentOfInertiaUnit CentimeterToTheSixth;
    public static WarpingMomentOfInertiaUnit DecimeterToTheSixth;
    public static WarpingMomentOfInertiaUnit FootToTheSixth;
    public static WarpingMomentOfInertiaUnit InchToTheSixth;
    public static WarpingMomentOfInertiaUnit MeterToTheSixth;
    public static WarpingMomentOfInertiaUnit MillimeterToTheSixth;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.UnitsNetException : Exception {
    public UnitsNetException(string message);
    public UnitsNetException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.UnitsNetSetup : object {
    [CompilerGeneratedAttribute]
private static UnitsNetSetup <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private UnitConverter <UnitConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private UnitAbbreviationsCache <UnitAbbreviations>k__BackingField;
    [CompilerGeneratedAttribute]
private UnitParser <UnitParser>k__BackingField;
    [CompilerGeneratedAttribute]
private QuantityParser <QuantityParser>k__BackingField;
    [CompilerGeneratedAttribute]
private QuantityInfoLookup <QuantityInfoLookup>k__BackingField;
    public static UnitsNetSetup Default { get; }
    public UnitConverter UnitConverter { get; }
    public UnitAbbreviationsCache UnitAbbreviations { get; }
    public UnitParser UnitParser { get; }
    internal QuantityParser QuantityParser { get; }
    internal QuantityInfoLookup QuantityInfoLookup { get; }
    private static UnitsNetSetup();
    public UnitsNetSetup(ICollection`1<QuantityInfo> quantityInfos, UnitConverter unitConverter);
    [CompilerGeneratedAttribute]
public static UnitsNetSetup get_Default();
    [CompilerGeneratedAttribute]
public UnitConverter get_UnitConverter();
    [CompilerGeneratedAttribute]
public UnitAbbreviationsCache get_UnitAbbreviations();
    [CompilerGeneratedAttribute]
public UnitParser get_UnitParser();
    [CompilerGeneratedAttribute]
internal QuantityParser get_QuantityParser();
    [CompilerGeneratedAttribute]
internal QuantityInfoLookup get_QuantityInfoLookup();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.UnitSystem : object {
    [CompilerGeneratedAttribute]
private BaseUnits <BaseUnits>k__BackingField;
    private static BaseUnits SIBaseUnits;
    [CompilerGeneratedAttribute]
private static UnitSystem <SI>k__BackingField;
    public BaseUnits BaseUnits { get; }
    public static UnitSystem SI { get; }
    public UnitSystem(BaseUnits baseUnits);
    private static UnitSystem();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(UnitSystem other);
    [NullableContextAttribute("2")]
public static bool op_Equality(UnitSystem left, UnitSystem right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(UnitSystem left, UnitSystem right);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public BaseUnits get_BaseUnits();
    [CompilerGeneratedAttribute]
public static UnitSystem get_SI();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.VitaminA : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<VitaminAUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<VitaminAUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static VitaminAUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static VitaminAUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static VitaminA <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<VitaminAUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static VitaminAUnit BaseUnit { get; }
    public static VitaminAUnit[] Units { get; }
    public static VitaminA Zero { get; }
    public static VitaminA AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public VitaminAUnit Unit { get; }
    public QuantityInfo`1<VitaminAUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double InternationalUnits { get; }
    private static VitaminA();
    public VitaminA(double value, VitaminAUnit unit);
    public VitaminA(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<VitaminAUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static VitaminAUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static VitaminAUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override VitaminA get_Zero();
    public static override VitaminA get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual VitaminAUnit get_Unit();
    public sealed virtual QuantityInfo`1<VitaminAUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_InternationalUnits();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(VitaminAUnit unit);
    public static string GetAbbreviation(VitaminAUnit unit, IFormatProvider provider);
    public static VitaminA FromInternationalUnits(double value);
    public static VitaminA From(double value, VitaminAUnit fromUnit);
    public static VitaminA Parse(string str);
    public static override VitaminA Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, VitaminA& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, VitaminA& result);
    public static VitaminAUnit ParseUnit(string str);
    public static VitaminAUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, VitaminAUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, VitaminAUnit& unit);
    public static override VitaminA op_UnaryNegation(VitaminA right);
    public static override VitaminA op_Addition(VitaminA left, VitaminA right);
    public static override VitaminA op_Subtraction(VitaminA left, VitaminA right);
    public static VitaminA op_Multiply(double left, VitaminA right);
    public static override VitaminA op_Multiply(VitaminA left, double right);
    public static override VitaminA op_Division(VitaminA left, double right);
    public static double op_Division(VitaminA left, VitaminA right);
    public static override bool op_LessThanOrEqual(VitaminA left, VitaminA right);
    public static override bool op_GreaterThanOrEqual(VitaminA left, VitaminA right);
    public static override bool op_LessThan(VitaminA left, VitaminA right);
    public static override bool op_GreaterThan(VitaminA left, VitaminA right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(VitaminA other, VitaminA tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(VitaminA left, VitaminA right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(VitaminA other, VitaminA tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(VitaminA left, VitaminA right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(VitaminA other, VitaminA tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(VitaminA other, VitaminA tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(VitaminA other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(VitaminA other);
    [ObsoleteAttribute("Use Equals(VitaminA other, VitaminA tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(VitaminA other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(VitaminA other, VitaminA tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(VitaminAUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public VitaminA ToUnit(VitaminAUnit unit);
    public VitaminA ToUnit(VitaminAUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(VitaminAUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public VitaminA ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<VitaminAUnit> UnitsNet.IQuantity<UnitsNet.Units.VitaminAUnit>.ToUnit(VitaminAUnit unit);
    private sealed virtual override IQuantity`1<VitaminAUnit> UnitsNet.IQuantity<UnitsNet.Units.VitaminAUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.Volume : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<VolumeUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<VolumeUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumeUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumeUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static Volume <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<VolumeUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static VolumeUnit BaseUnit { get; }
    public static VolumeUnit[] Units { get; }
    public static Volume Zero { get; }
    public static Volume AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public VolumeUnit Unit { get; }
    public QuantityInfo`1<VolumeUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double AcreFeet { get; }
    public double AuTablespoons { get; }
    public double BoardFeet { get; }
    public double Centiliters { get; }
    public double CubicCentimeters { get; }
    public double CubicDecimeters { get; }
    public double CubicFeet { get; }
    public double CubicHectometers { get; }
    public double CubicInches { get; }
    public double CubicKilometers { get; }
    public double CubicMeters { get; }
    public double CubicMicrometers { get; }
    public double CubicMiles { get; }
    public double CubicMillimeters { get; }
    public double CubicYards { get; }
    public double Decaliters { get; }
    public double DecausGallons { get; }
    public double Deciliters { get; }
    public double DeciusGallons { get; }
    public double HectocubicFeet { get; }
    public double HectocubicMeters { get; }
    public double Hectoliters { get; }
    public double HectousGallons { get; }
    public double ImperialBeerBarrels { get; }
    public double ImperialGallons { get; }
    public double ImperialOunces { get; }
    public double ImperialPints { get; }
    public double ImperialQuarts { get; }
    public double KilocubicFeet { get; }
    public double KilocubicMeters { get; }
    public double KiloimperialGallons { get; }
    public double Kiloliters { get; }
    public double KilousGallons { get; }
    public double Liters { get; }
    public double MegacubicFeet { get; }
    public double MegaimperialGallons { get; }
    public double Megaliters { get; }
    public double MegausGallons { get; }
    public double MetricCups { get; }
    public double MetricTeaspoons { get; }
    public double Microliters { get; }
    public double Milliliters { get; }
    public double Nanoliters { get; }
    public double OilBarrels { get; }
    public double UkTablespoons { get; }
    public double UsBeerBarrels { get; }
    public double UsCustomaryCups { get; }
    public double UsGallons { get; }
    public double UsLegalCups { get; }
    public double UsOunces { get; }
    public double UsPints { get; }
    public double UsQuarts { get; }
    public double UsTablespoons { get; }
    public double UsTeaspoons { get; }
    private static Volume();
    public Volume(double value, VolumeUnit unit);
    public Volume(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<VolumeUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static VolumeUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static VolumeUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override Volume get_Zero();
    public static override Volume get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual VolumeUnit get_Unit();
    public sealed virtual QuantityInfo`1<VolumeUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_AcreFeet();
    public double get_AuTablespoons();
    public double get_BoardFeet();
    public double get_Centiliters();
    public double get_CubicCentimeters();
    public double get_CubicDecimeters();
    public double get_CubicFeet();
    public double get_CubicHectometers();
    public double get_CubicInches();
    public double get_CubicKilometers();
    public double get_CubicMeters();
    public double get_CubicMicrometers();
    public double get_CubicMiles();
    public double get_CubicMillimeters();
    public double get_CubicYards();
    public double get_Decaliters();
    public double get_DecausGallons();
    public double get_Deciliters();
    public double get_DeciusGallons();
    public double get_HectocubicFeet();
    public double get_HectocubicMeters();
    public double get_Hectoliters();
    public double get_HectousGallons();
    public double get_ImperialBeerBarrels();
    public double get_ImperialGallons();
    public double get_ImperialOunces();
    public double get_ImperialPints();
    public double get_ImperialQuarts();
    public double get_KilocubicFeet();
    public double get_KilocubicMeters();
    public double get_KiloimperialGallons();
    public double get_Kiloliters();
    public double get_KilousGallons();
    public double get_Liters();
    public double get_MegacubicFeet();
    public double get_MegaimperialGallons();
    public double get_Megaliters();
    public double get_MegausGallons();
    public double get_MetricCups();
    public double get_MetricTeaspoons();
    public double get_Microliters();
    public double get_Milliliters();
    public double get_Nanoliters();
    public double get_OilBarrels();
    public double get_UkTablespoons();
    public double get_UsBeerBarrels();
    public double get_UsCustomaryCups();
    public double get_UsGallons();
    public double get_UsLegalCups();
    public double get_UsOunces();
    public double get_UsPints();
    public double get_UsQuarts();
    public double get_UsTablespoons();
    public double get_UsTeaspoons();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(VolumeUnit unit);
    public static string GetAbbreviation(VolumeUnit unit, IFormatProvider provider);
    public static Volume FromAcreFeet(double value);
    public static Volume FromAuTablespoons(double value);
    public static Volume FromBoardFeet(double value);
    public static Volume FromCentiliters(double value);
    public static Volume FromCubicCentimeters(double value);
    public static Volume FromCubicDecimeters(double value);
    public static Volume FromCubicFeet(double value);
    public static Volume FromCubicHectometers(double value);
    public static Volume FromCubicInches(double value);
    public static Volume FromCubicKilometers(double value);
    public static Volume FromCubicMeters(double value);
    public static Volume FromCubicMicrometers(double value);
    public static Volume FromCubicMiles(double value);
    public static Volume FromCubicMillimeters(double value);
    public static Volume FromCubicYards(double value);
    public static Volume FromDecaliters(double value);
    public static Volume FromDecausGallons(double value);
    public static Volume FromDeciliters(double value);
    public static Volume FromDeciusGallons(double value);
    public static Volume FromHectocubicFeet(double value);
    public static Volume FromHectocubicMeters(double value);
    public static Volume FromHectoliters(double value);
    public static Volume FromHectousGallons(double value);
    public static Volume FromImperialBeerBarrels(double value);
    public static Volume FromImperialGallons(double value);
    public static Volume FromImperialOunces(double value);
    public static Volume FromImperialPints(double value);
    public static Volume FromImperialQuarts(double value);
    public static Volume FromKilocubicFeet(double value);
    public static Volume FromKilocubicMeters(double value);
    public static Volume FromKiloimperialGallons(double value);
    public static Volume FromKiloliters(double value);
    public static Volume FromKilousGallons(double value);
    public static Volume FromLiters(double value);
    public static Volume FromMegacubicFeet(double value);
    public static Volume FromMegaimperialGallons(double value);
    public static Volume FromMegaliters(double value);
    public static Volume FromMegausGallons(double value);
    public static Volume FromMetricCups(double value);
    public static Volume FromMetricTeaspoons(double value);
    public static Volume FromMicroliters(double value);
    public static Volume FromMilliliters(double value);
    public static Volume FromNanoliters(double value);
    public static Volume FromOilBarrels(double value);
    public static Volume FromUkTablespoons(double value);
    public static Volume FromUsBeerBarrels(double value);
    public static Volume FromUsCustomaryCups(double value);
    public static Volume FromUsGallons(double value);
    public static Volume FromUsLegalCups(double value);
    public static Volume FromUsOunces(double value);
    public static Volume FromUsPints(double value);
    public static Volume FromUsQuarts(double value);
    public static Volume FromUsTablespoons(double value);
    public static Volume FromUsTeaspoons(double value);
    public static Volume From(double value, VolumeUnit fromUnit);
    public static Volume Parse(string str);
    public static override Volume Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, Volume& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, Volume& result);
    public static VolumeUnit ParseUnit(string str);
    public static VolumeUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, VolumeUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, VolumeUnit& unit);
    public static override Volume op_UnaryNegation(Volume right);
    public static override Volume op_Addition(Volume left, Volume right);
    public static override Volume op_Subtraction(Volume left, Volume right);
    public static Volume op_Multiply(double left, Volume right);
    public static override Volume op_Multiply(Volume left, double right);
    public static override Volume op_Division(Volume left, double right);
    public static double op_Division(Volume left, Volume right);
    public static override AmountOfSubstance op_Multiply(Volume volume, Molarity molarity);
    public static override Area op_Multiply(Volume volume, ReciprocalLength reciprocalLength);
    public static override Area op_Division(Volume volume, Length length);
    public static override AreaMomentOfInertia op_Multiply(Volume volume, Length length);
    public static override Duration op_Division(Volume volume, VolumeFlow volumeFlow);
    public static override Energy op_Multiply(Volume volume, EnergyDensity energyDensity);
    public static override Length op_Multiply(Volume volume, ReciprocalArea reciprocalArea);
    public static override Length op_Division(Volume volume, Area area);
    public static override Mass op_Multiply(Volume volume, Density density);
    public static override Mass op_Multiply(Volume volume, MassConcentration massConcentration);
    public static override Mass op_Division(Volume volume, SpecificVolume specificVolume);
    public static override SpecificVolume op_Division(Volume volume, Mass mass);
    public static override VolumeFlow op_Division(Volume volume, Duration duration);
    public static override bool op_LessThanOrEqual(Volume left, Volume right);
    public static override bool op_GreaterThanOrEqual(Volume left, Volume right);
    public static override bool op_LessThan(Volume left, Volume right);
    public static override bool op_GreaterThan(Volume left, Volume right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Volume other, Volume tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(Volume left, Volume right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(Volume other, Volume tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(Volume left, Volume right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(Volume other, Volume tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(Volume other, Volume tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(Volume other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Volume other);
    [ObsoleteAttribute("Use Equals(Volume other, Volume tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(Volume other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(Volume other, Volume tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(VolumeUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public Volume ToUnit(VolumeUnit unit);
    public Volume ToUnit(VolumeUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(VolumeUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public Volume ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<VolumeUnit> UnitsNet.IQuantity<UnitsNet.Units.VolumeUnit>.ToUnit(VolumeUnit unit);
    private sealed virtual override IQuantity`1<VolumeUnit> UnitsNet.IQuantity<UnitsNet.Units.VolumeUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.VolumeConcentration : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<VolumeConcentrationUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<VolumeConcentrationUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumeConcentrationUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumeConcentrationUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumeConcentration <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<VolumeConcentrationUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static VolumeConcentrationUnit BaseUnit { get; }
    public static VolumeConcentrationUnit[] Units { get; }
    public static VolumeConcentration Zero { get; }
    public static VolumeConcentration AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public VolumeConcentrationUnit Unit { get; }
    public QuantityInfo`1<VolumeConcentrationUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentilitersPerLiter { get; }
    public double CentilitersPerMililiter { get; }
    public double DecilitersPerLiter { get; }
    public double DecilitersPerMililiter { get; }
    public double DecimalFractions { get; }
    public double LitersPerLiter { get; }
    public double LitersPerMililiter { get; }
    public double MicrolitersPerLiter { get; }
    public double MicrolitersPerMililiter { get; }
    public double MillilitersPerLiter { get; }
    public double MillilitersPerMililiter { get; }
    public double NanolitersPerLiter { get; }
    public double NanolitersPerMililiter { get; }
    public double PartsPerBillion { get; }
    public double PartsPerMillion { get; }
    public double PartsPerThousand { get; }
    public double PartsPerTrillion { get; }
    public double Percent { get; }
    public double PicolitersPerLiter { get; }
    public double PicolitersPerMililiter { get; }
    private static VolumeConcentration();
    public VolumeConcentration(double value, VolumeConcentrationUnit unit);
    public VolumeConcentration(double value, UnitSystem unitSystem);
    public MassConcentration ToMassConcentration(Density componentDensity);
    public Molarity ToMolarity(Density componentDensity, MolarMass compontMolarMass);
    public static VolumeConcentration FromVolumes(Volume componentVolume, Volume mixtureMass);
    public static VolumeConcentration FromMolarity(Molarity molarity, Density componentDensity, MolarMass componentMolarMass);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<VolumeConcentrationUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static VolumeConcentrationUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static VolumeConcentrationUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override VolumeConcentration get_Zero();
    public static override VolumeConcentration get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual VolumeConcentrationUnit get_Unit();
    public sealed virtual QuantityInfo`1<VolumeConcentrationUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentilitersPerLiter();
    public double get_CentilitersPerMililiter();
    public double get_DecilitersPerLiter();
    public double get_DecilitersPerMililiter();
    public double get_DecimalFractions();
    public double get_LitersPerLiter();
    public double get_LitersPerMililiter();
    public double get_MicrolitersPerLiter();
    public double get_MicrolitersPerMililiter();
    public double get_MillilitersPerLiter();
    public double get_MillilitersPerMililiter();
    public double get_NanolitersPerLiter();
    public double get_NanolitersPerMililiter();
    public double get_PartsPerBillion();
    public double get_PartsPerMillion();
    public double get_PartsPerThousand();
    public double get_PartsPerTrillion();
    public double get_Percent();
    public double get_PicolitersPerLiter();
    public double get_PicolitersPerMililiter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(VolumeConcentrationUnit unit);
    public static string GetAbbreviation(VolumeConcentrationUnit unit, IFormatProvider provider);
    public static VolumeConcentration FromCentilitersPerLiter(double value);
    public static VolumeConcentration FromCentilitersPerMililiter(double value);
    public static VolumeConcentration FromDecilitersPerLiter(double value);
    public static VolumeConcentration FromDecilitersPerMililiter(double value);
    public static VolumeConcentration FromDecimalFractions(double value);
    public static VolumeConcentration FromLitersPerLiter(double value);
    public static VolumeConcentration FromLitersPerMililiter(double value);
    public static VolumeConcentration FromMicrolitersPerLiter(double value);
    public static VolumeConcentration FromMicrolitersPerMililiter(double value);
    public static VolumeConcentration FromMillilitersPerLiter(double value);
    public static VolumeConcentration FromMillilitersPerMililiter(double value);
    public static VolumeConcentration FromNanolitersPerLiter(double value);
    public static VolumeConcentration FromNanolitersPerMililiter(double value);
    public static VolumeConcentration FromPartsPerBillion(double value);
    public static VolumeConcentration FromPartsPerMillion(double value);
    public static VolumeConcentration FromPartsPerThousand(double value);
    public static VolumeConcentration FromPartsPerTrillion(double value);
    public static VolumeConcentration FromPercent(double value);
    public static VolumeConcentration FromPicolitersPerLiter(double value);
    public static VolumeConcentration FromPicolitersPerMililiter(double value);
    public static VolumeConcentration From(double value, VolumeConcentrationUnit fromUnit);
    public static VolumeConcentration Parse(string str);
    public static override VolumeConcentration Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, VolumeConcentration& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, VolumeConcentration& result);
    public static VolumeConcentrationUnit ParseUnit(string str);
    public static VolumeConcentrationUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, VolumeConcentrationUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, VolumeConcentrationUnit& unit);
    public static override VolumeConcentration op_UnaryNegation(VolumeConcentration right);
    public static override VolumeConcentration op_Addition(VolumeConcentration left, VolumeConcentration right);
    public static override VolumeConcentration op_Subtraction(VolumeConcentration left, VolumeConcentration right);
    public static VolumeConcentration op_Multiply(double left, VolumeConcentration right);
    public static override VolumeConcentration op_Multiply(VolumeConcentration left, double right);
    public static override VolumeConcentration op_Division(VolumeConcentration left, double right);
    public static double op_Division(VolumeConcentration left, VolumeConcentration right);
    public static override MassConcentration op_Multiply(VolumeConcentration volumeConcentration, Density density);
    public static override Molarity op_Multiply(VolumeConcentration volumeConcentration, Molarity molarity);
    public static override bool op_LessThanOrEqual(VolumeConcentration left, VolumeConcentration right);
    public static override bool op_GreaterThanOrEqual(VolumeConcentration left, VolumeConcentration right);
    public static override bool op_LessThan(VolumeConcentration left, VolumeConcentration right);
    public static override bool op_GreaterThan(VolumeConcentration left, VolumeConcentration right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(VolumeConcentration other, VolumeConcentration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(VolumeConcentration left, VolumeConcentration right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(VolumeConcentration other, VolumeConcentration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(VolumeConcentration left, VolumeConcentration right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(VolumeConcentration other, VolumeConcentration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(VolumeConcentration other, VolumeConcentration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(VolumeConcentration other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(VolumeConcentration other);
    [ObsoleteAttribute("Use Equals(VolumeConcentration other, VolumeConcentration tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(VolumeConcentration other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(VolumeConcentration other, VolumeConcentration tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(VolumeConcentrationUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public VolumeConcentration ToUnit(VolumeConcentrationUnit unit);
    public VolumeConcentration ToUnit(VolumeConcentrationUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(VolumeConcentrationUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public VolumeConcentration ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<VolumeConcentrationUnit> UnitsNet.IQuantity<UnitsNet.Units.VolumeConcentrationUnit>.ToUnit(VolumeConcentrationUnit unit);
    private sealed virtual override IQuantity`1<VolumeConcentrationUnit> UnitsNet.IQuantity<UnitsNet.Units.VolumeConcentrationUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.VolumeFlow : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<VolumeFlowUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<VolumeFlowUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumeFlowUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumeFlowUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumeFlow <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<VolumeFlowUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static VolumeFlowUnit BaseUnit { get; }
    public static VolumeFlowUnit[] Units { get; }
    public static VolumeFlow Zero { get; }
    public static VolumeFlow AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public VolumeFlowUnit Unit { get; }
    public QuantityInfo`1<VolumeFlowUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double AcreFeetPerDay { get; }
    public double AcreFeetPerHour { get; }
    public double AcreFeetPerMinute { get; }
    public double AcreFeetPerSecond { get; }
    public double CentilitersPerDay { get; }
    public double CentilitersPerHour { get; }
    public double CentilitersPerMinute { get; }
    public double CentilitersPerSecond { get; }
    public double CubicCentimetersPerMinute { get; }
    public double CubicDecimetersPerMinute { get; }
    public double CubicFeetPerHour { get; }
    public double CubicFeetPerMinute { get; }
    public double CubicFeetPerSecond { get; }
    public double CubicMetersPerDay { get; }
    public double CubicMetersPerHour { get; }
    public double CubicMetersPerMinute { get; }
    public double CubicMetersPerSecond { get; }
    public double CubicMillimetersPerSecond { get; }
    public double CubicYardsPerDay { get; }
    public double CubicYardsPerHour { get; }
    public double CubicYardsPerMinute { get; }
    public double CubicYardsPerSecond { get; }
    public double DecalitersPerDay { get; }
    public double DecalitersPerHour { get; }
    public double DecalitersPerMinute { get; }
    public double DecalitersPerSecond { get; }
    public double DecilitersPerDay { get; }
    public double DecilitersPerHour { get; }
    public double DecilitersPerMinute { get; }
    public double DecilitersPerSecond { get; }
    public double HectolitersPerDay { get; }
    public double HectolitersPerHour { get; }
    public double HectolitersPerMinute { get; }
    public double HectolitersPerSecond { get; }
    public double KilolitersPerDay { get; }
    public double KilolitersPerHour { get; }
    public double KilolitersPerMinute { get; }
    public double KilolitersPerSecond { get; }
    public double KilousGallonsPerMinute { get; }
    public double LitersPerDay { get; }
    public double LitersPerHour { get; }
    public double LitersPerMinute { get; }
    public double LitersPerSecond { get; }
    public double MegalitersPerDay { get; }
    public double MegalitersPerHour { get; }
    public double MegalitersPerMinute { get; }
    public double MegalitersPerSecond { get; }
    public double MegaukGallonsPerDay { get; }
    public double MegaukGallonsPerSecond { get; }
    public double MegausGallonsPerDay { get; }
    public double MicrolitersPerDay { get; }
    public double MicrolitersPerHour { get; }
    public double MicrolitersPerMinute { get; }
    public double MicrolitersPerSecond { get; }
    public double MillilitersPerDay { get; }
    public double MillilitersPerHour { get; }
    public double MillilitersPerMinute { get; }
    public double MillilitersPerSecond { get; }
    public double MillionUsGallonsPerDay { get; }
    public double NanolitersPerDay { get; }
    public double NanolitersPerHour { get; }
    public double NanolitersPerMinute { get; }
    public double NanolitersPerSecond { get; }
    public double OilBarrelsPerDay { get; }
    public double OilBarrelsPerHour { get; }
    public double OilBarrelsPerMinute { get; }
    public double OilBarrelsPerSecond { get; }
    public double UkGallonsPerDay { get; }
    public double UkGallonsPerHour { get; }
    public double UkGallonsPerMinute { get; }
    public double UkGallonsPerSecond { get; }
    public double UsGallonsPerDay { get; }
    public double UsGallonsPerHour { get; }
    public double UsGallonsPerMinute { get; }
    public double UsGallonsPerSecond { get; }
    private static VolumeFlow();
    public VolumeFlow(double value, VolumeFlowUnit unit);
    public VolumeFlow(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<VolumeFlowUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static VolumeFlowUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static VolumeFlowUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override VolumeFlow get_Zero();
    public static override VolumeFlow get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual VolumeFlowUnit get_Unit();
    public sealed virtual QuantityInfo`1<VolumeFlowUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_AcreFeetPerDay();
    public double get_AcreFeetPerHour();
    public double get_AcreFeetPerMinute();
    public double get_AcreFeetPerSecond();
    public double get_CentilitersPerDay();
    public double get_CentilitersPerHour();
    public double get_CentilitersPerMinute();
    public double get_CentilitersPerSecond();
    public double get_CubicCentimetersPerMinute();
    public double get_CubicDecimetersPerMinute();
    public double get_CubicFeetPerHour();
    public double get_CubicFeetPerMinute();
    public double get_CubicFeetPerSecond();
    public double get_CubicMetersPerDay();
    public double get_CubicMetersPerHour();
    public double get_CubicMetersPerMinute();
    public double get_CubicMetersPerSecond();
    public double get_CubicMillimetersPerSecond();
    public double get_CubicYardsPerDay();
    public double get_CubicYardsPerHour();
    public double get_CubicYardsPerMinute();
    public double get_CubicYardsPerSecond();
    public double get_DecalitersPerDay();
    public double get_DecalitersPerHour();
    public double get_DecalitersPerMinute();
    public double get_DecalitersPerSecond();
    public double get_DecilitersPerDay();
    public double get_DecilitersPerHour();
    public double get_DecilitersPerMinute();
    public double get_DecilitersPerSecond();
    public double get_HectolitersPerDay();
    public double get_HectolitersPerHour();
    public double get_HectolitersPerMinute();
    public double get_HectolitersPerSecond();
    public double get_KilolitersPerDay();
    public double get_KilolitersPerHour();
    public double get_KilolitersPerMinute();
    public double get_KilolitersPerSecond();
    public double get_KilousGallonsPerMinute();
    public double get_LitersPerDay();
    public double get_LitersPerHour();
    public double get_LitersPerMinute();
    public double get_LitersPerSecond();
    public double get_MegalitersPerDay();
    public double get_MegalitersPerHour();
    public double get_MegalitersPerMinute();
    public double get_MegalitersPerSecond();
    public double get_MegaukGallonsPerDay();
    public double get_MegaukGallonsPerSecond();
    public double get_MegausGallonsPerDay();
    public double get_MicrolitersPerDay();
    public double get_MicrolitersPerHour();
    public double get_MicrolitersPerMinute();
    public double get_MicrolitersPerSecond();
    public double get_MillilitersPerDay();
    public double get_MillilitersPerHour();
    public double get_MillilitersPerMinute();
    public double get_MillilitersPerSecond();
    public double get_MillionUsGallonsPerDay();
    public double get_NanolitersPerDay();
    public double get_NanolitersPerHour();
    public double get_NanolitersPerMinute();
    public double get_NanolitersPerSecond();
    public double get_OilBarrelsPerDay();
    public double get_OilBarrelsPerHour();
    public double get_OilBarrelsPerMinute();
    public double get_OilBarrelsPerSecond();
    public double get_UkGallonsPerDay();
    public double get_UkGallonsPerHour();
    public double get_UkGallonsPerMinute();
    public double get_UkGallonsPerSecond();
    public double get_UsGallonsPerDay();
    public double get_UsGallonsPerHour();
    public double get_UsGallonsPerMinute();
    public double get_UsGallonsPerSecond();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(VolumeFlowUnit unit);
    public static string GetAbbreviation(VolumeFlowUnit unit, IFormatProvider provider);
    public static VolumeFlow FromAcreFeetPerDay(double value);
    public static VolumeFlow FromAcreFeetPerHour(double value);
    public static VolumeFlow FromAcreFeetPerMinute(double value);
    public static VolumeFlow FromAcreFeetPerSecond(double value);
    public static VolumeFlow FromCentilitersPerDay(double value);
    public static VolumeFlow FromCentilitersPerHour(double value);
    public static VolumeFlow FromCentilitersPerMinute(double value);
    public static VolumeFlow FromCentilitersPerSecond(double value);
    public static VolumeFlow FromCubicCentimetersPerMinute(double value);
    public static VolumeFlow FromCubicDecimetersPerMinute(double value);
    public static VolumeFlow FromCubicFeetPerHour(double value);
    public static VolumeFlow FromCubicFeetPerMinute(double value);
    public static VolumeFlow FromCubicFeetPerSecond(double value);
    public static VolumeFlow FromCubicMetersPerDay(double value);
    public static VolumeFlow FromCubicMetersPerHour(double value);
    public static VolumeFlow FromCubicMetersPerMinute(double value);
    public static VolumeFlow FromCubicMetersPerSecond(double value);
    public static VolumeFlow FromCubicMillimetersPerSecond(double value);
    public static VolumeFlow FromCubicYardsPerDay(double value);
    public static VolumeFlow FromCubicYardsPerHour(double value);
    public static VolumeFlow FromCubicYardsPerMinute(double value);
    public static VolumeFlow FromCubicYardsPerSecond(double value);
    public static VolumeFlow FromDecalitersPerDay(double value);
    public static VolumeFlow FromDecalitersPerHour(double value);
    public static VolumeFlow FromDecalitersPerMinute(double value);
    public static VolumeFlow FromDecalitersPerSecond(double value);
    public static VolumeFlow FromDecilitersPerDay(double value);
    public static VolumeFlow FromDecilitersPerHour(double value);
    public static VolumeFlow FromDecilitersPerMinute(double value);
    public static VolumeFlow FromDecilitersPerSecond(double value);
    public static VolumeFlow FromHectolitersPerDay(double value);
    public static VolumeFlow FromHectolitersPerHour(double value);
    public static VolumeFlow FromHectolitersPerMinute(double value);
    public static VolumeFlow FromHectolitersPerSecond(double value);
    public static VolumeFlow FromKilolitersPerDay(double value);
    public static VolumeFlow FromKilolitersPerHour(double value);
    public static VolumeFlow FromKilolitersPerMinute(double value);
    public static VolumeFlow FromKilolitersPerSecond(double value);
    public static VolumeFlow FromKilousGallonsPerMinute(double value);
    public static VolumeFlow FromLitersPerDay(double value);
    public static VolumeFlow FromLitersPerHour(double value);
    public static VolumeFlow FromLitersPerMinute(double value);
    public static VolumeFlow FromLitersPerSecond(double value);
    public static VolumeFlow FromMegalitersPerDay(double value);
    public static VolumeFlow FromMegalitersPerHour(double value);
    public static VolumeFlow FromMegalitersPerMinute(double value);
    public static VolumeFlow FromMegalitersPerSecond(double value);
    public static VolumeFlow FromMegaukGallonsPerDay(double value);
    public static VolumeFlow FromMegaukGallonsPerSecond(double value);
    public static VolumeFlow FromMegausGallonsPerDay(double value);
    public static VolumeFlow FromMicrolitersPerDay(double value);
    public static VolumeFlow FromMicrolitersPerHour(double value);
    public static VolumeFlow FromMicrolitersPerMinute(double value);
    public static VolumeFlow FromMicrolitersPerSecond(double value);
    public static VolumeFlow FromMillilitersPerDay(double value);
    public static VolumeFlow FromMillilitersPerHour(double value);
    public static VolumeFlow FromMillilitersPerMinute(double value);
    public static VolumeFlow FromMillilitersPerSecond(double value);
    public static VolumeFlow FromMillionUsGallonsPerDay(double value);
    public static VolumeFlow FromNanolitersPerDay(double value);
    public static VolumeFlow FromNanolitersPerHour(double value);
    public static VolumeFlow FromNanolitersPerMinute(double value);
    public static VolumeFlow FromNanolitersPerSecond(double value);
    public static VolumeFlow FromOilBarrelsPerDay(double value);
    public static VolumeFlow FromOilBarrelsPerHour(double value);
    public static VolumeFlow FromOilBarrelsPerMinute(double value);
    public static VolumeFlow FromOilBarrelsPerSecond(double value);
    public static VolumeFlow FromUkGallonsPerDay(double value);
    public static VolumeFlow FromUkGallonsPerHour(double value);
    public static VolumeFlow FromUkGallonsPerMinute(double value);
    public static VolumeFlow FromUkGallonsPerSecond(double value);
    public static VolumeFlow FromUsGallonsPerDay(double value);
    public static VolumeFlow FromUsGallonsPerHour(double value);
    public static VolumeFlow FromUsGallonsPerMinute(double value);
    public static VolumeFlow FromUsGallonsPerSecond(double value);
    public static VolumeFlow From(double value, VolumeFlowUnit fromUnit);
    public static VolumeFlow Parse(string str);
    public static override VolumeFlow Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, VolumeFlow& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, VolumeFlow& result);
    public static VolumeFlowUnit ParseUnit(string str);
    public static VolumeFlowUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, VolumeFlowUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, VolumeFlowUnit& unit);
    public static override VolumeFlow op_UnaryNegation(VolumeFlow right);
    public static override VolumeFlow op_Addition(VolumeFlow left, VolumeFlow right);
    public static override VolumeFlow op_Subtraction(VolumeFlow left, VolumeFlow right);
    public static VolumeFlow op_Multiply(double left, VolumeFlow right);
    public static override VolumeFlow op_Multiply(VolumeFlow left, double right);
    public static override VolumeFlow op_Division(VolumeFlow left, double right);
    public static double op_Division(VolumeFlow left, VolumeFlow right);
    public static override Area op_Division(VolumeFlow volumeFlow, Speed speed);
    public static override MassFlow op_Multiply(VolumeFlow volumeFlow, Density density);
    public static override MolarFlow op_Multiply(VolumeFlow volumeFlow, Molarity molarity);
    public static override Speed op_Division(VolumeFlow volumeFlow, Area area);
    public static override Volume op_Multiply(VolumeFlow volumeFlow, Duration duration);
    public static override bool op_LessThanOrEqual(VolumeFlow left, VolumeFlow right);
    public static override bool op_GreaterThanOrEqual(VolumeFlow left, VolumeFlow right);
    public static override bool op_LessThan(VolumeFlow left, VolumeFlow right);
    public static override bool op_GreaterThan(VolumeFlow left, VolumeFlow right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(VolumeFlow other, VolumeFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(VolumeFlow left, VolumeFlow right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(VolumeFlow other, VolumeFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(VolumeFlow left, VolumeFlow right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(VolumeFlow other, VolumeFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(VolumeFlow other, VolumeFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(VolumeFlow other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(VolumeFlow other);
    [ObsoleteAttribute("Use Equals(VolumeFlow other, VolumeFlow tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(VolumeFlow other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(VolumeFlow other, VolumeFlow tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(VolumeFlowUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public VolumeFlow ToUnit(VolumeFlowUnit unit);
    public VolumeFlow ToUnit(VolumeFlowUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(VolumeFlowUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public VolumeFlow ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<VolumeFlowUnit> UnitsNet.IQuantity<UnitsNet.Units.VolumeFlowUnit>.ToUnit(VolumeFlowUnit unit);
    private sealed virtual override IQuantity`1<VolumeFlowUnit> UnitsNet.IQuantity<UnitsNet.Units.VolumeFlowUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.VolumeFlowPerArea : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<VolumeFlowPerAreaUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<VolumeFlowPerAreaUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumeFlowPerAreaUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumeFlowPerAreaUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumeFlowPerArea <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<VolumeFlowPerAreaUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static VolumeFlowPerAreaUnit BaseUnit { get; }
    public static VolumeFlowPerAreaUnit[] Units { get; }
    public static VolumeFlowPerArea Zero { get; }
    public static VolumeFlowPerArea AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public VolumeFlowPerAreaUnit Unit { get; }
    public QuantityInfo`1<VolumeFlowPerAreaUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CubicFeetPerMinutePerSquareFoot { get; }
    public double CubicMetersPerSecondPerSquareMeter { get; }
    private static VolumeFlowPerArea();
    public VolumeFlowPerArea(double value, VolumeFlowPerAreaUnit unit);
    public VolumeFlowPerArea(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<VolumeFlowPerAreaUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static VolumeFlowPerAreaUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static VolumeFlowPerAreaUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override VolumeFlowPerArea get_Zero();
    public static override VolumeFlowPerArea get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual VolumeFlowPerAreaUnit get_Unit();
    public sealed virtual QuantityInfo`1<VolumeFlowPerAreaUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CubicFeetPerMinutePerSquareFoot();
    public double get_CubicMetersPerSecondPerSquareMeter();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(VolumeFlowPerAreaUnit unit);
    public static string GetAbbreviation(VolumeFlowPerAreaUnit unit, IFormatProvider provider);
    public static VolumeFlowPerArea FromCubicFeetPerMinutePerSquareFoot(double value);
    public static VolumeFlowPerArea FromCubicMetersPerSecondPerSquareMeter(double value);
    public static VolumeFlowPerArea From(double value, VolumeFlowPerAreaUnit fromUnit);
    public static VolumeFlowPerArea Parse(string str);
    public static override VolumeFlowPerArea Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, VolumeFlowPerArea& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, VolumeFlowPerArea& result);
    public static VolumeFlowPerAreaUnit ParseUnit(string str);
    public static VolumeFlowPerAreaUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, VolumeFlowPerAreaUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, VolumeFlowPerAreaUnit& unit);
    public static override VolumeFlowPerArea op_UnaryNegation(VolumeFlowPerArea right);
    public static override VolumeFlowPerArea op_Addition(VolumeFlowPerArea left, VolumeFlowPerArea right);
    public static override VolumeFlowPerArea op_Subtraction(VolumeFlowPerArea left, VolumeFlowPerArea right);
    public static VolumeFlowPerArea op_Multiply(double left, VolumeFlowPerArea right);
    public static override VolumeFlowPerArea op_Multiply(VolumeFlowPerArea left, double right);
    public static override VolumeFlowPerArea op_Division(VolumeFlowPerArea left, double right);
    public static double op_Division(VolumeFlowPerArea left, VolumeFlowPerArea right);
    public static override bool op_LessThanOrEqual(VolumeFlowPerArea left, VolumeFlowPerArea right);
    public static override bool op_GreaterThanOrEqual(VolumeFlowPerArea left, VolumeFlowPerArea right);
    public static override bool op_LessThan(VolumeFlowPerArea left, VolumeFlowPerArea right);
    public static override bool op_GreaterThan(VolumeFlowPerArea left, VolumeFlowPerArea right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(VolumeFlowPerArea other, VolumeFlowPerArea tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(VolumeFlowPerArea left, VolumeFlowPerArea right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(VolumeFlowPerArea other, VolumeFlowPerArea tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(VolumeFlowPerArea left, VolumeFlowPerArea right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(VolumeFlowPerArea other, VolumeFlowPerArea tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(VolumeFlowPerArea other, VolumeFlowPerArea tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(VolumeFlowPerArea other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(VolumeFlowPerArea other);
    [ObsoleteAttribute("Use Equals(VolumeFlowPerArea other, VolumeFlowPerArea tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(VolumeFlowPerArea other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(VolumeFlowPerArea other, VolumeFlowPerArea tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(VolumeFlowPerAreaUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public VolumeFlowPerArea ToUnit(VolumeFlowPerAreaUnit unit);
    public VolumeFlowPerArea ToUnit(VolumeFlowPerAreaUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(VolumeFlowPerAreaUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public VolumeFlowPerArea ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<VolumeFlowPerAreaUnit> UnitsNet.IQuantity<UnitsNet.Units.VolumeFlowPerAreaUnit>.ToUnit(VolumeFlowPerAreaUnit unit);
    private sealed virtual override IQuantity`1<VolumeFlowPerAreaUnit> UnitsNet.IQuantity<UnitsNet.Units.VolumeFlowPerAreaUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.VolumePerLength : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<VolumePerLengthUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<VolumePerLengthUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumePerLengthUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumePerLengthUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumePerLength <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<VolumePerLengthUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static VolumePerLengthUnit BaseUnit { get; }
    public static VolumePerLengthUnit[] Units { get; }
    public static VolumePerLength Zero { get; }
    public static VolumePerLength AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public VolumePerLengthUnit Unit { get; }
    public QuantityInfo`1<VolumePerLengthUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CubicMetersPerMeter { get; }
    public double CubicYardsPerFoot { get; }
    public double CubicYardsPerUsSurveyFoot { get; }
    public double ImperialGallonsPerMile { get; }
    public double LitersPerKilometer { get; }
    public double LitersPerMeter { get; }
    public double LitersPerMillimeter { get; }
    public double OilBarrelsPerFoot { get; }
    public double UsGallonsPerMile { get; }
    private static VolumePerLength();
    public VolumePerLength(double value, VolumePerLengthUnit unit);
    public VolumePerLength(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<VolumePerLengthUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static VolumePerLengthUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static VolumePerLengthUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override VolumePerLength get_Zero();
    public static override VolumePerLength get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual VolumePerLengthUnit get_Unit();
    public sealed virtual QuantityInfo`1<VolumePerLengthUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CubicMetersPerMeter();
    public double get_CubicYardsPerFoot();
    public double get_CubicYardsPerUsSurveyFoot();
    public double get_ImperialGallonsPerMile();
    public double get_LitersPerKilometer();
    public double get_LitersPerMeter();
    public double get_LitersPerMillimeter();
    public double get_OilBarrelsPerFoot();
    public double get_UsGallonsPerMile();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(VolumePerLengthUnit unit);
    public static string GetAbbreviation(VolumePerLengthUnit unit, IFormatProvider provider);
    public static VolumePerLength FromCubicMetersPerMeter(double value);
    public static VolumePerLength FromCubicYardsPerFoot(double value);
    public static VolumePerLength FromCubicYardsPerUsSurveyFoot(double value);
    public static VolumePerLength FromImperialGallonsPerMile(double value);
    public static VolumePerLength FromLitersPerKilometer(double value);
    public static VolumePerLength FromLitersPerMeter(double value);
    public static VolumePerLength FromLitersPerMillimeter(double value);
    public static VolumePerLength FromOilBarrelsPerFoot(double value);
    public static VolumePerLength FromUsGallonsPerMile(double value);
    public static VolumePerLength From(double value, VolumePerLengthUnit fromUnit);
    public static VolumePerLength Parse(string str);
    public static override VolumePerLength Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, VolumePerLength& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, VolumePerLength& result);
    public static VolumePerLengthUnit ParseUnit(string str);
    public static VolumePerLengthUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, VolumePerLengthUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, VolumePerLengthUnit& unit);
    public static override VolumePerLength op_UnaryNegation(VolumePerLength right);
    public static override VolumePerLength op_Addition(VolumePerLength left, VolumePerLength right);
    public static override VolumePerLength op_Subtraction(VolumePerLength left, VolumePerLength right);
    public static VolumePerLength op_Multiply(double left, VolumePerLength right);
    public static override VolumePerLength op_Multiply(VolumePerLength left, double right);
    public static override VolumePerLength op_Division(VolumePerLength left, double right);
    public static double op_Division(VolumePerLength left, VolumePerLength right);
    public static override bool op_LessThanOrEqual(VolumePerLength left, VolumePerLength right);
    public static override bool op_GreaterThanOrEqual(VolumePerLength left, VolumePerLength right);
    public static override bool op_LessThan(VolumePerLength left, VolumePerLength right);
    public static override bool op_GreaterThan(VolumePerLength left, VolumePerLength right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(VolumePerLength other, VolumePerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(VolumePerLength left, VolumePerLength right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(VolumePerLength other, VolumePerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(VolumePerLength left, VolumePerLength right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(VolumePerLength other, VolumePerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(VolumePerLength other, VolumePerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(VolumePerLength other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(VolumePerLength other);
    [ObsoleteAttribute("Use Equals(VolumePerLength other, VolumePerLength tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(VolumePerLength other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(VolumePerLength other, VolumePerLength tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(VolumePerLengthUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public VolumePerLength ToUnit(VolumePerLengthUnit unit);
    public VolumePerLength ToUnit(VolumePerLengthUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(VolumePerLengthUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public VolumePerLength ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<VolumePerLengthUnit> UnitsNet.IQuantity<UnitsNet.Units.VolumePerLengthUnit>.ToUnit(VolumePerLengthUnit unit);
    private sealed virtual override IQuantity`1<VolumePerLengthUnit> UnitsNet.IQuantity<UnitsNet.Units.VolumePerLengthUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.VolumetricHeatCapacity : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<VolumetricHeatCapacityUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<VolumetricHeatCapacityUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumetricHeatCapacityUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumetricHeatCapacityUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static VolumetricHeatCapacity <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<VolumetricHeatCapacityUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static VolumetricHeatCapacityUnit BaseUnit { get; }
    public static VolumetricHeatCapacityUnit[] Units { get; }
    public static VolumetricHeatCapacity Zero { get; }
    public static VolumetricHeatCapacity AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public VolumetricHeatCapacityUnit Unit { get; }
    public QuantityInfo`1<VolumetricHeatCapacityUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double BtusPerCubicFootDegreeFahrenheit { get; }
    public double CaloriesPerCubicCentimeterDegreeCelsius { get; }
    public double JoulesPerCubicMeterDegreeCelsius { get; }
    public double JoulesPerCubicMeterKelvin { get; }
    public double KilocaloriesPerCubicCentimeterDegreeCelsius { get; }
    public double KilojoulesPerCubicMeterDegreeCelsius { get; }
    public double KilojoulesPerCubicMeterKelvin { get; }
    public double MegajoulesPerCubicMeterDegreeCelsius { get; }
    public double MegajoulesPerCubicMeterKelvin { get; }
    private static VolumetricHeatCapacity();
    public VolumetricHeatCapacity(double value, VolumetricHeatCapacityUnit unit);
    public VolumetricHeatCapacity(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<VolumetricHeatCapacityUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static VolumetricHeatCapacityUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static VolumetricHeatCapacityUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override VolumetricHeatCapacity get_Zero();
    public static override VolumetricHeatCapacity get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual VolumetricHeatCapacityUnit get_Unit();
    public sealed virtual QuantityInfo`1<VolumetricHeatCapacityUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_BtusPerCubicFootDegreeFahrenheit();
    public double get_CaloriesPerCubicCentimeterDegreeCelsius();
    public double get_JoulesPerCubicMeterDegreeCelsius();
    public double get_JoulesPerCubicMeterKelvin();
    public double get_KilocaloriesPerCubicCentimeterDegreeCelsius();
    public double get_KilojoulesPerCubicMeterDegreeCelsius();
    public double get_KilojoulesPerCubicMeterKelvin();
    public double get_MegajoulesPerCubicMeterDegreeCelsius();
    public double get_MegajoulesPerCubicMeterKelvin();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(VolumetricHeatCapacityUnit unit);
    public static string GetAbbreviation(VolumetricHeatCapacityUnit unit, IFormatProvider provider);
    public static VolumetricHeatCapacity FromBtusPerCubicFootDegreeFahrenheit(double value);
    public static VolumetricHeatCapacity FromCaloriesPerCubicCentimeterDegreeCelsius(double value);
    public static VolumetricHeatCapacity FromJoulesPerCubicMeterDegreeCelsius(double value);
    public static VolumetricHeatCapacity FromJoulesPerCubicMeterKelvin(double value);
    public static VolumetricHeatCapacity FromKilocaloriesPerCubicCentimeterDegreeCelsius(double value);
    public static VolumetricHeatCapacity FromKilojoulesPerCubicMeterDegreeCelsius(double value);
    public static VolumetricHeatCapacity FromKilojoulesPerCubicMeterKelvin(double value);
    public static VolumetricHeatCapacity FromMegajoulesPerCubicMeterDegreeCelsius(double value);
    public static VolumetricHeatCapacity FromMegajoulesPerCubicMeterKelvin(double value);
    public static VolumetricHeatCapacity From(double value, VolumetricHeatCapacityUnit fromUnit);
    public static VolumetricHeatCapacity Parse(string str);
    public static override VolumetricHeatCapacity Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, VolumetricHeatCapacity& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, VolumetricHeatCapacity& result);
    public static VolumetricHeatCapacityUnit ParseUnit(string str);
    public static VolumetricHeatCapacityUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, VolumetricHeatCapacityUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, VolumetricHeatCapacityUnit& unit);
    public static override VolumetricHeatCapacity op_UnaryNegation(VolumetricHeatCapacity right);
    public static override VolumetricHeatCapacity op_Addition(VolumetricHeatCapacity left, VolumetricHeatCapacity right);
    public static override VolumetricHeatCapacity op_Subtraction(VolumetricHeatCapacity left, VolumetricHeatCapacity right);
    public static VolumetricHeatCapacity op_Multiply(double left, VolumetricHeatCapacity right);
    public static override VolumetricHeatCapacity op_Multiply(VolumetricHeatCapacity left, double right);
    public static override VolumetricHeatCapacity op_Division(VolumetricHeatCapacity left, double right);
    public static double op_Division(VolumetricHeatCapacity left, VolumetricHeatCapacity right);
    public static override bool op_LessThanOrEqual(VolumetricHeatCapacity left, VolumetricHeatCapacity right);
    public static override bool op_GreaterThanOrEqual(VolumetricHeatCapacity left, VolumetricHeatCapacity right);
    public static override bool op_LessThan(VolumetricHeatCapacity left, VolumetricHeatCapacity right);
    public static override bool op_GreaterThan(VolumetricHeatCapacity left, VolumetricHeatCapacity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(VolumetricHeatCapacity other, VolumetricHeatCapacity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(VolumetricHeatCapacity left, VolumetricHeatCapacity right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(VolumetricHeatCapacity other, VolumetricHeatCapacity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(VolumetricHeatCapacity left, VolumetricHeatCapacity right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(VolumetricHeatCapacity other, VolumetricHeatCapacity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(VolumetricHeatCapacity other, VolumetricHeatCapacity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(VolumetricHeatCapacity other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(VolumetricHeatCapacity other);
    [ObsoleteAttribute("Use Equals(VolumetricHeatCapacity other, VolumetricHeatCapacity tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(VolumetricHeatCapacity other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(VolumetricHeatCapacity other, VolumetricHeatCapacity tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(VolumetricHeatCapacityUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public VolumetricHeatCapacity ToUnit(VolumetricHeatCapacityUnit unit);
    public VolumetricHeatCapacity ToUnit(VolumetricHeatCapacityUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(VolumetricHeatCapacityUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public VolumetricHeatCapacity ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<VolumetricHeatCapacityUnit> UnitsNet.IQuantity<UnitsNet.Units.VolumetricHeatCapacityUnit>.ToUnit(VolumetricHeatCapacityUnit unit);
    private sealed virtual override IQuantity`1<VolumetricHeatCapacityUnit> UnitsNet.IQuantity<UnitsNet.Units.VolumetricHeatCapacityUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
[DebuggerTypeProxyAttribute("UnitsNet.QuantityDisplay")]
public class UnitsNet.WarpingMomentOfInertia : ValueType {
    [DataMemberAttribute]
private double _value;
    [DataMemberAttribute]
private Nullable`1<WarpingMomentOfInertiaUnit> _unit;
    [CompilerGeneratedAttribute]
private static UnitConverter <DefaultConversionFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private static QuantityInfo`1<WarpingMomentOfInertiaUnit> <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private static BaseDimensions <BaseDimensions>k__BackingField;
    [CompilerGeneratedAttribute]
private static WarpingMomentOfInertiaUnit <BaseUnit>k__BackingField;
    [CompilerGeneratedAttribute]
private static WarpingMomentOfInertiaUnit[] <Units>k__BackingField;
    [CompilerGeneratedAttribute]
private static WarpingMomentOfInertia <Zero>k__BackingField;
    public static UnitConverter DefaultConversionFunctions { get; }
    public static QuantityInfo`1<WarpingMomentOfInertiaUnit> Info { get; }
    public static BaseDimensions BaseDimensions { get; }
    public static WarpingMomentOfInertiaUnit BaseUnit { get; }
    public static WarpingMomentOfInertiaUnit[] Units { get; }
    public static WarpingMomentOfInertia Zero { get; }
    public static WarpingMomentOfInertia AdditiveIdentity { get; }
    public double Value { get; }
    private double UnitsNet.IQuantity.Value { get; }
    private Enum UnitsNet.IQuantity.Unit { get; }
    public WarpingMomentOfInertiaUnit Unit { get; }
    public QuantityInfo`1<WarpingMomentOfInertiaUnit> QuantityInfo { get; }
    private QuantityInfo UnitsNet.IQuantity.QuantityInfo { get; }
    public BaseDimensions Dimensions { get; }
    public double CentimetersToTheSixth { get; }
    public double DecimetersToTheSixth { get; }
    public double FeetToTheSixth { get; }
    public double InchesToTheSixth { get; }
    public double MetersToTheSixth { get; }
    public double MillimetersToTheSixth { get; }
    private static WarpingMomentOfInertia();
    public WarpingMomentOfInertia(double value, WarpingMomentOfInertiaUnit unit);
    public WarpingMomentOfInertia(double value, UnitSystem unitSystem);
    [CompilerGeneratedAttribute]
public static UnitConverter get_DefaultConversionFunctions();
    [CompilerGeneratedAttribute]
public static QuantityInfo`1<WarpingMomentOfInertiaUnit> get_Info();
    [CompilerGeneratedAttribute]
public static BaseDimensions get_BaseDimensions();
    [CompilerGeneratedAttribute]
public static WarpingMomentOfInertiaUnit get_BaseUnit();
    [CompilerGeneratedAttribute]
public static WarpingMomentOfInertiaUnit[] get_Units();
    [CompilerGeneratedAttribute]
public static override WarpingMomentOfInertia get_Zero();
    public static override WarpingMomentOfInertia get_AdditiveIdentity();
    public double get_Value();
    private sealed virtual override double UnitsNet.IQuantity.get_Value();
    private sealed virtual override Enum UnitsNet.IQuantity.get_Unit();
    public sealed virtual WarpingMomentOfInertiaUnit get_Unit();
    public sealed virtual QuantityInfo`1<WarpingMomentOfInertiaUnit> get_QuantityInfo();
    private sealed virtual override QuantityInfo UnitsNet.IQuantity.get_QuantityInfo();
    public sealed virtual BaseDimensions get_Dimensions();
    public double get_CentimetersToTheSixth();
    public double get_DecimetersToTheSixth();
    public double get_FeetToTheSixth();
    public double get_InchesToTheSixth();
    public double get_MetersToTheSixth();
    public double get_MillimetersToTheSixth();
    internal static void RegisterDefaultConversions(UnitConverter unitConverter);
    public static string GetAbbreviation(WarpingMomentOfInertiaUnit unit);
    public static string GetAbbreviation(WarpingMomentOfInertiaUnit unit, IFormatProvider provider);
    public static WarpingMomentOfInertia FromCentimetersToTheSixth(double value);
    public static WarpingMomentOfInertia FromDecimetersToTheSixth(double value);
    public static WarpingMomentOfInertia FromFeetToTheSixth(double value);
    public static WarpingMomentOfInertia FromInchesToTheSixth(double value);
    public static WarpingMomentOfInertia FromMetersToTheSixth(double value);
    public static WarpingMomentOfInertia FromMillimetersToTheSixth(double value);
    public static WarpingMomentOfInertia From(double value, WarpingMomentOfInertiaUnit fromUnit);
    public static WarpingMomentOfInertia Parse(string str);
    public static override WarpingMomentOfInertia Parse(string str, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static bool TryParse(string str, WarpingMomentOfInertia& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string str, IFormatProvider provider, WarpingMomentOfInertia& result);
    public static WarpingMomentOfInertiaUnit ParseUnit(string str);
    public static WarpingMomentOfInertiaUnit ParseUnit(string str, IFormatProvider provider);
    public static bool TryParseUnit(string str, WarpingMomentOfInertiaUnit& unit);
    public static bool TryParseUnit(string str, IFormatProvider provider, WarpingMomentOfInertiaUnit& unit);
    public static override WarpingMomentOfInertia op_UnaryNegation(WarpingMomentOfInertia right);
    public static override WarpingMomentOfInertia op_Addition(WarpingMomentOfInertia left, WarpingMomentOfInertia right);
    public static override WarpingMomentOfInertia op_Subtraction(WarpingMomentOfInertia left, WarpingMomentOfInertia right);
    public static WarpingMomentOfInertia op_Multiply(double left, WarpingMomentOfInertia right);
    public static override WarpingMomentOfInertia op_Multiply(WarpingMomentOfInertia left, double right);
    public static override WarpingMomentOfInertia op_Division(WarpingMomentOfInertia left, double right);
    public static double op_Division(WarpingMomentOfInertia left, WarpingMomentOfInertia right);
    public static override bool op_LessThanOrEqual(WarpingMomentOfInertia left, WarpingMomentOfInertia right);
    public static override bool op_GreaterThanOrEqual(WarpingMomentOfInertia left, WarpingMomentOfInertia right);
    public static override bool op_LessThan(WarpingMomentOfInertia left, WarpingMomentOfInertia right);
    public static override bool op_GreaterThan(WarpingMomentOfInertia left, WarpingMomentOfInertia right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(WarpingMomentOfInertia other, WarpingMomentOfInertia tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Equality(WarpingMomentOfInertia left, WarpingMomentOfInertia right);
    [ObsoleteAttribute("For null checks, use `x is null` syntax to not invoke overloads. For equality checks, use Equals(WarpingMomentOfInertia other, WarpingMomentOfInertia tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public static override bool op_Inequality(WarpingMomentOfInertia left, WarpingMomentOfInertia right);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Use Equals(WarpingMomentOfInertia other, WarpingMomentOfInertia tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public virtual bool Equals(object obj);
    [ObsoleteAttribute("Use Equals(WarpingMomentOfInertia other, WarpingMomentOfInertia tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public sealed virtual bool Equals(WarpingMomentOfInertia other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(WarpingMomentOfInertia other);
    [ObsoleteAttribute("Use Equals(WarpingMomentOfInertia other, WarpingMomentOfInertia tolerance) instead, to check equality across units and to specify the max tolerance for rounding errors due to floating-point arithmetic when converting between units.")]
public bool Equals(WarpingMomentOfInertia other, double tolerance, ComparisonType comparisonType);
    public sealed virtual bool Equals(IQuantity other, IQuantity tolerance);
    public sealed virtual bool Equals(WarpingMomentOfInertia other, WarpingMomentOfInertia tolerance);
    public virtual int GetHashCode();
    public sealed virtual double As(WarpingMomentOfInertiaUnit unit);
    public sealed virtual double As(UnitSystem unitSystem);
    private sealed virtual override double UnitsNet.IQuantity.As(Enum unit);
    public WarpingMomentOfInertia ToUnit(WarpingMomentOfInertiaUnit unit);
    public WarpingMomentOfInertia ToUnit(WarpingMomentOfInertiaUnit unit, UnitConverter unitConverter);
    private bool TryToUnit(WarpingMomentOfInertiaUnit unit, Nullable`1& converted);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(Enum unit);
    public WarpingMomentOfInertia ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity UnitsNet.IQuantity.ToUnit(UnitSystem unitSystem);
    private sealed virtual override IQuantity`1<WarpingMomentOfInertiaUnit> UnitsNet.IQuantity<UnitsNet.Units.WarpingMomentOfInertiaUnit>.ToUnit(WarpingMomentOfInertiaUnit unit);
    private sealed virtual override IQuantity`1<WarpingMomentOfInertiaUnit> UnitsNet.IQuantity<UnitsNet.Units.WarpingMomentOfInertiaUnit>.ToUnit(UnitSystem unitSystem);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    private sealed virtual override TypeCode System.IConvertible.GetTypeCode();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override string System.IConvertible.ToString(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type conversionType, IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    [NullableContextAttribute("2")]
private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class UnitsNet.Wrappers.ReferencePressure : ValueType {
    [CompilerGeneratedAttribute]
private Pressure <AtmosphericPressure>k__BackingField;
    private static Pressure DefaultAtmosphericPressure;
    [CompilerGeneratedAttribute]
private static PressureReference[] <References>k__BackingField;
    [CompilerGeneratedAttribute]
private PressureReference <Reference>k__BackingField;
    public static PressureReference BaseReference;
    [CompilerGeneratedAttribute]
private Pressure <Pressure>k__BackingField;
    public Pressure AtmosphericPressure { get; public set; }
    public static PressureReference[] References { get; }
    public PressureReference Reference { get; }
    public Pressure Pressure { get; }
    public Pressure Gauge { get; }
    public Pressure Absolute { get; }
    public Pressure Vacuum { get; }
    public ReferencePressure(Pressure pressure);
    public ReferencePressure(Pressure pressure, PressureReference reference);
    public ReferencePressure(Pressure pressure, PressureReference reference, Pressure atmosphericPressure);
    private static ReferencePressure();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Pressure get_AtmosphericPressure();
    [CompilerGeneratedAttribute]
public void set_AtmosphericPressure(Pressure value);
    [CompilerGeneratedAttribute]
public static PressureReference[] get_References();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public PressureReference get_Reference();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Pressure get_Pressure();
    public Pressure get_Gauge();
    public Pressure get_Absolute();
    public Pressure get_Vacuum();
    private Pressure As(PressureReference reference);
    private double AsBaseNumericType(PressureReference reference);
    private double AsBaseReference();
}
