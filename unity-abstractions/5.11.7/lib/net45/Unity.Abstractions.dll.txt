[ExtensionAttribute]
internal static class System.Reflection.IntrospectionExtensions : object {
    [ExtensionAttribute]
public static MethodInfo GetGetMethod(PropertyInfo info, bool _);
    [ExtensionAttribute]
public static MethodInfo GetSetMethod(PropertyInfo info, bool _);
}
[AttributeUsageAttribute("2432")]
public class Unity.DependencyAttribute : DependencyResolutionAttribute {
    [DebuggerBrowsableAttribute("0")]
internal static DependencyAttribute Instance;
    public DependencyAttribute(string name);
    private static DependencyAttribute();
}
public abstract class Unity.DependencyResolutionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    protected DependencyResolutionAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
internal class Unity.Exceptions.CircularDependencyException : Exception {
    public CircularDependencyException(Type type, string name);
}
public static class Unity.FactoryLifetime : object {
    [CompilerGeneratedAttribute]
private static IFactoryLifetimeManager <Transient>k__BackingField;
    public static IFactoryLifetimeManager Singleton { get; }
    public static IFactoryLifetimeManager PerContainer { get; }
    public static IFactoryLifetimeManager Hierarchical { get; }
    public static IFactoryLifetimeManager Scoped { get; }
    public static IFactoryLifetimeManager PerResolve { get; }
    public static IFactoryLifetimeManager PerThread { get; }
    public static IFactoryLifetimeManager Transient { get; }
    public static IFactoryLifetimeManager PerContainerTransient { get; }
    public static IFactoryLifetimeManager External { get; }
    private static FactoryLifetime();
    public static IFactoryLifetimeManager get_Singleton();
    public static IFactoryLifetimeManager get_PerContainer();
    public static IFactoryLifetimeManager get_Hierarchical();
    public static IFactoryLifetimeManager get_Scoped();
    public static IFactoryLifetimeManager get_PerResolve();
    public static IFactoryLifetimeManager get_PerThread();
    [CompilerGeneratedAttribute]
public static IFactoryLifetimeManager get_Transient();
    public static IFactoryLifetimeManager get_PerContainerTransient();
    public static IFactoryLifetimeManager get_External();
}
public interface Unity.IContainerRegistration {
    public Type RegisteredType { get; }
    public string Name { get; }
    public Type MappedToType { get; }
    public LifetimeManager LifetimeManager { get; }
    public abstract virtual Type get_RegisteredType();
    public abstract virtual string get_Name();
    public abstract virtual Type get_MappedToType();
    public abstract virtual LifetimeManager get_LifetimeManager();
}
public static class Unity.Inject : object {
    public static ParameterBase Array(Type elementType, Object[] elementValues);
    public static ParameterBase Array(Object[] elementValues);
    public static ParameterBase Parameter(object value);
    public static ParameterBase Parameter(Type type, object value);
    public static ParameterBase Parameter(object value);
    public static InjectionMember Field(string name, object value);
    public static InjectionMember Property(string name, object value);
}
public abstract class Unity.Injection.GenericBase : ParameterValue {
    private string _name;
    private bool _isArray;
    private string _genericParameterName;
    public string ParameterTypeName { get; }
    protected GenericBase(string genericParameterName);
    protected GenericBase(string genericParameterName, string resolutionName);
    public virtual string get_ParameterTypeName();
    public virtual bool Equals(Type type);
    public virtual ResolveDelegate`1<TContext> GetResolver(Type type);
    public virtual ResolveDelegate`1<TContext> GetResolver(ParameterInfo info);
    protected virtual ResolveDelegate`1<TContext> GetResolver(Type type, string name);
}
[DebuggerDisplayAttribute("GenericParameter: Type={ParameterTypeName}")]
public class Unity.Injection.GenericParameter : GenericBase {
    public GenericParameter(string genericParameterName);
    public GenericParameter(string genericParameterName, string name);
    public virtual string ToString();
}
[DebuggerDisplayAttribute("GenericResolvedArrayParameter: Type={ParameterTypeName}")]
public class Unity.Injection.GenericResolvedArrayParameter : GenericBase {
    private Object[] _values;
    private static MethodInfo ResolverMethod;
    public string ParameterTypeName { get; }
    public GenericResolvedArrayParameter(string genericParameterName, Object[] elementValues);
    private static GenericResolvedArrayParameter();
    public virtual string get_ParameterTypeName();
    public virtual bool Equals(Type type);
    protected virtual ResolveDelegate`1<TContext> GetResolver(Type type, string name);
    public virtual string ToString();
    public static object DoResolve(TContext& context, Object[] values);
    [CompilerGeneratedAttribute]
internal static object <DoResolve>g__ResolveValue|9_0(TContext& c, object value);
}
public class Unity.Injection.InjectionConstructor : MethodBase`1<ConstructorInfo> {
    public InjectionConstructor(Object[] arguments);
    public InjectionConstructor(ConstructorInfo info, Object[] arguments);
    protected virtual ConstructorInfo SelectMember(Type type, InjectionMember _);
    public virtual IEnumerable`1<ConstructorInfo> DeclaredMembers(Type type);
    protected virtual string ToString(bool debug);
}
[ObsoleteAttribute("InjectionFactory has been deprecated and will be removed in next release. Please use IUnityContainer.RegisterFactory(...) method instead.", "False")]
public class Unity.Injection.InjectionFactory : InjectionMember {
    private Func`4<IUnityContainer, Type, string, object> _factoryFunc;
    public InjectionFactory(Func`2<IUnityContainer, object> factoryFunc);
    public InjectionFactory(Func`4<IUnityContainer, Type, string, object> factoryFunc);
    public virtual void AddPolicies(Type registeredType, Type mappedToType, string name, TPolicySet& policies);
    protected virtual string ToString(bool debug);
    [CompilerGeneratedAttribute]
private ResolveDelegate`1<TContext> <AddPolicies>g__CreateLegacyPolicy|3_0();
    [CompilerGeneratedAttribute]
private object <AddPolicies>b__3_2(TContext& c);
    [CompilerGeneratedAttribute]
private ResolveDelegate`1<TContext> <AddPolicies>g__CreatePerResolveLegacyPolicy|3_1();
    [CompilerGeneratedAttribute]
private object <AddPolicies>b__3_3(TContext& context);
}
public class Unity.Injection.InjectionField : MemberInfoBase`1<FieldInfo> {
    protected Type MemberType { get; }
    public InjectionField(string name, ResolutionOption option);
    public InjectionField(string name, object value);
    protected virtual FieldInfo DeclaredMember(Type type, string name);
    [IteratorStateMachineAttribute("Unity.Injection.InjectionField/<DeclaredMembers>d__3")]
public virtual IEnumerable`1<FieldInfo> DeclaredMembers(Type type);
    protected virtual Type get_MemberType();
    protected virtual string ToString(bool debug);
}
[ExtensionAttribute]
public static class Unity.Injection.InjectionMatching : object {
    [ExtensionAttribute]
public static bool MatchMemberInfo(Object[] data, MethodBase info);
    [ExtensionAttribute]
public static bool Matches(object data, Type match);
    [ExtensionAttribute]
public static bool MatchesType(Type type, Type match);
    [ExtensionAttribute]
public static bool MatchesObject(object parameter, Type match);
    [ExtensionAttribute]
public static string Signature(Object[] data);
    [ExtensionAttribute]
public static string Signature(MethodBase selection);
}
public abstract class Unity.Injection.InjectionMember : object {
    public bool BuildRequired { get; }
    public virtual void AddPolicies(Type registeredType, Type mappedToType, string name, TPolicySet& policies);
    public virtual bool get_BuildRequired();
    protected virtual string ToString(bool debug);
}
[DebuggerDisplayAttribute("{ToString(true)}")]
public abstract class Unity.Injection.InjectionMember`2 : InjectionMember {
    protected static string NoMatchFound;
    [CompilerGeneratedAttribute]
private TMemberInfo <Selection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private TData <Data>k__BackingField;
    protected TMemberInfo Selection { get; protected set; }
    public string Name { get; }
    public TData Data { get; }
    public bool IsInitialized { get; }
    public bool BuildRequired { get; }
    protected InjectionMember`2(string name, TData data);
    protected InjectionMember`2(TMemberInfo info, TData data);
    [CompilerGeneratedAttribute]
protected TMemberInfo get_Selection();
    [CompilerGeneratedAttribute]
protected void set_Selection(TMemberInfo value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public virtual TData get_Data();
    public abstract virtual TMemberInfo MemberInfo(Type type);
    public abstract virtual IEnumerable`1<TMemberInfo> DeclaredMembers(Type type);
    public bool get_IsInitialized();
    public virtual bool Equals(TMemberInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual bool get_BuildRequired();
    public virtual void AddPolicies(Type registeredType, Type mappedToType, string name, TPolicySet& policies);
    public virtual string ToString();
    protected virtual TMemberInfo SelectMember(Type type, InjectionMember member);
}
public class Unity.Injection.InjectionMethod : MethodBase`1<MethodInfo> {
    public InjectionMethod(string name, Object[] arguments);
    protected virtual MethodInfo SelectMember(Type type, InjectionMember _);
    [IteratorStateMachineAttribute("Unity.Injection.InjectionMethod/<DeclaredMembers>d__2")]
public virtual IEnumerable`1<MethodInfo> DeclaredMembers(Type type);
    protected virtual string ToString(bool debug);
}
[DebuggerDisplayAttribute("InjectionParameter: Type={ParameterType.Name ?? "Any"} Value={_value ?? "null"}")]
public class Unity.Injection.InjectionParameter : ParameterBase {
    private object _value;
    public InjectionParameter(object value);
    public InjectionParameter(Type parameterType, object parameterValue);
    public sealed virtual object Resolve(TContext& context);
    public virtual string ToString();
}
public class Unity.Injection.InjectionParameter`1 : InjectionParameter {
    public InjectionParameter`1(TParameter value);
}
public class Unity.Injection.InjectionProperty : MemberInfoBase`1<PropertyInfo> {
    protected Type MemberType { get; }
    public InjectionProperty(string name, ResolutionOption option);
    public InjectionProperty(string name, object value);
    protected virtual PropertyInfo DeclaredMember(Type type, string name);
    [IteratorStateMachineAttribute("Unity.Injection.InjectionProperty/<DeclaredMembers>d__3")]
public virtual IEnumerable`1<PropertyInfo> DeclaredMembers(Type type);
    protected virtual Type get_MemberType();
    protected virtual string ToString(bool debug);
    [CompilerGeneratedAttribute]
private bool <DeclaredMember>b__2_0(PropertyInfo p);
}
public abstract class Unity.Injection.MemberInfoBase`1 : InjectionMember`2<TMemberInfo, object> {
    protected Type MemberType { get; }
    protected MemberInfoBase`1(string name, object data);
    public virtual TMemberInfo MemberInfo(Type type);
    protected virtual TMemberInfo SelectMember(Type type, InjectionMember _);
    protected abstract virtual TMemberInfo DeclaredMember(Type type, string name);
    protected abstract virtual Type get_MemberType();
    protected virtual string ToString(bool debug);
}
public abstract class Unity.Injection.MethodBase`1 : InjectionMember`2<TMemberInfo, Object[]> {
    protected MethodBase`1(string name, Object[] arguments);
    protected MethodBase`1(TMemberInfo info, Object[] arguments);
    public virtual TMemberInfo MemberInfo(Type type);
}
[DebuggerDisplayAttribute("OptionalGenericParameter: Type={ParameterTypeName}")]
public class Unity.Injection.OptionalGenericParameter : GenericBase {
    public OptionalGenericParameter(string genericParameterName);
    public OptionalGenericParameter(string genericParameterName, string name);
    protected virtual ResolveDelegate`1<TContext> GetResolver(Type type, string name);
    public virtual string ToString();
}
[DebuggerDisplayAttribute("OptionalParameter: Type={ParameterType?.Name ?? "Any"} Name={_name ?? "null"}")]
public class Unity.Injection.OptionalParameter : ParameterBase {
    private string _name;
    public OptionalParameter(Type type);
    public OptionalParameter(string name);
    public OptionalParameter(Type type, string name);
    public sealed virtual ResolveDelegate`1<TContext> GetResolver(Type type);
    public sealed virtual ResolveDelegate`1<TContext> GetResolver(ParameterInfo info);
    public virtual string ToString();
}
public class Unity.Injection.OptionalParameter`1 : OptionalParameter {
    public OptionalParameter`1(string name);
}
public abstract class Unity.Injection.ParameterBase : ParameterValue {
    private Type _type;
    public Type ParameterType { get; }
    protected ParameterBase(Type parameterType);
    public virtual Type get_ParameterType();
    public virtual bool Equals(Type type);
}
public abstract class Unity.Injection.ParameterValue : object {
    public abstract virtual bool Equals(Type type);
}
[DebuggerDisplayAttribute("ResolvedArrayParameter: Type={ParameterType.Name}")]
public class Unity.Injection.ResolvedArrayParameter : ParameterBase {
    private Object[] _values;
    private Type _elementType;
    private static MethodInfo ResolverMethod;
    public ResolvedArrayParameter(Type elementType, Object[] elementValues);
    protected ResolvedArrayParameter(Type arrayParameterType, Type elementType, Object[] elementValues);
    private static ResolvedArrayParameter();
    public sealed virtual ResolveDelegate`1<TContext> GetResolver(Type type);
    public sealed virtual ResolveDelegate`1<TContext> GetResolver(ParameterInfo info);
    public virtual string ToString();
}
public class Unity.Injection.ResolvedArrayParameter`1 : ResolvedArrayParameter {
    public ResolvedArrayParameter`1(Object[] elementValues);
}
[DebuggerDisplayAttribute("ResolvedParameter: Type={ParameterType?.Name ?? "Any"} Name={_name ?? "null"}")]
public class Unity.Injection.ResolvedParameter : ParameterBase {
    private string _name;
    public ResolvedParameter(Type parameterType);
    public ResolvedParameter(string name);
    public ResolvedParameter(Type parameterType, string name);
    public sealed virtual ResolveDelegate`1<TContext> GetResolver(Type type);
    public sealed virtual ResolveDelegate`1<TContext> GetResolver(ParameterInfo info);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private object <GetResolver>b__6_0(TContext& c);
}
public class Unity.Injection.ResolvedParameter`1 : ResolvedParameter {
    public ResolvedParameter`1(string name);
}
[AttributeUsageAttribute("32")]
public class Unity.InjectionConstructorAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class Unity.InjectionMethodAttribute : Attribute {
}
public static class Unity.InstanceLifetime : object {
    public static IInstanceLifetimeManager External { get; }
    public static IInstanceLifetimeManager Singleton { get; }
    public static IInstanceLifetimeManager PerContainer { get; }
    public static IInstanceLifetimeManager get_External();
    public static IInstanceLifetimeManager get_Singleton();
    public static IInstanceLifetimeManager get_PerContainer();
}
public static class Unity.Invoke : object {
    public static InjectionMember Ctor();
    public static InjectionMember Ctor(Object[] parameters);
    public static InjectionMember Ctor(Type[] parameters);
    public static InjectionMember Ctor(ConstructorInfo info, Object[] parameters);
    public static InjectionMember Constructor();
    public static InjectionMember Constructor(Object[] parameters);
    public static InjectionMember Constructor(Type[] parameters);
    public static InjectionMember Constructor(ConstructorInfo info, Object[] parameters);
    public static InjectionMember Method(string name, Object[] parameters);
}
[CLSCompliantAttribute("True")]
public interface Unity.IUnityContainer {
    public IEnumerable`1<IContainerRegistration> Registrations { get; }
    public IUnityContainer Parent { get; }
    public abstract virtual IUnityContainer RegisterType(Type registeredType, Type mappedToType, string name, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    public abstract virtual IUnityContainer RegisterInstance(Type type, string name, object instance, IInstanceLifetimeManager lifetimeManager);
    public abstract virtual IUnityContainer RegisterFactory(Type type, string name, Func`4<IUnityContainer, Type, string, object> factory, IFactoryLifetimeManager lifetimeManager);
    public abstract virtual bool IsRegistered(Type type, string name);
    public abstract virtual IEnumerable`1<IContainerRegistration> get_Registrations();
    public abstract virtual object Resolve(Type type, string name, ResolverOverride[] overrides);
    public abstract virtual object BuildUp(Type type, object existing, string name, ResolverOverride[] overrides);
    public abstract virtual IUnityContainer get_Parent();
    public abstract virtual IUnityContainer CreateChildContainer();
}
[CLSCompliantAttribute("True")]
public interface Unity.IUnityContainerAsync {
    public IEnumerable`1<IContainerRegistration> Registrations { get; }
    public IUnityContainerAsync Parent { get; }
    public abstract virtual Task RegisterType(IEnumerable`1<Type> interfaces, Type type, string name, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    public abstract virtual Task RegisterInstance(IEnumerable`1<Type> interfaces, string name, object instance, IInstanceLifetimeManager lifetimeManager);
    public abstract virtual Task RegisterFactory(IEnumerable`1<Type> interfaces, string name, Func`4<IUnityContainer, Type, string, object> factory, IFactoryLifetimeManager lifetimeManager);
    public abstract virtual bool IsRegistered(Type type, string name);
    public abstract virtual IEnumerable`1<IContainerRegistration> get_Registrations();
    public abstract virtual ValueTask`1<object> ResolveAsync(Type type, string name, ResolverOverride[] overrides);
    public abstract virtual ValueTask`1<IEnumerable`1<object>> Resolve(Type type, Regex regex, ResolverOverride[] overrides);
    public abstract virtual IUnityContainerAsync get_Parent();
    public abstract virtual IUnityContainerAsync CreateChildContainer();
}
public class Unity.Lifetime.ContainerControlledLifetimeManager : SynchronizedLifetimeManager {
    protected object Value;
    [CompilerGeneratedAttribute]
private object <Scope>k__BackingField;
    public object Scope { get; public set; }
    [CompilerGeneratedAttribute]
public object get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(object value);
    public virtual object GetValue(ILifetimeContainer container);
    public virtual void SetValue(object newValue, ILifetimeContainer container);
    protected virtual object SynchronizedGetValue(ILifetimeContainer container);
    protected virtual void SynchronizedSetValue(object newValue, ILifetimeContainer container);
    public virtual void RemoveValue(ILifetimeContainer container);
    protected virtual LifetimeManager OnCreateLifetimeManager();
    protected virtual void Dispose(bool disposing);
    public virtual string ToString();
}
public class Unity.Lifetime.ContainerControlledTransientManager : LifetimeManager {
    public bool InUse { get; public set; }
    public virtual void SetValue(object newValue, ILifetimeContainer container);
    protected virtual LifetimeManager OnCreateLifetimeManager();
    public virtual bool get_InUse();
    public virtual void set_InUse(bool value);
    public virtual string ToString();
}
public class Unity.Lifetime.ExternallyControlledLifetimeManager : SynchronizedLifetimeManager {
    private WeakReference _value;
    protected virtual object SynchronizedGetValue(ILifetimeContainer container);
    protected virtual void SynchronizedSetValue(object newValue, ILifetimeContainer container);
    public virtual void RemoveValue(ILifetimeContainer container);
    protected virtual LifetimeManager OnCreateLifetimeManager();
    public virtual string ToString();
}
public class Unity.Lifetime.HierarchicalLifetimeManager : SynchronizedLifetimeManager {
    private IDictionary`2<ILifetimeContainer, object> _values;
    protected virtual object SynchronizedGetValue(ILifetimeContainer container);
    protected virtual void SynchronizedSetValue(object newValue, ILifetimeContainer container);
    public virtual void RemoveValue(ILifetimeContainer container);
    protected virtual LifetimeManager OnCreateLifetimeManager();
    public virtual string ToString();
    protected virtual void Dispose(bool disposing);
}
public interface Unity.Lifetime.IFactoryLifetimeManager {
    public abstract virtual LifetimeManager CreateLifetimePolicy();
}
public interface Unity.Lifetime.IInstanceLifetimeManager {
    public abstract virtual LifetimeManager CreateLifetimePolicy();
}
public interface Unity.Lifetime.ILifetimeContainer {
    public IUnityContainer Container { get; }
    public int Count { get; }
    public abstract virtual IUnityContainer get_Container();
    public abstract virtual int get_Count();
    public abstract virtual void Add(object item);
    public abstract virtual bool Contains(object item);
    public abstract virtual void Remove(object item);
}
public interface Unity.Lifetime.ITypeLifetimeManager {
    public abstract virtual LifetimeManager CreateLifetimePolicy();
}
public abstract class Unity.Lifetime.LifetimeManager : object {
    public static object NoValue;
    [CompilerGeneratedAttribute]
private bool <InUse>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ILifetimeContainer, object> <TryGet>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<ILifetimeContainer, object> <Get>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<object, ILifetimeContainer> <Set>k__BackingField;
    internal Delegate PipelineDelegate;
    public bool InUse { get; public set; }
    public Func`2<ILifetimeContainer, object> TryGet { get; protected set; }
    public Func`2<ILifetimeContainer, object> Get { get; protected set; }
    public Action`2<object, ILifetimeContainer> Set { get; protected set; }
    private static LifetimeManager();
    [CompilerGeneratedAttribute]
public virtual bool get_InUse();
    [CompilerGeneratedAttribute]
public virtual void set_InUse(bool value);
    [CompilerGeneratedAttribute]
public virtual Func`2<ILifetimeContainer, object> get_TryGet();
    [CompilerGeneratedAttribute]
protected virtual void set_TryGet(Func`2<ILifetimeContainer, object> value);
    [CompilerGeneratedAttribute]
public virtual Func`2<ILifetimeContainer, object> get_Get();
    [CompilerGeneratedAttribute]
protected virtual void set_Get(Func`2<ILifetimeContainer, object> value);
    [CompilerGeneratedAttribute]
public virtual Action`2<object, ILifetimeContainer> get_Set();
    [CompilerGeneratedAttribute]
protected virtual void set_Set(Action`2<object, ILifetimeContainer> value);
    public virtual object TryGetValue(ILifetimeContainer container);
    public virtual object GetValue(ILifetimeContainer container);
    public virtual void SetValue(object newValue, ILifetimeContainer container);
    public virtual void RemoveValue(ILifetimeContainer container);
    public sealed virtual LifetimeManager CreateLifetimePolicy();
    protected abstract virtual LifetimeManager OnCreateLifetimeManager();
    internal virtual object Pipeline(TContext& context);
}
public class Unity.Lifetime.PerResolveLifetimeManager : LifetimeManager {
    protected object value;
    public virtual object GetValue(ILifetimeContainer container);
    protected virtual LifetimeManager OnCreateLifetimeManager();
    public virtual string ToString();
}
public class Unity.Lifetime.PerThreadLifetimeManager : LifetimeManager {
    [ThreadStaticAttribute]
private static Dictionary`2<Guid, object> _values;
    private Guid _key;
    public virtual object GetValue(ILifetimeContainer container);
    public virtual void SetValue(object newValue, ILifetimeContainer container);
    protected virtual LifetimeManager OnCreateLifetimeManager();
    public virtual string ToString();
}
public class Unity.Lifetime.SingletonLifetimeManager : ContainerControlledLifetimeManager {
    protected virtual LifetimeManager OnCreateLifetimeManager();
    public virtual string ToString();
}
public abstract class Unity.Lifetime.SynchronizedLifetimeManager : LifetimeManager {
    private object _lock;
    public static int ResolveTimeout;
    private static SynchronizedLifetimeManager();
    public virtual object TryGetValue(ILifetimeContainer container);
    public virtual object GetValue(ILifetimeContainer container);
    protected abstract virtual object SynchronizedGetValue(ILifetimeContainer container);
    public virtual void SetValue(object newValue, ILifetimeContainer container);
    protected abstract virtual void SynchronizedSetValue(object newValue, ILifetimeContainer container);
    public void Recover();
    protected virtual void TryExit();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Unity.Lifetime.TransientLifetimeManager : LifetimeManager {
    public static TransientLifetimeManager Instance;
    public bool InUse { get; public set; }
    private static TransientLifetimeManager();
    public virtual bool get_InUse();
    public virtual void set_InUse(bool value);
    protected virtual LifetimeManager OnCreateLifetimeManager();
    public virtual string ToString();
}
[AttributeUsageAttribute("2432")]
public class Unity.OptionalDependencyAttribute : DependencyResolutionAttribute {
    [DebuggerBrowsableAttribute("0")]
internal static OptionalDependencyAttribute Instance;
    public OptionalDependencyAttribute(string name);
    private static OptionalDependencyAttribute();
}
public static class Unity.Override : object {
    public static ResolverOverride Property(string name, object value);
    public static ResolverOverride Field(string name, object value);
    public static ResolverOverride Parameter(object value);
    public static ResolverOverride Parameter(string name, object value);
    public static ResolverOverride Parameter(Type type, object value);
    public static ResolverOverride Parameter(Type type, string name, object value);
    public static ResolverOverride Parameter(object value);
    public static ResolverOverride Parameter(string name, object value);
    public static ResolverOverride Dependency(object value);
    public static ResolverOverride Dependency(string name, object value);
    public static ResolverOverride Dependency(Type type, object value);
    public static ResolverOverride Dependency(Type type, string name, object value);
    public static ResolverOverride Dependency(object value);
    public static ResolverOverride Dependency(string name, object value);
}
public interface Unity.Policy.IPolicyList {
    public abstract virtual object Get(Type type, Type policyInterface);
    public abstract virtual object Get(Type type, string name, Type policyInterface);
    public abstract virtual void Set(Type type, Type policyInterface, object policy);
    public abstract virtual void Set(Type type, string name, Type policyInterface, object policy);
    public abstract virtual void Clear(Type type, string name, Type policyInterface);
}
public interface Unity.Policy.IPolicySet {
    public abstract virtual object Get(Type policyInterface);
    public abstract virtual void Set(Type policyInterface, object policy);
    public abstract virtual void Clear(Type policyInterface);
}
[ExtensionAttribute]
public static class Unity.Policy.PolicySetExtensions : object {
    [ExtensionAttribute]
public static T Get(IPolicySet policySet);
    [ExtensionAttribute]
public static void Set(IPolicySet policySet, object policy);
}
public class Unity.Resolution.DependencyOverride : ResolverOverride {
    protected object Value;
    public DependencyOverride(Type typeToConstruct, object dependencyValue);
    public DependencyOverride(string name, object dependencyValue);
    public DependencyOverride(Type type, string name, object value);
    public DependencyOverride(Type target, Type type, string name, object value);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(NamedType other);
    public sealed virtual object Resolve(TContext& context);
}
public class Unity.Resolution.DependencyOverride`1 : DependencyOverride {
    public DependencyOverride`1(object dependencyValue);
}
public class Unity.Resolution.FieldOverride : ResolverOverride {
    protected object Value;
    public FieldOverride(string fieldName, object fieldValue);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(FieldInfo other);
    public sealed virtual object Resolve(TContext& context);
}
public interface Unity.Resolution.IResolve {
    public abstract virtual object Resolve(TContext& context);
}
public interface Unity.Resolution.IResolveContext {
    public IUnityContainer Container { get; }
    public Type Type { get; }
    public string Name { get; }
    public abstract virtual IUnityContainer get_Container();
    public abstract virtual Type get_Type();
    public abstract virtual string get_Name();
    public abstract virtual object Resolve(Type type, string name);
}
public class Unity.Resolution.IResolveContextExpression`1 : object {
    public static MethodInfo ResolveMethod;
    public static ParameterExpression Context;
    public static MemberExpression Type;
    public static MemberExpression Name;
    public static MemberExpression Container;
    private static IResolveContextExpression`1();
}
public interface Unity.Resolution.IResolverFactory`1 {
    public abstract virtual ResolveDelegate`1<TContext> GetResolver(TMemberInfo info);
}
public class Unity.Resolution.NamedType : ValueType {
    public Type Type;
    public string Name;
    public virtual int GetHashCode();
    public static int GetHashCode(Type type, string name);
    public static int GetHashCode(int typeHash, int nameHash);
    public virtual bool Equals(object obj);
    public static bool op_Equality(NamedType obj1, NamedType obj2);
    public static bool op_Inequality(NamedType obj1, NamedType obj2);
    public virtual string ToString();
}
public class Unity.Resolution.ParameterOverride : ResolverOverride {
    protected object Value;
    public ParameterOverride(string parameterName, object parameterValue);
    public ParameterOverride(Type parameterType, object parameterValue);
    public ParameterOverride(Type parameterType, string parameterName, object parameterValue);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(ParameterInfo other);
    public sealed virtual object Resolve(TContext& context);
}
public class Unity.Resolution.ParameterOverrides : object {
    private IList`1<Tuple`2<string, object>> _values;
    public void Add(string key, object value);
    public ResolverOverride[] OnType();
    public ResolverOverride[] OnType(Type targetType);
    [IteratorStateMachineAttribute("Unity.Resolution.ParameterOverrides/<GetEnumerator>d__4")]
public sealed virtual IEnumerator GetEnumerator();
}
public class Unity.Resolution.PropertyOverride : ResolverOverride {
    protected object Value;
    public PropertyOverride(string propertyName, object propertyValue);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(PropertyInfo other);
    public sealed virtual object Resolve(TContext& context);
}
public class Unity.Resolution.ResolveDelegate`1 : MulticastDelegate {
    public ResolveDelegate`1(object object, IntPtr method);
    public virtual object Invoke(TContext& context);
    public virtual IAsyncResult BeginInvoke(TContext& context, AsyncCallback callback, object object);
    public virtual object EndInvoke(TContext& context, IAsyncResult result);
}
public class Unity.Resolution.ResolverFactory`1 : MulticastDelegate {
    public ResolverFactory`1(object object, IntPtr method);
    public virtual ResolveDelegate`1<TContext> Invoke(Type type);
    public virtual IAsyncResult BeginInvoke(Type type, AsyncCallback callback, object object);
    public virtual ResolveDelegate`1<TContext> EndInvoke(IAsyncResult result);
}
public abstract class Unity.Resolution.ResolverOverride : object {
    protected Type Target;
    protected Type Type;
    protected string Name;
    protected ResolverOverride(string name);
    protected ResolverOverride(Type target, Type type, string name);
    public ResolverOverride OnType();
    public ResolverOverride OnType(Type targetType);
    public virtual ResolveDelegate`1<TContext> GetResolver(Type type);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public static bool op_Equality(ResolverOverride left, ResolverOverride right);
    public static bool op_Inequality(ResolverOverride left, ResolverOverride right);
}
public class Unity.ResolutionFailedException : Exception {
    [CompilerGeneratedAttribute]
private string <TypeRequested>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NameRequested>k__BackingField;
    public string TypeRequested { get; private set; }
    public string NameRequested { get; private set; }
    public ResolutionFailedException(Type type, string name, string message, Exception innerException);
    [CompilerGeneratedAttribute]
public string get_TypeRequested();
    [CompilerGeneratedAttribute]
private void set_TypeRequested(string value);
    [CompilerGeneratedAttribute]
public string get_NameRequested();
    [CompilerGeneratedAttribute]
private void set_NameRequested(string value);
    private void RegisterSerializationHandler();
    [CompilerGeneratedAttribute]
private void <RegisterSerializationHandler>b__9_0(object s, SafeSerializationEventArgs e);
}
public enum Unity.ResolutionOption : Enum {
    public int value__;
    public static ResolutionOption Required;
    public static ResolutionOption Optional;
}
public static class Unity.Resolve : object {
    public static ParameterBase Dependency();
    public static ParameterBase Dependency(string name);
    public static ParameterBase Parameter();
    public static ParameterBase Parameter(string name);
    public static ParameterBase Parameter(Type type);
    public static ParameterBase Parameter();
    public static ParameterBase Parameter(Type type, string name);
    public static ParameterBase Parameter(string name);
    public static GenericParameter Generic(string genericParameterName);
    public static GenericParameter Generic(string genericParameterName, string registrationName);
    public static ParameterBase Optional();
    public static ParameterBase Optional(string name);
    public static ParameterBase Optional(Type type);
    public static ParameterBase Optional();
    public static ParameterBase Optional(Type type, string name);
    public static ParameterBase Optional(string name);
    public static InjectionMember Field(string name);
    public static InjectionMember OptionalField(string name);
    public static InjectionMember Property(string name);
    public static InjectionMember OptionalProperty(string name);
}
public static class Unity.TypeLifetime : object {
    public static ITypeLifetimeManager Singleton { get; }
    public static ITypeLifetimeManager ContainerControlled { get; }
    public static ITypeLifetimeManager PerContainer { get; }
    public static ITypeLifetimeManager Hierarchical { get; }
    public static ITypeLifetimeManager Scoped { get; }
    public static ITypeLifetimeManager PerResolve { get; }
    public static ITypeLifetimeManager PerThread { get; }
    public static ITypeLifetimeManager Transient { get; }
    public static ITypeLifetimeManager PerContainerTransient { get; }
    public static ITypeLifetimeManager External { get; }
    public static ITypeLifetimeManager get_Singleton();
    public static ITypeLifetimeManager get_ContainerControlled();
    public static ITypeLifetimeManager get_PerContainer();
    public static ITypeLifetimeManager get_Hierarchical();
    public static ITypeLifetimeManager get_Scoped();
    public static ITypeLifetimeManager get_PerResolve();
    public static ITypeLifetimeManager get_PerThread();
    public static ITypeLifetimeManager get_Transient();
    public static ITypeLifetimeManager get_PerContainerTransient();
    public static ITypeLifetimeManager get_External();
}
[ExtensionAttribute]
internal static class Unity.TypeReflectionExtensions : object {
    [ExtensionAttribute]
public static Type GetArrayParameterType(Type typeToReflect, Type[] genericArguments);
    [IteratorStateMachineAttribute("Unity.TypeReflectionExtensions/<GetDeclaredFields>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<FieldInfo> GetDeclaredFields(Type type);
    [IteratorStateMachineAttribute("Unity.TypeReflectionExtensions/<GetDeclaredProperties>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetDeclaredProperties(Type type);
    [IteratorStateMachineAttribute("Unity.TypeReflectionExtensions/<GetDeclaredMethods>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetDeclaredMethods(Type type);
}
[ExtensionAttribute]
public static class Unity.UnityContainerAsyncExtensions : object {
    [ExtensionAttribute]
public static Task RegisterType(IUnityContainerAsync container, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterType(IUnityContainerAsync container, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterType(IUnityContainerAsync container, string name, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterType(IUnityContainerAsync container, string name, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterType(IUnityContainerAsync container, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterType(IUnityContainerAsync container, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterType(IUnityContainerAsync container, string name, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterType(IUnityContainerAsync container, string name, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterSingleton(IUnityContainerAsync container, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterSingleton(IUnityContainerAsync container, string name, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterSingleton(IUnityContainerAsync container, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterSingleton(IUnityContainerAsync container, string name, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterType(IUnityContainerAsync container, Type t, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterType(IUnityContainerAsync container, Type t, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterType(IUnityContainerAsync container, Type t, string name, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterType(IUnityContainerAsync container, Type t, string name, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterType(IUnityContainerAsync container, IEnumerable`1<Type> from, Type to, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterType(IUnityContainerAsync container, IEnumerable`1<Type> from, Type to, string name, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterType(IUnityContainerAsync container, IEnumerable`1<Type> from, Type to, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterSingleton(IUnityContainerAsync container, Type t, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterSingleton(IUnityContainerAsync container, Type t, string name, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterSingleton(IUnityContainerAsync container, IEnumerable`1<Type> from, Type to, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterSingleton(IUnityContainerAsync container, IEnumerable`1<Type> from, Type to, string name, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static Task RegisterInstance(IUnityContainerAsync container, TInterface instance);
    [ExtensionAttribute]
public static Task RegisterInstance(IUnityContainerAsync container, TInterface instance, IInstanceLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static Task RegisterInstance(IUnityContainerAsync container, string name, TInterface instance);
    [ExtensionAttribute]
public static Task RegisterInstance(IUnityContainerAsync container, string name, TInterface instance, IInstanceLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static Task RegisterInstance(IUnityContainerAsync container, Type t, object instance);
    [ExtensionAttribute]
public static Task RegisterInstance(IUnityContainerAsync container, Type t, object instance, IInstanceLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static Task RegisterInstance(IUnityContainerAsync container, Type t, string name, object instance);
    [ExtensionAttribute]
public static Task RegisterFactory(IUnityContainerAsync container, Func`2<IUnityContainer, object> factory, IFactoryLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static Task RegisterFactory(IUnityContainerAsync container, Func`4<IUnityContainer, Type, string, object> factory, IFactoryLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static Task RegisterFactory(IUnityContainerAsync container, string name, Func`2<IUnityContainer, object> factory, IFactoryLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static Task RegisterFactory(IUnityContainerAsync container, string name, Func`4<IUnityContainer, Type, string, object> factory, IFactoryLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static IUnityContainerAsync RegisterFactory(IUnityContainerAsync container, Type type, Func`2<IUnityContainerAsync, object> factory, IFactoryLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static IUnityContainerAsync RegisterFactory(IUnityContainerAsync container, Type type, Func`4<IUnityContainerAsync, Type, string, object> factory, IFactoryLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static IUnityContainerAsync RegisterFactory(IUnityContainerAsync container, Type type, string name, Func`2<IUnityContainerAsync, object> factory, IFactoryLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static IUnityContainerAsync RegisterFactory(IUnityContainerAsync container, Type type, string name, Func`4<IUnityContainerAsync, Type, string, object> factory, IFactoryLifetimeManager lifetimeManager);
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static T ResolveAsync(IUnityContainerAsync container, ResolverOverride[] overrides);
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static T ResolveAsync(IUnityContainerAsync container, string name, ResolverOverride[] overrides);
    [ExtensionAttribute]
[SecuritySafeCriticalAttribute]
public static ValueTask`1<object> ResolveAsync(IUnityContainerAsync container, Type t, ResolverOverride[] overrides);
    [ExtensionAttribute]
public static bool IsRegistered(IUnityContainerAsync container, Type typeToCheck);
    [ExtensionAttribute]
public static bool IsRegistered(IUnityContainerAsync container);
    [ExtensionAttribute]
public static bool IsRegistered(IUnityContainerAsync container, string nameToCheck);
}
[ExtensionAttribute]
public static class Unity.UnityContainerExtensions : object {
    [ExtensionAttribute]
public static IUnityContainer RegisterType(IUnityContainer container, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterType(IUnityContainer container, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterType(IUnityContainer container, string name, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterType(IUnityContainer container, string name, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterType(IUnityContainer container, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterType(IUnityContainer container, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterType(IUnityContainer container, string name, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterType(IUnityContainer container, string name, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterSingleton(IUnityContainer container, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterSingleton(IUnityContainer container, string name, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterSingleton(IUnityContainer container, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterSingleton(IUnityContainer container, string name, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterType(IUnityContainer container, Type t, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterType(IUnityContainer container, Type t, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterType(IUnityContainer container, Type t, string name, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterType(IUnityContainer container, Type t, string name, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterType(IUnityContainer container, Type from, Type to, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterType(IUnityContainer container, Type from, Type to, string name, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterType(IUnityContainer container, Type from, Type to, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterSingleton(IUnityContainer container, Type t, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterSingleton(IUnityContainer container, Type t, string name, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterSingleton(IUnityContainer container, Type from, Type to, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterSingleton(IUnityContainer container, Type from, Type to, string name, InjectionMember[] injectionMembers);
    [ExtensionAttribute]
public static IUnityContainer RegisterInstance(IUnityContainer container, TInterface instance);
    [ExtensionAttribute]
public static IUnityContainer RegisterInstance(IUnityContainer container, TInterface instance, IInstanceLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static IUnityContainer RegisterInstance(IUnityContainer container, string name, TInterface instance);
    [ExtensionAttribute]
public static IUnityContainer RegisterInstance(IUnityContainer container, string name, TInterface instance, IInstanceLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static IUnityContainer RegisterInstance(IUnityContainer container, Type t, object instance);
    [ExtensionAttribute]
public static IUnityContainer RegisterInstance(IUnityContainer container, Type t, object instance, IInstanceLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static IUnityContainer RegisterInstance(IUnityContainer container, Type t, string name, object instance);
    [ExtensionAttribute]
public static IUnityContainer RegisterFactory(IUnityContainer container, Func`2<IUnityContainer, object> factory, IFactoryLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static IUnityContainer RegisterFactory(IUnityContainer container, Func`4<IUnityContainer, Type, string, object> factory, IFactoryLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static IUnityContainer RegisterFactory(IUnityContainer container, string name, Func`2<IUnityContainer, object> factory, IFactoryLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static IUnityContainer RegisterFactory(IUnityContainer container, string name, Func`4<IUnityContainer, Type, string, object> factory, IFactoryLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static IUnityContainer RegisterFactory(IUnityContainer container, Type type, Func`2<IUnityContainer, object> factory, IFactoryLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static IUnityContainer RegisterFactory(IUnityContainer container, Type type, Func`4<IUnityContainer, Type, string, object> factory, IFactoryLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static IUnityContainer RegisterFactory(IUnityContainer container, Type type, string name, Func`2<IUnityContainer, object> factory, IFactoryLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static IUnityContainer RegisterFactory(IUnityContainer container, Type type, string name, Func`4<IUnityContainer, Type, string, object> factory, IFactoryLifetimeManager lifetimeManager);
    [ExtensionAttribute]
public static T Resolve(IUnityContainer container, ResolverOverride[] overrides);
    [ExtensionAttribute]
public static T Resolve(IUnityContainer container, string name, ResolverOverride[] overrides);
    [ExtensionAttribute]
public static object Resolve(IUnityContainer container, Type t, ResolverOverride[] overrides);
    [ExtensionAttribute]
public static IEnumerable`1<object> ResolveAll(IUnityContainer container, Type type, ResolverOverride[] resolverOverrides);
    [ExtensionAttribute]
public static IEnumerable`1<T> ResolveAll(IUnityContainer container, ResolverOverride[] resolverOverrides);
    [ExtensionAttribute]
public static T BuildUp(IUnityContainer container, T existing, ResolverOverride[] resolverOverrides);
    [ExtensionAttribute]
public static T BuildUp(IUnityContainer container, T existing, string name, ResolverOverride[] resolverOverrides);
    [ExtensionAttribute]
public static object BuildUp(IUnityContainer container, Type t, object existing, ResolverOverride[] resolverOverrides);
    [ExtensionAttribute]
public static bool IsRegistered(IUnityContainer container, Type typeToCheck);
    [ExtensionAttribute]
public static bool IsRegistered(IUnityContainer container);
    [ExtensionAttribute]
public static bool IsRegistered(IUnityContainer container, string nameToCheck);
}
