[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[SecuritySafeCriticalAttribute]
[DebuggerDisplayAttribute("Resolving: {Type},  Name: {Name}")]
public class Unity.Builder.BuilderContext : ValueType {
    public ResolverOverride[] Overrides;
    public IPolicyList List;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RegistrationType>k__BackingField;
    [CompilerGeneratedAttribute]
private IPolicySet <Registration>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Existing>k__BackingField;
    public ILifetimeContainer Lifetime;
    public SynchronizedLifetimeManager RequiresRecovery;
    public bool BuildComplete;
    public Type DeclaringType;
    public IntPtr Parent;
    public ExecutePlanDelegate ExecutePlan;
    public ResolvePlanDelegate ResolvePlan;
    public IUnityContainer Container { get; }
    public Type Type { get; public set; }
    public string Name { get; public set; }
    public Type RegistrationType { get; public set; }
    public IPolicySet Registration { get; public set; }
    public object Existing { get; public set; }
    public sealed virtual IUnityContainer get_Container();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public sealed virtual object Resolve(Type type, string name);
    public object Get(Type policyInterface);
    public sealed virtual object Get(Type type, string name, Type policyInterface);
    public sealed virtual object Get(Type type, Type policyInterface);
    public void Set(Type policyInterface, object policy);
    public sealed virtual void Set(Type type, Type policyInterface, object policy);
    public sealed virtual void Set(Type type, string name, Type policyInterface, object policy);
    public sealed virtual void Clear(Type type, string name, Type policyInterface);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Type get_RegistrationType();
    [CompilerGeneratedAttribute]
public void set_RegistrationType(Type value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public IPolicySet get_Registration();
    [CompilerGeneratedAttribute]
public void set_Registration(IPolicySet value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public object get_Existing();
    [CompilerGeneratedAttribute]
public void set_Existing(object value);
    public object Resolve(Type type, string name, InternalRegistration registration);
    public object Resolve(ParameterInfo parameter, object value);
    public object Resolve(PropertyInfo property, object value);
    public object Resolve(FieldInfo field, object value);
}
public class Unity.Builder.BuilderContextExpression : IResolveContextExpression`1<BuilderContext> {
    public static MethodInfo ResolvePropertyMethod;
    public static MethodInfo ResolveFieldMethod;
    public static MethodInfo ResolveParameterMethod;
    public static MethodInfo SetMethod;
    public static MemberExpression Existing;
    private static BuilderContextExpression();
}
public enum Unity.Builder.BuilderStage : Enum {
    public int value__;
    public static BuilderStage PreCreation;
    public static BuilderStage Creation;
    public static BuilderStage Initialization;
    public static BuilderStage Fields;
    public static BuilderStage Properties;
    public static BuilderStage Methods;
    public static BuilderStage PostInitialization;
}
public class Unity.Builder.NamedTypeBuildKey : object {
    private int _hash;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public Type Type { get; }
    public string Name { get; }
    public NamedTypeBuildKey(Type type, string name);
    public NamedTypeBuildKey(Type type);
    public static NamedTypeBuildKey Make();
    public static NamedTypeBuildKey Make(string name);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(NamedTypeBuildKey left, NamedTypeBuildKey right);
    public static bool op_Inequality(NamedTypeBuildKey left, NamedTypeBuildKey right);
    public virtual string ToString();
}
public class Unity.Builder.NamedTypeBuildKey`1 : NamedTypeBuildKey {
    public NamedTypeBuildKey`1(string name);
}
public enum Unity.Builder.SelectionStage : Enum {
    public int value__;
    public static SelectionStage Injected;
    public static SelectionStage Custom;
    public static SelectionStage Default;
}
public enum Unity.Builder.UnityBuildStage : Enum {
    public int value__;
    public static UnityBuildStage Setup;
    public static UnityBuildStage Enumerable;
    public static UnityBuildStage Lifetime;
    public static UnityBuildStage TypeMapping;
    public static UnityBuildStage PreCreation;
    public static UnityBuildStage Creation;
    public static UnityBuildStage Initialization;
    public static UnityBuildStage PostInitialization;
}
public class Unity.DefaultLifetime : UnityContainerExtension {
    public ITypeLifetimeManager TypeDefaultLifetime { get; public set; }
    public IInstanceLifetimeManager InstanceDefaultLifetime { get; public set; }
    public IFactoryLifetimeManager FactoryDefaultLifetime { get; public set; }
    protected virtual void Initialize();
    public ITypeLifetimeManager get_TypeDefaultLifetime();
    public void set_TypeDefaultLifetime(ITypeLifetimeManager value);
    public IInstanceLifetimeManager get_InstanceDefaultLifetime();
    public void set_InstanceDefaultLifetime(IInstanceLifetimeManager value);
    public IFactoryLifetimeManager get_FactoryDefaultLifetime();
    public void set_FactoryDefaultLifetime(IFactoryLifetimeManager value);
}
public class Unity.Diagnostic : UnityContainerExtension {
    protected virtual void Initialize();
}
[ExtensionAttribute]
public static class Unity.DiagnosticExtensions : object {
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
public static void EnableDebugDiagnostic(UnityContainer container);
    [ExtensionAttribute]
public static UnityContainer EnableDiagnostic(UnityContainer container);
}
internal static class Unity.Error : object {
    public static string MissingDependency;
    public static string NoOperationExceptionReason;
    public static string NotAGenericType;
    public static string ResolutionFailed;
    public static string SelectedConstructorHasRefParameters;
    public static string SelectedConstructorHasRefItself;
    public static string TypesAreNotAssignable;
    public static string UnknownType;
}
public class Unity.Events.ChildContainerCreatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ExtensionContext <ChildContext>k__BackingField;
    public IUnityContainer ChildContainer { get; }
    public ExtensionContext ChildContext { get; }
    public ChildContainerCreatedEventArgs(ExtensionContext childContext);
    public IUnityContainer get_ChildContainer();
    [CompilerGeneratedAttribute]
public ExtensionContext get_ChildContext();
}
public abstract class Unity.Events.NamedEventArgs : EventArgs {
    private string _name;
    public string Name { get; public set; }
    protected NamedEventArgs(string name);
    public virtual string get_Name();
    public virtual void set_Name(string value);
}
public class Unity.Events.RegisterEventArgs : NamedEventArgs {
    [CompilerGeneratedAttribute]
private Type <TypeFrom>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TypeTo>k__BackingField;
    [CompilerGeneratedAttribute]
private LifetimeManager <LifetimeManager>k__BackingField;
    public Type TypeFrom { get; }
    public Type TypeTo { get; }
    public LifetimeManager LifetimeManager { get; }
    public RegisterEventArgs(Type typeFrom, Type typeTo, string name, LifetimeManager lifetimeManager);
    [CompilerGeneratedAttribute]
public Type get_TypeFrom();
    [CompilerGeneratedAttribute]
public Type get_TypeTo();
    [CompilerGeneratedAttribute]
public LifetimeManager get_LifetimeManager();
}
public class Unity.Events.RegisterInstanceEventArgs : NamedEventArgs {
    [CompilerGeneratedAttribute]
private Type <RegisteredType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private LifetimeManager <LifetimeManager>k__BackingField;
    public Type RegisteredType { get; }
    public object Instance { get; }
    public LifetimeManager LifetimeManager { get; }
    public RegisterInstanceEventArgs(Type registeredType, object instance, string name, LifetimeManager lifetimeManager);
    [CompilerGeneratedAttribute]
public Type get_RegisteredType();
    [CompilerGeneratedAttribute]
public object get_Instance();
    [CompilerGeneratedAttribute]
public LifetimeManager get_LifetimeManager();
}
public class Unity.Exceptions.DependencyMissingException : Exception {
    public DependencyMissingException(string message);
    public DependencyMissingException(string message, Exception innerException);
    public DependencyMissingException(object buildKey);
}
public class Unity.Exceptions.IllegalInjectionMethodException : Exception {
    public IllegalInjectionMethodException(string message);
    public IllegalInjectionMethodException(string message, Exception innerException);
}
internal class Unity.Exceptions.InvalidRegistrationException : Exception {
    public InvalidRegistrationException(string message, Exception exception);
}
internal class Unity.Exceptions.MakeGenericTypeFailedException : Exception {
    public MakeGenericTypeFailedException(ArgumentException innerException);
}
public abstract class Unity.Extension.ExtensionContext : object {
    public IUnityContainer Container { get; }
    public ILifetimeContainer Lifetime { get; }
    public IStagedStrategyChain`2<BuilderStrategy, UnityBuildStage> Strategies { get; }
    public IStagedStrategyChain`2<MemberProcessor, BuilderStage> BuildPlanStrategies { get; }
    public IPolicyList Policies { get; }
    public abstract virtual IUnityContainer get_Container();
    public abstract virtual ILifetimeContainer get_Lifetime();
    public abstract virtual IStagedStrategyChain`2<BuilderStrategy, UnityBuildStage> get_Strategies();
    public abstract virtual IStagedStrategyChain`2<MemberProcessor, BuilderStage> get_BuildPlanStrategies();
    public abstract virtual IPolicyList get_Policies();
    [CompilerGeneratedAttribute]
public abstract virtual void add_Registering(EventHandler`1<RegisterEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Registering(EventHandler`1<RegisterEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_RegisteringInstance(EventHandler`1<RegisterInstanceEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_RegisteringInstance(EventHandler`1<RegisterInstanceEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ChildContainerCreated(EventHandler`1<ChildContainerCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ChildContainerCreated(EventHandler`1<ChildContainerCreatedEventArgs> value);
}
public interface Unity.Extension.IUnityContainerExtensionConfigurator {
    public IUnityContainer Container { get; }
    public abstract virtual IUnityContainer get_Container();
}
public class Unity.Extension.Legacy : UnityContainerExtension {
    protected virtual void Initialize();
}
public abstract class Unity.Extension.UnityContainerExtension : object {
    private IUnityContainer _container;
    private ExtensionContext _context;
    public IUnityContainer Container { get; }
    protected ExtensionContext Context { get; }
    public void InitializeExtension(ExtensionContext context);
    public sealed virtual IUnityContainer get_Container();
    protected ExtensionContext get_Context();
    protected abstract virtual void Initialize();
    public virtual void Remove();
}
[ExtensionAttribute]
public static class Unity.ExtensionExtensions : object {
    [ExtensionAttribute]
public static IUnityContainer AddExtension(IUnityContainer container, IUnityContainerExtensionConfigurator extension);
    [ExtensionAttribute]
public static object Configure(IUnityContainer container, Type configurationInterface);
    [ExtensionAttribute]
public static IUnityContainer AddNewExtension(IUnityContainer container);
    [ExtensionAttribute]
public static TConfigurator Configure(IUnityContainer container);
}
internal class Unity.Factories.DeferredFuncResolverFactory : object {
    private static MethodInfo DeferredResolveMethodInfo;
    private static DeferredFuncResolverFactory();
    public static ResolveDelegate`1<BuilderContext> DeferredResolveDelegateFactory(BuilderContext& context);
    private static Func`1<T> DeferredResolve(BuilderContext& context);
}
public class Unity.Factories.EnumerableResolver : object {
    internal static MethodInfo EnumerableMethod;
    internal static MethodInfo EnumerableFactory;
    public static ResolveDelegateFactory Factory;
    private static EnumerableResolver();
    private static object Resolver(BuilderContext& context);
    private static ResolveDelegate`1<BuilderContext> ResolverFactory();
    internal static object DiagnosticResolver(BuilderContext& context);
    internal static ResolveDelegate`1<BuilderContext> DiagnosticResolverFactory();
}
internal class Unity.Factories.GenericLazyResolverFactory : object {
    private static MethodInfo BuildResolveLazyMethod;
    private static GenericLazyResolverFactory();
    public static ResolveDelegate`1<BuilderContext> GetResolver(BuilderContext& context);
    private static object BuildResolveLazy(BuilderContext& context);
}
public class Unity.ForceActivation : UnityContainerExtension {
    protected virtual void Initialize();
}
public class Unity.ForceCompillation : UnityContainerExtension {
    protected virtual void Initialize();
}
public abstract class Unity.Injection.Injection_ParameterValue : object {
}
public abstract class Unity.Injection.Typed_InjectionValue : Injection_ParameterValue {
}
public static class Unity.Injection.Validating : object {
    public static Func`3<Type, InjectionMember, ConstructorInfo> ConstructorSelector;
    public static Func`3<Type, InjectionMember, MethodInfo> MethodSelector;
    public static Func`3<Type, InjectionMember, FieldInfo> FieldSelector;
    public static Func`3<Type, InjectionMember, PropertyInfo> PropertySelector;
    private static Validating();
}
internal class Unity.Lifetime.ContainerLifetimeManager : LifetimeManager {
    public bool InUse { get; public set; }
    public virtual object GetValue(ILifetimeContainer container);
    protected virtual LifetimeManager OnCreateLifetimeManager();
    public virtual bool get_InUse();
    public virtual void set_InUse(bool value);
}
internal class Unity.Lifetime.InternalPerResolveLifetimeManager : PerResolveLifetimeManager {
    public InternalPerResolveLifetimeManager(object value);
}
public class Unity.Lifetime.LifetimeContainer : object {
    private List`1<object> _items;
    [CompilerGeneratedAttribute]
private IUnityContainer <Container>k__BackingField;
    public IUnityContainer Container { get; }
    public int Count { get; }
    public LifetimeContainer(IUnityContainer owner);
    [CompilerGeneratedAttribute]
public sealed virtual IUnityContainer get_Container();
    public sealed virtual int get_Count();
    public sealed virtual void Add(object item);
    public sealed virtual bool Contains(object item);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual IEnumerator`1<object> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Remove(object item);
}
public class Unity.ObjectBuilder.BuildPlan.DynamicMethod.DynamicBuildPlanGenerationContext : object {
    private Queue`1<Expression> _buildPlanExpressions;
    [CompilerGeneratedAttribute]
private Type <TypeToBuild>k__BackingField;
    public Type TypeToBuild { get; }
    public DynamicBuildPlanGenerationContext(Type typeToBuild);
    [CompilerGeneratedAttribute]
public Type get_TypeToBuild();
    public void AddToBuildPlan(Expression expression);
    internal ResolveDelegate`1<BuilderContext> GetBuildMethod();
}
[ObsoleteAttribute("This interface has been replaced with Unity.Policy.ResolveDelegateFactory delegate", "True")]
public interface Unity.Policy.IBuildPlanCreatorPolicy {
    public abstract virtual IBuildPlanPolicy CreatePlan(BuilderContext& context, Type type, string name);
}
[ObsoleteAttribute("IBuildPlanPolicy has been deprecated, please use ResolveDelegateFactory instead", "True")]
public interface Unity.Policy.IBuildPlanPolicy {
    public abstract virtual void BuildUp(BuilderContext& context);
}
[ObsoleteAttribute("IConstructorSelectorPolicy has been deprecated, please use ISelect<ConstructorInfo> instead", "True")]
public interface Unity.Policy.IConstructorSelectorPolicy {
}
[ObsoleteAttribute("IMethodSelectorPolicy has been deprecated, please use ISelectMembers<MethodInfo> instead", "True")]
public interface Unity.Policy.IMethodSelectorPolicy {
    public abstract virtual IEnumerable`1<object> SelectMethods(BuilderContext& context);
}
[ObsoleteAttribute("IPropertySelectorPolicy has been deprecated, please use IPropertySelectorPolicy instead", "True")]
public interface Unity.Policy.IPropertySelectorPolicy {
    public abstract virtual IEnumerable`1<object> SelectProperties(BuilderContext& context);
}
public interface Unity.Policy.IResolveDelegateFactory {
    public abstract virtual ResolveDelegate`1<BuilderContext> GetResolver(BuilderContext& context);
}
public interface Unity.Policy.ISelect`1 {
    public abstract virtual IEnumerable`1<object> Select(Type type, IPolicySet registration);
}
public class Unity.Policy.ResolveDelegateFactory : MulticastDelegate {
    public ResolveDelegateFactory(object object, IntPtr method);
    public virtual ResolveDelegate`1<BuilderContext> Invoke(BuilderContext& context);
    public virtual IAsyncResult BeginInvoke(BuilderContext& context, AsyncCallback callback, object object);
    public virtual ResolveDelegate`1<BuilderContext> EndInvoke(BuilderContext& context, IAsyncResult result);
}
public class Unity.Processors.ConstructorDiagnostic : ConstructorProcessor {
    private static string CannotConstructAbstractClass;
    private static string CannotConstructDelegate;
    private static string CannotConstructInterface;
    private static string TypeIsNotConstructable;
    private static Expression[] CannotConstructInterfaceExpr;
    private static Expression[] CannotConstructAbstractClassExpr;
    private static Expression[] CannotConstructDelegateExpr;
    private static Expression[] TypeIsNotConstructableExpr;
    public ConstructorDiagnostic(IPolicySet policySet, UnityContainer container);
    private static ConstructorDiagnostic();
    public virtual IEnumerable`1<object> Select(Type type, IPolicySet registration);
    protected virtual object SmartSelector(Type type, ConstructorInfo[] constructors);
    public virtual IEnumerable`1<Expression> GetExpressions(Type type, IPolicySet registration);
    protected virtual Expression GetResolverExpression(ConstructorInfo info, object resolvers);
    public virtual ResolveDelegate`1<BuilderContext> GetResolver(Type type, IPolicySet registration, ResolveDelegate`1<BuilderContext> seed);
    protected virtual ResolveDelegate`1<BuilderContext> GetResolverDelegate(ConstructorInfo info, object resolvers);
    protected virtual ResolveDelegate`1<BuilderContext> GetPerResolveDelegate(ConstructorInfo info, object resolvers);
    [CompilerGeneratedAttribute]
private bool <SmartSelector>b__10_3(ParameterInfo p);
    [CompilerGeneratedAttribute]
internal static string <GetResolverExpression>g__CreateErrorMessage|12_1(string format, Type type, MethodBase constructor);
}
public class Unity.Processors.ConstructorProcessor : ParametersProcessor`1<ConstructorInfo> {
    protected static ConstructorInfo InvalidOperationExceptionCtor;
    private static ConstructorInfo PerResolveInfo;
    protected static Expression SetPerBuildSingletonExpr;
    protected static Expression[] NoConstructorExpr;
    [CompilerGeneratedAttribute]
private Func`3<Type, ConstructorInfo[], object> <SelectMethod>k__BackingField;
    public Func`3<Type, ConstructorInfo[], object> SelectMethod { get; public set; }
    public ConstructorProcessor(IPolicySet policySet, UnityContainer container);
    private static ConstructorProcessor();
    public virtual IEnumerable`1<Expression> GetExpressions(Type type, IPolicySet registration);
    protected virtual Expression GetResolverExpression(ConstructorInfo info, object resolvers);
    [CompilerGeneratedAttribute]
public Func`3<Type, ConstructorInfo[], object> get_SelectMethod();
    [CompilerGeneratedAttribute]
public void set_SelectMethod(Func`3<Type, ConstructorInfo[], object> value);
    public virtual IEnumerable`1<object> Select(Type type, IPolicySet registration);
    protected virtual IEnumerable`1<ConstructorInfo> DeclaredMembers(Type type);
    public object LegacySelector(Type type, ConstructorInfo[] members);
    protected virtual object SmartSelector(Type type, ConstructorInfo[] constructors);
    public virtual ResolveDelegate`1<BuilderContext> GetResolver(Type type, IPolicySet registration, ResolveDelegate`1<BuilderContext> seed);
    protected virtual ResolveDelegate`1<BuilderContext> GetResolverDelegate(ConstructorInfo info, object resolvers);
    protected virtual ResolveDelegate`1<BuilderContext> GetPerResolveDelegate(ConstructorInfo info, object resolvers);
    [CompilerGeneratedAttribute]
private bool <SmartSelector>b__14_3(ParameterInfo p);
}
public class Unity.Processors.FieldDiagnostic : FieldProcessor {
    public FieldDiagnostic(IPolicySet policySet);
    [IteratorStateMachineAttribute("Unity.Processors.FieldDiagnostic/<Select>d__1")]
public virtual IEnumerable`1<object> Select(Type type, IPolicySet registration);
    protected virtual Expression GetResolverExpression(FieldInfo field, object resolver);
    protected virtual ResolveDelegate`1<BuilderContext> GetResolverDelegate(FieldInfo info, object resolver);
}
public class Unity.Processors.FieldProcessor : MemberProcessor`2<FieldInfo, object> {
    public FieldProcessor(IPolicySet policySet);
    protected virtual IEnumerable`1<FieldInfo> DeclaredMembers(Type type);
    protected virtual Type MemberType(FieldInfo info);
    protected virtual Expression GetResolverExpression(FieldInfo info, object resolver);
    protected virtual ResolveDelegate`1<BuilderContext> GetResolverDelegate(FieldInfo info, object resolver);
}
public abstract class Unity.Processors.MemberProcessor : object {
    protected static MethodInfo StringFormat;
    protected static Expression InvalidRegistrationExpression;
    protected static Expression NewGuid;
    protected static PropertyInfo DataProperty;
    protected static MethodInfo AddMethod;
    private static MemberProcessor();
    public abstract virtual IEnumerable`1<Expression> GetExpressions(Type type, IPolicySet registration);
    public abstract virtual ResolveDelegate`1<BuilderContext> GetResolver(Type type, IPolicySet registration, ResolveDelegate`1<BuilderContext> seed);
}
public abstract class Unity.Processors.MemberProcessor`2 : MemberProcessor {
    private IPolicySet _policySet;
    protected AttributeFactoryNode[] AttributeFactories;
    protected MemberProcessor`2(IPolicySet policySet);
    protected MemberProcessor`2(IPolicySet policySet, Type attribute);
    [IteratorStateMachineAttribute("Unity.Processors.MemberProcessor`2/<ExpressionsFromSelection>d__0")]
protected virtual IEnumerable`1<Expression> ExpressionsFromSelection(Type type, IEnumerable`1<object> members);
    protected abstract virtual Expression GetResolverExpression(TMemberInfo info, object resolver);
    public void Add(Type type, Func`2<Attribute, string> getName, Func`4<Attribute, object, object, ResolveDelegate`1<BuilderContext>> resolutionFactory);
    public virtual IEnumerable`1<Expression> GetExpressions(Type type, IPolicySet registration);
    public virtual ResolveDelegate`1<BuilderContext> GetResolver(Type type, IPolicySet registration, ResolveDelegate`1<BuilderContext> seed);
    [IteratorStateMachineAttribute("Unity.Processors.MemberProcessor`2/<Select>d__9")]
public virtual IEnumerable`1<object> Select(Type type, IPolicySet registration);
    protected abstract virtual Type MemberType(TMemberInfo info);
    protected abstract virtual IEnumerable`1<TMemberInfo> DeclaredMembers(Type type);
    protected object PreProcessResolver(TMemberInfo info, object resolver);
    protected Attribute GetCustomAttribute(TMemberInfo info, Type type);
    public TPolicyInterface GetPolicy(IPolicySet registration);
    protected virtual ResolveDelegate`1<BuilderContext> DependencyResolverFactory(Attribute attribute, object info, object value);
    protected virtual ResolveDelegate`1<BuilderContext> OptionalDependencyResolverFactory(Attribute attribute, object info, object value);
    [IteratorStateMachineAttribute("Unity.Processors.MemberProcessor`2/<ResolversFromSelection>d__18")]
protected virtual IEnumerable`1<ResolveDelegate`1<BuilderContext>> ResolversFromSelection(Type type, IEnumerable`1<object> members);
    protected abstract virtual ResolveDelegate`1<BuilderContext> GetResolverDelegate(TMemberInfo info, object resolver);
}
public class Unity.Processors.MethodDiagnostic : MethodProcessor {
    public MethodDiagnostic(IPolicySet policySet, UnityContainer container);
    [IteratorStateMachineAttribute("Unity.Processors.MethodDiagnostic/<Select>d__1")]
public virtual IEnumerable`1<object> Select(Type type, IPolicySet registration);
    protected virtual Expression GetResolverExpression(MethodInfo info, object resolvers);
    protected virtual ResolveDelegate`1<BuilderContext> GetResolverDelegate(MethodInfo info, object resolvers);
}
public class Unity.Processors.MethodProcessor : ParametersProcessor`1<MethodInfo> {
    public MethodProcessor(IPolicySet policySet, UnityContainer container);
    protected virtual IEnumerable`1<MethodInfo> DeclaredMembers(Type type);
    protected virtual Expression GetResolverExpression(MethodInfo info, object resolvers);
    protected virtual ResolveDelegate`1<BuilderContext> GetResolverDelegate(MethodInfo info, object resolvers);
}
public abstract class Unity.Processors.ParametersProcessor`1 : MemberProcessor`2<TMemberInfo, Object[]> {
    protected UnityContainer Container;
    private static TypeInfo DelegateType;
    protected ParametersProcessor`1(IPolicySet policySet, Type attribute, UnityContainer container);
    private static ParametersProcessor`1();
    [IteratorStateMachineAttribute("Unity.Processors.ParametersProcessor`1/<CreateDiagnosticParameterExpressions>d__0")]
protected virtual IEnumerable`1<Expression> CreateDiagnosticParameterExpressions(ParameterInfo[] parameters, object injectors);
    [IteratorStateMachineAttribute("Unity.Processors.ParametersProcessor`1/<CreateDiagnosticParameterResolvers>d__1")]
protected virtual IEnumerable`1<ResolveDelegate`1<BuilderContext>> CreateDiagnosticParameterResolvers(ParameterInfo[] parameters, object injectors);
    protected virtual Type MemberType(TMemberInfo info);
    [IteratorStateMachineAttribute("Unity.Processors.ParametersProcessor`1/<CreateParameterExpressions>d__6")]
protected virtual IEnumerable`1<Expression> CreateParameterExpressions(ParameterInfo[] parameters, object injectors);
    [IteratorStateMachineAttribute("Unity.Processors.ParametersProcessor`1/<CreateParameterResolvers>d__7")]
protected virtual IEnumerable`1<ResolveDelegate`1<BuilderContext>> CreateParameterResolvers(ParameterInfo[] parameters, object injectors);
    private object PreProcessResolver(ParameterInfo parameter, object resolver);
    private object FromType(Type type);
    private object FromAttribute(ParameterInfo info);
    protected bool CanResolve(ParameterInfo info);
    protected bool CanResolve(Type type, string name);
    protected virtual ResolveDelegate`1<BuilderContext> DependencyResolverFactory(Attribute attribute, object info, object value);
    protected virtual ResolveDelegate`1<BuilderContext> OptionalDependencyResolverFactory(Attribute attribute, object info, object value);
}
public class Unity.Processors.PropertyDiagnostic : PropertyProcessor {
    public PropertyDiagnostic(IPolicySet policySet);
    [IteratorStateMachineAttribute("Unity.Processors.PropertyDiagnostic/<Select>d__1")]
public virtual IEnumerable`1<object> Select(Type type, IPolicySet registration);
    protected virtual Expression GetResolverExpression(PropertyInfo property, object resolver);
    protected virtual ResolveDelegate`1<BuilderContext> GetResolverDelegate(PropertyInfo info, object resolver);
}
public class Unity.Processors.PropertyProcessor : MemberProcessor`2<PropertyInfo, object> {
    public PropertyProcessor(IPolicySet policySet);
    protected virtual Type MemberType(PropertyInfo info);
    [IteratorStateMachineAttribute("Unity.Processors.PropertyProcessor/<DeclaredMembers>d__2")]
protected virtual IEnumerable`1<PropertyInfo> DeclaredMembers(Type type);
    protected virtual Expression GetResolverExpression(PropertyInfo info, object resolver);
    protected virtual ResolveDelegate`1<BuilderContext> GetResolverDelegate(PropertyInfo info, object resolver);
}
[DebuggerDisplayAttribute("ContainerRegistration: MappedTo={Type?.Name ?? string.Empty},    {LifetimeManager?.GetType()?.Name}")]
public class Unity.Registration.ContainerRegistration : InternalRegistration {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public Type Type { get; }
    public LifetimeManager LifetimeManager { get; }
    public ContainerRegistration(LinkedNode`2<Type, object> validators, Type mappedTo, LifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    [CompilerGeneratedAttribute]
public virtual Type get_Type();
    public virtual LifetimeManager get_LifetimeManager();
}
[DebuggerDisplayAttribute("InternalRegistration")]
public class Unity.Registration.InternalRegistration : LinkedNode`2<Type, object> {
    [CompilerGeneratedAttribute]
private BuilderStrategy[] <BuildChain>k__BackingField;
    [CompilerGeneratedAttribute]
private InjectionMember[] <InjectionMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BuildRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private Converter`2<Type, Type> <Map>k__BackingField;
    public BuilderStrategy[] BuildChain { get; public set; }
    public InjectionMember[] InjectionMembers { get; public set; }
    public bool BuildRequired { get; public set; }
    public Converter`2<Type, Type> Map { get; public set; }
    public InternalRegistration(Type policyInterface, object policy);
    [CompilerGeneratedAttribute]
public virtual BuilderStrategy[] get_BuildChain();
    [CompilerGeneratedAttribute]
public virtual void set_BuildChain(BuilderStrategy[] value);
    [CompilerGeneratedAttribute]
public InjectionMember[] get_InjectionMembers();
    [CompilerGeneratedAttribute]
public void set_InjectionMembers(InjectionMember[] value);
    [CompilerGeneratedAttribute]
public bool get_BuildRequired();
    [CompilerGeneratedAttribute]
public void set_BuildRequired(bool value);
    [CompilerGeneratedAttribute]
public Converter`2<Type, Type> get_Map();
    [CompilerGeneratedAttribute]
public void set_Map(Converter`2<Type, Type> value);
    public virtual object Get(Type policyInterface);
    public virtual void Set(Type policyInterface, object policy);
    public virtual void Clear(Type policyInterface);
}
[ObsoleteAttribute("This type has been deprecated as degrading performance. Use DependencyOverride instead.", "False")]
public class Unity.Resolution.TypeBasedOverride : ResolverOverride {
    private ResolverOverride _innerOverride;
    public TypeBasedOverride(Type targetType, ResolverOverride innerOverride);
    public virtual ResolveDelegate`1<TContext> GetResolver(Type type);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PropertyInfo other);
    public sealed virtual bool Equals(ParameterInfo other);
}
[ObsoleteAttribute("This type has been deprecated as degrading performance. Use DependencyOverride instead.", "False")]
public class Unity.Resolution.TypeBasedOverride`1 : TypeBasedOverride {
    public TypeBasedOverride`1(ResolverOverride innerOverride);
}
[DefaultMemberAttribute("Item")]
[SecuritySafeCriticalAttribute]
[DebuggerDisplayAttribute("HashRegistry ({Count}) ")]
internal class Unity.Storage.HashRegistry : object {
    private static float LoadFactor;
    public Int32[] Buckets;
    public Entry[] Entries;
    public int Count;
    public IPolicySet Item { get; public set; }
    public bool RequireToGrow { get; }
    public IEnumerable`1<string> Keys { get; }
    public IEnumerable`1<IPolicySet> Values { get; }
    public HashRegistry(int capacity);
    public HashRegistry(int capacity, LinkedNode`2<string, IPolicySet> head);
    public HashRegistry(HashRegistry dictionary);
    public sealed virtual IPolicySet get_Item(string key);
    public sealed virtual void set_Item(string key, IPolicySet value);
    public sealed virtual bool get_RequireToGrow();
    [IteratorStateMachineAttribute("Unity.Storage.HashRegistry/<get_Keys>d__13")]
public sealed virtual IEnumerable`1<string> get_Keys();
    [IteratorStateMachineAttribute("Unity.Storage.HashRegistry/<get_Values>d__15")]
public sealed virtual IEnumerable`1<IPolicySet> get_Values();
    public sealed virtual IPolicySet GetOrAdd(string key, Func`1<IPolicySet> factory);
    public sealed virtual IPolicySet SetOrReplace(string key, IPolicySet value);
}
[DefaultMemberAttribute("Item")]
public interface Unity.Storage.IRegistry`2 {
    public TValue Item { get; public set; }
    public bool RequireToGrow { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey index);
    public abstract virtual void set_Item(TKey index, TValue value);
    public abstract virtual bool get_RequireToGrow();
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
    public abstract virtual TValue GetOrAdd(TKey key, Func`1<TValue> factory);
    public abstract virtual TValue SetOrReplace(TKey key, TValue value);
}
public interface Unity.Storage.IStagedStrategyChain`2 {
    public abstract virtual void Add(TStrategyType strategy, TStageEnum stage);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Invalidated(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Invalidated(EventHandler`1<EventArgs> value);
}
[DebuggerDisplayAttribute("Node:  Key={Key},  Value={Value}")]
public class Unity.Storage.LinkedNode`2 : object {
    public TKey Key;
    public TValue Value;
    public LinkedNode`2<TKey, TValue> Next;
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("LinkedRegistry ({_count}) ")]
internal class Unity.Storage.LinkedRegistry : LinkedNode`2<string, IPolicySet> {
    private int _count;
    public static int ListToHashCutoverPoint;
    public IPolicySet Item { get; public set; }
    public bool RequireToGrow { get; }
    public IEnumerable`1<string> Keys { get; }
    public IEnumerable`1<IPolicySet> Values { get; }
    public LinkedRegistry(string key, IPolicySet value);
    public LinkedRegistry(HashRegistry registry);
    public void Append(string name, IPolicySet value);
    public sealed virtual IPolicySet get_Item(string key);
    public sealed virtual void set_Item(string key, IPolicySet value);
    public sealed virtual bool get_RequireToGrow();
    [IteratorStateMachineAttribute("Unity.Storage.LinkedRegistry/<get_Keys>d__11")]
public sealed virtual IEnumerable`1<string> get_Keys();
    [IteratorStateMachineAttribute("Unity.Storage.LinkedRegistry/<get_Values>d__13")]
public sealed virtual IEnumerable`1<IPolicySet> get_Values();
    public sealed virtual IPolicySet GetOrAdd(string name, Func`1<IPolicySet> factory);
    public sealed virtual IPolicySet SetOrReplace(string name, IPolicySet value);
}
public class Unity.Storage.PolicyList : object {
    private object _sync;
    private IPolicyList _innerPolicyList;
    private IDictionary`2<PolicyKey, object> _policies;
    public int Count { get; }
    public PolicyList(IPolicyList innerPolicyList);
    public int get_Count();
    public sealed virtual void Clear(Type type, string name, Type policyInterface);
    public void ClearDefault(Type policyInterface);
    public sealed virtual object Get(Type type, string name, Type policyInterface);
    public sealed virtual object Get(Type type, Type policyInterface);
    public sealed virtual void Set(Type type, Type policyInterface, object policy);
    public sealed virtual void Set(Type type, string name, Type policyInterface, object policy);
}
[SecuritySafeCriticalAttribute]
public class Unity.Storage.QuickSet`1 : object {
    private int _prime;
    private Int32[] Buckets;
    private Entry[] Entries;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public static Int32[] Primes;
    public int Count { get; private set; }
    private static QuickSet`1();
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public bool Add(int hashCode, TValue value);
    private void Expand();
}
[DefaultMemberAttribute("Item")]
[SecuritySafeCriticalAttribute]
[DebuggerDisplayAttribute("Registrations ({Count}) ")]
internal class Unity.Storage.Registrations : object {
    private static float LoadFactor;
    public Int32[] Buckets;
    public Entry[] Entries;
    public int Count;
    public IRegistry`2<string, IPolicySet> Item { get; public set; }
    public bool RequireToGrow { get; }
    public IEnumerable`1<Type> Keys { get; }
    public IEnumerable`1<IRegistry`2<string, IPolicySet>> Values { get; }
    public Registrations(int capacity);
    public Registrations(int capacity, LinkedNode`2<Type, IRegistry`2<string, IPolicySet>> head);
    public Registrations(Registrations dictionary);
    public sealed virtual IRegistry`2<string, IPolicySet> get_Item(Type key);
    public sealed virtual void set_Item(Type key, IRegistry`2<string, IPolicySet> value);
    public sealed virtual bool get_RequireToGrow();
    [IteratorStateMachineAttribute("Unity.Storage.Registrations/<get_Keys>d__13")]
public sealed virtual IEnumerable`1<Type> get_Keys();
    [IteratorStateMachineAttribute("Unity.Storage.Registrations/<get_Values>d__15")]
public sealed virtual IEnumerable`1<IRegistry`2<string, IPolicySet>> get_Values();
    public sealed virtual IRegistry`2<string, IPolicySet> GetOrAdd(Type key, Func`1<IRegistry`2<string, IPolicySet>> factory);
    public sealed virtual IRegistry`2<string, IPolicySet> SetOrReplace(Type key, IRegistry`2<string, IPolicySet> value);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("IEnumerable<IContainerRegistration> ({Count}) ")]
[DebuggerTypeProxyAttribute("Unity.Storage.RegistrationSet/RegistrationSetDebugProxy")]
public class Unity.Storage.RegistrationSet : object {
    [DebuggerBrowsableAttribute("0")]
private static int InitialCapacity;
    [DebuggerBrowsableAttribute("0")]
private Int32[] _buckets;
    private Entry[] _entries;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public Entry& Item { get; }
    public int Count { get; private set; }
    public Entry& get_Item(int index);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public void Add(Type type, string name, InternalRegistration registration);
    private void IncreaseCapacity();
    [IteratorStateMachineAttribute("Unity.Storage.RegistrationSet/<GetEnumerator>d__12")]
public sealed virtual IEnumerator`1<IContainerRegistration> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Unity.Storage.StagedStrategyChain`2 : object {
    private static int _size;
    private object _lockObject;
    private StagedStrategyChain`2<TStrategyType, TStageEnum> _innerChain;
    private IList`1[] _stages;
    private TStrategyType[] _cache;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> Invalidated;
    public StagedStrategyChain`2(StagedStrategyChain`2<TStrategyType, TStageEnum> innerChain);
    private static StagedStrategyChain`2();
    private void OnParentInvalidated(object sender, EventArgs e);
    private IEnumerable`1<TStrategyType> Enumerate(int i);
    [CompilerGeneratedAttribute]
public sealed virtual void add_Invalidated(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_Invalidated(EventHandler`1<EventArgs> value);
    public sealed virtual void Add(TStrategyType strategy, TStageEnum stage);
    public TStrategyType[] ToArray();
    [IteratorStateMachineAttribute("Unity.Storage.StagedStrategyChain`2/<GetEnumerator>d__14")]
public sealed virtual IEnumerator`1<TStrategyType> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
public static class Unity.Storage.StagedStrategyChainExtensions : object {
    [ExtensionAttribute]
public static void AddNew(IStagedStrategyChain`2<TStrategy, TStageEnum> chain, TStageEnum stage);
}
public class Unity.Strategies.ArrayResolveStrategy : BuilderStrategy {
    private MethodInfo _resolveMethod;
    private MethodInfo _resolveGenericMethod;
    public ArrayResolveStrategy(MethodInfo method, MethodInfo generic);
    public virtual bool RequiredToBuildType(IUnityContainer container, Type type, InternalRegistration registration, InjectionMember[] injectionMembers);
    public virtual void PreBuildUp(BuilderContext& context);
}
public abstract class Unity.Strategies.BuilderStrategy : object {
    public virtual void PreBuildUp(BuilderContext& context);
    public virtual void PostBuildUp(BuilderContext& context);
    public virtual bool RequiredToBuildType(IUnityContainer container, Type type, InternalRegistration registration, InjectionMember[] injectionMembers);
    public virtual bool RequiredToResolveInstance(IUnityContainer container, InternalRegistration registration);
    public static TPolicyInterface GetPolicy(BuilderContext& context);
}
public class Unity.Strategies.BuildKeyMappingStrategy : BuilderStrategy {
    public virtual bool RequiredToBuildType(IUnityContainer container, Type type, InternalRegistration registration, InjectionMember[] injectionMembers);
    public virtual void PreBuildUp(BuilderContext& context);
}
public class Unity.Strategies.BuildPlanStrategy : BuilderStrategy {
    public virtual bool RequiredToBuildType(IUnityContainer container, Type type, InternalRegistration registration, InjectionMember[] injectionMembers);
    public virtual void PreBuildUp(BuilderContext& context);
    protected static TPolicyInterface Get_Policy(BuilderContext& context, Type type, string name);
    protected static object GetGeneric(BuilderContext& context, Type policyInterface);
    protected static object GetGeneric(BuilderContext& context, Type policyInterface, Type type, string name);
}
public class Unity.Strategies.LifetimeStrategy : BuilderStrategy {
    private object _genericLifetimeManagerLock;
    public virtual void PreBuildUp(BuilderContext& context);
    public virtual void PostBuildUp(BuilderContext& context);
    public virtual bool RequiredToBuildType(IUnityContainer container, Type type, InternalRegistration registration, InjectionMember[] injectionMembers);
    public virtual bool RequiredToResolveInstance(IUnityContainer container, InternalRegistration registration);
}
[DebuggerDisplayAttribute("{DebugName()}")]
[DebuggerTypeProxyAttribute("Unity.UnityContainer/UnityContainerDebugProxy")]
[CLSCompliantAttribute("True")]
[SecuritySafeCriticalAttribute]
public class Unity.UnityContainer : object {
    internal ResolveDelegateFactory _buildStrategy;
    private static Func`2<Exception, string> CreateMessage;
    private UnityContainer _root;
    private UnityContainer _parent;
    internal LifetimeContainer LifetimeContainer;
    private List`1<IUnityContainerExtensionConfigurator> _extensions;
    private LifetimeManager _typeLifetimeManager;
    private LifetimeManager _factoryLifetimeManager;
    private LifetimeManager _instanceLifetimeManager;
    private ContainerContext _context;
    private StagedStrategyChain`2<BuilderStrategy, UnityBuildStage> _strategies;
    private StagedStrategyChain`2<MemberProcessor, BuilderStage> _processors;
    private BuilderStrategy[] _strategiesChain;
    private MemberProcessor[] _processorsChain;
    [CompilerGeneratedAttribute]
private EventHandler`1<RegisterEventArgs> Registering;
    [CompilerGeneratedAttribute]
private EventHandler`1<RegisterInstanceEventArgs> RegisteringInstance;
    [CompilerGeneratedAttribute]
private EventHandler`1<ChildContainerCreatedEventArgs> ChildContainerCreated;
    [DebuggerBrowsableAttribute("0")]
internal Func`3<Type, string, IPolicySet> GetRegistration;
    [DebuggerBrowsableAttribute("0")]
internal Func`4<Type, string, InternalRegistration, IPolicySet> Register;
    [DebuggerBrowsableAttribute("0")]
internal GetPolicyDelegate GetPolicy;
    [DebuggerBrowsableAttribute("0")]
internal SetPolicyDelegate SetPolicy;
    [DebuggerBrowsableAttribute("0")]
internal ClearPolicyDelegate ClearPolicy;
    [DebuggerBrowsableAttribute("0")]
private Func`3<Type, string, IPolicySet> _get;
    [DebuggerBrowsableAttribute("0")]
internal Func`3<Type, string, bool> _isExplicitlyRegistered;
    [DebuggerBrowsableAttribute("0")]
private Func`4<Type, string, Type, IPolicySet> _getGenericRegistration;
    [DebuggerBrowsableAttribute("0")]
internal Func`2<Type, bool> IsTypeExplicitlyRegistered;
    private static ContainerLifetimeManager _containerManager;
    internal Action`1<UnityContainer> SetDefaultPolicies;
    private static string LifetimeManagerInUse;
    private Action`2<Type, Type> TypeValidator;
    [DebuggerBrowsableAttribute("0")]
private static int ContainerInitialCapacity;
    [DebuggerBrowsableAttribute("0")]
private static int ListToHashCutPoint;
    [DebuggerBrowsableAttribute("0")]
public static string All;
    [DebuggerBrowsableAttribute("0")]
internal static int HashMask;
    internal IPolicySet Defaults;
    private object _syncRoot;
    private LinkedNode`2<Type, object> _validators;
    private Registrations _registrations;
    [CompilerGeneratedAttribute]
private ResolveDelegate`1<BuilderContext> <ExecutePlan>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutePlanDelegate <ContextExecutePlan>k__BackingField;
    [CompilerGeneratedAttribute]
private ResolvePlanDelegate <ContextResolvePlan>k__BackingField;
    internal LifetimeManager TypeLifetimeManager { get; internal set; }
    internal LifetimeManager FactoryLifetimeManager { get; internal set; }
    internal LifetimeManager InstanceLifetimeManager { get; internal set; }
    private IUnityContainer Unity.IUnityContainer.Parent { get; }
    public IEnumerable`1<IContainerRegistration> Registrations { get; }
    private ResolveDelegate`1<BuilderContext> ExecutePlan { get; private set; }
    internal ExecutePlanDelegate ContextExecutePlan { get; internal set; }
    internal ResolvePlanDelegate ContextResolvePlan { get; internal set; }
    private UnityContainer(UnityContainer parent);
    private static UnityContainer();
    private static string CreateDiagnosticMessage(Exception ex);
    private static string DataToString(object value);
    private string DebugName();
    [CompilerGeneratedAttribute]
private void add_Registering(EventHandler`1<RegisterEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove_Registering(EventHandler`1<RegisterEventArgs> value);
    [CompilerGeneratedAttribute]
private void add_RegisteringInstance(EventHandler`1<RegisterInstanceEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove_RegisteringInstance(EventHandler`1<RegisterInstanceEventArgs> value);
    [CompilerGeneratedAttribute]
private void add_ChildContainerCreated(EventHandler`1<ChildContainerCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove_ChildContainerCreated(EventHandler`1<ChildContainerCreatedEventArgs> value);
    internal static void SetDiagnosticPolicies(UnityContainer container);
    internal LifetimeManager get_TypeLifetimeManager();
    internal void set_TypeLifetimeManager(LifetimeManager value);
    internal LifetimeManager get_FactoryLifetimeManager();
    internal void set_FactoryLifetimeManager(LifetimeManager value);
    internal LifetimeManager get_InstanceLifetimeManager();
    internal void set_InstanceLifetimeManager(LifetimeManager value);
    private void CreateAndSetPolicy(Type type, string name, Type policyInterface, object policy);
    private IPolicySet CreateAndSetOrUpdate(Type type, string name, InternalRegistration registration);
    private void SetupChildContainerBehaviors();
    private void OnStrategiesChanged(object sender, EventArgs e);
    private BuilderStrategy[] GetBuilders(Type type, InternalRegistration registration);
    internal Type GetFinalType(Type argType);
    protected virtual void Dispose(bool disposing);
    private sealed virtual override IUnityContainer Unity.IUnityContainer.RegisterType(Type typeFrom, Type typeTo, string name, ITypeLifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    private sealed virtual override IUnityContainer Unity.IUnityContainer.RegisterInstance(Type type, string name, object instance, IInstanceLifetimeManager lifetimeManager);
    public sealed virtual IUnityContainer RegisterFactory(Type type, string name, Func`4<IUnityContainer, Type, string, object> factory, IFactoryLifetimeManager lifetimeManager);
    private sealed virtual override bool Unity.IUnityContainer.IsRegistered(Type type, string name);
    private sealed virtual override object Unity.IUnityContainer.Resolve(Type type, string name, ResolverOverride[] overrides);
    private sealed virtual override object Unity.IUnityContainer.BuildUp(Type type, object existing, string name, ResolverOverride[] overrides);
    private sealed virtual override IUnityContainer Unity.IUnityContainer.CreateChildContainer();
    private sealed virtual override IUnityContainer Unity.IUnityContainer.get_Parent();
    [IteratorStateMachineAttribute("Unity.UnityContainer/<get_Registrations>d__75")]
public sealed virtual IEnumerable`1<IContainerRegistration> get_Registrations();
    public IUnityContainer AddExtension(IUnityContainerExtensionConfigurator extension);
    public object Configure(Type configurationInterface);
    public sealed virtual void Dispose();
    private bool IsExplicitlyRegisteredLocally(Type type, string name);
    private bool IsTypeTypeExplicitlyRegisteredLocally(Type type);
    internal bool RegistrationExists(Type type, string name);
    private static RegistrationSet GetRegistrations(UnityContainer container);
    private static RegistrationSet GetRegistrations(UnityContainer container, Type[] types);
    private static RegistrationSet GetNamedRegistrations(UnityContainer container, Type[] types);
    private IRegistry`2<string, IPolicySet> Get(Type type);
    internal IPolicySet AppendNew(Type type, string name, InternalRegistration registration);
    private IPolicySet AddOrUpdate(Type type, string name, InternalRegistration registration);
    private IPolicySet GetOrAdd(Type type, string name);
    private IPolicySet GetOrAddGeneric(Type type, string name, Type definition);
    private IPolicySet Get(Type type, string name);
    private void Set(Type type, string name, IPolicySet value);
    private object Get(Type type, string name, Type policyInterface);
    private void Set(Type type, string name, Type policyInterface, object policy);
    private void Clear(Type type, string name, Type policyInterface);
    private IPolicySet GetDynamicRegistration(Type type, string name);
    private IPolicySet CreateRegistration(Type type, string name, InternalRegistration factory);
    private IPolicySet CreateRegistration(Type type, string name);
    private IPolicySet CreateRegistration(Type type, Type policyInterface, object policy);
    [IteratorStateMachineAttribute("Unity.UnityContainer/<ResolveEnumerable>d__107`1")]
internal IEnumerable`1<TElement> ResolveEnumerable(Func`4<Type, string, InternalRegistration, object> resolve, string name);
    [IteratorStateMachineAttribute("Unity.UnityContainer/<ResolveEnumerable>d__108`1")]
internal IEnumerable`1<TElement> ResolveEnumerable(Func`4<Type, string, InternalRegistration, object> resolve, Type generic, string name);
    internal static object ResolveArray(BuilderContext& context);
    private static IList`1<TElement> ResolveRegistrations(BuilderContext& context, RegistrationSet registrations);
    internal static object ResolveGenericArray(BuilderContext& context, Type type);
    private static IList`1<TElement> ResolveGenericRegistrations(BuilderContext& context, RegistrationSet registrations);
    private static ResolveDelegate`1<BuilderContext> OptimizingFactory(BuilderContext& context);
    internal ResolveDelegate`1<BuilderContext> CompilingFactory(BuilderContext& context);
    internal ResolveDelegate`1<BuilderContext> ResolvingFactory(BuilderContext& context);
    [CompilerGeneratedAttribute]
private ResolveDelegate`1<BuilderContext> get_ExecutePlan();
    [CompilerGeneratedAttribute]
private void set_ExecutePlan(ResolveDelegate`1<BuilderContext> value);
    private object ExecuteValidatingPlan(BuilderContext& context);
    [CompilerGeneratedAttribute]
internal ExecutePlanDelegate get_ContextExecutePlan();
    [CompilerGeneratedAttribute]
internal void set_ContextExecutePlan(ExecutePlanDelegate value);
    internal static object ContextValidatingExecutePlan(BuilderStrategy[] chain, BuilderContext& context);
    [CompilerGeneratedAttribute]
internal ResolvePlanDelegate get_ContextResolvePlan();
    [CompilerGeneratedAttribute]
internal void set_ContextResolvePlan(ResolvePlanDelegate value);
    internal static object ContextValidatingResolvePlan(BuilderContext& thisContext, ResolveDelegate`1<BuilderContext> resolver);
    [CompilerGeneratedAttribute]
private IEnumerable`1<IPolicySet> <DebugName>b__5_0(Type t);
    [CompilerGeneratedAttribute]
private IPolicySet <.ctor>b__41_0(Type t, string n);
    [CompilerGeneratedAttribute]
private IPolicySet <SetupChildContainerBehaviors>b__55_0(Type type, string name);
    [CompilerGeneratedAttribute]
private object <Dispose>b__59_0(Type type, string name, Type policyInterface);
    [CompilerGeneratedAttribute]
internal static int <GetRegistrations>g__GetStartIndex|90_0(<>c__DisplayClass90_0& );
    [CompilerGeneratedAttribute]
internal static object <ContextValidatingExecutePlan>g__GetPerResolveValue|125_0(IntPtr parent, Type registrationType, string name);
}
internal static class Unity.Utility.HashHelpers : object {
    public static Int32[] Primes;
    internal static int HashPrime;
    public static int MaxPrimeArrayLength;
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int GetMinPrime();
    public static int ExpandPrime(int oldSize);
}
