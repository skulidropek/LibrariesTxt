[ExtensionAttribute]
internal static class System.Reflection.IntrospectionExtensions : object {
    [ExtensionAttribute]
public static MethodInfo GetGetMethod(PropertyInfo info, bool _);
    [ExtensionAttribute]
public static MethodInfo GetSetMethod(PropertyInfo info, bool _);
}
public class Unity.Interception.ContainerIntegration.AdditionalInterface : InterceptionMember {
    private Type _additionalInterface;
    public AdditionalInterface(Type additionalInterface);
    public virtual void AddPolicies(Type registeredType, Type mappedToType, string name, TPolicySet& policies);
}
public class Unity.Interception.ContainerIntegration.AdditionalInterface`1 : AdditionalInterface {
}
public class Unity.Interception.ContainerIntegration.InterceptionBehavior : InterceptionBehaviorBase {
    public InterceptionBehavior(IInterceptionBehavior interceptionBehavior);
    public InterceptionBehavior(Type behaviorType, string name);
    public InterceptionBehavior(Type behaviorType);
    protected virtual InterceptionBehaviorsPolicy GetBehaviorsPolicy(TPolicySet& policies);
}
public class Unity.Interception.ContainerIntegration.InterceptionBehavior`1 : InterceptionBehavior {
    public InterceptionBehavior`1(string name);
}
public abstract class Unity.Interception.ContainerIntegration.InterceptionBehaviorBase : InterceptionMember {
    private NamedTypeBuildKey _behaviorKey;
    private IInterceptionBehavior _explicitBehavior;
    protected InterceptionBehaviorBase(IInterceptionBehavior interceptionBehavior);
    protected InterceptionBehaviorBase(Type behaviorType, string name);
    protected InterceptionBehaviorBase(Type behaviorType);
    public virtual void AddPolicies(Type registeredType, Type mappedToType, string name, TPolicySet& policies);
    protected abstract virtual InterceptionBehaviorsPolicy GetBehaviorsPolicy(TPolicySet& policies);
}
public abstract class Unity.Interception.ContainerIntegration.InterceptionMember : InjectionMember {
}
public class Unity.Interception.ContainerIntegration.Interceptor : InterceptionMember {
    private IInterceptor _interceptor;
    private Type _type;
    private string _name;
    public bool BuildRequired { get; }
    private bool IsInstanceInterceptor { get; }
    public Interceptor(IInterceptor interceptor);
    public Interceptor(Type interceptorType, string name);
    public Interceptor(Type interceptorType);
    public virtual void AddPolicies(Type registeredType, Type mappedToType, string name, TPolicySet& policies);
    public virtual bool get_BuildRequired();
    private bool get_IsInstanceInterceptor();
    private IInstanceInterceptionPolicy CreateInstanceInterceptionPolicy();
    private ITypeInterceptionPolicy CreateTypeInterceptionPolicy();
}
public class Unity.Interception.ContainerIntegration.Interceptor`1 : Interceptor {
    public Interceptor`1(string name);
}
public class Unity.Interception.ContainerIntegration.ObjectBuilder.AdditionalInterfacesPolicy : object {
    private List`1<Type> _additionalInterfaces;
    public IEnumerable`1<Type> AdditionalInterfaces { get; }
    public sealed virtual IEnumerable`1<Type> get_AdditionalInterfaces();
    internal void AddAdditionalInterface(Type additionalInterface);
    internal static AdditionalInterfacesPolicy GetOrCreate(TPolicySet& policies);
}
public class Unity.Interception.ContainerIntegration.ObjectBuilder.FixedInstanceInterceptionPolicy : object {
    private IInstanceInterceptor _interceptor;
    public FixedInstanceInterceptionPolicy(IInstanceInterceptor interceptor);
    public sealed virtual IInstanceInterceptor GetInterceptor(BuilderContext& context);
}
public class Unity.Interception.ContainerIntegration.ObjectBuilder.FixedTypeInterceptionPolicy : object {
    private ITypeInterceptor _interceptor;
    [CompilerGeneratedAttribute]
private Type <ProxyType>k__BackingField;
    public Type ProxyType { get; public set; }
    public FixedTypeInterceptionPolicy(ITypeInterceptor interceptor);
    public sealed virtual ITypeInterceptor GetInterceptor(IUnityContainer container);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ProxyType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProxyType(Type value);
}
public interface Unity.Interception.ContainerIntegration.ObjectBuilder.IAdditionalInterfacesPolicy {
    public IEnumerable`1<Type> AdditionalInterfaces { get; }
    public abstract virtual IEnumerable`1<Type> get_AdditionalInterfaces();
}
public interface Unity.Interception.ContainerIntegration.ObjectBuilder.IInstanceInterceptionPolicy {
    public abstract virtual IInstanceInterceptor GetInterceptor(BuilderContext& context);
}
public interface Unity.Interception.ContainerIntegration.ObjectBuilder.IInterceptionBehaviorsPolicy {
    public IEnumerable`1<NamedTypeBuildKey> BehaviorKeys { get; }
    public abstract virtual IEnumerable`1<NamedTypeBuildKey> get_BehaviorKeys();
    public abstract virtual IEnumerable`1<IInterceptionBehavior> GetEffectiveBehaviors(IUnityContainer container, IInterceptor interceptor, Type typeToIntercept, Type implementationType);
}
public class Unity.Interception.ContainerIntegration.ObjectBuilder.InstanceInterceptionStrategy : BuilderStrategy {
    public virtual void PostBuildUp(BuilderContext& context);
    private static T FindInterceptionPolicy(BuilderContext& context, bool probeOriginalKey);
    public static TPolicyInterface GetPolicyOrDefault(BuilderContext& context);
    [CompilerGeneratedAttribute]
internal static object <GetPolicyOrDefault>g__GetNamedPolicy|2_0(BuilderContext& c, Type t, string n);
}
public class Unity.Interception.ContainerIntegration.ObjectBuilder.InterceptionBehaviorsPolicy : object {
    private List`1<NamedTypeBuildKey> _behaviorKeys;
    private List`1<IInterceptionBehavior> _explicitBehaviors;
    public IEnumerable`1<NamedTypeBuildKey> BehaviorKeys { get; }
    public sealed virtual IEnumerable`1<NamedTypeBuildKey> get_BehaviorKeys();
    [IteratorStateMachineAttribute("Unity.Interception.ContainerIntegration.ObjectBuilder.InterceptionBehaviorsPolicy/<GetEffectiveBehaviors>d__4")]
public sealed virtual IEnumerable`1<IInterceptionBehavior> GetEffectiveBehaviors(IUnityContainer container, IInterceptor interceptor, Type typeToIntercept, Type implementationType);
    internal void AddBehaviorKey(NamedTypeBuildKey key);
    public void AddBehavior(IInterceptionBehavior behavior);
    internal static InterceptionBehaviorsPolicy GetOrCreate(TPolicySet& policies);
}
[ExtensionAttribute]
public static class Unity.Interception.ContainerIntegration.ObjectBuilder.InterceptionBehaviorsPolicyExtension : object {
    [ExtensionAttribute]
public static IEnumerable`1<IInterceptionBehavior> GetEffectiveBehaviors(IInterceptionBehaviorsPolicy policy, BuilderContext& context, IInterceptor interceptor, Type typeToIntercept, Type implementationType);
}
public interface Unity.Interception.ContainerIntegration.ObjectBuilder.ITypeInterceptionPolicy {
    public Type ProxyType { get; public set; }
    public abstract virtual ITypeInterceptor GetInterceptor(IUnityContainer container);
    public abstract virtual Type get_ProxyType();
    public abstract virtual void set_ProxyType(Type value);
}
public class Unity.Interception.ContainerIntegration.ObjectBuilder.ResolvedInstanceInterceptionPolicy : object {
    private Type _type;
    private string _name;
    public ResolvedInstanceInterceptionPolicy(NamedTypeBuildKey buildKey);
    public ResolvedInstanceInterceptionPolicy(Type type, string name);
    public sealed virtual IInstanceInterceptor GetInterceptor(BuilderContext& context);
}
public class Unity.Interception.ContainerIntegration.ObjectBuilder.ResolvedTypeInterceptionPolicy : object {
    private Type _type;
    private string _name;
    private ITypeInterceptor _policy;
    [CompilerGeneratedAttribute]
private Type <ProxyType>k__BackingField;
    public Type ProxyType { get; public set; }
    public ResolvedTypeInterceptionPolicy(NamedTypeBuildKey buildKey);
    public ResolvedTypeInterceptionPolicy(Type type, string name);
    public sealed virtual ITypeInterceptor GetInterceptor(IUnityContainer container);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_ProxyType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ProxyType(Type value);
}
[ExtensionAttribute]
public static class Unity.Interception.ContainerIntegration.ObjectBuilder.TypeInterceptionPolicyExtension : object {
    [ExtensionAttribute]
public static ITypeInterceptor GetInterceptor(ITypeInterceptionPolicy policy, BuilderContext& context);
}
public class Unity.Interception.ContainerIntegration.ObjectBuilder.TypeInterceptionStrategy : BuilderStrategy {
    public virtual void PreBuildUp(BuilderContext& context);
    public virtual void PostBuildUp(BuilderContext& context);
    public static TPolicyInterface GetPolicyOrDefault(BuilderContext& context);
    [CompilerGeneratedAttribute]
internal static object <GetPolicyOrDefault>g__GetNamedPolicy|2_0(BuilderContext& c, Type t, string n);
}
public class Unity.Interception.ContainerIntegration.PolicyDefinition : object {
    private string _policyName;
    private Interception _extension;
    private List`1<ResolvedParameter> _rulesParameters;
    private List`1<string> _handlersNames;
    public IUnityContainer Container { get; }
    public Interception Interception { get; }
    internal PolicyDefinition(string policyName, Interception extension);
    private PolicyDefinition UpdateRuleDrivenPolicyInjection();
    private PolicyDefinition UpdateRulesParameters(string name);
    private PolicyDefinition UpdateHandlerNames(string name);
    private static string NewName();
    public IUnityContainer get_Container();
    public Interception get_Interception();
    public PolicyDefinition AddMatchingRule(string name);
    public PolicyDefinition AddMatchingRule(IMatchingRule instance);
    public PolicyDefinition AddMatchingRule(Type type, InjectionMember[] injectionMembers);
    public PolicyDefinition AddMatchingRule(Type type, LifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    public PolicyDefinition AddMatchingRule(Type type, string name, InjectionMember[] injectionMembers);
    public PolicyDefinition AddMatchingRule(Type type, string name, LifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    public PolicyDefinition AddMatchingRule(InjectionMember[] injectionMembers);
    public PolicyDefinition AddMatchingRule(LifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    public PolicyDefinition AddMatchingRule(string name, InjectionMember[] injectionMembers);
    public PolicyDefinition AddMatchingRule(string name, LifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    public PolicyDefinition AddCallHandler(string name);
    public PolicyDefinition AddCallHandler(ICallHandler instance);
    public PolicyDefinition AddCallHandler(Type type, InjectionMember[] injectionMembers);
    public PolicyDefinition AddCallHandler(Type type, LifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    public PolicyDefinition AddCallHandler(Type type, string name, InjectionMember[] injectionMembers);
    public PolicyDefinition AddCallHandler(Type type, string name, LifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    public PolicyDefinition AddCallHandler(InjectionMember[] injectionMembers);
    public PolicyDefinition AddCallHandler(LifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    public PolicyDefinition AddCallHandler(string name, InjectionMember[] injectionMembers);
    public PolicyDefinition AddCallHandler(string name, LifetimeManager lifetimeManager, InjectionMember[] injectionMembers);
    private PolicyDefinition AddElement(string name, UpdateElements update);
    private PolicyDefinition AddElement(T instance, UpdateElements update);
    private PolicyDefinition AddElement(Type type, string name, LifetimeManager lifetimeManager, InjectionMember[] injectionMembers, UpdateElements update);
    private PolicyDefinition AddElement(string name, LifetimeManager lifetimeManager, InjectionMember[] injectionMembers, UpdateElements update);
}
public class Unity.Interception.ContainerIntegration.Selection.SelectedConstructor : MethodBase`1<ConstructorInfo> {
    public ConstructorInfo Constructor { get; }
    public SelectedConstructor(ConstructorInfo constructor);
    public SelectedConstructor(ConstructorInfo info, Object[] parameters);
    public ConstructorInfo get_Constructor();
    public virtual IEnumerable`1<ConstructorInfo> DeclaredMembers(Type type);
}
public static class Unity.Interception.Intercept : object {
    public static T ThroughProxyWithAdditionalInterfaces(T target, IInstanceInterceptor interceptor, IEnumerable`1<IInterceptionBehavior> interceptionBehaviors, IEnumerable`1<Type> additionalInterfaces);
    public static T ThroughProxy(T target, IInstanceInterceptor interceptor, IEnumerable`1<IInterceptionBehavior> interceptionBehaviors);
    public static object ThroughProxyWithAdditionalInterfaces(Type interceptedType, object target, IInstanceInterceptor interceptor, IEnumerable`1<IInterceptionBehavior> interceptionBehaviors, IEnumerable`1<Type> additionalInterfaces);
    public static object ThroughProxy(Type interceptedType, object target, IInstanceInterceptor interceptor, IEnumerable`1<IInterceptionBehavior> interceptionBehaviors);
    public static T NewInstanceWithAdditionalInterfaces(ITypeInterceptor interceptor, IEnumerable`1<IInterceptionBehavior> interceptionBehaviors, IEnumerable`1<Type> additionalInterfaces, Object[] constructorParameters);
    public static T NewInstance(ITypeInterceptor interceptor, IEnumerable`1<IInterceptionBehavior> interceptionBehaviors, Object[] constructorParameters);
    public static object NewInstanceWithAdditionalInterfaces(Type type, ITypeInterceptor interceptor, IEnumerable`1<IInterceptionBehavior> interceptionBehaviors, IEnumerable`1<Type> additionalInterfaces, Object[] constructorParameters);
    public static object NewInstance(Type type, ITypeInterceptor interceptor, IEnumerable`1<IInterceptionBehavior> interceptionBehaviors, Object[] constructorParameters);
    public static Type[] GetAllAdditionalInterfaces(IEnumerable`1<IInterceptionBehavior> interceptionBehaviors, IEnumerable`1<Type> additionalInterfaces);
    private static IEnumerable`1<Type> CheckInterfaces(IEnumerable`1<Type> interfaces, string argumentName, Func`2<string, string> messageFormatter);
}
public class Unity.Interception.Interception : UnityContainerExtension {
    protected virtual void Initialize();
    public Interception SetInterceptorFor(Type typeToIntercept, string name, ITypeInterceptor interceptor);
    public Interception SetInterceptorFor(Type typeToIntercept, ITypeInterceptor interceptor);
    public Interception SetInterceptorFor(string name, ITypeInterceptor interceptor);
    public Interception SetInterceptorFor(ITypeInterceptor interceptor);
    public Interception SetInterceptorFor(Type typeToIntercept, string name, IInstanceInterceptor interceptor);
    public Interception SetDefaultInterceptorFor(Type typeToIntercept, ITypeInterceptor interceptor);
    public Interception SetDefaultInterceptorFor(ITypeInterceptor interceptor);
    public Interception SetInterceptorFor(Type typeToIntercept, IInstanceInterceptor interceptor);
    public Interception SetInterceptorFor(string name, IInstanceInterceptor interceptor);
    public Interception SetInterceptorFor(IInstanceInterceptor interceptor);
    public Interception SetDefaultInterceptorFor(Type typeToIntercept, IInstanceInterceptor interceptor);
    public Interception SetDefaultInterceptorFor(IInstanceInterceptor interceptor);
    private static void GuardTypeInterceptable(Type typeToIntercept, IInterceptor interceptor);
    public PolicyDefinition AddPolicy(string policyName);
}
public class Unity.Interception.InterceptionBehaviors.CurrentInterceptionRequest : object {
    [CompilerGeneratedAttribute]
private IInterceptor <Interceptor>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TypeToIntercept>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ImplementationType>k__BackingField;
    public IInterceptor Interceptor { get; public set; }
    public Type TypeToIntercept { get; public set; }
    public Type ImplementationType { get; public set; }
    public CurrentInterceptionRequest(IInterceptor interceptor, Type typeToIntercept, Type implementationType);
    [CompilerGeneratedAttribute]
public IInterceptor get_Interceptor();
    [CompilerGeneratedAttribute]
public void set_Interceptor(IInterceptor value);
    [CompilerGeneratedAttribute]
public Type get_TypeToIntercept();
    [CompilerGeneratedAttribute]
public void set_TypeToIntercept(Type value);
    [CompilerGeneratedAttribute]
public Type get_ImplementationType();
    [CompilerGeneratedAttribute]
public void set_ImplementationType(Type value);
}
public class Unity.Interception.InterceptionBehaviors.GetNextInterceptionBehaviorDelegate : MulticastDelegate {
    public GetNextInterceptionBehaviorDelegate(object object, IntPtr method);
    public virtual InvokeInterceptionBehaviorDelegate Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual InvokeInterceptionBehaviorDelegate EndInvoke(IAsyncResult result);
}
public interface Unity.Interception.InterceptionBehaviors.IInterceptionBehavior {
    public bool WillExecute { get; }
    public abstract virtual IMethodReturn Invoke(IMethodInvocation input, GetNextInterceptionBehaviorDelegate getNext);
    public abstract virtual IEnumerable`1<Type> GetRequiredInterfaces();
    public abstract virtual bool get_WillExecute();
}
public class Unity.Interception.InterceptionBehaviors.InterceptionBehaviorPipeline : object {
    private List`1<IInterceptionBehavior> _interceptionBehaviors;
    public int Count { get; }
    public InterceptionBehaviorPipeline(IEnumerable`1<IInterceptionBehavior> interceptionBehaviors);
    public int get_Count();
    public IMethodReturn Invoke(IMethodInvocation input, InvokeInterceptionBehaviorDelegate target);
    public void Add(IInterceptionBehavior interceptionBehavior);
}
public class Unity.Interception.InterceptionBehaviors.InvokeInterceptionBehaviorDelegate : MulticastDelegate {
    public InvokeInterceptionBehaviorDelegate(object object, IntPtr method);
    public virtual IMethodReturn Invoke(IMethodInvocation input, GetNextInterceptionBehaviorDelegate getNext);
    public virtual IAsyncResult BeginInvoke(IMethodInvocation input, GetNextInterceptionBehaviorDelegate getNext, AsyncCallback callback, object object);
    public virtual IMethodReturn EndInvoke(IAsyncResult result);
}
public class Unity.Interception.Interceptors.GenericParameterMapper : object {
    private static KeyValuePair`2[] EmptyMappings;
    private IDictionary`2<Type, Type> _mappedTypesCache;
    private ICollection`1<KeyValuePair`2<Type, Type>> _localMappings;
    private GenericParameterMapper _parent;
    [CompilerGeneratedAttribute]
private static GenericParameterMapper <DefaultMapper>k__BackingField;
    public static GenericParameterMapper DefaultMapper { get; }
    public GenericParameterMapper(Type type, GenericParameterMapper parent);
    public GenericParameterMapper(Type[] reflectedParameters, Type[] generatedParameters);
    public GenericParameterMapper(Type[] reflectedParameters, Type[] generatedParameters, GenericParameterMapper parent);
    private static GenericParameterMapper();
    private static ICollection`1<KeyValuePair`2<Type, Type>> CreateMappings(Type[] reflectedParameters, Type[] generatedParameters);
    public Type Map(Type typeToMap);
    private Type DoMap(Type typeToMap);
    [CompilerGeneratedAttribute]
public static GenericParameterMapper get_DefaultMapper();
    public Type[] GetReflectedParameters();
    public Type[] GetGeneratedParameters();
}
public interface Unity.Interception.Interceptors.IInterceptingProxy {
    public abstract virtual void AddInterceptionBehavior(IInterceptionBehavior interceptor);
}
public interface Unity.Interception.Interceptors.IInterceptor {
    public abstract virtual bool CanIntercept(Type t);
    public abstract virtual IEnumerable`1<MethodImplementationInfo> GetInterceptableMethods(Type interceptedType, Type implementationType);
}
public interface Unity.Interception.Interceptors.InstanceInterceptors.IInstanceInterceptor {
    public abstract virtual IInterceptingProxy CreateProxy(Type t, object target, Type[] additionalInterfaces);
}
internal class Unity.Interception.Interceptors.InstanceInterceptors.InterfaceInterception.InterfaceImplementation : object {
    private TypeBuilder _typeBuilder;
    private Type _interface;
    private Type _targetInterface;
    private GenericParameterMapper _genericParameterMapper;
    private FieldBuilder _proxyInterceptionPipelineField;
    private bool _explicitImplementation;
    private FieldBuilder _targetField;
    public InterfaceImplementation(TypeBuilder typeBuilder, Type interface, FieldBuilder proxyInterceptionPipelineField, bool explicitImplementation);
    public InterfaceImplementation(TypeBuilder typeBuilder, Type interface, FieldBuilder proxyInterceptionPipelineField, bool explicitImplementation, FieldBuilder targetField);
    public InterfaceImplementation(TypeBuilder typeBuilder, Type interface, GenericParameterMapper genericParameterMapper, FieldBuilder proxyInterceptionPipelineField, bool explicitImplementation, FieldBuilder targetField);
    public int Implement(HashSet`1<Type> implementedInterfaces, int memberCount);
    [IteratorStateMachineAttribute("Unity.Interception.Interceptors.InstanceInterceptors.InterfaceInterception.InterfaceImplementation/<MethodsToIntercept>d__11")]
private IEnumerable`1<MethodInfo> MethodsToIntercept();
    private void OverrideMethod(MethodInfo method, int methodNum);
    private IEnumerable`1<PropertyInfo> PropertiesToIntercept();
    private void OverrideProperty(PropertyInfo property, int count);
    private void AddPropertyDefinition(PropertyInfo property, MethodBuilder getMethod, MethodBuilder setMethod);
    private MethodBuilder OverridePropertyMethod(MethodInfo method, int count);
    private IEnumerable`1<EventInfo> EventsToIntercept();
    private void OverrideEvent(EventInfo event, int count);
    private void AddEventDefinition(EventInfo event, MethodBuilder addMethod, MethodBuilder removeMethod);
    private MethodBuilder OverrideEventMethod(MethodInfo method, int count);
}
public class Unity.Interception.Interceptors.InstanceInterceptors.InterfaceInterception.InterfaceInterceptor : object {
    private static Dictionary`2<GeneratedTypeKey, Type> InterceptorClasses;
    private static InterfaceInterceptor();
    public sealed virtual bool CanIntercept(Type t);
    public sealed virtual IEnumerable`1<MethodImplementationInfo> GetInterceptableMethods(Type interceptedType, Type implementationType);
    [IteratorStateMachineAttribute("Unity.Interception.Interceptors.InstanceInterceptors.InterfaceInterception.InterfaceInterceptor/<DoGetInterceptableMethods>d__3")]
private IEnumerable`1<MethodImplementationInfo> DoGetInterceptableMethods(Type interceptedType, Type implementationType);
    public sealed virtual IInterceptingProxy CreateProxy(Type t, object target, Type[] additionalInterfaces);
}
public class Unity.Interception.Interceptors.InstanceInterceptors.InterfaceInterception.InterfaceInterceptorClassGenerator : object {
    private static AssemblyBuilder AssemblyBuilder;
    private Type _typeToIntercept;
    private IEnumerable`1<Type> _additionalInterfaces;
    private GenericParameterMapper _mainInterfaceMapper;
    private FieldBuilder _proxyInterceptionPipelineField;
    private FieldBuilder _targetField;
    private FieldBuilder _typeToProxyField;
    private TypeBuilder _typeBuilder;
    private static InterfaceInterceptorClassGenerator();
    public InterfaceInterceptorClassGenerator(Type typeToIntercept, IEnumerable`1<Type> additionalInterfaces);
    private static void CheckAdditionalInterfaces(IEnumerable`1<Type> additionalInterfaces);
    public Type CreateProxyType();
    private void AddConstructor();
    private void CreateTypeBuilder();
    private string CreateTypeName();
    private GenericParameterMapper DefineGenericArguments();
}
public class Unity.Interception.Interceptors.InstanceInterceptors.InterfaceInterception.InterfaceMethodOverride : object {
    private static MethodInfo BuildAdditionalInterfaceNonImplementedExceptionMethod;
    private static MethodAttributes ImplicitImplementationAttributes;
    private static MethodAttributes ExplicitImplementationAttributes;
    private TypeBuilder _typeBuilder;
    private MethodInfo _methodToOverride;
    private ParameterInfo[] _methodParameters;
    private FieldBuilder _proxyInterceptionPipelineField;
    private bool _explicitImplementation;
    private FieldBuilder _targetField;
    private Type _targetInterface;
    private GenericParameterMapper _targetInterfaceParameterMapper;
    private int _overrideCount;
    private static OpCode[] LoadArgsOpcodes;
    private static OpCode[] LoadConstOpCodes;
    private bool MethodHasReturnValue { get; }
    internal InterfaceMethodOverride(TypeBuilder typeBuilder, FieldBuilder proxyInterceptionPipelineField, FieldBuilder targetField, MethodInfo methodToOverride, Type targetInterface, GenericParameterMapper targetInterfaceParameterMapper, bool explicitImplementation, int overrideCount);
    private static InterfaceMethodOverride();
    internal MethodBuilder AddMethod();
    private string CreateMethodName(string purpose);
    private static void EmitLoadArgument(ILGenerator il, int argumentNumber);
    private static void EmitLoadConstant(ILGenerator il, int i);
    private static void EmitBox(ILGenerator il, Type typeOnStack);
    private static void EmitUnboxOrCast(ILGenerator il, Type targetType);
    private MethodBuilder CreateDelegateImplementation();
    private MethodBuilder CreateMethodOverride(MethodBuilder delegateMethod);
    private bool get_MethodHasReturnValue();
    public static Exception BuildAdditionalInterfaceNonImplementedException();
}
[SecurityCriticalAttribute]
public class Unity.Interception.Interceptors.InstanceInterceptors.TransparentProxyInterception.InterceptingRealProxy : RealProxy {
    private InterceptionBehaviorPipeline _interceptorsPipeline;
    private ReadOnlyCollection`1<Type> _additionalInterfaces;
    [CompilerGeneratedAttribute]
private object <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public object Target { get; }
    public string TypeName { get; public set; }
    public InterceptingRealProxy(object target, Type classToProxy, Type[] additionalInterfaces);
    private static ReadOnlyCollection`1<Type> CheckAdditionalInterfaces(Type[] interfaces);
    [CompilerGeneratedAttribute]
public object get_Target();
    [SecuritySafeCriticalAttribute]
public sealed virtual void AddInterceptionBehavior(IInterceptionBehavior interceptor);
    [SecurityCriticalAttribute]
public sealed virtual bool CanCastTo(Type fromType, object o);
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
public sealed virtual string get_TypeName();
    [CompilerGeneratedAttribute]
[SecurityCriticalAttribute]
public sealed virtual void set_TypeName(string value);
    [SecurityCriticalAttribute]
public virtual IMessage Invoke(IMessage msg);
    private IMessage HandleInterceptingProxyMethod(IMethodCallMessage callMessage);
    private IMessage ExecuteAddInterceptionBehavior(IMethodCallMessage callMessage);
}
[SecurityCriticalAttribute]
internal class Unity.Interception.Interceptors.InstanceInterceptors.TransparentProxyInterception.TransparentProxyInputParameterCollection : ParameterCollection {
    public TransparentProxyInputParameterCollection(IMethodCallMessage callMessage, Object[] arguments);
}
public class Unity.Interception.Interceptors.InstanceInterceptors.TransparentProxyInterception.TransparentProxyInterceptor : object {
    public sealed virtual bool CanIntercept(Type t);
    public sealed virtual IEnumerable`1<MethodImplementationInfo> GetInterceptableMethods(Type interceptedType, Type implementationType);
    [IteratorStateMachineAttribute("Unity.Interception.Interceptors.InstanceInterceptors.TransparentProxyInterception.TransparentProxyInterceptor/<GetMBROMethods>d__2")]
private static IEnumerable`1<MethodImplementationInfo> GetMBROMethods(Type t);
    [IteratorStateMachineAttribute("Unity.Interception.Interceptors.InstanceInterceptors.TransparentProxyInterception.TransparentProxyInterceptor/<GetImplementedInterfaceMethods>d__3")]
private static IEnumerable`1<MethodImplementationInfo> GetImplementedInterfaceMethods(Type t);
    private static bool IsNotSystemMethod(MethodInfo method);
    [SecuritySafeCriticalAttribute]
public sealed virtual IInterceptingProxy CreateProxy(Type t, object target, Type[] additionalInterfaces);
}
[SecurityCriticalAttribute]
public class Unity.Interception.Interceptors.InstanceInterceptors.TransparentProxyInterception.TransparentProxyMethodInvocation : object {
    private IMethodCallMessage _callMessage;
    private TransparentProxyInputParameterCollection _inputParams;
    private ParameterCollection _allParams;
    private Dictionary`2<string, object> _invocationContext;
    private object _target;
    private Object[] _arguments;
    public IParameterCollection Inputs { get; }
    private IParameterCollection Unity.Interception.PolicyInjection.Pipeline.IMethodInvocation.Arguments { get; }
    public IDictionary`2<string, object> InvocationContext { get; }
    public object Target { get; }
    public MethodBase MethodBase { get; }
    internal Object[] Arguments { get; }
    public TransparentProxyMethodInvocation(IMethodCallMessage callMessage, object target);
    [SecuritySafeCriticalAttribute]
public sealed virtual IParameterCollection get_Inputs();
    [SecuritySafeCriticalAttribute]
private sealed virtual override IParameterCollection Unity.Interception.PolicyInjection.Pipeline.IMethodInvocation.get_Arguments();
    [SecuritySafeCriticalAttribute]
public sealed virtual IDictionary`2<string, object> get_InvocationContext();
    [SecuritySafeCriticalAttribute]
public sealed virtual object get_Target();
    [SecuritySafeCriticalAttribute]
public sealed virtual MethodBase get_MethodBase();
    [SecuritySafeCriticalAttribute]
public sealed virtual IMethodReturn CreateMethodReturn(object returnValue, Object[] outputs);
    [SecuritySafeCriticalAttribute]
public sealed virtual IMethodReturn CreateExceptionMethodReturn(Exception ex);
    internal Object[] get_Arguments();
}
[SecurityCriticalAttribute]
internal class Unity.Interception.Interceptors.InstanceInterceptors.TransparentProxyInterception.TransparentProxyMethodReturn : object {
    private IMethodCallMessage _callMessage;
    private ParameterCollection _outputs;
    private IDictionary`2<string, object> _invocationContext;
    private Object[] _arguments;
    private object _returnValue;
    private Exception _exception;
    public IParameterCollection Outputs { get; }
    public object ReturnValue { get; public set; }
    public Exception Exception { get; public set; }
    public IDictionary`2<string, object> InvocationContext { get; }
    public TransparentProxyMethodReturn(IMethodCallMessage callMessage, object returnValue, Object[] arguments, IDictionary`2<string, object> invocationContext);
    public TransparentProxyMethodReturn(Exception ex, IMethodCallMessage callMessage, IDictionary`2<string, object> invocationContext);
    [SecuritySafeCriticalAttribute]
public sealed virtual IParameterCollection get_Outputs();
    [SecuritySafeCriticalAttribute]
public sealed virtual object get_ReturnValue();
    [SecuritySafeCriticalAttribute]
public sealed virtual void set_ReturnValue(object value);
    [SecuritySafeCriticalAttribute]
public sealed virtual Exception get_Exception();
    [SecuritySafeCriticalAttribute]
public sealed virtual void set_Exception(Exception value);
    [SecuritySafeCriticalAttribute]
public sealed virtual IDictionary`2<string, object> get_InvocationContext();
    [SecurityCriticalAttribute]
public IMethodReturnMessage ToMethodReturnMessage();
}
[SecurityCriticalAttribute]
internal class Unity.Interception.Interceptors.InstanceInterceptors.TransparentProxyInterception.TransparentProxyOutputParameterCollection : ParameterCollection {
    public TransparentProxyOutputParameterCollection(IMethodCallMessage callMessage, Object[] arguments);
}
public static class Unity.Interception.Interceptors.InterceptorClassGenerator : object {
    private static ConcurrentDictionary`2<AssemblyBuilder, ModuleBuilder> ModuleByAssembly;
    private static InterceptorClassGenerator();
    public static ModuleBuilder CreateModuleBuilder(AssemblyBuilder assemblyBuilder);
}
public class Unity.Interception.Interceptors.MethodImplementationInfo : object {
    [CompilerGeneratedAttribute]
private MethodInfo <InterfaceMethodInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <ImplementationMethodInfo>k__BackingField;
    public MethodInfo InterfaceMethodInfo { get; }
    public MethodInfo ImplementationMethodInfo { get; }
    public MethodImplementationInfo(MethodInfo interfaceMethodInfo, MethodInfo implementationMethodInfo);
    [CompilerGeneratedAttribute]
public MethodInfo get_InterfaceMethodInfo();
    [CompilerGeneratedAttribute]
public MethodInfo get_ImplementationMethodInfo();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MethodImplementationInfo left, MethodImplementationInfo right);
    public static bool op_Inequality(MethodImplementationInfo left, MethodImplementationInfo right);
    public virtual string ToString();
}
public interface Unity.Interception.Interceptors.TypeInterceptors.ITypeInterceptor {
    public abstract virtual Type CreateProxyType(Type t, Type[] additionalInterfaces);
}
internal static class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.CompilerGeneratedAttributeMethods : object {
    public static ConstructorInfo CompilerGeneratedAttribute { get; }
    public static ConstructorInfo get_CompilerGeneratedAttribute();
}
internal class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.GeneratedTypeKey : ValueType {
    private Type _baseType;
    private Type[] _additionalInterfaces;
    public GeneratedTypeKey(Type baseType, Type[] additionalInterfaces);
}
internal static class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.IInterceptingProxyMethods : object {
    internal static MethodInfo AddInterceptionBehavior { get; }
    internal static MethodInfo get_AddInterceptionBehavior();
}
internal static class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.IListMethods : object {
    internal static MethodInfo GetItem { get; }
    internal static MethodInfo get_GetItem();
}
internal static class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.IMethodInvocationMethods : object {
    internal static MethodInfo CreateExceptionMethodReturn { get; }
    internal static MethodInfo CreateReturn { get; }
    internal static MethodInfo GetArguments { get; }
    internal static MethodInfo get_CreateExceptionMethodReturn();
    internal static MethodInfo get_CreateReturn();
    internal static MethodInfo get_GetArguments();
}
internal static class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.IMethodReturnMethods : object {
    internal static MethodInfo GetException { get; }
    internal static MethodInfo GetReturnValue { get; }
    internal static MethodInfo GetOutputs { get; }
    internal static MethodInfo get_GetException();
    internal static MethodInfo get_GetReturnValue();
    internal static MethodInfo get_GetOutputs();
}
public class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.InterceptingClassGenerator : object {
    private static AssemblyBuilder AssemblyBuilder;
    private Type _typeToIntercept;
    private IEnumerable`1<Type> _additionalInterfaces;
    private Type _targetType;
    private GenericParameterMapper _mainTypeMapper;
    private FieldBuilder _proxyInterceptionPipelineField;
    private TypeBuilder _typeBuilder;
    private static InterceptingClassGenerator();
    public InterceptingClassGenerator(Type typeToIntercept, Type[] additionalInterfaces);
    public Type GenerateType();
    private void AddMethods();
    [IteratorStateMachineAttribute("Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.InterceptingClassGenerator/<GetMethodsToIntercept>d__11")]
private IEnumerable`1<MethodInfo> GetMethodsToIntercept();
    private void AddProperties();
    private void OverridePropertyMethod(MethodInfo method, int count);
    private void AddEvents();
    private void OverrideEventMethod(MethodInfo method, int count);
    private void AddConstructors();
    private void AddConstructor(ConstructorInfo ctor);
    private void CreateTypeBuilder();
    private static Type GetGenericType(Type typeToIntercept);
    private static GenericParameterMapper DefineGenericArguments(TypeBuilder typeBuilder, Type baseClass);
    private static TypeAttributes FilterTypeAttributes(TypeAttributes attributes);
    private HashSet`1<Type> GetImplementedInterfacesSet();
    private static void AddToImplementedInterfaces(Type type, HashSet`1<Type> implementedInterfaces);
    [CompilerGeneratedAttribute]
private Type <CreateTypeBuilder>b__18_0(Type t);
}
internal static class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.InterceptingProxyImplementor : object {
    internal static FieldBuilder ImplementIInterceptingProxy(TypeBuilder typeBuilder);
    private static void ImplementAddInterceptionBehavior(TypeBuilder typeBuilder, FieldInfo proxyInterceptorPipelineField);
}
internal static class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.InterceptionBehaviorPipelineMethods : object {
    internal static ConstructorInfo Constructor { get; }
    internal static MethodInfo Add { get; }
    internal static MethodInfo Invoke { get; }
    internal static ConstructorInfo get_Constructor();
    internal static MethodInfo get_Add();
    internal static MethodInfo get_Invoke();
}
internal static class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.InvokeInterceptionBehaviorDelegateMethods : object {
    internal static ConstructorInfo InvokeInterceptionBehaviorDelegate { get; }
    internal static ConstructorInfo get_InvokeInterceptionBehaviorDelegate();
}
internal static class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.MethodBaseMethods : object {
    internal static MethodInfo GetMethodFromHandle { get; }
    internal static MethodInfo GetMethodForGenericFromHandle { get; }
    internal static MethodInfo get_GetMethodFromHandle();
    internal static MethodInfo get_GetMethodForGenericFromHandle();
}
public class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.MethodOverride : object {
    private static MethodInfo BuildAbstractMethodInvokedExceptionMethod;
    private TypeBuilder _typeBuilder;
    private MethodInfo _methodToOverride;
    private ParameterInfo[] _methodParameters;
    private FieldBuilder _proxyInterceptionPipelineField;
    private Type _targetType;
    private GenericParameterMapper _targetTypeParameterMapper;
    private int _overrideCount;
    private static OpCode[] LoadArgsOpcodes;
    private static OpCode[] LoadConstOpCodes;
    private bool MethodHasReturnValue { get; }
    private Type ReturnType { get; }
    private IEnumerable`1<int> OutputParameterIndices { get; }
    internal MethodOverride(TypeBuilder typeBuilder, FieldBuilder proxyInterceptionPipelineField, MethodInfo methodToOverride, Type targetType, GenericParameterMapper targetTypeParameterMapper, int overrideCount);
    private static MethodOverride();
    internal static bool MethodCanBeIntercepted(MethodInfo method);
    internal MethodBuilder AddMethod();
    private string CreateMethodName(string purpose);
    private static void EmitLoadArgument(ILGenerator il, int argumentNumber);
    private static void EmitLoadConstant(ILGenerator il, int i);
    private static void EmitBox(ILGenerator il, Type typeOnStack);
    private static void EmitUnboxOrCast(ILGenerator il, Type typeOnStack);
    private MethodBuilder CreateDelegateImplementation(MethodInfo callBaseMethod);
    private MethodBuilder CreateMethodOverride(MethodBuilder delegateMethod);
    private bool get_MethodHasReturnValue();
    private Type get_ReturnType();
    [IteratorStateMachineAttribute("Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.MethodOverride/<get_OutputParameterIndices>d__25")]
private IEnumerable`1<int> get_OutputParameterIndices();
    public static Exception BuildAbstractMethodInvokedException();
}
internal class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.MethodOverrideParameterMapper : object {
    private MethodInfo _methodToOverride;
    private GenericParameterMapper _genericParameterMapper;
    public Type[] GenericMethodParameters { get; }
    public MethodOverrideParameterMapper(MethodInfo methodToOverride);
    public void SetupParameters(MethodBuilder methodBuilder, GenericParameterMapper parentMapper);
    public Type GetParameterType(Type originalParameterType);
    public Type GetElementType(Type originalParameterType);
    public Type GetReturnType();
    public Type[] get_GenericMethodParameters();
}
internal class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.MethodSorter : object {
    private Dictionary`2<string, List`1<MethodInfo>> _methodsByName;
    private Type _declaringType;
    public MethodSorter(Type declaringType, IEnumerable`1<MethodInfo> methodsToSort);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.MethodSorter/<GetEnumerator>d__4")]
public sealed virtual IEnumerator`1<MethodInfo> GetEnumerator();
    private void GroupMethodsByName(IEnumerable`1<MethodInfo> methodsToSort);
    [IteratorStateMachineAttribute("Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.MethodSorter/<RemoveHiddenOverloads>d__6")]
private IEnumerable`1<MethodInfo> RemoveHiddenOverloads(IEnumerable`1<MethodInfo> methods);
    [IteratorStateMachineAttribute("Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.MethodSorter/<GroupOverloadedMethods>d__7")]
private static IEnumerable`1<List`1<MethodInfo>> GroupOverloadedMethods(IList`1<MethodInfo> sortedMethods);
    private MethodInfo SelectMostDerivedOverload(IList`1<MethodInfo> overloads);
    private int DeclarationDepth(MethodInfo method);
    private static int CompareMethodInfosByParameterLists(MethodInfo left, MethodInfo right);
    private static int CompareParameterLists(ParameterInfo[] left, ParameterInfo[] right);
    private static int CompareParameterInfo(ParameterInfo left, ParameterInfo right);
}
internal static class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.ObjectMethods : object {
    internal static ConstructorInfo Constructor { get; }
    internal static ConstructorInfo get_Constructor();
}
internal static class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.InterceptingClassGeneration.VirtualMethodInvocationMethods : object {
    internal static ConstructorInfo VirtualMethodInvocation { get; }
    internal static ConstructorInfo get_VirtualMethodInvocation();
}
public class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.VirtualMethodInterceptor : object {
    private static Dictionary`2<GeneratedTypeKey, Type> DerivedClasses;
    private static VirtualMethodInterceptor();
    public sealed virtual bool CanIntercept(Type t);
    public sealed virtual IEnumerable`1<MethodImplementationInfo> GetInterceptableMethods(Type interceptedType, Type implementationType);
    [IteratorStateMachineAttribute("Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.VirtualMethodInterceptor/<DoGetInterceptableMethods>d__3")]
private IEnumerable`1<MethodImplementationInfo> DoGetInterceptableMethods(Type implementationType);
    public sealed virtual Type CreateProxyType(Type t, Type[] additionalInterfaces);
}
public class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.VirtualMethodInvocation : object {
    private ParameterCollection _inputs;
    private ParameterCollection _arguments;
    private Dictionary`2<string, object> _context;
    [CompilerGeneratedAttribute]
private object <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodBase <MethodBase>k__BackingField;
    public IParameterCollection Inputs { get; }
    public IParameterCollection Arguments { get; }
    public IDictionary`2<string, object> InvocationContext { get; }
    public object Target { get; }
    public MethodBase MethodBase { get; }
    public VirtualMethodInvocation(object target, MethodBase targetMethod, Object[] parameterValues);
    public sealed virtual IParameterCollection get_Inputs();
    public sealed virtual IParameterCollection get_Arguments();
    public sealed virtual IDictionary`2<string, object> get_InvocationContext();
    [CompilerGeneratedAttribute]
public sealed virtual object get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual MethodBase get_MethodBase();
    public sealed virtual IMethodReturn CreateMethodReturn(object returnValue, Object[] outputs);
    public sealed virtual IMethodReturn CreateExceptionMethodReturn(Exception ex);
}
public class Unity.Interception.Interceptors.TypeInterceptors.VirtualMethodInterception.VirtualMethodReturn : object {
    private ParameterCollection _outputs;
    [CompilerGeneratedAttribute]
private object <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <InvocationContext>k__BackingField;
    public IParameterCollection Outputs { get; }
    public object ReturnValue { get; public set; }
    public Exception Exception { get; public set; }
    public IDictionary`2<string, object> InvocationContext { get; }
    public VirtualMethodReturn(IMethodInvocation originalInvocation, object returnValue, Object[] arguments);
    public VirtualMethodReturn(IMethodInvocation originalInvocation, Exception exception);
    public sealed virtual IParameterCollection get_Outputs();
    [CompilerGeneratedAttribute]
public sealed virtual object get_ReturnValue();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ReturnValue(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_InvocationContext();
}
public class Unity.Interception.PolicyInjection.HandlerPipelineKey : ValueType {
    private Module _module;
    private int _methodMetadataToken;
    private HandlerPipelineKey(Module module, int methodMetadataToken);
    public static HandlerPipelineKey ForMethod(MethodBase methodBase);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(HandlerPipelineKey left, HandlerPipelineKey right);
    public static bool op_Inequality(HandlerPipelineKey left, HandlerPipelineKey right);
    public sealed virtual bool Equals(HandlerPipelineKey other);
}
internal class Unity.Interception.PolicyInjection.MatchingRules.ApplyNoPoliciesMatchingRule : object {
    public sealed virtual bool Matches(MethodBase member);
}
public class Unity.Interception.PolicyInjection.MatchingRules.AssemblyMatchingRule : object {
    private string _assemblyName;
    public AssemblyMatchingRule(string assemblyName);
    public AssemblyMatchingRule(Assembly assembly);
    public sealed virtual bool Matches(MethodBase member);
    private static bool DoesAssemblyNameMatchString(string assemblyNameString, AssemblyName assemblyName);
}
public class Unity.Interception.PolicyInjection.MatchingRules.AttributeDrivenPolicyMatchingRule : object {
    public sealed virtual bool Matches(MethodBase member);
}
public class Unity.Interception.PolicyInjection.MatchingRules.CustomAttributeMatchingRule : object {
    private Type _attributeType;
    private bool _inherited;
    public CustomAttributeMatchingRule(Type attributeType, bool inherited);
    public sealed virtual bool Matches(MethodBase member);
}
public interface Unity.Interception.PolicyInjection.MatchingRules.IMatchingRule {
    public abstract virtual bool Matches(MethodBase member);
}
public class Unity.Interception.PolicyInjection.MatchingRules.MatchingInfo : object {
    [CompilerGeneratedAttribute]
private string <Match>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    public string Match { get; public set; }
    public bool IgnoreCase { get; public set; }
    public MatchingInfo(string nameToMatch);
    public MatchingInfo(string nameToMatch, bool ignoreCase);
    [CompilerGeneratedAttribute]
public string get_Match();
    [CompilerGeneratedAttribute]
public void set_Match(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
}
public class Unity.Interception.PolicyInjection.MatchingRules.MatchingRuleSet : List`1<IMatchingRule> {
    public sealed virtual bool Matches(MethodBase member);
}
public class Unity.Interception.PolicyInjection.MatchingRules.MemberNameMatchingRule : object {
    private List`1<Glob> _patterns;
    public MemberNameMatchingRule(string nameToMatch);
    public MemberNameMatchingRule(string nameToMatch, bool ignoreCase);
    public MemberNameMatchingRule(IEnumerable`1<string> namesToMatch);
    public MemberNameMatchingRule(IEnumerable`1<string> namesToMatch, bool ignoreCase);
    public MemberNameMatchingRule(IEnumerable`1<MatchingInfo> matches);
    public sealed virtual bool Matches(MethodBase member);
}
public class Unity.Interception.PolicyInjection.MatchingRules.MethodSignatureMatchingRule : object {
    private Glob _methodNamePattern;
    private List`1<TypeMatchingRule> _parameterRules;
    public MethodSignatureMatchingRule(string methodName, IEnumerable`1<string> parameterTypeNames, bool ignoreCase);
    public MethodSignatureMatchingRule(string methodName, IEnumerable`1<string> parameterTypeNames);
    public MethodSignatureMatchingRule(IEnumerable`1<string> parameterTypeNames);
    public MethodSignatureMatchingRule(IEnumerable`1<string> parameterTypeNames, bool ignoreCase);
    public sealed virtual bool Matches(MethodBase member);
}
public class Unity.Interception.PolicyInjection.MatchingRules.NamespaceMatchingRule : object {
    private List`1<NamespaceMatchingInfo> _matches;
    public NamespaceMatchingRule(string namespaceName);
    public NamespaceMatchingRule(string namespaceName, bool ignoreCase);
    public NamespaceMatchingRule(IEnumerable`1<MatchingInfo> matches);
    public sealed virtual bool Matches(MethodBase member);
}
public enum Unity.Interception.PolicyInjection.MatchingRules.ParameterKind : Enum {
    public int value__;
    public static ParameterKind Input;
    public static ParameterKind Output;
    public static ParameterKind InputOrOutput;
    public static ParameterKind ReturnValue;
}
public class Unity.Interception.PolicyInjection.MatchingRules.ParameterTypeMatchingInfo : MatchingInfo {
    [CompilerGeneratedAttribute]
private ParameterKind <Kind>k__BackingField;
    public ParameterKind Kind { get; public set; }
    public ParameterTypeMatchingInfo(ParameterKind kind);
    public ParameterTypeMatchingInfo(string nameToMatch, ParameterKind kind);
    public ParameterTypeMatchingInfo(string nameToMatch, bool ignoreCase, ParameterKind kind);
    [CompilerGeneratedAttribute]
public ParameterKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(ParameterKind value);
}
public class Unity.Interception.PolicyInjection.MatchingRules.ParameterTypeMatchingRule : object {
    private List`1<ParameterTypeMatchingInfo> _matches;
    public IEnumerable`1<ParameterTypeMatchingInfo> ParameterMatches { get; }
    public ParameterTypeMatchingRule(IEnumerable`1<ParameterTypeMatchingInfo> matches);
    public IEnumerable`1<ParameterTypeMatchingInfo> get_ParameterMatches();
    public sealed virtual bool Matches(MethodBase member);
}
public class Unity.Interception.PolicyInjection.MatchingRules.PropertyMatchingInfo : MatchingInfo {
    [CompilerGeneratedAttribute]
private PropertyMatchingOption <Option>k__BackingField;
    public PropertyMatchingOption Option { get; public set; }
    public PropertyMatchingInfo(string match);
    public PropertyMatchingInfo(string match, PropertyMatchingOption option);
    public PropertyMatchingInfo(string match, PropertyMatchingOption option, bool ignoreCase);
    [CompilerGeneratedAttribute]
public PropertyMatchingOption get_Option();
    [CompilerGeneratedAttribute]
public void set_Option(PropertyMatchingOption value);
}
public enum Unity.Interception.PolicyInjection.MatchingRules.PropertyMatchingOption : Enum {
    public int value__;
    public static PropertyMatchingOption Get;
    public static PropertyMatchingOption Set;
    public static PropertyMatchingOption GetOrSet;
}
public class Unity.Interception.PolicyInjection.MatchingRules.PropertyMatchingRule : object {
    private List`1<Glob> _patterns;
    public PropertyMatchingRule(string propertyName);
    public PropertyMatchingRule(string propertyName, PropertyMatchingOption option);
    public PropertyMatchingRule(string propertyName, PropertyMatchingOption option, bool ignoreCase);
    public PropertyMatchingRule(IEnumerable`1<PropertyMatchingInfo> matches);
    public sealed virtual bool Matches(MethodBase member);
}
public class Unity.Interception.PolicyInjection.MatchingRules.ReturnTypeMatchingRule : object {
    private TypeMatchingRule _typeMatchingRule;
    public ReturnTypeMatchingRule(Type returnType);
    public ReturnTypeMatchingRule(string returnTypeName);
    public ReturnTypeMatchingRule(string returnTypeName, bool ignoreCase);
    public sealed virtual bool Matches(MethodBase member);
}
[AttributeUsageAttribute("196")]
public class Unity.Interception.PolicyInjection.MatchingRules.TagAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Tag>k__BackingField;
    public string Tag { get; }
    public TagAttribute(string tag);
    [CompilerGeneratedAttribute]
public string get_Tag();
}
public class Unity.Interception.PolicyInjection.MatchingRules.TagAttributeMatchingRule : object {
    private string _tagToMatch;
    private bool _ignoreCase;
    public TagAttributeMatchingRule(string tagToMatch);
    public TagAttributeMatchingRule(string tagToMatch, bool ignoreCase);
    public sealed virtual bool Matches(MethodBase member);
}
public class Unity.Interception.PolicyInjection.MatchingRules.TypeMatchingRule : object {
    private List`1<MatchingInfo> _matches;
    private bool _matchesTypelessMembers;
    public TypeMatchingRule(Type type);
    public TypeMatchingRule(string typeName);
    public TypeMatchingRule(string typeName, bool ignoreCase);
    public TypeMatchingRule(IEnumerable`1<MatchingInfo> matches);
    public sealed virtual bool Matches(MethodBase member);
    public bool Matches(Type t);
    private static StringComparison Comparison(bool ignoreCase);
    private static string SafeGetTypeName(Type type);
}
[ExtensionAttribute]
internal static class Unity.Interception.PolicyInjection.MatchingRules.UtilityExtensions : object {
    [ExtensionAttribute]
internal static bool IsReturn(ParameterInfo parameterInfo);
    [ExtensionAttribute]
internal static bool IsInvariantCulture(CultureInfo cultureInfo);
    [ExtensionAttribute]
internal static bool IsSameAs(CultureInfo cultureInfo, CultureInfo otherCultureInfo);
}
public class Unity.Interception.PolicyInjection.Pipeline.GetNextHandlerDelegate : MulticastDelegate {
    public GetNextHandlerDelegate(object object, IntPtr method);
    public virtual InvokeHandlerDelegate Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual InvokeHandlerDelegate EndInvoke(IAsyncResult result);
}
public class Unity.Interception.PolicyInjection.Pipeline.HandlerPipeline : object {
    private List`1<ICallHandler> _handlers;
    public int Count { get; }
    public HandlerPipeline(IEnumerable`1<ICallHandler> handlers);
    public int get_Count();
    public IMethodReturn Invoke(IMethodInvocation input, InvokeHandlerDelegate target);
}
public interface Unity.Interception.PolicyInjection.Pipeline.ICallHandler {
    public int Order { get; public set; }
    public abstract virtual IMethodReturn Invoke(IMethodInvocation input, GetNextHandlerDelegate getNext);
    public abstract virtual int get_Order();
    public abstract virtual void set_Order(int value);
}
public interface Unity.Interception.PolicyInjection.Pipeline.IMethodInvocation {
    public IParameterCollection Inputs { get; }
    public IParameterCollection Arguments { get; }
    public IDictionary`2<string, object> InvocationContext { get; }
    public object Target { get; }
    public MethodBase MethodBase { get; }
    public abstract virtual IParameterCollection get_Inputs();
    public abstract virtual IParameterCollection get_Arguments();
    public abstract virtual IDictionary`2<string, object> get_InvocationContext();
    public abstract virtual object get_Target();
    public abstract virtual MethodBase get_MethodBase();
    public abstract virtual IMethodReturn CreateMethodReturn(object returnValue, Object[] outputs);
    public abstract virtual IMethodReturn CreateExceptionMethodReturn(Exception ex);
}
public interface Unity.Interception.PolicyInjection.Pipeline.IMethodReturn {
    public IParameterCollection Outputs { get; }
    public object ReturnValue { get; public set; }
    public Exception Exception { get; public set; }
    public IDictionary`2<string, object> InvocationContext { get; }
    public abstract virtual IParameterCollection get_Outputs();
    public abstract virtual object get_ReturnValue();
    public abstract virtual void set_ReturnValue(object value);
    public abstract virtual Exception get_Exception();
    public abstract virtual void set_Exception(Exception value);
    public abstract virtual IDictionary`2<string, object> get_InvocationContext();
}
public class Unity.Interception.PolicyInjection.Pipeline.InvokeHandlerDelegate : MulticastDelegate {
    public InvokeHandlerDelegate(object object, IntPtr method);
    public virtual IMethodReturn Invoke(IMethodInvocation input, GetNextHandlerDelegate getNext);
    public virtual IAsyncResult BeginInvoke(IMethodInvocation input, GetNextHandlerDelegate getNext, AsyncCallback callback, object object);
    public virtual IMethodReturn EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
public interface Unity.Interception.PolicyInjection.Pipeline.IParameterCollection {
    public object Item { get; public set; }
    public abstract virtual object get_Item(string parameterName);
    public abstract virtual void set_Item(string parameterName, object value);
    public abstract virtual string ParameterName(int index);
    public abstract virtual ParameterInfo GetParameterInfo(int index);
    public abstract virtual ParameterInfo GetParameterInfo(string parameterName);
    public abstract virtual bool ContainsParameter(string parameterName);
}
[DefaultMemberAttribute("Item")]
public class Unity.Interception.PolicyInjection.Pipeline.ParameterCollection : object {
    private List`1<ArgumentInfo> _argumentInfo;
    private Object[] _arguments;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFixedSize>k__BackingField;
    public object Item { get; public set; }
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public ParameterCollection(Object[] arguments, ParameterInfo[] argumentInfo, Predicate`1<ParameterInfo> isArgumentPartOfCollection);
    public sealed virtual object get_Item(string parameterName);
    public sealed virtual void set_Item(string parameterName, object value);
    private int IndexForInputParameterName(string paramName);
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual ParameterInfo GetParameterInfo(int index);
    public sealed virtual ParameterInfo GetParameterInfo(string parameterName);
    public sealed virtual string ParameterName(int index);
    public sealed virtual bool ContainsParameter(string parameterName);
    public sealed virtual int Add(object value);
    public sealed virtual bool Contains(object value);
    public sealed virtual void Clear();
    public sealed virtual int IndexOf(object value);
    public sealed virtual void Insert(int index, object value);
    public sealed virtual void Remove(object value);
    public sealed virtual void RemoveAt(int index);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsFixedSize();
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual object get_SyncRoot();
    public sealed virtual bool get_IsSynchronized();
    [IteratorStateMachineAttribute("Unity.Interception.PolicyInjection.Pipeline.ParameterCollection/<GetEnumerator>d__35")]
public sealed virtual IEnumerator GetEnumerator();
}
public class Unity.Interception.PolicyInjection.Pipeline.PipelineManager : object {
    private Dictionary`2<HandlerPipelineKey, HandlerPipeline> _pipelines;
    private static HandlerPipeline EmptyPipeline;
    private static ConcurrentDictionary`2<HandlerPipelineKey, MethodInfo> BaseMethodDefinitions;
    private static PipelineManager();
    public HandlerPipeline GetPipeline(MethodBase method);
    public void SetPipeline(MethodBase method, HandlerPipeline pipeline);
    public bool InitializePipeline(MethodImplementationInfo method, IEnumerable`1<ICallHandler> handlers);
    private HandlerPipeline CreatePipeline(MethodInfo method, IEnumerable`1<ICallHandler> handlers);
}
[AttributeUsageAttribute("196")]
public class Unity.Interception.PolicyInjection.Policies.ApplyNoPoliciesAttribute : Attribute {
}
public class Unity.Interception.PolicyInjection.Policies.AttributeDrivenPolicy : InjectionPolicy {
    private AttributeDrivenPolicyMatchingRule _attributeMatchRule;
    protected virtual bool DoesMatch(MethodImplementationInfo member);
    [IteratorStateMachineAttribute("Unity.Interception.PolicyInjection.Policies.AttributeDrivenPolicy/<DoGetHandlersFor>d__3")]
protected virtual IEnumerable`1<ICallHandler> DoGetHandlersFor(MethodImplementationInfo member, IUnityContainer container);
}
public abstract class Unity.Interception.PolicyInjection.Policies.HandlerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    public int Order { get; public set; }
    public abstract virtual ICallHandler CreateHandler(IUnityContainer container);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
}
public abstract class Unity.Interception.PolicyInjection.Policies.InjectionPolicy : object {
    private string _name;
    private IMatchingRule _doesNotHaveNoPoliciesAttributeRule;
    public string Name { get; }
    protected InjectionPolicy(string name);
    public string get_Name();
    public bool Matches(MethodImplementationInfo member);
    private bool DoesNotHaveNoPoliciesAttributeRule(MethodImplementationInfo method);
    [IteratorStateMachineAttribute("Unity.Interception.PolicyInjection.Policies.InjectionPolicy/<GetHandlersFor>d__8")]
public virtual IEnumerable`1<ICallHandler> GetHandlersFor(MethodImplementationInfo member, IUnityContainer container);
    protected static IEnumerable`1<MethodBase> GetMethodSet(MethodBase member);
    protected abstract virtual bool DoesMatch(MethodImplementationInfo member);
    protected abstract virtual IEnumerable`1<ICallHandler> DoGetHandlersFor(MethodImplementationInfo member, IUnityContainer container);
}
public class Unity.Interception.PolicyInjection.Policies.PolicySet : List`1<InjectionPolicy> {
    public PolicySet(InjectionPolicy[] policies);
    [IteratorStateMachineAttribute("Unity.Interception.PolicyInjection.Policies.PolicySet/<GetPoliciesFor>d__1")]
public IEnumerable`1<InjectionPolicy> GetPoliciesFor(MethodImplementationInfo member);
    public IEnumerable`1<InjectionPolicy> GetPoliciesNotFor(MethodImplementationInfo member);
    public IEnumerable`1<ICallHandler> GetHandlersFor(MethodImplementationInfo member, IUnityContainer container);
    internal static IEnumerable`1<ICallHandler> CalculateHandlersFor(IEnumerable`1<InjectionPolicy> policies, MethodImplementationInfo member, IUnityContainer container);
}
public class Unity.Interception.PolicyInjection.Policies.RuleDrivenPolicy : InjectionPolicy {
    private MatchingRuleSet _ruleSet;
    private IEnumerable`1<string> _callHandlerNames;
    public RuleDrivenPolicy(IMatchingRule[] matchingRules, String[] callHandlerNames);
    public RuleDrivenPolicy(string name, IMatchingRule[] matchingRules, String[] callHandlerNames);
    protected virtual bool DoesMatch(MethodImplementationInfo member);
    [IteratorStateMachineAttribute("Unity.Interception.PolicyInjection.Policies.RuleDrivenPolicy/<DoGetHandlersFor>d__5")]
protected virtual IEnumerable`1<ICallHandler> DoGetHandlersFor(MethodImplementationInfo member, IUnityContainer container);
}
public class Unity.Interception.PolicyInjection.PolicyInjectionBehavior : object {
    private PipelineManager _pipelineManager;
    public bool WillExecute { get; }
    public PolicyInjectionBehavior(PipelineManager pipelineManager);
    [InjectionConstructorAttribute]
public PolicyInjectionBehavior(CurrentInterceptionRequest interceptionRequest, InjectionPolicy[] policies, IUnityContainer container);
    public sealed virtual IMethodReturn Invoke(IMethodInvocation input, GetNextInterceptionBehaviorDelegate getNext);
    private HandlerPipeline GetPipeline(MethodBase method);
    public sealed virtual IEnumerable`1<Type> GetRequiredInterfaces();
    public sealed virtual bool get_WillExecute();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Unity.Interception.Properties.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ExceptionAbstractMethodNotImplemented { get; }
    internal static string ExceptionAdditionalInterfaceNotImplemented { get; }
    internal static string ExceptionAdditionalInterfacesInvalid { get; }
    internal static string ExceptionAttributeNoSubclassOfAttribute { get; }
    internal static string ExceptionCannotCreateInstance { get; }
    internal static string ExceptionCannotMapGenericTypeDefinition { get; }
    internal static string ExceptionContainsNullElement { get; }
    internal static string ExceptionMappedParametersDoNotMatch { get; }
    internal static string ExceptionNullInterfacesCollection { get; }
    internal static string ExceptionRequiredInterfacesInvalid { get; }
    internal static string ExceptionTypeIsNotInterface { get; }
    internal static string ExceptionTypeIsNull { get; }
    internal static string ExceptionTypeIsOpenGeneric { get; }
    internal static string InterceptionNotSupported { get; }
    internal static string InterfaceMethodNotImplemented { get; }
    internal static string NullBehavior { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ExceptionAbstractMethodNotImplemented();
    internal static string get_ExceptionAdditionalInterfaceNotImplemented();
    internal static string get_ExceptionAdditionalInterfacesInvalid();
    internal static string get_ExceptionAttributeNoSubclassOfAttribute();
    internal static string get_ExceptionCannotCreateInstance();
    internal static string get_ExceptionCannotMapGenericTypeDefinition();
    internal static string get_ExceptionContainsNullElement();
    internal static string get_ExceptionMappedParametersDoNotMatch();
    internal static string get_ExceptionNullInterfacesCollection();
    internal static string get_ExceptionRequiredInterfacesInvalid();
    internal static string get_ExceptionTypeIsNotInterface();
    internal static string get_ExceptionTypeIsNull();
    internal static string get_ExceptionTypeIsOpenGeneric();
    internal static string get_InterceptionNotSupported();
    internal static string get_InterfaceMethodNotImplemented();
    internal static string get_NullBehavior();
}
[ExtensionAttribute]
public static class Unity.Interception.Utilities.EnumerableExtensions : object {
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<TItem> sequence, Action`1<TItem> action);
    [ExtensionAttribute]
public static string JoinStrings(IEnumerable`1<TItem> sequence, string separator, Func`2<TItem, string> converter);
    [ExtensionAttribute]
public static string JoinStrings(IEnumerable`1<TItem> sequence, string separator);
}
public class Unity.Interception.Utilities.Glob : object {
    private Regex pattern;
    public Glob(string pattern);
    public Glob(string pattern, bool caseSensitive);
    public bool IsMatch(string s);
    private static Regex GlobPatternToRegex(string pattern, bool caseSensitive);
}
internal static class Unity.Interception.Utilities.Guard : object {
    public static void ArgumentNotNull(object argumentValue, string argumentName);
    public static void ArgumentNotNullOrEmpty(string argumentValue, string argumentName);
    public static void TypeIsAssignable(Type assignmentTargetType, Type assignmentValueType, string argumentName);
    public static void InstanceIsAssignable(Type assignmentTargetType, object assignmentInstance, string argumentName);
    private static string GetTypeName(object assignmentInstance);
}
public static class Unity.Interception.Utilities.Pair : object {
    public static Pair`2<TFirstParameter, TSecondParameter> Make(TFirstParameter first, TSecondParameter second);
}
public class Unity.Interception.Utilities.Pair`2 : object {
    [CompilerGeneratedAttribute]
private TFirst <First>k__BackingField;
    [CompilerGeneratedAttribute]
private TSecond <Second>k__BackingField;
    public TFirst First { get; }
    public TSecond Second { get; }
    public Pair`2(TFirst first, TSecond second);
    [CompilerGeneratedAttribute]
public TFirst get_First();
    [CompilerGeneratedAttribute]
public TSecond get_Second();
}
public static class Unity.Interception.Utilities.ReflectionHelper : object {
    public static MethodInfo ExceptionDispatchInfoCaptureMethod;
    public static MethodInfo ExceptionDispatchInfoThrowMethod;
    private static ReflectionHelper();
    public static PropertyInfo GetPropertyFromMethod(MethodBase method);
    public static PropertyInfo GetPropertyFromMethod(MethodInfo method);
    private static void GetPropertyTypes(MethodInfo method, bool isGetter, Type& propertyType, Type[]& indexerTypes);
    public static TAttribute[] GetAttributes(MemberInfo member, bool inherits);
    public static TAttribute[] GetAllAttributes(MemberInfo member, bool inherits);
}
public static class Unity.Interception.Utilities.Sequence : object {
    public static T[] Collect(T[] arguments);
    [IteratorStateMachineAttribute("Unity.Interception.Utilities.Sequence/<Zip>d__1`2")]
public static IEnumerable`1<Pair`2<TFirstSequenceElement, TSecondSequenceElement>> Zip(IEnumerable`1<TFirstSequenceElement> sequence1, IEnumerable`1<TSecondSequenceElement> sequence2);
}
public static class Unity.Interception.Utilities.StaticReflection : object {
    public static MethodInfo GetMethodInfo(Expression`1<Action> expression);
    public static MethodInfo GetMethodInfo(Expression`1<Action`1<T>> expression);
    private static MethodInfo GetMethodInfo(LambdaExpression lambda);
    public static MethodInfo GetPropertyGetMethodInfo(Expression`1<Func`2<T, TProperty>> expression);
    public static MethodInfo GetPropertySetMethodInfo(Expression`1<Func`2<T, TProperty>> expression);
    private static PropertyInfo GetPropertyInfo(LambdaExpression lambda);
    public static MemberInfo GetMemberInfo(Expression`1<Func`2<T, TProperty>> expression);
    public static ConstructorInfo GetConstructorInfo(Expression`1<Func`1<T>> expression);
    private static void GuardProperExpressionForm(Expression expression);
}
