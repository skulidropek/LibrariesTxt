internal abstract class Microsoft.CodeAnalysis.AbstractLinkedFileMergeConflictCommentAdditionService : object {
    internal abstract virtual string GetConflictCommentText(string header, string beforeString, string afterString);
    public sealed virtual IEnumerable`1<TextChange> CreateEdits(SourceText originalSourceText, IEnumerable`1<UnmergedDocumentChanges> unmergedChanges);
    private IEnumerable`1<IEnumerable`1<TextChange>> PartitionChangesForDocument(IEnumerable`1<TextChange> changes, SourceText originalSourceText);
    private List`1<TextChange> GetCommentChangesForDocument(IEnumerable`1<IEnumerable`1<TextChange>> partitionedChanges, string projectName, SourceText oldDocumentText);
    private string TrimBlankLines(SourceText text);
}
internal abstract class Microsoft.CodeAnalysis.AddImports.AbstractAddImportsService`4 : object {
    protected abstract virtual SyntaxNode GetAlias(TUsingOrAliasSyntax usingOrAlias);
    protected abstract virtual ImmutableArray`1<SyntaxNode> GetGlobalImports(Compilation compilation);
    protected abstract virtual SyntaxList`1<TUsingOrAliasSyntax> GetUsingsAndAliases(SyntaxNode node);
    protected abstract virtual SyntaxList`1<TExternSyntax> GetExterns(SyntaxNode node);
    private bool IsUsing(TUsingOrAliasSyntax usingOrAlias);
    private bool IsAlias(TUsingOrAliasSyntax usingOrAlias);
    private bool HasAliases(SyntaxNode node);
    private bool HasUsings(SyntaxNode node);
    private bool HasExterns(SyntaxNode node);
    private bool HasAnyImports(SyntaxNode node);
    public sealed virtual bool HasExistingImport(Compilation compilation, SyntaxNode root, SyntaxNode contextLocation, SyntaxNode import);
    private static ImmutableArray`1<SyntaxNode> GetAllContainers(SyntaxNode root, SyntaxNode contextLocation);
    private bool HasExistingImport(SyntaxNode import, ImmutableArray`1<SyntaxNode> containers, ImmutableArray`1<SyntaxNode> globalImports);
    public sealed virtual SyntaxNode GetImportContainer(SyntaxNode root, SyntaxNode contextLocation, SyntaxNode import);
    public sealed virtual SyntaxNode AddImports(Compilation compilation, SyntaxNode root, SyntaxNode contextLocation, IEnumerable`1<SyntaxNode> newImports, bool placeSystemNamespaceFirst);
    protected abstract virtual SyntaxNode Rewrite(TExternSyntax[] externAliases, TUsingOrAliasSyntax[] usingDirectives, TUsingOrAliasSyntax[] aliasDirectives, SyntaxNode externContainer, SyntaxNode usingContainer, SyntaxNode aliasContainer, bool placeSystemNamespaceFirst, SyntaxNode root);
    private void GetContainers(SyntaxNode root, SyntaxNode contextLocation, SyntaxNode& externContainer, SyntaxNode& usingContainer, SyntaxNode& aliasContainer);
    private static SyntaxNode GetFirstApplicableContainer(SyntaxNode contextNode);
}
internal static class Microsoft.CodeAnalysis.AddImports.AddImportHelpers : object {
    public static TRootSyntax MoveTrivia(ISyntaxFactsService syntaxFacts, TRootSyntax root, SyntaxList`1<TImportDirectiveSyntax> existingImports, List`1<TImportDirectiveSyntax> newImports);
    private static bool IsDocCommentOrElastic(ISyntaxFactsService syntaxFacts, SyntaxTrivia t);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.AddImports.IAddImportServiceExtensions : object {
    [ExtensionAttribute]
public static SyntaxNode AddImport(IAddImportsService service, Compilation compilation, SyntaxNode root, SyntaxNode contextLocation, SyntaxNode newImport, bool placeSystemNamespaceFirst);
}
internal interface Microsoft.CodeAnalysis.AddImports.IAddImportsService {
    public abstract virtual bool HasExistingImport(Compilation compilation, SyntaxNode root, SyntaxNode contextLocation, SyntaxNode import);
    public abstract virtual SyntaxNode GetImportContainer(SyntaxNode root, SyntaxNode contextLocation, SyntaxNode import);
    public abstract virtual SyntaxNode AddImports(Compilation compilation, SyntaxNode root, SyntaxNode contextLocation, IEnumerable`1<SyntaxNode> newImports, bool placeSystemNamespaceFirst);
}
public class Microsoft.CodeAnalysis.AdhocWorkspace : Workspace {
    public bool CanOpenDocuments { get; }
    public AdhocWorkspace(HostServices host, string workspaceKind);
    public virtual bool CanApplyChange(ApplyChangesKind feature);
    public virtual bool get_CanOpenDocuments();
    public void ClearSolution();
    public Solution AddSolution(SolutionInfo solutionInfo);
    public Project AddProject(string name, string language);
    public Project AddProject(ProjectInfo projectInfo);
    public void AddProjects(IEnumerable`1<ProjectInfo> projectInfos);
    public Document AddDocument(ProjectId projectId, string name, SourceText text);
    public Document AddDocument(DocumentInfo documentInfo);
    public virtual void OpenDocument(DocumentId documentId, bool activate);
    public virtual void CloseDocument(DocumentId documentId);
    public virtual void OpenAdditionalDocument(DocumentId documentId, bool activate);
    public virtual void CloseAdditionalDocument(DocumentId documentId);
}
internal abstract class Microsoft.CodeAnalysis.AnalyzerAssemblyLoader : object {
    private object _guard;
    private Dictionary`2<string, Assembly> _loadedAssembliesByPath;
    private Dictionary`2<string, AssemblyIdentity> _loadedAssemblyIdentitiesByPath;
    private Dictionary`2<AssemblyIdentity, Assembly> _loadedAssembliesByIdentity;
    private Dictionary`2<string, List`1<string>> _knownAssemblyPathsBySimpleName;
    protected abstract virtual Assembly LoadFromPathImpl(string fullPath);
    public sealed virtual void AddDependencyLocation(string fullPath);
    public sealed virtual Assembly LoadFromPath(string fullPath);
    private Assembly LoadFromPathUnchecked(string fullPath);
    private Assembly LoadFromPathUncheckedCore(string fullPath, AssemblyIdentity identity);
    private Assembly AddToCache(Assembly assembly, string fullPath, AssemblyIdentity identity);
    private AssemblyIdentity GetOrAddAssemblyIdentity(string fullPath);
    private AssemblyIdentity AddToCache(string fullPath, AssemblyIdentity identity);
    public Assembly Load(string displayName);
}
public enum Microsoft.CodeAnalysis.ApplyChangesKind : Enum {
    public int value__;
    public static ApplyChangesKind AddProject;
    public static ApplyChangesKind RemoveProject;
    public static ApplyChangesKind AddProjectReference;
    public static ApplyChangesKind RemoveProjectReference;
    public static ApplyChangesKind AddMetadataReference;
    public static ApplyChangesKind RemoveMetadataReference;
    public static ApplyChangesKind AddDocument;
    public static ApplyChangesKind RemoveDocument;
    public static ApplyChangesKind ChangeDocument;
    public static ApplyChangesKind AddAnalyzerReference;
    public static ApplyChangesKind RemoveAnalyzerReference;
    public static ApplyChangesKind AddAdditionalDocument;
    public static ApplyChangesKind RemoveAdditionalDocument;
    public static ApplyChangesKind ChangeAdditionalDocument;
    public static ApplyChangesKind ChangeCompilationOptions;
    public static ApplyChangesKind ChangeParseOptions;
    public static ApplyChangesKind ChangeDocumentInfo;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ArrayBuilderExtensions : object {
    [ExtensionAttribute]
public static bool Any(ArrayBuilder`1<T> builder, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Any(ArrayBuilder`1<T> builder, Func`3<T, A, bool> predicate, A arg);
    [ExtensionAttribute]
public static bool All(ArrayBuilder`1<T> builder, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ArrayBuilder`1<TItem> items, Func`2<TItem, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ArrayBuilder`1<TItem> items, Func`3<TItem, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static void AddOptional(ArrayBuilder`1<T> builder, T item);
    [ExtensionAttribute]
public static void Push(ArrayBuilder`1<T> builder, T e);
    [ExtensionAttribute]
public static T Pop(ArrayBuilder`1<T> builder);
    [ExtensionAttribute]
public static T Peek(ArrayBuilder`1<T> builder);
    [ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableOrEmptyAndFree(ArrayBuilder`1<T> builderOpt);
    [ExtensionAttribute]
public static void AddIfNotNull(ArrayBuilder`1<T> builder, Nullable`1<T> value);
    [ExtensionAttribute]
public static void AddIfNotNull(ArrayBuilder`1<T> builder, T value);
}
internal static class Microsoft.CodeAnalysis.AssemblyIdentityUtils : object {
    public static AssemblyIdentity TryGetAssemblyIdentity(string filePath);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.BitVector : ValueType {
    private static UInt32 ZeroWord;
    private static int Log2BitsPerWord;
    public static int BitsPerWord;
    private static UInt32[] s_emptyArray;
    private static BitVector s_nullValue;
    private static BitVector s_emptyValue;
    private UInt32 _bits0;
    private UInt32[] _bits;
    private int _capacity;
    public int Capacity { get; }
    public bool IsNull { get; }
    public static BitVector Null { get; }
    public static BitVector Empty { get; }
    public bool Item { get; public set; }
    private BitVector(UInt32 bits0, UInt32[] bits, int capacity);
    private static BitVector();
    public sealed virtual bool Equals(BitVector other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(BitVector left, BitVector right);
    public static bool op_Inequality(BitVector left, BitVector right);
    public virtual int GetHashCode();
    private static int WordsForCapacity(int capacity);
    public int get_Capacity();
    [ConditionalAttribute("DEBUG_BITARRAY")]
private void Check();
    public void EnsureCapacity(int newCapacity);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.BitVector/<Words>d__20")]
public IEnumerable`1<UInt32> Words();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.BitVector/<TrueBits>d__21")]
public IEnumerable`1<int> TrueBits();
    public static BitVector Create(int capacity);
    public static BitVector AllSet(int capacity);
    public BitVector Clone();
    public bool get_IsNull();
    public static BitVector get_Null();
    public static BitVector get_Empty();
    public bool IntersectWith(BitVector& other);
    public bool UnionWith(BitVector& other);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public void Clear();
    public static bool IsTrue(UInt32 word, int index);
    public static int WordsRequired(int capacity);
}
internal static class Microsoft.CodeAnalysis.Boxes : object {
    public static object BoxedTrue;
    public static object BoxedFalse;
    public static object BoxedByteZero;
    public static object BoxedSByteZero;
    public static object BoxedInt16Zero;
    public static object BoxedUInt16Zero;
    public static object BoxedInt32Zero;
    public static object BoxedInt32One;
    public static object BoxedUInt32Zero;
    public static object BoxedInt64Zero;
    public static object BoxedUInt64Zero;
    public static object BoxedSingleZero;
    public static object BoxedDoubleZero;
    public static object BoxedDecimalZero;
    private static Object[] s_boxedAsciiChars;
    private static Boxes();
    public static object Box(bool b);
    public static object Box(byte b);
    public static object Box(sbyte sb);
    public static object Box(short s);
    public static object Box(ushort us);
    public static object Box(int i);
    public static object Box(UInt32 u);
    public static object Box(long l);
    public static object Box(ulong ul);
    public static object Box(float f);
    public static object Box(double d);
    public static object Box(char c);
    public static object Box(decimal d);
}
internal class Microsoft.CodeAnalysis.BranchId : object {
    private static int s_nextId;
    private int _id;
    private BranchId(int id);
    internal static BranchId GetNextId();
}
internal abstract class Microsoft.CodeAnalysis.CaseCorrection.AbstractCaseCorrectionService : object {
    protected abstract virtual void AddReplacements(SemanticModel semanticModel, SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, ConcurrentDictionary`2<SyntaxToken, SyntaxToken> replacements, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CaseCorrection.AbstractCaseCorrectionService/<CaseCorrectAsync>d__1")]
public sealed virtual Task`1<Document> CaseCorrectAsync(Document document, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode CaseCorrect(SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
    private SyntaxNode CaseCorrect(SemanticModel semanticModel, SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector : object {
    public static SyntaxAnnotation Annotation;
    private static CaseCorrector();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector/<CaseCorrectAsync>d__1")]
public static Task`1<Document> CaseCorrectAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector/<CaseCorrectAsync>d__2")]
public static Task`1<Document> CaseCorrectAsync(Document document, SyntaxAnnotation annotation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector/<CaseCorrectAsync>d__3")]
public static Task`1<Document> CaseCorrectAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    public static Task`1<Document> CaseCorrectAsync(Document document, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    internal static SyntaxNode CaseCorrect(SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CaseCorrection.ICaseCorrectionService {
    public abstract virtual Task`1<Document> CaseCorrectAsync(Document document, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CaseCorrect(SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Checksum : object {
    private static int Sha1HashSize;
    public static Checksum Null;
    private Sha1Hash _checkSum;
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    public Checksum(Byte[] checksum);
    private Checksum(Sha1Hash hash);
    private static Checksum();
    public sealed virtual bool Equals(Checksum other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(Checksum left, Checksum right);
    public static bool op_Inequality(Checksum left, Checksum right);
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    public sealed virtual void WriteTo(ObjectWriter writer);
    public static Checksum ReadFrom(ObjectReader reader);
    public static string GetChecksumLogInfo(Checksum checksum);
    public static string GetChecksumsLogInfo(IEnumerable`1<Checksum> checksums);
    public static Checksum Create(Stream stream);
    private static Checksum ComputeChecksum(Stream stream, IncrementalHash hash);
    public static Checksum Create(WellKnownSynchronizationKind kind, IObjectWritable object);
    public static Checksum Create(WellKnownSynchronizationKind kind, IEnumerable`1<Checksum> checksums);
    public static Checksum Create(WellKnownSynchronizationKind kind, ImmutableArray`1<byte> bytes);
    public static Checksum Create(WellKnownSynchronizationKind kind, T value, ISerializerService serializer);
}
internal abstract class Microsoft.CodeAnalysis.Classification.AbstractClassificationService : object {
    public abstract virtual void AddLexicalClassifications(SourceText text, TextSpan textSpan, List`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual ClassifiedSpan AdjustStaleClassification(SourceText text, ClassifiedSpan classifiedSpan);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.AbstractClassificationService/<AddSemanticClassificationsAsync>d__2")]
public sealed virtual Task AddSemanticClassificationsAsync(Document document, TextSpan textSpan, List`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.AbstractClassificationService/<AddSyntacticClassificationsAsync>d__3")]
public sealed virtual Task AddSyntacticClassificationsAsync(Document document, TextSpan textSpan, List`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    protected void AddRange(ArrayBuilder`1<ClassifiedSpan> temp, List`1<ClassifiedSpan> result);
}
internal abstract class Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService : object {
    public abstract virtual void AddLexicalClassifications(SourceText text, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual void AddSyntacticClassifications(SyntaxTree syntaxTree, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<ISyntaxClassifier> GetDefaultSyntaxClassifiers();
    public abstract virtual ClassifiedSpan FixClassification(SourceText text, ClassifiedSpan classifiedSpan);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService/<AddSemanticClassificationsAsync>d__5")]
public sealed virtual Task AddSemanticClassificationsAsync(Document document, TextSpan textSpan, Func`2<SyntaxNode, ImmutableArray`1<ISyntaxClassifier>> getNodeClassifiers, Func`2<SyntaxToken, ImmutableArray`1<ISyntaxClassifier>> getTokenClassifiers, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public sealed virtual void AddSemanticClassifications(SemanticModel semanticModel, TextSpan textSpan, Workspace workspace, Func`2<SyntaxNode, ImmutableArray`1<ISyntaxClassifier>> getNodeClassifiers, Func`2<SyntaxToken, ImmutableArray`1<ISyntaxClassifier>> getTokenClassifiers, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Classification.ClassificationExtensions : object {
    [ExtensionAttribute]
public static string GetClassification(ITypeSymbol type);
}
public static class Microsoft.CodeAnalysis.Classification.ClassificationTypeNames : object {
    public static string Comment;
    public static string ExcludedCode;
    public static string Identifier;
    public static string Keyword;
    public static string NumericLiteral;
    public static string Operator;
    public static string PreprocessorKeyword;
    public static string StringLiteral;
    public static string WhiteSpace;
    public static string Text;
    public static string PreprocessorText;
    public static string Punctuation;
    public static string VerbatimStringLiteral;
    public static string ClassName;
    public static string DelegateName;
    public static string EnumName;
    public static string InterfaceName;
    public static string ModuleName;
    public static string StructName;
    public static string TypeParameterName;
    public static string FieldName;
    public static string EnumMemberName;
    public static string ConstantName;
    public static string LocalName;
    public static string ParameterName;
    public static string MethodName;
    public static string ExtensionMethodName;
    public static string PropertyName;
    public static string EventName;
    public static string XmlDocCommentAttributeName;
    public static string XmlDocCommentAttributeQuotes;
    public static string XmlDocCommentAttributeValue;
    public static string XmlDocCommentCDataSection;
    public static string XmlDocCommentComment;
    public static string XmlDocCommentDelimiter;
    public static string XmlDocCommentEntityReference;
    public static string XmlDocCommentName;
    public static string XmlDocCommentProcessingInstruction;
    public static string XmlDocCommentText;
    public static string XmlLiteralAttributeName;
    public static string XmlLiteralAttributeQuotes;
    public static string XmlLiteralAttributeValue;
    public static string XmlLiteralCDataSection;
    public static string XmlLiteralComment;
    public static string XmlLiteralDelimiter;
    public static string XmlLiteralEmbeddedExpression;
    public static string XmlLiteralEntityReference;
    public static string XmlLiteralName;
    public static string XmlLiteralProcessingInstruction;
    public static string XmlLiteralText;
}
public class Microsoft.CodeAnalysis.Classification.ClassifiedSpan : ValueType {
    [CompilerGeneratedAttribute]
private string <ClassificationType>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    public string ClassificationType { get; }
    public TextSpan TextSpan { get; }
    public ClassifiedSpan(string classificationType, TextSpan textSpan);
    public ClassifiedSpan(TextSpan textSpan, string classificationType);
    [CompilerGeneratedAttribute]
public string get_ClassificationType();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ClassifiedSpan other);
}
internal class Microsoft.CodeAnalysis.Classification.ClassifiedText : ValueType {
    [CompilerGeneratedAttribute]
private string <ClassificationType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string ClassificationType { get; }
    public string Text { get; }
    public ClassifiedText(string classificationType, string text);
    [CompilerGeneratedAttribute]
public string get_ClassificationType();
    [CompilerGeneratedAttribute]
public string get_Text();
}
public static class Microsoft.CodeAnalysis.Classification.Classifier : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.Classifier/<GetClassifiedSpansAsync>d__0")]
public static Task`1<IEnumerable`1<ClassifiedSpan>> GetClassifiedSpansAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    public static IEnumerable`1<ClassifiedSpan> GetClassifiedSpans(SemanticModel semanticModel, TextSpan textSpan, Workspace workspace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.Classifier/<GetClassifiedSymbolDisplayPartsAsync>d__2")]
internal static Task`1<ImmutableArray`1<SymbolDisplayPart>> GetClassifiedSymbolDisplayPartsAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.Classifier/<GetClassifiedSymbolDisplayPartsAsync>d__3")]
internal static Task`1<ImmutableArray`1<SymbolDisplayPart>> GetClassifiedSymbolDisplayPartsAsync(SemanticModel semanticModel, TextSpan textSpan, Workspace workspace, CancellationToken cancellationToken);
    internal static ImmutableArray`1<SymbolDisplayPart> ConvertClassificationsToParts(SourceText sourceText, int startPosition, IEnumerable`1<ClassifiedSpan> classifiedSpans);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Classification.Classifier/<Space>d__5")]
private static IEnumerable`1<SymbolDisplayPart> Space(int count);
    private static Nullable`1<SymbolDisplayPartKind> GetClassificationKind(string type);
}
internal interface Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier {
    public ImmutableArray`1<Type> SyntaxNodeTypes { get; }
    public ImmutableArray`1<int> SyntaxTokenKinds { get; }
    public abstract virtual ImmutableArray`1<Type> get_SyntaxNodeTypes();
    public abstract virtual ImmutableArray`1<int> get_SyntaxTokenKinds();
    public abstract virtual void AddClassifications(SyntaxNode node, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual void AddClassifications(SyntaxToken token, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Classification.IClassificationService {
    public abstract virtual void AddLexicalClassifications(SourceText text, TextSpan textSpan, List`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual Task AddSyntacticClassificationsAsync(Document document, TextSpan textSpan, List`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual Task AddSemanticClassificationsAsync(Document document, TextSpan textSpan, List`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual ClassifiedSpan AdjustStaleClassification(SourceText text, ClassifiedSpan classifiedSpan);
}
internal interface Microsoft.CodeAnalysis.Classification.ISyntaxClassificationService {
    public abstract virtual ImmutableArray`1<ISyntaxClassifier> GetDefaultSyntaxClassifiers();
    public abstract virtual void AddLexicalClassifications(SourceText text, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual void AddSyntacticClassifications(SyntaxTree syntaxTree, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual Task AddSemanticClassificationsAsync(Document document, TextSpan textSpan, Func`2<SyntaxNode, ImmutableArray`1<ISyntaxClassifier>> getNodeClassifiers, Func`2<SyntaxToken, ImmutableArray`1<ISyntaxClassifier>> getTokenClassifiers, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual void AddSemanticClassifications(SemanticModel semanticModel, TextSpan textSpan, Workspace workspace, Func`2<SyntaxNode, ImmutableArray`1<ISyntaxClassifier>> getNodeClassifiers, Func`2<SyntaxToken, ImmutableArray`1<ISyntaxClassifier>> getTokenClassifiers, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual ClassifiedSpan FixClassification(SourceText text, ClassifiedSpan classifiedSpan);
}
public class Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation : CodeActionOperation {
    [CompilerGeneratedAttribute]
private Solution <ChangedSolution>k__BackingField;
    public Solution ChangedSolution { get; }
    internal bool ApplyDuringTests { get; }
    public ApplyChangesOperation(Solution changedSolution);
    [CompilerGeneratedAttribute]
public Solution get_ChangedSolution();
    internal virtual bool get_ApplyDuringTests();
    public virtual void Apply(Workspace workspace, CancellationToken cancellationToken);
    internal virtual bool TryApply(Workspace workspace, IProgressTracker progressTracker, CancellationToken cancellationToken);
}
public abstract class Microsoft.CodeAnalysis.CodeActions.CodeAction : object {
    public string Title { get; }
    internal string Message { get; }
    public string EquivalenceKey { get; }
    internal bool IsInlinable { get; }
    internal CodeActionPriority Priority { get; }
    public ImmutableArray`1<string> Tags { get; }
    internal ImmutableArray`1<CodeAction> NestedCodeActions { get; }
    internal bool PerformFinalApplicabilityCheck { get; }
    public abstract virtual string get_Title();
    internal virtual string get_Message();
    public virtual string get_EquivalenceKey();
    internal virtual bool get_IsInlinable();
    internal virtual CodeActionPriority get_Priority();
    public virtual ImmutableArray`1<string> get_Tags();
    internal virtual ImmutableArray`1<CodeAction> get_NestedCodeActions();
    public Task`1<ImmutableArray`1<CodeActionOperation>> GetOperationsAsync(CancellationToken cancellationToken);
    internal Task`1<ImmutableArray`1<CodeActionOperation>> GetOperationsAsync(IProgressTracker progressTracker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<GetOperationsCoreAsync>d__16")]
internal virtual Task`1<ImmutableArray`1<CodeActionOperation>> GetOperationsCoreAsync(IProgressTracker progressTracker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<GetPreviewOperationsAsync>d__17")]
public Task`1<ImmutableArray`1<CodeActionOperation>> GetPreviewOperationsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<ComputeOperationsAsync>d__18")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<ComputeOperationsAsync>d__19")]
internal virtual Task`1<ImmutableArray`1<CodeActionOperation>> ComputeOperationsAsync(IProgressTracker progressTracker, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputePreviewOperationsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<GetChangedSolutionAsync>d__21")]
protected virtual Task`1<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken);
    internal virtual Task`1<Solution> GetChangedSolutionAsync(IProgressTracker progressTracker, CancellationToken cancellationToken);
    protected virtual Task`1<Document> GetChangedDocumentAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<GetChangedSolutionInternalAsync>d__24")]
internal Task`1<Solution> GetChangedSolutionInternalAsync(bool postProcessChanges, CancellationToken cancellationToken);
    internal Task`1<Document> GetChangedDocumentInternalAsync(CancellationToken cancellation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<PostProcessAsync>d__26")]
protected Task`1<ImmutableArray`1<CodeActionOperation>> PostProcessAsync(IEnumerable`1<CodeActionOperation> operations, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<PostProcessChangesAsync>d__27")]
protected Task`1<Solution> PostProcessChangesAsync(Solution changedSolution, CancellationToken cancellationToken);
    protected virtual Task`1<Document> PostProcessChangesAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<CleanupDocumentAsync>d__29")]
internal static Task`1<Document> CleanupDocumentAsync(Document document, CancellationToken cancellationToken);
    internal virtual bool get_PerformFinalApplicabilityCheck();
    internal virtual bool IsApplicable(Workspace workspace);
    public static CodeAction Create(string title, Func`2<CancellationToken, Task`1<Document>> createChangedDocument, string equivalenceKey);
    public static CodeAction Create(string title, Func`2<CancellationToken, Task`1<Solution>> createChangedSolution, string equivalenceKey);
}
public abstract class Microsoft.CodeAnalysis.CodeActions.CodeActionOperation : object {
    public string Title { get; }
    internal bool ApplyDuringTests { get; }
    public virtual string get_Title();
    public virtual void Apply(Workspace workspace, CancellationToken cancellationToken);
    internal virtual bool TryApply(Workspace workspace, IProgressTracker progressTracker, CancellationToken cancellationToken);
    internal virtual bool get_ApplyDuringTests();
}
internal enum Microsoft.CodeAnalysis.CodeActions.CodeActionPriority : Enum {
    public int value__;
    public static CodeActionPriority None;
    public static CodeActionPriority Low;
    public static CodeActionPriority Medium;
    public static CodeActionPriority High;
}
public abstract class Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions : CodeAction {
    public abstract virtual object GetOptions(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions/<GetOperationsAsync>d__1")]
public Task`1<IEnumerable`1<CodeActionOperation>> GetOperationsAsync(object options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions/<GetOperationsCoreAsync>d__2")]
internal virtual Task`1<ImmutableArray`1<CodeActionOperation>> GetOperationsCoreAsync(IProgressTracker progressTracker, CancellationToken cancellationToken);
    protected abstract virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(object options, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken);
}
public static class Microsoft.CodeAnalysis.CodeActions.ConflictAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create(string description);
    public static string GetDescription(SyntaxAnnotation annotation);
}
internal static class Microsoft.CodeAnalysis.CodeActions.NavigationAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create();
}
public class Microsoft.CodeAnalysis.CodeActions.OpenDocumentOperation : CodeActionOperation {
    private DocumentId _documentId;
    private bool _activate;
    public DocumentId DocumentId { get; }
    public OpenDocumentOperation(DocumentId documentId, bool activateIfAlreadyOpen);
    public DocumentId get_DocumentId();
    public virtual void Apply(Workspace workspace, CancellationToken cancellationToken);
}
public abstract class Microsoft.CodeAnalysis.CodeActions.PreviewOperation : CodeActionOperation {
    public abstract virtual Task`1<object> GetPreviewAsync(CancellationToken cancellationToken);
}
public static class Microsoft.CodeAnalysis.CodeActions.RenameAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create();
}
internal class Microsoft.CodeAnalysis.CodeActions.RenameDocumentOperation : CodeActionOperation {
    private DocumentId _oldDocumentId;
    private DocumentId _newDocumentId;
    private string _newFileName;
    private SourceText _text;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; }
    internal bool ApplyDuringTests { get; }
    public RenameDocumentOperation(DocumentId oldDocumentId, DocumentId newDocumentId, string newFileName, SourceText text);
    [CompilerGeneratedAttribute]
public virtual string get_Title();
    internal virtual bool get_ApplyDuringTests();
    internal virtual bool TryApply(Workspace workspace, IProgressTracker progressTracker, CancellationToken cancellationToken);
    public virtual void Apply(Workspace workspace, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CodeActions.SuppressDiagnosticsAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create();
}
public static class Microsoft.CodeAnalysis.CodeActions.WarningAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create(string description);
    public static string GetDescription(SyntaxAnnotation annotation);
}
internal abstract class Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService : object {
    public abstract virtual ImmutableArray`1<ICodeCleanupProvider> GetDefaultProviders();
    protected abstract virtual ImmutableArray`1<TextSpan> GetSpansToAvoid(SyntaxNode root);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService/<CleanupAsync>d__2")]
public sealed virtual Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService/<CleanupAsync>d__3")]
public sealed virtual Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    private ImmutableArray`1<TextSpan> GetTextSpansFromAnnotation(SyntaxNode node, List`1<ValueTuple`2<SyntaxAnnotation, SyntaxAnnotation>> annotations, CancellationToken cancellationToken);
    private bool TryGetTextSpanFromAnnotation(SpanMarker previousTokenMarker, SpanMarker nextTokenMarker, SyntaxNode node, IEnumerable`1<SyntaxToken> previousTokens, IEnumerable`1<SyntaxToken> nextTokens, TextSpan& span);
    private int GetPreviousTokenStartPosition(SpanMarkerType spanMarkerType, SyntaxToken previousToken);
    private int GetNextTokenEndPosition(SpanMarkerType spanMarkerType, SyntaxToken nextToken);
    private ValueTuple`2<SyntaxNode, List`1<ValueTuple`2<SyntaxAnnotation, SyntaxAnnotation>>> AnnotateNodeForTextSpans(ISyntaxFactsService syntaxFactsService, SyntaxNode root, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    private ImmutableArray`1<TextSpan> GetNonOverlappingSpans(ISyntaxFactsService syntaxFactsService, SyntaxNode root, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    private static void GetTokensAroundSpan(SyntaxNode root, TextSpan span, SyntaxToken& previousToken, SyntaxToken& startToken, SyntaxToken& endToken, SyntaxToken& nextToken);
    private TextSpan GetSpanAlignedToTokens(ISyntaxFactsService syntaxFactsService, SyntaxNode root, TextSpan span, SyntaxToken& startToken, SyntaxToken& endToken);
    private SyntaxToken FindTokenOnRightOfPosition(ISyntaxFactsService syntaxFactsService, SyntaxNode root, int position);
    private SyntaxToken FindTokenOnLeftOfPosition(ISyntaxFactsService syntaxFactsService, SyntaxNode root, int position);
    private bool CleanupWholeNode(List`1<ValueTuple`2<SyntaxAnnotation, SyntaxAnnotation>> annotations);
    private bool CleanupWholeNode(TextSpan nodeSpan, ImmutableArray`1<TextSpan> spans);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService/<IterateAllCodeCleanupProvidersAsync>d__16")]
private Task`1<Document> IterateAllCodeCleanupProvidersAsync(Document originalDocument, Document annotatedDocument, Func`2<SyntaxNode, ImmutableArray`1<TextSpan>> spanGetter, ImmutableArray`1<ICodeCleanupProvider> codeCleaners, CancellationToken cancellationToken);
    private ImmutableArray`1<TextSpan> GetSpans(SyntaxNode root, Func`2<SyntaxNode, ImmutableArray`1<TextSpan>> spanGetter);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService/<IterateAllCodeCleanupProvidersAsync>d__18")]
private Task`1<SyntaxNode> IterateAllCodeCleanupProvidersAsync(SyntaxNode originalRoot, SyntaxNode annotatedRoot, Func`2<SyntaxNode, ImmutableArray`1<TextSpan>> spanGetter, Workspace workspace, ImmutableArray`1<ICodeCleanupProvider> codeCleaners, CancellationToken cancellationToken);
    private string GetCodeCleanerTypeName(ICodeCleanupProvider codeCleaner);
    private SyntaxNode InjectAnnotations(SyntaxNode node, Dictionary`2<SyntaxToken, List`1<SyntaxAnnotation>> map);
    private bool TryCreateTextSpan(int start, int end, TextSpan& span);
}
internal static class Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner : object {
    public static ImmutableArray`1<ICodeCleanupProvider> GetDefaultProviders(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner/<CleanupAsync>d__1")]
public static Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner/<CleanupAsync>d__2")]
public static Task`1<Document> CleanupAsync(Document document, SyntaxAnnotation annotation, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    public static Task`1<Document> CleanupAsync(Document document, TextSpan span, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    public static Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    public static Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, TextSpan span, Workspace workspace, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    public static Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService {
    public abstract virtual ImmutableArray`1<ICodeCleanupProvider> GetDefaultProviders();
    public abstract virtual Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    public abstract virtual Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.ExportCodeCleanupProvider : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Languages>k__BackingField;
    public string Name { get; }
    public IEnumerable`1<string> Languages { get; }
    public ExportCodeCleanupProvider(string name, String[] languages);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Languages();
}
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.FormatCodeCleanupProvider : object {
    public string Name { get; }
    public sealed virtual string get_Name();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.Providers.FormatCodeCleanupProvider/<CleanupAsync>d__2")]
public sealed virtual Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.Providers.FormatCodeCleanupProvider/<CleanupAsync>d__3")]
public sealed virtual Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    public abstract virtual Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CodeCleanup.Providers.PredefinedCodeCleanupProviderNames : object {
    public static string Simplification;
    public static string CaseCorrection;
    public static string AddMissingTokens;
    public static string NormalizeModifiersOrOperators;
    public static string RemoveUnnecessaryLineContinuation;
    public static string Format;
    public static string FixIncorrectTokens;
    public static string ReduceTokens;
}
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.SimpleCodeCleanupProvider : object {
    private Func`4<Document, ImmutableArray`1<TextSpan>, CancellationToken, Task`1<Document>> _documentDelegatee;
    private Func`5<SyntaxNode, ImmutableArray`1<TextSpan>, Workspace, CancellationToken, SyntaxNode> _syntaxDelegatee;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public SimpleCodeCleanupProvider(string name, Func`4<Document, ImmutableArray`1<TextSpan>, CancellationToken, Task`1<Document>> documentDelegatee, Func`5<SyntaxNode, ImmutableArray`1<TextSpan>, Workspace, CancellationToken, SyntaxNode> syntaxDelegatee);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.Providers.SimpleCodeCleanupProvider/<CleanupCoreAsync>d__7")]
private Task`1<Document> CleanupCoreAsync(Document document, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    public sealed virtual Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.SimplificationCodeCleanupProvider : object {
    public string Name { get; }
    public sealed virtual string get_Name();
    public sealed virtual Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    public sealed virtual Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider : FixAllProvider {
    public static FixAllProvider Instance;
    private static Func`2<DocumentId, ConcurrentBag`1<ValueTuple`2<CodeAction, Document>>> s_getValue;
    private static BatchFixAllProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<GetFixAsync>d__2")]
public virtual Task`1<CodeAction> GetFixAsync(FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<GetFixAsync>d__3")]
internal virtual Task`1<CodeAction> GetFixAsync(ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> documentsAndDiagnosticsToFixMap, FixAllState fixAllState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<GetDiagnosticsAndCodeActions>d__4")]
private Task`1<ImmutableArray`1<ValueTuple`2<Diagnostic, CodeAction>>> GetDiagnosticsAndCodeActions(ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> documentsAndDiagnosticsToFixMap, FixAllState fixAllState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<AddDocumentFixesAsync>d__5")]
protected virtual Task AddDocumentFixesAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, ConcurrentBag`1<ValueTuple`2<Diagnostic, CodeAction>> fixes, FixAllState fixAllState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<GetFixAsync>d__6")]
internal virtual Task`1<CodeAction> GetFixAsync(ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>> projectsAndDiagnosticsToFixMap, FixAllState fixAllState, CancellationToken cancellationToken);
    private static Action`2<CodeAction, ImmutableArray`1<Diagnostic>> GetRegisterCodeFixAction(FixAllState fixAllState, ConcurrentBag`1<ValueTuple`2<Diagnostic, CodeAction>> result);
    protected virtual Task AddProjectFixesAsync(Project project, ImmutableArray`1<Diagnostic> diagnostics, ConcurrentBag`1<ValueTuple`2<Diagnostic, CodeAction>> fixes, FixAllState fixAllState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<TryGetMergedFixAsync>d__9")]
public virtual Task`1<CodeAction> TryGetMergedFixAsync(ImmutableArray`1<ValueTuple`2<Diagnostic, CodeAction>> batchOfFixes, FixAllState fixAllState, CancellationToken cancellationToken);
    public virtual string GetFixAllTitle(FixAllState fixAllState);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<TryMergeFixesAsync>d__11")]
public virtual Task`1<Solution> TryMergeFixesAsync(Solution oldSolution, ImmutableArray`1<ValueTuple`2<Diagnostic, CodeAction>> diagnosticsAndCodeActions, FixAllState fixAllState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<GetDocumentIdToChangedDocuments>d__12")]
private Task`1<IReadOnlyDictionary`2<DocumentId, ConcurrentBag`1<ValueTuple`2<CodeAction, Document>>>> GetDocumentIdToChangedDocuments(Solution oldSolution, ImmutableArray`1<ValueTuple`2<Diagnostic, CodeAction>> diagnosticsAndCodeActions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<GetDocumentIdToFinalTextAsync>d__13")]
private Task`1<IReadOnlyDictionary`2<DocumentId, SourceText>> GetDocumentIdToFinalTextAsync(Solution oldSolution, IReadOnlyDictionary`2<DocumentId, ConcurrentBag`1<ValueTuple`2<CodeAction, Document>>> documentIdToChangedDocuments, ImmutableArray`1<ValueTuple`2<Diagnostic, CodeAction>> diagnosticsAndCodeActions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<GetFinalDocumentTextAsync>d__14")]
private Task GetFinalDocumentTextAsync(Solution oldSolution, Dictionary`2<CodeAction, int> codeActionToDiagnosticLocation, ConcurrentDictionary`2<DocumentId, SourceText> documentIdToFinalText, IEnumerable`1<ValueTuple`2<CodeAction, Document>> changedDocuments, CancellationToken cancellationToken);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Text.TextChange>.GetStart(TextChange value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Text.TextChange>.GetLength(TextChange value);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<GetChangedDocumentsAsync>d__18")]
private Task GetChangedDocumentsAsync(Solution oldSolution, ConcurrentDictionary`2<DocumentId, ConcurrentBag`1<ValueTuple`2<CodeAction, Document>>> documentIdToChangedDocuments, CodeAction codeAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<TryAddDocumentMergeChangesAsync>d__19")]
private static Task TryAddDocumentMergeChangesAsync(IDocumentTextDifferencingService differenceService, Document oldDocument, Document newDocument, SimpleIntervalTree`1<TextChange> cumulativeChanges, CancellationToken cancellationToken);
    private static bool AllChangesCanBeApplied(SimpleIntervalTree`1<TextChange> cumulativeChanges, ImmutableArray`1<TextChange> currentChanges);
    private static bool AllChangesCanBeApplied(SimpleIntervalTree`1<TextChange> cumulativeChanges, ImmutableArray`1<TextChange> currentChanges, ArrayBuilder`1<TextChange> overlappingSpans, ArrayBuilder`1<TextChange> intersectingSpans);
    private static bool ChangeCanBeApplied(TextChange change, ArrayBuilder`1<TextChange> overlappingSpans, ArrayBuilder`1<TextChange> intersectingSpans);
    private static bool IsPureInsertion(TextChange change);
    private static bool PureInsertionChangeCanBeApplied(TextChange change, ArrayBuilder`1<TextChange> overlappingSpans, ArrayBuilder`1<TextChange> intersectingSpans);
    private static bool OverwriteChangeCanBeApplied(TextChange change, ArrayBuilder`1<TextChange> overlappingSpans, ArrayBuilder`1<TextChange> intersectingSpans);
    private static bool OverwriteChangeConflictsWithOverlappingSpans(TextChange change, ArrayBuilder`1<TextChange> overlappingSpans);
    private static bool OverwriteChangeConflictsWithIntersectingSpans(TextChange change, ArrayBuilder`1<TextChange> intersectingSpans);
}
internal class Microsoft.CodeAnalysis.CodeFixes.CodeFix : object {
    internal Project Project;
    internal CodeAction Action;
    internal ImmutableArray`1<Diagnostic> Diagnostics;
    internal Diagnostic PrimaryDiagnostic { get; }
    internal CodeFix(Project project, CodeAction action, Diagnostic diagnostic);
    internal CodeFix(Project project, CodeAction action, ImmutableArray`1<Diagnostic> diagnostics);
    internal Diagnostic get_PrimaryDiagnostic();
}
public class Microsoft.CodeAnalysis.CodeFixes.CodeFixContext : ValueType {
    private Document _document;
    private Project _project;
    private TextSpan _span;
    private ImmutableArray`1<Diagnostic> _diagnostics;
    private CancellationToken _cancellationToken;
    private Action`2<CodeAction, ImmutableArray`1<Diagnostic>> _registerCodeFix;
    public Document Document { get; }
    internal Project Project { get; }
    public TextSpan Span { get; }
    public ImmutableArray`1<Diagnostic> Diagnostics { get; }
    public CancellationToken CancellationToken { get; }
    public CodeFixContext(Document document, TextSpan span, ImmutableArray`1<Diagnostic> diagnostics, Action`2<CodeAction, ImmutableArray`1<Diagnostic>> registerCodeFix, CancellationToken cancellationToken);
    public CodeFixContext(Document document, Diagnostic diagnostic, Action`2<CodeAction, ImmutableArray`1<Diagnostic>> registerCodeFix, CancellationToken cancellationToken);
    internal CodeFixContext(Document document, TextSpan span, ImmutableArray`1<Diagnostic> diagnostics, Action`2<CodeAction, ImmutableArray`1<Diagnostic>> registerCodeFix, bool verifyArguments, CancellationToken cancellationToken);
    internal CodeFixContext(Project project, ImmutableArray`1<Diagnostic> diagnostics, Action`2<CodeAction, ImmutableArray`1<Diagnostic>> registerCodeFix, CancellationToken cancellationToken);
    private CodeFixContext(Document document, Project project, TextSpan span, ImmutableArray`1<Diagnostic> diagnostics, Action`2<CodeAction, ImmutableArray`1<Diagnostic>> registerCodeFix, bool verifyArguments, CancellationToken cancellationToken);
    internal CodeFixContext(Document document, Diagnostic diagnostic, Action`2<CodeAction, ImmutableArray`1<Diagnostic>> registerCodeFix, bool verifyArguments, CancellationToken cancellationToken);
    public Document get_Document();
    internal Project get_Project();
    public TextSpan get_Span();
    public ImmutableArray`1<Diagnostic> get_Diagnostics();
    public CancellationToken get_CancellationToken();
    public void RegisterCodeFix(CodeAction action, Diagnostic diagnostic);
    public void RegisterCodeFix(CodeAction action, IEnumerable`1<Diagnostic> diagnostics);
    public void RegisterCodeFix(CodeAction action, ImmutableArray`1<Diagnostic> diagnostics);
    private static void VerifyDiagnosticsArgument(ImmutableArray`1<Diagnostic> diagnostics, TextSpan span);
}
public abstract class Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider : object {
    public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    public abstract virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    public abstract virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    public virtual FixAllProvider GetFixAllProvider();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Languages>k__BackingField;
    public string Name { get; public set; }
    public String[] Languages { get; }
    public ExportCodeFixProviderAttribute(string firstLanguage, String[] additionalLanguages);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public String[] get_Languages();
}
public class Microsoft.CodeAnalysis.CodeFixes.FixAllContext : object {
    [CompilerGeneratedAttribute]
private FixAllState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgressTracker <ProgressTracker>k__BackingField;
    internal FixAllState State { get; }
    internal FixAllProvider FixAllProvider { get; }
    public Solution Solution { get; }
    public Project Project { get; }
    public Document Document { get; }
    public CodeFixProvider CodeFixProvider { get; }
    public FixAllScope Scope { get; }
    public ImmutableHashSet`1<string> DiagnosticIds { get; }
    public string CodeActionEquivalenceKey { get; }
    public CancellationToken CancellationToken { get; }
    internal IProgressTracker ProgressTracker { get; }
    public FixAllContext(Document document, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable`1<string> diagnosticIds, DiagnosticProvider fixAllDiagnosticProvider, CancellationToken cancellationToken);
    public FixAllContext(Project project, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable`1<string> diagnosticIds, DiagnosticProvider fixAllDiagnosticProvider, CancellationToken cancellationToken);
    internal FixAllContext(FixAllState state, IProgressTracker progressTracker, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal FixAllState get_State();
    internal FixAllProvider get_FixAllProvider();
    public Solution get_Solution();
    public Project get_Project();
    public Document get_Document();
    public CodeFixProvider get_CodeFixProvider();
    public FixAllScope get_Scope();
    public ImmutableHashSet`1<string> get_DiagnosticIds();
    public string get_CodeActionEquivalenceKey();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
internal IProgressTracker get_ProgressTracker();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FixAllContext/<GetDocumentDiagnosticsAsync>d__28")]
public Task`1<ImmutableArray`1<Diagnostic>> GetDocumentDiagnosticsAsync(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FixAllContext/<GetFilteredDiagnosticsAsync>d__29")]
private static Task`1<ImmutableArray`1<Diagnostic>> GetFilteredDiagnosticsAsync(Task`1<IEnumerable`1<Diagnostic>> getDiagnosticsTask, ImmutableHashSet`1<string> diagnosticIds);
    public Task`1<ImmutableArray`1<Diagnostic>> GetProjectDiagnosticsAsync(Project project);
    public Task`1<ImmutableArray`1<Diagnostic>> GetAllDiagnosticsAsync(Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FixAllContext/<GetProjectDiagnosticsAsync>d__32")]
private Task`1<ImmutableArray`1<Diagnostic>> GetProjectDiagnosticsAsync(Project project, bool includeAllDocumentDiagnostics);
    public FixAllContext WithCancellationToken(CancellationToken cancellationToken);
    internal Task`1<ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>>> GetDocumentDiagnosticsToFixAsync();
    internal Task`1<ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>>> GetProjectDiagnosticsToFixAsync();
}
internal static class Microsoft.CodeAnalysis.CodeFixes.FixAllLogger : object {
    public static string CorrelationId;
    private static string CodeFixProvider;
    private static string CodeActionEquivalenceKey;
    public static string FixAllScope;
    private static string LanguageName;
    private static string DocumentCount;
    private static string Result;
    private static string Completed;
    private static string TimedOut;
    private static string Cancelled;
    private static string AllChangesApplied;
    private static string SubsetOfChangesApplied;
    private static string DocumentsWithDiagnosticsToFix;
    private static string ProjectsWithDiagnosticsToFix;
    private static string TotalDiagnosticsToFix;
    private static string TotalFixesToMerge;
    public static void LogState(FixAllState fixAllState, bool isInternalCodeFixProvider);
    public static void LogComputationResult(int correlationId, bool completed, bool timedOut);
    public static void LogPreviewChangesResult(Nullable`1<int> correlationId, bool applied, bool allChangesApplied);
    public static void LogDiagnosticsStats(int correlationId, ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> documentsAndDiagnosticsToFixMap);
    public static void LogDiagnosticsStats(int correlationId, ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>> projectsAndDiagnosticsToFixMap);
    public static void LogFixesToMergeStats(FunctionId functionId, int correlationId, int count);
    public static LogMessage CreateCorrelationLogMessage(int correlationId);
}
public abstract class Microsoft.CodeAnalysis.CodeFixes.FixAllProvider : object {
    public virtual IEnumerable`1<FixAllScope> GetSupportedFixAllScopes();
    public virtual IEnumerable`1<string> GetSupportedFixAllDiagnosticIds(CodeFixProvider originalCodeFixProvider);
    public abstract virtual Task`1<CodeAction> GetFixAsync(FixAllContext fixAllContext);
    internal virtual Task`1<CodeAction> GetFixAsync(ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> documentsAndDiagnosticsToFixMap, FixAllState fixAllState, CancellationToken cancellationToken);
    internal virtual Task`1<CodeAction> GetFixAsync(ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>> projectsAndDiagnosticsToFixMap, FixAllState fixAllState, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CodeFixes.FixAllProviderInfo : object {
    public FixAllProvider FixAllProvider;
    public ImmutableArray`1<FixAllScope> SupportedScopes;
    private FixAllProviderInfo(FixAllProvider fixAllProvider, ImmutableArray`1<FixAllScope> supportedScopes);
    public static FixAllProviderInfo Create(object provider);
    private static FixAllProviderInfo CreateWithCodeFixer(CodeFixProvider provider);
    private static FixAllProviderInfo CreateWithSuppressionFixer(ISuppressionFixProvider provider);
    public abstract virtual bool CanBeFixed(Diagnostic diagnostic);
}
public enum Microsoft.CodeAnalysis.CodeFixes.FixAllScope : Enum {
    public int value__;
    public static FixAllScope Document;
    public static FixAllScope Project;
    public static FixAllScope Solution;
    public static FixAllScope Custom;
}
internal class Microsoft.CodeAnalysis.CodeFixes.FixAllState : object {
    internal int CorrelationId;
    [CompilerGeneratedAttribute]
private DiagnosticProvider <DiagnosticProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private FixAllProvider <FixAllProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CodeActionEquivalenceKey>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeFixProvider <CodeFixProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <DiagnosticIds>k__BackingField;
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private FixAllScope <Scope>k__BackingField;
    internal DiagnosticProvider DiagnosticProvider { get; }
    public FixAllProvider FixAllProvider { get; }
    public string CodeActionEquivalenceKey { get; }
    public CodeFixProvider CodeFixProvider { get; }
    public ImmutableHashSet`1<string> DiagnosticIds { get; }
    public Document Document { get; }
    public Project Project { get; }
    public FixAllScope Scope { get; }
    public Solution Solution { get; }
    internal bool IsFixMultiple { get; }
    internal FixAllState(FixAllProvider fixAllProvider, Document document, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable`1<string> diagnosticIds, DiagnosticProvider fixAllDiagnosticProvider);
    internal FixAllState(FixAllProvider fixAllProvider, Project project, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable`1<string> diagnosticIds, DiagnosticProvider fixAllDiagnosticProvider);
    private FixAllState(FixAllProvider fixAllProvider, Document document, Project project, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable`1<string> diagnosticIds, DiagnosticProvider fixAllDiagnosticProvider);
    [CompilerGeneratedAttribute]
internal DiagnosticProvider get_DiagnosticProvider();
    [CompilerGeneratedAttribute]
public FixAllProvider get_FixAllProvider();
    [CompilerGeneratedAttribute]
public string get_CodeActionEquivalenceKey();
    [CompilerGeneratedAttribute]
public CodeFixProvider get_CodeFixProvider();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<string> get_DiagnosticIds();
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public Project get_Project();
    [CompilerGeneratedAttribute]
public FixAllScope get_Scope();
    public Solution get_Solution();
    internal bool get_IsFixMultiple();
    public FixAllState WithScopeAndEquivalenceKey(FixAllScope scope, string codeActionEquivalenceKey);
    public FixAllContext CreateFixAllContext(IProgressTracker progressTracker, CancellationToken cancellationToken);
    internal string GetDefaultFixAllTitle();
    internal static FixAllState Create(FixAllProvider fixAllProvider, ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> diagnosticsToFix, CodeFixProvider codeFixProvider, string codeActionEquivalenceKey);
    internal static FixAllState Create(FixAllProvider fixAllProvider, ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>> diagnosticsToFix, CodeFixProvider codeFixProvider, string codeActionEquivalenceKey);
    private static ImmutableHashSet`1<string> GetDiagnosticsIds(IEnumerable`1<ImmutableArray`1<Diagnostic>> diagnosticsCollection);
}
internal interface Microsoft.CodeAnalysis.CodeFixes.Suppression.ISuppressionFixProvider {
    public abstract virtual bool CanBeSuppressedOrUnsuppressed(Diagnostic diagnostic);
    public abstract virtual Task`1<ImmutableArray`1<CodeFix>> GetSuppressionsAsync(Document document, TextSpan span, IEnumerable`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<CodeFix>> GetSuppressionsAsync(Project project, IEnumerable`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    public abstract virtual FixAllProvider GetFixAllProvider();
}
internal abstract class Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider : CodeFixProvider {
    private bool _supportsFixAll;
    protected SyntaxEditorBasedCodeFixProvider(bool supportsFixAll);
    public sealed virtual FixAllProvider GetFixAllProvider();
    protected Task`1<Document> FixAsync(Document document, Diagnostic diagnostic, CancellationToken cancellationToken);
    private Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider/<FixAllWithEditorAsync>d__5")]
protected Task`1<Document> FixAllWithEditorAsync(Document document, Func`2<SyntaxEditor, Task> editAsync, CancellationToken cancellationToken);
    protected abstract virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CancellationToken cancellationToken);
    protected virtual bool IncludeDiagnosticDuringFixAll(FixAllState fixAllState, Diagnostic diagnostic);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
}
public static class Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders : object {
    public static FixAllProvider BatchFixer { get; }
    public static FixAllProvider get_BatchFixer();
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService : object {
    private ISymbolDeclarationService _symbolDeclarationService;
    protected Workspace Workspace;
    protected AbstractCodeGenerationService(ISymbolDeclarationService symbolDeclarationService, Workspace workspace);
    public sealed virtual TDeclarationNode AddEvent(TDeclarationNode destination, IEventSymbol event, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddField(TDeclarationNode destination, IFieldSymbol field, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddMethod(TDeclarationNode destination, IMethodSymbol method, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddProperty(TDeclarationNode destination, IPropertySymbol property, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddNamedType(TDeclarationNode destination, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddNamespace(TDeclarationNode destination, INamespaceSymbol namespace, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<ISymbol> members, CodeGenerationOptions options, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddEvent(TDeclarationNode destination, IEventSymbol event, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected abstract virtual TDeclarationNode AddField(TDeclarationNode destination, IFieldSymbol field, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected abstract virtual TDeclarationNode AddMethod(TDeclarationNode destination, IMethodSymbol method, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected abstract virtual TDeclarationNode AddProperty(TDeclarationNode destination, IPropertySymbol property, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected abstract virtual TDeclarationNode AddNamedType(TDeclarationNode destination, INamedTypeSymbol namedType, CodeGenerationOptions options, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddNamespace(TDeclarationNode destination, INamespaceSymbol namespace, CodeGenerationOptions options, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<SyntaxNode> members);
    public abstract virtual TDeclarationNode AddParameters(TDeclarationNode destinationMember, IEnumerable`1<IParameterSymbol> parameters, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddAttributes(TDeclarationNode destination, IEnumerable`1<AttributeData> attributes, Nullable`1<SyntaxToken> target, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, SyntaxNode attributeToRemove, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, AttributeData attributeToRemove, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddStatements(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, IEnumerable`1<SyntaxToken> newModifiers, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationAccessibility(TDeclarationNode declaration, Accessibility newAccessibility, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationType(TDeclarationNode declaration, ITypeSymbol newType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationMembers(TDeclarationNode declaration, IList`1<ISymbol> newMembers, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual CodeGenerationDestination GetDestination(SyntaxNode node);
    public abstract virtual SyntaxNode CreateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreateFieldDeclaration(IFieldSymbol field, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreatePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreateNamedTypeDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateNamespaceDeclaration(INamespaceSymbol namespace, CodeGenerationDestination destination, CodeGenerationOptions options, CancellationToken cancellationToken);
    protected abstract virtual AbstractImportsAdder CreateImportsAdder(Document document);
    protected static T Cast(object value);
    protected static void CheckDeclarationNode(SyntaxNode destination);
    protected static void CheckDeclarationNode(SyntaxNode destination);
    protected static void CheckDeclarationNode(SyntaxNode destination);
    protected static void CheckDeclarationNode(SyntaxNode destination);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService/<GetEditAsync>d__39")]
private Task`1<Document> GetEditAsync(Solution solution, INamespaceOrTypeSymbol destination, Func`5<SyntaxNode, CodeGenerationOptions, IList`1<bool>, CancellationToken, SyntaxNode> declarationTransform, CodeGenerationOptions options, IEnumerable`1<ISymbol> members, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService/<AddImportsAsync>d__40")]
public sealed virtual Task`1<Document> AddImportsAsync(Document document, CodeGenerationOptions options, CancellationToken cancellationToken);
    protected TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<ISymbol> members, IList`1<bool> availableIndices, CodeGenerationOptions options, CancellationToken cancellationToken);
    private TDeclarationSyntax AddMembersToEndOfDestination(TDeclarationSyntax destination, IEnumerable`1<ISymbol> members, IList`1<bool> availableIndices, CodeGenerationOptions options, CancellationToken cancellationToken);
    private TDeclarationSyntax AddMembersToAppropiateLocationInDestination(TDeclarationSyntax destination, IEnumerable`1<ISymbol> members, IList`1<bool> availableIndices, CodeGenerationOptions options, CancellationToken cancellationToken);
    private SyntaxNode GetNewMember(CodeGenerationOptions options, CodeGenerationDestination codeGenerationDestination, ISymbol member, CancellationToken cancellationToken);
    private TDeclarationNode UpdateDestination(IList`1<bool> availableIndices, CodeGenerationOptions options, TDeclarationNode currentDestination, ISymbol member, CancellationToken cancellationToken);
    private bool GeneratingEnum(IEnumerable`1<ISymbol> members);
    protected abstract virtual IComparer`1<SyntaxNode> GetMemberComparer();
    protected static CodeGenerationOptions CreateOptionsForMultipleMembers(CodeGenerationOptions options);
    public virtual Task`1<Document> AddEventAsync(Solution solution, INamedTypeSymbol destination, IEventSymbol event, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddFieldAsync(Solution solution, INamedTypeSymbol destination, IFieldSymbol field, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddPropertyAsync(Solution solution, INamedTypeSymbol destination, IPropertySymbol property, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddNamedTypeAsync(Solution solution, INamedTypeSymbol destination, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddNamedTypeAsync(Solution solution, INamespaceSymbol destination, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddNamespaceAsync(Solution solution, INamespaceSymbol destination, INamespaceSymbol namespace, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddMethodAsync(Solution solution, INamedTypeSymbol destination, IMethodSymbol method, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddMembersAsync(Solution solution, INamedTypeSymbol destination, IEnumerable`1<ISymbol> members, CodeGenerationOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddNamespaceOrTypeAsync(Solution solution, INamespaceSymbol destination, INamespaceOrTypeSymbol namespaceOrType, CodeGenerationOptions options, CancellationToken cancellationToken);
    protected static void CheckLocation(TDeclarationNode destinationMember, Location location);
    protected static void ComputePositionAndTriviaForRemoveAttributeList(SyntaxNode attributeList, Func`2<SyntaxTrivia, bool> isEndOfLineTrivia, Int32& positionOfRemovedNode, IEnumerable`1& triviaOfRemovedNode);
    protected static void ComputePositionAndTriviaForRemoveAttributeFromAttributeList(SyntaxNode attributeToRemove, Func`2<SyntaxToken, bool> isComma, Int32& positionOfRemovedNode, IEnumerable`1& triviaOfRemovedNode);
    protected static T AppendTriviaAtPosition(T node, int position, SyntaxTriviaList trivia);
    protected static IList`1<SyntaxToken> GetUpdatedDeclarationAccessibilityModifiers(IList`1<SyntaxToken> newModifierTokens, SyntaxTokenList modifiersList, Func`2<SyntaxToken, bool> isAccessibilityModifier);
    protected abstract virtual IList`1<bool> GetAvailableInsertionIndices(SyntaxNode destination, CancellationToken cancellationToken);
    private IList`1<bool> GetAvailableInsertionIndices(TDeclarationNode destination, CancellationToken cancellationToken);
    public sealed virtual bool CanAddTo(ISymbol destination, Solution solution, CancellationToken cancellationToken);
    protected static SyntaxToken GetEndToken(SyntaxNode node);
    protected static TextSpan GetSpan(SyntaxNode node);
    public sealed virtual bool CanAddTo(SyntaxNode destination, Solution solution, CancellationToken cancellationToken);
    private bool CanAddTo(SyntaxNode destination, Solution solution, CancellationToken cancellationToken, IList`1& availableIndices, bool checkGeneratedCode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService/<FindMostRelevantDeclarationAsync>d__70")]
private Task`1<ValueTuple`2<SyntaxNode, IList`1<bool>>> FindMostRelevantDeclarationAsync(Solution solution, INamespaceOrTypeSymbol namespaceOrType, CodeGenerationOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService/<SelectFirstOrDefaultAsync>d__71")]
private static Task`1<SyntaxNode> SelectFirstOrDefaultAsync(IEnumerable`1<SyntaxReference> references, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.AbstractFlagsEnumGenerator : object {
    protected abstract virtual SyntaxGenerator GetSyntaxGenerator();
    protected abstract virtual SyntaxNode CreateExplicitlyCastedLiteralValue(INamedTypeSymbol enumType, SpecialType underlyingSpecialType, object constantValue);
    protected abstract virtual bool IsValidName(INamedTypeSymbol enumType, string name);
    internal SyntaxNode CreateEnumConstantValue(INamedTypeSymbol enumType, object constantValue);
    private bool IsFlagsEnum(INamedTypeSymbol typeSymbol);
    private SyntaxNode CreateFlagsEnumConstantValue(INamedTypeSymbol enumType, object constantValue);
    private SyntaxNode CreateFlagsEnumConstantValue(INamedTypeSymbol enumType, object constantValue, List`1<ValueTuple`2<IFieldSymbol, ulong>> allFieldsAndValues, List`1<ValueTuple`2<IFieldSymbol, ulong>> usedFieldsAndValues);
    private SyntaxNode CreateMemberAccessExpression(IFieldSymbol field, INamedTypeSymbol enumType, SpecialType underlyingSpecialType);
    private IFieldSymbol GetZeroField(List`1<ValueTuple`2<IFieldSymbol, ulong>> allFieldsAndValues);
    private void GetSortedEnumFieldsAndValues(INamedTypeSymbol enumType, List`1<ValueTuple`2<IFieldSymbol, ulong>> allFieldsAndValues);
    private SyntaxNode CreateNonFlagsEnumConstantValue(INamedTypeSymbol enumType, object constantValue);
    private sealed virtual override int System.Collections.Generic.IComparer<(Microsoft.CodeAnalysis.IFieldSymbolfield,System.UInt64value)>.Compare(ValueTuple`2<IFieldSymbol, ulong> x, ValueTuple`2<IFieldSymbol, ulong> y);
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.AbstractImportsAdder : object {
    protected Document Document;
    protected AbstractImportsAdder(Document document);
    protected abstract virtual IList`1<INamespaceSymbol> GetExistingNamespaces(SemanticModel semanticModel, SyntaxNode namespaceScope, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode GetImportsContainer(SyntaxNode node);
    protected abstract virtual SyntaxNode GetInnermostNamespaceScope(SyntaxNodeOrToken node);
    public abstract virtual Task`1<Document> AddAsync(bool placeSystemNamespaceFirst, CodeGenerationOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractImportsAdder/<GetAllReferencedDefinitionsAsync>d__6")]
protected Task`1<IDictionary`2<SyntaxNode, ISet`1<INamedTypeSymbol>>> GetAllReferencedDefinitionsAsync(Compilation compilation, CancellationToken cancellationToken);
    private bool IsBuiltIn(INamedTypeSymbol type);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractImportsAdder/<DetermineNamespaceToImportAsync>d__8")]
protected Task`1<IDictionary`2<SyntaxNode, IList`1<INamespaceSymbol>>> DetermineNamespaceToImportAsync(CodeGenerationOptions options, CancellationToken cancellationToken);
    private void AddMissingNamespaces(SemanticModel semanticModel, Dictionary`2<SyntaxNode, IList`1<INamespaceSymbol>> importsContainerToMissingImports, SyntaxNode namespaceScope, IEnumerable`1<INamespaceSymbol> referencedNamespaces, CancellationToken cancellationToken);
    protected virtual bool CouldCauseAmbiguity(ISet`1<INamespaceSymbol> currentImportedNamespaces, INamespaceSymbol namespaceToImport);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractImportsAdder/<GetContainingNamespacesAndThis>d__11")]
protected static IEnumerable`1<INamespaceSymbol> GetContainingNamespacesAndThis(INamespaceSymbol namespaceSymbol);
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationAbstractMethodSymbol : CodeGenerationSymbol {
    [CompilerGeneratedAttribute]
private IMethodSymbol <OriginalDefinition>k__BackingField;
    private ImmutableArray`1<AttributeData> _returnTypeAttributes;
    public IMethodSymbol OriginalDefinition { get; protected set; }
    public int Arity { get; }
    public bool ReturnsVoid { get; }
    public bool ReturnsByRef { get; }
    public bool ReturnsByRefReadonly { get; }
    public RefKind RefKind { get; }
    public ITypeSymbol ReturnType { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public IMethodSymbol ConstructedFrom { get; }
    public IMethodSymbol OverriddenMethod { get; }
    public IMethodSymbol ReducedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> ExplicitInterfaceImplementations { get; }
    public IMethodSymbol PartialDefinitionPart { get; }
    public IMethodSymbol PartialImplementationPart { get; }
    public ITypeSymbol ReceiverType { get; }
    public MethodKind MethodKind { get; }
    public SymbolKind Kind { get; }
    public bool IsGenericMethod { get; }
    public bool IsExtensionMethod { get; }
    public bool IsAsync { get; }
    public bool IsVararg { get; }
    public bool IsCheckedBuiltin { get; }
    public bool HidesBaseMethodsByName { get; }
    public ImmutableArray`1<CustomModifier> RefCustomModifiers { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ISymbol AssociatedSymbol { get; }
    public INamedTypeSymbol AssociatedAnonymousDelegate { get; }
    protected CodeGenerationAbstractMethodSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name, ImmutableArray`1<AttributeData> returnTypeAttributes);
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_OriginalDefinition();
    [CompilerGeneratedAttribute]
protected void set_OriginalDefinition(IMethodSymbol value);
    public virtual ImmutableArray`1<AttributeData> GetReturnTypeAttributes();
    public abstract virtual int get_Arity();
    public abstract virtual bool get_ReturnsVoid();
    public abstract virtual bool get_ReturnsByRef();
    public abstract virtual bool get_ReturnsByRefReadonly();
    public abstract virtual RefKind get_RefKind();
    public abstract virtual ITypeSymbol get_ReturnType();
    public abstract virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public abstract virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public abstract virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    public abstract virtual IMethodSymbol get_ConstructedFrom();
    public abstract virtual IMethodSymbol get_OverriddenMethod();
    public abstract virtual IMethodSymbol get_ReducedFrom();
    public abstract virtual ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    public abstract virtual IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType);
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_ExplicitInterfaceImplementations();
    public abstract virtual IMethodSymbol get_PartialDefinitionPart();
    public abstract virtual IMethodSymbol get_PartialImplementationPart();
    public virtual ITypeSymbol get_ReceiverType();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual MethodKind get_MethodKind();
    public virtual SymbolKind get_Kind();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsExtensionMethod();
    public virtual bool get_IsAsync();
    public virtual bool get_IsVararg();
    public sealed virtual bool get_IsCheckedBuiltin();
    public virtual bool get_HidesBaseMethodsByName();
    public sealed virtual ImmutableArray`1<CustomModifier> get_RefCustomModifiers();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ISymbol get_AssociatedSymbol();
    public sealed virtual INamedTypeSymbol get_AssociatedAnonymousDelegate();
    public sealed virtual IMethodSymbol Construct(ITypeSymbol[] typeArguments);
    public sealed virtual DllImportData GetDllImportData();
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationAbstractNamedTypeSymbol : CodeGenerationTypeSymbol {
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <OriginalDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IFieldSymbol> <TupleElements>k__BackingField;
    internal ImmutableArray`1<CodeGenerationAbstractNamedTypeSymbol> TypeMembers;
    [CompilerGeneratedAttribute]
private ISymbol <AssociatedSymbol>k__BackingField;
    public INamedTypeSymbol OriginalDefinition { get; protected set; }
    public ImmutableArray`1<IFieldSymbol> TupleElements { get; protected set; }
    public SymbolKind Kind { get; }
    public int Arity { get; }
    public bool IsGenericType { get; }
    public bool IsUnboundGenericType { get; }
    public bool IsScriptClass { get; }
    public bool IsImplicitClass { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IMethodSymbol DelegateInvokeMethod { get; }
    public INamedTypeSymbol EnumUnderlyingType { get; }
    public INamedTypeSymbol ConstructedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> InstanceConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> StaticConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> Constructors { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public string MetadataName { get; }
    public ISymbol AssociatedSymbol { get; internal set; }
    public bool MightContainExtensionMethods { get; }
    public bool IsComImport { get; }
    protected CodeGenerationAbstractNamedTypeSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name, SpecialType specialType, ImmutableArray`1<CodeGenerationAbstractNamedTypeSymbol> typeMembers);
    [CompilerGeneratedAttribute]
public sealed virtual INamedTypeSymbol get_OriginalDefinition();
    [CompilerGeneratedAttribute]
protected void set_OriginalDefinition(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IFieldSymbol> get_TupleElements();
    [CompilerGeneratedAttribute]
protected void set_TupleElements(ImmutableArray`1<IFieldSymbol> value);
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual INamedTypeSymbol Construct(ITypeSymbol[] typeArguments);
    public abstract virtual int get_Arity();
    public abstract virtual bool get_IsGenericType();
    public abstract virtual bool get_IsUnboundGenericType();
    public abstract virtual bool get_IsScriptClass();
    public abstract virtual bool get_IsImplicitClass();
    public abstract virtual IEnumerable`1<string> get_MemberNames();
    public abstract virtual IMethodSymbol get_DelegateInvokeMethod();
    public abstract virtual INamedTypeSymbol get_EnumUnderlyingType();
    public abstract virtual INamedTypeSymbol get_ConstructedFrom();
    public abstract virtual INamedTypeSymbol ConstructUnboundGenericType();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_InstanceConstructors();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_StaticConstructors();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_Constructors();
    public abstract virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public sealed virtual ImmutableArray`1<CustomModifier> GetTypeArgumentCustomModifiers(int ordinal);
    public abstract virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public virtual string get_MetadataName();
    [CompilerGeneratedAttribute]
public sealed virtual ISymbol get_AssociatedSymbol();
    [CompilerGeneratedAttribute]
internal void set_AssociatedSymbol(ISymbol value);
    public sealed virtual bool get_MightContainExtensionMethods();
    public sealed virtual bool get_IsComImport();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationArrayTypeSymbol : CodeGenerationTypeSymbol {
    [CompilerGeneratedAttribute]
private ITypeSymbol <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rank>k__BackingField;
    public ITypeSymbol ElementType { get; }
    public int Rank { get; }
    public bool IsSZArray { get; }
    public ImmutableArray`1<int> Sizes { get; }
    public ImmutableArray`1<int> LowerBounds { get; }
    public TypeKind TypeKind { get; }
    public SymbolKind Kind { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public CodeGenerationArrayTypeSymbol(ITypeSymbol elementType, int rank);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_ElementType();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Rank();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual ImmutableArray`1<int> get_Sizes();
    public sealed virtual ImmutableArray`1<int> get_LowerBounds();
    protected virtual CodeGenerationSymbol Clone();
    public virtual TypeKind get_TypeKind();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public sealed virtual bool Equals(IArrayTypeSymbol other);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationAttributeData : AttributeData {
    private INamedTypeSymbol _attributeClass;
    private ImmutableArray`1<TypedConstant> _constructorArguments;
    private ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> _namedArguments;
    protected INamedTypeSymbol CommonAttributeClass { get; }
    protected IMethodSymbol CommonAttributeConstructor { get; }
    protected ImmutableArray`1<TypedConstant> CommonConstructorArguments { get; }
    protected ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> CommonNamedArguments { get; }
    protected SyntaxReference CommonApplicationSyntaxReference { get; }
    public CodeGenerationAttributeData(INamedTypeSymbol attributeClass, ImmutableArray`1<TypedConstant> constructorArguments, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments);
    protected virtual INamedTypeSymbol get_CommonAttributeClass();
    protected virtual IMethodSymbol get_CommonAttributeConstructor();
    protected virtual ImmutableArray`1<TypedConstant> get_CommonConstructorArguments();
    protected virtual ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> get_CommonNamedArguments();
    protected virtual SyntaxReference get_CommonApplicationSyntaxReference();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConstructedMethodSymbol : CodeGenerationAbstractMethodSymbol {
    private CodeGenerationAbstractMethodSymbol _constructedFrom;
    private ITypeSymbol[] _typeArguments;
    public int Arity { get; }
    public bool ReturnsVoid { get; }
    public bool ReturnsByRef { get; }
    public RefKind RefKind { get; }
    public bool ReturnsByRefReadonly { get; }
    public ITypeSymbol ReturnType { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public IMethodSymbol ConstructedFrom { get; }
    public IMethodSymbol OverriddenMethod { get; }
    public IMethodSymbol ReducedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> ExplicitInterfaceImplementations { get; }
    public IMethodSymbol PartialDefinitionPart { get; }
    public IMethodSymbol PartialImplementationPart { get; }
    public CodeGenerationConstructedMethodSymbol(CodeGenerationAbstractMethodSymbol constructedFrom, ITypeSymbol[] typeArguments);
    public virtual int get_Arity();
    public virtual bool get_ReturnsVoid();
    public virtual bool get_ReturnsByRef();
    public virtual RefKind get_RefKind();
    public virtual bool get_ReturnsByRefReadonly();
    public virtual ITypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    public virtual IMethodSymbol get_ConstructedFrom();
    public virtual IMethodSymbol get_OverriddenMethod();
    public virtual IMethodSymbol get_ReducedFrom();
    public virtual ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    public virtual IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType);
    public virtual ImmutableArray`1<IMethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual IMethodSymbol get_PartialDefinitionPart();
    public virtual IMethodSymbol get_PartialImplementationPart();
    protected virtual CodeGenerationSymbol Clone();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConstructedNamedTypeSymbol : CodeGenerationAbstractNamedTypeSymbol {
    private CodeGenerationAbstractNamedTypeSymbol _constructedFrom;
    private ImmutableArray`1<ITypeSymbol> _typeArguments;
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public int Arity { get; }
    public bool IsGenericType { get; }
    public bool IsUnboundGenericType { get; }
    public bool IsScriptClass { get; }
    public bool IsImplicitClass { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IMethodSymbol DelegateInvokeMethod { get; }
    public INamedTypeSymbol EnumUnderlyingType { get; }
    public INamedTypeSymbol ConstructedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> InstanceConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> StaticConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> Constructors { get; }
    public TypeKind TypeKind { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public CodeGenerationConstructedNamedTypeSymbol(CodeGenerationAbstractNamedTypeSymbol constructedFrom, ImmutableArray`1<ITypeSymbol> typeArguments, ImmutableArray`1<CodeGenerationAbstractNamedTypeSymbol> typeMembers);
    public virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public virtual int get_Arity();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsUnboundGenericType();
    public virtual bool get_IsScriptClass();
    public virtual bool get_IsImplicitClass();
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual IMethodSymbol get_DelegateInvokeMethod();
    public virtual INamedTypeSymbol get_EnumUnderlyingType();
    public virtual INamedTypeSymbol get_ConstructedFrom();
    public virtual INamedTypeSymbol ConstructUnboundGenericType();
    public virtual ImmutableArray`1<IMethodSymbol> get_InstanceConstructors();
    public virtual ImmutableArray`1<IMethodSymbol> get_StaticConstructors();
    public virtual ImmutableArray`1<IMethodSymbol> get_Constructors();
    public virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers();
    public virtual TypeKind get_TypeKind();
    protected virtual CodeGenerationSymbol Clone();
    public virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConstructorInfo : object {
    private static ConditionalWeakTable`2<IMethodSymbol, CodeGenerationConstructorInfo> s_constructorToInfoMap;
    private string _typeName;
    private ImmutableArray`1<SyntaxNode> _baseConstructorArguments;
    private ImmutableArray`1<SyntaxNode> _thisConstructorArguments;
    private ImmutableArray`1<SyntaxNode> _statements;
    private CodeGenerationConstructorInfo(string typeName, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> baseConstructorArguments, ImmutableArray`1<SyntaxNode> thisConstructorArguments);
    private static CodeGenerationConstructorInfo();
    public static void Attach(IMethodSymbol constructor, string typeName, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> baseConstructorArguments, ImmutableArray`1<SyntaxNode> thisConstructorArguments);
    private static CodeGenerationConstructorInfo GetInfo(IMethodSymbol method);
    public static ImmutableArray`1<SyntaxNode> GetThisConstructorArgumentsOpt(IMethodSymbol constructor);
    public static ImmutableArray`1<SyntaxNode> GetBaseConstructorArgumentsOpt(IMethodSymbol constructor);
    public static ImmutableArray`1<SyntaxNode> GetStatements(IMethodSymbol constructor);
    public static string GetTypeName(IMethodSymbol constructor);
    private static ImmutableArray`1<SyntaxNode> GetThisConstructorArgumentsOpt(CodeGenerationConstructorInfo info);
    private static ImmutableArray`1<SyntaxNode> GetBaseConstructorArgumentsOpt(CodeGenerationConstructorInfo info);
    private static ImmutableArray`1<SyntaxNode> GetStatements(CodeGenerationConstructorInfo info);
    private static string GetTypeName(CodeGenerationConstructorInfo info, IMethodSymbol constructor);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConstructorSymbol : CodeGenerationMethodSymbol {
    public MethodKind MethodKind { get; }
    public CodeGenerationConstructorSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ImmutableArray`1<IParameterSymbol> parameters);
    public virtual MethodKind get_MethodKind();
    protected virtual CodeGenerationSymbol Clone();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConversionSymbol : CodeGenerationMethodSymbol {
    public MethodKind MethodKind { get; }
    public CodeGenerationConversionSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, ITypeSymbol toType, IParameterSymbol fromType, bool isImplicit, ImmutableArray`1<AttributeData> toTypeAttributes);
    public virtual MethodKind get_MethodKind();
}
internal enum Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination : Enum {
    public int value__;
    public static CodeGenerationDestination Unspecified;
    public static CodeGenerationDestination CompilationUnit;
    public static CodeGenerationDestination Namespace;
    public static CodeGenerationDestination ClassType;
    public static CodeGenerationDestination EnumType;
    public static CodeGenerationDestination InterfaceType;
    public static CodeGenerationDestination ModuleType;
    public static CodeGenerationDestination StructType;
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestructorInfo : object {
    private static ConditionalWeakTable`2<IMethodSymbol, CodeGenerationDestructorInfo> s_destructorToInfoMap;
    private string _typeName;
    private ImmutableArray`1<SyntaxNode> _statements;
    private CodeGenerationDestructorInfo(string typeName, ImmutableArray`1<SyntaxNode> statements);
    private static CodeGenerationDestructorInfo();
    public static void Attach(IMethodSymbol destructor, string typeName, ImmutableArray`1<SyntaxNode> statements);
    private static CodeGenerationDestructorInfo GetInfo(IMethodSymbol method);
    public static ImmutableArray`1<SyntaxNode> GetStatements(IMethodSymbol destructor);
    public static string GetTypeName(IMethodSymbol destructor);
    private static ImmutableArray`1<SyntaxNode> GetStatements(CodeGenerationDestructorInfo info);
    private static string GetTypeName(CodeGenerationDestructorInfo info, IMethodSymbol constructor);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestructorSymbol : CodeGenerationMethodSymbol {
    public MethodKind MethodKind { get; }
    public CodeGenerationDestructorSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes);
    public virtual MethodKind get_MethodKind();
    protected virtual CodeGenerationSymbol Clone();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationEventInfo : object {
    private static ConditionalWeakTable`2<IEventSymbol, CodeGenerationEventInfo> s_eventToInfoMap;
    private bool _isUnsafe;
    private CodeGenerationEventInfo(bool isUnsafe);
    private static CodeGenerationEventInfo();
    public static void Attach(IEventSymbol event, bool isUnsafe);
    private static CodeGenerationEventInfo GetInfo(IEventSymbol event);
    public static bool GetIsUnsafe(IEventSymbol event);
    private static bool GetIsUnsafe(CodeGenerationEventInfo info);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationEventSymbol : CodeGenerationSymbol {
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IEventSymbol> <ExplicitInterfaceImplementations>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <AddMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <RemoveMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <RaiseMethod>k__BackingField;
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IEventSymbol> ExplicitInterfaceImplementations { get; }
    public IMethodSymbol AddMethod { get; }
    public IMethodSymbol RemoveMethod { get; }
    public IMethodSymbol RaiseMethod { get; }
    public SymbolKind Kind { get; }
    public IEventSymbol OriginalDefinition { get; }
    public bool IsWindowsRuntimeEvent { get; }
    public IEventSymbol OverriddenEvent { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public CodeGenerationEventSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, ITypeSymbol type, ImmutableArray`1<IEventSymbol> explicitInterfaceImplementations, string name, IMethodSymbol addMethod, IMethodSymbol removeMethod, IMethodSymbol raiseMethod);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IEventSymbol> get_ExplicitInterfaceImplementations();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_AddMethod();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_RemoveMethod();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_RaiseMethod();
    protected virtual CodeGenerationSymbol Clone();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual IEventSymbol get_OriginalDefinition();
    public sealed virtual bool get_IsWindowsRuntimeEvent();
    public sealed virtual IEventSymbol get_OverriddenEvent();
    public ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationFieldInfo : object {
    private static ConditionalWeakTable`2<IFieldSymbol, CodeGenerationFieldInfo> s_fieldToInfoMap;
    private bool _isUnsafe;
    private bool _isWithEvents;
    private SyntaxNode _initializer;
    private CodeGenerationFieldInfo(bool isUnsafe, bool isWithEvents, SyntaxNode initializer);
    private static CodeGenerationFieldInfo();
    public static void Attach(IFieldSymbol field, bool isUnsafe, bool isWithEvents, SyntaxNode initializer);
    private static CodeGenerationFieldInfo GetInfo(IFieldSymbol field);
    private static bool GetIsUnsafe(CodeGenerationFieldInfo info);
    public static bool GetIsUnsafe(IFieldSymbol field);
    private static bool GetIsWithEvents(CodeGenerationFieldInfo info);
    public static bool GetIsWithEvents(IFieldSymbol field);
    private static SyntaxNode GetInitializer(CodeGenerationFieldInfo info);
    public static SyntaxNode GetInitializer(IFieldSymbol field);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationFieldSymbol : CodeGenerationSymbol {
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ConstantValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasConstantValue>k__BackingField;
    public ITypeSymbol Type { get; }
    public object ConstantValue { get; }
    public bool HasConstantValue { get; }
    public IFieldSymbol OriginalDefinition { get; }
    public IFieldSymbol CorrespondingTupleField { get; }
    public SymbolKind Kind { get; }
    public bool IsConst { get; }
    public bool IsReadOnly { get; }
    public bool IsVolatile { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public ISymbol AssociatedSymbol { get; }
    public CodeGenerationFieldSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, string name, bool hasConstantValue, object constantValue);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual object get_ConstantValue();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasConstantValue();
    protected virtual CodeGenerationSymbol Clone();
    public sealed virtual IFieldSymbol get_OriginalDefinition();
    public sealed virtual IFieldSymbol get_CorrespondingTupleField();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual bool get_IsConst();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public sealed virtual ISymbol get_AssociatedSymbol();
}
internal static class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationHelpers : object {
    public static SyntaxNode GenerateThrowStatement(SyntaxGenerator factory, SemanticDocument document, string exceptionMetadataName, CancellationToken cancellationToken);
    public static TSyntaxNode AddAnnotationsTo(ISymbol symbol, TSyntaxNode syntax);
    public static TSyntaxNode AddFormatterAndCodeGeneratorAnnotationsTo(TSyntaxNode node);
    public static void CheckNodeType(SyntaxNode node, string argumentName);
    public static void GetNameAndInnermostNamespace(INamespaceSymbol namespace, CodeGenerationOptions options, String& name, INamespaceSymbol& innermostNamespace);
    public static bool IsSpecialType(ITypeSymbol type, SpecialType specialType);
    public static int GetPreferredIndex(int index, IList`1<bool> availableIndices, bool forward);
    public static bool TryGetDocumentationComment(ISymbol symbol, string commentToken, String& comment, CancellationToken cancellationToken);
    public static bool TypesMatch(ITypeSymbol type, object value);
    public static IEnumerable`1<ISymbol> GetMembers(INamedTypeSymbol namedType);
    public static T GetReuseableSyntaxNodeForSymbol(ISymbol symbol, CodeGenerationOptions options);
    public static T GetReuseableSyntaxNodeForAttribute(AttributeData attribute, CodeGenerationOptions options);
    public static int GetInsertionIndex(SyntaxList`1<TDeclaration> declarationList, TDeclaration declaration, CodeGenerationOptions options, IList`1<bool> availableIndices, IComparer`1<TDeclaration> comparerWithoutNameCheck, IComparer`1<TDeclaration> comparerWithNameCheck, Func`2<SyntaxList`1<TDeclaration>, TDeclaration> after, Func`2<SyntaxList`1<TDeclaration>, TDeclaration> before);
    public static Nullable`1<int> TryGetDesiredIndexIfGrouped(SyntaxList`1<TDeclarationSyntax> declarationList, TDeclarationSyntax declaration, IList`1<bool> availableIndices, IComparer`1<TDeclarationSyntax> comparerWithoutNameCheck, IComparer`1<TDeclarationSyntax> comparerWithNameCheck);
    private static Nullable`1<int> TryGetDesiredIndexIfGroupedWorker(SyntaxList`1<TDeclarationSyntax> declarationList, TDeclarationSyntax declaration, IList`1<bool> availableIndices, IComparer`1<TDeclarationSyntax> comparerWithoutNameCheck, IComparer`1<TDeclarationSyntax> comparerWithNameCheck);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationMethodInfo : object {
    private static ConditionalWeakTable`2<IMethodSymbol, CodeGenerationMethodInfo> s_methodToInfoMap;
    private bool _isNew;
    private bool _isUnsafe;
    private bool _isPartial;
    private bool _isAsync;
    private ImmutableArray`1<SyntaxNode> _statements;
    private ImmutableArray`1<SyntaxNode> _handlesExpressions;
    private CodeGenerationMethodInfo(bool isNew, bool isUnsafe, bool isPartial, bool isAsync, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> handlesExpressions);
    private static CodeGenerationMethodInfo();
    public static void Attach(IMethodSymbol method, bool isNew, bool isUnsafe, bool isPartial, bool isAsync, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> handlesExpressions);
    private static CodeGenerationMethodInfo GetInfo(IMethodSymbol method);
    public static ImmutableArray`1<SyntaxNode> GetStatements(IMethodSymbol method);
    public static ImmutableArray`1<SyntaxNode> GetHandlesExpressions(IMethodSymbol method);
    public static bool GetIsNew(IMethodSymbol method);
    public static bool GetIsUnsafe(IMethodSymbol method);
    public static bool GetIsPartial(IMethodSymbol method);
    public static bool GetIsAsync(IMethodSymbol method);
    private static ImmutableArray`1<SyntaxNode> GetStatements(CodeGenerationMethodInfo info);
    private static ImmutableArray`1<SyntaxNode> GetHandlesExpressions(CodeGenerationMethodInfo info);
    private static bool GetIsNew(CodeGenerationMethodInfo info);
    private static bool GetIsUnsafe(CodeGenerationMethodInfo info);
    private static bool GetIsPartial(CodeGenerationMethodInfo info);
    private static bool GetIsAsync(CodeGenerationMethodInfo info);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationMethodSymbol : CodeGenerationAbstractMethodSymbol {
    [CompilerGeneratedAttribute]
private ITypeSymbol <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ITypeParameterSymbol> <TypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IParameterSymbol> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMethodSymbol> <ExplicitInterfaceImplementations>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodKind <MethodKind>k__BackingField;
    [CompilerGeneratedAttribute]
private RefKind <RefKind>k__BackingField;
    public ITypeSymbol ReturnType { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public ImmutableArray`1<IMethodSymbol> ExplicitInterfaceImplementations { get; }
    public MethodKind MethodKind { get; }
    public int Arity { get; }
    public bool ReturnsVoid { get; }
    public bool ReturnsByRef { get; }
    public bool ReturnsByRefReadonly { get; }
    public RefKind RefKind { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public IMethodSymbol ConstructedFrom { get; }
    public IMethodSymbol OverriddenMethod { get; }
    public IMethodSymbol ReducedFrom { get; }
    public IMethodSymbol PartialImplementationPart { get; }
    public IMethodSymbol PartialDefinitionPart { get; }
    public CodeGenerationMethodSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, RefKind refKind, ImmutableArray`1<IMethodSymbol> explicitInterfaceImplementations, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<AttributeData> returnTypeAttributes, MethodKind methodKind);
    [CompilerGeneratedAttribute]
public virtual ITypeSymbol get_ReturnType();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IMethodSymbol> get_ExplicitInterfaceImplementations();
    [CompilerGeneratedAttribute]
public virtual MethodKind get_MethodKind();
    protected virtual CodeGenerationSymbol Clone();
    public virtual int get_Arity();
    public virtual bool get_ReturnsVoid();
    public virtual bool get_ReturnsByRef();
    public virtual bool get_ReturnsByRefReadonly();
    [CompilerGeneratedAttribute]
public virtual RefKind get_RefKind();
    public virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public virtual IMethodSymbol get_ConstructedFrom();
    public virtual IMethodSymbol get_OverriddenMethod();
    public virtual IMethodSymbol get_ReducedFrom();
    public virtual ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    public virtual IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType);
    public virtual IMethodSymbol get_PartialImplementationPart();
    public virtual IMethodSymbol get_PartialDefinitionPart();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationNamedTypeSymbol : CodeGenerationAbstractNamedTypeSymbol {
    private TypeKind _typeKind;
    private ImmutableArray`1<ITypeParameterSymbol> _typeParameters;
    private INamedTypeSymbol _baseType;
    private ImmutableArray`1<INamedTypeSymbol> _interfaces;
    private ImmutableArray`1<ISymbol> _members;
    private INamedTypeSymbol _enumUnderlyingType;
    public TypeKind TypeKind { get; }
    public SymbolKind Kind { get; }
    public int Arity { get; }
    public bool IsGenericType { get; }
    public bool IsUnboundGenericType { get; }
    public bool IsScriptClass { get; }
    public bool IsImplicitClass { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IMethodSymbol DelegateInvokeMethod { get; }
    public INamedTypeSymbol EnumUnderlyingType { get; }
    public INamedTypeSymbol ConstructedFrom { get; }
    public ImmutableArray`1<ISymbol> CandidateSymbols { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public INamedTypeSymbol BaseType { get; }
    public ImmutableArray`1<INamedTypeSymbol> Interfaces { get; }
    public ImmutableArray`1<IMethodSymbol> InstanceConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> StaticConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> Constructors { get; }
    public CodeGenerationNamedTypeSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, TypeKind typeKind, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, INamedTypeSymbol baseType, ImmutableArray`1<INamedTypeSymbol> interfaces, SpecialType specialType, ImmutableArray`1<ISymbol> members, ImmutableArray`1<CodeGenerationAbstractNamedTypeSymbol> typeMembers, INamedTypeSymbol enumUnderlyingType);
    protected virtual CodeGenerationSymbol Clone();
    public virtual TypeKind get_TypeKind();
    public virtual SymbolKind get_Kind();
    public virtual int get_Arity();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsUnboundGenericType();
    public virtual bool get_IsScriptClass();
    public virtual bool get_IsImplicitClass();
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual IMethodSymbol get_DelegateInvokeMethod();
    public virtual INamedTypeSymbol get_EnumUnderlyingType();
    public virtual INamedTypeSymbol get_ConstructedFrom();
    public virtual INamedTypeSymbol ConstructUnboundGenericType();
    public ImmutableArray`1<ISymbol> get_CandidateSymbols();
    public virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public virtual INamedTypeSymbol get_BaseType();
    public virtual ImmutableArray`1<INamedTypeSymbol> get_Interfaces();
    public virtual ImmutableArray`1<ISymbol> GetMembers();
    public virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<IMethodSymbol> get_InstanceConstructors();
    public virtual ImmutableArray`1<IMethodSymbol> get_StaticConstructors();
    public virtual ImmutableArray`1<IMethodSymbol> get_Constructors();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationNamespaceInfo : object {
    private static ConditionalWeakTable`2<INamespaceSymbol, CodeGenerationNamespaceInfo> s_namespaceToInfoMap;
    private IList`1<ISymbol> _imports;
    private CodeGenerationNamespaceInfo(IList`1<ISymbol> imports);
    private static CodeGenerationNamespaceInfo();
    public static void Attach(INamespaceSymbol namespace, IList`1<ISymbol> imports);
    private static CodeGenerationNamespaceInfo GetInfo(INamespaceSymbol namespace);
    public static IList`1<ISymbol> GetImports(INamespaceSymbol namespace);
    private static IList`1<ISymbol> GetImports(CodeGenerationNamespaceInfo info);
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationNamespaceOrTypeSymbol : CodeGenerationSymbol {
    public bool IsNamespace { get; }
    public bool IsType { get; }
    protected CodeGenerationNamespaceOrTypeSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name);
    public virtual ImmutableArray`1<ISymbol> GetMembers();
    public sealed virtual ImmutableArray`1<ISymbol> GetMembers(string name);
    public virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers();
    public sealed virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers(string name);
    public sealed virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers(string name, int arity);
    public abstract virtual bool get_IsNamespace();
    public abstract virtual bool get_IsType();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationNamespaceSymbol : CodeGenerationNamespaceOrTypeSymbol {
    private IList`1<INamespaceOrTypeSymbol> _members;
    public bool IsNamespace { get; }
    public bool IsType { get; }
    public SymbolKind Kind { get; }
    public bool IsGlobalNamespace { get; }
    public NamespaceKind NamespaceKind { get; }
    public Compilation ContainingCompilation { get; }
    public INamedTypeSymbol ImplicitType { get; }
    public ImmutableArray`1<INamespaceSymbol> ConstituentNamespaces { get; }
    public CodeGenerationNamespaceSymbol(string name, IList`1<INamespaceOrTypeSymbol> members);
    public virtual bool get_IsNamespace();
    public virtual bool get_IsType();
    protected virtual CodeGenerationSymbol Clone();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual IEnumerable`1<INamespaceOrTypeSymbol> GetMembers();
    private sealed virtual override IEnumerable`1<INamespaceOrTypeSymbol> Microsoft.CodeAnalysis.INamespaceSymbol.GetMembers(string name);
    public sealed virtual IEnumerable`1<INamespaceSymbol> GetNamespaceMembers();
    public sealed virtual bool get_IsGlobalNamespace();
    public sealed virtual NamespaceKind get_NamespaceKind();
    public sealed virtual Compilation get_ContainingCompilation();
    public INamedTypeSymbol get_ImplicitType();
    public sealed virtual ImmutableArray`1<INamespaceSymbol> get_ConstituentNamespaces();
}
internal enum Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOperatorKind : Enum {
    public int value__;
    public static CodeGenerationOperatorKind Addition;
    public static CodeGenerationOperatorKind BitwiseAnd;
    public static CodeGenerationOperatorKind BitwiseOr;
    public static CodeGenerationOperatorKind Concatenate;
    public static CodeGenerationOperatorKind Decrement;
    public static CodeGenerationOperatorKind Division;
    public static CodeGenerationOperatorKind Equality;
    public static CodeGenerationOperatorKind ExclusiveOr;
    public static CodeGenerationOperatorKind Exponent;
    public static CodeGenerationOperatorKind False;
    public static CodeGenerationOperatorKind GreaterThan;
    public static CodeGenerationOperatorKind GreaterThanOrEqual;
    public static CodeGenerationOperatorKind Increment;
    public static CodeGenerationOperatorKind Inequality;
    public static CodeGenerationOperatorKind IntegerDivision;
    public static CodeGenerationOperatorKind LeftShift;
    public static CodeGenerationOperatorKind LessThan;
    public static CodeGenerationOperatorKind LessThanOrEqual;
    public static CodeGenerationOperatorKind Like;
    public static CodeGenerationOperatorKind LogicalNot;
    public static CodeGenerationOperatorKind Modulus;
    public static CodeGenerationOperatorKind Multiplication;
    public static CodeGenerationOperatorKind OnesComplement;
    public static CodeGenerationOperatorKind RightShift;
    public static CodeGenerationOperatorKind Subtraction;
    public static CodeGenerationOperatorKind True;
    public static CodeGenerationOperatorKind UnaryPlus;
    public static CodeGenerationOperatorKind UnaryNegation;
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOperatorSymbol : CodeGenerationMethodSymbol {
    public MethodKind MethodKind { get; }
    public CodeGenerationOperatorSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, CodeGenerationOperatorKind operatorKind, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<AttributeData> returnTypeAttributes);
    public virtual MethodKind get_MethodKind();
    public static int GetParameterCount(CodeGenerationOperatorKind operatorKind);
    private static string GetMetadataName(CodeGenerationOperatorKind operatorKind);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions : object {
    public static CodeGenerationOptions Default;
    [CompilerGeneratedAttribute]
private Location <ContextLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <AfterThisLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <BeforeThisLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddImports>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PlaceSystemNamespaceFirst>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<INamespaceSymbol> <AdditionalImports>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MergeNestedNamespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MergeAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateDefaultAccessibility>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateMethodBodies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateDocumentationComments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoInsertionLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SortMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReuseSyntax>k__BackingField;
    [CompilerGeneratedAttribute]
private ParseOptions <ParseOptions>k__BackingField;
    public Location ContextLocation { get; }
    public Location AfterThisLocation { get; }
    public Location BeforeThisLocation { get; }
    public bool AddImports { get; }
    public bool PlaceSystemNamespaceFirst { get; }
    public IEnumerable`1<INamespaceSymbol> AdditionalImports { get; }
    public bool GenerateMembers { get; }
    public bool MergeNestedNamespaces { get; }
    public bool MergeAttributes { get; }
    public bool GenerateDefaultAccessibility { get; }
    public bool GenerateMethodBodies { get; }
    public bool GenerateDocumentationComments { get; }
    public bool AutoInsertionLocation { get; }
    public bool SortMembers { get; }
    public bool ReuseSyntax { get; }
    public ParseOptions ParseOptions { get; }
    internal Location BestLocation { get; }
    public CodeGenerationOptions(Location contextLocation, Location afterThisLocation, Location beforeThisLocation, bool addImports, bool placeSystemNamespaceFirst, IEnumerable`1<INamespaceSymbol> additionalImports, bool generateMembers, bool mergeNestedNamespaces, bool mergeAttributes, bool generateDefaultAccessibility, bool generateMethodBodies, bool generateDocumentationComments, bool autoInsertionLocation, bool sortMembers, bool reuseSyntax, ParseOptions parseOptions);
    private static CodeGenerationOptions();
    [CompilerGeneratedAttribute]
public Location get_ContextLocation();
    [CompilerGeneratedAttribute]
public Location get_AfterThisLocation();
    [CompilerGeneratedAttribute]
public Location get_BeforeThisLocation();
    [CompilerGeneratedAttribute]
public bool get_AddImports();
    [CompilerGeneratedAttribute]
public bool get_PlaceSystemNamespaceFirst();
    [CompilerGeneratedAttribute]
public IEnumerable`1<INamespaceSymbol> get_AdditionalImports();
    [CompilerGeneratedAttribute]
public bool get_GenerateMembers();
    [CompilerGeneratedAttribute]
public bool get_MergeNestedNamespaces();
    [CompilerGeneratedAttribute]
public bool get_MergeAttributes();
    [CompilerGeneratedAttribute]
public bool get_GenerateDefaultAccessibility();
    [CompilerGeneratedAttribute]
public bool get_GenerateMethodBodies();
    [CompilerGeneratedAttribute]
public bool get_GenerateDocumentationComments();
    [CompilerGeneratedAttribute]
public bool get_AutoInsertionLocation();
    [CompilerGeneratedAttribute]
public bool get_SortMembers();
    [CompilerGeneratedAttribute]
public bool get_ReuseSyntax();
    [CompilerGeneratedAttribute]
public ParseOptions get_ParseOptions();
    private void CheckLocation(Location location, string name);
    internal Location get_BestLocation();
    public CodeGenerationOptions With(Optional`1<Location> contextLocation, Optional`1<Location> afterThisLocation, Optional`1<Location> beforeThisLocation, Optional`1<bool> addImports, Optional`1<bool> placeSystemNamespaceFirst, Optional`1<IEnumerable`1<INamespaceSymbol>> additionalImports, Optional`1<bool> generateMembers, Optional`1<bool> mergeNestedNamespaces, Optional`1<bool> mergeAttributes, Optional`1<bool> generateDefaultAccessibility, Optional`1<bool> generateMethodBodies, Optional`1<bool> generateDocumentationComments, Optional`1<bool> autoInsertionLocation, Optional`1<bool> sortMembers, Optional`1<bool> reuseSyntax, Optional`1<ParseOptions> parseOptions);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationParameterSymbol : CodeGenerationSymbol {
    [CompilerGeneratedAttribute]
private RefKind <RefKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParams>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Ordinal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasExplicitDefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ExplicitDefaultValue>k__BackingField;
    public RefKind RefKind { get; }
    public bool IsParams { get; }
    public ITypeSymbol Type { get; }
    public bool IsOptional { get; }
    public int Ordinal { get; }
    public bool HasExplicitDefaultValue { get; }
    public object ExplicitDefaultValue { get; }
    public IParameterSymbol OriginalDefinition { get; }
    public SymbolKind Kind { get; }
    public bool IsThis { get; }
    public ImmutableArray`1<CustomModifier> RefCustomModifiers { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public CodeGenerationParameterSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, RefKind refKind, bool isParams, ITypeSymbol type, string name, bool isOptional, bool hasDefaultValue, object defaultValue);
    [CompilerGeneratedAttribute]
public sealed virtual RefKind get_RefKind();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsParams();
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsOptional();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Ordinal();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasExplicitDefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual object get_ExplicitDefaultValue();
    protected virtual CodeGenerationSymbol Clone();
    public sealed virtual IParameterSymbol get_OriginalDefinition();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual bool get_IsThis();
    public sealed virtual ImmutableArray`1<CustomModifier> get_RefCustomModifiers();
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationPointerTypeSymbol : CodeGenerationTypeSymbol {
    [CompilerGeneratedAttribute]
private ITypeSymbol <PointedAtType>k__BackingField;
    public ITypeSymbol PointedAtType { get; }
    public TypeKind TypeKind { get; }
    public SymbolKind Kind { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public CodeGenerationPointerTypeSymbol(ITypeSymbol pointedAtType);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_PointedAtType();
    protected virtual CodeGenerationSymbol Clone();
    public virtual TypeKind get_TypeKind();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationPropertyInfo : object {
    private static ConditionalWeakTable`2<IPropertySymbol, CodeGenerationPropertyInfo> s_propertyToInfoMap;
    private bool _isNew;
    private bool _isUnsafe;
    private SyntaxNode _initializer;
    private CodeGenerationPropertyInfo(bool isNew, bool isUnsafe, SyntaxNode initializer);
    private static CodeGenerationPropertyInfo();
    public static void Attach(IPropertySymbol property, bool isNew, bool isUnsafe, SyntaxNode initializer);
    private static CodeGenerationPropertyInfo GetInfo(IPropertySymbol property);
    public static SyntaxNode GetInitializer(CodeGenerationPropertyInfo info);
    public static SyntaxNode GetInitializer(IPropertySymbol property);
    public static bool GetIsNew(IPropertySymbol property);
    public static bool GetIsUnsafe(IPropertySymbol property);
    private static bool GetIsNew(CodeGenerationPropertyInfo info);
    private static bool GetIsUnsafe(CodeGenerationPropertyInfo info);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationPropertySymbol : CodeGenerationSymbol {
    private RefKind _refKind;
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIndexer>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IParameterSymbol> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IPropertySymbol> <ExplicitInterfaceImplementations>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <GetMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <SetMethod>k__BackingField;
    public ITypeSymbol Type { get; }
    public bool IsIndexer { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public ImmutableArray`1<IPropertySymbol> ExplicitInterfaceImplementations { get; }
    public IMethodSymbol GetMethod { get; }
    public IMethodSymbol SetMethod { get; }
    public SymbolKind Kind { get; }
    public bool IsReadOnly { get; }
    public bool IsWriteOnly { get; }
    public IPropertySymbol OriginalDefinition { get; }
    public RefKind RefKind { get; }
    public bool ReturnsByRef { get; }
    public bool ReturnsByRefReadonly { get; }
    public IPropertySymbol OverriddenProperty { get; }
    public bool IsWithEvents { get; }
    public ImmutableArray`1<CustomModifier> RefCustomModifiers { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public CodeGenerationPropertySymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, ITypeSymbol type, RefKind refKind, ImmutableArray`1<IPropertySymbol> explicitInterfaceImplementations, string name, bool isIndexer, ImmutableArray`1<IParameterSymbol> parametersOpt, IMethodSymbol getMethod, IMethodSymbol setMethod);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsIndexer();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IPropertySymbol> get_ExplicitInterfaceImplementations();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_GetMethod();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_SetMethod();
    protected virtual CodeGenerationSymbol Clone();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsWriteOnly();
    public sealed virtual IPropertySymbol get_OriginalDefinition();
    public sealed virtual RefKind get_RefKind();
    public sealed virtual bool get_ReturnsByRef();
    public sealed virtual bool get_ReturnsByRefReadonly();
    public sealed virtual IPropertySymbol get_OverriddenProperty();
    public sealed virtual bool get_IsWithEvents();
    public sealed virtual ImmutableArray`1<CustomModifier> get_RefCustomModifiers();
    public sealed virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbol : object {
    protected static ConditionalWeakTable`2<CodeGenerationSymbol, SyntaxAnnotation[]> annotationsTable;
    private ImmutableArray`1<AttributeData> _attributes;
    [CompilerGeneratedAttribute]
private Accessibility <DeclaredAccessibility>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclarationModifiers <Modifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <ContainingType>k__BackingField;
    public Accessibility DeclaredAccessibility { get; }
    protected internal DeclarationModifiers Modifiers { get; }
    public string Name { get; }
    public INamedTypeSymbol ContainingType { get; protected set; }
    public SymbolKind Kind { get; }
    public string Language { get; }
    public ISymbol ContainingSymbol { get; }
    public IAssemblySymbol ContainingAssembly { get; }
    public IMethodSymbol ContainingMethod { get; }
    public IModuleSymbol ContainingModule { get; }
    public INamespaceSymbol ContainingNamespace { get; }
    public bool IsDefinition { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    public bool IsImplicitlyDeclared { get; }
    public bool CanBeReferencedByName { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxNode> DeclaringSyntaxNodes { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public ISymbol OriginalDefinition { get; }
    public string MetadataName { get; }
    public bool HasUnsupportedMetadata { get; }
    protected CodeGenerationSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name);
    private static CodeGenerationSymbol();
    [CompilerGeneratedAttribute]
public sealed virtual Accessibility get_DeclaredAccessibility();
    [CompilerGeneratedAttribute]
protected internal DeclarationModifiers get_Modifiers();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual INamedTypeSymbol get_ContainingType();
    [CompilerGeneratedAttribute]
protected void set_ContainingType(INamedTypeSymbol value);
    protected abstract virtual CodeGenerationSymbol Clone();
    internal SyntaxAnnotation[] GetAnnotations();
    internal CodeGenerationSymbol WithAdditionalAnnotations(SyntaxAnnotation[] annotations);
    private CodeGenerationSymbol AddAnnotationsTo(CodeGenerationSymbol originalDefinition, CodeGenerationSymbol newDefinition, SyntaxAnnotation[] annotations);
    public abstract virtual SymbolKind get_Kind();
    public sealed virtual string get_Language();
    public sealed virtual ISymbol get_ContainingSymbol();
    public sealed virtual IAssemblySymbol get_ContainingAssembly();
    public IMethodSymbol get_ContainingMethod();
    public sealed virtual IModuleSymbol get_ContainingModule();
    public sealed virtual INamespaceSymbol get_ContainingNamespace();
    public sealed virtual bool get_IsDefinition();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsImplicitlyDeclared();
    public sealed virtual bool get_CanBeReferencedByName();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public ImmutableArray`1<SyntaxNode> get_DeclaringSyntaxNodes();
    public sealed virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual ImmutableArray`1<AttributeData> GetAttributes();
    public ImmutableArray`1<AttributeData> GetAttributes(INamedTypeSymbol attributeType);
    public ImmutableArray`1<AttributeData> GetAttributes(IMethodSymbol attributeConstructor);
    public sealed virtual ISymbol get_OriginalDefinition();
    public abstract virtual void Accept(SymbolVisitor visitor);
    public abstract virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public sealed virtual string GetDocumentationCommentId();
    public sealed virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public sealed virtual string ToDisplayString(SymbolDisplayFormat format);
    public sealed virtual ImmutableArray`1<SymbolDisplayPart> ToDisplayParts(SymbolDisplayFormat format);
    public sealed virtual string ToMinimalDisplayString(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    public sealed virtual ImmutableArray`1<SymbolDisplayPart> ToMinimalDisplayParts(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    public virtual string get_MetadataName();
    public sealed virtual bool get_HasUnsupportedMetadata();
    public sealed virtual bool Equals(ISymbol other);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory : object {
    [ExtensionAttribute]
public static bool IsCodeGenerationSymbol(ISymbol symbol);
    public static IEventSymbol CreateEventSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, ImmutableArray`1<IEventSymbol> explicitInterfaceImplementations, string name, IMethodSymbol addMethod, IMethodSymbol removeMethod, IMethodSymbol raiseMethod);
    internal static IPropertySymbol CreatePropertySymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, RefKind refKind, ImmutableArray`1<IPropertySymbol> explicitInterfaceImplementations, string name, ImmutableArray`1<IParameterSymbol> parameters, IMethodSymbol getMethod, IMethodSymbol setMethod, bool isIndexer, SyntaxNode initializer);
    public static IPropertySymbol CreatePropertySymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, RefKind refKind, ImmutableArray`1<IPropertySymbol> explicitInterfaceImplementations, string name, ImmutableArray`1<IParameterSymbol> parameters, IMethodSymbol getMethod, IMethodSymbol setMethod, bool isIndexer);
    public static IFieldSymbol CreateFieldSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, string name, bool hasConstantValue, object constantValue, SyntaxNode initializer);
    public static IMethodSymbol CreateConstructorSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, string typeName, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> baseConstructorArguments, ImmutableArray`1<SyntaxNode> thisConstructorArguments);
    public static IMethodSymbol CreateDestructorSymbol(ImmutableArray`1<AttributeData> attributes, string typeName, ImmutableArray`1<SyntaxNode> statements);
    internal static IMethodSymbol CreateMethodSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, RefKind refKind, ImmutableArray`1<IMethodSymbol> explicitInterfaceImplementations, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> handlesExpressions, ImmutableArray`1<AttributeData> returnTypeAttributes, MethodKind methodKind);
    public static IMethodSymbol CreateMethodSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, RefKind refKind, ImmutableArray`1<IMethodSymbol> explicitInterfaceImplementations, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> handlesExpressions, ImmutableArray`1<AttributeData> returnTypeAttributes, MethodKind methodKind);
    public static IMethodSymbol CreateOperatorSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, CodeGenerationOperatorKind operatorKind, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<AttributeData> returnTypeAttributes);
    public static IMethodSymbol CreateConversionSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol toType, IParameterSymbol fromType, bool isImplicit, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<AttributeData> toTypeAttributes);
    public static IParameterSymbol CreateParameterSymbol(ITypeSymbol type, string name);
    public static IParameterSymbol CreateParameterSymbol(ImmutableArray`1<AttributeData> attributes, RefKind refKind, bool isParams, ITypeSymbol type, string name, bool isOptional, bool hasDefaultValue, object defaultValue);
    public static ITypeParameterSymbol CreateTypeParameterSymbol(string name, int ordinal);
    public static ITypeParameterSymbol CreateTypeParameter(ImmutableArray`1<AttributeData> attributes, VarianceKind varianceKind, string name, ImmutableArray`1<ITypeSymbol> constraintTypes, bool hasConstructorConstraint, bool hasReferenceConstraint, bool hasUnmanagedConstraint, bool hasValueConstraint, int ordinal);
    public static IPointerTypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType);
    public static IArrayTypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    internal static IMethodSymbol CreateAccessorSymbol(IMethodSymbol accessor, ImmutableArray`1<AttributeData> attributes, Nullable`1<Accessibility> accessibility, ImmutableArray`1<IMethodSymbol> explicitInterfaceImplementations, ImmutableArray`1<SyntaxNode> statements);
    public static IMethodSymbol CreateAccessorSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, ImmutableArray`1<SyntaxNode> statements);
    public static AttributeData CreateAttributeData(INamedTypeSymbol attributeClass, ImmutableArray`1<TypedConstant> constructorArguments, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments);
    public static INamedTypeSymbol CreateNamedTypeSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, TypeKind typeKind, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, INamedTypeSymbol baseType, ImmutableArray`1<INamedTypeSymbol> interfaces, SpecialType specialType, ImmutableArray`1<ISymbol> members);
    public static CodeGenerationNamedTypeSymbol CreateDelegateTypeSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, RefKind refKind, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<IParameterSymbol> parameters);
    public static INamespaceSymbol CreateNamespaceSymbol(string name, IList`1<ISymbol> imports, IList`1<INamespaceOrTypeSymbol> members);
    internal static IMethodSymbol CreateMethodSymbol(IMethodSymbol method, ImmutableArray`1<AttributeData> attributes, Nullable`1<Accessibility> accessibility, Nullable`1<DeclarationModifiers> modifiers, ImmutableArray`1<IMethodSymbol> explicitInterfaceImplementations, string name, ImmutableArray`1<SyntaxNode> statements, INamedTypeSymbol containingType);
    internal static IPropertySymbol CreatePropertySymbol(IPropertySymbol property, ImmutableArray`1<AttributeData> attributes, Nullable`1<Accessibility> accessibility, Nullable`1<DeclarationModifiers> modifiers, ImmutableArray`1<IPropertySymbol> explicitInterfaceImplementations, string name, Nullable`1<bool> isIndexer, IMethodSymbol getMethod, IMethodSymbol setMethod);
    internal static IEventSymbol CreateEventSymbol(IEventSymbol event, ImmutableArray`1<AttributeData> attributes, Nullable`1<Accessibility> accessibility, Nullable`1<DeclarationModifiers> modifiers, ImmutableArray`1<IEventSymbol> explicitInterfaceImplementations, string name, IMethodSymbol addMethod, IMethodSymbol removeMethod);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationTypeParameterSymbol : CodeGenerationTypeSymbol {
    [CompilerGeneratedAttribute]
private VarianceKind <Variance>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ITypeSymbol> <ConstraintTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasConstructorConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasReferenceTypeConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValueTypeConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasUnmanagedTypeConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Ordinal>k__BackingField;
    public VarianceKind Variance { get; }
    public ImmutableArray`1<ITypeSymbol> ConstraintTypes { get; internal set; }
    public bool HasConstructorConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public bool HasUnmanagedTypeConstraint { get; }
    public int Ordinal { get; }
    public ITypeParameterSymbol OriginalDefinition { get; }
    public ITypeParameterSymbol ReducedFrom { get; }
    public SymbolKind Kind { get; }
    public TypeKind TypeKind { get; }
    public TypeParameterKind TypeParameterKind { get; }
    public IMethodSymbol DeclaringMethod { get; }
    public INamedTypeSymbol DeclaringType { get; }
    public CodeGenerationTypeParameterSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, VarianceKind varianceKind, string name, ImmutableArray`1<ITypeSymbol> constraintTypes, bool hasConstructorConstraint, bool hasReferenceConstraint, bool hasValueConstraint, bool hasUnmanagedConstraint, int ordinal);
    [CompilerGeneratedAttribute]
public sealed virtual VarianceKind get_Variance();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ITypeSymbol> get_ConstraintTypes();
    [CompilerGeneratedAttribute]
internal void set_ConstraintTypes(ImmutableArray`1<ITypeSymbol> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasConstructorConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasReferenceTypeConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasValueTypeConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasUnmanagedTypeConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Ordinal();
    protected virtual CodeGenerationSymbol Clone();
    public sealed virtual ITypeParameterSymbol get_OriginalDefinition();
    public sealed virtual ITypeParameterSymbol get_ReducedFrom();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TypeKind get_TypeKind();
    public sealed virtual TypeParameterKind get_TypeParameterKind();
    public sealed virtual IMethodSymbol get_DeclaringMethod();
    public sealed virtual INamedTypeSymbol get_DeclaringType();
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationTypeSymbol : CodeGenerationNamespaceOrTypeSymbol {
    [CompilerGeneratedAttribute]
private SpecialType <SpecialType>k__BackingField;
    public SpecialType SpecialType { get; protected set; }
    public TypeKind TypeKind { get; }
    public INamedTypeSymbol BaseType { get; }
    public ImmutableArray`1<INamedTypeSymbol> Interfaces { get; }
    public ImmutableArray`1<INamedTypeSymbol> AllInterfaces { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    public bool IsAnonymousType { get; }
    public bool IsTupleType { get; }
    public ImmutableArray`1<ITypeSymbol> TupleElementTypes { get; }
    public ImmutableArray`1<string> TupleElementNames { get; }
    public INamedTypeSymbol TupleUnderlyingType { get; }
    public ITypeSymbol OriginalDefinition { get; }
    public bool IsNamespace { get; }
    public bool IsType { get; }
    public bool IsSerializable { get; }
    protected CodeGenerationTypeSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name, SpecialType specialType);
    [CompilerGeneratedAttribute]
public sealed virtual SpecialType get_SpecialType();
    [CompilerGeneratedAttribute]
protected void set_SpecialType(SpecialType value);
    public abstract virtual TypeKind get_TypeKind();
    public virtual INamedTypeSymbol get_BaseType();
    public virtual ImmutableArray`1<INamedTypeSymbol> get_Interfaces();
    public sealed virtual ImmutableArray`1<INamedTypeSymbol> get_AllInterfaces();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsAnonymousType();
    public sealed virtual bool get_IsTupleType();
    public ImmutableArray`1<ITypeSymbol> get_TupleElementTypes();
    public ImmutableArray`1<string> get_TupleElementNames();
    public sealed virtual INamedTypeSymbol get_TupleUnderlyingType();
    public sealed virtual ITypeSymbol get_OriginalDefinition();
    public sealed virtual ISymbol FindImplementationForInterfaceMember(ISymbol interfaceMember);
    public virtual bool get_IsNamespace();
    public virtual bool get_IsType();
    public sealed virtual bool get_IsSerializable();
}
internal static class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator : object {
    public static SyntaxAnnotation Annotation;
    private static CodeGenerator();
    private static ICodeGenerationService GetCodeGenerationService(Workspace workspace, string language);
    public static SyntaxNode CreateEventDeclaration(IEventSymbol event, Workspace workspace, CodeGenerationDestination destination, CodeGenerationOptions options);
    public static SyntaxNode CreateFieldDeclaration(IFieldSymbol field, Workspace workspace, CodeGenerationDestination destination, CodeGenerationOptions options);
    public static SyntaxNode CreateMethodDeclaration(IMethodSymbol method, Workspace workspace, CodeGenerationDestination destination, CodeGenerationOptions options);
    public static SyntaxNode CreatePropertyDeclaration(IPropertySymbol property, Workspace workspace, CodeGenerationDestination destination, CodeGenerationOptions options);
    public static SyntaxNode CreateNamedTypeDeclaration(INamedTypeSymbol namedType, Workspace workspace, CodeGenerationDestination destination, CodeGenerationOptions options);
    public static SyntaxNode CreateNamespaceDeclaration(INamespaceSymbol namespace, Workspace workspace, CodeGenerationDestination destination, CodeGenerationOptions options);
    public static TDeclarationNode AddEventDeclaration(TDeclarationNode destination, IEventSymbol event, Workspace workspace, CodeGenerationOptions options);
    public static TDeclarationNode AddFieldDeclaration(TDeclarationNode destination, IFieldSymbol field, Workspace workspace, CodeGenerationOptions options);
    public static TDeclarationNode AddMethodDeclaration(TDeclarationNode destination, IMethodSymbol method, Workspace workspace, CodeGenerationOptions options);
    public static TDeclarationNode AddPropertyDeclaration(TDeclarationNode destination, IPropertySymbol property, Workspace workspace, CodeGenerationOptions options);
    public static TDeclarationNode AddNamedTypeDeclaration(TDeclarationNode destination, INamedTypeSymbol namedType, Workspace workspace, CodeGenerationOptions options);
    public static TDeclarationNode AddMemberDeclarations(TDeclarationNode destination, IEnumerable`1<ISymbol> members, Workspace workspace, CodeGenerationOptions options);
    public static TDeclarationNode AddParameterDeclarations(TDeclarationNode destinationMember, IEnumerable`1<IParameterSymbol> parameters, Workspace workspace, CodeGenerationOptions options);
    public static TDeclarationNode AddAttributes(TDeclarationNode destination, Workspace workspace, IEnumerable`1<AttributeData> attributes, Nullable`1<SyntaxToken> target, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static TDeclarationNode RemoveAttribute(TDeclarationNode destination, Workspace workspace, AttributeData attributeToRemove, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static TDeclarationNode RemoveAttribute(TDeclarationNode destination, Workspace workspace, SyntaxNode attributeToRemove, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode destination, Workspace workspace, IEnumerable`1<SyntaxToken> newModifiers, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static TDeclarationNode UpdateDeclarationAccessibility(TDeclarationNode destination, Workspace workspace, Accessibility newAccessibility, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static TDeclarationNode UpdateDeclarationType(TDeclarationNode destination, Workspace workspace, ITypeSymbol newType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static TDeclarationNode UpdateDeclarationMembers(TDeclarationNode destination, Workspace workspace, IList`1<ISymbol> newMembers, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static TDeclarationNode AddStatements(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, Workspace workspace, CodeGenerationOptions options);
    public static Task`1<Document> AddEventDeclarationAsync(Solution solution, INamedTypeSymbol destination, IEventSymbol event, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> AddFieldDeclarationAsync(Solution solution, INamedTypeSymbol destination, IFieldSymbol field, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> AddMethodDeclarationAsync(Solution solution, INamedTypeSymbol destination, IMethodSymbol method, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> AddPropertyDeclarationAsync(Solution solution, INamedTypeSymbol destination, IPropertySymbol property, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> AddNamedTypeDeclarationAsync(Solution solution, INamedTypeSymbol destination, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> AddNamedTypeDeclarationAsync(Solution solution, INamespaceSymbol destination, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> AddNamespaceDeclarationAsync(Solution solution, INamespaceSymbol destination, INamespaceSymbol namespace, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> AddNamespaceOrTypeDeclarationAsync(Solution solution, INamespaceSymbol destination, INamespaceOrTypeSymbol namespaceOrType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> AddMemberDeclarationsAsync(Solution solution, INamedTypeSymbol destination, IEnumerable`1<ISymbol> members, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static bool CanAdd(Solution solution, ISymbol destination, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService {
    public abstract virtual SyntaxNode CreateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreateFieldDeclaration(IFieldSymbol field, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreatePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationOptions options);
    public abstract virtual SyntaxNode CreateNamedTypeDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateNamespaceDeclaration(INamespaceSymbol namespace, CodeGenerationDestination destination, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddEvent(TDeclarationNode destination, IEventSymbol event, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddField(TDeclarationNode destination, IFieldSymbol field, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddMethod(TDeclarationNode destination, IMethodSymbol method, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddProperty(TDeclarationNode destination, IPropertySymbol property, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddNamedType(TDeclarationNode destination, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddNamespace(TDeclarationNode destination, INamespaceSymbol namespace, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<ISymbol> members, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddParameters(TDeclarationNode destination, IEnumerable`1<IParameterSymbol> parameters, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddAttributes(TDeclarationNode destination, IEnumerable`1<AttributeData> attributes, Nullable`1<SyntaxToken> target, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, SyntaxNode attributeToRemove, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, AttributeData attributeToRemove, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, IEnumerable`1<SyntaxToken> newModifiers, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationAccessibility(TDeclarationNode declaration, Accessibility newAccessibility, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationType(TDeclarationNode declaration, ITypeSymbol newType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationMembers(TDeclarationNode declaration, IList`1<ISymbol> newMembers, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddStatements(TDeclarationNode destination, IEnumerable`1<SyntaxNode> statements, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddImportsAsync(Document document, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddEventAsync(Solution solution, INamedTypeSymbol destination, IEventSymbol event, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddFieldAsync(Solution solution, INamedTypeSymbol destination, IFieldSymbol field, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddMethodAsync(Solution solution, INamedTypeSymbol destination, IMethodSymbol method, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddPropertyAsync(Solution solution, INamedTypeSymbol destination, IPropertySymbol property, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddNamedTypeAsync(Solution solution, INamedTypeSymbol destination, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddNamedTypeAsync(Solution solution, INamespaceSymbol destination, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddNamespaceAsync(Solution solution, INamespaceSymbol destination, INamespaceSymbol namespace, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddNamespaceOrTypeAsync(Solution solution, INamespaceSymbol destination, INamespaceOrTypeSymbol namespaceOrType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddMembersAsync(Solution solution, INamedTypeSymbol destination, IEnumerable`1<ISymbol> members, CodeGenerationOptions options, CancellationToken cancellationToken);
    public abstract virtual bool CanAddTo(ISymbol destination, Solution solution, CancellationToken cancellationToken);
    public abstract virtual bool CanAddTo(SyntaxNode destination, Solution solution, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeGeneration.INamedTypeSymbolExtensions : object {
    [ExtensionAttribute]
public static CodeGenerationAbstractNamedTypeSymbol ToCodeGenerationSymbol(INamedTypeSymbol namedType);
}
internal static class Microsoft.CodeAnalysis.CodeGeneration.LiteralSpecialValues : object {
    public static IEnumerable`1<KeyValuePair`2<byte, string>> ByteSpecialValues;
    public static IEnumerable`1<KeyValuePair`2<sbyte, string>> SByteSpecialValues;
    public static IEnumerable`1<KeyValuePair`2<short, string>> Int16SpecialValues;
    public static IEnumerable`1<KeyValuePair`2<ushort, string>> UInt16SpecialValues;
    public static IEnumerable`1<KeyValuePair`2<int, string>> Int32SpecialValues;
    public static IEnumerable`1<KeyValuePair`2<UInt32, string>> UInt32SpecialValues;
    public static IEnumerable`1<KeyValuePair`2<long, string>> Int64SpecialValues;
    public static IEnumerable`1<KeyValuePair`2<ulong, string>> UInt64SpecialValues;
    public static IEnumerable`1<KeyValuePair`2<float, string>> SingleSpecialValues;
    public static IEnumerable`1<KeyValuePair`2<double, string>> DoubleSpecialValues;
    public static IEnumerable`1<KeyValuePair`2<decimal, string>> DecimalSpecialValues;
    private static LiteralSpecialValues();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeGeneration.SyntaxAnnotationExtensions : object {
    [ExtensionAttribute]
public static TSymbol AddAnnotationToSymbol(SyntaxAnnotation annotation, TSymbol symbol);
    internal static SyntaxAnnotation[] CombineAnnotations(SyntaxAnnotation[] originalAnnotations, SyntaxAnnotation[] newAnnotations);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.TypeGenerator : object {
    public sealed virtual ITypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    public sealed virtual ITypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType);
    public sealed virtual ITypeSymbol Construct(INamedTypeSymbol namedType, ITypeSymbol[] typeArguments);
}
public class Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext : ValueType {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    private Action`1<CodeAction> _registerRefactoring;
    public Document Document { get; }
    public TextSpan Span { get; }
    public CancellationToken CancellationToken { get; }
    public CodeRefactoringContext(Document document, TextSpan span, Action`1<CodeAction> registerRefactoring, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    public void RegisterRefactoring(CodeAction action);
}
public abstract class Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider : object {
    public abstract virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Languages>k__BackingField;
    public string Name { get; public set; }
    public String[] Languages { get; }
    public ExportCodeRefactoringProviderAttribute(string firstLanguage, String[] additionalLanguages);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public String[] get_Languages();
}
internal enum Microsoft.CodeAnalysis.CodeStyle.AccessibilityModifiersRequired : Enum {
    public int value__;
    public static AccessibilityModifiersRequired Never;
    public static AccessibilityModifiersRequired Always;
    public static AccessibilityModifiersRequired ForNonInterfaceMembers;
    public static AccessibilityModifiersRequired OmitIfDefault;
}
internal static class Microsoft.CodeAnalysis.CodeStyle.CodeStyleHelpers : object {
    public static bool TryParseStringEditorConfigCodeStyleOption(string arg, CodeStyleOption`1& option);
    public static bool TryParseBoolEditorConfigCodeStyleOption(string arg, CodeStyleOption`1& option);
    public static bool TryGetCodeStyleValueAndOptionalNotification(string arg, String& value, NotificationOption& notificationOpt);
    public static bool TryParseNotification(string value, NotificationOption& notification);
}
public class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption`1 : object {
    private static int SerializationVersion;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private NotificationOption <Notification>k__BackingField;
    public static CodeStyleOption`1<T> Default { get; }
    public T Value { get; public set; }
    private int EnumValueAsInt32 { get; }
    public NotificationOption Notification { get; public set; }
    public CodeStyleOption`1(T value, NotificationOption notification);
    public static CodeStyleOption`1<T> get_Default();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
    private int get_EnumValueAsInt32();
    [CompilerGeneratedAttribute]
public NotificationOption get_Notification();
    [CompilerGeneratedAttribute]
public void set_Notification(NotificationOption value);
    public sealed virtual XElement ToXElement();
    private object GetValueForSerialization();
    private string GetTypeNameForSerialization();
    private bool IsZeroOrOneValueOfEnum();
    public static CodeStyleOption`1<T> FromXElement(XElement element);
    private static Func`2<string, T> GetParser(string type);
    private static T Convert(bool b);
    private static T Convert(int i);
    public sealed virtual bool Equals(CodeStyleOption`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions : object {
    internal static CodeStyleOption`1<bool> TrueWithSilentEnforcement;
    internal static CodeStyleOption`1<bool> FalseWithSilentEnforcement;
    internal static CodeStyleOption`1<bool> TrueWithSuggestionEnforcement;
    internal static CodeStyleOption`1<bool> FalseWithSuggestionEnforcement;
    public static PerLanguageOption`1<CodeStyleOption`1<bool>> QualifyFieldAccess;
    public static PerLanguageOption`1<CodeStyleOption`1<bool>> QualifyPropertyAccess;
    public static PerLanguageOption`1<CodeStyleOption`1<bool>> QualifyMethodAccess;
    public static PerLanguageOption`1<CodeStyleOption`1<bool>> QualifyEventAccess;
    public static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferIntrinsicPredefinedTypeKeywordInDeclaration;
    public static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferIntrinsicPredefinedTypeKeywordInMemberAccess;
    internal static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferThrowExpression;
    internal static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferObjectInitializer;
    internal static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferCollectionInitializer;
    internal static PerLanguageOption`1<bool> PreferObjectInitializer_FadeOutCode;
    internal static PerLanguageOption`1<bool> PreferCollectionInitializer_FadeOutCode;
    internal static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferCoalesceExpression;
    internal static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferNullPropagation;
    internal static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferInlinedVariableDeclaration;
    internal static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferDeconstructedVariableDeclaration;
    internal static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferExplicitTupleNames;
    internal static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferAutoProperties;
    internal static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferInferredTupleNames;
    internal static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferInferredAnonymousTypeMemberNames;
    internal static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferIsNullCheckOverReferenceEqualityMethod;
    internal static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferConditionalExpressionOverAssignment;
    internal static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferConditionalExpressionOverReturn;
    private static CodeStyleOption`1<AccessibilityModifiersRequired> s_requireAccessibilityModifiersDefault;
    internal static PerLanguageOption`1<CodeStyleOption`1<AccessibilityModifiersRequired>> RequireAccessibilityModifiers;
    internal static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferReadonly;
    private static CodeStyleOption`1<ParenthesesPreference> s_alwaysForClarityPreference;
    private static CodeStyleOption`1<ParenthesesPreference> s_neverIfUnnecessaryPreference;
    internal static PerLanguageOption`1<CodeStyleOption`1<ParenthesesPreference>> ArithmeticBinaryParentheses;
    internal static PerLanguageOption`1<CodeStyleOption`1<ParenthesesPreference>> OtherBinaryParentheses;
    internal static PerLanguageOption`1<CodeStyleOption`1<ParenthesesPreference>> RelationalBinaryParentheses;
    internal static PerLanguageOption`1<CodeStyleOption`1<ParenthesesPreference>> OtherParentheses;
    private static CodeStyleOptions();
    private static CodeStyleOption`1<AccessibilityModifiersRequired> ParseAccessibilityModifiersRequired(string optionString);
    private static PerLanguageOption`1<CodeStyleOption`1<ParenthesesPreference>> CreateParenthesesOption(string fieldName, CodeStyleOption`1<ParenthesesPreference> defaultValue, string styleName);
    private static Optional`1<CodeStyleOption`1<ParenthesesPreference>> ParseParenthesesPreference(string optionString, Optional`1<CodeStyleOption`1<ParenthesesPreference>> defaultValue);
}
internal enum Microsoft.CodeAnalysis.CodeStyle.ExpressionBodyPreference : Enum {
    public int value__;
    public static ExpressionBodyPreference Never;
    public static ExpressionBodyPreference WhenPossible;
    public static ExpressionBodyPreference WhenOnSingleLine;
}
internal interface Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption {
    public abstract virtual XElement ToXElement();
}
public class Microsoft.CodeAnalysis.CodeStyle.NotificationOption : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ReportDiagnostic <Severity>k__BackingField;
    public static NotificationOption None;
    public static NotificationOption Silent;
    public static NotificationOption Suggestion;
    public static NotificationOption Warning;
    public static NotificationOption Error;
    public string Name { get; public set; }
    public ReportDiagnostic Severity { get; public set; }
    [ObsoleteAttribute("Use Severity instead.")]
public DiagnosticSeverity Value { get; public set; }
    private NotificationOption(string name, ReportDiagnostic severity);
    private static NotificationOption();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public ReportDiagnostic get_Severity();
    [CompilerGeneratedAttribute]
public void set_Severity(ReportDiagnostic value);
    public DiagnosticSeverity get_Value();
    public void set_Value(DiagnosticSeverity value);
    public virtual string ToString();
}
internal enum Microsoft.CodeAnalysis.CodeStyle.ParenthesesPreference : Enum {
    public int value__;
    public static ParenthesesPreference AlwaysForClarity;
    public static ParenthesesPreference NeverIfUnnecessary;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2 : object {
    private ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> _pool;
    private static ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> s_poolInstance;
    private static Dictionary`2<K, ValueSet<K, V>> s_emptyDictionary;
    private PooledDictionary`2<K, ValueSet<K, V>> _dictionary;
    public bool IsEmpty { get; }
    public ImmutableArray`1<V> Item { get; }
    public KeyCollection<K, ValueSet<K, V>> Keys { get; }
    private OrderPreservingMultiDictionary`2(ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> pool);
    private static OrderPreservingMultiDictionary`2();
    public void Free();
    public static ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> CreatePool();
    public static OrderPreservingMultiDictionary`2<K, V> GetInstance();
    private void EnsureDictionary();
    public bool get_IsEmpty();
    public void Add(K k, V v);
    public Enumerator<K, ValueSet<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<K, ValueSet<K, V>>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K,V>.ValueSet>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ImmutableArray`1<V> get_Item(K k);
    public bool Contains(K key, V value);
    public KeyCollection<K, ValueSet<K, V>> get_Keys();
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.IDocumentTextDifferencingService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.DefaultDocumentTextDifferencingService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DefaultDocumentTextDifferencingService/<GetTextChangesAsync>d__0")]
public sealed virtual Task`1<ImmutableArray`1<TextChange>> GetTextChangesAsync(Document oldDocument, Document newDocument, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.DeferredDocumentationProvider : DocumentationProvider {
    private Compilation _compilation;
    public DeferredDocumentationProvider(Compilation compilation);
    protected virtual string GetDocumentationForSymbol(string documentationMemberID, CultureInfo preferredCulture, CancellationToken cancellationToken);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class Microsoft.CodeAnalysis.DiagnosticProvider : object {
    public static void Enable(Workspace workspace, Options options);
    public static void Disable(Workspace workspace);
    private static OptionSet GetOptions(Workspace workspace, Options options);
}
internal abstract class Microsoft.CodeAnalysis.Diagnostics.AbstractDiagnosticPropertiesService : object {
    public sealed virtual ImmutableDictionary`2<string, string> GetAdditionalProperties(Diagnostic diagnostic);
    protected abstract virtual Compilation GetCompilation();
    private ImmutableDictionary`2<string, string> GetAdditionalProperties(Diagnostic diagnostic, Compilation compilation);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AdditionalTextDocument : AdditionalText {
    private TextDocumentState _document;
    public string Path { get; }
    public AdditionalTextDocument(TextDocumentState document);
    public virtual string get_Path();
    public virtual SourceText GetText(CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.AccessibilityExtensions : object {
    [ExtensionAttribute]
internal static bool MatchesSymbol(Accessibility accessibility, ISymbol symbol);
    [ExtensionAttribute]
internal static XElement CreateXElement(Accessibility accessibility);
    internal static Accessibility FromXElement(XElement accessibilityElement);
    private static Accessibility GetAccessibility(ISymbol symbol);
}
internal enum Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization : Enum {
    public int value__;
    public static Capitalization PascalCase;
    public static Capitalization CamelCase;
    public static Capitalization FirstUpper;
    public static Capitalization AllUpper;
    public static Capitalization AllLower;
}
internal static class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.EditorConfigNamingStyleParser : object {
    private static ConditionalWeakTable`2<IReadOnlyDictionary`2<string, object>, NamingStylePreferences> _cache;
    private static object _cacheLock;
    private static SymbolKindOrTypeKind _namespace;
    private static SymbolKindOrTypeKind _class;
    private static SymbolKindOrTypeKind _struct;
    private static SymbolKindOrTypeKind _interface;
    private static SymbolKindOrTypeKind _enum;
    private static SymbolKindOrTypeKind _property;
    private static SymbolKindOrTypeKind _method;
    private static SymbolKindOrTypeKind _localFunction;
    private static SymbolKindOrTypeKind _field;
    private static SymbolKindOrTypeKind _event;
    private static SymbolKindOrTypeKind _delegate;
    private static SymbolKindOrTypeKind _parameter;
    private static SymbolKindOrTypeKind _typeParameter;
    private static SymbolKindOrTypeKind _local;
    private static ImmutableArray`1<SymbolKindOrTypeKind> _all;
    private static ImmutableArray`1<Accessibility> _allAccessibility;
    private static ModifierKind _abstractModifierKind;
    private static ModifierKind _asyncModifierKind;
    private static ModifierKind _constModifierKind;
    private static ModifierKind _readonlyModifierKind;
    private static ModifierKind _staticModifierKind;
    private static ImmutableArray`1<ModifierKind> _allModifierKind;
    private static EditorConfigNamingStyleParser();
    public static NamingStylePreferences GetNamingStylesFromDictionary(IReadOnlyDictionary`2<string, object> allRawConventions);
    public static NamingStylePreferences ParseDictionary(IReadOnlyDictionary`2<string, object> allRawConventions);
    private static Dictionary`2<string, object> TrimDictionary(IReadOnlyDictionary`2<string, object> allRawConventions);
    private static IEnumerable`1<string> GetRuleTitles(IReadOnlyDictionary`2<string, object> allRawConventions);
    private static bool TryGetSerializableNamingRule(string namingRuleTitle, SymbolSpecification symbolSpec, NamingStyle namingStyle, IReadOnlyDictionary`2<string, object> conventionsDictionary, SerializableNamingRule& serializableNamingRule);
    private static bool TryGetRuleSeverity(string namingRuleName, IReadOnlyDictionary`2<string, object> conventionsDictionary, ReportDiagnostic& severity);
    private static ReportDiagnostic ParseEnforcementLevel(string ruleSeverity);
    private static bool TryGetNamingStyleData(string namingRuleName, IReadOnlyDictionary`2<string, object> allRawConventions, NamingStyle& namingStyle);
    private static bool TryGetNamingStyleTitle(string namingRuleName, IReadOnlyDictionary`2<string, object> conventionsDictionary, String& namingStyleName);
    private static string GetNamingRequiredPrefix(string namingStyleName, IReadOnlyDictionary`2<string, object> conventionsDictionary);
    private static string GetNamingRequiredSuffix(string namingStyleName, IReadOnlyDictionary`2<string, object> conventionsDictionary);
    private static string GetNamingWordSeparator(string namingStyleName, IReadOnlyDictionary`2<string, object> conventionsDictionary);
    private static bool TryGetNamingCapitalization(string namingStyleName, IReadOnlyDictionary`2<string, object> conventionsDictionary, Capitalization& capitalization);
    private static string GetStringFromConventionsDictionary(string namingStyleName, string optionName, IReadOnlyDictionary`2<string, object> conventionsDictionary);
    private static bool TryParseCapitalizationScheme(string namingStyleCapitalization, Capitalization& capitalization);
    private static bool TryGetSymbolSpec(string namingRuleTitle, IReadOnlyDictionary`2<string, object> conventionsDictionary, SymbolSpecification& symbolSpec);
    private static bool TryGetSymbolSpecNameForNamingRule(string namingRuleName, IReadOnlyDictionary`2<string, object> conventionsDictionary, String& symbolSpecName);
    private static ImmutableArray`1<SymbolKindOrTypeKind> GetSymbolsApplicableKinds(string symbolSpecName, IReadOnlyDictionary`2<string, object> conventionsDictionary);
    private static ImmutableArray`1<SymbolKindOrTypeKind> ParseSymbolKindList(string symbolSpecApplicableKinds);
    private static ImmutableArray`1<Accessibility> GetSymbolsApplicableAccessibilities(string symbolSpecName, IReadOnlyDictionary`2<string, object> conventionsDictionary);
    private static ImmutableArray`1<Accessibility> ParseAccessibilityKindList(string symbolSpecApplicableAccessibilities);
    private static ImmutableArray`1<ModifierKind> GetSymbolsRequiredModifiers(string symbolSpecName, IReadOnlyDictionary`2<string, object> conventionsDictionary);
    private static ImmutableArray`1<ModifierKind> ParseModifiers(string symbolSpecRequiredModifiers);
}
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.MutableNamingStyle : object {
    [CompilerGeneratedAttribute]
private NamingStyle <NamingStyle>k__BackingField;
    public NamingStyle NamingStyle { get; private set; }
    public Guid ID { get; }
    public string Name { get; public set; }
    public string Prefix { get; public set; }
    public string Suffix { get; public set; }
    public string WordSeparator { get; public set; }
    public Capitalization CapitalizationScheme { get; public set; }
    public MutableNamingStyle(NamingStyle namingStyle);
    [CompilerGeneratedAttribute]
public NamingStyle get_NamingStyle();
    [CompilerGeneratedAttribute]
private void set_NamingStyle(NamingStyle value);
    public Guid get_ID();
    public string get_Name();
    public void set_Name(string value);
    public string get_Prefix();
    public void set_Prefix(string value);
    public string get_Suffix();
    public void set_Suffix(string value);
    public string get_WordSeparator();
    public void set_WordSeparator(string value);
    public Capitalization get_CapitalizationScheme();
    public void set_CapitalizationScheme(Capitalization value);
    internal MutableNamingStyle Clone();
}
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingRule : ValueType {
    public SymbolSpecification SymbolSpecification;
    public NamingStyle NamingStyle;
    public ReportDiagnostic EnforcementLevel;
    public NamingRule(SymbolSpecification symbolSpecification, NamingStyle namingStyle, ReportDiagnostic enforcementLevel);
}
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStylePreferences : object {
    private static int s_serializationVersion;
    public ImmutableArray`1<SymbolSpecification> SymbolSpecifications;
    public ImmutableArray`1<NamingStyle> NamingStyles;
    public ImmutableArray`1<SerializableNamingRule> NamingRules;
    private Lazy`1<NamingStyleRules> _lazyRules;
    private static string _defaultNamingPreferencesString;
    public static NamingStylePreferences Default { get; }
    public static string DefaultNamingPreferencesString { get; }
    public NamingStyleRules Rules { get; }
    internal NamingStylePreferences(ImmutableArray`1<SymbolSpecification> symbolSpecifications, ImmutableArray`1<NamingStyle> namingStyles, ImmutableArray`1<SerializableNamingRule> namingRules);
    private static NamingStylePreferences();
    public static NamingStylePreferences get_Default();
    public static string get_DefaultNamingPreferencesString();
    internal NamingStyle GetNamingStyle(Guid namingStyleID);
    internal SymbolSpecification GetSymbolSpecification(Guid symbolSpecificationID);
    public NamingStyleRules get_Rules();
    public NamingStyleRules CreateRules();
    internal XElement CreateXElement();
    internal static NamingStylePreferences FromXElement(XElement element);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(NamingStylePreferences other);
    public static bool op_Equality(NamingStylePreferences left, NamingStylePreferences right);
    public static bool op_Inequality(NamingStylePreferences left, NamingStylePreferences right);
    public virtual int GetHashCode();
    private static XElement GetUpgradedSerializationIfNecessary(XElement rootElement);
    private static void UpgradeSerialization_4To5(XElement rootElement);
    [CompilerGeneratedAttribute]
private NamingRule <CreateRules>b__14_0(SerializableNamingRule r);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStylePreferencesExtensions : object {
    [ExtensionAttribute]
public static NamingStylePreferences PrependNamingStylePreferences(NamingStylePreferences original, NamingStylePreferences newPreferences);
}
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStyleRules : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<NamingRule> <NamingRules>k__BackingField;
    private ImmutableArray`1<SymbolKind> _symbolKindsThatCanBeOverridden;
    public ImmutableArray`1<NamingRule> NamingRules { get; }
    public NamingStyleRules(ImmutableArray`1<NamingRule> namingRules);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<NamingRule> get_NamingRules();
    internal bool TryGetApplicableRule(ISymbol symbol, NamingRule& applicableRule);
    private bool IsSymbolNameAnalyzable(ISymbol symbol);
    private bool DoesSymbolImplementAnotherSymbol(ISymbol symbol);
    private bool IsInterfaceImplementation(ISymbol symbol);
}
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.SerializableNamingRule : object {
    public Guid SymbolSpecificationID;
    public Guid NamingStyleID;
    public ReportDiagnostic EnforcementLevel;
    public NamingRule GetRule(NamingStylePreferences info);
    internal XElement CreateXElement();
    internal static SerializableNamingRule FromXElement(XElement namingRuleElement);
}
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.SymbolSpecification : object {
    private static SymbolSpecification DefaultSymbolSpecificationTemplate;
    [CompilerGeneratedAttribute]
private Guid <ID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SymbolKindOrTypeKind> <ApplicableSymbolKindList>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Accessibility> <ApplicableAccessibilityList>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ModifierKind> <RequiredModifierList>k__BackingField;
    public Guid ID { get; }
    public string Name { get; }
    public ImmutableArray`1<SymbolKindOrTypeKind> ApplicableSymbolKindList { get; }
    public ImmutableArray`1<Accessibility> ApplicableAccessibilityList { get; }
    public ImmutableArray`1<ModifierKind> RequiredModifierList { get; }
    public SymbolSpecification(Nullable`1<Guid> id, string symbolSpecName, ImmutableArray`1<SymbolKindOrTypeKind> symbolKindList, ImmutableArray`1<Accessibility> accessibilityList, ImmutableArray`1<ModifierKind> modifiers);
    private static SymbolSpecification();
    [CompilerGeneratedAttribute]
public Guid get_ID();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SymbolKindOrTypeKind> get_ApplicableSymbolKindList();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<Accessibility> get_ApplicableAccessibilityList();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ModifierKind> get_RequiredModifierList();
    public static SymbolSpecification CreateDefaultSymbolSpecification();
    internal bool AppliesTo(ISymbol symbol);
    internal bool AppliesTo(SymbolKind symbolKind, Accessibility accessibility);
    internal bool AppliesTo(SymbolKindOrTypeKind kind, DeclarationModifiers modifiers, Nullable`1<Accessibility> accessibility);
    private DeclarationModifiers CollapseModifiers(ImmutableArray`1<ModifierKind> requiredModifierList);
    private bool AnyMatches(ImmutableArray`1<TSymbolMatcher> matchers, ISymbol symbol);
    private bool AnyMatches(ImmutableArray`1<Accessibility> matchers, ISymbol symbol);
    private bool AllMatches(ImmutableArray`1<TSymbolMatcher> matchers, ISymbol symbol);
    internal XElement CreateXElement();
    private XElement CreateSymbolKindsXElement();
    private XElement CreateAccessibilitiesXElement();
    private XElement CreateModifiersXElement();
    internal static SymbolSpecification FromXElement(XElement symbolSpecificationElement);
    private static ImmutableArray`1<SymbolKindOrTypeKind> GetSymbolKindListFromXElement(XElement symbolKindListElement);
    private static ImmutableArray`1<Accessibility> GetAccessibilityListFromXElement(XElement accessibilityListElement);
    private static ImmutableArray`1<ModifierKind> GetModifierListFromXElement(XElement modifierListElement);
}
internal class Microsoft.CodeAnalysis.Diagnostics.DiagnosticData : object {
    private static ImmutableDictionary`2<string, string> s_Properties;
    public string Id;
    public string Category;
    public string Message;
    public string Description;
    public string Title;
    public string HelpLink;
    public DiagnosticSeverity Severity;
    public DiagnosticSeverity DefaultSeverity;
    public bool IsEnabledByDefault;
    public int WarningLevel;
    public IReadOnlyList`1<string> CustomTags;
    public ImmutableDictionary`2<string, string> Properties;
    public bool IsSuppressed;
    public string ENUMessageForBingSearch;
    public Workspace Workspace;
    public ProjectId ProjectId;
    public DiagnosticDataLocation DataLocation;
    public IReadOnlyCollection`1<DiagnosticDataLocation> AdditionalLocations;
    public DocumentId DocumentId { get; }
    public bool HasTextSpan { get; }
    public TextSpan TextSpan { get; }
    internal static ImmutableDictionary`2<string, string> PropertiesForBuildDiagnostic { get; }
    public DiagnosticData(string id, string category, string message, string enuMessageForBingSearch, DiagnosticSeverity severity, bool isEnabledByDefault, int warningLevel, Workspace workspace, ProjectId projectId, DiagnosticDataLocation location, IReadOnlyCollection`1<DiagnosticDataLocation> additionalLocations, string title, string description, string helpLink, bool isSuppressed, IReadOnlyList`1<string> customTags, ImmutableDictionary`2<string, string> properties);
    public DiagnosticData(string id, string category, string message, string enuMessageForBingSearch, DiagnosticSeverity severity, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, IReadOnlyList`1<string> customTags, ImmutableDictionary`2<string, string> properties, Workspace workspace, ProjectId projectId, DiagnosticDataLocation location, IReadOnlyCollection`1<DiagnosticDataLocation> additionalLocations, string title, string description, string helpLink, bool isSuppressed);
    private static DiagnosticData();
    public DocumentId get_DocumentId();
    public bool get_HasTextSpan();
    public TextSpan get_TextSpan();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public TextSpan GetExistingOrCalculatedTextSpan(SourceText text);
    private static TextSpan EnsureInBounds(TextSpan textSpan, SourceText text);
    public DiagnosticData WithCalculatedSpan(SourceText text);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.DiagnosticData/<ToDiagnosticAsync>d__33")]
public Task`1<Diagnostic> ToDiagnosticAsync(Project project, CancellationToken cancellationToken);
    public static TextSpan GetTextSpan(DiagnosticDataLocation dataLocation, SourceText text);
    private static void AdjustBoundaries(DiagnosticDataLocation dataLocation, TextLineCollection lines, Int32& startLine, Int32& startColumn, Int32& endLine, Int32& endColumn);
    private static void SwapIfNeeded(LinePosition& startLinePosition, LinePosition& endLinePosition);
    public static DiagnosticData Create(Workspace workspace, Diagnostic diagnostic);
    public static DiagnosticData Create(Project project, Diagnostic diagnostic);
    private static DiagnosticDataLocation CreateLocation(Document document, Location location);
    public static DiagnosticData Create(Document document, Diagnostic diagnostic);
    private static ImmutableDictionary`2<string, string> GetProperties(Document document, Diagnostic diagnostic);
    public static bool TryCreate(DiagnosticDescriptor descriptor, String[] messageArguments, ProjectId projectId, Workspace workspace, DiagnosticData& diagnosticData, CancellationToken cancellationToken);
    private static DiagnosticSeverity GetEffectiveSeverity(ReportDiagnostic effectiveReportDiagnostic, DiagnosticSeverity defaultSeverity);
    private static void GetLocationInfo(Document document, Location location, TextSpan& sourceSpan, FileLinePositionSpan& originalLineInfo, FileLinePositionSpan& mappedLineInfo);
    internal static ImmutableDictionary`2<string, string> get_PropertiesForBuildDiagnostic();
    internal bool IsBuildDiagnostic();
}
internal class Microsoft.CodeAnalysis.Diagnostics.DiagnosticDataLocation : object {
    public DocumentId DocumentId;
    public Nullable`1<TextSpan> SourceSpan;
    public string MappedFilePath;
    public int MappedStartLine;
    public int MappedStartColumn;
    public int MappedEndLine;
    public int MappedEndColumn;
    public string OriginalFilePath;
    public int OriginalStartLine;
    public int OriginalStartColumn;
    public int OriginalEndLine;
    public int OriginalEndColumn;
    public DiagnosticDataLocation(DocumentId documentId, Nullable`1<TextSpan> sourceSpan, string originalFilePath, int originalStartLine, int originalStartColumn, int originalEndLine, int originalEndColumn, string mappedFilePath, int mappedStartLine, int mappedStartColumn, int mappedEndLine, int mappedEndColumn);
    internal DiagnosticDataLocation WithCalculatedSpan(TextSpan newSourceSpan);
}
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticPropertyConstants : object {
    public static string UnreferencedAssemblyIdentity;
    public static string RequiredLanguageVersion;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.Extensions : object {
    public static CultureInfo s_USCultureInfo;
    private static Extensions();
    [ExtensionAttribute]
public static string GetBingHelpMessage(Diagnostic diagnostic, Workspace workspace);
    [ExtensionAttribute]
public static string GetBingHelpMessage(DiagnosticDescriptor descriptor);
    private static bool GetCustomTypeInBingSearchOption(Workspace workspace);
    [ExtensionAttribute]
public static DiagnosticData GetPrimaryDiagnosticData(CodeFix fix);
    [ExtensionAttribute]
public static ImmutableArray`1<DiagnosticData> GetDiagnosticData(CodeFix fix);
    [ExtensionAttribute]
public static DiagnosticData ToDiagnosticData(Diagnostic diagnostic, Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.Extensions/<ToDiagnosticsAsync>d__7")]
[ExtensionAttribute]
public static Task`1<ImmutableArray`1<Diagnostic>> ToDiagnosticsAsync(IEnumerable`1<DiagnosticData> diagnostics, Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.Extensions/<ConvertLocationsAsync>d__8")]
[ExtensionAttribute]
public static Task`1<IList`1<Location>> ConvertLocationsAsync(IReadOnlyCollection`1<DiagnosticDataLocation> locations, Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.Extensions/<ConvertLocationAsync>d__9")]
[ExtensionAttribute]
public static Task`1<Location> ConvertLocationAsync(DiagnosticDataLocation dataLocation, Project project, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Location ConvertLocation(DiagnosticDataLocation dataLocation, SyntacticDocument document);
    [ExtensionAttribute]
public static string GetAnalyzerId(DiagnosticAnalyzer analyzer);
    private static string GetAssemblyQualifiedName(Type type);
    [ExtensionAttribute]
public static ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResultBuilder> ToResultBuilderMap(AnalysisResult analysisResult, Project project, VersionStamp version, Compilation compilation, IEnumerable`1<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Nullable`1<DiagnosticSeverity> ToDiagnosticSeverity(ReportDiagnostic reportDiagnostic);
    [ExtensionAttribute]
public static ReportDiagnostic WithDefaultSeverity(ReportDiagnostic reportDiagnostic, DiagnosticSeverity defaultSeverity);
    [ExtensionAttribute]
public static ReportDiagnostic ToReportDiagnostic(DiagnosticSeverity diagnosticSeverity);
}
internal interface Microsoft.CodeAnalysis.Diagnostics.IDiagnosticPropertiesService {
    public abstract virtual ImmutableDictionary`2<string, string> GetAdditionalProperties(Diagnostic diagnostic);
}
internal static class Microsoft.CodeAnalysis.Diagnostics.InternalDiagnosticsOptions : object {
    private static string LocalRegistryPath;
    public static Option`1<bool> BlueSquiggleForBuildDiagnostic;
    public static Option`1<bool> CompilationEndCodeFix;
    public static Option`1<bool> UseCompilationEndCodeFixHeuristic;
    public static Option`1<bool> PreferLiveErrorsOnOpenedFiles;
    public static Option`1<bool> PreferBuildErrorsOverLiveErrors;
    public static Option`1<bool> PutCustomTypeInBingSearch;
    public static Option`1<bool> CrashOnAnalyzerException;
    public static Option`1<bool> ProcessHiddenDiagnostics;
    private static InternalDiagnosticsOptions();
}
internal static class Microsoft.CodeAnalysis.Diagnostics.InternalRuntimeDiagnosticOptions : object {
    public static Option`1<bool> Syntax;
    public static Option`1<bool> Semantic;
    private static InternalRuntimeDiagnosticOptions();
}
internal interface Microsoft.CodeAnalysis.Diagnostics.IWorkspaceVenusSpanMappingService {
    public abstract virtual void GetAdjustedDiagnosticSpan(DocumentId documentId, Location location, TextSpan& span, FileLinePositionSpan& originalLineInfo, FileLinePositionSpan& mappedLineInfo);
}
internal static class Microsoft.CodeAnalysis.Diagnostics.WellKnownDiagnosticPropertyNames : object {
    public static string Origin;
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.Differencing.Edit`1 : ValueType {
    private TreeComparer`1<TNode> _comparer;
    private EditKind _kind;
    private TNode _oldNode;
    private TNode _newNode;
    public EditKind Kind { get; }
    public TNode OldNode { get; }
    public TNode NewNode { get; }
    internal Edit`1(EditKind kind, TreeComparer`1<TNode> comparer, TNode oldNode, TNode newNode);
    public EditKind get_Kind();
    public TNode get_OldNode();
    public TNode get_NewNode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Edit`1<TNode> other);
    public virtual int GetHashCode();
    internal string GetDebuggerDisplay();
    private string DisplayPosition(TNode node);
}
public enum Microsoft.CodeAnalysis.Differencing.EditKind : Enum {
    public int value__;
    public static EditKind None;
    public static EditKind Update;
    public static EditKind Insert;
    public static EditKind Delete;
    public static EditKind Move;
    public static EditKind Reorder;
}
public class Microsoft.CodeAnalysis.Differencing.EditScript`1 : object {
    private Match`1<TNode> _match;
    private ImmutableArray`1<Edit`1<TNode>> _edits;
    public ImmutableArray`1<Edit`1<TNode>> Edits { get; }
    public Match`1<TNode> Match { get; }
    private TreeComparer`1<TNode> Comparer { get; }
    private TNode Root1 { get; }
    private TNode Root2 { get; }
    internal EditScript`1(Match`1<TNode> match);
    public ImmutableArray`1<Edit`1<TNode>> get_Edits();
    public Match`1<TNode> get_Match();
    private TreeComparer`1<TNode> get_Comparer();
    private TNode get_Root1();
    private TNode get_Root2();
    private void AddUpdatesInsertsMoves(List`1<Edit`1<TNode>> edits);
    private void ProcessNode(List`1<Edit`1<TNode>> edits, TNode x);
    private void AddDeletes(List`1<Edit`1<TNode>> edits);
    private void AlignChildren(List`1<Edit`1<TNode>> edits, TNode w, TNode x);
    private static bool ContainsPair(Dictionary`2<TNode, TNode> dict, TNode a, TNode b);
}
internal abstract class Microsoft.CodeAnalysis.Differencing.LongestCommonImmutableArraySubsequence`1 : LongestCommonSubsequence`1<ImmutableArray`1<TElement>> {
    protected abstract virtual bool Equals(TElement oldElement, TElement newElement);
    protected sealed virtual bool ItemsEqual(ImmutableArray`1<TElement> oldSequence, int oldIndex, ImmutableArray`1<TElement> newSequence, int newIndex);
    public IEnumerable`1<SequenceEdit> GetEdits(ImmutableArray`1<TElement> oldSequence, ImmutableArray`1<TElement> newSequence);
    public double ComputeDistance(ImmutableArray`1<TElement> oldSequence, ImmutableArray`1<TElement> newSequence);
}
internal abstract class Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1 : object {
    protected abstract virtual bool ItemsEqual(TSequence oldSequence, int oldIndex, TSequence newSequence, int newIndex);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1/<GetMatchingPairs>d__2")]
protected IEnumerable`1<KeyValuePair`2<int, int>> GetMatchingPairs(TSequence oldSequence, int oldLength, TSequence newSequence, int newLength);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1/<GetEdits>d__3")]
protected IEnumerable`1<SequenceEdit> GetEdits(TSequence oldSequence, int oldLength, TSequence newSequence, int newLength);
    protected double ComputeDistance(TSequence oldSequence, int oldLength, TSequence newSequence, int newLength);
    private Stack`1<VArray<TSequence>> ComputeEditPaths(TSequence oldSequence, int oldLength, TSequence newSequence, int newLength);
}
internal class Microsoft.CodeAnalysis.Differencing.LongestCommonSubstring : LongestCommonSubsequence`1<string> {
    private static LongestCommonSubstring s_instance;
    private static LongestCommonSubstring();
    protected virtual bool ItemsEqual(string oldSequence, int oldIndex, string newSequence, int newIndex);
    public static double ComputeDistance(string oldValue, string newValue);
    public static IEnumerable`1<SequenceEdit> GetEdits(string oldValue, string newValue);
}
public class Microsoft.CodeAnalysis.Differencing.Match`1 : object {
    private static double ExactMatchDistance;
    private static double EpsilonDistance;
    private static double MatchingDistance1;
    private static double MatchingDistance2;
    private static double MatchingDistance3;
    private static double MaxDistance;
    private TreeComparer`1<TNode> _comparer;
    private TNode _root1;
    private TNode _root2;
    private Dictionary`2<TNode, TNode> _oneToTwo;
    private Dictionary`2<TNode, TNode> _twoToOne;
    public TreeComparer`1<TNode> Comparer { get; }
    public TNode OldRoot { get; }
    public TNode NewRoot { get; }
    public IReadOnlyDictionary`2<TNode, TNode> Matches { get; }
    public IReadOnlyDictionary`2<TNode, TNode> ReverseMatches { get; }
    internal Match`1(TNode root1, TNode root2, TreeComparer`1<TNode> comparer, IEnumerable`1<KeyValuePair`2<TNode, TNode>> knownMatches);
    private static void CategorizeNodesByLabels(TreeComparer`1<TNode> comparer, TNode root, int labelCount, List`1[]& nodes, Int32& totalCount);
    private void ComputeMatch(List`1[] nodes1, List`1[] nodes2);
    private void ComputeMatchForLabel(int label, List`1<TNode> s1, List`1<TNode> s2);
    private void ComputeMatchForLabel(List`1<TNode> s1, List`1<TNode> s2, int tiedToAncestor, double maxAcceptableDistance);
    internal bool TryAdd(TNode node1, TNode node2);
    internal bool TryGetPartnerInTree1(TNode node2, TNode& partner1);
    internal bool HasPartnerInTree1(TNode node2);
    internal bool TryGetPartnerInTree2(TNode node1, TNode& partner2);
    internal bool HasPartnerInTree2(TNode node1);
    internal bool Contains(TNode node1, TNode node2);
    public TreeComparer`1<TNode> get_Comparer();
    public TNode get_OldRoot();
    public TNode get_NewRoot();
    public IReadOnlyDictionary`2<TNode, TNode> get_Matches();
    public IReadOnlyDictionary`2<TNode, TNode> get_ReverseMatches();
    public bool TryGetNewNode(TNode oldNode, TNode& newNode);
    public bool TryGetOldNode(TNode newNode, TNode& oldNode);
    public EditScript`1<TNode> GetTreeEdits();
    public IEnumerable`1<Edit`1<TNode>> GetSequenceEdits(IEnumerable`1<TNode> oldNodes, IEnumerable`1<TNode> newNodes);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.Differencing.SequenceEdit : ValueType {
    private int _oldIndex;
    private int _newIndex;
    public EditKind Kind { get; }
    public int OldIndex { get; }
    public int NewIndex { get; }
    internal SequenceEdit(int oldIndex, int newIndex);
    public EditKind get_Kind();
    public int get_OldIndex();
    public int get_NewIndex();
    public sealed virtual bool Equals(SequenceEdit other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal string GetDebuggerDisplay();
}
public abstract class Microsoft.CodeAnalysis.Differencing.TreeComparer`1 : object {
    protected internal int LabelCount { get; }
    public EditScript`1<TNode> ComputeEditScript(TNode oldRoot, TNode newRoot);
    public Match`1<TNode> ComputeMatch(TNode oldRoot, TNode newRoot, IEnumerable`1<KeyValuePair`2<TNode, TNode>> knownMatches);
    public abstract virtual double GetDistance(TNode oldNode, TNode newNode);
    public abstract virtual bool ValuesEqual(TNode oldNode, TNode newNode);
    protected internal abstract virtual int get_LabelCount();
    protected internal abstract virtual int GetLabel(TNode node);
    protected internal abstract virtual int TiedToAncestor(int label);
    protected internal abstract virtual IEnumerable`1<TNode> GetChildren(TNode node);
    protected internal abstract virtual IEnumerable`1<TNode> GetDescendants(TNode node);
    protected internal abstract virtual bool TryGetParent(TNode node, TNode& parent);
    internal TNode GetParent(TNode node);
    internal TNode GetAncestor(TNode node, int level);
    protected internal abstract virtual bool TreesEqual(TNode oldNode, TNode newNode);
    protected internal abstract virtual TextSpan GetSpan(TNode node);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.Document : TextDocument {
    private WeakReference`1<SemanticModel> _model;
    private Task`1<SyntaxTree> _syntaxTreeResultTask;
    private AsyncLazy`1<DocumentOptionSet> _cachedOptions;
    private DocumentState DocumentState { get; }
    public SourceCodeKind SourceCodeKind { get; }
    public bool SupportsSyntaxTree { get; }
    public bool SupportsSemanticModel { get; }
    internal Document(Project project, DocumentState state);
    private DocumentState get_DocumentState();
    public SourceCodeKind get_SourceCodeKind();
    internal bool HasInfoChanged(Document otherDocument);
    internal DocumentInfo GetDocumentInfoWithoutContent();
    internal bool HasTextChanged(Document otherDocument);
    public bool TryGetSyntaxTree(SyntaxTree& syntaxTree);
    public bool TryGetSyntaxVersion(VersionStamp& version);
    internal bool TryGetTopLevelChangeTextVersion(VersionStamp& version);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Document/<GetSyntaxVersionAsync>d__13")]
public Task`1<VersionStamp> GetSyntaxVersionAsync(CancellationToken cancellationToken);
    public bool get_SupportsSyntaxTree();
    public bool get_SupportsSemanticModel();
    public Task`1<SyntaxTree> GetSyntaxTreeAsync(CancellationToken cancellationToken);
    internal SyntaxTree GetSyntaxTreeSynchronously(CancellationToken cancellationToken);
    public bool TryGetSyntaxRoot(SyntaxNode& root);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Document/<GetSyntaxRootAsync>d__21")]
public Task`1<SyntaxNode> GetSyntaxRootAsync(CancellationToken cancellationToken);
    internal SyntaxNode GetSyntaxRootSynchronously(CancellationToken cancellationToken);
    public bool TryGetSemanticModel(SemanticModel& semanticModel);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Document/<GetSemanticModelAsync>d__24")]
public Task`1<SemanticModel> GetSemanticModelAsync(CancellationToken cancellationToken);
    public Document WithSourceCodeKind(SourceCodeKind kind);
    public Document WithText(SourceText text);
    public Document WithSyntaxRoot(SyntaxNode root);
    public Document WithName(string name);
    public Document WithFolders(IEnumerable`1<string> folders);
    public Document WithFilePath(string filePath);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Document/<GetTextChangesAsync>d__31")]
public Task`1<IEnumerable`1<TextChange>> GetTextChangesAsync(Document oldDocument, CancellationToken cancellationToken);
    public ImmutableArray`1<DocumentId> GetLinkedDocumentIds();
    internal Document WithFrozenPartialSemantics(CancellationToken cancellationToken);
    private string GetDebuggerDisplay();
    public Task`1<DocumentOptionSet> GetOptionsAsync(CancellationToken cancellationToken);
    internal Task`1<DocumentOptionSet> GetOptionsAsync(OptionSet solutionOptions, CancellationToken cancellationToken);
    private void InitializeCachedOptions(OptionSet solutionOptions, CancellationToken cancellationToken);
}
public class Microsoft.CodeAnalysis.DocumentActiveContextChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Solution <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceTextContainer <SourceTextContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <OldActiveContextDocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <NewActiveContextDocumentId>k__BackingField;
    public Solution Solution { get; }
    public SourceTextContainer SourceTextContainer { get; }
    public DocumentId OldActiveContextDocumentId { get; }
    public DocumentId NewActiveContextDocumentId { get; }
    public DocumentActiveContextChangedEventArgs(Solution solution, SourceTextContainer sourceTextContainer, DocumentId oldActiveContextDocumentId, DocumentId newActiveContextDocumentId);
    [CompilerGeneratedAttribute]
public Solution get_Solution();
    [CompilerGeneratedAttribute]
public SourceTextContainer get_SourceTextContainer();
    [CompilerGeneratedAttribute]
public DocumentId get_OldActiveContextDocumentId();
    [CompilerGeneratedAttribute]
public DocumentId get_NewActiveContextDocumentId();
}
public class Microsoft.CodeAnalysis.DocumentDiagnostic : WorkspaceDiagnostic {
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    public DocumentId DocumentId { get; }
    public DocumentDiagnostic(WorkspaceDiagnosticKind kind, string message, DocumentId documentId);
    [CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
}
public class Microsoft.CodeAnalysis.DocumentEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    public Document Document { get; }
    public DocumentEventArgs(Document document);
    [CompilerGeneratedAttribute]
public Document get_Document();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.DocumentId : object {
    [CompilerGeneratedAttribute]
private ProjectId <ProjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    private string _debugName;
    public ProjectId ProjectId { get; }
    public Guid Id { get; }
    internal string DebugName { get; }
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    private DocumentId(ProjectId projectId, Guid guid, string debugName);
    [CompilerGeneratedAttribute]
public ProjectId get_ProjectId();
    [CompilerGeneratedAttribute]
public Guid get_Id();
    public static DocumentId CreateNewId(ProjectId projectId, string debugName);
    public static DocumentId CreateFromSerialized(ProjectId projectId, Guid id, string debugName);
    internal string get_DebugName();
    internal string GetDebuggerDisplay();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DocumentId other);
    public virtual int GetHashCode();
    public static bool op_Equality(DocumentId left, DocumentId right);
    public static bool op_Inequality(DocumentId left, DocumentId right);
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    internal static DocumentId ReadFrom(ObjectReader reader);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay() , nq}")]
public class Microsoft.CodeAnalysis.DocumentInfo : object {
    [CompilerGeneratedAttribute]
private DocumentAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private TextLoader <TextLoader>k__BackingField;
    internal DocumentAttributes Attributes { get; }
    public DocumentId Id { get; }
    public string Name { get; }
    public IReadOnlyList`1<string> Folders { get; }
    public SourceCodeKind SourceCodeKind { get; }
    public string FilePath { get; }
    public bool IsGenerated { get; }
    public TextLoader TextLoader { get; }
    private DocumentInfo(DocumentAttributes attributes, TextLoader loader);
    [CompilerGeneratedAttribute]
internal DocumentAttributes get_Attributes();
    public DocumentId get_Id();
    public string get_Name();
    public IReadOnlyList`1<string> get_Folders();
    public SourceCodeKind get_SourceCodeKind();
    public string get_FilePath();
    public bool get_IsGenerated();
    [CompilerGeneratedAttribute]
public TextLoader get_TextLoader();
    public static DocumentInfo Create(DocumentId id, string name, IEnumerable`1<string> folders, SourceCodeKind sourceCodeKind, TextLoader loader, string filePath, bool isGenerated);
    private DocumentInfo With(DocumentAttributes attributes, Optional`1<TextLoader> loader);
    public DocumentInfo WithId(DocumentId id);
    public DocumentInfo WithName(string name);
    public DocumentInfo WithFolders(IEnumerable`1<string> folders);
    public DocumentInfo WithSourceCodeKind(SourceCodeKind kind);
    public DocumentInfo WithTextLoader(TextLoader loader);
    public DocumentInfo WithFilePath(string filePath);
    private string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.DocumentState : TextDocumentState {
    private static Func`3<string, PreservationMode, string> s_fullParseLog;
    private HostLanguageServices _languageServices;
    private ParseOptions _options;
    private ValueSource`1<TreeAndVersion> _treeSource;
    private static int MaxTextChangeRangeLength;
    private static ConditionalWeakTable`2<SyntaxTree, DocumentId> s_syntaxTreeToIdMap;
    internal bool SupportsSyntaxTree { get; }
    public HostLanguageServices LanguageServices { get; }
    public ParseOptions ParseOptions { get; }
    public SourceCodeKind SourceCodeKind { get; }
    public bool IsGenerated { get; }
    private DocumentState(HostLanguageServices languageServices, SolutionServices solutionServices, DocumentInfo info, ParseOptions options, SourceText sourceTextOpt, ValueSource`1<TextAndVersion> textSource, ValueSource`1<TreeAndVersion> treeSource, ValueSource`1<DocumentStateChecksums> lazyChecksums);
    private static DocumentState();
    internal bool get_SupportsSyntaxTree();
    public static DocumentState Create(DocumentInfo info, ParseOptions options, HostLanguageServices language, SolutionServices services);
    private static string GetSyntaxTreeFilePath(DocumentInfo info);
    private static ValueSource`1<TreeAndVersion> CreateLazyFullyParsedTree(ValueSource`1<TextAndVersion> newTextSource, ProjectId cacheKey, string filePath, ParseOptions options, HostLanguageServices languageServices, SolutionServices solutionServices, PreservationMode mode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentState/<FullyParseTreeAsync>d__10")]
private static Task`1<TreeAndVersion> FullyParseTreeAsync(ValueSource`1<TextAndVersion> newTextSource, ProjectId cacheKey, string filePath, ParseOptions options, HostLanguageServices languageServices, SolutionServices solutionServices, PreservationMode mode, CancellationToken cancellationToken);
    private static TreeAndVersion FullyParseTree(ValueSource`1<TextAndVersion> newTextSource, ProjectId cacheKey, string filePath, ParseOptions options, HostLanguageServices languageServices, SolutionServices solutionServices, PreservationMode mode, CancellationToken cancellationToken);
    private static TreeAndVersion CreateTreeAndVersion(ValueSource`1<TextAndVersion> newTextSource, ProjectId cacheKey, string filePath, ParseOptions options, HostLanguageServices languageServices, PreservationMode mode, TextAndVersion textAndVersion, CancellationToken cancellationToken);
    private static ValueSource`1<TreeAndVersion> CreateLazyIncrementallyParsedTree(ValueSource`1<TreeAndVersion> oldTreeSource, ValueSource`1<TextAndVersion> newTextSource);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentState/<IncrementallyParseTreeAsync>d__14")]
private static Task`1<TreeAndVersion> IncrementallyParseTreeAsync(ValueSource`1<TreeAndVersion> oldTreeSource, ValueSource`1<TextAndVersion> newTextSource, CancellationToken cancellationToken);
    private static TreeAndVersion IncrementallyParseTree(ValueSource`1<TreeAndVersion> oldTreeSource, ValueSource`1<TextAndVersion> newTextSource, CancellationToken cancellationToken);
    private static TreeAndVersion IncrementallyParse(TextAndVersion newTextAndVersion, TreeAndVersion oldTreeAndVersion, CancellationToken cancellationToken);
    private static TreeAndVersion MakeNewTreeAndVersion(SyntaxTree oldTree, SourceText oldText, VersionStamp oldVersion, SyntaxTree newTree, SourceText newText, VersionStamp newVersion);
    private static bool TopLevelChanged(SyntaxTree oldTree, SourceText oldText, SyntaxTree newTree, SourceText newText);
    public bool HasContentChanged(DocumentState oldState);
    public bool HasTextChanged(DocumentState oldState);
    public DocumentState UpdateParseOptions(ParseOptions options);
    private DocumentState SetParseOptions(ParseOptions options);
    public DocumentState UpdateSourceCodeKind(SourceCodeKind kind);
    public DocumentState UpdateName(string name);
    public DocumentState UpdateFolders(IList`1<string> folders);
    public DocumentState UpdateFilePath(string filePath);
    public DocumentState UpdateText(SourceText newText, PreservationMode mode);
    public DocumentState UpdateText(TextAndVersion newTextAndVersion, PreservationMode mode);
    public DocumentState UpdateText(TextLoader loader, PreservationMode mode);
    internal DocumentState UpdateText(TextLoader loader, SourceText textOpt, PreservationMode mode);
    internal DocumentState UpdateTree(SyntaxNode newRoot, PreservationMode mode);
    private VersionStamp GetNewTreeVersionForUpdatedTree(SyntaxNode newRoot, VersionStamp newTextVersion, PreservationMode mode);
    private static Tuple`2<ValueSource`1<TextAndVersion>, TreeAndVersion> CreateRecoverableTextAndTree(SyntaxNode newRoot, VersionStamp textVersion, VersionStamp treeVersion, Encoding encoding, DocumentInfo info, ParseOptions options, ISyntaxTreeFactoryService factory, PreservationMode mode, SolutionServices solutionServices);
    private static SourceText BuildRecoverableTreeText(SyntaxTree tree, Encoding encoding, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentState/<BuildRecoverableTreeTextAsync>d__36")]
private static Task`1<SourceText> BuildRecoverableTreeTextAsync(SyntaxTree tree, Encoding encoding, CancellationToken cancellationToken);
    private VersionStamp GetNewerVersion();
    public bool TryGetSyntaxTree(SyntaxTree& syntaxTree);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentState/<GetSyntaxTreeAsync>d__39")]
public ValueTask`1<SyntaxTree> GetSyntaxTreeAsync(CancellationToken cancellationToken);
    internal SyntaxTree GetSyntaxTree(CancellationToken cancellationToken);
    public bool TryGetTopLevelChangeTextVersion(VersionStamp& version);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentState/<GetTopLevelChangeTextVersionAsync>d__42")]
public virtual Task`1<VersionStamp> GetTopLevelChangeTextVersionAsync(CancellationToken cancellationToken);
    private static void BindSyntaxTreeToId(SyntaxTree tree, DocumentId id);
    public static DocumentId GetDocumentIdForTree(SyntaxTree tree);
    public HostLanguageServices get_LanguageServices();
    public ParseOptions get_ParseOptions();
    public SourceCodeKind get_SourceCodeKind();
    public bool get_IsGenerated();
}
public enum Microsoft.CodeAnalysis.Editing.DeclarationKind : Enum {
    public int value__;
    public static DeclarationKind None;
    public static DeclarationKind CompilationUnit;
    public static DeclarationKind Class;
    public static DeclarationKind Struct;
    public static DeclarationKind Interface;
    public static DeclarationKind Enum;
    public static DeclarationKind Delegate;
    public static DeclarationKind Method;
    public static DeclarationKind Operator;
    public static DeclarationKind ConversionOperator;
    public static DeclarationKind Constructor;
    public static DeclarationKind Destructor;
    public static DeclarationKind Field;
    public static DeclarationKind Property;
    public static DeclarationKind Indexer;
    public static DeclarationKind EnumMember;
    public static DeclarationKind Event;
    public static DeclarationKind CustomEvent;
    public static DeclarationKind Namespace;
    public static DeclarationKind NamespaceImport;
    public static DeclarationKind Parameter;
    public static DeclarationKind Variable;
    public static DeclarationKind Attribute;
    public static DeclarationKind LambdaExpression;
    public static DeclarationKind GetAccessor;
    public static DeclarationKind SetAccessor;
    public static DeclarationKind AddAccessor;
    public static DeclarationKind RemoveAccessor;
    public static DeclarationKind RaiseAccessor;
}
public class Microsoft.CodeAnalysis.Editing.DeclarationModifiers : ValueType {
    private Modifiers _modifiers;
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsNew { get; }
    public bool IsUnsafe { get; }
    public bool IsReadOnly { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsSealed { get; }
    public bool IsConst { get; }
    public bool IsWithEvents { get; }
    public bool IsPartial { get; }
    public bool IsAsync { get; }
    public bool IsWriteOnly { get; }
    public bool IsRef { get; }
    public static DeclarationModifiers None { get; }
    public static DeclarationModifiers Static { get; }
    public static DeclarationModifiers Abstract { get; }
    public static DeclarationModifiers New { get; }
    public static DeclarationModifiers Unsafe { get; }
    public static DeclarationModifiers ReadOnly { get; }
    public static DeclarationModifiers Virtual { get; }
    public static DeclarationModifiers Override { get; }
    public static DeclarationModifiers Sealed { get; }
    public static DeclarationModifiers Const { get; }
    public static DeclarationModifiers WithEvents { get; }
    public static DeclarationModifiers Partial { get; }
    public static DeclarationModifiers Async { get; }
    public static DeclarationModifiers WriteOnly { get; }
    public static DeclarationModifiers Ref { get; }
    private DeclarationModifiers(Modifiers modifiers);
    internal DeclarationModifiers(bool isStatic, bool isAbstract, bool isNew, bool isUnsafe, bool isReadOnly, bool isVirtual, bool isOverride, bool isSealed, bool isConst, bool isWithEvents, bool isPartial, bool isAsync, bool isWriteOnly);
    public static DeclarationModifiers From(ISymbol symbol);
    public bool get_IsStatic();
    public bool get_IsAbstract();
    public bool get_IsNew();
    public bool get_IsUnsafe();
    public bool get_IsReadOnly();
    public bool get_IsVirtual();
    public bool get_IsOverride();
    public bool get_IsSealed();
    public bool get_IsConst();
    public bool get_IsWithEvents();
    public bool get_IsPartial();
    public bool get_IsAsync();
    public bool get_IsWriteOnly();
    public bool get_IsRef();
    public DeclarationModifiers WithIsStatic(bool isStatic);
    public DeclarationModifiers WithIsAbstract(bool isAbstract);
    public DeclarationModifiers WithIsNew(bool isNew);
    public DeclarationModifiers WithIsUnsafe(bool isUnsafe);
    public DeclarationModifiers WithIsReadOnly(bool isReadOnly);
    public DeclarationModifiers WithIsVirtual(bool isVirtual);
    public DeclarationModifiers WithIsOverride(bool isOverride);
    public DeclarationModifiers WithIsSealed(bool isSealed);
    public DeclarationModifiers WithIsConst(bool isConst);
    public DeclarationModifiers WithWithEvents(bool withEvents);
    public DeclarationModifiers WithPartial(bool isPartial);
    public DeclarationModifiers WithAsync(bool isAsync);
    public DeclarationModifiers WithIsWriteOnly(bool isWriteOnly);
    private static Modifiers SetFlag(Modifiers existing, Modifiers modifier, bool isSet);
    public static DeclarationModifiers get_None();
    public static DeclarationModifiers get_Static();
    public static DeclarationModifiers get_Abstract();
    public static DeclarationModifiers get_New();
    public static DeclarationModifiers get_Unsafe();
    public static DeclarationModifiers get_ReadOnly();
    public static DeclarationModifiers get_Virtual();
    public static DeclarationModifiers get_Override();
    public static DeclarationModifiers get_Sealed();
    public static DeclarationModifiers get_Const();
    public static DeclarationModifiers get_WithEvents();
    public static DeclarationModifiers get_Partial();
    public static DeclarationModifiers get_Async();
    public static DeclarationModifiers get_WriteOnly();
    public static DeclarationModifiers get_Ref();
    public static DeclarationModifiers op_BitwiseOr(DeclarationModifiers left, DeclarationModifiers right);
    public static DeclarationModifiers op_BitwiseAnd(DeclarationModifiers left, DeclarationModifiers right);
    public static DeclarationModifiers op_Addition(DeclarationModifiers left, DeclarationModifiers right);
    public static DeclarationModifiers op_Subtraction(DeclarationModifiers left, DeclarationModifiers right);
    public sealed virtual bool Equals(DeclarationModifiers modifiers);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DeclarationModifiers left, DeclarationModifiers right);
    public static bool op_Inequality(DeclarationModifiers left, DeclarationModifiers right);
    public virtual string ToString();
    public static bool TryParse(string value, DeclarationModifiers& modifiers);
}
public class Microsoft.CodeAnalysis.Editing.DocumentEditor : SyntaxEditor {
    private Document _document;
    private SemanticModel _model;
    public Document OriginalDocument { get; }
    public SemanticModel SemanticModel { get; }
    private DocumentEditor(Document document, SemanticModel model, SyntaxNode root);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.DocumentEditor/<CreateAsync>d__3")]
public static Task`1<DocumentEditor> CreateAsync(Document document, CancellationToken cancellationToken);
    public Document get_OriginalDocument();
    public SemanticModel get_SemanticModel();
    public Document GetChangedDocument();
}
internal class Microsoft.CodeAnalysis.Editing.GenerationOptions : object {
    public static PerLanguageOption`1<bool> PlaceSystemNamespaceFirst;
    public static PerLanguageOption`1<bool> SeparateImportDirectiveGroups;
    private static GenerationOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Editing.GenerationOptionsProvider : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
public static class Microsoft.CodeAnalysis.Editing.ImportAdder : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdder/<AddImportsAsync>d__0")]
public static Task`1<Document> AddImportsAsync(Document document, OptionSet options, CancellationToken cancellationToken);
    public static Task`1<Document> AddImportsAsync(Document document, TextSpan span, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdder/<AddImportsAsync>d__2")]
public static Task`1<Document> AddImportsAsync(Document document, SyntaxAnnotation annotation, OptionSet options, CancellationToken cancellationToken);
    public static Task`1<Document> AddImportsAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet options, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Editing.ImportAdderService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdderService/<AddImportsAsync>d__0")]
public Task`1<Document> AddImportsAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet options, CancellationToken cancellationToken);
    protected abstract virtual INamespaceSymbol GetExplicitNamespaceSymbol(SyntaxNode node, SemanticModel model);
}
public enum Microsoft.CodeAnalysis.Editing.OperatorKind : Enum {
    public int value__;
    public static OperatorKind ImplicitConversion;
    public static OperatorKind ExplicitConversion;
    public static OperatorKind Addition;
    public static OperatorKind BitwiseAnd;
    public static OperatorKind BitwiseOr;
    public static OperatorKind Decrement;
    public static OperatorKind Division;
    public static OperatorKind Equality;
    public static OperatorKind ExclusiveOr;
    public static OperatorKind False;
    public static OperatorKind GreaterThan;
    public static OperatorKind GreaterThanOrEqual;
    public static OperatorKind Increment;
    public static OperatorKind Inequality;
    public static OperatorKind LeftShift;
    public static OperatorKind LessThan;
    public static OperatorKind LessThanOrEqual;
    public static OperatorKind LogicalNot;
    public static OperatorKind Modulus;
    public static OperatorKind Multiply;
    public static OperatorKind OnesComplement;
    public static OperatorKind RightShift;
    public static OperatorKind Subtraction;
    public static OperatorKind True;
    public static OperatorKind UnaryNegation;
    public static OperatorKind UnaryPlus;
}
public class Microsoft.CodeAnalysis.Editing.SolutionEditor : object {
    private Solution _solution;
    private Dictionary`2<DocumentId, DocumentEditor> _documentEditors;
    public Solution OriginalSolution { get; }
    public SolutionEditor(Solution solution);
    public Solution get_OriginalSolution();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SolutionEditor/<GetDocumentEditorAsync>d__5")]
public Task`1<DocumentEditor> GetDocumentEditorAsync(DocumentId id, CancellationToken cancellationToken);
    public Solution GetChangedSolution();
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind : Enum {
    public int value__;
    public static SpecialTypeConstraintKind None;
    public static SpecialTypeConstraintKind ReferenceType;
    public static SpecialTypeConstraintKind ValueType;
    public static SpecialTypeConstraintKind Constructor;
}
public class Microsoft.CodeAnalysis.Editing.SymbolEditor : object {
    private Solution _originalSolution;
    private Solution _currentSolution;
    private ImmutableDictionary`2<string, ImmutableArray`1<ProjectId>> _assemblyNameToProjectIdMap;
    public Solution OriginalSolution { get; }
    public Solution ChangedSolution { get; }
    private SymbolEditor(Solution solution);
    public static SymbolEditor Create(Solution solution);
    public static SymbolEditor Create(Document document);
    public Solution get_OriginalSolution();
    public Solution get_ChangedSolution();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<GetChangedDocuments>d__9")]
public IEnumerable`1<Document> GetChangedDocuments();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<GetCurrentSymbolAsync>d__10")]
public Task`1<ISymbol> GetCurrentSymbolAsync(ISymbol symbol, CancellationToken cancellationToken);
    private ImmutableArray`1<ProjectId> GetProjectsForAssembly(IAssemblySymbol assembly);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<GetSymbolAsync>d__13")]
private Task`1<ISymbol> GetSymbolAsync(Solution solution, ProjectId projectId, string symbolId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<GetCurrentDeclarationsAsync>d__14")]
public Task`1<IReadOnlyList`1<SyntaxNode>> GetCurrentDeclarationsAsync(ISymbol symbol, CancellationToken cancellationToken);
    private IEnumerable`1<SyntaxNode> GetDeclarations(ISymbol symbol);
    private bool TryGetBestDeclarationForSingleEdit(ISymbol symbol, SyntaxNode& declaration);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<EditOneDeclarationAsync>d__19")]
public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, DeclarationEditAction editAction, CancellationToken cancellationToken);
    private void CheckSymbolArgument(ISymbol currentSymbol, ISymbol argSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<EditDeclarationAsync>d__22")]
private Task`1<ISymbol> EditDeclarationAsync(ISymbol currentSymbol, SyntaxNode declaration, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, Location location, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, Location location, DeclarationEditAction editAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<EditOneDeclarationAsync>d__25")]
private Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, DocumentId documentId, int position, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<EditOneDeclarationAsync>d__26")]
public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, ISymbol member, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, ISymbol member, DeclarationEditAction editAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<EditAllDeclarationsAsync>d__28")]
public Task`1<ISymbol> EditAllDeclarationsAsync(ISymbol symbol, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    public Task`1<ISymbol> EditAllDeclarationsAsync(ISymbol symbol, DeclarationEditAction editAction, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private SyntaxNode <GetDeclarations>b__15_1(SyntaxNode n);
    [CompilerGeneratedAttribute]
private DocumentId <EditAllDeclarationsAsync>b__28_0(SyntaxNode d);
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions/<GetBaseOrInterfaceDeclarationReferenceAsync>d__0")]
[ExtensionAttribute]
public static Task`1<SyntaxNode> GetBaseOrInterfaceDeclarationReferenceAsync(SymbolEditor editor, ISymbol symbol, ITypeSymbol baseOrInterfaceType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions/<SetBaseTypeAsync>d__1")]
[ExtensionAttribute]
public static Task`1<ISymbol> SetBaseTypeAsync(SymbolEditor editor, INamedTypeSymbol symbol, Func`2<SyntaxGenerator, SyntaxNode> getNewBaseType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ISymbol> SetBaseTypeAsync(SymbolEditor editor, INamedTypeSymbol symbol, ITypeSymbol newBaseType, CancellationToken cancellationToken);
}
public class Microsoft.CodeAnalysis.Editing.SyntaxEditor : object {
    private SyntaxGenerator _generator;
    private List`1<Change> _changes;
    [CompilerGeneratedAttribute]
private SyntaxNode <OriginalRoot>k__BackingField;
    public SyntaxNode OriginalRoot { get; }
    public SyntaxGenerator Generator { get; }
    public SyntaxEditor(SyntaxNode root, Workspace workspace);
    internal SyntaxEditor(SyntaxNode root, SyntaxGenerator generator);
    [CompilerGeneratedAttribute]
public SyntaxNode get_OriginalRoot();
    public SyntaxGenerator get_Generator();
    public SyntaxNode GetChangedRoot();
    public void TrackNode(SyntaxNode node);
    public void RemoveNode(SyntaxNode node);
    public void RemoveNode(SyntaxNode node, SyntaxRemoveOptions options);
    public void ReplaceNode(SyntaxNode node, Func`3<SyntaxNode, SyntaxGenerator, SyntaxNode> computeReplacement);
    internal void ReplaceNode(SyntaxNode node, Func`4<SyntaxNode, SyntaxGenerator, TArgument, SyntaxNode> computeReplacement, TArgument argument);
    public void ReplaceNode(SyntaxNode node, SyntaxNode newNode);
    public void InsertBefore(SyntaxNode node, IEnumerable`1<SyntaxNode> newNodes);
    public void InsertBefore(SyntaxNode node, SyntaxNode newNode);
    public void InsertAfter(SyntaxNode node, IEnumerable`1<SyntaxNode> newNodes);
    public void InsertAfter(SyntaxNode node, SyntaxNode newNode);
    private void CheckNodeInTree(SyntaxNode node);
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions : object {
    [ExtensionAttribute]
public static void SetAccessibility(SyntaxEditor editor, SyntaxNode declaration, Accessibility accessibility);
    [ExtensionAttribute]
public static void SetModifiers(SyntaxEditor editor, SyntaxNode declaration, DeclarationModifiers modifiers);
    [ExtensionAttribute]
internal static void RemoveAllAttributes(SyntaxEditor editor, SyntaxNode declaration);
    [ExtensionAttribute]
internal static void RemoveAllComments(SyntaxEditor editor, SyntaxNode declaration);
    [ExtensionAttribute]
internal static void RemoveAllTypeInheritance(SyntaxEditor editor, SyntaxNode declaration);
    [ExtensionAttribute]
public static void SetName(SyntaxEditor editor, SyntaxNode declaration, string name);
    [ExtensionAttribute]
public static void SetType(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode type);
    [ExtensionAttribute]
public static void SetTypeParameters(SyntaxEditor editor, SyntaxNode declaration, IEnumerable`1<string> typeParameters);
    [ExtensionAttribute]
public static void SetTypeConstraint(SyntaxEditor editor, SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kind, IEnumerable`1<SyntaxNode> types);
    [ExtensionAttribute]
public static void SetExpression(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode expression);
    [ExtensionAttribute]
public static void SetStatements(SyntaxEditor editor, SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    [ExtensionAttribute]
public static void SetGetAccessorStatements(SyntaxEditor editor, SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    [ExtensionAttribute]
public static void SetSetAccessorStatements(SyntaxEditor editor, SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    [ExtensionAttribute]
public static void AddParameter(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode parameter);
    [ExtensionAttribute]
public static void InsertParameter(SyntaxEditor editor, SyntaxNode declaration, int index, SyntaxNode parameter);
    [ExtensionAttribute]
public static void AddAttribute(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode attribute);
    [ExtensionAttribute]
public static void AddReturnAttribute(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode attribute);
    [ExtensionAttribute]
public static void AddAttributeArgument(SyntaxEditor editor, SyntaxNode attributeDeclaration, SyntaxNode attributeArgument);
    [ExtensionAttribute]
public static void AddMember(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode member);
    [ExtensionAttribute]
public static void InsertMembers(SyntaxEditor editor, SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> members);
    [ExtensionAttribute]
public static void AddInterfaceType(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode interfaceType);
    [ExtensionAttribute]
public static void AddBaseType(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode baseType);
}
public abstract class Microsoft.CodeAnalysis.Editing.SyntaxGenerator : object {
    public static SyntaxRemoveOptions DefaultRemoveOptions;
    private static Char[] s_dotSeparator;
    internal SyntaxTrivia CarriageReturnLineFeed { get; }
    internal SyntaxTrivia ElasticCarriageReturnLineFeed { get; }
    internal bool RequiresExplicitImplementationForInterfaceMembers { get; }
    private static SyntaxGenerator();
    internal abstract virtual SyntaxTrivia get_CarriageReturnLineFeed();
    internal abstract virtual SyntaxTrivia get_ElasticCarriageReturnLineFeed();
    internal abstract virtual bool get_RequiresExplicitImplementationForInterfaceMembers();
    internal abstract virtual SyntaxTrivia EndOfLine(string text);
    public static SyntaxGenerator GetGenerator(Workspace workspace, string language);
    public static SyntaxGenerator GetGenerator(Document document);
    public static SyntaxGenerator GetGenerator(Project project);
    public SyntaxNode GetDeclaration(SyntaxNode node);
    public SyntaxNode GetDeclaration(SyntaxNode node, DeclarationKind kind);
    public abstract virtual SyntaxNode FieldDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, SyntaxNode initializer);
    public SyntaxNode FieldDeclaration(IFieldSymbol field);
    public SyntaxNode FieldDeclaration(IFieldSymbol field, SyntaxNode initializer);
    public abstract virtual SyntaxNode MethodDeclaration(string name, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<string> typeParameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode MethodDeclaration(IMethodSymbol method, IEnumerable`1<SyntaxNode> statements);
    internal SyntaxNode MethodDeclaration(IMethodSymbol method, string name, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode OperatorDeclaration(OperatorKind kind, IEnumerable`1<SyntaxNode> parameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode OperatorDeclaration(IMethodSymbol method, IEnumerable`1<SyntaxNode> statements);
    private OperatorKind GetOperatorKind(IMethodSymbol method);
    public abstract virtual SyntaxNode ParameterDeclaration(string name, SyntaxNode type, SyntaxNode initializer, RefKind refKind);
    public SyntaxNode ParameterDeclaration(IParameterSymbol symbol, SyntaxNode initializer);
    public abstract virtual SyntaxNode PropertyDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    public SyntaxNode PropertyDeclaration(IPropertySymbol property, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    public SyntaxNode WithAccessorDeclarations(SyntaxNode declaration, SyntaxNode[] accessorDeclarations);
    public abstract virtual SyntaxNode WithAccessorDeclarations(SyntaxNode declaration, IEnumerable`1<SyntaxNode> accessorDeclarations);
    public abstract virtual SyntaxNode GetAccessorDeclaration(Accessibility accessibility, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode SetAccessorDeclaration(Accessibility accessibility, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode IndexerDeclaration(IEnumerable`1<SyntaxNode> parameters, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    public SyntaxNode IndexerDeclaration(IPropertySymbol indexer, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    public abstract virtual SyntaxNode AddEventHandler(SyntaxNode event, SyntaxNode handler);
    public abstract virtual SyntaxNode RemoveEventHandler(SyntaxNode event, SyntaxNode handler);
    public abstract virtual SyntaxNode EventDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers);
    public SyntaxNode EventDeclaration(IEventSymbol symbol);
    public abstract virtual SyntaxNode CustomEventDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<SyntaxNode> addAccessorStatements, IEnumerable`1<SyntaxNode> removeAccessorStatements);
    public SyntaxNode CustomEventDeclaration(IEventSymbol symbol, IEnumerable`1<SyntaxNode> addAccessorStatements, IEnumerable`1<SyntaxNode> removeAccessorStatements);
    public abstract virtual SyntaxNode ConstructorDeclaration(string containingTypeName, IEnumerable`1<SyntaxNode> parameters, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> baseConstructorArguments, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode ConstructorDeclaration(IMethodSymbol constructorMethod, IEnumerable`1<SyntaxNode> baseConstructorArguments, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode AsPublicInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType);
    public abstract virtual SyntaxNode AsPublicInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType, string interfaceMemberName);
    public SyntaxNode AsPrivateInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType);
    public abstract virtual SyntaxNode AsPrivateInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType, string interfaceMemberName);
    public abstract virtual SyntaxNode ClassDeclaration(string name, IEnumerable`1<string> typeParameters, Accessibility accessibility, DeclarationModifiers modifiers, SyntaxNode baseType, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    public abstract virtual SyntaxNode StructDeclaration(string name, IEnumerable`1<string> typeParameters, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    public abstract virtual SyntaxNode InterfaceDeclaration(string name, IEnumerable`1<string> typeParameters, Accessibility accessibility, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    public abstract virtual SyntaxNode EnumDeclaration(string name, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> members);
    public abstract virtual SyntaxNode EnumMember(string name, SyntaxNode expression);
    public abstract virtual SyntaxNode DelegateDeclaration(string name, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<string> typeParameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers);
    public SyntaxNode Declaration(ISymbol symbol);
    private static bool CanBeDeclared(ISymbol symbol);
    private SyntaxNode WithTypeParametersAndConstraints(SyntaxNode declaration, ImmutableArray`1<ITypeParameterSymbol> typeParameters);
    internal abstract virtual SyntaxNode WithExplicitInterfaceImplementations(SyntaxNode declaration, ImmutableArray`1<IMethodSymbol> explicitInterfaceImplementations);
    public abstract virtual SyntaxNode WithTypeParameters(SyntaxNode declaration, IEnumerable`1<string> typeParameters);
    public SyntaxNode WithTypeParameters(SyntaxNode declaration, String[] typeParameters);
    public abstract virtual SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, IEnumerable`1<SyntaxNode> types);
    public SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, SyntaxNode[] types);
    public SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SyntaxNode[] types);
    public abstract virtual SyntaxNode NamespaceDeclaration(SyntaxNode name, IEnumerable`1<SyntaxNode> declarations);
    public SyntaxNode NamespaceDeclaration(SyntaxNode name, SyntaxNode[] declarations);
    public SyntaxNode NamespaceDeclaration(string name, IEnumerable`1<SyntaxNode> declarations);
    public SyntaxNode NamespaceDeclaration(string name, SyntaxNode[] declarations);
    public abstract virtual SyntaxNode CompilationUnit(IEnumerable`1<SyntaxNode> declarations);
    public SyntaxNode CompilationUnit(SyntaxNode[] declarations);
    public abstract virtual SyntaxNode NamespaceImportDeclaration(SyntaxNode name);
    public SyntaxNode NamespaceImportDeclaration(string name);
    public SyntaxNode AliasImportDeclaration(string aliasIdentifierName, INamespaceOrTypeSymbol symbol);
    public abstract virtual SyntaxNode AliasImportDeclaration(string aliasIdentifierName, SyntaxNode name);
    public abstract virtual SyntaxNode Attribute(SyntaxNode name, IEnumerable`1<SyntaxNode> attributeArguments);
    public SyntaxNode Attribute(string name, IEnumerable`1<SyntaxNode> attributeArguments);
    public SyntaxNode Attribute(string name, SyntaxNode[] attributeArguments);
    public SyntaxNode Attribute(AttributeData attribute);
    private IEnumerable`1<SyntaxNode> GetSymbolAttributes(ISymbol symbol);
    public abstract virtual SyntaxNode AttributeArgument(string name, SyntaxNode expression);
    public SyntaxNode AttributeArgument(SyntaxNode expression);
    public SyntaxNode RemoveAllAttributes(SyntaxNode declaration);
    internal SyntaxNode RemoveAllComments(SyntaxNode declaration);
    internal abstract virtual bool IsRegularOrDocComment(SyntaxTrivia trivia);
    internal SyntaxNode RemoveAllTypeInheritance(SyntaxNode declaration);
    internal abstract virtual ImmutableArray`1<SyntaxNode> GetTypeInheritance(SyntaxNode declaration);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetAttributes(SyntaxNode declaration);
    public abstract virtual SyntaxNode InsertAttributes(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributes);
    public SyntaxNode InsertAttributes(SyntaxNode declaration, int index, SyntaxNode[] attributes);
    public SyntaxNode AddAttributes(SyntaxNode declaration, IEnumerable`1<SyntaxNode> attributes);
    public SyntaxNode AddAttributes(SyntaxNode declaration, SyntaxNode[] attributes);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetReturnAttributes(SyntaxNode declaration);
    public abstract virtual SyntaxNode InsertReturnAttributes(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributes);
    public SyntaxNode InsertReturnAttributes(SyntaxNode declaration, int index, SyntaxNode[] attributes);
    public SyntaxNode AddReturnAttributes(SyntaxNode declaration, IEnumerable`1<SyntaxNode> attributes);
    public SyntaxNode AddReturnAttributes(SyntaxNode declaration, SyntaxNode[] attributes);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetAttributeArguments(SyntaxNode attributeDeclaration);
    public abstract virtual SyntaxNode InsertAttributeArguments(SyntaxNode attributeDeclaration, int index, IEnumerable`1<SyntaxNode> attributeArguments);
    public SyntaxNode AddAttributeArguments(SyntaxNode attributeDeclaration, IEnumerable`1<SyntaxNode> attributeArguments);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetNamespaceImports(SyntaxNode declaration);
    public abstract virtual SyntaxNode InsertNamespaceImports(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> imports);
    public SyntaxNode InsertNamespaceImports(SyntaxNode declaration, int index, SyntaxNode[] imports);
    public SyntaxNode AddNamespaceImports(SyntaxNode declaration, IEnumerable`1<SyntaxNode> imports);
    public SyntaxNode AddNamespaceImports(SyntaxNode declaration, SyntaxNode[] imports);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetMembers(SyntaxNode declaration);
    public abstract virtual SyntaxNode InsertMembers(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> members);
    public SyntaxNode InsertMembers(SyntaxNode declaration, int index, SyntaxNode[] members);
    public SyntaxNode AddMembers(SyntaxNode declaration, IEnumerable`1<SyntaxNode> members);
    public SyntaxNode AddMembers(SyntaxNode declaration, SyntaxNode[] members);
    public abstract virtual Accessibility GetAccessibility(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithAccessibility(SyntaxNode declaration, Accessibility accessibility);
    internal abstract virtual bool CanHaveAccessibility(SyntaxNode declaration);
    public abstract virtual DeclarationModifiers GetModifiers(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithModifiers(SyntaxNode declaration, DeclarationModifiers modifiers);
    public abstract virtual DeclarationKind GetDeclarationKind(SyntaxNode declaration);
    public abstract virtual string GetName(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithName(SyntaxNode declaration, string name);
    public abstract virtual SyntaxNode GetType(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithType(SyntaxNode declaration, SyntaxNode type);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetParameters(SyntaxNode declaration);
    public abstract virtual SyntaxNode InsertParameters(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> parameters);
    public SyntaxNode AddParameters(SyntaxNode declaration, IEnumerable`1<SyntaxNode> parameters);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetSwitchSections(SyntaxNode switchStatement);
    public abstract virtual SyntaxNode InsertSwitchSections(SyntaxNode switchStatement, int index, IEnumerable`1<SyntaxNode> switchSections);
    public SyntaxNode AddSwitchSections(SyntaxNode switchStatement, IEnumerable`1<SyntaxNode> switchSections);
    public abstract virtual SyntaxNode GetExpression(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithExpression(SyntaxNode declaration, SyntaxNode expression);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetStatements(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetAccessors(SyntaxNode declaration);
    public SyntaxNode GetAccessor(SyntaxNode declaration, DeclarationKind kind);
    public abstract virtual SyntaxNode InsertAccessors(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> accessors);
    public SyntaxNode AddAccessors(SyntaxNode declaration, IEnumerable`1<SyntaxNode> accessors);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetGetAccessorStatements(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithGetAccessorStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetSetAccessorStatements(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithSetAccessorStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetBaseAndInterfaceTypes(SyntaxNode declaration);
    public abstract virtual SyntaxNode AddBaseType(SyntaxNode declaration, SyntaxNode baseType);
    public abstract virtual SyntaxNode AddInterfaceType(SyntaxNode declaration, SyntaxNode interfaceType);
    internal abstract virtual SyntaxNode AsInterfaceMember(SyntaxNode member);
    public virtual SyntaxNode ReplaceNode(SyntaxNode root, SyntaxNode node, SyntaxNode newDeclaration);
    public virtual SyntaxNode InsertNodesBefore(SyntaxNode root, SyntaxNode node, IEnumerable`1<SyntaxNode> newDeclarations);
    public virtual SyntaxNode InsertNodesAfter(SyntaxNode root, SyntaxNode node, IEnumerable`1<SyntaxNode> newDeclarations);
    public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode node);
    public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode node, SyntaxRemoveOptions options);
    public SyntaxNode RemoveNodes(SyntaxNode root, IEnumerable`1<SyntaxNode> declarations);
    internal static SyntaxTokenList Merge(SyntaxTokenList original, SyntaxTokenList newList);
    private static bool Any(SyntaxTokenList original, int rawKind);
    protected static SyntaxNode PreserveTrivia(TNode node, Func`2<TNode, SyntaxNode> nodeChanger);
    protected static SyntaxNode ReplaceWithTrivia(SyntaxNode root, SyntaxNode original, SyntaxNode replacement);
    protected static SyntaxNode ReplaceWithTrivia(SyntaxNode root, TNode original, Func`2<TNode, SyntaxNode> replacer);
    protected static SyntaxNode ReplaceWithTrivia(SyntaxNode root, SyntaxToken original, SyntaxToken replacement);
    public abstract virtual TNode ClearTrivia(TNode node);
    protected int IndexOf(IReadOnlyList`1<T> list, T element);
    protected static SyntaxNode ReplaceRange(SyntaxNode root, SyntaxNode node, IEnumerable`1<SyntaxNode> replacements);
    protected static SeparatedSyntaxList`1<TNode> RemoveRange(SeparatedSyntaxList`1<TNode> list, int offset, int count);
    protected static SyntaxList`1<TNode> RemoveRange(SyntaxList`1<TNode> list, int offset, int count);
    public abstract virtual SyntaxNode ExpressionStatement(SyntaxNode expression);
    public abstract virtual SyntaxNode ReturnStatement(SyntaxNode expression);
    internal abstract virtual SyntaxNode YieldReturnStatement(SyntaxNode expression);
    public abstract virtual SyntaxNode ThrowStatement(SyntaxNode expression);
    public abstract virtual SyntaxNode ThrowExpression(SyntaxNode expression);
    public abstract virtual SyntaxNode LocalDeclarationStatement(SyntaxNode type, string identifier, SyntaxNode initializer, bool isConst);
    internal abstract virtual SyntaxNode LocalDeclarationStatement(SyntaxNode type, SyntaxToken identifier, SyntaxNode initializer, bool isConst);
    internal abstract virtual SyntaxNode WithInitializer(SyntaxNode variableDeclarator, SyntaxNode initializer);
    internal abstract virtual SyntaxNode EqualsValueClause(SyntaxToken operatorToken, SyntaxNode value);
    public SyntaxNode LocalDeclarationStatement(ITypeSymbol type, string name, SyntaxNode initializer, bool isConst);
    public SyntaxNode LocalDeclarationStatement(string name, SyntaxNode initializer);
    internal SyntaxNode LocalDeclarationStatement(SyntaxToken name, SyntaxNode initializer);
    public abstract virtual SyntaxNode IfStatement(SyntaxNode condition, IEnumerable`1<SyntaxNode> trueStatements, IEnumerable`1<SyntaxNode> falseStatements);
    public SyntaxNode IfStatement(SyntaxNode condition, IEnumerable`1<SyntaxNode> trueStatements, SyntaxNode falseStatement);
    public abstract virtual SyntaxNode SwitchStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> sections);
    public SyntaxNode SwitchStatement(SyntaxNode expression, SyntaxNode[] sections);
    public abstract virtual SyntaxNode SwitchSection(IEnumerable`1<SyntaxNode> caseExpressions, IEnumerable`1<SyntaxNode> statements);
    internal abstract virtual SyntaxNode SwitchSectionFromLabels(IEnumerable`1<SyntaxNode> labels, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode SwitchSection(SyntaxNode caseExpression, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode DefaultSwitchSection(IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode ExitSwitchStatement();
    public abstract virtual SyntaxNode UsingStatement(SyntaxNode type, string name, SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode UsingStatement(string name, SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode UsingStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode LockStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode TryCatchStatement(IEnumerable`1<SyntaxNode> tryStatements, IEnumerable`1<SyntaxNode> catchClauses, IEnumerable`1<SyntaxNode> finallyStatements);
    public SyntaxNode TryCatchStatement(IEnumerable`1<SyntaxNode> tryStatements, SyntaxNode[] catchClauses);
    public SyntaxNode TryFinallyStatement(IEnumerable`1<SyntaxNode> tryStatements, IEnumerable`1<SyntaxNode> finallyStatements);
    public abstract virtual SyntaxNode CatchClause(SyntaxNode type, string identifier, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode CatchClause(ITypeSymbol type, string identifier, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode WhileStatement(SyntaxNode condition, IEnumerable`1<SyntaxNode> statements);
    internal abstract virtual SyntaxToken NumericLiteralToken(string text, ulong value);
    internal abstract virtual SyntaxToken InterpolatedStringTextToken(string content);
    internal abstract virtual SyntaxNode InterpolatedStringText(SyntaxToken textToken);
    internal abstract virtual SyntaxNode Interpolation(SyntaxNode syntaxNode);
    internal abstract virtual SyntaxNode InterpolatedStringExpression(SyntaxToken startToken, IEnumerable`1<SyntaxNode> content, SyntaxToken endToken);
    public abstract virtual SyntaxNode DefaultExpression(SyntaxNode type);
    public abstract virtual SyntaxNode DefaultExpression(ITypeSymbol type);
    public abstract virtual SyntaxNode ThisExpression();
    public abstract virtual SyntaxNode BaseExpression();
    public abstract virtual SyntaxNode LiteralExpression(object value);
    public abstract virtual SyntaxNode TypedConstantExpression(TypedConstant value);
    public SyntaxNode FalseLiteralExpression();
    public SyntaxNode TrueLiteralExpression();
    public SyntaxNode NullLiteralExpression();
    public abstract virtual SyntaxNode IdentifierName(string identifier);
    internal abstract virtual SyntaxNode IdentifierName(SyntaxToken identifier);
    internal abstract virtual SyntaxToken Identifier(string identifier);
    internal abstract virtual SyntaxNode NamedAnonymousObjectMemberDeclarator(SyntaxNode identifier, SyntaxNode expression);
    public abstract virtual SyntaxNode GenericName(string identifier, IEnumerable`1<SyntaxNode> typeArguments);
    public SyntaxNode GenericName(string identifier, IEnumerable`1<ITypeSymbol> typeArguments);
    public SyntaxNode GenericName(string identifier, SyntaxNode[] typeArguments);
    public SyntaxNode GenericName(string identifier, ITypeSymbol[] typeArguments);
    public abstract virtual SyntaxNode WithTypeArguments(SyntaxNode expression, IEnumerable`1<SyntaxNode> typeArguments);
    public SyntaxNode WithTypeArguments(SyntaxNode expression, SyntaxNode[] typeArguments);
    public abstract virtual SyntaxNode QualifiedName(SyntaxNode left, SyntaxNode right);
    public SyntaxNode DottedName(string dottedName);
    public abstract virtual SyntaxNode NameExpression(INamespaceOrTypeSymbol namespaceOrTypeSymbol);
    public abstract virtual SyntaxNode TypeExpression(ITypeSymbol typeSymbol);
    public SyntaxNode TypeExpression(ITypeSymbol typeSymbol, bool addImport);
    public abstract virtual SyntaxNode TypeExpression(SpecialType specialType);
    public abstract virtual SyntaxNode ArrayTypeExpression(SyntaxNode type);
    public abstract virtual SyntaxNode NullableTypeExpression(SyntaxNode type);
    public SyntaxNode TupleTypeExpression(IEnumerable`1<SyntaxNode> elements);
    internal abstract virtual SyntaxNode CreateTupleType(IEnumerable`1<SyntaxNode> elements);
    public SyntaxNode TupleTypeExpression(SyntaxNode[] elements);
    public SyntaxNode TupleTypeExpression(IEnumerable`1<ITypeSymbol> elementTypes, IEnumerable`1<string> elementNames);
    public abstract virtual SyntaxNode TupleElementExpression(SyntaxNode type, string name);
    public SyntaxNode TupleElementExpression(ITypeSymbol type, string name);
    public abstract virtual SyntaxNode AssignmentStatement(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ValueEqualsExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ReferenceEqualsExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ValueNotEqualsExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ReferenceNotEqualsExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode LessThanExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode LessThanOrEqualExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode GreaterThanExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode GreaterThanOrEqualExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode NegateExpression(SyntaxNode expression);
    public abstract virtual SyntaxNode AddExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode SubtractExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode MultiplyExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode DivideExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ModuloExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode BitwiseAndExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode BitwiseOrExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode BitwiseNotExpression(SyntaxNode operand);
    public abstract virtual SyntaxNode LogicalAndExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode LogicalOrExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode LogicalNotExpression(SyntaxNode expression);
    public abstract virtual SyntaxNode ConditionalExpression(SyntaxNode condition, SyntaxNode whenTrue, SyntaxNode whenFalse);
    internal abstract virtual SyntaxNode ConditionalAccessExpression(SyntaxNode expression, SyntaxNode whenNotNull);
    internal abstract virtual SyntaxNode MemberBindingExpression(SyntaxNode name);
    internal abstract virtual SyntaxNode ElementBindingExpression(SyntaxNode argumentList);
    public abstract virtual SyntaxNode CoalesceExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode MemberAccessExpression(SyntaxNode expression, SyntaxNode memberName);
    internal abstract virtual SyntaxNode MemberAccessExpressionWorker(SyntaxNode expression, SyntaxNode memberName);
    internal abstract virtual SyntaxNode RefExpression(SyntaxNode expression);
    public SyntaxNode MemberAccessExpression(SyntaxNode expression, string memberName);
    public abstract virtual SyntaxNode ArrayCreationExpression(SyntaxNode elementType, SyntaxNode size);
    public abstract virtual SyntaxNode ArrayCreationExpression(SyntaxNode elementType, IEnumerable`1<SyntaxNode> elements);
    public abstract virtual SyntaxNode ObjectCreationExpression(SyntaxNode namedType, IEnumerable`1<SyntaxNode> arguments);
    public SyntaxNode ObjectCreationExpression(ITypeSymbol type, IEnumerable`1<SyntaxNode> arguments);
    public SyntaxNode ObjectCreationExpression(SyntaxNode type, SyntaxNode[] arguments);
    public SyntaxNode ObjectCreationExpression(ITypeSymbol type, SyntaxNode[] arguments);
    public abstract virtual SyntaxNode InvocationExpression(SyntaxNode expression, IEnumerable`1<SyntaxNode> arguments);
    public SyntaxNode InvocationExpression(SyntaxNode expression, SyntaxNode[] arguments);
    public abstract virtual SyntaxNode Argument(string name, RefKind refKind, SyntaxNode expression);
    public SyntaxNode Argument(RefKind refKind, SyntaxNode expression);
    public SyntaxNode Argument(SyntaxNode expression);
    public abstract virtual SyntaxNode ElementAccessExpression(SyntaxNode expression, IEnumerable`1<SyntaxNode> arguments);
    public SyntaxNode ElementAccessExpression(SyntaxNode expression, SyntaxNode[] arguments);
    public abstract virtual SyntaxNode TypeOfExpression(SyntaxNode type);
    public abstract virtual SyntaxNode IsTypeExpression(SyntaxNode expression, SyntaxNode type);
    public SyntaxNode IsTypeExpression(SyntaxNode expression, ITypeSymbol type);
    public abstract virtual SyntaxNode TryCastExpression(SyntaxNode expression, SyntaxNode type);
    public SyntaxNode TryCastExpression(SyntaxNode expression, ITypeSymbol type);
    public abstract virtual SyntaxNode CastExpression(SyntaxNode type, SyntaxNode expression);
    public SyntaxNode CastExpression(ITypeSymbol type, SyntaxNode expression);
    public abstract virtual SyntaxNode ConvertExpression(SyntaxNode type, SyntaxNode expression);
    public SyntaxNode ConvertExpression(ITypeSymbol type, SyntaxNode expression);
    public abstract virtual SyntaxNode ValueReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, SyntaxNode expression);
    public abstract virtual SyntaxNode VoidReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, SyntaxNode expression);
    public abstract virtual SyntaxNode ValueReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode VoidReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode ValueReturningLambdaExpression(string parameterName, SyntaxNode expression);
    public SyntaxNode VoidReturningLambdaExpression(string parameterName, SyntaxNode expression);
    public SyntaxNode ValueReturningLambdaExpression(string parameterName, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode VoidReturningLambdaExpression(string parameterName, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode ValueReturningLambdaExpression(SyntaxNode expression);
    public SyntaxNode VoidReturningLambdaExpression(SyntaxNode expression);
    public SyntaxNode ValueReturningLambdaExpression(IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode VoidReturningLambdaExpression(IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode LambdaParameter(string identifier, SyntaxNode type);
    public SyntaxNode LambdaParameter(string identifier, ITypeSymbol type);
    public abstract virtual SyntaxNode AwaitExpression(SyntaxNode expression);
    public abstract virtual SyntaxNode NameOfExpression(SyntaxNode expression);
    public abstract virtual SyntaxNode TupleExpression(IEnumerable`1<SyntaxNode> arguments);
    [CompilerGeneratedAttribute]
private SyntaxNode <MethodDeclaration>b__18_0(IParameterSymbol p);
    [CompilerGeneratedAttribute]
private SyntaxNode <OperatorDeclaration>b__20_0(IParameterSymbol p);
    [CompilerGeneratedAttribute]
private SyntaxNode <IndexerDeclaration>b__31_0(IParameterSymbol p);
    [CompilerGeneratedAttribute]
private SyntaxNode <CustomEventDeclaration>b__37_1(IParameterSymbol p);
    [CompilerGeneratedAttribute]
private SyntaxNode <ConstructorDeclaration>b__39_0(IParameterSymbol p);
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__50_0(INamedTypeSymbol i);
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__50_1(ISymbol m);
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__50_2(INamedTypeSymbol i);
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__50_3(ISymbol m);
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__50_4(INamedTypeSymbol i);
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__50_5(ISymbol m);
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__50_6(ISymbol m);
    [CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__50_7(IParameterSymbol p);
    [CompilerGeneratedAttribute]
private SyntaxNode <WithTypeParametersAndConstraints>b__52_1(ITypeSymbol t);
    [CompilerGeneratedAttribute]
private SyntaxNode <Attribute>b__72_0(TypedConstant a);
    [CompilerGeneratedAttribute]
private SyntaxNode <Attribute>b__72_1(KeyValuePair`2<string, TypedConstant> n);
    [CompilerGeneratedAttribute]
private SyntaxNode <GetSymbolAttributes>b__73_0(AttributeData a);
    [CompilerGeneratedAttribute]
private bool <RemoveAllComments>b__77_0(SyntaxTrivia t);
    [CompilerGeneratedAttribute]
private bool <RemoveAllComments>b__77_1(SyntaxTrivia t);
    [CompilerGeneratedAttribute]
private SyntaxNode <GenericName>b__203_0(ITypeSymbol ta);
    [CompilerGeneratedAttribute]
private SyntaxNode <TupleTypeExpression>b__220_0(ITypeSymbol type, string name);
    [CompilerGeneratedAttribute]
private SyntaxNode <TupleTypeExpression>b__220_1(ITypeSymbol type);
}
internal static class Microsoft.CodeAnalysis.EditorConfigSeverityStrings : object {
    public static string None;
    public static string Refactoring;
    public static string Silent;
    public static string Suggestion;
    public static string Warning;
    public static string Error;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal interface Microsoft.CodeAnalysis.ErrorLogger.IErrorLoggerService {
    public abstract virtual void LogException(object source, Exception exception);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.ErrorLogger.IErrorLoggerService", "Default")]
[ExportAttribute("Microsoft.CodeAnalysis.ErrorLogger.IErrorLoggerService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ErrorLogger.WorkspaceErrorLogger : object {
    public sealed virtual void LogException(object source, Exception exception);
    private static string ToLogFormat(Exception exception);
}
internal static class Microsoft.CodeAnalysis.ErrorReporting.FatalError : object {
    private static Action`1<Exception> s_fatalHandler;
    private static Action`1<Exception> s_nonFatalHandler;
    private static Exception s_reportedException;
    private static string s_reportedExceptionMessage;
    private static object s_reportedMarker;
    public static Action`1<Exception> Handler { get; public set; }
    public static Action`1<Exception> NonFatalHandler { get; public set; }
    private static FatalError();
    public static Action`1<Exception> get_Handler();
    public static void set_Handler(Action`1<Exception> value);
    public static Action`1<Exception> get_NonFatalHandler();
    public static void set_NonFatalHandler(Action`1<Exception> value);
    public static void OverwriteHandler(Action`1<Exception> value);
    [DebuggerHiddenAttribute]
public static bool ReportUnlessCanceled(Exception exception);
    [DebuggerHiddenAttribute]
public static bool ReportWithoutCrashUnlessCanceled(Exception exception);
    [DebuggerHiddenAttribute]
public static bool ReportUnlessNotImplemented(Exception exception);
    [DebuggerHiddenAttribute]
public static bool Report(Exception exception);
    [DebuggerHiddenAttribute]
public static bool ReportWithoutCrash(Exception exception);
    [DebuggerHiddenAttribute]
public static bool ReportWithoutCrashAndPropagate(Exception exception);
    [DebuggerHiddenAttribute]
public static bool ReportWithoutCrashUnlessCanceledAndPropagate(Exception exception);
    private static void Report(Exception exception, Action`1<Exception> handler);
}
internal abstract class Microsoft.CodeAnalysis.Execution.AbstractOptionsSerializationService : object {
    public abstract virtual void WriteTo(CompilationOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(ParseOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(OptionSet options, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual CompilationOptions ReadCompilationOptionsFrom(ObjectReader reader, CancellationToken cancellationToken);
    public abstract virtual ParseOptions ReadParseOptionsFrom(ObjectReader reader, CancellationToken cancellationToken);
    public abstract virtual OptionSet ReadOptionSetFrom(ObjectReader reader, CancellationToken cancellationToken);
    protected void WriteCompilationOptionsTo(CompilationOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    protected void ReadCompilationOptionsFrom(ObjectReader reader, OutputKind& outputKind, Boolean& reportSuppressedDiagnostics, String& moduleName, String& mainTypeName, String& scriptClassName, OptimizationLevel& optimizationLevel, Boolean& checkOverflow, String& cryptoKeyContainer, String& cryptoKeyFile, ImmutableArray`1& cryptoPublicKey, Nullable`1& delaySign, Platform& platform, ReportDiagnostic& generalDiagnosticOption, Int32& warningLevel, IEnumerable`1& specificDiagnosticOptions, Boolean& concurrentBuild, Boolean& deterministic, Boolean& publicSign, XmlReferenceResolver& xmlReferenceResolver, SourceReferenceResolver& sourceReferenceResolver, MetadataReferenceResolver& metadataReferenceResolver, AssemblyIdentityComparer& assemblyIdentityComparer, StrongNameProvider& strongNameProvider, CancellationToken cancellationToken);
    protected void WriteParseOptionsTo(ParseOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    protected void ReadParseOptionsFrom(ObjectReader reader, SourceCodeKind& kind, DocumentationMode& documentationMode, IEnumerable`1& features, CancellationToken cancellationToken);
    protected void WriteOptionSetTo(OptionSet options, string language, ObjectWriter writer, CancellationToken cancellationToken);
    protected OptionSet ReadOptionSetFrom(OptionSet options, string language, ObjectReader reader, CancellationToken cancellationToken);
    protected void WriteOptionTo(OptionSet options, Option`1<CodeStyleOption`1<T>> option, ObjectWriter writer, CancellationToken cancellationToken);
    protected OptionSet ReadOptionFrom(OptionSet options, Option`1<CodeStyleOption`1<T>> option, ObjectReader reader, CancellationToken cancellationToken);
    private void WriteOptionTo(OptionSet options, string language, PerLanguageOption`1<CodeStyleOption`1<T>> option, ObjectWriter writer, CancellationToken cancellationToken);
    private OptionSet ReadOptionFrom(OptionSet options, string language, PerLanguageOption`1<CodeStyleOption`1<T>> option, ObjectReader reader, CancellationToken cancellationToken);
    protected void WriteOptionTo(OptionSet options, Option`1<NamingStylePreferences> option, ObjectWriter writer, CancellationToken cancellationToken);
    protected OptionSet ReadOptionFrom(OptionSet options, Option`1<NamingStylePreferences> option, ObjectReader reader, CancellationToken cancellationToken);
    private void WriteOptionTo(OptionSet options, string language, PerLanguageOption`1<NamingStylePreferences> option, ObjectWriter writer, CancellationToken cancellationToken);
    private OptionSet ReadOptionFrom(OptionSet options, string language, PerLanguageOption`1<NamingStylePreferences> option, ObjectReader reader, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Execution.AbstractReferenceSerializationService : object {
    private static int MetadataFailed;
    private static string VisualStudioUnresolvedAnalyzerReference;
    protected static byte NoEncodingSerialization;
    protected static byte EncodingSerialization;
    private static ConditionalWeakTable`2<Metadata, object> s_lifetimeMap;
    private ITemporaryStorageService _storageService;
    private IDocumentationProviderService _documentationService;
    protected AbstractReferenceSerializationService(ITemporaryStorageService storageService, IDocumentationProviderService documentationService);
    private static AbstractReferenceSerializationService();
    public virtual void WriteTo(Encoding encoding, ObjectWriter writer, CancellationToken cancellationToken);
    public virtual Encoding ReadEncodingFrom(ObjectReader reader, CancellationToken cancellationToken);
    protected Encoding ReadEncodingFrom(byte serialized, ObjectReader reader, CancellationToken cancellationToken);
    protected abstract virtual string GetAnalyzerAssemblyPath(AnalyzerFileReference reference);
    protected abstract virtual AnalyzerReference GetAnalyzerReference(string displayPath, string assemblyPath);
    public sealed virtual Checksum CreateChecksum(MetadataReference reference, CancellationToken cancellationToken);
    public sealed virtual Checksum CreateChecksum(AnalyzerReference reference, CancellationToken cancellationToken);
    public sealed virtual void WriteTo(MetadataReference reference, ObjectWriter writer, CancellationToken cancellationToken);
    public sealed virtual MetadataReference ReadMetadataReferenceFrom(ObjectReader reader, CancellationToken cancellationToken);
    public sealed virtual void WriteTo(AnalyzerReference reference, ObjectWriter writer, bool usePathFromAssembly, CancellationToken cancellationToken);
    public sealed virtual AnalyzerReference ReadAnalyzerReferenceFrom(ObjectReader reader, CancellationToken cancellationToken);
    private void WriteAnalyzerFileReferenceMvid(AnalyzerFileReference reference, ObjectWriter writer, CancellationToken cancellationToken);
    protected void WritePortableExecutableReferenceHeaderTo(PortableExecutableReference reference, SerializationKinds kind, ObjectWriter writer, CancellationToken cancellationToken);
    private void WritePortableExecutableReferencePropertiesTo(PortableExecutableReference reference, ObjectWriter writer, CancellationToken cancellationToken);
    private Checksum CreatePortableExecutableReferenceChecksum(PortableExecutableReference reference, CancellationToken cancellationToken);
    private void WriteMvidsTo(Metadata metadata, ObjectWriter writer, CancellationToken cancellationToken);
    private void WriteMvidTo(ModuleMetadata metadata, ObjectWriter writer, CancellationToken cancellationToken);
    private void WritePortableExecutableReferenceTo(PortableExecutableReference reference, ObjectWriter writer, CancellationToken cancellationToken);
    private PortableExecutableReference ReadPortableExecutableReferenceFrom(ObjectReader reader, CancellationToken cancellationToken);
    private void WriteTo(MetadataReferenceProperties properties, ObjectWriter writer, CancellationToken cancellationToken);
    private MetadataReferenceProperties ReadMetadataReferencePropertiesFrom(ObjectReader reader, CancellationToken cancellationToken);
    private void WriteTo(Metadata metadata, ObjectWriter writer, CancellationToken cancellationToken);
    private bool TryWritePortableExecutableReferenceBackedByTemporaryStorageTo(ISupportTemporaryStorage reference, ObjectWriter writer, CancellationToken cancellationToken);
    private Nullable`1<ValueTuple`2<Metadata, ImmutableArray`1<ITemporaryStreamStorage>>> TryReadMetadataFrom(ObjectReader reader, SerializationKinds kind, CancellationToken cancellationToken);
    private ValueTuple`2<ModuleMetadata, ITemporaryStreamStorage> ReadModuleMetadataFrom(ObjectReader reader, SerializationKinds kind, CancellationToken cancellationToken);
    private void GetTemporaryStorage(ObjectReader reader, SerializationKinds kind, ITemporaryStreamStorage& storage, Int64& length, CancellationToken cancellationToken);
    private void GetMetadata(Stream stream, long length, ModuleMetadata& metadata, Object& lifeTimeObject);
    private void CopyByteArrayToStream(ObjectReader reader, Stream stream, CancellationToken cancellationToken);
    private void WriteTo(ModuleMetadata metadata, ObjectWriter writer, CancellationToken cancellationToken);
    private void WriteTo(MetadataReader reader, ObjectWriter writer, CancellationToken cancellationToken);
    private static void WriteUnresolvedAnalyzerReferenceTo(AnalyzerReference reference, ObjectWriter writer);
    private static Metadata TryGetMetadata(PortableExecutableReference reference);
    private string TryGetAnalyzerAssemblyPath(AnalyzerFileReference file);
}
internal class Microsoft.CodeAnalysis.Execution.AssetStorages : object {
    private ConcurrentDictionary`2<object, CustomAsset> _globalAssets;
    private ConcurrentDictionary`2<int, Storage> _storages;
    public void AddGlobalAsset(object value, CustomAsset asset, CancellationToken cancellationToken);
    public CustomAsset GetGlobalAsset(object value, CancellationToken cancellationToken);
    public void RemoveGlobalAsset(object value, CancellationToken cancellationToken);
    public Storage CreateStorage(SolutionState solutionState);
    public RemotableData GetRemotableData(int scopeId, Checksum checksum, CancellationToken cancellationToken);
    public IReadOnlyDictionary`2<Checksum, RemotableData> GetRemotableData(int scopeId, IEnumerable`1<Checksum> checksums, CancellationToken cancellationToken);
    public void RegisterSnapshot(PinnedRemotableDataScope scope, Storage storage);
    public void UnregisterSnapshot(PinnedRemotableDataScope scope);
    public RemotableData GetRemotableData_TestOnly(Checksum checksum, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Execution.Creator : object {
    public static PooledObject`1<HashSet`1<Checksum>> CreateChecksumSet(IEnumerable`1<Checksum> checksums);
    public static PooledObject`1<List`1<T>> CreateList();
    public static PooledObject`1<Dictionary`2<Checksum, object>> CreateResultSet();
}
internal abstract class Microsoft.CodeAnalysis.Execution.CustomAsset : RemotableData {
    public CustomAsset(Checksum checksum, WellKnownSynchronizationKind kind);
}
internal class Microsoft.CodeAnalysis.Execution.CustomAssetBuilder : object {
    private ISerializerService _serializer;
    public CustomAssetBuilder(Solution solution);
    public CustomAssetBuilder(Workspace workspace);
    public CustomAssetBuilder(HostWorkspaceServices services);
    public CustomAsset Build(OptionSet options, string language, CancellationToken cancellationToken);
    public CustomAsset Build(AnalyzerReference reference, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Execution.Extensions : object {
    [ExtensionAttribute]
public static T[] ReadArray(ObjectReader reader);
    [ExtensionAttribute]
public static WellKnownSynchronizationKind GetWellKnownSynchronizationKind(object value);
}
internal interface Microsoft.CodeAnalysis.Execution.IOptionsSerializationService {
    public abstract virtual void WriteTo(CompilationOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(ParseOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(OptionSet options, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual CompilationOptions ReadCompilationOptionsFrom(ObjectReader reader, CancellationToken cancellationToken);
    public abstract virtual ParseOptions ReadParseOptionsFrom(ObjectReader reader, CancellationToken cancellationToken);
    public abstract virtual OptionSet ReadOptionSetFrom(ObjectReader reader, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Execution.IReferenceSerializationService {
    public abstract virtual Checksum CreateChecksum(MetadataReference reference, CancellationToken cancellationToken);
    public abstract virtual Checksum CreateChecksum(AnalyzerReference reference, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(Encoding encoding, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(MetadataReference reference, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(AnalyzerReference reference, ObjectWriter writer, bool usePathFromAssembly, CancellationToken cancellationToken);
    public abstract virtual Encoding ReadEncodingFrom(ObjectReader reader, CancellationToken cancellationToken);
    public abstract virtual MetadataReference ReadMetadataReferenceFrom(ObjectReader reader, CancellationToken cancellationToken);
    public abstract virtual AnalyzerReference ReadAnalyzerReferenceFrom(ObjectReader reader, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Execution.IRemotableDataService {
    public abstract virtual void AddGlobalAsset(object value, CustomAsset asset, CancellationToken cancellationToken);
    public abstract virtual CustomAsset GetGlobalAsset(object value, CancellationToken cancellationToken);
    public abstract virtual void RemoveGlobalAsset(object value, CancellationToken cancellationToken);
    public abstract virtual Task`1<PinnedRemotableDataScope> CreatePinnedRemotableDataScopeAsync(Solution solution, CancellationToken cancellationToken);
    public abstract virtual RemotableData GetRemotableData(int scopeId, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual IReadOnlyDictionary`2<Checksum, RemotableData> GetRemotableData(int scopeId, IEnumerable`1<Checksum> checksums, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Execution.ISupportTemporaryStorage {
    public abstract virtual IEnumerable`1<ITemporaryStreamStorage> GetStorages();
}
internal class Microsoft.CodeAnalysis.Execution.PinnedRemotableDataScope : object {
    private static int s_scopeId;
    private AssetStorages _storages;
    private Storage _storage;
    private bool _disposed;
    public PinnedSolutionInfo SolutionInfo;
    public Workspace Workspace { get; }
    public Checksum SolutionChecksum { get; }
    public PinnedRemotableDataScope(AssetStorages storages, Storage storage, Checksum solutionChecksum);
    private static PinnedRemotableDataScope();
    public Workspace get_Workspace();
    public Checksum get_SolutionChecksum();
    public void AddAdditionalAsset(CustomAsset asset);
    public RemotableData GetRemotableData(Checksum checksum, CancellationToken cancellationToken);
    public IReadOnlyDictionary`2<Checksum, RemotableData> GetRemotableData(IEnumerable`1<Checksum> checksums, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
internal class Microsoft.CodeAnalysis.Execution.PinnedSolutionInfo : object {
    public int ScopeId;
    public bool FromPrimaryBranch;
    public Checksum SolutionChecksum;
    public PinnedSolutionInfo(int scopeId, bool fromPrimaryBranch, Checksum solutionChecksum);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Execution.IReferenceSerializationService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Execution.ReferenceSerializationServiceFactory : object {
    private static IAnalyzerAssemblyLoader s_loader;
    private static ReferenceSerializationServiceFactory();
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal abstract class Microsoft.CodeAnalysis.Execution.RemotableData : object {
    public static RemotableData Null;
    public WellKnownSynchronizationKind Kind;
    public Checksum Checksum;
    public RemotableData(Checksum checksum, WellKnownSynchronizationKind kind);
    private static RemotableData();
    public abstract virtual Task WriteObjectToAsync(ObjectWriter writer, CancellationToken cancellationToken);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Execution.IRemotableDataService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Execution.RemotableDataServiceFactory : object {
    private AssetStorages _assetStorages;
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Serialization.ISerializerService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Execution.SerializerServiceFactory : object {
    [ObsoleteAttribute("This factory method only provides services for the MEF export provider.", "True")]
public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal class Microsoft.CodeAnalysis.Execution.SimpleCustomAsset : CustomAsset {
    private Action`2<ObjectWriter, CancellationToken> _writer;
    public SimpleCustomAsset(WellKnownSynchronizationKind kind, Action`2<ObjectWriter, CancellationToken> writer);
    public virtual Task WriteObjectToAsync(ObjectWriter writer, CancellationToken cancellationToken);
    private static Checksum CreateChecksumFromStreamWriter(WellKnownSynchronizationKind kind, Action`2<ObjectWriter, CancellationToken> writer);
}
internal abstract class Microsoft.CodeAnalysis.Execution.SolutionAsset : RemotableData {
    protected SolutionAsset(Checksum checksum, WellKnownSynchronizationKind kind);
    public static RemotableData Create(Checksum checksum, object value, ISerializerService serializer);
}
internal class Microsoft.CodeAnalysis.Execution.WorkspaceAnalyzerReferenceAsset : CustomAsset {
    private AnalyzerReference _reference;
    private ISerializerService _serializer;
    public WorkspaceAnalyzerReferenceAsset(AnalyzerReference reference, ISerializerService serializer);
    public virtual Task WriteObjectToAsync(ObjectWriter writer, CancellationToken cancellationToken);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Experiments.IExperimentationService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Experiments.DefaultExperimentationService : object {
    public sealed virtual bool IsExperimentEnabled(string experimentName);
}
internal interface Microsoft.CodeAnalysis.Experiments.IExperimentationService {
    public abstract virtual bool IsExperimentEnabled(string experimentName);
}
internal static class Microsoft.CodeAnalysis.Experiments.WellKnownExperimentNames : object {
    public static string RoslynFeatureOOP;
    public static string RoslynOOP64bit;
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.ExtensionOrderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <After>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Before>k__BackingField;
    public string After { get; public set; }
    public string Before { get; public set; }
    [CompilerGeneratedAttribute]
public string get_After();
    [CompilerGeneratedAttribute]
public void set_After(string value);
    [CompilerGeneratedAttribute]
public string get_Before();
    [CompilerGeneratedAttribute]
public void set_Before(string value);
}
internal abstract class Microsoft.CodeAnalysis.Extensions.AbstractExtensionManager : object {
    private ConcurrentSet`1<object> _disabledProviders;
    private ConcurrentSet`1<object> _ignoredProviders;
    protected void DisableProvider(object provider);
    protected void EnableProvider(object provider);
    protected void IgnoreProvider(object provider);
    public bool IsIgnored(object provider);
    public sealed virtual bool IsDisabled(object provider);
    public virtual bool CanHandleException(object provider, Exception exception);
    public virtual void HandleException(object provider, Exception exception);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Extensions.CommonParenthesizedExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsSafeToChangeAssociativity(SyntaxNode parenthesizedExpression, SyntaxNode innerExpression, SyntaxNode parentBinaryLeft, SyntaxNode parentBinaryRight, SemanticModel semanticModel);
    private static bool AnySymbolIsUserDefinedOperator(SymbolInfo symbolInfo);
    private static bool IsUserDefinedOperator(ISymbol symbol);
    private static bool IsFloatingPoint(TypeInfo typeInfo);
    private static bool IsFloatingPoint(ITypeSymbol type);
}
internal interface Microsoft.CodeAnalysis.Extensions.IErrorReportingService {
    public abstract virtual void ShowErrorInfoInActiveView(string message, InfoBarUI[] items);
    public abstract virtual void ShowGlobalErrorInfo(string message, InfoBarUI[] items);
    public abstract virtual void ShowDetailedErrorInfo(Exception exception);
}
internal interface Microsoft.CodeAnalysis.Extensions.IExtensionManager {
    public abstract virtual bool IsDisabled(object provider);
    public abstract virtual bool CanHandleException(object provider, Exception exception);
    public abstract virtual void HandleException(object provider, Exception exception);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions : object {
    [ExtensionAttribute]
public static void PerformAction(IExtensionManager extensionManager, object extension, Action action);
    [ExtensionAttribute]
public static T PerformFunction(IExtensionManager extensionManager, object extension, Func`1<T> function, T defaultValue);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions/<PerformActionAsync>d__2")]
[ExtensionAttribute]
public static Task PerformActionAsync(IExtensionManager extensionManager, object extension, Func`1<Task> function);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions/<PerformFunctionAsync>d__3`1")]
[ExtensionAttribute]
public static Task`1<T> PerformFunctionAsync(IExtensionManager extensionManager, object extension, Func`1<Task`1<T>> function, T defaultValue);
    [ExtensionAttribute]
public static Func`2<SyntaxNode, ImmutableArray`1<TExtension>> CreateNodeExtensionGetter(IExtensionManager extensionManager, IEnumerable`1<TExtension> extensions, Func`2<TExtension, ImmutableArray`1<Type>> nodeTypeGetter);
    [ExtensionAttribute]
public static Func`2<SyntaxToken, ImmutableArray`1<TExtension>> CreateTokenExtensionGetter(IExtensionManager extensionManager, IEnumerable`1<TExtension> extensions, Func`2<TExtension, ImmutableArray`1<int>> tokenKindGetter);
}
internal interface Microsoft.CodeAnalysis.Extensions.IInfoBarService {
    public abstract virtual void ShowInfoBarInActiveView(string message, InfoBarUI[] items);
    public abstract virtual void ShowInfoBarInGlobalView(string message, InfoBarUI[] items);
}
internal class Microsoft.CodeAnalysis.Extensions.InfoBarUI : ValueType {
    public string Title;
    public UIKind Kind;
    public Action Action;
    public bool CloseAfterAction;
    public bool IsDefault { get; }
    public InfoBarUI(string title, UIKind kind, Action action, bool closeAfterAction);
    public bool get_IsDefault();
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Extensions.IExtensionManager", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Extensions.ServicesLayerExtensionManager : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal static class Microsoft.CodeAnalysis.FailFast : object {
    [DebuggerHiddenAttribute]
internal static void OnFatalException(Exception exception);
    [ConditionalAttribute("DEBUG")]
[DebuggerHiddenAttribute]
internal static void Assert(bool condition, string message);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.FileTextLoader : TextLoader {
    private string _path;
    private Encoding _defaultEncoding;
    public string Path { get; }
    public Encoding DefaultEncoding { get; }
    public FileTextLoader(string path, Encoding defaultEncoding);
    public string get_Path();
    public Encoding get_DefaultEncoding();
    protected virtual SourceText CreateText(Stream stream, Workspace workspace);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FileTextLoader/<LoadTextAndVersionAsync>d__8")]
public virtual Task`1<TextAndVersion> LoadTextAndVersionAsync(Workspace workspace, DocumentId documentId, CancellationToken cancellationToken);
    internal virtual TextAndVersion LoadTextAndVersionSynchronously(Workspace workspace, DocumentId documentId, CancellationToken cancellationToken);
    private string GetDebuggerDisplay();
    private static void ValidateFileLength(Workspace workspace, string path);
    [CompilerGeneratedAttribute]
private FileStream <LoadTextAndVersionAsync>b__8_0();
    [CompilerGeneratedAttribute]
private FileStream <LoadTextAndVersionSynchronously>b__9_0();
}
internal static class Microsoft.CodeAnalysis.FileTextLoaderOptions : object {
    internal static Option`1<long> FileLengthThreshold;
    private static FileTextLoaderOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.FileTextLoaderOptionsProvider : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
internal static class Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder : object {
    private static SymbolDisplayFormat DottedNameFormat;
    private static DeclarationFinder();
    private static Task AddCompilationDeclarationsWithNormalQueryAsync(Project project, SearchQuery query, SymbolFilter filter, ArrayBuilder`1<SymbolAndProjectId> list, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<AddCompilationDeclarationsWithNormalQueryAsync>d__1")]
private static Task AddCompilationDeclarationsWithNormalQueryAsync(Project project, SearchQuery query, SymbolFilter filter, ArrayBuilder`1<SymbolAndProjectId> list, Compilation startingCompilation, IAssemblySymbol startingAssembly, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<AddMetadataDeclarationsWithNormalQueryAsync>d__2")]
private static Task AddMetadataDeclarationsWithNormalQueryAsync(Project project, IAssemblySymbol assembly, PortableExecutableReference referenceOpt, SearchQuery query, SymbolFilter filter, ArrayBuilder`1<SymbolAndProjectId> list, CancellationToken cancellationToken);
    internal static ImmutableArray`1<SymbolAndProjectId> FilterByCriteria(ImmutableArray`1<SymbolAndProjectId> symbols, SymbolFilter criteria);
    private static bool MeetCriteria(ISymbol symbol, SymbolFilter filter);
    private static bool IsNonTypeMember(ISymbol symbol);
    private static bool IsOn(SymbolFilter filter, SymbolFilter flag);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindAllDeclarationsWithNormalQueryAsync>d__7")]
public static Task`1<ImmutableArray`1<SymbolAndProjectId>> FindAllDeclarationsWithNormalQueryAsync(Project project, SearchQuery query, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindAllDeclarationsWithNormalQueryInCurrentProcessAsync>d__8")]
internal static Task`1<ImmutableArray`1<SymbolAndProjectId>> FindAllDeclarationsWithNormalQueryInCurrentProcessAsync(Project project, SearchQuery query, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<TryFindAllDeclarationsWithNormalQueryInRemoteProcessAsync>d__9")]
private static Task`1<ValueTuple`2<bool, ImmutableArray`1<SymbolAndProjectId>>> TryFindAllDeclarationsWithNormalQueryInRemoteProcessAsync(Project project, SearchQuery query, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<RehydrateAsync>d__10")]
private static Task`1<ImmutableArray`1<SymbolAndProjectId>> RehydrateAsync(Solution solution, IList`1<SerializableSymbolAndProjectId> array, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindSourceDeclarationsWithNormalQueryAsync>d__11")]
public static Task`1<ImmutableArray`1<SymbolAndProjectId>> FindSourceDeclarationsWithNormalQueryAsync(Solution solution, string name, bool ignoreCase, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindSourceDeclarationsWithNormalQueryAsync>d__12")]
public static Task`1<ImmutableArray`1<SymbolAndProjectId>> FindSourceDeclarationsWithNormalQueryAsync(Project project, string name, bool ignoreCase, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindSourceDeclarationsWithPatternAsync>d__13")]
public static Task`1<ImmutableArray`1<SymbolAndProjectId>> FindSourceDeclarationsWithPatternAsync(Solution solution, string pattern, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindSourceDeclarationsWithPatternAsync>d__14")]
public static Task`1<ImmutableArray`1<SymbolAndProjectId>> FindSourceDeclarationsWithPatternAsync(Project project, string pattern, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<TryFindSourceDeclarationsWithNormalQueryInRemoteProcessAsync>d__15")]
private static Task`1<ValueTuple`2<bool, ImmutableArray`1<SymbolAndProjectId>>> TryFindSourceDeclarationsWithNormalQueryInRemoteProcessAsync(Solution solution, string name, bool ignoreCase, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<TryFindSourceDeclarationsWithNormalQueryInRemoteProcessAsync>d__16")]
private static Task`1<ValueTuple`2<bool, ImmutableArray`1<SymbolAndProjectId>>> TryFindSourceDeclarationsWithNormalQueryInRemoteProcessAsync(Project project, string name, bool ignoreCase, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<TryFindSourceDeclarationsWithPatternInRemoteProcessAsync>d__17")]
private static Task`1<ValueTuple`2<bool, ImmutableArray`1<SymbolAndProjectId>>> TryFindSourceDeclarationsWithPatternInRemoteProcessAsync(Solution solution, string pattern, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<TryFindSourceDeclarationsWithPatternInRemoteProcessAsync>d__18")]
private static Task`1<ValueTuple`2<bool, ImmutableArray`1<SymbolAndProjectId>>> TryFindSourceDeclarationsWithPatternInRemoteProcessAsync(Project project, string pattern, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindSourceDeclarationsWithNormalQueryInCurrentProcessAsync>d__19")]
internal static Task`1<ImmutableArray`1<SymbolAndProjectId>> FindSourceDeclarationsWithNormalQueryInCurrentProcessAsync(Solution solution, string name, bool ignoreCase, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindSourceDeclarationsWithNormalQueryInCurrentProcessAsync>d__20")]
internal static Task`1<ImmutableArray`1<SymbolAndProjectId>> FindSourceDeclarationsWithNormalQueryInCurrentProcessAsync(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindSourceDeclarationsWithPatternInCurrentProcessAsync>d__21")]
private static Task`1<ImmutableArray`1<SymbolAndProjectId>> FindSourceDeclarationsWithPatternInCurrentProcessAsync(string pattern, Func`2<SearchQuery, Task`1<ImmutableArray`1<SymbolAndProjectId>>> searchAsync);
    internal static Task`1<ImmutableArray`1<SymbolAndProjectId>> FindSourceDeclarationsWithPatternInCurrentProcessAsync(Solution solution, string pattern, SymbolFilter criteria, CancellationToken cancellationToken);
    internal static Task`1<ImmutableArray`1<SymbolAndProjectId>> FindSourceDeclarationsWithPatternInCurrentProcessAsync(Project project, string pattern, SymbolFilter criteria, CancellationToken cancellationToken);
    private static string GetContainer(ISymbol symbol);
}
internal class Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NameSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContainerDisplayName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullyQualifiedContainerName>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    private UInt32 _flags;
    private static UInt32 Lower4BitMask;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <InheritanceNames>k__BackingField;
    public string Name { get; }
    public string NameSuffix { get; }
    public string ContainerDisplayName { get; }
    public string FullyQualifiedContainerName { get; }
    public TextSpan Span { get; }
    public DeclaredSymbolInfoKind Kind { get; }
    public Accessibility Accessibility { get; }
    public byte ParameterCount { get; }
    public byte TypeParameterCount { get; }
    public bool IsNestedType { get; }
    public ImmutableArray`1<string> InheritanceNames { get; }
    public DeclaredSymbolInfo(StringTable stringTable, string name, string nameSuffix, string containerDisplayName, string fullyQualifiedContainerName, DeclaredSymbolInfoKind kind, Accessibility accessibility, TextSpan span, ImmutableArray`1<string> inheritanceNames, bool isNestedType, int parameterCount, int typeParameterCount);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_NameSuffix();
    [CompilerGeneratedAttribute]
public string get_ContainerDisplayName();
    [CompilerGeneratedAttribute]
public string get_FullyQualifiedContainerName();
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    public DeclaredSymbolInfoKind get_Kind();
    public Accessibility get_Accessibility();
    public byte get_ParameterCount();
    public byte get_TypeParameterCount();
    public bool get_IsNestedType();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_InheritanceNames();
    public static string Intern(StringTable stringTable, string name);
    private static DeclaredSymbolInfoKind GetKind(UInt32 flags);
    private static Accessibility GetAccessibility(UInt32 flags);
    private static byte GetParameterCount(UInt32 flags);
    private static byte GetTypeParameterCount(UInt32 flags);
    private static bool GetIsNestedType(UInt32 flags);
    internal void WriteTo(ObjectWriter writer);
    internal static DeclaredSymbolInfo ReadFrom_ThrowsOnFailure(StringTable stringTable, ObjectReader reader);
    public ISymbol TryResolve(SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfoKind : Enum {
    public byte value__;
    public static DeclaredSymbolInfoKind Class;
    public static DeclaredSymbolInfoKind Constant;
    public static DeclaredSymbolInfoKind Constructor;
    public static DeclaredSymbolInfoKind Delegate;
    public static DeclaredSymbolInfoKind Enum;
    public static DeclaredSymbolInfoKind EnumMember;
    public static DeclaredSymbolInfoKind Event;
    public static DeclaredSymbolInfoKind ExtensionMethod;
    public static DeclaredSymbolInfoKind Field;
    public static DeclaredSymbolInfoKind Indexer;
    public static DeclaredSymbolInfoKind Interface;
    public static DeclaredSymbolInfoKind Method;
    public static DeclaredSymbolInfoKind Module;
    public static DeclaredSymbolInfoKind Property;
    public static DeclaredSymbolInfoKind Struct;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder : object {
    private static ConditionalWeakTable`2<Solution, ConcurrentDictionary`2<DefinitionProject, ImmutableArray`1<DependentProject>>> s_dependentProjectsCache;
    private static CreateValueCallback<Solution, ConcurrentDictionary`2<DefinitionProject, ImmutableArray`1<DependentProject>>> s_createDependentProjectsMapCallback;
    private static DependentProjectsFinder();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder/<GetDependentProjectsAsync>d__4")]
public static Task`1<ImmutableArray`1<Project>> GetDependentProjectsAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    private static ImmutableArray`1<Project> GetAllProjects(Solution solution);
    private static ImmutableArray`1<Project> GetProjects(Solution solution, ImmutableArray`1<ProjectId> projectIds);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder/<GetDependentProjectsWorkerAsync>d__7")]
[ExtensionAttribute]
private static Task`1<ImmutableArray`1<Project>> GetDependentProjectsWorkerAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder/<GetDependentProjectsCoreAsync>d__8")]
private static Task`1<ImmutableArray`1<DependentProject>> GetDependentProjectsCoreAsync(ISymbol symbol, Solution solution, Project sourceProject, SymbolVisibility visibility, CancellationToken cancellationToken);
    private static ImmutableArray`1<Project> FilterDependentProjectsByVisibility(Solution solution, ImmutableArray`1<DependentProject> dependentProjects, SymbolVisibility visibility);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder/<AddSubmissionDependentProjectsAsync>d__10")]
private static Task AddSubmissionDependentProjectsAsync(Solution solution, Project sourceProject, HashSet`1<DependentProject> dependentProjects, CancellationToken cancellationToken);
    private static bool IsInternalsVisibleToAttribute(AttributeData attr);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder/<AddNonSubmissionDependentProjectsAsync>d__12")]
private static Task AddNonSubmissionDependentProjectsAsync(IAssemblySymbol sourceAssembly, Solution solution, Project sourceProject, HashSet`1<DependentProject> dependentProjects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder/<HasInternalsAccessAsync>d__13")]
private static Task`1<bool> HasInternalsAccessAsync(IAssemblySymbol sourceAssembly, Lazy`1<HashSet`1<string>> internalsVisibleToMap, SymbolKey sourceAssemblySymbolKey, Project project, CancellationToken cancellationToken);
    private static Lazy`1<HashSet`1<string>> CreateInternalsVisibleToMap(IAssemblySymbol assembly);
    private static bool HasReferenceTo(IAssemblySymbol containingAssembly, Project sourceProject, Project project, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool HasReferenceToAssembly(Project project, IAssemblySymbol assemblySymbol);
    [ExtensionAttribute]
public static bool HasReferenceToAssembly(Project project, string assemblyName);
    [ExtensionAttribute]
private static Nullable`1<T> GetAssemblyReferenceType(Project project, Func`2<IAssemblySymbol, Nullable`1<T>> predicate);
}
internal static class Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder : object {
    private static Func`2<Location, bool> s_isInMetadata;
    private static Func`2<Location, bool> s_isInSource;
    private static Func`2<INamedTypeSymbol, bool> s_isNonSealedClass;
    private static Func`2<INamedTypeSymbol, bool> s_isInterfaceOrNonSealedClass;
    private static ObjectPool`1<HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>>> s_setPool;
    private static ConditionalWeakTable`2<Solution, ConcurrentDictionary`2<ValueTuple`2<SymbolKey, IImmutableSet`1<Project>>, AsyncLazy`1<ImmutableArray`1<ValueTuple`2<SymbolKey, ProjectId>>>>> s_typeToImmediatelyDerivedClassesMap;
    private static ConditionalWeakTable`2<Solution, ConcurrentDictionary`2<ValueTuple`2<SymbolKey, IImmutableSet`1<Project>>, AsyncLazy`1<ImmutableArray`1<ValueTuple`2<SymbolKey, ProjectId>>>>> s_typeToTransitivelyDerivedClassesMap;
    private static ConditionalWeakTable`2<Solution, ConcurrentDictionary`2<ValueTuple`2<SymbolKey, IImmutableSet`1<Project>>, AsyncLazy`1<ImmutableArray`1<ValueTuple`2<SymbolKey, ProjectId>>>>> s_typeToTransitivelyImplementingTypesMap;
    private static ConditionalWeakTable`2<Solution, ConcurrentDictionary`2<ValueTuple`2<SymbolKey, IImmutableSet`1<Project>>, AsyncLazy`1<ImmutableArray`1<ValueTuple`2<SymbolKey, ProjectId>>>>> s_typeToImmediatelyDerivedAndImplementingTypesMap;
    private static DependentTypeFinder();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<FindTypesFromCacheOrComputeAsync>d__9")]
public static Task`1<ImmutableArray`1<SymbolAndProjectId`1<INamedTypeSymbol>>> FindTypesFromCacheOrComputeAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, ConditionalWeakTable`2<Solution, ConcurrentDictionary`2<ValueTuple`2<SymbolKey, IImmutableSet`1<Project>>, AsyncLazy`1<ImmutableArray`1<ValueTuple`2<SymbolKey, ProjectId>>>>> cache, Func`2<CancellationToken, Task`1<ImmutableArray`1<SymbolAndProjectId`1<INamedTypeSymbol>>>> findAsync, CancellationToken cancellationToken);
    public static Task`1<ImmutableArray`1<SymbolAndProjectId`1<INamedTypeSymbol>>> FindImmediatelyDerivedClassesAsync(INamedTypeSymbol type, Solution solution, CancellationToken cancellationToken);
    public static Task`1<ImmutableArray`1<SymbolAndProjectId`1<INamedTypeSymbol>>> FindTransitivelyDerivedClassesAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    private static Task`1<ImmutableArray`1<SymbolAndProjectId`1<INamedTypeSymbol>>> FindDerivedClassesAsync(SymbolAndProjectId`1<INamedTypeSymbol> type, Solution solution, IImmutableSet`1<Project> projects, bool transitive, CancellationToken cancellationToken);
    public static Task`1<ImmutableArray`1<SymbolAndProjectId`1<INamedTypeSymbol>>> FindTransitivelyImplementingTypesAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<FindTransitivelyImplementingTypesWorkerAsync>d__14")]
private static Task`1<ImmutableArray`1<SymbolAndProjectId`1<INamedTypeSymbol>>> FindTransitivelyImplementingTypesWorkerAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    public static Task`1<ImmutableArray`1<SymbolAndProjectId`1<INamedTypeSymbol>>> FindImmediatelyDerivedAndImplementingTypesAsync(INamedTypeSymbol type, Solution solution, CancellationToken cancellationToken);
    private static Task`1<ImmutableArray`1<SymbolAndProjectId`1<INamedTypeSymbol>>> FindDerivedAndImplementingTypesAsync(SymbolAndProjectId`1<INamedTypeSymbol> type, Solution solution, IImmutableSet`1<Project> projects, bool transitive, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<FindTypesAsync>d__17")]
private static Task`1<ImmutableArray`1<SymbolAndProjectId`1<INamedTypeSymbol>>> FindTypesAsync(SymbolAndProjectId`1<INamedTypeSymbol> type, Solution solution, IImmutableSet`1<Project> projects, Func`3<HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>>, INamedTypeSymbol, bool> metadataTypeMatches, Func`3<HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>>, INamedTypeSymbol, bool> sourceTypeImmediatelyMatches, Func`2<INamedTypeSymbol, bool> shouldContinueSearching, bool transitive, CancellationToken cancellationToken);
    private static ImmutableArray`1<SymbolAndProjectId`1<INamedTypeSymbol>> ToImmutableAndFree(HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> set);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<FindTypesInProjectAsync>d__19")]
private static Task FindTypesInProjectAsync(bool searchInMetadata, HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> result, HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> currentMetadataTypes, HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> currentSourceAndMetadataTypes, Project project, Func`3<HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>>, INamedTypeSymbol, bool> metadataTypeMatches, Func`3<HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>>, INamedTypeSymbol, bool> sourceTypeImmediatelyMatches, Func`2<INamedTypeSymbol, bool> shouldContinueSearching, bool transitive, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<GetProjectsThatCouldReferenceTypeAsync>d__20")]
private static Task`1<ISet`1<ProjectId>> GetProjectsThatCouldReferenceTypeAsync(INamedTypeSymbol type, Solution solution, bool searchInMetadata, CancellationToken cancellationToken);
    private static IEnumerable`1<ProjectId> GetProjectsThatCouldReferenceType(ProjectDependencyGraph dependencyGraph, Project project);
    private static List`1<Project> GetOrderedProjectsToExamine(Solution solution, IImmutableSet`1<Project> projects, IEnumerable`1<ProjectId> projectsThatCouldReferenceType);
    private static List`1<Project> OrderTopologically(Solution solution, IEnumerable`1<Project> projectsToExamine);
    private static IEnumerable`1<Project> GetProjectsToExamineWorker(Solution solution, IImmutableSet`1<Project> projects, IEnumerable`1<ProjectId> projectsThatCouldReferenceType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<AddAllMatchingMetadataTypesInProjectAsync>d__25")]
private static Task AddAllMatchingMetadataTypesInProjectAsync(HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> metadataTypes, Project project, Func`3<HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>>, INamedTypeSymbol, bool> metadataTypeMatches, HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> result, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<FindImmediateMatchingMetadataTypesInMetadataReferenceAsync>d__26")]
private static Task FindImmediateMatchingMetadataTypesInMetadataReferenceAsync(HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> metadataTypes, Project project, Func`3<HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>>, INamedTypeSymbol, bool> metadataTypeMatches, Compilation compilation, PortableExecutableReference reference, HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> result, CancellationToken cancellationToken);
    private static bool TypeDerivesFrom(HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> metadataTypes, INamedTypeSymbol type, bool transitive);
    private static bool TypeImplementsFrom(HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> metadataTypes, INamedTypeSymbol type, bool transitive);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<AddSourceTypesInProjectAsync>d__29")]
private static Task AddSourceTypesInProjectAsync(HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> sourceAndMetadataTypes, Project project, Func`3<HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>>, INamedTypeSymbol, bool> sourceTypeImmediatelyMatches, Func`2<INamedTypeSymbol, bool> shouldContinueSearching, bool transitive, HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> finalResult, CancellationToken cancellationToken);
    private static bool ImmediatelyDerivesOrImplementsFrom(HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> typesToSearchFor, INamedTypeSymbol type);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<AddTypesThatDeriveFromNameAsync>d__31")]
private static Task AddTypesThatDeriveFromNameAsync(Func`3<HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>>, INamedTypeSymbol, bool> typeImmediatelyMatches, ConcurrentSet`1<SemanticModel> cachedModels, HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> typesToSearchFor, ProjectIndex index, HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> result, string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<AddMatchingTypesAsync>d__32")]
private static Task AddMatchingTypesAsync(ConcurrentSet`1<SemanticModel> cachedModels, MultiDictionary`2<Document, DeclaredSymbolInfo> documentToInfos, HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> result, Func`2<INamedTypeSymbol, bool> predicateOpt, CancellationToken cancellationToken);
    private static HashSet`1<SymbolAndProjectId`1<INamedTypeSymbol>> CreateSymbolAndProjectIdSet();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FindSymbols.Extensions : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Extensions/<GetConstructorInitializerTokensAsync>d__0")]
[ExtensionAttribute]
public static Task`1<IEnumerable`1<SyntaxToken>> GetConstructorInitializerTokensAsync(Document document, SemanticModel model, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Extensions/<GetIdentifierOrGlobalNamespaceTokensWithTextAsync>d__1")]
[ExtensionAttribute]
internal static Task`1<ImmutableArray`1<SyntaxToken>> GetIdentifierOrGlobalNamespaceTokensWithTextAsync(Document document, SemanticModel model, string identifier, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool TextMatch(ISyntaxFactsService syntaxFacts, string text1, string text2);
}
internal abstract class Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractMemberScopedReferenceFinder`1 : AbstractReferenceFinder`1<TSymbol> {
    protected sealed virtual bool CanFind(TSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(TSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractMemberScopedReferenceFinder`1/<FindReferencesInDocumentAsync>d__2")]
protected virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(TSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ISymbol GetContainer(ISymbol symbol);
    protected Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInTokensWithSymbolNameAsync(TSymbol symbol, Document document, SemanticModel semanticModel, IEnumerable`1<SyntaxToken> tokens, CancellationToken cancellationToken);
    protected Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInTokensWithSymbolNameAsync(TSymbol symbol, Document document, SemanticModel semanticModel, IEnumerable`1<SyntaxToken> tokens, Func`2<SyntaxToken, SyntaxNode> findParentNode, CancellationToken cancellationToken);
    private Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInContainerAsync(TSymbol symbol, ISymbol container, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    private Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInContainerAsync(TSymbol symbol, ISymbol container, Document document, SemanticModel semanticModel, Func`2<SyntaxToken, SyntaxNode> findParentNode, CancellationToken cancellationToken);
    protected abstract virtual Func`2<SyntaxToken, bool> GetTokensMatchFunction(ISyntaxFactsService syntaxFacts, string name);
}
internal abstract class Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1 : AbstractReferenceFinder`1<TSymbol> {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1/<DetermineCascadedSymbolsAsync>d__1")]
protected virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId`1<TSymbol> symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder : object {
    public abstract virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId symbolAndProject, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<Project>> DetermineProjectsToSearchAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(ISymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(SymbolAndProjectId symbolAndProjectId, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected static bool TryGetNameWithoutAttributeSuffix(string name, ISyntaxFactsService syntaxFacts, String& result);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindDocumentsAsync>d__5")]
protected Task`1<ImmutableArray`1<Document>> FindDocumentsAsync(Project project, IImmutableSet`1<Document> scope, Func`3<Document, CancellationToken, Task`1<bool>> predicateAsync, CancellationToken cancellationToken);
    protected Task`1<ImmutableArray`1<Document>> FindDocumentsAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken, String[] values);
    protected Task`1<ImmutableArray`1<Document>> FindDocumentsAsync(Project project, IImmutableSet`1<Document> documents, PredefinedType predefinedType, CancellationToken cancellationToken);
    protected Task`1<ImmutableArray`1<Document>> FindDocumentsAsync(Project project, IImmutableSet`1<Document> documents, PredefinedOperator op, CancellationToken cancellationToken);
    protected static bool IdentifiersMatch(ISyntaxFactsService syntaxFacts, string name, SyntaxToken token);
    protected static Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentUsingIdentifierAsync(ISymbol symbol, string identifier, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected static Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentUsingIdentifierAsync(ISymbol symbol, string identifier, Document document, SemanticModel semanticModel, Func`2<SyntaxToken, SyntaxNode> findParentNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindReferencesInDocumentUsingIdentifierAsync>d__12")]
protected static Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentUsingIdentifierAsync(string identifier, Document document, SemanticModel semanticModel, Func`3<SyntaxToken, SemanticModel, ValueTuple`2<bool, CandidateReason>> symbolsMatch, CancellationToken cancellationToken);
    protected static Func`3<SyntaxToken, SemanticModel, ValueTuple`2<bool, CandidateReason>> GetStandardSymbolsMatchFunction(ISymbol symbol, Func`2<SyntaxToken, SyntaxNode> findParentNode, Solution solution, CancellationToken cancellationToken);
    protected static Func`3<SyntaxNode, SemanticModel, ValueTuple`2<bool, CandidateReason>> GetStandardSymbolsNodeMatchFunction(ISymbol searchSymbol, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindReferencesInTokensAsync>d__15")]
protected static Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInTokensAsync(Document document, SemanticModel semanticModel, IEnumerable`1<SyntaxToken> tokens, Func`2<SyntaxToken, bool> tokensMatch, Func`3<SyntaxToken, SemanticModel, ValueTuple`2<bool, CandidateReason>> symbolsMatch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<GetAliasSymbolAsync>d__16")]
private static Task`1<IAliasSymbol> GetAliasSymbolAsync(Document document, SemanticModel semanticModel, ReferenceLocation location, CancellationToken cancellationToken);
    protected static Task`1<ImmutableArray`1<ReferenceLocation>> FindAliasReferencesAsync(ImmutableArray`1<ReferenceLocation> nonAliasReferences, ISymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindAliasReferencesAsync>d__18")]
protected static Task`1<ImmutableArray`1<ReferenceLocation>> FindAliasReferencesAsync(ImmutableArray`1<ReferenceLocation> nonAliasReferences, ISymbol symbol, Document document, SemanticModel semanticModel, Func`2<SyntaxToken, SyntaxNode> findParentNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindAliasReferencesAsync>d__19")]
protected static Task`1<ImmutableArray`1<ReferenceLocation>> FindAliasReferencesAsync(ImmutableArray`1<ReferenceLocation> nonAliasReferences, ISymbol symbol, Document document, SemanticModel semanticModel, Func`3<SyntaxToken, SemanticModel, ValueTuple`2<bool, CandidateReason>> symbolsMatch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<GetAliasSymbolsAsync>d__20")]
private static Task`1<ImmutableArray`1<IAliasSymbol>> GetAliasSymbolsAsync(Document document, SemanticModel semanticModel, ImmutableArray`1<ReferenceLocation> nonAliasReferences, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindReferencesThroughAliasSymbolsAsync>d__21")]
private static Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesThroughAliasSymbolsAsync(ISymbol symbol, Document document, SemanticModel semanticModel, ImmutableArray`1<IAliasSymbol> aliasSymbols, Func`2<SyntaxToken, SyntaxNode> findParentNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindReferencesThroughAliasSymbolsAsync>d__22")]
private static Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesThroughAliasSymbolsAsync(ISymbol symbol, Document document, SemanticModel semanticModel, ImmutableArray`1<IAliasSymbol> aliasSymbols, Func`3<SyntaxToken, SemanticModel, ValueTuple`2<bool, CandidateReason>> symbolsMatch, CancellationToken cancellationToken);
    private Task`1<ImmutableArray`1<Document>> FindDocumentsWithPredicateAsync(Project project, IImmutableSet`1<Document> documents, Func`2<SyntaxTreeIndex, bool> predicate, CancellationToken cancellationToken);
    protected Task`1<ImmutableArray`1<Document>> FindDocumentsWithForEachStatementsAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected Task`1<ImmutableArray`1<Document>> FindDocumentsWithDeconstructionAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected Task`1<ImmutableArray`1<Document>> FindDocumentsWithAwaitExpressionAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindReferencesInDocumentAsync>d__28")]
private Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(ISymbol symbol, Document document, SemanticModel semanticModel, Func`2<SyntaxTreeIndex, bool> isRelevantDocument, CollectMatchingReferences collectMatchingReferences, CancellationToken cancellationToken);
    protected Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInForEachStatementsAsync(ISymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDeconstructionAsync(ISymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInAwaitExpressionAsync(ISymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool Matches(ISymbol symbol1, ISymbol notNulloriginalUnreducedSymbol2);
}
internal abstract class Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1 : AbstractReferenceFinder {
    protected abstract virtual bool CanFind(TSymbol symbol);
    protected abstract virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(TSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected abstract virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(TSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    public virtual Task`1<ImmutableArray`1<Project>> DetermineProjectsToSearchAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    public virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(ISymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    public virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(SymbolAndProjectId symbolAndProjectId, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    public virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<Project>> DetermineProjectsToSearchAsync(TSymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId`1<TSymbol> symbolAndProject, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected static Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentUsingSymbolNameAsync(TSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    protected Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInTokensAsync(TSymbol symbol, Document document, SemanticModel semanticModel, IEnumerable`1<SyntaxToken> tokens, Func`2<SyntaxToken, bool> tokensMatch, CancellationToken cancellationToken);
    protected Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInTokensAsync(TSymbol symbol, Document document, SemanticModel semanticModel, IEnumerable`1<SyntaxToken> tokens, Func`2<SyntaxToken, bool> tokensMatch, Func`2<SyntaxToken, SyntaxNode> findParentNode, CancellationToken cancellationToken);
    protected static Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(TSymbol symbol, Document document, SemanticModel semanticModel, Func`2<SyntaxToken, bool> tokensMatch, CancellationToken cancellationToken);
    protected static Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(TSymbol symbol, Document document, SemanticModel semanticModel, Func`2<SyntaxToken, bool> tokensMatch, Func`2<SyntaxToken, SyntaxNode> findParentNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1/<FindReferencesInDocumentAsync>d__14")]
protected static Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(TSymbol symbol, Document document, SemanticModel semanticModel, Func`2<SyntaxToken, bool> tokensMatch, Func`3<SyntaxToken, SemanticModel, ValueTuple`2<bool, CandidateReason>> symbolsMatch, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorInitializerSymbolReferenceFinder : AbstractReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorInitializerSymbolReferenceFinder/<FindReferencesInDocumentAsync>d__2")]
protected virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(IMethodSymbol methodSymbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorSymbolReferenceFinder : AbstractReferenceFinder`1<IMethodSymbol> {
    public static ConstructorSymbolReferenceFinder Instance;
    private static ConstructorSymbolReferenceFinder();
    protected virtual bool CanFind(IMethodSymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorSymbolReferenceFinder/<DetermineDocumentsToSearchAsync>d__3")]
protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private static bool IsPotentialReference(PredefinedType predefinedType, ISyntaxFactsService syntaxFacts, SyntaxToken token);
    protected virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(IMethodSymbol methodSymbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorSymbolReferenceFinder/<FindAllReferencesInDocumentAsync>d__6")]
internal Task`1<ImmutableArray`1<ReferenceLocation>> FindAllReferencesInDocumentAsync(IMethodSymbol methodSymbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static Func`2<SyntaxToken, SyntaxNode> GetFindParentNodeFunction(ISyntaxFactsService syntaxFacts);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorSymbolReferenceFinder/<FindReferencesInDocumentWorkerAsync>d__8")]
private Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentWorkerAsync(IMethodSymbol symbol, Document document, SemanticModel semanticModel, Func`2<SyntaxToken, SyntaxNode> findParentNode, CancellationToken cancellationToken);
    private Task`1<ImmutableArray`1<ReferenceLocation>> FindOrdinaryReferencesAsync(IMethodSymbol symbol, Document document, SemanticModel semanticModel, Func`2<SyntaxToken, SyntaxNode> findParentNode, CancellationToken cancellationToken);
    private Task`1<ImmutableArray`1<ReferenceLocation>> FindPredefinedTypeReferencesAsync(IMethodSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    private Task`1<ImmutableArray`1<ReferenceLocation>> FindAttributeReferencesAsync(IMethodSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.DestructorSymbolReferenceFinder : AbstractReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId`1<IMethodSymbol> symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(IMethodSymbol methodSymbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.EventSymbolReferenceFinder : AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1<IEventSymbol> {
    protected virtual bool CanFind(IEventSymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.EventSymbolReferenceFinder/<DetermineCascadedSymbolsAsync>d__1")]
protected virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId`1<IEventSymbol> symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IEventSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(IEventSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ImmutableArray`1<SymbolAndProjectId>> <>n__0(SymbolAndProjectId`1<IEventSymbol> symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.ExplicitInterfaceMethodReferenceFinder : AbstractReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId`1<IMethodSymbol> symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(IMethodSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.FieldSymbolReferenceFinder : AbstractReferenceFinder`1<IFieldSymbol> {
    protected virtual bool CanFind(IFieldSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId`1<IFieldSymbol> symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IFieldSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(IFieldSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.FindSymbols.Finders.ILanguageServiceReferenceFinder {
    public abstract virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId symbolAndProjectId, Project project, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder {
    public abstract virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId symbolAndProject, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<Project>> DetermineProjectsToSearchAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(ISymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(SymbolAndProjectId symbolAndProjectId, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.LabelSymbolReferenceFinder : AbstractMemberScopedReferenceFinder`1<ILabelSymbol> {
    protected virtual Func`2<SyntaxToken, bool> GetTokensMatchFunction(ISyntaxFactsService syntaxFacts, string name);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.LinkedFileReferenceFinder : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.LinkedFileReferenceFinder/<DetermineCascadedSymbolsAsync>d__0")]
public sealed virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    public sealed virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(ISymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    public sealed virtual Task`1<ImmutableArray`1<Project>> DetermineProjectsToSearchAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    public sealed virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(SymbolAndProjectId symbolAndProjectId, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.LocalSymbolReferenceFinder : AbstractMemberScopedReferenceFinder`1<ILocalSymbol> {
    protected virtual Func`2<SyntaxToken, bool> GetTokensMatchFunction(ISyntaxFactsService syntaxFacts, string name);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.MethodTypeParameterSymbolReferenceFinder : AbstractReferenceFinder`1<ITypeParameterSymbol> {
    protected virtual bool CanFind(ITypeParameterSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId`1<ITypeParameterSymbol> symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(ITypeParameterSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private static string GetMemberNameWithoutInterfaceName(string fullName);
    protected virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(ITypeParameterSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder : AbstractReferenceFinder`1<INamedTypeSymbol> {
    protected virtual bool CanFind(INamedTypeSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId`1<INamedTypeSymbol> symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    private void Add(ArrayBuilder`1<SymbolAndProjectId> result, SymbolAndProjectId symbolAndProjectId, ImmutableArray`1<TSymbol> enumerable);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder/<DetermineDocumentsToSearchAsync>d__3")]
protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(INamedTypeSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private static bool IsPotentialReference(PredefinedType predefinedType, ISyntaxFactsService syntaxFacts, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder/<FindReferencesInDocumentAsync>d__5")]
protected virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(INamedTypeSymbol namedType, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder/<MarkConstructorReferences>d__6")]
private Task`1<ImmutableArray`1<ReferenceLocation>> MarkConstructorReferences(INamedTypeSymbol namedType, Document document, SemanticModel semanticModel, ImmutableArray`1<ReferenceLocation> namedTypereferences, CancellationToken cancellationToken);
    private bool Contains(ArrayBuilder`1<ReferenceLocation> constructorReferences, ReferenceLocation reference);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder/<FindReferencesInDocumentWorker>d__8")]
private static Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentWorker(INamedTypeSymbol namedType, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder/<FindNonAliasReferencesAsync>d__9")]
internal static Task`1<ImmutableArray`1<ReferenceLocation>> FindNonAliasReferencesAsync(INamedTypeSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static Task`1<ImmutableArray`1<ReferenceLocation>> FindOrdinaryReferencesAsync(INamedTypeSymbol namedType, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static Task`1<ImmutableArray`1<ReferenceLocation>> FindPredefinedTypeReferencesAsync(INamedTypeSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static Task`1<ImmutableArray`1<ReferenceLocation>> FindAttributeReferencesAsync(INamedTypeSymbol namedType, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.NamespaceSymbolReferenceFinder : AbstractReferenceFinder`1<INamespaceSymbol> {
    private static SymbolDisplayFormat s_globalNamespaceFormat;
    private static NamespaceSymbolReferenceFinder();
    protected virtual bool CanFind(INamespaceSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(INamespaceSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private static string GetNamespaceIdentifierName(INamespaceSymbol symbol, Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamespaceSymbolReferenceFinder/<FindReferencesInDocumentAsync>d__4")]
protected virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(INamespaceSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.OperatorSymbolReferenceFinder : AbstractReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(IMethodSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    private bool IsPotentialReference(ISyntaxFactsService syntaxFacts, PredefinedOperator op, SyntaxToken token);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.OrdinaryMethodReferenceFinder : AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.OrdinaryMethodReferenceFinder/<DetermineCascadedSymbolsAsync>d__1")]
protected virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId`1<IMethodSymbol> symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    private ImmutableArray`1<SymbolAndProjectId> GetOtherPartsOfPartial(SymbolAndProjectId`1<IMethodSymbol> symbolAndProjectId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.OrdinaryMethodReferenceFinder/<DetermineDocumentsToSearchAsync>d__3")]
protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol methodSymbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private bool IsForEachMethod(IMethodSymbol methodSymbol);
    private bool IsDeconstructMethod(IMethodSymbol methodSymbol);
    private bool IsGetAwaiterMethod(IMethodSymbol methodSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.OrdinaryMethodReferenceFinder/<FindReferencesInDocumentAsync>d__7")]
protected virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(IMethodSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ImmutableArray`1<SymbolAndProjectId>> <>n__0(SymbolAndProjectId`1<IMethodSymbol> symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.ParameterSymbolReferenceFinder : AbstractReferenceFinder`1<IParameterSymbol> {
    protected virtual bool CanFind(IParameterSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IParameterSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(IParameterSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    private Func`3<SyntaxToken, SemanticModel, ValueTuple`2<bool, CandidateReason>> GetParameterSymbolsMatchFunction(IParameterSymbol parameter, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ParameterSymbolReferenceFinder/<DetermineCascadedSymbolsAsync>d__4")]
protected virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId`1<IParameterSymbol> parameterAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ParameterSymbolReferenceFinder/<CascadeBetweenAnonymousFunctionParametersAsync>d__5")]
private Task CascadeBetweenAnonymousFunctionParametersAsync(Solution solution, SymbolAndProjectId`1<IParameterSymbol> parameterAndProjectId, ArrayBuilder`1<SymbolAndProjectId> results, CancellationToken cancellationToken);
    private void CascadeBetweenAnonymousFunctionParameters(Document document, SemanticModel semanticModel, SyntaxNode container, SymbolAndProjectId`1<IParameterSymbol> parameterAndProjectId, ITypeSymbol convertedType1, ArrayBuilder`1<SymbolAndProjectId> results, CancellationToken cancellationToken);
    private bool ParameterNamesMatch(ISyntaxFactsService syntaxFacts, IMethodSymbol methodSymbol1, IMethodSymbol methodSymbol2);
    private SyntaxNode GetContainer(SemanticModel semanticModel, SyntaxNode parameterNode, ISyntaxFactsService syntaxFactsService);
    private void CascadeBetweenPropertyAndAccessorParameters(Solution solution, SymbolAndProjectId`1<IParameterSymbol> parameterAndProjectId, ArrayBuilder`1<SymbolAndProjectId> results);
    private void CascadeBetweenDelegateMethodParameters(Solution solution, SymbolAndProjectId`1<IParameterSymbol> parameterAndProjectId, ArrayBuilder`1<SymbolAndProjectId> results);
    private static void AddParameterAtIndex(SymbolAndProjectId`1<IParameterSymbol> parameterAndProjectId, ArrayBuilder`1<SymbolAndProjectId> results, int ordinal, Nullable`1<ImmutableArray`1<IParameterSymbol>> parameters);
    private void CascadeBetweenPartialMethodParameters(SymbolAndProjectId`1<IParameterSymbol> parameterAndProjectId, ArrayBuilder`1<SymbolAndProjectId> results);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.PropertyAccessorSymbolReferenceFinder : AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertyAccessorSymbolReferenceFinder/<DetermineCascadedSymbolsAsync>d__1")]
protected virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId`1<IMethodSymbol> symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(IMethodSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ImmutableArray`1<SymbolAndProjectId>> <>n__0(SymbolAndProjectId`1<IMethodSymbol> symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder : AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1<IPropertySymbol> {
    protected virtual bool CanFind(IPropertySymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder/<DetermineCascadedSymbolsAsync>d__1")]
protected virtual Task`1<ImmutableArray`1<SymbolAndProjectId>> DetermineCascadedSymbolsAsync(SymbolAndProjectId`1<IPropertySymbol> symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder/<DetermineDocumentsToSearchAsync>d__2")]
protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IPropertySymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private static bool IsForEachProperty(IPropertySymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder/<FindReferencesInDocumentAsync>d__4")]
protected virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(IPropertySymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    private Task`1<ImmutableArray`1<Document>> FindDocumentWithElementAccessExpressionsAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private Task`1<ImmutableArray`1<Document>> FindDocumentWithIndexerMemberCrefAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder/<FindElementAccessReferencesAndIndexerMemberCrefReferencesAsync>d__7")]
private Task`1<ImmutableArray`1<ReferenceLocation>> FindElementAccessReferencesAndIndexerMemberCrefReferencesAsync(IPropertySymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ImmutableArray`1<SymbolAndProjectId>> <>n__0(SymbolAndProjectId`1<IPropertySymbol> symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.RangeVariableSymbolReferenceFinder : AbstractMemberScopedReferenceFinder`1<IRangeVariableSymbol> {
    protected virtual Func`2<SyntaxToken, bool> GetTokensMatchFunction(ISyntaxFactsService syntaxFacts, string name);
}
internal static class Microsoft.CodeAnalysis.FindSymbols.Finders.ReferenceFinders : object {
    public static IReferenceFinder Constructor;
    public static IReferenceFinder ConstructorInitializer;
    public static IReferenceFinder Destructor;
    public static IReferenceFinder ExplicitInterfaceMethod;
    public static IReferenceFinder Event;
    public static IReferenceFinder Field;
    public static IReferenceFinder Label;
    public static IReferenceFinder LinkedFiles;
    public static IReferenceFinder Local;
    public static IReferenceFinder MethodTypeParameter;
    public static IReferenceFinder NamedType;
    public static IReferenceFinder Namespace;
    public static IReferenceFinder Operator;
    public static IReferenceFinder OrdinaryMethod;
    public static IReferenceFinder Parameter;
    public static IReferenceFinder Property;
    public static IReferenceFinder PropertyAccessor;
    public static IReferenceFinder RangeVariable;
    public static IReferenceFinder TypeParameter;
    public static ImmutableArray`1<IReferenceFinder> DefaultReferenceFinders;
    internal static ImmutableArray`1<IReferenceFinder> DefaultRenameReferenceFinders;
    private static ReferenceFinders();
}
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.TypeParameterSymbolReferenceFinder : AbstractReferenceFinder`1<ITypeParameterSymbol> {
    protected virtual bool CanFind(ITypeParameterSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(ITypeParameterSymbol symbol, Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<ReferenceLocation>> FindReferencesInDocumentAsync(ITypeParameterSymbol symbol, Document document, SemanticModel semanticModel, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.FindLiteralsSearchEngine : object {
    private Solution _solution;
    private IStreamingFindLiteralReferencesProgress _progress;
    private StreamingProgressTracker _progressTracker;
    private CancellationToken _cancellationToken;
    private object _value;
    private string _stringValue;
    private long _longValue;
    private SearchKind _searchKind;
    public FindLiteralsSearchEngine(Solution solution, IStreamingFindLiteralReferencesProgress progress, object value, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindLiteralsSearchEngine/<FindReferencesAsync>d__10")]
public Task FindReferencesAsync();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindLiteralsSearchEngine/<FindReferencesWorkerAsync>d__11")]
private Task FindReferencesWorkerAsync();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindLiteralsSearchEngine/<ProcessDocumentAsync>d__12")]
private Task ProcessDocumentAsync(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindLiteralsSearchEngine/<ProcessDocumentWorkerAsync>d__13")]
private Task ProcessDocumentWorkerAsync(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindLiteralsSearchEngine/<SearchDocumentAsync>d__14")]
private Task SearchDocumentAsync(Document document);
    private void ProcessNode(ISyntaxFactsService syntaxFacts, SyntaxNode node, ArrayBuilder`1<SyntaxToken> matches);
    private void ProcessToken(ISyntaxFactsService syntaxFacts, SyntaxToken token, ArrayBuilder`1<SyntaxToken> matches);
    private void CheckToken(SyntaxToken token, ArrayBuilder`1<SyntaxToken> matches);
}
internal static class Microsoft.CodeAnalysis.FindSymbols.FindReferenceCache : object {
    private static ReaderWriterLockSlim s_gate;
    private static Dictionary`2<SemanticModel, Entry> s_cache;
    private static Func`2<SemanticModel, Entry> s_entryCreator;
    private static FindReferenceCache();
    public static SymbolInfo GetSymbolInfo(SemanticModel model, SyntaxNode node, CancellationToken cancellationToken);
    public static IAliasSymbol GetAliasInfo(ISemanticFactsService semanticFacts, SemanticModel model, SyntaxToken token, CancellationToken cancellationToken);
    public static ImmutableArray`1<SyntaxToken> GetIdentifierOrGlobalNamespaceTokensWithText(ISyntaxFactsService syntaxFacts, Document document, VersionStamp version, SemanticModel model, SyntaxNode root, SourceText sourceText, string text, CancellationToken cancellationToken);
    private static ImmutableArray`1<SyntaxToken> GetIdentifierOrGlobalNamespaceTokensWithText(ISyntaxFactsService syntaxFacts, Document document, VersionStamp version, SyntaxNode root, SourceText sourceText, string text, CancellationToken cancellationToken);
    private static ImmutableArray`1<SyntaxToken> GetTokensFromText(ISyntaxFactsService syntaxFacts, Document document, VersionStamp version, SyntaxNode root, SourceText content, string text, Func`2<SyntaxToken, bool> candidate, CancellationToken cancellationToken);
    private static ImmutableArray`1<SyntaxToken> GetTokensFromText(SyntaxNode root, List`1<int> positions, string text, Func`2<SyntaxToken, bool> candidate, CancellationToken cancellationToken);
    private static ImmutableArray`1<SyntaxToken> GetTokensFromText(ISyntaxFactsService syntaxFacts, SyntaxNode root, SourceText content, string text, Func`2<SyntaxToken, bool> candidate, CancellationToken cancellationToken);
    public static IEnumerable`1<SyntaxToken> GetConstructorInitializerTokens(ISyntaxFactsService syntaxFacts, SemanticModel model, SyntaxNode root, CancellationToken cancellationToken);
    private static List`1<SyntaxToken> GetConstructorInitializerTokens(ISyntaxFactsService syntaxFacts, SyntaxNode root, CancellationToken cancellationToken);
    private static ConcurrentDictionary`2<SyntaxNode, SymbolInfo> GetNodeCache(SemanticModel model);
    private static Entry GetCachedEntry(SemanticModel model);
    public static void Start(SemanticModel model);
    public static void Stop(SemanticModel model);
}
internal class Microsoft.CodeAnalysis.FindSymbols.FindReferencesProgress : object {
    public static IFindReferencesProgress Instance;
    private static FindReferencesProgress();
    public sealed virtual void ReportProgress(int current, int maximum);
    public sealed virtual void OnCompleted();
    public sealed virtual void OnStarted();
    public sealed virtual void OnDefinitionFound(ISymbol symbol);
    public sealed virtual void OnReferenceFound(ISymbol symbol, ReferenceLocation location);
    public sealed virtual void OnFindInDocumentStarted(Document document);
    public sealed virtual void OnFindInDocumentCompleted(Document document);
}
internal class Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine : object {
    private Solution _solution;
    private IImmutableSet`1<Document> _documents;
    private ImmutableArray`1<IReferenceFinder> _finders;
    private StreamingProgressTracker _progressTracker;
    private IStreamingFindReferencesProgress _progress;
    private CancellationToken _cancellationToken;
    private ProjectDependencyGraph _dependencyGraph;
    private ConcurrentDictionary`2<Document, ConcurrentSet`1<ReferenceLocation>> _documentToLocationMap;
    private static Func`2<Document, ConcurrentSet`1<ReferenceLocation>> s_createDocumentLocations;
    private static Func`3<Document, ISymbol, string> s_logDocument;
    public FindReferencesSearchEngine(Solution solution, IImmutableSet`1<Document> documents, ImmutableArray`1<IReferenceFinder> finders, IStreamingFindReferencesProgress progress, CancellationToken cancellationToken);
    private static FindReferencesSearchEngine();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<FindReferencesAsync>d__10")]
public Task FindReferencesAsync(SymbolAndProjectId symbolAndProjectId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ProcessAsync>d__11")]
private Task ProcessAsync(Dictionary`2<Project, MultiDictionary`2<Document, ValueTuple`2<SymbolAndProjectId, IReferenceFinder>>> projectToDocumentMap);
    [ConditionalAttribute("DEBUG")]
private static void ValidateProjectToDocumentMap(Dictionary`2<Project, MultiDictionary`2<Document, ValueTuple`2<SymbolAndProjectId, IReferenceFinder>>> projectToDocumentMap);
    private Task HandleLocationAsync(SymbolAndProjectId symbolAndProjectId, ReferenceLocation location);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ProcessDocumentQueueAsync>d__14")]
private Task ProcessDocumentQueueAsync(Document document, ValueSet<Document, ValueTuple`2<SymbolAndProjectId, IReferenceFinder>> documentQueue);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ProcessDocumentAsync>d__16")]
private Task ProcessDocumentAsync(Document document, SemanticModel semanticModel, SymbolAndProjectId symbolAndProjectId, IReferenceFinder finder);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<CreateProjectToDocumentMapAsync>d__17")]
private Task`1<Dictionary`2<Project, MultiDictionary`2<Document, ValueTuple`2<SymbolAndProjectId, IReferenceFinder>>>> CreateProjectToDocumentMapAsync(MultiDictionary`2<Project, ValueTuple`2<SymbolAndProjectId, IReferenceFinder>> projectMap);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<CreateProjectMapAsync>d__18")]
private Task`1<MultiDictionary`2<Project, ValueTuple`2<SymbolAndProjectId, IReferenceFinder>>> CreateProjectMapAsync(ConcurrentSet`1<SymbolAndProjectId> symbols);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<DetermineAllSymbolsAsync>d__19")]
private Task`1<ConcurrentSet`1<SymbolAndProjectId>> DetermineAllSymbolsAsync(SymbolAndProjectId symbolAndProjectId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<DetermineAllSymbolsCoreAsync>d__20")]
private Task DetermineAllSymbolsCoreAsync(SymbolAndProjectId symbolAndProjectId, ConcurrentSet`1<SymbolAndProjectId> result);
    private void AddSymbolTasks(ConcurrentSet`1<SymbolAndProjectId> result, ImmutableArray`1<SymbolAndProjectId> symbols, List`1<Task> symbolTasks);
    private ImmutableHashSet`1<Project> GetProjectScope();
    private static SymbolAndProjectId MapToAppropriateSymbol(SymbolAndProjectId symbolAndProjectId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ProcessProjectsAsync>d__24")]
private Task ProcessProjectsAsync(IEnumerable`1<ProjectId> connectedProjectSet, Dictionary`2<Project, MultiDictionary`2<Document, ValueTuple`2<SymbolAndProjectId, IReferenceFinder>>> projectToDocumentMap);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ProcessProjectAsync>d__25")]
private Task ProcessProjectAsync(ProjectId projectId, Dictionary`2<Project, MultiDictionary`2<Document, ValueTuple`2<SymbolAndProjectId, IReferenceFinder>>> projectToDocumentMap, HashSet`1<ProjectId> visitedProjects);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ProcessProjectAsync>d__26")]
private Task ProcessProjectAsync(Project project, Dictionary`2<Project, MultiDictionary`2<Document, ValueTuple`2<SymbolAndProjectId, IReferenceFinder>>> projectToDocumentMap);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ProcessProjectAsync>d__27")]
private Task ProcessProjectAsync(Project project, MultiDictionary`2<Document, ValueTuple`2<SymbolAndProjectId, IReferenceFinder>> documentMap);
}
internal interface Microsoft.CodeAnalysis.FindSymbols.IDeclaredSymbolInfoFactoryService {
    public abstract virtual bool TryGetDeclaredSymbolInfo(StringTable stringTable, SyntaxNode node, DeclaredSymbolInfo& declaredSymbolInfo);
}
public interface Microsoft.CodeAnalysis.FindSymbols.IFindReferencesProgress {
    public abstract virtual void OnStarted();
    public abstract virtual void OnCompleted();
    public abstract virtual void OnFindInDocumentStarted(Document document);
    public abstract virtual void OnFindInDocumentCompleted(Document document);
    public abstract virtual void OnDefinitionFound(ISymbol symbol);
    public abstract virtual void OnReferenceFound(ISymbol symbol, ReferenceLocation location);
    public abstract virtual void ReportProgress(int current, int maximum);
}
internal interface Microsoft.CodeAnalysis.FindSymbols.IRemoteSymbolFinder {
    public abstract virtual Task FindReferencesAsync(SerializableSymbolAndProjectId symbolAndProjectIdArg, DocumentId[] documentArgs, CancellationToken cancellationToken);
    public abstract virtual Task FindLiteralReferencesAsync(object value, TypeCode typeCode, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<SerializableSymbolAndProjectId>> FindAllDeclarationsWithNormalQueryAsync(ProjectId projectId, string name, SearchKind searchKind, SymbolFilter criteria, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<SerializableSymbolAndProjectId>> FindSolutionSourceDeclarationsWithNormalQueryAsync(string name, bool ignoreCase, SymbolFilter criteria, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<SerializableSymbolAndProjectId>> FindProjectSourceDeclarationsWithNormalQueryAsync(ProjectId projectId, string name, bool ignoreCase, SymbolFilter criteria, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<SerializableSymbolAndProjectId>> FindSolutionSourceDeclarationsWithPatternAsync(string pattern, SymbolFilter criteria, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<SerializableSymbolAndProjectId>> FindProjectSourceDeclarationsWithPatternAsync(ProjectId projectId, string pattern, SymbolFilter criteria, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.FindSymbols.IStreamingFindLiteralReferencesProgress {
    public abstract virtual Task OnReferenceFoundAsync(Document document, TextSpan span);
    public abstract virtual Task ReportProgressAsync(int current, int maximum);
}
internal interface Microsoft.CodeAnalysis.FindSymbols.IStreamingFindReferencesProgress {
    public abstract virtual Task OnStartedAsync();
    public abstract virtual Task OnCompletedAsync();
    public abstract virtual Task OnFindInDocumentStartedAsync(Document document);
    public abstract virtual Task OnFindInDocumentCompletedAsync(Document document);
    public abstract virtual Task OnDefinitionFoundAsync(SymbolAndProjectId symbolAndProjectId);
    public abstract virtual Task OnReferenceFoundAsync(SymbolAndProjectId symbolAndProjectId, ReferenceLocation location);
    public abstract virtual Task ReportProgressAsync(int current, int maximum);
}
internal class Microsoft.CodeAnalysis.FindSymbols.MetadataUnifyingEquivalenceComparer : object {
    public static IEqualityComparer`1<ISymbol> Instance;
    private static MetadataUnifyingEquivalenceComparer();
    public sealed virtual bool Equals(ISymbol x, ISymbol y);
    public sealed virtual int GetHashCode(ISymbol obj);
    private static bool IsInSource(ISymbol symbol);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol : object {
    [CompilerGeneratedAttribute]
private SymbolAndProjectId <DefinitionAndProjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ReferenceLocation> <Locations>k__BackingField;
    public ISymbol Definition { get; }
    internal SymbolAndProjectId DefinitionAndProjectId { get; }
    public IEnumerable`1<ReferenceLocation> Locations { get; }
    internal ReferencedSymbol(SymbolAndProjectId definitionAndProjectId, IEnumerable`1<ReferenceLocation> locations);
    public ISymbol get_Definition();
    [CompilerGeneratedAttribute]
internal SymbolAndProjectId get_DefinitionAndProjectId();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ReferenceLocation> get_Locations();
    internal string GetDebuggerDisplay();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation : ValueType {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private IAliasSymbol <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWrittenTo>k__BackingField;
    internal bool IsDuplicateReferenceLocation;
    [CompilerGeneratedAttribute]
private CandidateReason <CandidateReason>k__BackingField;
    public Document Document { get; }
    public IAliasSymbol Alias { get; }
    public Location Location { get; }
    public bool IsImplicit { get; }
    internal bool IsWrittenTo { get; }
    public CandidateReason CandidateReason { get; }
    public bool IsCandidateLocation { get; }
    internal ReferenceLocation(Document document, IAliasSymbol alias, Location location, bool isImplicit, bool isWrittenTo, CandidateReason candidateReason);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public IAliasSymbol get_Alias();
    [CompilerGeneratedAttribute]
public Location get_Location();
    [CompilerGeneratedAttribute]
public bool get_IsImplicit();
    [CompilerGeneratedAttribute]
internal bool get_IsWrittenTo();
    [CompilerGeneratedAttribute]
public CandidateReason get_CandidateReason();
    public bool get_IsCandidateLocation();
    public static bool op_Equality(ReferenceLocation left, ReferenceLocation right);
    public static bool op_Inequality(ReferenceLocation left, ReferenceLocation right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReferenceLocation other);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(ReferenceLocation other);
    private string GetDebuggerDisplay();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FindSymbols.ReferenceLocationExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.ReferenceLocationExtensions/<FindReferencingSymbolsAsync>d__0")]
[ExtensionAttribute]
public static Task`1<Dictionary`2<ISymbol, List`1<Location>>> FindReferencingSymbolsAsync(IEnumerable`1<ReferenceLocation> referenceLocations, CancellationToken cancellationToken);
    private static void AddSymbols(Document document, SemanticModel semanticModel, IEnumerable`1<ReferenceLocation> references, Dictionary`2<ISymbol, List`1<Location>> result, CancellationToken cancellationToken);
    private static ISymbol GetEnclosingMethodOrPropertyOrField(SemanticModel semanticModel, ReferenceLocation reference);
}
internal enum Microsoft.CodeAnalysis.FindSymbols.SearchKind : Enum {
    public int value__;
    public static SearchKind Exact;
    public static SearchKind ExactIgnoreCase;
    public static SearchKind Fuzzy;
    public static SearchKind Custom;
}
internal class Microsoft.CodeAnalysis.FindSymbols.SearchQuery : object {
    public string Name;
    public SearchKind Kind;
    private Func`2<string, bool> _predicate;
    private WordSimilarityChecker _wordSimilarityChecker;
    private SearchQuery(string name, SearchKind kind);
    private SearchQuery(Func`2<string, bool> predicate);
    public sealed virtual void Dispose();
    public static SearchQuery Create(string name, SearchKind kind);
    public static SearchQuery Create(string name, bool ignoreCase);
    public static SearchQuery CreateFuzzy(string name);
    public static SearchQuery CreateCustom(Func`2<string, bool> predicate);
    public Func`2<string, bool> GetPredicate();
}
internal class Microsoft.CodeAnalysis.FindSymbols.StreamingFindReferencesProgress : object {
    public static IStreamingFindReferencesProgress Instance;
    private static StreamingFindReferencesProgress();
    public sealed virtual Task ReportProgressAsync(int current, int maximum);
    public sealed virtual Task OnCompletedAsync();
    public sealed virtual Task OnStartedAsync();
    public sealed virtual Task OnDefinitionFoundAsync(SymbolAndProjectId symbol);
    public sealed virtual Task OnReferenceFoundAsync(SymbolAndProjectId symbol, ReferenceLocation location);
    public sealed virtual Task OnFindInDocumentStartedAsync(Document document);
    public sealed virtual Task OnFindInDocumentCompletedAsync(Document document);
}
internal class Microsoft.CodeAnalysis.FindSymbols.StreamingFindReferencesProgressAdapter : object {
    private IFindReferencesProgress _progress;
    public StreamingFindReferencesProgressAdapter(IFindReferencesProgress progress);
    public sealed virtual Task OnCompletedAsync();
    public sealed virtual Task OnDefinitionFoundAsync(SymbolAndProjectId symbolAndProjectId);
    public sealed virtual Task OnFindInDocumentCompletedAsync(Document document);
    public sealed virtual Task OnFindInDocumentStartedAsync(Document document);
    public sealed virtual Task OnReferenceFoundAsync(SymbolAndProjectId symbolAndProjectId, ReferenceLocation location);
    public sealed virtual Task OnStartedAsync();
    public sealed virtual Task ReportProgressAsync(int current, int maximum);
}
internal class Microsoft.CodeAnalysis.FindSymbols.StreamingProgressCollector : object {
    private object _gate;
    private IStreamingFindReferencesProgress _underlyingProgress;
    private Dictionary`2<SymbolAndProjectId, List`1<ReferenceLocation>> _symbolToLocations;
    public StreamingProgressCollector(IStreamingFindReferencesProgress underlyingProgress);
    public ImmutableArray`1<ReferencedSymbol> GetReferencedSymbols();
    public sealed virtual Task OnStartedAsync();
    public sealed virtual Task OnCompletedAsync();
    public sealed virtual Task ReportProgressAsync(int current, int maximum);
    public sealed virtual Task OnFindInDocumentCompletedAsync(Document document);
    public sealed virtual Task OnFindInDocumentStartedAsync(Document document);
    public sealed virtual Task OnDefinitionFoundAsync(SymbolAndProjectId definition);
    public sealed virtual Task OnReferenceFoundAsync(SymbolAndProjectId definition, ReferenceLocation location);
}
internal class Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId : ValueType {
    public ISymbol Symbol;
    public ProjectId ProjectId;
    public SymbolAndProjectId(ISymbol symbol, ProjectId projectId);
    public virtual bool Equals(object obj);
    public bool Equals(SymbolAndProjectId other);
    public virtual int GetHashCode();
    public static SymbolAndProjectId Create(ISymbol symbol, ProjectId projectId);
    public static SymbolAndProjectId`1<TSymbol> Create(TSymbol symbol, ProjectId projectId);
    public SymbolAndProjectId`1<TOther> WithSymbol(TOther other);
    public SymbolAndProjectId WithSymbol(ISymbol other);
}
internal class Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectId`1 : ValueType {
    public TSymbol Symbol;
    public ProjectId ProjectId;
    public SymbolAndProjectId`1(TSymbol symbol, ProjectId projectId);
    public static SymbolAndProjectId op_Implicit(SymbolAndProjectId`1<TSymbol> value);
    public SymbolAndProjectId`1<TOther> WithSymbol(TOther other);
    public SymbolAndProjectId WithSymbol(ISymbol other);
}
internal class Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectIdComparer : object {
    public static SymbolAndProjectIdComparer SymbolEquivalenceInstance;
    private IEqualityComparer`1<ISymbol> _underlyingComparer;
    public SymbolAndProjectIdComparer(IEqualityComparer`1<ISymbol> underlyingComparer);
    private static SymbolAndProjectIdComparer();
    public sealed virtual bool Equals(SymbolAndProjectId x, SymbolAndProjectId y);
    public sealed virtual int GetHashCode(SymbolAndProjectId obj);
}
internal class Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectIdComparer`1 : object {
    public static SymbolAndProjectIdComparer`1<TSymbol> SymbolEquivalenceInstance;
    private static IEqualityComparer`1<ISymbol> _underlyingComparer;
    private static SymbolAndProjectIdComparer`1();
    public sealed virtual bool Equals(SymbolAndProjectId`1<TSymbol> x, SymbolAndProjectId`1<TSymbol> y);
    public sealed virtual int GetHashCode(SymbolAndProjectId`1<TSymbol> obj);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FindSymbols.SymbolAndProjectIdExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<SymbolAndProjectId`1<TConvert>> Convert(IEnumerable`1<SymbolAndProjectId`1<TOriginal>> list);
}
public class Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo : ValueType {
    [CompilerGeneratedAttribute]
private ISymbol <CallingSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Location> <Locations>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <CalledSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDirect>k__BackingField;
    public ISymbol CallingSymbol { get; }
    public IEnumerable`1<Location> Locations { get; }
    public ISymbol CalledSymbol { get; }
    public bool IsDirect { get; }
    internal SymbolCallerInfo(ISymbol callingSymbol, ISymbol calledSymbol, IEnumerable`1<Location> locations, bool isDirect);
    [CompilerGeneratedAttribute]
public ISymbol get_CallingSymbol();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Location> get_Locations();
    [CompilerGeneratedAttribute]
public ISymbol get_CalledSymbol();
    [CompilerGeneratedAttribute]
public bool get_IsDirect();
}
public static class Microsoft.CodeAnalysis.FindSymbols.SymbolFinder : object {
    [ObsoleteAttribute("Use FindSymbolAtPositionAsync instead.")]
public static ISymbol FindSymbolAtPosition(SemanticModel semanticModel, int position, Workspace workspace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSymbolAtPositionAsync>d__1")]
public static Task`1<ISymbol> FindSymbolAtPositionAsync(SemanticModel semanticModel, int position, Workspace workspace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<GetSemanticInfoAtPositionAsync>d__2")]
internal static Task`1<TokenSemanticInfo> GetSemanticInfoAtPositionAsync(SemanticModel semanticModel, int position, Workspace workspace, CancellationToken cancellationToken);
    private static Task`1<SyntaxToken> GetTokenAtPositionAsync(SemanticModel semanticModel, int position, Workspace workspace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSymbolAtPositionAsync>d__4")]
public static Task`1<ISymbol> FindSymbolAtPositionAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDefinitionAsync>d__5")]
public static Task`1<ISymbol> FindSourceDefinitionAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    internal static Task`1<SymbolAndProjectId> FindSourceDefinitionAsync(SymbolAndProjectId symbolAndProjectId, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDefinitionWorkerAsync>d__7")]
private static Task`1<SymbolAndProjectId> FindSourceDefinitionWorkerAsync(SymbolAndProjectId symbolAndProjectId, Solution solution, CancellationToken cancellationToken);
    private static bool InSource(ISymbol symbol);
    public static IEnumerable`1<TSymbol> FindSimilarSymbols(TSymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindDeclarationsAsync>d__12")]
public static Task`1<IEnumerable`1<ISymbol>> FindDeclarationsAsync(Project project, string name, bool ignoreCase, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindDeclarationsAsync>d__13")]
public static Task`1<IEnumerable`1<ISymbol>> FindDeclarationsAsync(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Solution solution, Func`2<string, bool> predicate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsAsync>d__15")]
public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Solution solution, Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsWithCustomQueryAsync>d__16")]
internal static Task`1<ImmutableArray`1<SymbolAndProjectId>> FindSourceDeclarationsWithCustomQueryAsync(Solution solution, SearchQuery query, SymbolFilter filter, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Project project, Func`2<string, bool> predicate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsAsync>d__18")]
public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Project project, Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsWithCustomQueryAsync>d__19")]
internal static Task`1<ImmutableArray`1<SymbolAndProjectId>> FindSourceDeclarationsWithCustomQueryAsync(Project project, SearchQuery query, SymbolFilter filter, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Solution solution, string name, bool ignoreCase, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsAsync>d__21")]
public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Solution solution, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Project project, string name, bool ignoreCase, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsAsync>d__23")]
public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsWithPatternAsync(Solution solution, string pattern, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsWithPatternAsync>d__25")]
public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsWithPatternAsync(Solution solution, string pattern, SymbolFilter filter, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsWithPatternAsync(Project project, string pattern, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsWithPatternAsync>d__27")]
public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsWithPatternAsync(Project project, string pattern, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindLiteralReferencesAsync>d__28")]
internal static Task FindLiteralReferencesAsync(object value, TypeCode typeCode, Solution solution, IStreamingFindLiteralReferencesProgress progress, CancellationToken cancellationToken);
    internal static Task FindLiteralReferencesInCurrentProcessAsync(object value, Solution solution, IStreamingFindLiteralReferencesProgress progress, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<TryFindLiteralReferencesInServiceProcessAsync>d__30")]
private static Task`1<bool> TryFindLiteralReferencesInServiceProcessAsync(object value, TypeCode typeCode, Solution solution, IStreamingFindLiteralReferencesProgress progress, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindReferencesAsync>d__31")]
internal static Task FindReferencesAsync(SymbolAndProjectId symbolAndProjectId, Solution solution, IStreamingFindReferencesProgress progress, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    internal static Task FindReferencesInCurrentProcessAsync(SymbolAndProjectId symbolAndProjectId, Solution solution, IStreamingFindReferencesProgress progress, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<TryFindReferencesInServiceProcessAsync>d__33")]
private static Task`1<bool> TryFindReferencesInServiceProcessAsync(SymbolAndProjectId symbolAndProjectId, Solution solution, IStreamingFindReferencesProgress progress, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindReferencesAsync>d__34")]
public static Task`1<IEnumerable`1<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindReferencesAsync>d__36")]
public static Task`1<IEnumerable`1<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, IFindReferencesProgress progress, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindRenamableReferencesAsync>d__37")]
internal static Task`1<ImmutableArray`1<ReferencedSymbol>> FindRenamableReferencesAsync(SymbolAndProjectId symbolAndProjectId, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindOverridesAsync>d__38")]
public static Task`1<IEnumerable`1<ISymbol>> FindOverridesAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindOverridesAsync>d__39")]
internal static Task`1<ImmutableArray`1<SymbolAndProjectId>> FindOverridesAsync(SymbolAndProjectId symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    private static bool IsOverride(Solution solution, ISymbol member, ISymbol symbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindImplementedInterfaceMembersAsync>d__41")]
public static Task`1<IEnumerable`1<ISymbol>> FindImplementedInterfaceMembersAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindImplementedInterfaceMembersAsync>d__42")]
internal static Task`1<ImmutableArray`1<SymbolAndProjectId>> FindImplementedInterfaceMembersAsync(SymbolAndProjectId symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    private static IEnumerable`1<SymbolAndProjectId> GetMembers(SymbolAndProjectId`1<INamedTypeSymbol> interfaceType, string name);
    private static IEnumerable`1<SymbolAndProjectId`1<INamedTypeSymbol>> GetAllInterfaces(SymbolAndProjectId`1<ITypeSymbol> type);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindDerivedClassesAsync>d__45")]
public static Task`1<IEnumerable`1<INamedTypeSymbol>> FindDerivedClassesAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    internal static Task`1<ImmutableArray`1<SymbolAndProjectId`1<INamedTypeSymbol>>> FindDerivedClassesAsync(SymbolAndProjectId`1<INamedTypeSymbol> typeAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindImplementationsAsync>d__47")]
public static Task`1<IEnumerable`1<ISymbol>> FindImplementationsAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindImplementationsAsync>d__48")]
internal static Task`1<ImmutableArray`1<SymbolAndProjectId>> FindImplementationsAsync(SymbolAndProjectId symbolAndProjectId, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    private static bool IsAccessible(SymbolAndProjectId symbolAndProjectId);
    public static Task`1<IEnumerable`1<SymbolCallerInfo>> FindCallersAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindCallersAsync>d__51")]
public static Task`1<IEnumerable`1<SymbolCallerInfo>> FindCallersAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindCallReferencesAsync>d__52")]
private static Task`1<ImmutableArray`1<ReferencedSymbol>> FindCallReferencesAsync(Solution solution, ISymbol symbol, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private static bool OriginalSymbolsMatch(ISymbol searchSymbol, ISymbol symbolToMatch, Solution solution, CancellationToken cancellationToken);
    internal static bool OriginalSymbolsMatch(ISymbol searchSymbol, ISymbol symbolToMatch, Solution solution, Compilation searchSymbolCompilation, Compilation symbolToMatchCompilation, CancellationToken cancellationToken);
    private static bool OriginalSymbolsMatchCore(ISymbol searchSymbol, ISymbol symbolToMatch, Solution solution, Compilation searchSymbolCompilation, Compilation symbolToMatchCompilation, CancellationToken cancellationToken);
    private static bool NamespaceSymbolsMatch(INamespaceSymbol namespace1, INamespaceSymbol namespace2, Solution solution, CancellationToken cancellationToken);
    private static bool VerifyForwardedTypes(Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies, ISymbol searchSymbol, ISymbol symbolToMatch, Solution solution, Compilation searchSymbolCompilation, Compilation symbolToMatchCompilation, CancellationToken cancellationToken);
    private static int VerifyForwardedTypes(Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies, Compilation compilation, HashSet`1<INamedTypeSymbol> verifiedKeys, bool isSearchSymbolCompilation);
    private static bool TryGetCompilation(ISymbol symbol, Solution solution, Compilation& definingCompilation, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.FindSymbols.SymbolTree.ISymbolTreeInfoCacheService {
    public abstract virtual Task`1<SymbolTreeInfo> TryGetSourceSymbolTreeInfoAsync(Project project, CancellationToken cancellationToken);
    public abstract virtual Task`1<SymbolTreeInfo> TryGetMetadataSymbolTreeInfoAsync(Solution solution, PortableExecutableReference reference, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo : object {
    [CompilerGeneratedAttribute]
private Checksum <Checksum>k__BackingField;
    private string _concatenatedNames;
    private ImmutableArray`1<Node> _nodes;
    private OrderPreservingMultiDictionary`2<int, int> _inheritanceMap;
    private Task`1<SpellChecker> _spellCheckerTask;
    private static StringSliceComparer s_caseInsensitiveComparer;
    private static Comparison`1<string> s_totalComparer;
    private static ConditionalWeakTable`2<MetadataId, SemaphoreSlim> s_metadataIdToGate;
    private static ConditionalWeakTable`2<MetadataId, Task`1<SymbolTreeInfo>> s_metadataIdToInfo;
    private static CreateValueCallback<MetadataId, SemaphoreSlim> s_metadataIdToGateCallback;
    private static int RootNodeParentIndex;
    private static string PrefixMetadataSymbolTreeInfo;
    private static string SerializationFormat;
    private static SimplePool`1<MultiDictionary`2<string, ISymbol>> s_symbolMapPool;
    private static ConditionalWeakTable`2<ProjectState, AsyncLazy`1<Checksum>> s_projectToSourceChecksum;
    private static Func`2<ISymbol, bool> s_useSymbolNoPrivate;
    private static Func`2<ISymbol, bool> s_useSymbolNoPrivateOrInternal;
    private static Action`2<ISymbol, MultiDictionary`2<string, ISymbol>> s_getMembersNoPrivate;
    public Checksum Checksum { get; }
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    private SymbolTreeInfo(Checksum checksum, string concatenatedNames, ImmutableArray`1<Node> sortedNodes, Task`1<SpellChecker> spellCheckerTask, OrderPreservingMultiDictionary`2<string, string> inheritanceMap);
    private SymbolTreeInfo(Checksum checksum, string concatenatedNames, ImmutableArray`1<Node> sortedNodes, Task`1<SpellChecker> spellCheckerTask, OrderPreservingMultiDictionary`2<int, int> inheritanceMap);
    private static SymbolTreeInfo();
    [CompilerGeneratedAttribute]
public sealed virtual Checksum get_Checksum();
    public static SymbolTreeInfo CreateEmpty(Checksum checksum);
    public SymbolTreeInfo WithChecksum(Checksum checksum);
    public Task`1<ImmutableArray`1<SymbolAndProjectId>> FindAsync(SearchQuery query, IAssemblySymbol assembly, ProjectId assemblyProjectId, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<FindAsync>d__14")]
public Task`1<ImmutableArray`1<SymbolAndProjectId>> FindAsync(SearchQuery query, AsyncLazy`1<IAssemblySymbol> lazyAssembly, ProjectId assemblyProjectId, SymbolFilter filter, CancellationToken cancellationToken);
    private Task`1<ImmutableArray`1<ISymbol>> FindAsyncWorker(SearchQuery query, AsyncLazy`1<IAssemblySymbol> lazyAssembly, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<FuzzyFindAsync>d__16")]
private Task`1<ImmutableArray`1<ISymbol>> FuzzyFindAsync(AsyncLazy`1<IAssemblySymbol> lazyAssembly, string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<FindAsync>d__17")]
private Task`1<ImmutableArray`1<ISymbol>> FindAsync(AsyncLazy`1<IAssemblySymbol> lazyAssembly, string name, bool ignoreCase, CancellationToken cancellationToken);
    private static StringSliceComparer GetComparer(bool ignoreCase);
    private IEnumerable`1<int> FindNodeIndices(string name, StringSliceComparer comparer);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<FindNodeIndices>d__20")]
private static IEnumerable`1<int> FindNodeIndices(string concatenatedNames, ImmutableArray`1<Node> nodes, string name, StringSliceComparer comparer);
    private StringSlice GetNameSlice(int nodeIndex);
    private static StringSlice GetNameSlice(string concatenatedNames, ImmutableArray`1<Node> nodes, int nodeIndex);
    private int BinarySearch(string name);
    private static int BinarySearch(string concatenatedNames, ImmutableArray`1<Node> nodes, string name);
    private static Task`1<SpellChecker> GetSpellCheckerTask(Solution solution, Checksum checksum, string filePath, string concatenatedNames, ImmutableArray`1<Node> sortedNodes);
    private static Task`1<SpellChecker> CreateSpellCheckerAsync(Checksum checksum, string concatenatedNames, ImmutableArray`1<Node> sortedNodes);
    private static void SortNodes(ImmutableArray`1<BuilderNode> unsortedNodes, String& concatenatedNames, ImmutableArray`1& sortedNodes);
    private static int CompareNodes(BuilderNode x, BuilderNode y, ImmutableArray`1<BuilderNode> nodeList);
    private void Bind(int index, INamespaceOrTypeSymbol rootContainer, ArrayBuilder`1<ISymbol> results, CancellationToken cancellationToken);
    private string GetName(Node node);
    internal void AssertEquivalentTo(SymbolTreeInfo other);
    private static SymbolTreeInfo CreateSymbolTreeInfo(Solution solution, Checksum checksum, string filePath, ImmutableArray`1<BuilderNode> unsortedNodes, OrderPreservingMultiDictionary`2<string, string> inheritanceMap);
    private static OrderPreservingMultiDictionary`2<int, int> CreateIndexBasedInheritanceMap(string concatenatedNames, ImmutableArray`1<Node> nodes, OrderPreservingMultiDictionary`2<string, string> inheritanceMap);
    public ImmutableArray`1<INamedTypeSymbol> GetDerivedMetadataTypes(string baseTypeName, Compilation compilation, CancellationToken cancellationToken);
    private static string GetMetadataNameWithoutBackticks(MetadataReader reader, StringHandle name);
    private static MetadataId GetMetadataIdNoThrow(PortableExecutableReference reference);
    private static Metadata GetMetadataNoThrow(PortableExecutableReference reference);
    public static Task`1<SymbolTreeInfo> GetInfoForMetadataReferenceAsync(Solution solution, PortableExecutableReference reference, bool loadOnly, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<GetInfoForMetadataReferenceAsync>d__46")]
public static Task`1<SymbolTreeInfo> GetInfoForMetadataReferenceAsync(Solution solution, PortableExecutableReference reference, Checksum checksum, bool loadOnly, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<GetInfoForMetadataReferenceSlowAsync>d__47")]
private static Task`1<SymbolTreeInfo> GetInfoForMetadataReferenceSlowAsync(Solution solution, PortableExecutableReference reference, Checksum checksum, bool loadOnly, Metadata metadata, CancellationToken cancellationToken);
    public static Checksum GetMetadataChecksum(Solution solution, PortableExecutableReference reference, CancellationToken cancellationToken);
    private static Task`1<SymbolTreeInfo> TryLoadOrCreateMetadataSymbolTreeInfoAsync(Solution solution, PortableExecutableReference reference, Checksum checksum, bool loadOnly, CancellationToken cancellationToken);
    private static Task`1<SymbolTreeInfo> CreateMetadataSymbolTreeInfoAsync(Solution solution, Checksum checksum, PortableExecutableReference reference, CancellationToken cancellationToken);
    private static Task`1<SpellChecker> LoadOrCreateSpellCheckerAsync(Solution solution, Checksum checksum, string filePath, string concatenatedNames, ImmutableArray`1<Node> sortedNodes);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<TryLoadOrCreateAsync>d__58`1")]
private static Task`1<T> TryLoadOrCreateAsync(Solution solution, Checksum checksum, bool loadOnly, Func`1<Task`1<T>> createAsync, string keySuffix, Func`2<ObjectReader, T> tryReadObject, CancellationToken cancellationToken);
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    public sealed virtual void WriteTo(ObjectWriter writer);
    internal static SymbolTreeInfo ReadSymbolTreeInfo_ForTestingPurposesOnly(ObjectReader reader, Checksum checksum);
    private static SymbolTreeInfo TryReadSymbolTreeInfo(ObjectReader reader, Func`3<string, ImmutableArray`1<Node>, Task`1<SpellChecker>> createSpellCheckerTask);
    private static MultiDictionary`2<string, ISymbol> AllocateSymbolMap();
    private static void FreeSymbolMap(MultiDictionary`2<string, ISymbol> symbolMap);
    public static Task`1<SymbolTreeInfo> GetInfoForSourceAssemblyAsync(Project project, Checksum checksum, CancellationToken cancellationToken);
    public static Task`1<Checksum> GetSourceSymbolsChecksumAsync(Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<ComputeSourceSymbolsChecksumAsync>d__70")]
private static Task`1<Checksum> ComputeSourceSymbolsChecksumAsync(ProjectState projectState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<CreateSourceSymbolTreeInfoAsync>d__71")]
internal static Task`1<SymbolTreeInfo> CreateSourceSymbolTreeInfoAsync(Project project, Checksum checksum, CancellationToken cancellationToken);
    private static void GenerateSourceNodes(INamespaceSymbol globalNamespace, ArrayBuilder`1<BuilderNode> list, Action`2<ISymbol, MultiDictionary`2<string, ISymbol>> lookup);
    private static void GenerateSourceNodes(string name, int parentIndex, ValueSet<string, ISymbol> symbolsWithSameName, ArrayBuilder`1<BuilderNode> list, Action`2<ISymbol, MultiDictionary`2<string, ISymbol>> lookup);
    private static void AddSymbol(ISymbol symbol, MultiDictionary`2<string, ISymbol> symbolMap, Func`2<ISymbol, bool> useSymbol);
}
internal class Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex : object {
    private LiteralInfo _literalInfo;
    private IdentifierInfo _identifierInfo;
    private ContextInfo _contextInfo;
    private DeclarationInfo _declarationInfo;
    private static ConditionalWeakTable`2<Document, SyntaxTreeIndex> s_documentToIndex;
    private static ConditionalWeakTable`2<DocumentId, SyntaxTreeIndex> s_documentIdToIndex;
    private static double FalsePositiveProbability;
    public static ObjectPool`1<HashSet`1<string>> StringLiteralHashSetPool;
    public static ObjectPool`1<HashSet`1<long>> LongLiteralHashSetPool;
    private static ConditionalWeakTable`2<Project, StringTable> s_projectStringTable;
    private static string PersistenceName;
    private static string SerializationFormat;
    public Checksum Checksum;
    public ImmutableArray`1<DeclaredSymbolInfo> DeclaredSymbolInfos { get; }
    public bool ContainsForEachStatement { get; }
    public bool ContainsDeconstruction { get; }
    public bool ContainsAwait { get; }
    public bool ContainsLockStatement { get; }
    public bool ContainsUsingStatement { get; }
    public bool ContainsQueryExpression { get; }
    public bool ContainsThisConstructorInitializer { get; }
    public bool ContainsBaseConstructorInitializer { get; }
    public bool ContainsElementAccessExpression { get; }
    public bool ContainsIndexerMemberCref { get; }
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    private SyntaxTreeIndex(Checksum checksum, LiteralInfo literalInfo, IdentifierInfo identifierInfo, ContextInfo contextInfo, DeclarationInfo declarationInfo);
    private static SyntaxTreeIndex();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex/<PrecalculateAsync>d__8")]
public static Task PrecalculateAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex/<GetIndexAsync>d__9")]
public static Task`1<SyntaxTreeIndex> GetIndexAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex/<GetIndexWorkerAsync>d__10")]
private static Task`1<SyntaxTreeIndex> GetIndexWorkerAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex/<CreateIndexAsync>d__18")]
private static Task`1<SyntaxTreeIndex> CreateIndexAsync(Document document, Checksum checksum, CancellationToken cancellationToken);
    private static StringTable GetStringTable(Project project);
    private static void GetIdentifierSet(bool ignoreCase, HashSet`1& identifiers, HashSet`1& escapedIdentifiers);
    private static void Free(bool ignoreCase, HashSet`1<string> identifiers, HashSet`1<string> escapedIdentifiers);
    public ImmutableArray`1<DeclaredSymbolInfo> get_DeclaredSymbolInfos();
    public bool ProbablyContainsIdentifier(string identifier);
    public bool ProbablyContainsEscapedIdentifier(string identifier);
    public bool ContainsPredefinedType(PredefinedType type);
    public bool ContainsPredefinedOperator(PredefinedOperator op);
    public bool ProbablyContainsStringValue(string value);
    public bool ProbablyContainsInt64Value(long value);
    public bool get_ContainsForEachStatement();
    public bool get_ContainsDeconstruction();
    public bool get_ContainsAwait();
    public bool get_ContainsLockStatement();
    public bool get_ContainsUsingStatement();
    public bool get_ContainsQueryExpression();
    public bool get_ContainsThisConstructorInitializer();
    public bool get_ContainsBaseConstructorInitializer();
    public bool get_ContainsElementAccessExpression();
    public bool get_ContainsIndexerMemberCref();
    private void WriteFormatAndChecksum(ObjectWriter writer, string formatVersion);
    private static bool TryReadFormatAndChecksum(ObjectReader reader, string formatVersion, Checksum& checksum);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex/<LoadAsync>d__55")]
private static Task`1<SyntaxTreeIndex> LoadAsync(Document document, Checksum checksum, CancellationToken cancellationToken);
    private static bool FormatAndChecksumMatches(ObjectReader reader, string formatVersion, Checksum checksum);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex/<GetChecksumAsync>d__57")]
public static Task`1<Checksum> GetChecksumAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex/<SaveAsync>d__58")]
private Task`1<bool> SaveAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex/<PrecalculatedAsync>d__59")]
private static Task`1<bool> PrecalculatedAsync(Document document, Checksum checksum, CancellationToken cancellationToken);
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    public sealed virtual void WriteTo(ObjectWriter writer);
    private static SyntaxTreeIndex ReadFrom(StringTable stringTable, ObjectReader reader, Checksum checksum);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractAggregatedFormattingResult : object {
    protected SyntaxNode Node;
    private IList`1<AbstractFormattingResult> _formattingResults;
    private SimpleIntervalTree`1<TextSpan> _formattingSpans;
    private CancellableLazy`1<IList`1<TextChange>> _lazyTextChanges;
    private CancellableLazy`1<SyntaxNode> _lazyNode;
    public bool ContainsChanges { get; }
    public AbstractAggregatedFormattingResult(SyntaxNode node, IList`1<AbstractFormattingResult> formattingResults, SimpleIntervalTree`1<TextSpan> formattingSpans);
    protected abstract virtual SyntaxNode Rewriter(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> changeMap, CancellationToken cancellationToken);
    protected SimpleIntervalTree`1<TextSpan> GetFormattingSpans();
    public bool get_ContainsChanges();
    public sealed virtual IList`1<TextChange> GetTextChanges(CancellationToken cancellationToken);
    public sealed virtual SyntaxNode GetFormattedRoot(CancellationToken cancellationToken);
    private IList`1<TextChange> CreateTextChanges(CancellationToken cancellationToken);
    private IList`1<TextChange> CreateTextChangesWorker(CancellationToken cancellationToken);
    private SyntaxNode CreateFormattedRoot(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <CreateTextChanges>b__12_0(TextChange s);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine : object {
    private static int ConcurrentThreshold;
    private ChainedFormattingRules _formattingRules;
    private SyntaxNode _commonRoot;
    private SyntaxToken _token1;
    private SyntaxToken _token2;
    private string _language;
    protected TextSpan SpanToFormat;
    internal TaskExecutor TaskExecutor;
    internal OptionSet OptionSet;
    internal TreeData TreeData;
    public AbstractFormatEngine(TreeData treeData, OptionSet optionSet, IEnumerable`1<IFormattingRule> formattingRules, SyntaxToken token1, SyntaxToken token2, TaskExecutor executor);
    internal AbstractFormatEngine(TreeData treeData, OptionSet optionSet, ChainedFormattingRules formattingRules, SyntaxToken token1, SyntaxToken token2, TaskExecutor executor);
    protected abstract virtual AbstractTriviaDataFactory CreateTriviaFactory();
    protected abstract virtual AbstractFormattingResult CreateFormattingResult(TokenStream tokenStream);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine/<FormatAsync>d__14")]
public Task`1<AbstractFormattingResult> FormatAsync(CancellationToken cancellationToken);
    protected virtual FormattingContext CreateFormattingContext(TokenStream tokenStream, CancellationToken cancellationToken);
    protected virtual NodeOperations CreateNodeOperationTasks(CancellationToken cancellationToken);
    private List`1<T> AddOperations(List`1<SyntaxNode> nodes, Action`2<List`1<T>, SyntaxNode> addOperations, CancellationToken cancellationToken);
    private Task`1<TokenPairWithOperations[]> CreateTokenOperationTask(TokenStream tokenStream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine/<ApplyTokenOperationsAsync>d__19")]
private Task ApplyTokenOperationsAsync(FormattingContext context, TokenStream tokenStream, Task anchorContextTask, NodeOperations nodeOperations, TokenPairWithOperations[] tokenOperations, CancellationToken cancellationToken);
    private void ApplyBeginningOfTreeTriviaOperation(FormattingContext context, TokenStream tokenStream, CancellationToken cancellationToken);
    private void ApplyEndOfTreeTriviaOperation(FormattingContext context, TokenStream tokenStream, CancellationToken cancellationToken);
    private void ApplyTriviaOperations(FormattingContext context, TokenStream tokenStream, CancellationToken cancellationToken);
    private TextSpan GetSpanToFormat();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine/<ApplySpecialOperationsAsync>d__24")]
private Task ApplySpecialOperationsAsync(FormattingContext context, TokenStream tokenStream, NodeOperations nodeOperationsCollector, OperationApplier applier, CancellationToken cancellationToken);
    private void ApplyAnchorOperations(FormattingContext context, TokenStream tokenStream, TokenPairWithOperations[] tokenOperations, OperationApplier applier, CancellationToken cancellationToken);
    private static bool AnchorOperationCandidate(TokenPairWithOperations pair);
    private SyntaxToken FindCorrectBaseTokenOfRelativeIndentBlockOperation(IndentBlockOperation operation, TokenStream tokenStream);
    private void ApplySpaceAndWrappingOperations(FormattingContext context, TokenStream tokenStream, TokenPairWithOperations[] tokenOperations, OperationApplier applier, CancellationToken cancellationToken);
    private static void ApplySpaceAndWrappingOperationsBody(FormattingContext context, TokenStream tokenStream, TokenPairWithOperations operation, OperationApplier applier, CancellationToken cancellationToken);
    private void BuildContext(FormattingContext context, TokenStream tokenStream, NodeOperations nodeOperations, CancellationToken cancellationToken);
    private string FormatSummary();
}
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractFormattingResult : object {
    protected TreeData TreeInfo;
    protected TokenStream TokenStream;
    protected TaskExecutor TaskExecutor;
    private CancellableLazy`1<IList`1<TextChange>> _lazyChanges;
    private CancellableLazy`1<SyntaxNode> _lazyNode;
    public TextSpan FormattedSpan;
    internal AbstractFormattingResult(TreeData treeInfo, TokenStream tokenStream, TextSpan formattedSpan, TaskExecutor taskExecutor);
    protected abstract virtual SyntaxNode Rewriter(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> map, CancellationToken cancellationToken);
    public sealed virtual IList`1<TextChange> GetTextChanges(CancellationToken cancellationToken);
    public sealed virtual SyntaxNode GetFormattedRoot(CancellationToken cancellationToken);
    private IList`1<TextChange> CreateTextChanges(CancellationToken cancellationToken);
    private void AddTextChanges(List`1<TextChange> list, SyntaxToken token1, SyntaxToken token2, TriviaData data);
    private SyntaxNode CreateFormattedRoot(CancellationToken cancellationToken);
    internal IEnumerable`1<ValueTuple`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData>> GetChanges(CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractFormattingService : object {
    public sealed virtual Task`1<Document> FormatAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet options, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractSyntaxFormattingService : object {
    private static Func`2<TextSpan, bool> s_notEmpty;
    private static Func`2<TextSpan, int> s_spanLength;
    private static AbstractSyntaxFormattingService();
    public abstract virtual IEnumerable`1<IFormattingRule> GetDefaultFormattingRules();
    protected abstract virtual IFormattingResult CreateAggregatedFormattingResult(SyntaxNode node, IList`1<AbstractFormattingResult> results, SimpleIntervalTree`1<TextSpan> formattingSpans);
    protected abstract virtual Task`1<AbstractFormattingResult> FormatAsync(SyntaxNode node, OptionSet options, IEnumerable`1<IFormattingRule> rules, SyntaxToken token1, SyntaxToken token2, CancellationToken cancellationToken);
    public sealed virtual Task`1<IFormattingResult> FormatAsync(SyntaxNode node, IEnumerable`1<TextSpan> spans, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.AbstractSyntaxFormattingService/<FormatMergedSpanAsync>d__7")]
private Task`1<IFormattingResult> FormatMergedSpanAsync(SyntaxNode node, OptionSet options, IEnumerable`1<IFormattingRule> rules, IList`1<TextSpan> spansToFormat, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.AbstractSyntaxFormattingService/<FormatIndividuallyAsync>d__8")]
private Task`1<IFormattingResult> FormatIndividuallyAsync(SyntaxNode node, OptionSet options, IEnumerable`1<IFormattingRule> rules, IList`1<TextSpan> spansToFormat, CancellationToken cancellationToken);
    private bool AllowDisjointSpanMerging(IList`1<TextSpan> list, bool shouldUseFormattingSpanCollapse);
    private static void CheckArguments(SyntaxNode node, IEnumerable`1<TextSpan> spans, OptionSet options, IEnumerable`1<IFormattingRule> rules);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractTriviaDataFactory : object {
    private static int SpaceCacheSize;
    private static int LineBreakCacheSize;
    private static int IndentationLevelCacheSize;
    protected TreeData TreeInfo;
    protected OptionSet OptionSet;
    private Whitespace[] _spaces;
    private Whitespace[0...,0...] _whitespaces;
    protected AbstractTriviaDataFactory(TreeData treeInfo, OptionSet optionSet);
    protected TriviaData GetSpaceTriviaData(int space, bool elastic);
    protected TriviaData GetWhitespaceTriviaData(int lineBreaks, int indentation, bool useTriviaAsItIs, bool elastic);
    private void EnsureWhitespaceTriviaInfo(int lineIndex, int indentationLevel);
    public abstract virtual TriviaData CreateLeadingTrivia(SyntaxToken token);
    public abstract virtual TriviaData CreateTrailingTrivia(SyntaxToken token);
    public abstract virtual TriviaData Create(SyntaxToken token1, SyntaxToken token2);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter : object {
    private static String[] s_spaceCache;
    protected FormattingContext Context;
    protected ChainedFormattingRules FormattingRules;
    protected string OriginalString;
    protected int LineBreaks;
    protected int Spaces;
    protected LineColumn InitialLineColumn;
    protected SyntaxToken Token1;
    protected SyntaxToken Token2;
    private string _language;
    private int _indentation;
    private bool _firstLineBlank;
    protected int StartPosition { get; }
    protected int EndPosition { get; }
    protected TreeData TreeInfo { get; }
    protected OptionSet OptionSet { get; }
    protected string Language { get; }
    protected TokenStream TokenStream { get; }
    private static AbstractTriviaFormatter();
    public AbstractTriviaFormatter(FormattingContext context, ChainedFormattingRules formattingRules, SyntaxToken token1, SyntaxToken token2, string originalString, int lineBreaks, int spaces);
    protected abstract virtual bool Succeeded();
    protected abstract virtual bool IsWhitespace(SyntaxTrivia trivia);
    protected abstract virtual bool IsEndOfLine(SyntaxTrivia trivia);
    protected bool IsNullOrWhitespace(string text);
    protected abstract virtual bool IsWhitespace(char ch);
    protected abstract virtual bool IsNewLine(char ch);
    protected abstract virtual SyntaxTrivia CreateWhitespace(string text);
    protected abstract virtual SyntaxTrivia CreateEndOfLine();
    protected abstract virtual LineColumnRule GetLineColumnRuleBetween(SyntaxTrivia trivia1, LineColumnDelta existingWhitespaceBetween, bool implicitLineBreak, SyntaxTrivia trivia2);
    protected abstract virtual LineColumnDelta Format(LineColumn lineColumn, SyntaxTrivia trivia, List`1<SyntaxTrivia> changes, CancellationToken cancellationToken);
    protected abstract virtual LineColumnDelta Format(LineColumn lineColumn, SyntaxTrivia trivia, List`1<TextChange> changes, CancellationToken cancellationToken);
    protected abstract virtual bool ContainsImplicitLineBreak(SyntaxTrivia trivia);
    protected int get_StartPosition();
    protected int get_EndPosition();
    protected TreeData get_TreeInfo();
    protected OptionSet get_OptionSet();
    protected string get_Language();
    protected TokenStream get_TokenStream();
    public List`1<SyntaxTrivia> FormatToSyntaxTrivia(CancellationToken cancellationToken);
    public List`1<TextChange> FormatToTextChanges(CancellationToken cancellationToken);
    private LineColumn FormatTrivia(Formatter`1<T> formatter, WhitespaceAppender`1<T> whitespaceAdder, List`1<T> changes, CancellationToken cancellationToken);
    private LineColumn FormatFirstTriviaAndWhitespaceAfter(LineColumn lineColumnBeforeTrivia1, SyntaxTrivia trivia1, LineColumnDelta existingWhitespaceBetween, SyntaxTrivia trivia2, Formatter`1<T> format, WhitespaceAppender`1<T> addWhitespaceTrivia, List`1<T> changes, bool implicitLineBreak, CancellationToken cancellationToken);
    private LineColumnRule GetOverallLineColumnRuleBetween(SyntaxTrivia trivia1, LineColumnDelta existingWhitespaceBetween, bool implicitLineBreak, SyntaxTrivia trivia2);
    private void GetTokensAtEdgeOfStructureTrivia(SyntaxTrivia trivia1, SyntaxTrivia trivia2, SyntaxToken& token1, SyntaxToken& token2);
    private bool ContainsOnlyWhitespace(int start, int end);
    private bool FirstLineBlank();
    private LineColumnDelta Apply(LineColumn lineColumnBeforeTrivia1, SyntaxTrivia trivia1, LineColumn lineColumnAfterTrivia1, LineColumnDelta existingWhitespaceBetween, SyntaxTrivia trivia2, LineColumnRule rule);
    private int GetRuleSpacesOrIndentation(LineColumn lineColumnBeforeTrivia1, SyntaxTrivia trivia1, LineColumn lineColumnAfterTrivia1, LineColumnDelta existingWhitespaceBetween, SyntaxTrivia trivia2, LineColumnRule rule);
    private int GetRuleLines(LineColumnRule rule, LineColumn lineColumnAfterTrivia1, LineColumnDelta existingWhitespaceBetween);
    private int GetIndentation();
    private int GetTrailingLinesAtEndOfTrivia1(LineColumn lineColumnAfterTrivia1);
    private void AddExtraLines(int linesBetweenTokens, List`1<SyntaxTrivia> changes);
    private int GetInsertionIndex(List`1<SyntaxTrivia> changes);
    private void AddExtraLines(int linesBetweenTokens, List`1<TextChange> changes);
    private bool TryGetMatchingChangeIndex(List`1<TextChange> changes, Int32& index);
    private TextSpan GetInsertionSpan(List`1<TextChange> changes);
    private void AddWhitespaceTrivia(LineColumn lineColumn, LineColumnDelta delta, List`1<SyntaxTrivia> changes);
    private void AddWhitespaceTrivia(LineColumn lineColumn, LineColumnDelta delta, TextSpan notUsed, List`1<SyntaxTrivia> changes);
    private string GetWhitespaceString(LineColumn lineColumn, LineColumnDelta delta);
    private TextChange GetWhitespaceTextChange(LineColumn lineColumn, LineColumnDelta delta, TextSpan span);
    private void AddWhitespaceTextChange(LineColumn lineColumn, LineColumnDelta delta, TextSpan span, List`1<TextChange> changes);
    private TextSpan GetTextSpan(SyntaxTrivia trivia1, SyntaxTrivia trivia2);
    private bool IsWhitespaceOrEndOfLine(SyntaxTrivia trivia);
    private LineColumnDelta GetLineColumnOfWhitespace(LineColumn lineColumn, SyntaxTrivia previousTrivia, SyntaxTrivia trivia1, LineColumnDelta whitespaceBetween, SyntaxTrivia trivia2);
    private LineColumn GetInitialLineColumn();
    protected LineColumn GetLineColumn(LineColumn lineColumn, SyntaxTrivia trivia);
    protected LineColumnDelta GetLineColumnDelta(LineColumn lineColumn, SyntaxTrivia trivia);
    protected LineColumnDelta GetLineColumnDelta(int initialColumn, string text);
    protected int GetExistingIndentation(SyntaxTrivia trivia);
    private static string GetSpaces(int space);
}
internal class Microsoft.CodeAnalysis.Formatting.ActionCache`1 : object {
    [CompilerGeneratedAttribute]
private Action`5<int, List`1<TArgument>, SyntaxNode, SyntaxToken, NextAction`1<TArgument>> <NextOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`5<int, List`1<TArgument>, SyntaxNode, SyntaxToken, IActionHolder`1<TArgument>> <Continuation>k__BackingField;
    public Action`5<int, List`1<TArgument>, SyntaxNode, SyntaxToken, NextAction`1<TArgument>> NextOperation { get; }
    public Action`5<int, List`1<TArgument>, SyntaxNode, SyntaxToken, IActionHolder`1<TArgument>> Continuation { get; }
    public ActionCache`1(Action`5<int, List`1<TArgument>, SyntaxNode, SyntaxToken, NextAction`1<TArgument>> nextOperation, Action`5<int, List`1<TArgument>, SyntaxNode, SyntaxToken, IActionHolder`1<TArgument>> continuation);
    [CompilerGeneratedAttribute]
public sealed virtual Action`5<int, List`1<TArgument>, SyntaxNode, SyntaxToken, NextAction`1<TArgument>> get_NextOperation();
    [CompilerGeneratedAttribute]
public sealed virtual Action`5<int, List`1<TArgument>, SyntaxNode, SyntaxToken, IActionHolder`1<TArgument>> get_Continuation();
}
internal class Microsoft.CodeAnalysis.Formatting.BottomUpBaseIndentationFinder : object {
    private TokenStream _tokenStream;
    private ChainedFormattingRules _formattingRules;
    private int _tabSize;
    private int _indentationSize;
    private SyntaxToken _lastToken;
    public BottomUpBaseIndentationFinder(ChainedFormattingRules formattingRules, int tabSize, int indentationSize, TokenStream tokenStream, SyntaxToken lastToken);
    public Nullable`1<int> FromIndentBlockOperations(SyntaxTree tree, SyntaxToken token, int position, CancellationToken cancellationToken);
    public Nullable`1<int> FromAlignTokensOperations(SyntaxTree tree, SyntaxToken token);
    public int GetIndentationOfCurrentPosition(SyntaxTree tree, SyntaxToken token, int position, CancellationToken cancellationToken);
    public int GetIndentationOfCurrentPosition(SyntaxTree tree, SyntaxToken token, int position, int extraSpaces, CancellationToken cancellationToken);
    public int GetIndentationOfCurrentPosition(SyntaxNode root, IndentBlockOperation startingOperation, Func`2<SyntaxToken, int> tokenColumnGetter, CancellationToken cancellationToken);
    private int GetIndentationOfCurrentPosition(SyntaxNode root, SyntaxToken token, List`1<IndentBlockOperation> list, int position, int extraSpaces, Func`2<SyntaxToken, int> tokenColumnGetter, CancellationToken cancellationToken);
    private ValueTuple`2<int, IndentBlockOperation> GetIndentationRuleOfCurrentPosition(SyntaxNode root, SyntaxToken token, List`1<IndentBlockOperation> list, int position);
    private List`1<IndentBlockOperation> GetParentIndentBlockOperations(SyntaxToken token);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.BottomUpBaseIndentationFinder/<GetParentNodes>d__14")]
private IEnumerable`1<SyntaxNode> GetParentNodes(SyntaxToken token);
    private SyntaxToken GetAlignmentBaseTokenFor(SyntaxToken token);
    private IndentBlockOperation GetIndentationDataFor(SyntaxNode root, SyntaxToken token, int position);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.BottomUpBaseIndentationFinder/<GetIndentBlockOperationsFromSmallestSpan>d__17")]
private static IEnumerable`1<IndentBlockOperation> GetIndentBlockOperationsFromSmallestSpan(SyntaxNode root, List`1<IndentBlockOperation> list, int position);
}
internal class Microsoft.CodeAnalysis.Formatting.ChainedFormattingRules : object {
    private List`1<IFormattingRule> _formattingRules;
    private OptionSet _optionSet;
    private ActionCache`1<SuppressOperation> _suppressWrappingFuncCache;
    private ActionCache`1<AnchorIndentationOperation> _anchorFuncCache;
    private ActionCache`1<IndentBlockOperation> _indentFuncCache;
    private ActionCache`1<AlignTokensOperation> _alignFuncCache;
    private OperationCache`1<AdjustNewLinesOperation> _newLinesFuncCache;
    private OperationCache`1<AdjustSpacesOperation> _spaceFuncCache;
    public ChainedFormattingRules(IEnumerable`1<IFormattingRule> formattingRules, OptionSet set);
    public void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode currentNode, SyntaxToken lastToken);
    public void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode currentNode, SyntaxToken lastToken);
    public void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode currentNode, SyntaxToken lastToken);
    public void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode currentNode, SyntaxToken lastToken);
    public AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken previousToken, SyntaxToken currentToken);
    public AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken previousToken, SyntaxToken currentToken);
    private void AddContinuedOperations(int index, List`1<TArg1> arg1, SyntaxNode node, SyntaxToken lastToken, IActionHolder`1<TArg1> actionCache);
    private TResult GetContinuedOperations(int index, SyntaxToken token1, SyntaxToken token2, IOperationHolder`1<TResult> funcCache);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_0(int index, List`1<SuppressOperation> list, SyntaxNode node, SyntaxToken lastToken, NextAction`1<SuppressOperation> next);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_1(int index, List`1<AnchorIndentationOperation> list, SyntaxNode node, SyntaxToken lastToken, NextAction`1<AnchorIndentationOperation> next);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_2(int index, List`1<IndentBlockOperation> list, SyntaxNode node, SyntaxToken lastToken, NextAction`1<IndentBlockOperation> next);
    [CompilerGeneratedAttribute]
private void <.ctor>b__8_3(int index, List`1<AlignTokensOperation> list, SyntaxNode node, SyntaxToken lastToken, NextAction`1<AlignTokensOperation> next);
    [CompilerGeneratedAttribute]
private AdjustNewLinesOperation <.ctor>b__8_4(int index, SyntaxToken token1, SyntaxToken token2, NextOperation`1<AdjustNewLinesOperation> next);
    [CompilerGeneratedAttribute]
private AdjustSpacesOperation <.ctor>b__8_5(int index, SyntaxToken token1, SyntaxToken token2, NextOperation`1<AdjustSpacesOperation> next);
}
internal class Microsoft.CodeAnalysis.Formatting.ContextIntervalTree`1 : SimpleIntervalTree`1<T> {
    private Func`4<T, int, int, bool> _edgeExclusivePredicate;
    private Func`4<T, int, int, bool> _edgeInclusivePredicate;
    private Func`4<T, int, int, bool> _containPredicate;
    public ContextIntervalTree`1(IIntervalIntrospector`1<T> introspector);
    public T GetSmallestEdgeExclusivelyContainingInterval(int start, int length);
    public T GetSmallestEdgeInclusivelyContainingInterval(int start, int length);
    public T GetSmallestContainingInterval(int start, int length);
    private bool ContainsEdgeExclusive(T value, int start, int length);
    private bool ContainsEdgeInclusive(T value, int start, int length);
    private T GetSmallestContainingIntervalWorker(int start, int length, Func`4<T, int, int, bool> predicate);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__3_0(T value, int start, int end);
}
public static class Microsoft.CodeAnalysis.Formatting.Formatter : object {
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <Annotation>k__BackingField;
    public static SyntaxAnnotation Annotation { get; }
    private static Formatter();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_Annotation();
    internal static IEnumerable`1<IFormattingRule> GetDefaultFormattingRules(Document document);
    internal static IEnumerable`1<IFormattingRule> GetDefaultFormattingRules(Workspace workspace, string language);
    public static Task`1<Document> FormatAsync(Document document, OptionSet options, CancellationToken cancellationToken);
    public static Task`1<Document> FormatAsync(Document document, TextSpan span, OptionSet options, CancellationToken cancellationToken);
    public static Task`1<Document> FormatAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<FormatAsync>d__8")]
internal static Task`1<Document> FormatAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
    public static Task`1<Document> FormatAsync(Document document, SyntaxAnnotation annotation, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<FormatAsync>d__10")]
internal static Task`1<Document> FormatAsync(Document document, SyntaxAnnotation annotation, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
    public static SyntaxNode Format(SyntaxNode node, SyntaxAnnotation annotation, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static Task`1<SyntaxNode> FormatAsync(SyntaxNode node, SyntaxAnnotation annotation, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static Task`1<SyntaxNode> FormatAsync(SyntaxNode node, SyntaxAnnotation annotation, Workspace workspace, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
    public static SyntaxNode Format(SyntaxNode node, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static Task`1<SyntaxNode> FormatAsync(SyntaxNode node, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    public static SyntaxNode Format(SyntaxNode node, TextSpan span, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static Task`1<SyntaxNode> FormatAsync(SyntaxNode node, TextSpan span, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    public static SyntaxNode Format(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static Task`1<SyntaxNode> FormatAsync(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static SyntaxNode Format(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<FormatAsync>d__21")]
internal static Task`1<SyntaxNode> FormatAsync(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<GetFormattedTextChangesAsync>d__22")]
internal static Task`1<IList`1<TextChange>> GetFormattedTextChangesAsync(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
    internal static Task`1<IFormattingResult> GetFormattingResult(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
    public static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static Task`1<IList`1<TextChange>> GetFormattedTextChangesAsync(SyntaxNode node, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    public static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, TextSpan span, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static Task`1<IList`1<TextChange>> GetFormattedTextChangesAsync(SyntaxNode node, TextSpan span, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    public static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static Task`1<IList`1<TextChange>> GetFormattedTextChangesAsync(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<GetAnnotatedSpans>d__31")]
private static IEnumerable`1<TextSpan> GetAnnotatedSpans(SyntaxNode node, SyntaxAnnotation annotation);
    private static TextSpan GetSpan(SyntaxToken firstToken, SyntaxToken lastToken);
    private static IEnumerable`1<TextSpan> GetElasticSpans(SyntaxNode root);
    private static TextSpan GetElasticSpan(SyntaxToken token);
    private static IEnumerable`1<TextSpan> AggregateSpans(IEnumerable`1<TextSpan> spans);
}
internal class Microsoft.CodeAnalysis.Formatting.FormattingContext : object {
    private AbstractFormatEngine _engine;
    private TokenStream _tokenStream;
    private ContextIntervalTree`1<RelativeIndentationData> _relativeIndentationTree;
    private ContextIntervalTree`1<IndentationData> _indentationTree;
    private ContextIntervalTree`1<SuppressWrappingData> _suppressWrappingTree;
    private ContextIntervalTree`1<SuppressSpacingData> _suppressSpacingTree;
    private ContextIntervalTree`1<AnchorData> _anchorTree;
    private Dictionary`2<SyntaxToken, AnchorData> _anchorBaseTokenMap;
    private HashSet`1<TextSpan> _indentationMap;
    private HashSet`1<TextSpan> _suppressWrappingMap;
    private HashSet`1<TextSpan> _suppressSpacingMap;
    private HashSet`1<TextSpan> _anchorMap;
    private List`1<IndentBlockOperation> _initialIndentBlockOperations;
    private string _language;
    public OptionSet OptionSet { get; }
    public TreeData TreeData { get; }
    public TokenStream TokenStream { get; }
    public FormattingContext(AbstractFormatEngine engine, TokenStream tokenStream, string language);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.FormattingContext.AnchorData>.GetStart(AnchorData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.FormattingContext.AnchorData>.GetLength(AnchorData value);
    public void Initialize(ChainedFormattingRules formattingRules, SyntaxToken startToken, SyntaxToken endToken, CancellationToken cancellationToken);
    public void AddIndentBlockOperations(List`1<IndentBlockOperation> operations, CancellationToken cancellationToken);
    public void AddIndentBlockOperation(IndentBlockOperation operation);
    public void AddInitialSuppressOperation(SuppressOperation operation);
    public void AddSuppressOperations(List`1<SuppressOperation> operations, CancellationToken cancellationToken);
    private void AddSuppressOperation(SuppressOperation operation, bool onSameLine);
    private void AddSpacingSuppressOperation(SuppressOperation operation, bool twoTokensOnSameLine);
    private void AddWrappingSuppressOperation(SuppressOperation operation, bool twoTokensOnSameLine);
    public void AddAnchorIndentationOperation(AnchorIndentationOperation operation);
    [ConditionalAttribute("DEBUG")]
private void DebugCheckEmpty(ContextIntervalTree`1<T> tree, TextSpan textSpan);
    public int GetBaseIndentation(SyntaxToken token);
    public int GetBaseIndentation(int position);
    public IEnumerable`1<IndentBlockOperation> GetAllRelativeIndentBlockOperations();
    public bool TryGetEndTokenForRelativeIndentationSpan(SyntaxToken token, int maxChainDepth, SyntaxToken& endToken, CancellationToken cancellationToken);
    private AnchorData GetAnchorData(SyntaxToken token);
    public int GetAnchorDeltaFromOriginalColumn(SyntaxToken token);
    public SyntaxToken GetAnchorToken(SyntaxToken token);
    public int GetDeltaFromPreviousChangesMap(SyntaxToken token, Dictionary`2<SyntaxToken, int> previousChangesMap);
    public SyntaxToken GetEndTokenForAnchorSpan(TokenData tokenData);
    private AnchorData FindAnchorSpanOnSameLineAfterToken(TokenData tokenData);
    public bool IsWrappingSuppressed(TextSpan textSpan);
    public bool IsSpacingSuppressed(TextSpan textSpan);
    public bool IsSpacingSuppressed(int pairIndex);
    public OptionSet get_OptionSet();
    public TreeData get_TreeData();
    public TokenStream get_TokenStream();
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.FormattingContext.IndentationData>.GetStart(IndentationData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.FormattingContext.IndentationData>.GetLength(IndentationData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.FormattingContext.RelativeIndentationData>.GetStart(RelativeIndentationData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.FormattingContext.RelativeIndentationData>.GetLength(RelativeIndentationData value);
    [CompilerGeneratedAttribute]
private int <Initialize>b__18_1(SyntaxToken t);
    [CompilerGeneratedAttribute]
private void <Initialize>b__18_0(SuppressOperation o);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Formatting.FormattingExtensions : object {
    private static Char[] s_trimChars;
    private static FormattingExtensions();
    [ExtensionAttribute]
public static SyntaxNode GetParentWithBiggerSpan(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<IFormattingRule> Concat(IFormattingRule rule, IEnumerable`1<IFormattingRule> rules);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> list, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static List`1<T> Combine(List`1<T> list1, List`1<T> list2);
    [ExtensionAttribute]
public static bool ContainsElasticTrivia(SuppressOperation operation, TokenStream tokenStream);
    [ExtensionAttribute]
public static bool HasAnyWhitespaceElasticTrivia(SyntaxTriviaList list);
    [ExtensionAttribute]
public static bool IsOn(IndentBlockOption option, IndentBlockOption flag);
    [ExtensionAttribute]
public static bool IsMaskOn(IndentBlockOption option, IndentBlockOption mask);
    [ExtensionAttribute]
public static bool IsOn(SuppressOption option, SuppressOption flag);
    [ExtensionAttribute]
public static bool IsMaskOn(SuppressOption option, SuppressOption mask);
    [ExtensionAttribute]
public static SuppressOption RemoveFlag(SuppressOption option, SuppressOption flag);
    [ExtensionAttribute]
public static string CreateIndentationString(int desiredIndentation, bool useTab, int tabSize);
    [ExtensionAttribute]
public static StringBuilder AppendIndentationString(StringBuilder sb, int desiredIndentation, bool useTab, int tabSize);
    [ExtensionAttribute]
public static void ProcessTextBetweenTokens(string text, TreeData treeInfo, SyntaxToken baseToken, int tabSize, Int32& lineBreaks, Int32& spaceOrIndentation);
    [ExtensionAttribute]
public static string AdjustIndentForXmlDocExteriorTrivia(string triviaText, bool forceIndentation, int indentation, int indentationDelta, bool useTab, int tabSize);
    [ExtensionAttribute]
public static string ReindentStartOfXmlDocumentationComment(string triviaText, bool forceIndentation, int indentation, int indentationDelta, bool useTab, int tabSize, string newLine);
    [ExtensionAttribute]
private static int GetNewIndentationForComments(string line, int nonWhitespaceCharIndex, bool forceIndentation, int indentation, int indentationDelta, int tabSize);
    [ExtensionAttribute]
public static int GetFirstNonWhitespaceIndexInString(string text);
    [ExtensionAttribute]
public static TextChange SimpleDiff(TextChange textChange, string text);
}
public static class Microsoft.CodeAnalysis.Formatting.FormattingOptions : object {
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <UseTabs>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<int> <TabSize>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<int> <IndentationSize>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<IndentStyle> <SmartIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<string> <NewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <InsertFinalNewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <DebugMode>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <AllowDisjointSpanMerging>k__BackingField;
    public static PerLanguageOption`1<bool> UseTabs { get; }
    public static PerLanguageOption`1<int> TabSize { get; }
    public static PerLanguageOption`1<int> IndentationSize { get; }
    public static PerLanguageOption`1<IndentStyle> SmartIndent { get; }
    public static PerLanguageOption`1<string> NewLine { get; }
    internal static Option`1<bool> InsertFinalNewLine { get; }
    internal static PerLanguageOption`1<bool> DebugMode { get; }
    internal static Option`1<bool> AllowDisjointSpanMerging { get; }
    private static FormattingOptions();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_UseTabs();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<int> get_TabSize();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<int> get_IndentationSize();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<IndentStyle> get_SmartIndent();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<string> get_NewLine();
    [CompilerGeneratedAttribute]
internal static Option`1<bool> get_InsertFinalNewLine();
    private static Optional`1<string> ParseEditorConfigEndOfLine(string endOfLineValue);
    [CompilerGeneratedAttribute]
internal static PerLanguageOption`1<bool> get_DebugMode();
    [CompilerGeneratedAttribute]
internal static Option`1<bool> get_AllowDisjointSpanMerging();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Formatting.FormattingOptionsProvider : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
internal interface Microsoft.CodeAnalysis.Formatting.IFormattingResult {
    public abstract virtual IList`1<TextChange> GetTextChanges(CancellationToken cancellationToken);
    public abstract virtual SyntaxNode GetFormattedRoot(CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Formatting.IFormattingService {
    public abstract virtual Task`1<Document> FormatAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet options, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Formatting.ISyntaxFormattingService {
    public abstract virtual IEnumerable`1<IFormattingRule> GetDefaultFormattingRules();
    public abstract virtual Task`1<IFormattingResult> FormatAsync(SyntaxNode node, IEnumerable`1<TextSpan> spans, OptionSet options, IEnumerable`1<IFormattingRule> rules, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Formatting.LineColumn : ValueType {
    public static LineColumn Default;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WhitespaceOnly>k__BackingField;
    public int Line { get; private set; }
    public int Column { get; private set; }
    public bool WhitespaceOnly { get; private set; }
    public LineColumn(int line, int column, bool whitespaceOnly);
    private static LineColumn();
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
private void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
private void set_Column(int value);
    [CompilerGeneratedAttribute]
public bool get_WhitespaceOnly();
    [CompilerGeneratedAttribute]
private void set_WhitespaceOnly(bool value);
    public LineColumn With(LineColumnDelta delta);
}
internal class Microsoft.CodeAnalysis.Formatting.LineColumnDelta : ValueType {
    public static LineColumnDelta Default;
    [CompilerGeneratedAttribute]
private int <Lines>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Spaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WhitespaceOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceUpdate>k__BackingField;
    public int Lines { get; private set; }
    public int Spaces { get; private set; }
    public bool WhitespaceOnly { get; private set; }
    public bool ForceUpdate { get; private set; }
    public LineColumnDelta(int lines, int spaces);
    public LineColumnDelta(int lines, int spaces, bool whitespaceOnly);
    public LineColumnDelta(int lines, int spaces, bool whitespaceOnly, bool forceUpdate);
    private static LineColumnDelta();
    [CompilerGeneratedAttribute]
public int get_Lines();
    [CompilerGeneratedAttribute]
private void set_Lines(int value);
    [CompilerGeneratedAttribute]
public int get_Spaces();
    [CompilerGeneratedAttribute]
private void set_Spaces(int value);
    [CompilerGeneratedAttribute]
public bool get_WhitespaceOnly();
    [CompilerGeneratedAttribute]
private void set_WhitespaceOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForceUpdate();
    [CompilerGeneratedAttribute]
private void set_ForceUpdate(bool value);
    internal LineColumnDelta With(LineColumnDelta delta);
}
internal class Microsoft.CodeAnalysis.Formatting.LineColumnRule : ValueType {
    [CompilerGeneratedAttribute]
private SpaceOperations <SpaceOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private LineOperations <LineOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private IndentationOperations <IndentationOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Lines>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Spaces>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Indentation>k__BackingField;
    public SpaceOperations SpaceOperation { get; private set; }
    public LineOperations LineOperation { get; private set; }
    public IndentationOperations IndentationOperation { get; private set; }
    public int Lines { get; private set; }
    public int Spaces { get; private set; }
    public int Indentation { get; private set; }
    public LineColumnRule With(Nullable`1<int> lines, Nullable`1<int> spaces, Nullable`1<int> indentation, Nullable`1<LineOperations> lineOperation, Nullable`1<SpaceOperations> spaceOperation, Nullable`1<IndentationOperations> indentationOperation);
    [CompilerGeneratedAttribute]
public SpaceOperations get_SpaceOperation();
    [CompilerGeneratedAttribute]
private void set_SpaceOperation(SpaceOperations value);
    [CompilerGeneratedAttribute]
public LineOperations get_LineOperation();
    [CompilerGeneratedAttribute]
private void set_LineOperation(LineOperations value);
    [CompilerGeneratedAttribute]
public IndentationOperations get_IndentationOperation();
    [CompilerGeneratedAttribute]
private void set_IndentationOperation(IndentationOperations value);
    [CompilerGeneratedAttribute]
public int get_Lines();
    [CompilerGeneratedAttribute]
private void set_Lines(int value);
    [CompilerGeneratedAttribute]
public int get_Spaces();
    [CompilerGeneratedAttribute]
private void set_Spaces(int value);
    [CompilerGeneratedAttribute]
public int get_Indentation();
    [CompilerGeneratedAttribute]
private void set_Indentation(int value);
    public static LineColumnRule Preserve();
    public static LineColumnRule PreserveWithGivenSpaces(int spaces);
    public static LineColumnRule PreserveLinesWithDefaultIndentation(int lines);
    public static LineColumnRule PreserveLinesWithGivenIndentation(int lines);
    public static LineColumnRule PreserveLinesWithAbsoluteIndentation(int lines, int indentation);
    public static LineColumnRule PreserveLinesWithFollowingPrecedingIndentation();
    public static LineColumnRule ForceSpaces(int spaces);
    public static LineColumnRule PreserveSpacesOrUseDefaultIndentation(int spaces);
    public static LineColumnRule ForceSpacesOrUseDefaultIndentation(int spaces);
    public static LineColumnRule ForceSpacesOrUseAbsoluteIndentation(int spacesOrIndentation);
}
internal static class Microsoft.CodeAnalysis.Formatting.ListPool`1 : object {
    public static List`1<T> Allocate();
    public static void Free(List`1<T> list);
    public static List`1<T> ReturnAndFree(List`1<T> list);
}
internal class Microsoft.CodeAnalysis.Formatting.NodeOperations : object {
    public static NodeOperations Empty;
    [CompilerGeneratedAttribute]
private Task`1<List`1<IndentBlockOperation>> <IndentBlockOperationTask>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<List`1<SuppressOperation>> <SuppressOperationTask>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<List`1<AlignTokensOperation>> <AlignmentOperationTask>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<List`1<AnchorIndentationOperation>> <AnchorIndentationOperationsTask>k__BackingField;
    public Task`1<List`1<IndentBlockOperation>> IndentBlockOperationTask { get; }
    public Task`1<List`1<SuppressOperation>> SuppressOperationTask { get; }
    public Task`1<List`1<AlignTokensOperation>> AlignmentOperationTask { get; }
    public Task`1<List`1<AnchorIndentationOperation>> AnchorIndentationOperationsTask { get; }
    public NodeOperations(Task`1<List`1<IndentBlockOperation>> indentBlockOperationTask, Task`1<List`1<SuppressOperation>> suppressOperationTask, Task`1<List`1<AnchorIndentationOperation>> anchorIndentationOperationsTask, Task`1<List`1<AlignTokensOperation>> alignmentOperationTask);
    private static NodeOperations();
    [CompilerGeneratedAttribute]
public Task`1<List`1<IndentBlockOperation>> get_IndentBlockOperationTask();
    [CompilerGeneratedAttribute]
public Task`1<List`1<SuppressOperation>> get_SuppressOperationTask();
    [CompilerGeneratedAttribute]
public Task`1<List`1<AlignTokensOperation>> get_AlignmentOperationTask();
    [CompilerGeneratedAttribute]
public Task`1<List`1<AnchorIndentationOperation>> get_AnchorIndentationOperationsTask();
}
internal class Microsoft.CodeAnalysis.Formatting.OperationCache`1 : object {
    [CompilerGeneratedAttribute]
private Func`5<int, SyntaxToken, SyntaxToken, NextOperation`1<TResult>, TResult> <NextOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`5<int, SyntaxToken, SyntaxToken, IOperationHolder`1<TResult>, TResult> <Continuation>k__BackingField;
    public Func`5<int, SyntaxToken, SyntaxToken, NextOperation`1<TResult>, TResult> NextOperation { get; }
    public Func`5<int, SyntaxToken, SyntaxToken, IOperationHolder`1<TResult>, TResult> Continuation { get; }
    public OperationCache`1(Func`5<int, SyntaxToken, SyntaxToken, NextOperation`1<TResult>, TResult> nextOperation, Func`5<int, SyntaxToken, SyntaxToken, IOperationHolder`1<TResult>, TResult> continuation);
    [CompilerGeneratedAttribute]
public sealed virtual Func`5<int, SyntaxToken, SyntaxToken, NextOperation`1<TResult>, TResult> get_NextOperation();
    [CompilerGeneratedAttribute]
public sealed virtual Func`5<int, SyntaxToken, SyntaxToken, IOperationHolder`1<TResult>, TResult> get_Continuation();
}
internal abstract class Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule : object {
    public virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, SyntaxToken lastToken, OptionSet optionSet, NextAction`1<SuppressOperation> nextOperation);
    public virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<AnchorIndentationOperation> nextOperation);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<IndentBlockOperation> nextOperation);
    public virtual void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<AlignTokensOperation> nextOperation);
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet, NextOperation`1<AdjustNewLinesOperation> nextOperation);
    public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet, NextOperation`1<AdjustSpacesOperation> nextOperation);
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOperation : object {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustNewLinesOption <Option>k__BackingField;
    public int Line { get; }
    public AdjustNewLinesOption Option { get; }
    internal AdjustNewLinesOperation(int line, AdjustNewLinesOption option);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public AdjustNewLinesOption get_Option();
}
internal enum Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOption : Enum {
    public int value__;
    public static AdjustNewLinesOption PreserveLines;
    public static AdjustNewLinesOption ForceLines;
    public static AdjustNewLinesOption ForceLinesIfOnSingleLine;
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOperation : object {
    [CompilerGeneratedAttribute]
private int <Space>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustSpacesOption <Option>k__BackingField;
    public int Space { get; }
    public AdjustSpacesOption Option { get; }
    internal AdjustSpacesOperation(int space, AdjustSpacesOption option);
    [CompilerGeneratedAttribute]
public int get_Space();
    [CompilerGeneratedAttribute]
public AdjustSpacesOption get_Option();
}
internal enum Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption : Enum {
    public int value__;
    public static AdjustSpacesOption PreserveSpaces;
    public static AdjustSpacesOption DefaultSpacesIfOnSingleLine;
    public static AdjustSpacesOption ForceSpacesIfOnSingleLine;
    public static AdjustSpacesOption ForceSpaces;
    public static AdjustSpacesOption DynamicSpaceToIndentationIfOnSingleLine;
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation : object {
    [CompilerGeneratedAttribute]
private SyntaxToken <BaseToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SyntaxToken> <Tokens>k__BackingField;
    [CompilerGeneratedAttribute]
private AlignTokensOption <Option>k__BackingField;
    public SyntaxToken BaseToken { get; }
    public IEnumerable`1<SyntaxToken> Tokens { get; }
    public AlignTokensOption Option { get; }
    internal AlignTokensOperation(SyntaxToken baseToken, IEnumerable`1<SyntaxToken> tokens, AlignTokensOption option);
    [CompilerGeneratedAttribute]
public SyntaxToken get_BaseToken();
    [CompilerGeneratedAttribute]
public IEnumerable`1<SyntaxToken> get_Tokens();
    [CompilerGeneratedAttribute]
public AlignTokensOption get_Option();
}
internal enum Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOption : Enum {
    public int value__;
    public static AlignTokensOption AlignIndentationOfTokensToBaseToken;
    public static AlignTokensOption AlignIndentationOfTokensToFirstTokenOfBaseTokenLine;
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation : object {
    [CompilerGeneratedAttribute]
private SyntaxToken <AnchorToken>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <StartToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <EndToken>k__BackingField;
    public SyntaxToken AnchorToken { get; }
    public TextSpan TextSpan { get; }
    public SyntaxToken StartToken { get; }
    public SyntaxToken EndToken { get; }
    internal AnchorIndentationOperation(SyntaxToken anchorToken, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan);
    [CompilerGeneratedAttribute]
public SyntaxToken get_AnchorToken();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public SyntaxToken get_StartToken();
    [CompilerGeneratedAttribute]
public SyntaxToken get_EndToken();
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.BaseIndentationFormattingRule : AbstractFormattingRule {
    private IFormattingRule _vbHelperFormattingRule;
    private int _baseIndentation;
    private SyntaxToken _token1;
    private SyntaxToken _token2;
    private SyntaxNode _commonNode;
    private TextSpan _span;
    public BaseIndentationFormattingRule(SyntaxNode root, TextSpan span, int baseIndentation, IFormattingRule vbHelperFormattingRule);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<IndentBlockOperation> nextOperation);
    private void AddNextIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<IndentBlockOperation> nextOperation);
    private void AdjustIndentBlockOperation(List`1<IndentBlockOperation> list);
    private bool Myself(IndentBlockOperation operation);
    private IndentBlockOperation CloneAndAdjustFormattingOperation(IndentBlockOperation operation);
    private TextSpan AdjustTextSpan(TextSpan textSpan);
    private void SetInnermostNodeForSpan(SyntaxNode root, TextSpan& span, SyntaxToken& token1, SyntaxToken& token2, SyntaxNode& commonNode);
    private static void GetTokens(SyntaxNode root, TextSpan span, SyntaxToken& token1, SyntaxToken& token2);
    private static TextSpan GetSpanFromTokens(TextSpan span, SyntaxToken token1, SyntaxToken token2);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Formatting.Rules.IHostDependentFormattingRuleFactoryService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Formatting.Rules.DefaultFormattingRuleFactoryServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.Formatting.Rules.ExportFormattingRule : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Name { get; }
    public string Language { get; }
    public ExportFormattingRule(string name, string language);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Language();
}
internal static class Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations : object {
    private static AdjustNewLinesOperation s_preserveZeroLine;
    private static AdjustNewLinesOperation s_preserveOneLine;
    private static AdjustNewLinesOperation s_forceOneLine;
    private static AdjustNewLinesOperation s_forceIfSameLine;
    private static AdjustSpacesOperation s_defaultOneSpaceIfOnSingleLine;
    private static AdjustSpacesOperation s_forceOneSpaceIfOnSingleLine;
    private static AdjustSpacesOperation s_forceZeroSpaceIfOnSingleLine;
    private static AdjustSpacesOperation s_forceZeroLineUsingSpaceForce;
    private static FormattingOperations();
    public static AnchorIndentationOperation CreateAnchorIndentationOperation(SyntaxToken startToken, SyntaxToken endToken);
    public static AnchorIndentationOperation CreateAnchorIndentationOperation(SyntaxToken anchorToken, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan);
    public static SuppressOperation CreateSuppressOperation(SyntaxToken startToken, SyntaxToken endToken, SuppressOption option);
    private static SuppressOperation CreateSuppressOperation(SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, SuppressOption option);
    public static IndentBlockOperation CreateIndentBlockOperation(SyntaxToken startToken, SyntaxToken endToken, int indentationDelta, IndentBlockOption option);
    public static IndentBlockOperation CreateIndentBlockOperation(SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, int indentationDelta, IndentBlockOption option);
    public static IndentBlockOperation CreateRelativeIndentBlockOperation(SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, int indentationDelta, IndentBlockOption option);
    public static IndentBlockOperation CreateRelativeIndentBlockOperation(SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, int indentationDelta, IndentBlockOption option);
    public static AlignTokensOperation CreateAlignTokensOperation(SyntaxToken baseToken, IEnumerable`1<SyntaxToken> tokens, AlignTokensOption option);
    public static AdjustNewLinesOperation CreateAdjustNewLinesOperation(int line, AdjustNewLinesOption option);
    public static AdjustSpacesOperation CreateAdjustSpacesOperation(int space, AdjustSpacesOption option);
    internal static IEnumerable`1<SuppressOperation> GetSuppressOperations(IEnumerable`1<IFormattingRule> formattingRules, SyntaxNode node, SyntaxToken lastToken, OptionSet optionSet);
    internal static IEnumerable`1<AnchorIndentationOperation> GetAnchorIndentationOperations(IEnumerable`1<IFormattingRule> formattingRules, SyntaxNode node, SyntaxToken lastToken, OptionSet optionSet);
    internal static IEnumerable`1<IndentBlockOperation> GetIndentBlockOperations(IEnumerable`1<IFormattingRule> formattingRules, SyntaxNode node, SyntaxToken lastToken, OptionSet optionSet);
    internal static IEnumerable`1<AlignTokensOperation> GetAlignTokensOperations(IEnumerable`1<IFormattingRule> formattingRules, SyntaxNode node, SyntaxToken lastToken, OptionSet optionSet);
    internal static AdjustNewLinesOperation GetAdjustNewLinesOperation(IEnumerable`1<IFormattingRule> formattingRules, SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet);
    internal static AdjustSpacesOperation GetAdjustSpacesOperation(IEnumerable`1<IFormattingRule> formattingRules, SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet);
}
internal interface Microsoft.CodeAnalysis.Formatting.Rules.IActionHolder`1 {
    public Action`5<int, List`1<TArgument>, SyntaxNode, SyntaxToken, NextAction`1<TArgument>> NextOperation { get; }
    public Action`5<int, List`1<TArgument>, SyntaxNode, SyntaxToken, IActionHolder`1<TArgument>> Continuation { get; }
    public abstract virtual Action`5<int, List`1<TArgument>, SyntaxNode, SyntaxToken, NextAction`1<TArgument>> get_NextOperation();
    public abstract virtual Action`5<int, List`1<TArgument>, SyntaxNode, SyntaxToken, IActionHolder`1<TArgument>> get_Continuation();
}
internal interface Microsoft.CodeAnalysis.Formatting.Rules.IFormattingRule {
    public abstract virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, SyntaxToken lastToken, OptionSet optionSet, NextAction`1<SuppressOperation> nextOperation);
    public abstract virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<AnchorIndentationOperation> nextOperation);
    public abstract virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<IndentBlockOperation> nextOperation);
    public abstract virtual void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<AlignTokensOperation> nextOperation);
    public abstract virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet, NextOperation`1<AdjustNewLinesOperation> nextOperation);
    public abstract virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet, NextOperation`1<AdjustSpacesOperation> nextOperation);
}
internal interface Microsoft.CodeAnalysis.Formatting.Rules.IHostDependentFormattingRuleFactoryService {
    public abstract virtual bool ShouldNotFormatOrCommitOnPaste(Document document);
    public abstract virtual bool ShouldUseBaseIndentation(Document document);
    public abstract virtual IFormattingRule CreateRule(Document document, int position);
    public abstract virtual IEnumerable`1<TextChange> FilterFormattedChanges(Document document, TextSpan span, IList`1<TextChange> changes);
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation : object {
    [CompilerGeneratedAttribute]
private SyntaxToken <BaseToken>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private IndentBlockOption <Option>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <StartToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <EndToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRelativeIndentation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndentationDeltaOrPosition>k__BackingField;
    public SyntaxToken BaseToken { get; }
    public TextSpan TextSpan { get; }
    public IndentBlockOption Option { get; }
    public SyntaxToken StartToken { get; }
    public SyntaxToken EndToken { get; }
    public bool IsRelativeIndentation { get; }
    public int IndentationDeltaOrPosition { get; }
    internal IndentBlockOperation(SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, int indentationDelta, IndentBlockOption option);
    internal IndentBlockOperation(SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, int indentationDelta, IndentBlockOption option);
    [CompilerGeneratedAttribute]
public SyntaxToken get_BaseToken();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public IndentBlockOption get_Option();
    [CompilerGeneratedAttribute]
public SyntaxToken get_StartToken();
    [CompilerGeneratedAttribute]
public SyntaxToken get_EndToken();
    [CompilerGeneratedAttribute]
public bool get_IsRelativeIndentation();
    [CompilerGeneratedAttribute]
public int get_IndentationDeltaOrPosition();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption : Enum {
    public int value__;
    public static IndentBlockOption RelativeToFirstTokenOnBaseTokenLine;
    public static IndentBlockOption RelativePosition;
    public static IndentBlockOption AbsolutePosition;
    public static IndentBlockOption RelativePositionMask;
    public static IndentBlockOption PositionMask;
}
internal interface Microsoft.CodeAnalysis.Formatting.Rules.IOperationHolder`1 {
    public Func`5<int, SyntaxToken, SyntaxToken, NextOperation`1<TResult>, TResult> NextOperation { get; }
    public Func`5<int, SyntaxToken, SyntaxToken, IOperationHolder`1<TResult>, TResult> Continuation { get; }
    public abstract virtual Func`5<int, SyntaxToken, SyntaxToken, NextOperation`1<TResult>, TResult> get_NextOperation();
    public abstract virtual Func`5<int, SyntaxToken, SyntaxToken, IOperationHolder`1<TResult>, TResult> get_Continuation();
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.NextAction`1 : ValueType {
    private int _index;
    private SyntaxNode _node;
    private SyntaxToken _lastToken;
    private IActionHolder`1<TArgument> _actionCache;
    public NextAction`1(int index, SyntaxNode node, SyntaxToken lastToken, IActionHolder`1<TArgument> actionCache);
    public void Invoke(List`1<TArgument> arguments);
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.NextOperation`1 : ValueType {
    private int _index;
    private SyntaxToken _token1;
    private SyntaxToken _token2;
    private IOperationHolder`1<TResult> _operationCache;
    public NextOperation`1(int index, SyntaxToken token1, SyntaxToken token2, IOperationHolder`1<TResult> operationCache);
    public TResult Invoke();
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.NoOpFormattingRule : object {
    public sealed virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, SyntaxToken lastToken, OptionSet optionSet, NextAction`1<SuppressOperation> nextOperation);
    public sealed virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<AnchorIndentationOperation> nextOperation);
    public sealed virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<IndentBlockOperation> nextOperation);
    public sealed virtual void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode node, OptionSet optionSet, NextAction`1<AlignTokensOperation> nextOperation);
    public sealed virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet, NextOperation`1<AdjustNewLinesOperation> nextOperation);
    public sealed virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken previousToken, SyntaxToken currentToken, OptionSet optionSet, NextOperation`1<AdjustSpacesOperation> nextOperation);
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation : object {
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private SuppressOption <Option>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <StartToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <EndToken>k__BackingField;
    public TextSpan TextSpan { get; }
    public SuppressOption Option { get; }
    public SyntaxToken StartToken { get; }
    public SyntaxToken EndToken { get; }
    internal SuppressOperation(SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, SuppressOption option);
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public SuppressOption get_Option();
    [CompilerGeneratedAttribute]
public SyntaxToken get_StartToken();
    [CompilerGeneratedAttribute]
public SyntaxToken get_EndToken();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption : Enum {
    public int value__;
    public static SuppressOption None;
    public static SuppressOption NoWrappingIfOnSingleLine;
    public static SuppressOption NoWrappingIfOnMultipleLine;
    public static SuppressOption NoWrapping;
    public static SuppressOption NoSpacingIfOnSingleLine;
    public static SuppressOption NoSpacingIfOnMultipleLine;
    public static SuppressOption NoSpacing;
    public static SuppressOption IgnoreElastic;
}
internal static class Microsoft.CodeAnalysis.Formatting.StringBuilderPool : object {
    public static StringBuilder Allocate();
    public static void Free(StringBuilder builder);
    public static string ReturnAndFree(StringBuilder builder);
}
internal class Microsoft.CodeAnalysis.Formatting.SuppressIntervalIntrospector : object {
    public static SuppressIntervalIntrospector Instance;
    private static SuppressIntervalIntrospector();
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.SuppressSpacingData>.GetStart(SuppressSpacingData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.SuppressSpacingData>.GetLength(SuppressSpacingData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.SuppressWrappingData>.GetStart(SuppressWrappingData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.SuppressWrappingData>.GetLength(SuppressWrappingData value);
}
internal class Microsoft.CodeAnalysis.Formatting.SuppressSpacingData : object {
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoSpacing>k__BackingField;
    public TextSpan TextSpan { get; }
    public bool NoSpacing { get; }
    public SuppressSpacingData(TextSpan textSpan, bool noSpacing);
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public bool get_NoSpacing();
}
internal class Microsoft.CodeAnalysis.Formatting.SuppressWrappingData : object {
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoWrapping>k__BackingField;
    public TextSpan TextSpan { get; }
    public bool NoWrapping { get; }
    public SuppressWrappingData(TextSpan textSpan, bool noWrapping);
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public bool get_NoWrapping();
}
internal abstract class Microsoft.CodeAnalysis.Formatting.TaskExecutor : object {
    public static TaskExecutor Concurrent;
    public static TaskExecutor Synchronous;
    private static TaskExecutor();
    public abstract virtual Task`1<T2> ContinueWith(Task`1<T1> previousTask, Func`2<Task`1<T1>, T2> nextAction, CancellationToken cancellationToken);
    public abstract virtual Task ContinueWith(Task`1<T> previousTask, Action`1<Task`1<T>> nextAction, CancellationToken cancellationToken);
    public abstract virtual Task StartNew(Action action, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> StartNew(Func`1<T> action, CancellationToken cancellationToken);
    public abstract virtual void ForEach(IEnumerable`1<T> source, Action`1<T> action, CancellationToken cancellationToken);
    public abstract virtual void For(int fromInclusive, int toExclusive, Action`1<int> body, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<TResult> Filter(IEnumerable`1<TSource> source, Func`2<TSource, bool> filter, Func`2<TSource, TResult> projection, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Formatting.TokenData : ValueType {
    [CompilerGeneratedAttribute]
private TokenStream <TokenStream>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexInStream>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <Token>k__BackingField;
    public TokenStream TokenStream { get; }
    public int IndexInStream { get; }
    public SyntaxToken Token { get; }
    public TokenData(TokenStream tokenStream, int indexInStream, SyntaxToken token);
    [CompilerGeneratedAttribute]
public TokenStream get_TokenStream();
    [CompilerGeneratedAttribute]
public int get_IndexInStream();
    [CompilerGeneratedAttribute]
public SyntaxToken get_Token();
    public TokenData GetPreviousTokenData();
    public TokenData GetNextTokenData();
    public sealed virtual bool Equals(TokenData x, TokenData y);
    public sealed virtual int GetHashCode(TokenData obj);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TokenData other);
    public sealed virtual int Compare(TokenData x, TokenData y);
    public sealed virtual int CompareTo(TokenData other);
    private int Index(IEnumerable`1<SyntaxToken> tokens, SyntaxToken token);
    public static bool op_LessThan(TokenData left, TokenData right);
    public static bool op_GreaterThan(TokenData left, TokenData right);
    public static bool op_Equality(TokenData left, TokenData right);
    public static bool op_Inequality(TokenData left, TokenData right);
}
internal class Microsoft.CodeAnalysis.Formatting.TokenPairWithOperations : ValueType {
    [CompilerGeneratedAttribute]
private TokenStream <TokenStream>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustSpacesOperation <SpaceOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustNewLinesOperation <LineOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PairIndex>k__BackingField;
    public TokenStream TokenStream { get; }
    public AdjustSpacesOperation SpaceOperation { get; }
    public AdjustNewLinesOperation LineOperation { get; }
    public int PairIndex { get; }
    public SyntaxToken Token1 { get; }
    public SyntaxToken Token2 { get; }
    public TokenPairWithOperations(TokenStream tokenStream, int tokenPairIndex, AdjustSpacesOperation spaceOperations, AdjustNewLinesOperation lineOperations);
    [CompilerGeneratedAttribute]
public TokenStream get_TokenStream();
    [CompilerGeneratedAttribute]
public AdjustSpacesOperation get_SpaceOperation();
    [CompilerGeneratedAttribute]
public AdjustNewLinesOperation get_LineOperation();
    [CompilerGeneratedAttribute]
public int get_PairIndex();
    public SyntaxToken get_Token1();
    public SyntaxToken get_Token2();
}
internal class Microsoft.CodeAnalysis.Formatting.TokenStream : object {
    private static int MagicTextLengthToTokensRatio;
    private List`1<SyntaxToken> _tokens;
    private Dictionary`2<SyntaxToken, int> _tokenToIndexMap;
    private TriviaData[] _cachedOriginalTriviaInfo;
    private TreeData _treeData;
    private OptionSet _optionSet;
    private Changes _changes;
    private AbstractTriviaDataFactory _factory;
    private Func`3<TokenData, TokenData, TriviaData> _getTriviaData;
    private Func`3<TokenData, TokenData, TriviaData> _getOriginalTriviaData;
    public bool FormatBeginningOfTree { get; }
    public bool FormatEndOfTree { get; }
    public bool IsFormattingWholeDocument { get; }
    public TokenData FirstTokenInStream { get; }
    public TokenData LastTokenInStream { get; }
    public int TokenCount { get; }
    public IEnumerable`1<ValueTuple`3<int, SyntaxToken, SyntaxToken>> TokenIterator { get; }
    public TokenStream(TreeData treeData, OptionSet optionSet, TextSpan spanToFormat, AbstractTriviaDataFactory factory);
    [ConditionalAttribute("DEBUG")]
private void DebugCheckTokenOrder();
    public bool get_FormatBeginningOfTree();
    public bool get_FormatEndOfTree();
    public bool get_IsFormattingWholeDocument();
    public TokenData get_FirstTokenInStream();
    public TokenData get_LastTokenInStream();
    public int get_TokenCount();
    public SyntaxToken GetToken(int index);
    public TokenData GetTokenData(SyntaxToken token);
    public TokenData GetPreviousTokenData(TokenData tokenData);
    public TokenData GetNextTokenData(TokenData tokenData);
    internal SyntaxToken FirstTokenOfBaseTokenLine(SyntaxToken token);
    public bool TwoTokensOriginallyOnSameLine(SyntaxToken token1, SyntaxToken token2);
    public bool TwoTokensOnSameLine(SyntaxToken token1, SyntaxToken token2);
    private bool TwoTokensOnSameLineWorker(SyntaxToken token1, SyntaxToken token2, Func`3<TokenData, TokenData, TriviaData> triviaDataGetter);
    public void ApplyBeginningOfTreeChange(TriviaData data);
    public void ApplyEndOfTreeChange(TriviaData data);
    public void ApplyChange(int pairIndex, TriviaData data);
    public int GetCurrentColumn(SyntaxToken token);
    public int GetCurrentColumn(TokenData tokenData);
    public int GetOriginalColumn(SyntaxToken token);
    private int GetColumn(TokenData tokenData, Func`3<TokenData, TokenData, TriviaData> triviaDataGetter);
    public void GetTokenLength(SyntaxToken token, Int32& length, Boolean& onMultipleLines);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.TokenStream/<GetTriviaDataWithTokenPair>d__41")]
public IEnumerable`1<ValueTuple`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData>> GetTriviaDataWithTokenPair(CancellationToken cancellationToken);
    public TriviaData GetTriviaData(TokenData token1, TokenData token2);
    private TriviaData GetOriginalTriviaData(TokenData token1, TokenData token2);
    public TriviaData GetTriviaDataAtBeginningOfTree();
    public TriviaData GetTriviaDataAtEndOfTree();
    public TriviaData GetTriviaData(int pairIndex);
    private TriviaData GetOriginalTriviaData(int pairIndex);
    public bool IsFirstTokenOnLine(SyntaxToken token);
    private bool IsFirstTokenOnLine(TokenData tokenData1, TokenData tokenData2);
    private int GetTokenIndexInStream(SyntaxToken token);
    public IEnumerable`1<ValueTuple`3<int, SyntaxToken, SyntaxToken>> get_TokenIterator();
}
internal abstract class Microsoft.CodeAnalysis.Formatting.TreeData : object {
    private SyntaxNode _root;
    private SyntaxToken _firstToken;
    private SyntaxToken _lastToken;
    public SyntaxNode Root { get; }
    public int StartPosition { get; }
    public int EndPosition { get; }
    public TreeData(SyntaxNode root);
    public static TreeData Create(SyntaxNode root);
    public static TreeData Create(SyntaxTrivia trivia, int initialColumn);
    public abstract virtual string GetTextBetween(SyntaxToken token1, SyntaxToken token2);
    public abstract virtual int GetOriginalColumn(int tabSize, SyntaxToken token);
    public SyntaxNode get_Root();
    public bool IsFirstToken(SyntaxToken token);
    public bool IsLastToken(SyntaxToken token);
    public int get_StartPosition();
    public int get_EndPosition();
    public IEnumerable`1<SyntaxToken> GetApplicableTokens(TextSpan textSpan);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.TriviaData : object {
    protected static int TokenPairIndexNotNeeded;
    private OptionSet _optionSet;
    private string _language;
    [CompilerGeneratedAttribute]
private int <LineBreaks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Spaces>k__BackingField;
    protected OptionSet OptionSet { get; }
    protected string Language { get; }
    public int LineBreaks { get; protected set; }
    public int Spaces { get; protected set; }
    public bool SecondTokenIsFirstTokenOnLine { get; }
    public bool TreatAsElastic { get; }
    public bool IsWhitespaceOnlyTrivia { get; }
    public bool ContainsChanges { get; }
    protected TriviaData(OptionSet optionSet, string language);
    protected OptionSet get_OptionSet();
    protected string get_Language();
    [CompilerGeneratedAttribute]
public int get_LineBreaks();
    [CompilerGeneratedAttribute]
protected void set_LineBreaks(int value);
    [CompilerGeneratedAttribute]
public int get_Spaces();
    [CompilerGeneratedAttribute]
protected void set_Spaces(int value);
    public bool get_SecondTokenIsFirstTokenOnLine();
    public abstract virtual bool get_TreatAsElastic();
    public abstract virtual bool get_IsWhitespaceOnlyTrivia();
    public abstract virtual bool get_ContainsChanges();
    public abstract virtual IEnumerable`1<TextChange> GetTextChanges(TextSpan span);
    public abstract virtual TriviaData WithSpace(int space, FormattingContext context, ChainedFormattingRules formattingRules);
    public abstract virtual TriviaData WithLine(int line, int indentation, FormattingContext context, ChainedFormattingRules formattingRules, CancellationToken cancellationToken);
    public abstract virtual TriviaData WithIndentation(int indentation, FormattingContext context, ChainedFormattingRules formattingRules, CancellationToken cancellationToken);
    public abstract virtual void Format(FormattingContext context, ChainedFormattingRules formattingRules, Action`2<int, TriviaData> formattingResultApplier, CancellationToken cancellationToken, int tokenPairIndex);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.TriviaDataWithList : TriviaData {
    public TriviaDataWithList(OptionSet optionSet, string language);
    public abstract virtual List`1<SyntaxTrivia> GetTriviaList(CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Formatting.TriviaList : ValueType {
    private SyntaxTriviaList _list1;
    private SyntaxTriviaList _list2;
    public int Count { get; }
    public TriviaList(SyntaxTriviaList list1, SyntaxTriviaList list2);
    public int get_Count();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<SyntaxTrivia> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal abstract class Microsoft.CodeAnalysis.GeneratedCodeRecognition.AbstractGeneratedCodeRecognitionService : object {
    public sealed virtual bool IsGeneratedCode(Document document, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.GeneratedCodeRecognition.IGeneratedCodeRecognitionService {
    public abstract virtual bool IsGeneratedCode(Document document, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Host.AbstractPersistentStorage : object {
    [CompilerGeneratedAttribute]
private string <WorkingFolderPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SolutionFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseFile>k__BackingField;
    public string WorkingFolderPath { get; }
    public string SolutionFilePath { get; }
    public string DatabaseFile { get; }
    public string DatabaseDirectory { get; }
    protected AbstractPersistentStorage(string workingFolderPath, string solutionFilePath, string databaseFile);
    [CompilerGeneratedAttribute]
public string get_WorkingFolderPath();
    [CompilerGeneratedAttribute]
public string get_SolutionFilePath();
    [CompilerGeneratedAttribute]
public string get_DatabaseFile();
    public string get_DatabaseDirectory();
    public abstract virtual Task`1<Stream> ReadStreamAsync(string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(Project project, string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(Document document, string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(string name, Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(Project project, string name, Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(Document document, string name, Stream stream, CancellationToken cancellationToken);
    public abstract virtual void Dispose();
}
internal abstract class Microsoft.CodeAnalysis.Host.AbstractSyntaxTreeFactoryService : object {
    internal int MinimumLengthForRecoverableTree;
    private bool _hasCachingService;
    [CompilerGeneratedAttribute]
private HostLanguageServices <LanguageServices>k__BackingField;
    internal HostLanguageServices LanguageServices { get; }
    public AbstractSyntaxTreeFactoryService(HostLanguageServices languageServices);
    [CompilerGeneratedAttribute]
internal HostLanguageServices get_LanguageServices();
    public abstract virtual ParseOptions GetDefaultParseOptions();
    public abstract virtual SyntaxTree CreateSyntaxTree(string filePath, ParseOptions options, Encoding encoding, SyntaxNode root);
    public abstract virtual SyntaxTree ParseSyntaxTree(string filePath, ParseOptions options, SourceText text, CancellationToken cancellationToken);
    public abstract virtual SyntaxTree CreateRecoverableTree(ProjectId cacheKey, string filePath, ParseOptions options, ValueSource`1<TextAndVersion> text, Encoding encoding, SyntaxNode root);
    public abstract virtual SyntaxNode DeserializeNodeFrom(Stream stream, CancellationToken cancellationToken);
    public abstract virtual ParseOptions GetDefaultParseOptionsWithLatestLanguageVersion();
    public virtual bool CanCreateRecoverableTree(SyntaxNode root);
    protected static SyntaxNode RecoverNode(SyntaxTree tree, TextSpan textSpan, int kind);
}
internal class Microsoft.CodeAnalysis.Host.CachedWeakValueSource`1 : ValueSource`1<T> {
    private SemaphoreSlim _gateDoNotAccessDirectly;
    private ValueSource`1<T> _source;
    private WeakReference`1<T> _reference;
    private static WeakReference`1<T> s_noReference;
    private SemaphoreSlim Gate { get; }
    public CachedWeakValueSource`1(ValueSource`1<T> source);
    private static CachedWeakValueSource`1();
    private SemaphoreSlim get_Gate();
    public virtual bool TryGetValue(T& value);
    public virtual T GetValue(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Host.CachedWeakValueSource`1/<GetValueAsync>d__9")]
public virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Host.CacheOptions : object {
    internal static Option`1<int> RecoverableTreeLengthThreshold;
    private static CacheOptions();
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.IPersistentStorageLocationService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.DefaultPersistentStorageLocationService : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<PersistentStorageLocationChangingEventArgs> StorageLocationChanging;
    public sealed virtual bool IsSupported(Workspace workspace);
    public sealed virtual string TryGetStorageLocation(SolutionId solutionId);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StorageLocationChanging(EventHandler`1<PersistentStorageLocationChangingEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StorageLocationChanging(EventHandler`1<PersistentStorageLocationChangingEventArgs> value);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.IDocumentationProviderService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.DocumentationProviderServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.IFrameworkAssemblyPathResolver", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.FrameworkAssemblyPathResolverFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.IProjectTypeLookupService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.HostContext.ProjectTypeLookupService : object {
    private static string CSharpProjectType;
    private static string VisualBasicProjectType;
    public sealed virtual string GetProjectType(Workspace workspace, ProjectId projectId);
}
public abstract class Microsoft.CodeAnalysis.Host.HostLanguageServices : object {
    public HostWorkspaceServices WorkspaceServices { get; }
    public string Language { get; }
    internal ICompilationFactoryService CompilationFactory { get; }
    internal ISyntaxTreeFactoryService SyntaxTreeFactory { get; }
    public abstract virtual HostWorkspaceServices get_WorkspaceServices();
    public abstract virtual string get_Language();
    public abstract virtual TLanguageService GetService();
    public TLanguageService GetRequiredService();
    internal virtual ICompilationFactoryService get_CompilationFactory();
    internal virtual ISyntaxTreeFactoryService get_SyntaxTreeFactory();
}
public abstract class Microsoft.CodeAnalysis.Host.HostServices : object {
    protected internal abstract virtual HostWorkspaceServices CreateWorkspaceServices(Workspace workspace);
}
public abstract class Microsoft.CodeAnalysis.Host.HostWorkspaceServices : object {
    public HostServices HostServices { get; }
    public Workspace Workspace { get; }
    public IPersistentStorageService PersistentStorage { get; }
    public ITemporaryStorageService TemporaryStorage { get; }
    internal ITextFactoryService TextFactory { get; }
    public IEnumerable`1<string> SupportedLanguages { get; }
    public abstract virtual HostServices get_HostServices();
    public abstract virtual Workspace get_Workspace();
    public abstract virtual TWorkspaceService GetService();
    public TWorkspaceService GetRequiredService();
    public virtual IPersistentStorageService get_PersistentStorage();
    public virtual ITemporaryStorageService get_TemporaryStorage();
    internal virtual ITextFactoryService get_TextFactory();
    public virtual IEnumerable`1<string> get_SupportedLanguages();
    public virtual bool IsSupported(string languageName);
    public virtual HostLanguageServices GetLanguageServices(string languageName);
    public abstract virtual IEnumerable`1<TLanguageService> FindLanguageServices(MetadataFilter filter);
}
public interface Microsoft.CodeAnalysis.Host.IAnalyzerService {
    public abstract virtual IAnalyzerAssemblyLoader GetLoader();
}
internal interface Microsoft.CodeAnalysis.Host.ICachedObjectOwner {
    public object CachedObject { get; public set; }
    public abstract virtual object get_CachedObject();
    public abstract virtual void set_CachedObject(object value);
}
internal interface Microsoft.CodeAnalysis.Host.ICommandLineParserService {
    public abstract virtual CommandLineArguments Parse(IEnumerable`1<string> arguments, string baseDirectory, bool isInteractive, string sdkDirectory);
}
internal interface Microsoft.CodeAnalysis.Host.ICompilationFactoryService {
    public abstract virtual Compilation CreateCompilation(string assemblyName, CompilationOptions options);
    public abstract virtual Compilation CreateSubmissionCompilation(string assemblyName, CompilationOptions options, Type hostObjectType);
    public abstract virtual Compilation GetCompilationFromCompilationReference(MetadataReference reference);
    public abstract virtual bool IsCompilationReference(MetadataReference reference);
    public abstract virtual CompilationOptions GetDefaultCompilationOptions();
}
internal interface Microsoft.CodeAnalysis.Host.IDocumentationProviderService {
    public abstract virtual DocumentationProvider GetDocumentationProvider(string assemblyFullPath);
}
internal interface Microsoft.CodeAnalysis.Host.IFrameworkAssemblyPathResolver {
    public abstract virtual string ResolveAssemblyPath(ProjectId projectId, string assemblyName, string fullyQualifiedName);
}
public interface Microsoft.CodeAnalysis.Host.ILanguageService {
}
internal interface Microsoft.CodeAnalysis.Host.IMetadataService {
    public abstract virtual PortableExecutableReference GetReference(string resolvedPath, MetadataReferenceProperties properties);
}
internal interface Microsoft.CodeAnalysis.Host.IParseOptionsService {
    public abstract virtual string GetLanguageVersion(ParseOptions options);
    public abstract virtual ParseOptions WithLanguageVersion(ParseOptions old, string version);
}
public interface Microsoft.CodeAnalysis.Host.IPersistentStorage {
    public abstract virtual Task`1<Stream> ReadStreamAsync(string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(Project project, string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(Document document, string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(string name, Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(Project project, string name, Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(Document document, string name, Stream stream, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.IPersistentStorageFaultInjector {
    public abstract virtual void OnNewConnection();
    public abstract virtual void OnFatalError(Exception ex);
}
internal interface Microsoft.CodeAnalysis.Host.IPersistentStorageLocationService {
    public abstract virtual bool IsSupported(Workspace workspace);
    public abstract virtual string TryGetStorageLocation(SolutionId solutionId);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StorageLocationChanging(EventHandler`1<PersistentStorageLocationChangingEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StorageLocationChanging(EventHandler`1<PersistentStorageLocationChangingEventArgs> value);
}
public interface Microsoft.CodeAnalysis.Host.IPersistentStorageService {
    public abstract virtual IPersistentStorage GetStorage(Solution solution);
}
internal interface Microsoft.CodeAnalysis.Host.IPersistentStorageService2 {
    public abstract virtual IPersistentStorage GetStorage(Solution solution, bool checkBranchId);
}
internal interface Microsoft.CodeAnalysis.Host.IProjectCacheHostService {
    public abstract virtual T CacheObjectIfCachingEnabledForKey(ProjectId key, object owner, T instance);
    public abstract virtual T CacheObjectIfCachingEnabledForKey(ProjectId key, ICachedObjectOwner owner, T instance);
}
internal interface Microsoft.CodeAnalysis.Host.IProjectCacheService {
    public abstract virtual IDisposable EnableCaching(ProjectId key);
}
internal interface Microsoft.CodeAnalysis.Host.IProjectTypeLookupService {
    public abstract virtual string GetProjectType(Workspace workspace, ProjectId projectId);
}
internal interface Microsoft.CodeAnalysis.Host.IRecoverableSyntaxTree`1 {
    public abstract virtual TRoot CloneNodeAsRoot(TRoot root);
}
internal interface Microsoft.CodeAnalysis.Host.ISupportDirectMemoryAccess {
    public abstract virtual IntPtr GetPointer();
}
internal interface Microsoft.CodeAnalysis.Host.ISyntaxTreeFactoryService {
    public abstract virtual ParseOptions GetDefaultParseOptions();
    public abstract virtual ParseOptions GetDefaultParseOptionsWithLatestLanguageVersion();
    public abstract virtual SyntaxTree CreateSyntaxTree(string filePath, ParseOptions options, Encoding encoding, SyntaxNode root);
    public abstract virtual SyntaxTree ParseSyntaxTree(string filePath, ParseOptions options, SourceText text, CancellationToken cancellationToken);
    public abstract virtual bool CanCreateRecoverableTree(SyntaxNode root);
    public abstract virtual SyntaxTree CreateRecoverableTree(ProjectId cacheKey, string filePath, ParseOptions options, ValueSource`1<TextAndVersion> text, Encoding encoding, SyntaxNode root);
    public abstract virtual SyntaxNode DeserializeNodeFrom(Stream stream, CancellationToken cancellationToken);
}
public interface Microsoft.CodeAnalysis.Host.ITemporaryStorageService {
    public abstract virtual ITemporaryStreamStorage CreateTemporaryStreamStorage(CancellationToken cancellationToken);
    public abstract virtual ITemporaryTextStorage CreateTemporaryTextStorage(CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.ITemporaryStorageService2 {
    public abstract virtual ITemporaryStreamStorage AttachTemporaryStreamStorage(string storageName, long offset, long size, CancellationToken cancellationToken);
    public abstract virtual ITemporaryTextStorage AttachTemporaryTextStorage(string storageName, long offset, long size, Encoding encoding, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.ITemporaryStorageWithName {
    public string Name { get; }
    public long Offset { get; }
    public long Size { get; }
    public abstract virtual string get_Name();
    public abstract virtual long get_Offset();
    public abstract virtual long get_Size();
}
public interface Microsoft.CodeAnalysis.Host.ITemporaryStreamStorage {
    public abstract virtual Stream ReadStream(CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(CancellationToken cancellationToken);
    public abstract virtual void WriteStream(Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task WriteStreamAsync(Stream stream, CancellationToken cancellationToken);
}
public interface Microsoft.CodeAnalysis.Host.ITemporaryTextStorage {
    public abstract virtual SourceText ReadText(CancellationToken cancellationToken);
    public abstract virtual Task`1<SourceText> ReadTextAsync(CancellationToken cancellationToken);
    public abstract virtual void WriteText(SourceText text, CancellationToken cancellationToken);
    public abstract virtual Task WriteTextAsync(SourceText text, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.ITextFactoryService {
    public abstract virtual SourceText CreateText(Stream stream, Encoding defaultEncoding, CancellationToken cancellationToken);
    public abstract virtual SourceText CreateText(TextReader reader, Encoding encoding, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.IWorkspaceCacheService {
    [CompilerGeneratedAttribute]
public abstract virtual void add_CacheFlushRequested(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CacheFlushRequested(EventHandler value);
}
public interface Microsoft.CodeAnalysis.Host.IWorkspaceService {
}
internal interface Microsoft.CodeAnalysis.Host.IWorkspaceTaskScheduler {
    public abstract virtual Task ScheduleTask(Action taskAction, string taskName, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> ScheduleTask(Func`1<T> taskFunc, string taskName, CancellationToken cancellationToken);
    public abstract virtual Task ScheduleTask(Func`1<Task> taskFunc, string taskName, CancellationToken cancellationToken);
    public abstract virtual Task`1<T> ScheduleTask(Func`1<Task`1<T>> taskFunc, string taskName, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.IWorkspaceTaskSchedulerFactory {
    public abstract virtual IWorkspaceTaskScheduler CreateBackgroundTaskScheduler();
    public abstract virtual IWorkspaceTaskScheduler CreateEventingTaskQueue();
}
internal class Microsoft.CodeAnalysis.Host.Mef.CodeChangeProviderMetadata : OrderableMetadata {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Languages>k__BackingField;
    public IEnumerable`1<string> Languages { get; }
    public CodeChangeProviderMetadata(IDictionary`2<string, object> data);
    public CodeChangeProviderMetadata(string name, IEnumerable`1<string> after, IEnumerable`1<string> before, String[] languages);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_Languages();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    public string ServiceType { get; }
    public string Language { get; }
    public string Layer { get; }
    public ExportLanguageServiceAttribute(Type type, string language, string layer);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public string get_Layer();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    public string ServiceType { get; }
    public string Language { get; }
    public string Layer { get; }
    public ExportLanguageServiceFactoryAttribute(Type type, string language, string layer);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public string get_Layer();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    public string ServiceType { get; }
    public string Layer { get; }
    public ExportWorkspaceServiceAttribute(Type serviceType, string layer);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Layer();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    public string ServiceType { get; }
    public string Layer { get; }
    public ExportWorkspaceServiceFactoryAttribute(Type serviceType, string layer);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Layer();
}
internal interface Microsoft.CodeAnalysis.Host.Mef.ILanguageMetadata {
    public string Language { get; }
    public abstract virtual string get_Language();
}
public interface Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory {
    public abstract virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
internal interface Microsoft.CodeAnalysis.Host.Mef.ILanguagesMetadata {
    public IEnumerable`1<string> Languages { get; }
    public abstract virtual IEnumerable`1<string> get_Languages();
}
internal interface Microsoft.CodeAnalysis.Host.Mef.IMefHostExportProvider {
    public abstract virtual IEnumerable`1<Lazy`2<TExtension, TMetadata>> GetExports();
    public abstract virtual IEnumerable`1<Lazy`1<TExtension>> GetExports();
}
public interface Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory {
    public abstract virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal class Microsoft.CodeAnalysis.Host.Mef.LanguageMetadata : object {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; }
    public LanguageMetadata(IDictionary`2<string, object> data);
    public LanguageMetadata(string language);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
}
internal class Microsoft.CodeAnalysis.Host.Mef.LanguageServiceMetadata : LanguageMetadata {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Data>k__BackingField;
    public string ServiceType { get; }
    public string Layer { get; }
    public IReadOnlyDictionary`2<string, object> Data { get; }
    public LanguageServiceMetadata(IDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Layer();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Data();
}
internal static class Microsoft.CodeAnalysis.Host.Mef.MefConstruction : object {
    internal static string ImportingConstructorMessage;
    internal static string FactoryMethodMessage;
}
public class Microsoft.CodeAnalysis.Host.Mef.MefHostServices : HostServices {
    private static CreationHook s_CreationHook;
    private CompositionContext _compositionContext;
    private static MefHostServices s_defaultHost;
    private static ImmutableArray`1<Assembly> s_defaultAssemblies;
    public static MefHostServices DefaultHost { get; }
    public static ImmutableArray`1<Assembly> DefaultAssemblies { get; }
    public MefHostServices(CompositionContext compositionContext);
    public static MefHostServices Create(CompositionContext compositionContext);
    public static MefHostServices Create(IEnumerable`1<Assembly> assemblies);
    protected internal virtual HostWorkspaceServices CreateWorkspaceServices(Workspace workspace);
    private sealed virtual override IEnumerable`1<Lazy`1<TExtension>> Microsoft.CodeAnalysis.Host.Mef.IMefHostExportProvider.GetExports();
    private sealed virtual override IEnumerable`1<Lazy`2<TExtension, TMetadata>> Microsoft.CodeAnalysis.Host.Mef.IMefHostExportProvider.GetExports();
    internal static void HookServiceCreation(CreationHook hook);
    public static MefHostServices get_DefaultHost();
    public static ImmutableArray`1<Assembly> get_DefaultAssemblies();
    private static ImmutableArray`1<Assembly> LoadDefaultAssemblies();
    internal static ImmutableArray`1<Assembly> LoadNearbyAssemblies(String[] assemblyNames);
    private static Assembly TryLoadNearbyAssembly(string assemblySimpleName);
}
internal class Microsoft.CodeAnalysis.Host.Mef.MefLanguageServices : HostLanguageServices {
    private MefWorkspaceServices _workspaceServices;
    private string _language;
    private ImmutableArray`1<Lazy`2<ILanguageService, LanguageServiceMetadata>> _services;
    private ImmutableDictionary`2<Type, Lazy`2<ILanguageService, LanguageServiceMetadata>> _serviceMap;
    public HostWorkspaceServices WorkspaceServices { get; }
    public string Language { get; }
    public bool HasServices { get; }
    public MefLanguageServices(MefWorkspaceServices workspaceServices, string language);
    public virtual HostWorkspaceServices get_WorkspaceServices();
    public virtual string get_Language();
    public bool get_HasServices();
    public virtual TLanguageService GetService();
    internal bool TryGetService(Type serviceType, Lazy`2& service);
    private Lazy`2<ILanguageService, LanguageServiceMetadata> PickLanguageService(IEnumerable`1<Lazy`2<ILanguageService, LanguageServiceMetadata>> services);
    private static bool TryGetServiceByLayer(string layer, IEnumerable`1<Lazy`2<ILanguageService, LanguageServiceMetadata>> services, Lazy`2& service);
    [CompilerGeneratedAttribute]
private Lazy`2<ILanguageService, LanguageServiceMetadata> <TryGetService>b__12_0(Type svctype);
}
internal class Microsoft.CodeAnalysis.Host.Mef.MefWorkspaceServices : HostWorkspaceServices {
    private IMefHostExportProvider _exportProvider;
    private Workspace _workspace;
    private ImmutableArray`1<Lazy`2<IWorkspaceService, WorkspaceServiceMetadata>> _services;
    private ImmutableDictionary`2<Type, Lazy`2<IWorkspaceService, WorkspaceServiceMetadata>> _serviceMap;
    private ImmutableDictionary`2<string, MefLanguageServices> _languageServicesMap;
    private IEnumerable`1<string> _languages;
    public HostServices HostServices { get; }
    internal IMefHostExportProvider HostExportProvider { get; }
    public Workspace Workspace { get; }
    public IEnumerable`1<string> SupportedLanguages { get; }
    public MefWorkspaceServices(IMefHostExportProvider host, Workspace workspace);
    public virtual HostServices get_HostServices();
    internal IMefHostExportProvider get_HostExportProvider();
    public virtual Workspace get_Workspace();
    public virtual TWorkspaceService GetService();
    private bool TryGetService(Type serviceType, Lazy`2& service);
    private Lazy`2<IWorkspaceService, WorkspaceServiceMetadata> PickWorkspaceService(IEnumerable`1<Lazy`2<IWorkspaceService, WorkspaceServiceMetadata>> services);
    private static bool TryGetServiceByLayer(string layer, IEnumerable`1<Lazy`2<IWorkspaceService, WorkspaceServiceMetadata>> services, Lazy`2& service);
    private IEnumerable`1<string> GetSupportedLanguages();
    public virtual IEnumerable`1<string> get_SupportedLanguages();
    public virtual bool IsSupported(string languageName);
    public virtual HostLanguageServices GetLanguageServices(string languageName);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Host.Mef.MefWorkspaceServices/<FindLanguageServices>d__22`1")]
public virtual IEnumerable`1<TLanguageService> FindLanguageServices(MetadataFilter filter);
    internal bool TryGetLanguageServices(string languageName, MefLanguageServices& languageServices);
    [CompilerGeneratedAttribute]
private Lazy`2<IWorkspaceService, WorkspaceServiceMetadata> <.ctor>b__5_0(Lazy`2<IWorkspaceServiceFactory, WorkspaceServiceMetadata> lz);
    [CompilerGeneratedAttribute]
private Lazy`2<IWorkspaceService, WorkspaceServiceMetadata> <TryGetService>b__13_0(Type svctype);
}
internal class Microsoft.CodeAnalysis.Host.Mef.OrderableLanguageMetadata : OrderableMetadata {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; }
    public OrderableLanguageMetadata(IDictionary`2<string, object> data);
    public OrderableLanguageMetadata(string name, string language, IEnumerable`1<string> after, IEnumerable`1<string> before);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
}
public static class Microsoft.CodeAnalysis.Host.Mef.ServiceLayer : object {
    public static string Host;
    public static string Editor;
    public static string Desktop;
    public static string Default;
}
internal class Microsoft.CodeAnalysis.Host.Mef.WorkspaceServiceMetadata : object {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    public string ServiceType { get; }
    public string Layer { get; }
    public WorkspaceServiceMetadata(Type serviceType, string layer);
    public WorkspaceServiceMetadata(IDictionary`2<string, object> data);
    public WorkspaceServiceMetadata(string serviceType, string layer);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Layer();
}
internal class Microsoft.CodeAnalysis.Host.MetadataReferenceCache : object {
    private ImmutableDictionary`2<string, ReferenceSet> _referenceSets;
    private Func`3<string, MetadataReferenceProperties, MetadataReference> _createReference;
    public MetadataReferenceCache(Func`3<string, MetadataReferenceProperties, MetadataReference> createReference);
    public MetadataReference GetReference(string path, MetadataReferenceProperties properties);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.IMetadataService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.MetadataServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal class Microsoft.CodeAnalysis.Host.NoOpPersistentStorage : object {
    public static IPersistentStorage Instance;
    private static NoOpPersistentStorage();
    public sealed virtual void Dispose();
    public sealed virtual Task`1<Stream> ReadStreamAsync(Document document, string name, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(Project project, string name, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(string name, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(Document document, string name, Stream stream, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(Project project, string name, Stream stream, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(string name, Stream stream, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Host.NoOpPersistentStorageService : object {
    public static IPersistentStorageService Instance;
    private static NoOpPersistentStorageService();
    public sealed virtual IPersistentStorage GetStorage(Solution solution);
    public sealed virtual IPersistentStorage GetStorage(Solution solution, bool checkBranchId);
}
internal class Microsoft.CodeAnalysis.Host.PersistentStorageLocationChangingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private SolutionId <SolutionId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewStorageLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MustUseNewStorageLocationImmediately>k__BackingField;
    public SolutionId SolutionId { get; }
    public string NewStorageLocation { get; }
    public bool MustUseNewStorageLocationImmediately { get; }
    public PersistentStorageLocationChangingEventArgs(SolutionId solutionId, string newStorageLocation, bool mustUseNewStorageLocationImmediately);
    [CompilerGeneratedAttribute]
public SolutionId get_SolutionId();
    [CompilerGeneratedAttribute]
public string get_NewStorageLocation();
    [CompilerGeneratedAttribute]
public bool get_MustUseNewStorageLocationImmediately();
}
internal static class Microsoft.CodeAnalysis.Host.PersistentStorageOptions : object {
    public static string OptionName;
    public static Option`1<bool> Enabled;
    private static PersistentStorageOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.PersistentStorageOptionsProvider : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.IPersistentStorageService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.PersistentStorageServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.IProjectCacheService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.ProjectCacheServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal abstract class Microsoft.CodeAnalysis.Host.RecoverableWeakValueSource`1 : ValueSource`1<T> {
    private SemaphoreSlim _gateDoNotAccessDirectly;
    private bool _saved;
    private WeakReference`1<T> _weakInstance;
    private ValueSource`1<T> _recoverySource;
    private static WeakReference`1<T> s_noReference;
    private static Task s_latestTask;
    private static NonReentrantLock s_taskGuard;
    private SemaphoreSlim Gate { get; }
    public RecoverableWeakValueSource`1(ValueSource`1<T> initialValue);
    public RecoverableWeakValueSource`1(RecoverableWeakValueSource`1<T> savedSource);
    private static RecoverableWeakValueSource`1();
    protected abstract virtual Task SaveAsync(T instance, CancellationToken cancellationToken);
    protected abstract virtual Task`1<T> RecoverAsync(CancellationToken cancellationToken);
    protected abstract virtual T Recover(CancellationToken cancellationToken);
    private SemaphoreSlim get_Gate();
    public virtual bool TryGetValue(T& value);
    public virtual T GetValue(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Host.RecoverableWeakValueSource`1/<GetValueAsync>d__16")]
public virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
    private void ResetRecoverySource(Task saveTask, T instance);
    private Task EnsureInstanceIsSaved(T instance);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.ITextFactoryService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.TextFactoryService : object {
    public sealed virtual SourceText CreateText(Stream stream, Encoding defaultEncoding, CancellationToken cancellationToken);
    public sealed virtual SourceText CreateText(TextReader reader, Encoding encoding, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Host.WorkspaceMetadataFileReferenceResolver : MetadataReferenceResolver {
    private IMetadataService _metadataService;
    internal RelativePathResolver PathResolver;
    public WorkspaceMetadataFileReferenceResolver(IMetadataService metadataService, RelativePathResolver pathResolver);
    public virtual ImmutableArray`1<PortableExecutableReference> ResolveReference(string reference, string baseFilePath, MetadataReferenceProperties properties);
    public sealed virtual bool Equals(WorkspaceMetadataFileReferenceResolver other);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.IWorkspaceTaskSchedulerFactory", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.WorkspaceTaskSchedulerFactory : object {
    public virtual IWorkspaceTaskScheduler CreateBackgroundTaskScheduler();
    public virtual IWorkspaceTaskScheduler CreateEventingTaskQueue();
    protected virtual object BeginAsyncOperation(string taskName);
    protected virtual void CompleteAsyncOperation(object asyncToken, Task task);
}
internal interface Microsoft.CodeAnalysis.IChecksummedObject {
    public Checksum Checksum { get; }
    public abstract virtual Checksum get_Checksum();
}
internal interface Microsoft.CodeAnalysis.IDocumentTextDifferencingService {
    public abstract virtual Task`1<ImmutableArray`1<TextChange>> GetTextChangesAsync(Document oldDocument, Document newDocument, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.ILinkedFileMergeConflictCommentAdditionService {
}
internal interface Microsoft.CodeAnalysis.IMergeConflictHandler {
    public abstract virtual IEnumerable`1<TextChange> CreateEdits(SourceText originalSourceText, IEnumerable`1<UnmergedDocumentChanges> unmergedChanges);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutable(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrEmpty(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrNull(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutable(T[] items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrNull(T[] items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrEmpty(T[] items);
    [ExtensionAttribute]
public static ImmutableArray`1<byte> ToImmutable(MemoryStream stream);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`2<TItem, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`3<TItem, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`4<TItem, int, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> ZipAsArray(ImmutableArray`1<T1> self, ImmutableArray`1<T2> other, Func`3<T1, T2, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<T> WhereAsArray(ImmutableArray`1<T> array, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static ImmutableArray`1<TBase> Cast(ImmutableArray`1<TDerived> items);
    [ExtensionAttribute]
public static bool SetEquals(ImmutableArray`1<T> array1, ImmutableArray`1<T> array2, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static ImmutableArray`1<T> NullToEmpty(ImmutableArray`1<T> array);
    [ExtensionAttribute]
public static ImmutableArray`1<T> Distinct(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool HasAnyErrors(ImmutableArray`1<T> diagnostics);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> DeOrder(ImmutableArray`1<T> array);
    [ExtensionAttribute]
internal static ImmutableArray`1<TValue> Flatten(Dictionary`2<TKey, ImmutableArray`1<TValue>> dictionary, IComparer`1<TValue> comparer);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, T second);
    [ExtensionAttribute]
internal static bool HasDuplicates(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int Count(ImmutableArray`1<T> items, Func`2<T, bool> predicate);
    [ExtensionAttribute]
internal static Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(ImmutableArray`1<T> items, Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
}
internal class Microsoft.CodeAnalysis.Internal.Log.AggregateLogger : object {
    private ImmutableArray`1<ILogger> _loggers;
    private AggregateLogger(ImmutableArray`1<ILogger> loggers);
    public static AggregateLogger Create(ILogger[] loggers);
    public static ILogger AddOrReplace(ILogger newLogger, ILogger oldLogger, Func`2<ILogger, bool> predicate);
    public static ILogger Remove(ILogger logger, Func`2<ILogger, bool> predicate);
    public sealed virtual bool IsEnabled(FunctionId functionId);
    public sealed virtual void Log(FunctionId functionId, LogMessage logMessage);
    public sealed virtual void LogBlockStart(FunctionId functionId, LogMessage logMessage, int uniquePairId, CancellationToken cancellationToken);
    public sealed virtual void LogBlockEnd(FunctionId functionId, LogMessage logMessage, int uniquePairId, int delta, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Internal.Log.EmptyLogBlock : object {
    public static EmptyLogBlock Instance;
    private static EmptyLogBlock();
    public sealed virtual void Dispose();
}
internal class Microsoft.CodeAnalysis.Internal.Log.EmptyLogger : object {
    public static EmptyLogger Instance;
    private static EmptyLogger();
    public sealed virtual bool IsEnabled(FunctionId functionId);
    public sealed virtual void Log(FunctionId functionId, LogMessage logMessage);
    public sealed virtual void LogBlockStart(FunctionId functionId, LogMessage logMessage, int uniquePairId, CancellationToken cancellationToken);
    public sealed virtual void LogBlockEnd(FunctionId functionId, LogMessage logMessage, int uniquePairId, int delta, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.Internal.Log.FunctionId : Enum {
    public int value__;
    public static FunctionId TestEvent_NotUsed;
    public static FunctionId WorkCoordinator_DocumentWorker_Enqueue;
    public static FunctionId WorkCoordinator_ProcessProjectAsync;
    public static FunctionId WorkCoordinator_ProcessDocumentAsync;
    public static FunctionId WorkCoordinator_SemanticChange_Enqueue;
    public static FunctionId WorkCoordinator_SemanticChange_EnqueueFromMember;
    public static FunctionId WorkCoordinator_SemanticChange_EnqueueFromType;
    public static FunctionId WorkCoordinator_SemanticChange_FullProjects;
    public static FunctionId WorkCoordinator_Project_Enqueue;
    public static FunctionId WorkCoordinator_AsyncWorkItemQueue_LastItem;
    public static FunctionId WorkCoordinator_AsyncWorkItemQueue_FirstItem;
    public static FunctionId Diagnostics_SyntaxDiagnostic;
    public static FunctionId Diagnostics_SemanticDiagnostic;
    public static FunctionId Diagnostics_ProjectDiagnostic;
    public static FunctionId Diagnostics_DocumentReset;
    public static FunctionId Diagnostics_DocumentOpen;
    public static FunctionId Diagnostics_RemoveDocument;
    public static FunctionId Diagnostics_RemoveProject;
    public static FunctionId Diagnostics_DocumentClose;
    public static FunctionId Run_Environment;
    public static FunctionId Run_Environment_Options;
    public static FunctionId Tagger_AdornmentManager_OnLayoutChanged;
    public static FunctionId Tagger_AdornmentManager_UpdateInvalidSpans;
    public static FunctionId Tagger_BatchChangeNotifier_NotifyEditorNow;
    public static FunctionId Tagger_BatchChangeNotifier_NotifyEditor;
    public static FunctionId Tagger_TagSource_RecomputeTags;
    public static FunctionId Tagger_TagSource_ProcessNewTags;
    public static FunctionId Tagger_SyntacticClassification_TagComputer_GetTags;
    public static FunctionId Tagger_SemanticClassification_TagProducer_ProduceTags;
    public static FunctionId Tagger_BraceHighlighting_TagProducer_ProduceTags;
    public static FunctionId Tagger_LineSeparator_TagProducer_ProduceTags;
    public static FunctionId Tagger_Outlining_TagProducer_ProduceTags;
    public static FunctionId Tagger_Highlighter_TagProducer_ProduceTags;
    public static FunctionId Tagger_ReferenceHighlighting_TagProducer_ProduceTags;
    public static FunctionId CaseCorrection_CaseCorrect;
    public static FunctionId CaseCorrection_ReplaceTokens;
    public static FunctionId CaseCorrection_AddReplacements;
    public static FunctionId CodeCleanup_CleanupAsync;
    public static FunctionId CodeCleanup_Cleanup;
    public static FunctionId CodeCleanup_IterateAllCodeCleanupProviders;
    public static FunctionId CodeCleanup_IterateOneCodeCleanup;
    public static FunctionId CommandHandler_GetCommandState;
    public static FunctionId CommandHandler_ExecuteHandlers;
    public static FunctionId CommandHandler_FormatCommand;
    public static FunctionId Workspace_SourceText_GetChangeRanges;
    public static FunctionId Workspace_Recoverable_RecoverRootAsync;
    public static FunctionId Workspace_Recoverable_RecoverRoot;
    public static FunctionId Workspace_Recoverable_RecoverTextAsync;
    public static FunctionId Workspace_Recoverable_RecoverText;
    public static FunctionId Workspace_SkeletonAssembly_GetMetadataOnlyImage;
    public static FunctionId Workspace_SkeletonAssembly_EmitMetadataOnlyImage;
    public static FunctionId Workspace_Document_State_FullyParseSyntaxTree;
    public static FunctionId Workspace_Document_State_IncrementallyParseSyntaxTree;
    public static FunctionId Workspace_Document_GetSemanticModel;
    public static FunctionId Workspace_Document_GetSyntaxTree;
    public static FunctionId Workspace_Document_GetTextChanges;
    public static FunctionId Workspace_Project_GetCompilation;
    public static FunctionId Workspace_Project_CompilationTracker_BuildCompilationAsync;
    public static FunctionId Workspace_ApplyChanges;
    public static FunctionId Workspace_TryGetDocument;
    public static FunctionId Workspace_TryGetDocumentFromInProgressSolution;
    public static FunctionId Workspace_Solution_LinkedFileDiffMergingSession;
    public static FunctionId Workspace_Solution_LinkedFileDiffMergingSession_LinkedFileGroup;
    public static FunctionId EndConstruct_DoStatement;
    public static FunctionId EndConstruct_XmlCData;
    public static FunctionId EndConstruct_XmlComment;
    public static FunctionId EndConstruct_XmlElement;
    public static FunctionId EndConstruct_XmlEmbeddedExpression;
    public static FunctionId EndConstruct_XmlProcessingInstruction;
    public static FunctionId FindReference_Rename;
    public static FunctionId FindReference_ChangeSignature;
    public static FunctionId FindReference;
    public static FunctionId FindReference_DetermineAllSymbolsAsync;
    public static FunctionId FindReference_CreateProjectMapAsync;
    public static FunctionId FindReference_CreateDocumentMapAsync;
    public static FunctionId FindReference_ProcessAsync;
    public static FunctionId FindReference_ProcessProjectAsync;
    public static FunctionId FindReference_ProcessDocumentAsync;
    public static FunctionId LineCommit_CommitRegion;
    public static FunctionId Formatting_TokenStreamConstruction;
    public static FunctionId Formatting_ContextInitialization;
    public static FunctionId Formatting_Format;
    public static FunctionId Formatting_ApplyResultToBuffer;
    public static FunctionId Formatting_IterateNodes;
    public static FunctionId Formatting_CollectIndentBlock;
    public static FunctionId Formatting_CollectSuppressOperation;
    public static FunctionId Formatting_CollectAlignOperation;
    public static FunctionId Formatting_CollectAnchorOperation;
    public static FunctionId Formatting_CollectTokenOperation;
    public static FunctionId Formatting_BuildContext;
    public static FunctionId Formatting_ApplySpaceAndLine;
    public static FunctionId Formatting_ApplyAnchorOperation;
    public static FunctionId Formatting_ApplyAlignOperation;
    public static FunctionId Formatting_AggregateCreateTextChanges;
    public static FunctionId Formatting_AggregateCreateFormattedRoot;
    public static FunctionId Formatting_CreateTextChanges;
    public static FunctionId Formatting_CreateFormattedRoot;
    public static FunctionId Formatting_Partitions;
    public static FunctionId SmartIndentation_Start;
    public static FunctionId SmartIndentation_OpenCurly;
    public static FunctionId SmartIndentation_CloseCurly;
    public static FunctionId Rename_InlineSession;
    public static FunctionId Rename_InlineSession_Session;
    public static FunctionId Rename_FindLinkedSpans;
    public static FunctionId Rename_GetSymbolRenameInfo;
    public static FunctionId Rename_OnTextBufferChanged;
    public static FunctionId Rename_ApplyReplacementText;
    public static FunctionId Rename_CommitCore;
    public static FunctionId Rename_CommitCoreWithPreview;
    public static FunctionId Rename_GetAsynchronousLocationsSource;
    public static FunctionId Rename_AllRenameLocations;
    public static FunctionId Rename_StartSearchingForSpansInAllOpenDocuments;
    public static FunctionId Rename_StartSearchingForSpansInOpenDocument;
    public static FunctionId Rename_CreateOpenTextBufferManagerForAllOpenDocs;
    public static FunctionId Rename_CreateOpenTextBufferManagerForAllOpenDocument;
    public static FunctionId Rename_ReportSpan;
    public static FunctionId Rename_GetNoChangeConflictResolution;
    public static FunctionId Rename_Tracking_BufferChanged;
    public static FunctionId TPLTask_TaskScheduled;
    public static FunctionId TPLTask_TaskStarted;
    public static FunctionId TPLTask_TaskCompleted;
    public static FunctionId Get_QuickInfo_Async;
    public static FunctionId Completion_ModelComputer_DoInBackground;
    public static FunctionId Completion_ModelComputation_FilterModelInBackground;
    public static FunctionId Completion_ModelComputation_WaitForModel;
    public static FunctionId Completion_SymbolCompletionProvider_GetItemsWorker;
    public static FunctionId Completion_KeywordCompletionProvider_GetItemsWorker;
    public static FunctionId Completion_SnippetCompletionProvider_GetItemsWorker_CSharp;
    public static FunctionId SignatureHelp_ModelComputation_ComputeModelInBackground;
    public static FunctionId SignatureHelp_ModelComputation_UpdateModelInBackground;
    public static FunctionId Refactoring_CodeRefactoringService_GetRefactoringsAsync;
    public static FunctionId Refactoring_AddImport;
    public static FunctionId Refactoring_FullyQualify;
    public static FunctionId Refactoring_GenerateFromMembers_AddConstructorParametersFromMembers;
    public static FunctionId Refactoring_GenerateFromMembers_GenerateConstructorFromMembers;
    public static FunctionId Refactoring_GenerateFromMembers_GenerateEqualsAndGetHashCode;
    public static FunctionId Refactoring_GenerateMember_GenerateConstructor;
    public static FunctionId Refactoring_GenerateMember_GenerateDefaultConstructors;
    public static FunctionId Refactoring_GenerateMember_GenerateEnumMember;
    public static FunctionId Refactoring_GenerateMember_GenerateMethod;
    public static FunctionId Refactoring_GenerateMember_GenerateVariable;
    public static FunctionId Refactoring_ImplementAbstractClass;
    public static FunctionId Refactoring_ImplementInterface;
    public static FunctionId Refactoring_IntroduceVariable;
    public static FunctionId Refactoring_GenerateType;
    public static FunctionId Refactoring_RemoveUnnecessaryImports_CSharp;
    public static FunctionId Refactoring_RemoveUnnecessaryImports_VisualBasic;
    public static FunctionId Snippet_OnBeforeInsertion;
    public static FunctionId Snippet_OnAfterInsertion;
    public static FunctionId Misc_NonReentrantLock_BlockingWait;
    public static FunctionId Misc_VisualStudioWaitIndicator_Wait;
    public static FunctionId Misc_SaveEventsSink_OnBeforeSave;
    public static FunctionId TaskList_Refresh;
    public static FunctionId TaskList_NavigateTo;
    public static FunctionId WinformDesigner_GenerateXML;
    public static FunctionId NavigateTo_Search;
    public static FunctionId NavigationService_VSDocumentNavigationService_NavigateTo;
    public static FunctionId NavigationBar_ComputeModelAsync;
    public static FunctionId NavigationBar_ItemService_GetMembersInTypes_CSharp;
    public static FunctionId NavigationBar_ItemService_GetTypesInFile_CSharp;
    public static FunctionId NavigationBar_UpdateDropDownsSynchronously_WaitForModel;
    public static FunctionId NavigationBar_UpdateDropDownsSynchronously_WaitForSelectedItemInfo;
    public static FunctionId EventHookup_Determine_If_Event_Hookup;
    public static FunctionId EventHookup_Generate_Handler;
    public static FunctionId EventHookup_Type_Char;
    public static FunctionId Cache_Created;
    public static FunctionId Cache_AddOrAccess;
    public static FunctionId Cache_Remove;
    public static FunctionId Cache_Evict;
    public static FunctionId Cache_EvictAll;
    public static FunctionId Cache_ItemRank;
    public static FunctionId TextStructureNavigator_GetExtentOfWord;
    public static FunctionId TextStructureNavigator_GetSpanOfEnclosing;
    public static FunctionId TextStructureNavigator_GetSpanOfFirstChild;
    public static FunctionId TextStructureNavigator_GetSpanOfNextSibling;
    public static FunctionId TextStructureNavigator_GetSpanOfPreviousSibling;
    public static FunctionId Debugging_LanguageDebugInfoService_GetDataTipSpanAndText;
    public static FunctionId Debugging_VsLanguageDebugInfo_ValidateBreakpointLocation;
    public static FunctionId Debugging_VsLanguageDebugInfo_GetProximityExpressions;
    public static FunctionId Debugging_VsLanguageDebugInfo_ResolveName;
    public static FunctionId Debugging_VsLanguageDebugInfo_GetNameOfLocation;
    public static FunctionId Debugging_VsLanguageDebugInfo_GetDataTipText;
    public static FunctionId Debugging_EncSession;
    public static FunctionId Debugging_EncSession_EditSession;
    public static FunctionId Debugging_EncSession_EditSession_EmitDeltaErrorId;
    public static FunctionId Debugging_EncSession_EditSession_RudeEdit;
    public static FunctionId Simplifier_ReduceAsync;
    public static FunctionId Simplifier_ExpandNode;
    public static FunctionId Simplifier_ExpandToken;
    public static FunctionId ForegroundNotificationService_Processed;
    public static FunctionId ForegroundNotificationService_NotifyOnForeground;
    public static FunctionId BackgroundCompiler_BuildCompilationsAsync;
    public static FunctionId PersistenceService_ReadAsync;
    public static FunctionId PersistenceService_WriteAsync;
    public static FunctionId PersistenceService_ReadAsyncFailed;
    public static FunctionId PersistenceService_WriteAsyncFailed;
    public static FunctionId PersistenceService_Initialization;
    public static FunctionId TemporaryStorageServiceFactory_ReadText;
    public static FunctionId TemporaryStorageServiceFactory_WriteText;
    public static FunctionId TemporaryStorageServiceFactory_ReadStream;
    public static FunctionId TemporaryStorageServiceFactory_WriteStream;
    public static FunctionId SmartTags_RefreshSession;
    public static FunctionId SmartTags_SmartTagInitializeFixes;
    public static FunctionId SmartTags_ApplyQuickFix;
    public static FunctionId EditorTestApp_RefreshTask;
    public static FunctionId EditorTestApp_UpdateDiagnostics;
    public static FunctionId IncrementalAnalyzerProcessor_Analyzers;
    public static FunctionId IncrementalAnalyzerProcessor_Analyzer;
    public static FunctionId IncrementalAnalyzerProcessor_ActiveFileAnalyzers;
    public static FunctionId IncrementalAnalyzerProcessor_ActiveFileAnalyzer;
    public static FunctionId IncrementalAnalyzerProcessor_Shutdown;
    public static FunctionId WorkCoordinatorRegistrationService_Register;
    public static FunctionId WorkCoordinatorRegistrationService_Unregister;
    public static FunctionId WorkCoordinatorRegistrationService_Reanalyze;
    public static FunctionId WorkCoordinator_SolutionCrawlerOption;
    public static FunctionId WorkCoordinator_PersistentStorageAdded;
    public static FunctionId WorkCoordinator_PersistentStorageRemoved;
    public static FunctionId WorkCoordinator_Shutdown;
    public static FunctionId DiagnosticAnalyzerService_Analyzers;
    public static FunctionId DiagnosticAnalyzerDriver_AnalyzerCrash;
    public static FunctionId DiagnosticAnalyzerDriver_AnalyzerTypeCount;
    public static FunctionId PersistedSemanticVersion_Info;
    public static FunctionId StorageDatabase_Exceptions;
    public static FunctionId WorkCoordinator_ShutdownTimeout;
    public static FunctionId Diagnostics_HyperLink;
    public static FunctionId CodeFixes_FixAllOccurrencesSession;
    public static FunctionId CodeFixes_FixAllOccurrencesContext;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Document_Diagnostics;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Project_Diagnostics;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Document_Fixes;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Project_Fixes;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Document_Merge;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Project_Merge;
    public static FunctionId CodeFixes_FixAllOccurrencesPreviewChanges;
    public static FunctionId CodeFixes_ApplyChanges;
    public static FunctionId SolutionExplorer_AnalyzerItemSource_GetItems;
    public static FunctionId SolutionExplorer_DiagnosticItemSource_GetItems;
    public static FunctionId WorkCoordinator_ActiveFileEnqueue;
    public static FunctionId SymbolFinder_FindDeclarationsAsync;
    public static FunctionId SymbolFinder_Project_AddDeclarationsAsync;
    public static FunctionId SymbolFinder_Assembly_AddDeclarationsAsync;
    public static FunctionId SymbolFinder_Solution_Name_FindSourceDeclarationsAsync;
    public static FunctionId SymbolFinder_Project_Name_FindSourceDeclarationsAsync;
    public static FunctionId SymbolFinder_Solution_Predicate_FindSourceDeclarationsAsync;
    public static FunctionId SymbolFinder_Project_Predicate_FindSourceDeclarationsAsync;
    public static FunctionId Tagger_Diagnostics_RecomputeTags;
    public static FunctionId Tagger_Diagnostics_Updated;
    public static FunctionId SuggestedActions_HasSuggestedActionsAsync;
    public static FunctionId SuggestedActions_GetSuggestedActions;
    public static FunctionId AnalyzerDependencyCheckingService_LogConflict;
    public static FunctionId AnalyzerDependencyCheckingService_LogMissingDependency;
    public static FunctionId VirtualMemory_MemoryLow;
    public static FunctionId Extension_Exception;
    public static FunctionId WorkCoordinator_WaitForHigherPriorityOperationsAsync;
    public static FunctionId CSharp_Interactive_Window;
    public static FunctionId VisualBasic_Interactive_Window;
    public static FunctionId NonFatalWatson;
    public static FunctionId GlobalOperationRegistration;
    public static FunctionId CommandHandler_FindAllReference;
    public static FunctionId CodefixInfobar_Enable;
    public static FunctionId CodefixInfobar_EnableAndIgnoreFutureErrors;
    public static FunctionId CodefixInfobar_LeaveDisabled;
    public static FunctionId CodefixInfobar_ErrorIgnored;
    public static FunctionId Refactoring_NamingStyle;
    public static FunctionId SymbolTreeInfo_ExceptionInCacheRead;
    public static FunctionId SpellChecker_ExceptionInCacheRead;
    public static FunctionId BKTree_ExceptionInCacheRead;
    public static FunctionId IntellisenseBuild_Failed;
    public static FunctionId FileTextLoader_FileLengthThresholdExceeded;
    public static FunctionId MeasurePerformance_StartAction;
    public static FunctionId MeasurePerformance_StopAction;
    public static FunctionId Serializer_CreateChecksum;
    public static FunctionId Serializer_Serialize;
    public static FunctionId Serializer_Deserialize;
    public static FunctionId CodeAnalysisService_CalculateDiagnosticsAsync;
    public static FunctionId CodeAnalysisService_SerializeDiagnosticResultAsync;
    public static FunctionId CodeAnalysisService_GetReferenceCountAsync;
    public static FunctionId CodeAnalysisService_FindReferenceLocationsAsync;
    public static FunctionId CodeAnalysisService_FindReferenceMethodsAsync;
    public static FunctionId CodeAnalysisService_GetFullyQualifiedName;
    public static FunctionId CodeAnalysisService_GetTodoCommentsAsync;
    public static FunctionId CodeAnalysisService_GetDesignerAttributesAsync;
    public static FunctionId ServiceHubRemoteHostClient_CreateAsync;
    public static FunctionId PinnedRemotableDataScope_GetRemotableData;
    public static FunctionId RemoteHost_Connect;
    public static FunctionId RemoteHost_Disconnect;
    public static FunctionId RemoteHostClientService_AddGlobalAssetsAsync;
    public static FunctionId RemoteHostClientService_RemoveGlobalAssets;
    public static FunctionId RemoteHostClientService_Enabled;
    public static FunctionId RemoteHostClientService_Restarted;
    public static FunctionId RemoteHostService_SynchronizePrimaryWorkspaceAsync;
    public static FunctionId RemoteHostService_SynchronizeGlobalAssetsAsync;
    public static FunctionId AssetStorage_CleanAssets;
    public static FunctionId AssetStorage_TryGetAsset;
    public static FunctionId AssetService_GetAssetAsync;
    public static FunctionId AssetService_SynchronizeAssetsAsync;
    public static FunctionId AssetService_SynchronizeSolutionAssetsAsync;
    public static FunctionId AssetService_SynchronizeProjectAssetsAsync;
    public static FunctionId CodeLens_GetReferenceCountAsync;
    public static FunctionId CodeLens_FindReferenceLocationsAsync;
    public static FunctionId CodeLens_FindReferenceMethodsAsync;
    public static FunctionId CodeLens_GetFullyQualifiedName;
    public static FunctionId SolutionState_ComputeChecksumsAsync;
    public static FunctionId ProjectState_ComputeChecksumsAsync;
    public static FunctionId DocumentState_ComputeChecksumsAsync;
    public static FunctionId SolutionSynchronizationService_GetRemotableData;
    public static FunctionId SolutionSynchronizationServiceFactory_CreatePinnedRemotableDataScopeAsync;
    public static FunctionId SolutionChecksumUpdater_SynchronizePrimaryWorkspace;
    public static FunctionId JsonRpcSession_RequestAssetAsync;
    public static FunctionId SolutionService_GetSolutionAsync;
    public static FunctionId SolutionService_UpdatePrimaryWorkspaceAsync;
    public static FunctionId SnapshotService_RequestAssetAsync;
    public static FunctionId CompilationService_GetCompilationAsync;
    public static FunctionId SolutionCreator_AssetDifferences;
    public static FunctionId Extension_InfoBar;
    public static FunctionId Experiment_ABTesting;
    public static FunctionId AssetStorage_ForceGC;
    public static FunctionId RemoteHost_Bitness;
    public static FunctionId Intellisense_Completion;
    public static FunctionId MetadataOnlyImage_EmitFailure;
    public static FunctionId LiveTableDataSource_OnDiagnosticsUpdated;
    public static FunctionId Experiment_KeybindingsReset;
    public static FunctionId Diagnostics_GeneratePerformaceReport;
    public static FunctionId Diagnostics_BadAnalyzer;
    public static FunctionId CodeAnalysisService_ReportAnalyzerPerformance;
    public static FunctionId PerformanceTrackerService_AddSnapshot;
    public static FunctionId AbstractProject_SetIntelliSenseBuild;
    public static FunctionId AbstractProject_Created;
    public static FunctionId AbstractProject_PushedToWorkspace;
    public static FunctionId ExternalErrorDiagnosticUpdateSource_AddError;
    public static FunctionId DiagnosticIncrementalAnalyzer_SynchronizeWithBuildAsync;
    public static FunctionId Completion_ExecuteCommand_TypeChar;
    public static FunctionId RemoteHostService_SynchronizeTextAsync;
    public static FunctionId SymbolFinder_Solution_Pattern_FindSourceDeclarationsAsync;
    public static FunctionId SymbolFinder_Project_Pattern_FindSourceDeclarationsAsync;
    public static FunctionId Intellisense_Completion_Commit;
    public static FunctionId CodeCleanupInfobar_BarDisplayed;
    public static FunctionId CodeCleanupInfobar_ConfigureNow;
    public static FunctionId CodeCleanupInfobar_NeverShowCodeCleanupInfoBarAgain;
    public static FunctionId FormatDocument;
    public static FunctionId CodeCleanup_ApplyCodeFixesAsync;
    public static FunctionId CodeCleanup_RemoveUnusedImports;
    public static FunctionId CodeCleanup_SortImports;
    public static FunctionId CodeCleanup_Format;
    public static FunctionId CodeCleanupABTest_AssignedToOnByDefault;
    public static FunctionId CodeCleanupABTest_AssignedToOffByDefault;
}
internal static class Microsoft.CodeAnalysis.Internal.Log.FunctionIdOptions : object {
    private static ConcurrentDictionary`2<FunctionId, Option`1<bool>> s_options;
    private static Func`2<FunctionId, Option`1<bool>> s_optionCreator;
    private static FunctionIdOptions();
    private static Option`1<bool> CreateOption(FunctionId id);
    public static Option`1<bool> GetOption(FunctionId id);
}
internal interface Microsoft.CodeAnalysis.Internal.Log.ILogger {
    public abstract virtual bool IsEnabled(FunctionId functionId);
    public abstract virtual void Log(FunctionId functionId, LogMessage logMessage);
    public abstract virtual void LogBlockStart(FunctionId functionId, LogMessage logMessage, int uniquePairId, CancellationToken cancellationToken);
    public abstract virtual void LogBlockEnd(FunctionId functionId, LogMessage logMessage, int uniquePairId, int delta, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.Internal.Log.InteractionClass : Enum {
    public int value__;
    public static InteractionClass Undefined;
    public static InteractionClass Instant;
    public static InteractionClass Fast;
    public static InteractionClass Typical;
    public static InteractionClass Responsive;
    public static InteractionClass Captive;
    public static InteractionClass Extended;
}
internal class Microsoft.CodeAnalysis.Internal.Log.KeyValueLogMessage : LogMessage {
    private static ObjectPool`1<KeyValueLogMessage> s_pool;
    public static KeyValueLogMessage NoProperty;
    private LogType _kind;
    private Dictionary`2<string, object> _map;
    private Action`1<Dictionary`2<string, object>> _propertySetter;
    public LogType Kind { get; }
    public bool ContainsProperty { get; }
    public IEnumerable`1<KeyValuePair`2<string, object>> Properties { get; }
    private static KeyValueLogMessage();
    public static KeyValueLogMessage Create(Action`1<Dictionary`2<string, object>> propertySetter);
    public static KeyValueLogMessage Create(LogType kind);
    public static KeyValueLogMessage Create(LogType kind, Action`1<Dictionary`2<string, object>> propertySetter);
    private void Construct(LogType kind, Action`1<Dictionary`2<string, object>> propertySetter);
    public LogType get_Kind();
    public bool get_ContainsProperty();
    public IEnumerable`1<KeyValuePair`2<string, object>> get_Properties();
    protected virtual string CreateMessage();
    protected virtual void FreeCore();
    private void EnsureMap();
}
internal class Microsoft.CodeAnalysis.Internal.Log.LogAggregator : object {
    private static int s_globalId;
    private ConcurrentDictionary`2<object, Counter> _map;
    public static int GetNextId();
    public static StatisticResult GetStatistics(List`1<int> values);
    public void SetCount(object key, int count);
    public void IncreaseCount(object key);
    public void IncreaseCountBy(object key, int value);
    public int GetCount(object key);
    public int GetAverage(string key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<object, Counter>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private Counter GetCounter(object key);
}
internal static class Microsoft.CodeAnalysis.Internal.Log.Logger : object {
    private static ILogger s_currentLogger;
    private static int s_lastUniqueBlockId;
    private static ObjectPool`1<RoslynLogBlock> s_pool;
    private static Logger();
    public static ILogger SetLogger(ILogger logger);
    public static ILogger GetLogger();
    public static void Log(FunctionId functionId, string message);
    public static void Log(FunctionId functionId, Func`1<string> messageGetter);
    public static void Log(FunctionId functionId, Func`2<TArg, string> messageGetter, TArg arg);
    public static void Log(FunctionId functionId, Func`3<TArg0, TArg1, string> messageGetter, TArg0 arg0, TArg1 arg1);
    public static void Log(FunctionId functionId, Func`4<TArg0, TArg1, TArg2, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2);
    public static void Log(FunctionId functionId, Func`5<TArg0, TArg1, TArg2, TArg3, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3);
    public static void Log(FunctionId functionId, LogMessage logMessage);
    private static int GetNextUniqueBlockId();
    public static IDisposable LogBlock(FunctionId functionId, CancellationToken token);
    public static IDisposable LogBlock(FunctionId functionId, string message, CancellationToken token);
    public static IDisposable LogBlock(FunctionId functionId, Func`1<string> messageGetter, CancellationToken token);
    public static IDisposable LogBlock(FunctionId functionId, Func`2<TArg, string> messageGetter, TArg arg, CancellationToken token);
    public static IDisposable LogBlock(FunctionId functionId, Func`3<TArg0, TArg1, string> messageGetter, TArg0 arg0, TArg1 arg1, CancellationToken token);
    public static IDisposable LogBlock(FunctionId functionId, Func`4<TArg0, TArg1, TArg2, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, CancellationToken token);
    public static IDisposable LogBlock(FunctionId functionId, Func`5<TArg0, TArg1, TArg2, TArg3, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3, CancellationToken token);
    public static IDisposable LogBlock(FunctionId functionId, LogMessage logMessage, CancellationToken token);
    public static Func`2<FunctionId, bool> GetLoggingChecker(IGlobalOptionService optionService);
    private static IDisposable CreateLogBlock(FunctionId functionId, LogMessage message, int blockId, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Internal.Log.LogMessage : object {
    private string _message;
    public static LogMessage Create(string message);
    public static LogMessage Create(Func`1<string> messageGetter);
    public static LogMessage Create(Func`2<TArg, string> messageGetter, TArg arg);
    public static LogMessage Create(Func`3<TArg0, TArg1, string> messageGetter, TArg0 arg0, TArg1 arg1);
    public static LogMessage Create(Func`4<TArg0, TArg1, TArg2, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2);
    public static LogMessage Create(Func`5<TArg0, TArg1, TArg2, TArg3, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3);
    protected abstract virtual string CreateMessage();
    protected abstract virtual void FreeCore();
    public string GetMessage();
    public void Free();
}
internal enum Microsoft.CodeAnalysis.Internal.Log.LogType : Enum {
    public int value__;
    public static LogType Trace;
    public static LogType UserAction;
}
[AttributeUsageAttribute("256")]
internal class Microsoft.CodeAnalysis.Internal.Log.PerfGoalAttribute : Attribute {
    private InteractionClass _interactionClass;
    public InteractionClass InteractionClass { get; }
    public PerfGoalAttribute(InteractionClass interactionClass);
    public InteractionClass get_InteractionClass();
}
internal interface Microsoft.CodeAnalysis.IOrderableMetadata {
    public IEnumerable`1<string> After { get; }
    public IEnumerable`1<string> Before { get; }
    public string Name { get; }
    public abstract virtual IEnumerable`1<string> get_After();
    public abstract virtual IEnumerable`1<string> get_Before();
    public abstract virtual string get_Name();
}
internal interface Microsoft.CodeAnalysis.ITextVersionable {
    public abstract virtual bool TryGetTextVersion(VersionStamp& version);
}
internal abstract class Microsoft.CodeAnalysis.LanguageServices.AbstractDeclaredSymbolInfoFactoryService : object {
    private static ObjectPool`1<List`1<Dictionary`2<string, string>>> s_aliasMapListPool;
    private static ObjectPool`1<Dictionary`2<string, string>> s_aliasMapPool;
    private static AbstractDeclaredSymbolInfoFactoryService();
    protected static List`1<Dictionary`2<string, string>> AllocateAliasMapList();
    protected static void FreeAliasMapList(List`1<Dictionary`2<string, string>> list);
    protected static void FreeAliasMap(Dictionary`2<string, string> aliasMap);
    protected static Dictionary`2<string, string> AllocateAliasMap();
    protected static void AppendTokens(SyntaxNode node, StringBuilder builder);
    protected static void Intern(StringTable stringTable, ArrayBuilder`1<string> builder);
    public abstract virtual bool TryGetDeclaredSymbolInfo(StringTable stringTable, SyntaxNode node, DeclaredSymbolInfo& declaredSymbolInfo);
}
internal abstract class Microsoft.CodeAnalysis.LanguageServices.AbstractDocumentationCommentService`10 : object {
    public static string Ellipsis;
    private ISyntaxFactsService _syntaxFacts;
    protected AbstractDocumentationCommentService`10(ISyntaxFactsService syntaxFacts);
    private static void AddSpaceIfNotAlreadyThere(StringBuilder sb);
    private string GetDocumentationCommentPrefix(TDocumentationCommentTriviaSyntax documentationComment);
    public string GetBannerText(TDocumentationCommentTriviaSyntax documentationComment, int maxBannerLength, CancellationToken cancellationToken);
    private void HandleElement(TXmlElementSyntax summaryElement, StringBuilder sb);
    private void HandleNode(SyntaxNode node, StringBuilder sb);
    protected abstract virtual SyntaxToken GetIdentifier(TXmlNameAttributeSyntax xmlName);
    protected abstract virtual TCrefSyntax GetCref(TXmlCrefAttributeSyntax xmlCref);
    protected abstract virtual SyntaxList`1<TXmlAttributeSyntax> GetAttributes(TXmlEmptyElementSyntax xmlEmpty);
    protected abstract virtual SyntaxTokenList GetTextTokens(TXmlTextSyntax xmlText);
    protected abstract virtual SyntaxTokenList GetTextTokens(TXmlTextAttributeSyntax xmlTextAttribute);
    protected abstract virtual SyntaxNode GetName(TXmlElementSyntax xmlElement);
    private static void AppendTextTokens(StringBuilder sb, SyntaxTokenList textTokens);
    private static bool HasLeadingWhitespace(string tokenText);
    private static bool HasTrailingWhitespace(string tokenText);
    public sealed virtual string GetBannerText(SyntaxNode documentationCommentTriviaSyntax, int maxBannerLength, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <GetDocumentationCommentPrefix>b__4_0(SyntaxTrivia t);
    [CompilerGeneratedAttribute]
private bool <GetBannerText>b__5_0(TXmlElementSyntax e);
}
internal abstract class Microsoft.CodeAnalysis.LanguageServices.AbstractSemanticFactsService : object {
    protected ISyntaxFactsService SyntaxFactsService { get; }
    protected abstract virtual ISyntaxFactsService get_SyntaxFactsService();
    public SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, CancellationToken cancellationToken);
    public SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    public SyntaxToken GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, CancellationToken cancellationToken);
    private SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, Func`2<ISymbol, bool> filter, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    private SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, IEnumerable`1<ISymbol> candidates, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.LanguageServices.AbstractSyntaxFactsService : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ObjectPool`1<Stack`1<ValueTuple`3<SyntaxNodeOrToken, bool, bool>>> s_stackPool;
    private Matcher`1<SyntaxTrivia> _oneOrMoreBlankLines;
    private Matcher`1<SyntaxTrivia> _bannerMatcher;
    private Matcher`1<SyntaxTrivia> _fileBannerMatcher;
    protected IDocumentationCommentService DocumentationCommentService { get; }
    private static AbstractSyntaxFactsService();
    public abstract virtual bool IsWhitespaceTrivia(SyntaxTrivia trivia);
    public abstract virtual bool IsEndOfLineTrivia(SyntaxTrivia trivia);
    public abstract virtual bool IsSingleLineCommentTrivia(SyntaxTrivia trivia);
    public abstract virtual bool IsMultiLineCommentTrivia(SyntaxTrivia trivia);
    public abstract virtual bool IsShebangDirectiveTrivia(SyntaxTrivia trivia);
    public abstract virtual bool IsPreprocessorDirective(SyntaxTrivia trivia);
    public bool IsOnSingleLine(SyntaxNode node, bool fullSpan);
    private bool IsOnSingleLine(Stack`1<ValueTuple`3<SyntaxNodeOrToken, bool, bool>> stack);
    private bool IsOnSingleLine(SyntaxToken token, bool leading, bool trailing);
    private bool IsOnSingleLine(SyntaxTriviaList triviaList, bool checkTrivia);
    private bool IsOnSingleLine(string value);
    public abstract virtual bool IsStringLiteral(SyntaxToken token);
    public abstract virtual bool IsInterpolatedStringTextToken(SyntaxToken token);
    public ImmutableArray`1<SyntaxTrivia> GetLeadingBlankLines(SyntaxNode node);
    public ImmutableArray`1<SyntaxTrivia> GetLeadingBlankLines(TSyntaxNode node);
    public TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node);
    public TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
    public ImmutableArray`1<SyntaxTrivia> GetLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    public TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    public TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
    public ImmutableArray`1<SyntaxTrivia> GetFileBanner(SyntaxNode root);
    public ImmutableArray`1<SyntaxTrivia> GetFileBanner(SyntaxToken firstToken);
    public bool ContainsInterleavedDirective(ImmutableArray`1<SyntaxNode> nodes, CancellationToken cancellationToken);
    public bool ContainsInterleavedDirective(SyntaxNode node, CancellationToken cancellationToken);
    private bool ContainsInterleavedDirective(TextSpan span, SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual bool ContainsInterleavedDirective(TextSpan span, SyntaxToken token, CancellationToken cancellationToken);
    public string GetBannerText(SyntaxNode documentationCommentTriviaSyntax, int bannerLength, CancellationToken cancellationToken);
    protected abstract virtual IDocumentationCommentService get_DocumentationCommentService();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.LanguageServices.DisplayNameOptions : Enum {
    public int value__;
    public static DisplayNameOptions None;
    public static DisplayNameOptions IncludeMemberKeyword;
    public static DisplayNameOptions IncludeNamespaces;
    public static DisplayNameOptions IncludeParameters;
    public static DisplayNameOptions IncludeType;
    public static DisplayNameOptions IncludeTypeParameters;
}
internal class Microsoft.CodeAnalysis.LanguageServices.ExternalSourceInfo : ValueType {
    public Nullable`1<int> StartLine;
    public bool Ends;
    public ExternalSourceInfo(Nullable`1<int> startLine, bool ends);
}
internal class Microsoft.CodeAnalysis.LanguageServices.ForEachSymbols : ValueType {
    public IMethodSymbol GetEnumeratorMethod;
    public IMethodSymbol MoveNextMethod;
    public IPropertySymbol CurrentProperty;
    public IMethodSymbol DisposeMethod;
    public ITypeSymbol ElementType;
    internal ForEachSymbols(IMethodSymbol getEnumeratorMethod, IMethodSymbol moveNextMethod, IPropertySymbol currentProperty, IMethodSymbol disposeMethod, ITypeSymbol elementType);
}
internal interface Microsoft.CodeAnalysis.LanguageServices.IDocumentationCommentService {
    public abstract virtual string GetBannerText(SyntaxNode documentationCommentTriviaSyntax, int bannerLength, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService {
    public bool SupportsImplicitInterfaceImplementation { get; }
    public bool SupportsParameterizedProperties { get; }
    public bool ExposesAnonymousFunctionParameterNames { get; }
    public abstract virtual bool get_SupportsImplicitInterfaceImplementation();
    public abstract virtual bool get_SupportsParameterizedProperties();
    public abstract virtual bool get_ExposesAnonymousFunctionParameterNames();
    public abstract virtual bool IsExpressionContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsStatementContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsTypeContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsNamespaceContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsNamespaceDeclarationNameContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsTypeDeclarationContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsMemberDeclarationContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsPreProcessorDirectiveContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsGlobalStatementContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsLabelContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsAttributeNameContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsNameOfContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsInExpressionTree(SemanticModel semanticModel, SyntaxNode node, INamedTypeSymbol expressionTypeOpt, CancellationToken cancellationToken);
    public abstract virtual bool IsWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool IsOnlyWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool IsInOutContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool IsInRefContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool IsInInContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool CanReplaceWithRValue(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    public abstract virtual string GenerateNameForExpression(SemanticModel semanticModel, SyntaxNode expression, bool capitalize, CancellationToken cancellationToken);
    public abstract virtual ISymbol GetDeclaredSymbol(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    public abstract virtual bool LastEnumValueHasInitializer(INamedTypeSymbol namedTypeSymbol);
    public abstract virtual bool TryGetSpeculativeSemanticModel(SemanticModel oldSemanticModel, SyntaxNode oldNode, SyntaxNode newNode, SemanticModel& speculativeModel);
    public abstract virtual ImmutableHashSet`1<string> GetAliasNameSet(SemanticModel model, CancellationToken cancellationToken);
    public abstract virtual ForEachSymbols GetForEachSymbols(SemanticModel semanticModel, SyntaxNode forEachStatement);
    public abstract virtual IMethodSymbol GetGetAwaiterMethod(SemanticModel semanticModel, SyntaxNode node);
    public abstract virtual ImmutableArray`1<IMethodSymbol> GetDeconstructionAssignmentMethods(SemanticModel semanticModel, SyntaxNode node);
    public abstract virtual ImmutableArray`1<IMethodSymbol> GetDeconstructionForEachMethods(SemanticModel semanticModel, SyntaxNode node);
    public abstract virtual bool IsPartial(ITypeSymbol typeSymbol, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<ISymbol> GetDeclaredSymbols(SemanticModel semanticModel, SyntaxNode memberDeclaration, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<ISymbol> GetBestOrAllSymbols(SemanticModel semanticModel, SyntaxNode node, SyntaxToken token, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.LanguageServices.ISymbolDeclarationService {
    public abstract virtual IEnumerable`1<SyntaxReference> GetDeclarations(ISymbol symbol);
}
internal interface Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService {
    public bool IsCaseSensitive { get; }
    public StringComparer StringComparer { get; }
    public SyntaxTrivia ElasticMarker { get; }
    public SyntaxTrivia ElasticCarriageReturnLineFeed { get; }
    public abstract virtual bool get_IsCaseSensitive();
    public abstract virtual StringComparer get_StringComparer();
    public abstract virtual SyntaxTrivia get_ElasticMarker();
    public abstract virtual SyntaxTrivia get_ElasticCarriageReturnLineFeed();
    public abstract virtual bool SupportsIndexingInitializer(ParseOptions options);
    public abstract virtual bool SupportsThrowExpression(ParseOptions options);
    public abstract virtual SyntaxToken ParseToken(string text);
    public abstract virtual bool IsAwaitKeyword(SyntaxToken token);
    public abstract virtual bool IsIdentifier(SyntaxToken token);
    public abstract virtual bool IsGlobalNamespaceKeyword(SyntaxToken token);
    public abstract virtual bool IsVerbatimIdentifier(SyntaxToken token);
    public abstract virtual bool IsOperator(SyntaxToken token);
    public abstract virtual bool IsPredefinedType(SyntaxToken token);
    public abstract virtual bool IsPredefinedType(SyntaxToken token, PredefinedType type);
    public abstract virtual bool IsPredefinedOperator(SyntaxToken token);
    public abstract virtual bool IsPredefinedOperator(SyntaxToken token, PredefinedOperator op);
    public abstract virtual bool IsKeyword(SyntaxToken token);
    public abstract virtual bool IsContextualKeyword(SyntaxToken token);
    public abstract virtual bool IsPreprocessorKeyword(SyntaxToken token);
    public abstract virtual bool IsHashToken(SyntaxToken token);
    public abstract virtual bool IsLiteral(SyntaxToken token);
    public abstract virtual bool IsStringLiteralOrInterpolatedStringLiteral(SyntaxToken token);
    public abstract virtual bool IsNumericLiteral(SyntaxToken token);
    public abstract virtual bool IsCharacterLiteral(SyntaxToken token);
    public abstract virtual bool IsStringLiteral(SyntaxToken token);
    public abstract virtual bool IsVerbatimStringLiteral(SyntaxToken token);
    public abstract virtual bool IsInterpolatedStringTextToken(SyntaxToken token);
    public abstract virtual bool IsStringLiteralExpression(SyntaxNode node);
    public abstract virtual bool IsTypeNamedVarInVariableOrFieldDeclaration(SyntaxToken token, SyntaxNode parent);
    public abstract virtual bool IsTypeNamedDynamic(SyntaxToken token, SyntaxNode parent);
    public abstract virtual bool IsUsingOrExternOrImport(SyntaxNode node);
    public abstract virtual bool IsGlobalAttribute(SyntaxNode node);
    public abstract virtual bool IsDeclaration(SyntaxNode node);
    public abstract virtual bool IsRegularComment(SyntaxTrivia trivia);
    public abstract virtual bool IsDocumentationComment(SyntaxTrivia trivia);
    public abstract virtual bool IsElastic(SyntaxTrivia trivia);
    public abstract virtual bool IsDocumentationComment(SyntaxNode node);
    public abstract virtual bool IsNumericLiteralExpression(SyntaxNode node);
    public abstract virtual bool IsNullLiteralExpression(SyntaxNode node);
    public abstract virtual bool IsDefaultLiteralExpression(SyntaxNode node);
    public abstract virtual bool IsLiteralExpression(SyntaxNode node);
    public abstract virtual bool IsFalseLiteralExpression(SyntaxNode expression);
    public abstract virtual bool IsTrueLiteralExpression(SyntaxNode expression);
    public abstract virtual string GetText(int kind);
    public abstract virtual bool IsInInactiveRegion(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsInNonUserCode(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsEntirelyWithinStringOrCharOrNumericLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsPossibleTupleContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public abstract virtual bool TryGetPredefinedType(SyntaxToken token, PredefinedType& type);
    public abstract virtual bool TryGetPredefinedOperator(SyntaxToken token, PredefinedOperator& op);
    public abstract virtual bool TryGetExternalSourceInfo(SyntaxNode directive, ExternalSourceInfo& info);
    public abstract virtual bool IsObjectCreationExpressionType(SyntaxNode node);
    public abstract virtual bool IsObjectCreationExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetObjectCreationInitializer(SyntaxNode node);
    public abstract virtual SyntaxNode GetObjectCreationType(SyntaxNode node);
    public abstract virtual bool IsBinaryExpression(SyntaxNode node);
    public abstract virtual void GetPartsOfBinaryExpression(SyntaxNode node, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public abstract virtual void GetPartsOfConditionalExpression(SyntaxNode node, SyntaxNode& condition, SyntaxNode& whenTrue, SyntaxNode& whenFalse);
    public abstract virtual bool IsCastExpression(SyntaxNode node);
    public abstract virtual void GetPartsOfCastExpression(SyntaxNode node, SyntaxNode& type, SyntaxNode& expression);
    public abstract virtual bool IsInvocationExpression(SyntaxNode node);
    public abstract virtual bool IsExpressionOfInvocationExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfInvocationExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfExpressionStatement(SyntaxNode node);
    public abstract virtual bool IsAwaitExpression(SyntaxNode node);
    public abstract virtual bool IsExpressionOfAwaitExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfAwaitExpression(SyntaxNode node);
    public abstract virtual bool IsLogicalAndExpression(SyntaxNode node);
    public abstract virtual bool IsLogicalOrExpression(SyntaxNode node);
    public abstract virtual bool IsLogicalNotExpression(SyntaxNode node);
    public abstract virtual bool IsConditionalAnd(SyntaxNode node);
    public abstract virtual bool IsConditionalOr(SyntaxNode node);
    public abstract virtual SyntaxNode GetOperandOfPrefixUnaryExpression(SyntaxNode node);
    public abstract virtual SyntaxToken GetOperatorTokenOfPrefixUnaryExpression(SyntaxNode node);
    public abstract virtual bool IsLeftSideOfAssignment(SyntaxNode node);
    public abstract virtual bool IsSimpleAssignmentStatement(SyntaxNode statement);
    public abstract virtual void GetPartsOfAssignmentStatement(SyntaxNode statement, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public abstract virtual bool IsLeftSideOfAnyAssignment(SyntaxNode node);
    public abstract virtual SyntaxNode GetRightHandSideOfAssignment(SyntaxNode node);
    public abstract virtual bool IsInferredAnonymousObjectMemberDeclarator(SyntaxNode node);
    public abstract virtual bool IsOperandOfIncrementExpression(SyntaxNode node);
    public abstract virtual bool IsOperandOfIncrementOrDecrementExpression(SyntaxNode node);
    public abstract virtual bool IsLeftSideOfDot(SyntaxNode node);
    public abstract virtual SyntaxNode GetRightSideOfDot(SyntaxNode node);
    public abstract virtual bool IsRightSideOfQualifiedName(SyntaxNode node);
    public abstract virtual bool IsNameOfMemberAccessExpression(SyntaxNode node);
    public abstract virtual bool IsExpressionOfMemberAccessExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetNameOfMemberAccessExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfMemberAccessExpression(SyntaxNode node, bool allowImplicitTarget);
    public abstract virtual SyntaxToken GetOperatorTokenOfMemberAccessExpression(SyntaxNode node);
    public abstract virtual void GetPartsOfMemberAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& name);
    public abstract virtual SyntaxNode GetTargetOfMemberBinding(SyntaxNode node);
    public abstract virtual bool IsSimpleMemberAccessExpression(SyntaxNode node);
    public abstract virtual bool IsPointerMemberAccessExpression(SyntaxNode node);
    public abstract virtual bool IsNamedParameter(SyntaxNode node);
    public abstract virtual SyntaxNode GetDefaultOfParameter(SyntaxNode node);
    public abstract virtual SyntaxNode GetParameterList(SyntaxNode node);
    public abstract virtual bool IsSkippedTokensTrivia(SyntaxNode node);
    public abstract virtual bool IsWhitespaceTrivia(SyntaxTrivia trivia);
    public abstract virtual bool IsEndOfLineTrivia(SyntaxTrivia trivia);
    public abstract virtual bool IsDocumentationCommentExteriorTrivia(SyntaxTrivia trivia);
    public abstract virtual SyntaxNode GetExpressionOfConditionalAccessExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfElementAccessExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetArgumentListOfElementAccessExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfArgument(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfInterpolation(SyntaxNode node);
    public abstract virtual bool IsConditionalMemberAccessExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetNameOfAttribute(SyntaxNode node);
    public abstract virtual bool IsParenthesizedExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfParenthesizedExpression(SyntaxNode node);
    public abstract virtual bool IsIfStatement(SyntaxNode node);
    public abstract virtual SyntaxToken GetIdentifierOfGenericName(SyntaxNode node);
    public abstract virtual SyntaxToken GetIdentifierOfSimpleName(SyntaxNode node);
    public abstract virtual SyntaxToken GetIdentifierOfVariableDeclarator(SyntaxNode node);
    public abstract virtual SyntaxNode GetTypeOfVariableDeclarator(SyntaxNode node);
    public abstract virtual bool IsSimpleArgument(SyntaxNode node);
    public abstract virtual bool IsArgument(SyntaxNode node);
    public abstract virtual RefKind GetRefKindOfArgument(SyntaxNode node);
    public abstract virtual void GetNameAndArityOfSimpleName(SyntaxNode node, String& name, Int32& arity);
    public abstract virtual bool LooksGeneric(SyntaxNode simpleName);
    public abstract virtual SyntaxList`1<SyntaxNode> GetContentsOfInterpolatedString(SyntaxNode interpolatedString);
    public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfInvocationExpression(SyntaxNode node);
    public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfObjectCreationExpression(SyntaxNode node);
    public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfArgumentList(SyntaxNode node);
    public abstract virtual bool IsUsingDirectiveName(SyntaxNode node);
    public abstract virtual bool IsIdentifierName(SyntaxNode node);
    public abstract virtual bool IsGenericName(SyntaxNode node);
    public abstract virtual bool IsAttribute(SyntaxNode node);
    public abstract virtual bool IsAttributeName(SyntaxNode node);
    public abstract virtual bool IsAttributeNamedArgumentIdentifier(SyntaxNode node);
    public abstract virtual bool IsObjectInitializerNamedAssignmentIdentifier(SyntaxNode node);
    public abstract virtual bool IsObjectInitializerNamedAssignmentIdentifier(SyntaxNode node, SyntaxNode& initializedInstance);
    public abstract virtual bool IsDirective(SyntaxNode node);
    public abstract virtual bool IsForEachStatement(SyntaxNode node);
    public abstract virtual bool IsLockStatement(SyntaxNode node);
    public abstract virtual bool IsUsingStatement(SyntaxNode node);
    public abstract virtual bool IsStatement(SyntaxNode node);
    public abstract virtual bool IsParameter(SyntaxNode node);
    public abstract virtual bool IsVariableDeclarator(SyntaxNode node);
    public abstract virtual bool IsDeconstructionAssignment(SyntaxNode node);
    public abstract virtual bool IsDeconstructionForEachStatement(SyntaxNode node);
    public abstract virtual bool IsMethodBody(SyntaxNode node);
    public abstract virtual bool IsReturnStatement(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfReturnStatement(SyntaxNode node);
    public abstract virtual bool IsLocalDeclarationStatement(SyntaxNode node);
    public abstract virtual bool IsLocalFunctionStatement(SyntaxNode node);
    public abstract virtual bool IsDeclaratorOfLocalDeclarationStatement(SyntaxNode declarator, SyntaxNode localDeclarationStatement);
    public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetVariablesOfLocalDeclarationStatement(SyntaxNode node);
    public abstract virtual SyntaxNode GetInitializerOfVariableDeclarator(SyntaxNode node);
    public abstract virtual SyntaxNode GetValueOfEqualsValueClause(SyntaxNode node);
    public abstract virtual bool IsThisConstructorInitializer(SyntaxToken token);
    public abstract virtual bool IsBaseConstructorInitializer(SyntaxToken token);
    public abstract virtual bool IsQueryExpression(SyntaxNode node);
    public abstract virtual bool IsQueryKeyword(SyntaxToken token);
    public abstract virtual bool IsThrowExpression(SyntaxNode node);
    public abstract virtual bool IsElementAccessExpression(SyntaxNode node);
    public abstract virtual bool IsIndexerMemberCRef(SyntaxNode node);
    public abstract virtual bool IsIdentifierStartCharacter(char c);
    public abstract virtual bool IsIdentifierPartCharacter(char c);
    public abstract virtual bool IsIdentifierEscapeCharacter(char c);
    public abstract virtual bool IsStartOfUnicodeEscapeSequence(char c);
    public abstract virtual bool IsValidIdentifier(string identifier);
    public abstract virtual bool IsVerbatimIdentifier(string identifier);
    public abstract virtual bool IsTypeCharacter(char c);
    public abstract virtual bool IsBindableToken(SyntaxToken token);
    public abstract virtual bool IsInStaticContext(SyntaxNode node);
    public abstract virtual bool IsUnsafeContext(SyntaxNode node);
    public abstract virtual bool IsInNamespaceOrTypeContext(SyntaxNode node);
    public abstract virtual bool IsAnonymousFunction(SyntaxNode n);
    public abstract virtual bool IsInConstantContext(SyntaxNode node);
    public abstract virtual bool IsInConstructor(SyntaxNode node);
    public abstract virtual bool IsMethodLevelMember(SyntaxNode node);
    public abstract virtual bool IsTopLevelNodeWithMembers(SyntaxNode node);
    public abstract virtual bool HasIncompleteParentMember(SyntaxNode node);
    public abstract virtual bool IsExecutableBlock(SyntaxNode node);
    public abstract virtual SyntaxList`1<SyntaxNode> GetExecutableBlockStatements(SyntaxNode node);
    public abstract virtual SyntaxNode FindInnermostCommonExecutableBlock(IEnumerable`1<SyntaxNode> nodes);
    public abstract virtual bool AreEquivalent(SyntaxToken token1, SyntaxToken token2);
    public abstract virtual bool AreEquivalent(SyntaxNode node1, SyntaxNode node2);
    public abstract virtual string GetDisplayName(SyntaxNode node, DisplayNameOptions options, string rootNamespace);
    public abstract virtual SyntaxNode GetContainingTypeDeclaration(SyntaxNode root, int position);
    public abstract virtual SyntaxNode GetContainingMemberDeclaration(SyntaxNode root, int position, bool useFullSpan);
    public abstract virtual SyntaxNode GetContainingVariableDeclaratorOfFieldDeclaration(SyntaxNode node);
    public abstract virtual SyntaxToken FindTokenOnLeftOfPosition(SyntaxNode node, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    public abstract virtual SyntaxToken FindTokenOnRightOfPosition(SyntaxNode node, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    public abstract virtual void GetPartsOfParenthesizedExpression(SyntaxNode node, SyntaxToken& openParen, SyntaxNode& expression, SyntaxToken& closeParen);
    public abstract virtual SyntaxNode Parenthesize(SyntaxNode expression, bool includeElasticTrivia, bool addSimplifierAnnotation);
    public abstract virtual SyntaxNode WalkDownParentheses(SyntaxNode node);
    public abstract virtual SyntaxNode ConvertToSingleLine(SyntaxNode node, bool useElasticTrivia);
    public abstract virtual SyntaxToken ToIdentifierToken(string name);
    public abstract virtual List`1<SyntaxNode> GetMethodLevelMembers(SyntaxNode root);
    public abstract virtual SyntaxList`1<SyntaxNode> GetMembersOfTypeDeclaration(SyntaxNode typeDeclaration);
    public abstract virtual bool ContainsInMemberBody(SyntaxNode node, TextSpan span);
    public abstract virtual int GetMethodLevelMemberId(SyntaxNode root, SyntaxNode node);
    public abstract virtual SyntaxNode GetMethodLevelMember(SyntaxNode root, int memberId);
    public abstract virtual TextSpan GetInactiveRegionSpanAroundPosition(SyntaxTree tree, int position, CancellationToken cancellationToken);
    public abstract virtual TextSpan GetMemberBodySpanForSpeculativeBinding(SyntaxNode node);
    public abstract virtual SyntaxNode GetBindableParent(SyntaxToken token);
    public abstract virtual IEnumerable`1<SyntaxNode> GetConstructors(SyntaxNode root, CancellationToken cancellationToken);
    public abstract virtual bool TryGetCorrespondingOpenBrace(SyntaxToken token, SyntaxToken& openBrace);
    public abstract virtual string GetNameForArgument(SyntaxNode argument);
    public abstract virtual ImmutableArray`1<SyntaxNode> GetSelectedMembers(SyntaxNode root, TextSpan textSpan);
    public abstract virtual bool IsOnTypeHeader(SyntaxNode root, int position);
    public abstract virtual bool IsBetweenTypeMembers(SourceText sourceText, SyntaxNode root, int position);
    public abstract virtual void AddFirstMissingCloseBrace(SyntaxNode root, SyntaxNode contextNode, SyntaxNode& newRoot, SyntaxNode& newContextNode);
    public abstract virtual SyntaxNode GetNextExecutableStatement(SyntaxNode statement);
    public abstract virtual ImmutableArray`1<SyntaxTrivia> GetLeadingBlankLines(SyntaxNode node);
    public abstract virtual TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node);
    public abstract virtual ImmutableArray`1<SyntaxTrivia> GetFileBanner(SyntaxNode root);
    public abstract virtual ImmutableArray`1<SyntaxTrivia> GetFileBanner(SyntaxToken firstToken);
    public abstract virtual bool ContainsInterleavedDirective(SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool ContainsInterleavedDirective(ImmutableArray`1<SyntaxNode> nodes, CancellationToken cancellationToken);
    public abstract virtual string GetBannerText(SyntaxNode documentationCommentTriviaSyntax, int maxBannerLength, CancellationToken cancellationToken);
    public abstract virtual SyntaxTokenList GetModifiers(SyntaxNode node);
    public abstract virtual SyntaxNode WithModifiers(SyntaxNode node, SyntaxTokenList modifiers);
    public abstract virtual Location GetDeconstructionReferenceLocation(SyntaxNode node);
    public abstract virtual Nullable`1<SyntaxToken> GetDeclarationIdentifierIfOverride(SyntaxToken token);
    public abstract virtual bool SpansPreprocessorDirective(IEnumerable`1<SyntaxNode> nodes);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsServiceExtensions : object {
    [ExtensionAttribute]
public static bool IsWord(ISyntaxFactsService syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsAnyMemberAccessExpression(ISyntaxFactsService syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsRegularOrDocumentationComment(ISyntaxFactsService syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxTrivia> GetTriviaAfterLeadingBlankLines(ISyntaxFactsService syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static void GetPartsOfAssignmentStatement(ISyntaxFactsService syntaxFacts, SyntaxNode statement, SyntaxNode& left, SyntaxNode& right);
    [ExtensionAttribute]
public static SyntaxNode Unparenthesize(ISyntaxFactsService syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
private static bool IsWordOrNumber(ISyntaxFactsService syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(ISyntaxFactsService service, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsWhitespaceOrEndOfLineTrivia(ISyntaxFactsService syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static void GetPartsOfBinaryExpression(ISyntaxFactsService syntaxFacts, SyntaxNode node, SyntaxNode& left, SyntaxNode& right);
    [ExtensionAttribute]
public static SyntaxNode GetExpressionOfParenthesizedExpression(ISyntaxFactsService syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxToken GetOperatorTokenOfBinaryExpression(ISyntaxFactsService syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsAnonymousOrLocalFunctionStatement(ISyntaxFactsService syntaxFacts, SyntaxNode node);
}
internal interface Microsoft.CodeAnalysis.LanguageServices.ITypeInferenceService {
    public abstract virtual ImmutableArray`1<ITypeSymbol> InferTypes(SemanticModel semanticModel, SyntaxNode expression, string nameOpt, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<ITypeSymbol> InferTypes(SemanticModel semanticModel, int position, string nameOpt, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(SemanticModel semanticModel, int position, string nameOpt, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(SemanticModel semanticModel, SyntaxNode expression, string nameOpt, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.LanguageServices.PredefinedOperator : Enum {
    public int value__;
    public static PredefinedOperator None;
    public static PredefinedOperator Addition;
    public static PredefinedOperator BitwiseAnd;
    public static PredefinedOperator BitwiseOr;
    public static PredefinedOperator Complement;
    public static PredefinedOperator Concatenate;
    public static PredefinedOperator Decrement;
    public static PredefinedOperator Division;
    public static PredefinedOperator Equality;
    public static PredefinedOperator ExclusiveOr;
    public static PredefinedOperator Exponent;
    public static PredefinedOperator GreaterThan;
    public static PredefinedOperator GreaterThanOrEqual;
    public static PredefinedOperator Increment;
    public static PredefinedOperator Inequality;
    public static PredefinedOperator IntegerDivision;
    public static PredefinedOperator LeftShift;
    public static PredefinedOperator LessThan;
    public static PredefinedOperator LessThanOrEqual;
    public static PredefinedOperator Like;
    public static PredefinedOperator Modulus;
    public static PredefinedOperator Multiplication;
    public static PredefinedOperator RightShift;
    public static PredefinedOperator Subtraction;
}
internal enum Microsoft.CodeAnalysis.LanguageServices.PredefinedType : Enum {
    public int value__;
    public static PredefinedType None;
    public static PredefinedType Boolean;
    public static PredefinedType Byte;
    public static PredefinedType Char;
    public static PredefinedType DateTime;
    public static PredefinedType Decimal;
    public static PredefinedType Double;
    public static PredefinedType Int16;
    public static PredefinedType Int32;
    public static PredefinedType Int64;
    public static PredefinedType Object;
    public static PredefinedType SByte;
    public static PredefinedType Single;
    public static PredefinedType String;
    public static PredefinedType UInt16;
    public static PredefinedType UInt32;
    public static PredefinedType UInt64;
    public static PredefinedType Void;
}
internal class Microsoft.CodeAnalysis.LanguageServices.TypeInferenceInfo : ValueType {
    [CompilerGeneratedAttribute]
private ITypeSymbol <InferredType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParams>k__BackingField;
    public ITypeSymbol InferredType { get; }
    public bool IsParams { get; }
    public TypeInferenceInfo(ITypeSymbol type);
    public TypeInferenceInfo(ITypeSymbol type, bool isParams);
    [CompilerGeneratedAttribute]
public ITypeSymbol get_InferredType();
    [CompilerGeneratedAttribute]
public bool get_IsParams();
}
internal abstract class Microsoft.CodeAnalysis.LanguageServices.TypeInferenceService.AbstractTypeInferenceService`1 : object {
    private static ImmutableArray`1<string> s_booleanPrefixes;
    private static AbstractTypeInferenceService`1();
    protected abstract virtual AbstractTypeInferrer<TExpressionSyntax> CreateTypeInferrer(SemanticModel semanticModel, CancellationToken cancellationToken);
    private ImmutableArray`1<ITypeSymbol> InferTypeBasedOnNameIfEmpty(SemanticModel semanticModel, ImmutableArray`1<ITypeSymbol> result, string nameOpt);
    private ImmutableArray`1<TypeInferenceInfo> InferTypeBasedOnNameIfEmpty(SemanticModel semanticModel, ImmutableArray`1<TypeInferenceInfo> result, string nameOpt);
    private ImmutableArray`1<ITypeSymbol> InferTypeBasedOnName(SemanticModel semanticModel, string name);
    private static bool MatchesBoolean(string name);
    private static bool Matches(string name, string prefix);
    public sealed virtual ImmutableArray`1<ITypeSymbol> InferTypes(SemanticModel semanticModel, int position, string nameOpt, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<ITypeSymbol> InferTypes(SemanticModel semanticModel, SyntaxNode expression, string nameOpt, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(SemanticModel semanticModel, int position, string nameOpt, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(SemanticModel semanticModel, SyntaxNode expression, string nameOpt, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.LinkedFileDiffMergingLogger : object {
    private static LogAggregator LogAggregator;
    private static LinkedFileDiffMergingLogger();
    internal static void LogSession(Workspace workspace, LinkedFileDiffMergingSessionInfo sessionInfo);
    private static void LogNewSessionWithLinkedFiles();
    private static void LogNumberOfLinkedFileGroupsProcessed(int linkedFileGroupsProcessed);
    private static void LogNumberOfIdenticalDiffs(int identicalDiffs);
    private static void LogNumberOfIsolatedDiffs(int isolatedDiffs);
    private static void LogNumberOfOverlappingDistinctDiffs(int overlappingDistinctDiffs);
    private static void LogNumberOfOverlappingDistinctDiffsWithSameSpan(int overlappingDistinctDiffsWithSameSpan);
    private static void LogNumberOfOverlappingDistinctDiffsWithSameSpanAndSubstringRelation(int overlappingDistinctDiffsWithSameSpanAndSubstringRelation);
    private static void LogNumberOfInsertedMergeConflictComments(int insertedMergeConflictComments);
    private static void LogNumberOfInsertedMergeConflictCommentsAtAdjustedLocation(int insertedMergeConflictCommentsAtAdjustedLocation);
    private static void Log(int mergeInfo, int count);
    internal static void ReportTelemetry();
}
internal class Microsoft.CodeAnalysis.LinkedFileDiffMergingSession : object {
    private bool _logSessionInfo;
    private Solution _oldSolution;
    private Solution _newSolution;
    private SolutionChanges _solutionChanges;
    public LinkedFileDiffMergingSession(Solution oldSolution, Solution newSolution, SolutionChanges solutionChanges, bool logSessionInfo);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LinkedFileDiffMergingSession/<MergeDiffsAsync>d__5")]
internal Task`1<LinkedFileMergeSessionResult> MergeDiffsAsync(IMergeConflictHandler mergeConflictHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LinkedFileDiffMergingSession/<MergeLinkedDocumentGroupAsync>d__6")]
private Task`1<LinkedFileMergeResult> MergeLinkedDocumentGroupAsync(IEnumerable`1<DocumentId> allLinkedDocuments, IEnumerable`1<DocumentId> linkedDocumentGroup, LinkedFileDiffMergingSessionInfo sessionInfo, IMergeConflictHandler mergeConflictHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LinkedFileDiffMergingSession/<AddDocumentMergeChangesAsync>d__7")]
private static Task`1<ImmutableArray`1<TextChange>> AddDocumentMergeChangesAsync(Document oldDocument, Document newDocument, List`1<TextChange> cumulativeChanges, List`1<UnmergedDocumentChanges> unmergedChanges, LinkedFileGroupSessionInfo groupSessionInfo, IDocumentTextDifferencingService textDiffService, CancellationToken cancellationToken);
    private IEnumerable`1<TextChange> MergeChangesWithMergeFailComments(IEnumerable`1<TextChange> mergedChanges, IEnumerable`1<TextChange> commentChanges, IList`1<TextSpan> mergeConflictResolutionSpans, LinkedFileGroupSessionInfo groupSessionInfo);
    private IEnumerable`1<TextChange> NormalizeChanges(IEnumerable`1<TextChange> changes);
    private void LogLinkedFileDiffMergingSessionInfo(LinkedFileDiffMergingSessionInfo sessionInfo);
    [CompilerGeneratedAttribute]
private string <MergeDiffsAsync>b__5_1(DocumentId d);
}
internal class Microsoft.CodeAnalysis.LinkedFileMergeResult : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<DocumentId> <DocumentIds>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceText <MergedSourceText>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TextSpan> <MergeConflictResolutionSpans>k__BackingField;
    public IEnumerable`1<DocumentId> DocumentIds { get; internal set; }
    public SourceText MergedSourceText { get; internal set; }
    public IEnumerable`1<TextSpan> MergeConflictResolutionSpans { get; }
    public bool HasMergeConflicts { get; }
    public LinkedFileMergeResult(IEnumerable`1<DocumentId> documentIds, SourceText mergedSourceText, IEnumerable`1<TextSpan> mergeConflictResolutionSpans);
    [CompilerGeneratedAttribute]
public IEnumerable`1<DocumentId> get_DocumentIds();
    [CompilerGeneratedAttribute]
internal void set_DocumentIds(IEnumerable`1<DocumentId> value);
    [CompilerGeneratedAttribute]
public SourceText get_MergedSourceText();
    [CompilerGeneratedAttribute]
internal void set_MergedSourceText(SourceText value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<TextSpan> get_MergeConflictResolutionSpans();
    public bool get_HasMergeConflicts();
}
internal class Microsoft.CodeAnalysis.LinkedFileMergeSessionResult : object {
    [CompilerGeneratedAttribute]
private Solution <MergedSolution>k__BackingField;
    private Dictionary`2<DocumentId, IEnumerable`1<TextSpan>> _mergeConflictCommentSpans;
    public Solution MergedSolution { get; }
    public Dictionary`2<DocumentId, IEnumerable`1<TextSpan>> MergeConflictCommentSpans { get; }
    public LinkedFileMergeSessionResult(Solution mergedSolution, IEnumerable`1<LinkedFileMergeResult> fileMergeResults);
    [CompilerGeneratedAttribute]
public Solution get_MergedSolution();
    public Dictionary`2<DocumentId, IEnumerable`1<TextSpan>> get_MergeConflictCommentSpans();
}
internal class Microsoft.CodeAnalysis.MetadataOnlyImage : object {
    public static MetadataOnlyImage Empty;
    private static EmitOptions s_emitOptions;
    private ITemporaryStreamStorage _storage;
    private string _assemblyName;
    private static ConditionalWeakTable`2<AssemblyMetadata, ISupportDirectMemoryAccess> s_lifetime;
    public bool IsEmpty { get; }
    private MetadataOnlyImage(ITemporaryStreamStorage storage, string assemblyName);
    private static MetadataOnlyImage();
    public bool get_IsEmpty();
    public static MetadataOnlyImage Create(Workspace workspace, ITemporaryStorageService service, Compilation compilation, CancellationToken cancellationToken);
    public MetadataReference CreateReference(ImmutableArray`1<string> aliases, bool embedInteropTypes, DocumentationProvider documentationProvider);
    public void Cleanup();
}
internal class Microsoft.CodeAnalysis.MetadataOnlyReference : object {
    private static ConditionalWeakTable`2<BranchId, ConditionalWeakTable`2<ProjectId, MetadataOnlyReferenceSet>> s_cache;
    private static ConditionalWeakTable`2<Compilation, MetadataOnlyReferenceSet> s_snapshotCache;
    private static CreateValueCallback<BranchId, ConditionalWeakTable`2<ProjectId, MetadataOnlyReferenceSet>> s_createReferenceSetMap;
    private static MetadataOnlyReference();
    internal static MetadataReference GetOrBuildReference(SolutionState solution, ProjectReference projectReference, Compilation finalCompilation, VersionStamp version, CancellationToken cancellationToken);
    internal static bool TryGetReference(SolutionState solution, ProjectReference projectReference, Compilation finalOrDeclarationCompilation, VersionStamp version, MetadataReference& reference);
    private static bool TryGetReferenceFromBranch(BranchId branchId, ProjectReference projectReference, Compilation finalOrDeclarationCompilation, VersionStamp version, MetadataReference& reference);
}
internal class Microsoft.CodeAnalysis.MetadataReferenceManager : object {
    private static ConditionalWeakTable`2<ProjectState, WeakReference`1<Compilation>> s_compilationReferenceMap;
    private static CreateValueCallback<ProjectState, WeakReference`1<Compilation>> s_createValue;
    private static object s_guard;
    private static MetadataReferenceManager();
    internal static Compilation GetCompilationForMetadataReference(ProjectState projectState, Compilation compilation);
    internal static bool TryGetCompilationForMetadataReference(ProjectState projectState, Compilation& referenceCompilation);
}
internal class Microsoft.CodeAnalysis.NamingStyles.NamingStyle : ValueType {
    [CompilerGeneratedAttribute]
private Guid <ID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WordSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private Capitalization <CapitalizationScheme>k__BackingField;
    private static Func`3<string, TextSpan, bool> s_firstCharIsLowerCase;
    private static Func`3<string, TextSpan, bool> s_firstCharIsUpperCase;
    private static Func`3<string, TextSpan, bool> s_wordIsAllUpperCase;
    private static Func`3<string, TextSpan, bool> s_wordIsAllLowerCase;
    public Guid ID { get; }
    public string Name { get; }
    public string Prefix { get; }
    public string Suffix { get; }
    public string WordSeparator { get; }
    public Capitalization CapitalizationScheme { get; }
    public NamingStyle(Guid id, string name, string prefix, string suffix, string wordSeparator, Capitalization capitalizationScheme);
    private static NamingStyle();
    [CompilerGeneratedAttribute]
public Guid get_ID();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public string get_Suffix();
    [CompilerGeneratedAttribute]
public string get_WordSeparator();
    [CompilerGeneratedAttribute]
public Capitalization get_CapitalizationScheme();
    public NamingStyle With(Optional`1<string> name, Optional`1<string> prefix, Optional`1<string> suffix, Optional`1<string> wordSeparator, Optional`1<Capitalization> capitalizationScheme);
    public string CreateName(ImmutableArray`1<string> words);
    private IEnumerable`1<string> ApplyCapitalization(IEnumerable`1<string> words);
    private string CapitalizeFirstLetter(string word);
    private string DecapitalizeFirstLetter(string word);
    public bool IsNameCompliant(string name, String& failureReason);
    private WordSpanEnumerable GetWordSpans(string name, TextSpan nameSpan);
    private static string Substring(string name, TextSpan wordSpan);
    private bool CheckAllWords(string name, TextSpan nameSpan, Func`3<string, TextSpan, bool> wordCheck, string resourceId, String& reason);
    private bool CheckPascalCase(string name, TextSpan nameSpan, String& reason);
    private bool CheckAllUpper(string name, TextSpan nameSpan, String& reason);
    private bool CheckAllLower(string name, TextSpan nameSpan, String& reason);
    private bool CheckFirstAndRestWords(string name, TextSpan nameSpan, Func`3<string, TextSpan, bool> firstWordCheck, Func`3<string, TextSpan, bool> restWordCheck, string firstResourceId, string restResourceId, String& reason);
    private bool CheckCamelCase(string name, TextSpan nameSpan, String& reason);
    private bool CheckFirstUpper(string name, TextSpan nameSpan, String& reason);
    private static bool DoesCharacterHaveCasing(char c);
    private string CreateCompliantNameDirectly(string name);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.NamingStyles.NamingStyle/<MakeCompliant>d__40")]
public IEnumerable`1<string> MakeCompliant(string name);
    private string CreateCompliantNameReusingPartialPrefixesAndSuffixes(string name);
    private static string StripCommonPrefixes(string name);
    private string FinishFixingName(string name);
    private string EnsureSuffix(string name);
    private string EnsurePrefix(string name);
    internal XElement CreateXElement();
    internal static NamingStyle FromXElement(XElement namingStyleElement);
}
internal abstract class Microsoft.CodeAnalysis.Notification.AbstractGlobalOperationNotificationService : object {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Stopped(EventHandler`1<GlobalOperationEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Stopped(EventHandler`1<GlobalOperationEventArgs> value);
    public abstract virtual GlobalOperationRegistration Start(string reason);
    public abstract virtual void Cancel(GlobalOperationRegistration registration);
    public abstract virtual void Done(GlobalOperationRegistration registration);
}
internal class Microsoft.CodeAnalysis.Notification.GlobalOperationEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Operations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Cancelled>k__BackingField;
    public IReadOnlyList`1<string> Operations { get; }
    public bool Cancelled { get; }
    public GlobalOperationEventArgs(IReadOnlyList`1<string> operations, bool cancelled);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Operations();
    [CompilerGeneratedAttribute]
public bool get_Cancelled();
}
internal class Microsoft.CodeAnalysis.Notification.GlobalOperationNotificationService : AbstractGlobalOperationNotificationService {
    private static string GlobalOperationStartedEventName;
    private static string GlobalOperationStoppedEventName;
    private object _gate;
    private HashSet`1<GlobalOperationRegistration> _registrations;
    private HashSet`1<string> _operations;
    private SimpleTaskQueue _eventQueue;
    private EventMap _eventMap;
    private IAsynchronousOperationListener _listener;
    public GlobalOperationNotificationService(IAsynchronousOperationListener listener);
    public virtual GlobalOperationRegistration Start(string operation);
    protected virtual Task RaiseGlobalOperationStarted();
    protected virtual Task RaiseGlobalOperationStopped(IReadOnlyList`1<string> operations, bool cancelled);
    public virtual void add_Started(EventHandler value);
    public virtual void remove_Started(EventHandler value);
    public virtual void add_Stopped(EventHandler`1<GlobalOperationEventArgs> value);
    public virtual void remove_Stopped(EventHandler`1<GlobalOperationEventArgs> value);
    public virtual void Cancel(GlobalOperationRegistration registration);
    public virtual void Done(GlobalOperationRegistration registration);
    protected virtual override void Finalize();
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Notification.IGlobalOperationNotificationService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Notification.GlobalOperationNotificationServiceFactory : object {
    private IAsynchronousOperationListener _listener;
    private IGlobalOperationNotificationService _singleton;
    [ImportingConstructorAttribute]
public GlobalOperationNotificationServiceFactory(IAsynchronousOperationListenerProvider listenerProvider);
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal class Microsoft.CodeAnalysis.Notification.GlobalOperationRegistration : object {
    private AbstractGlobalOperationNotificationService _service;
    private CancellationTokenSource _source;
    private IDisposable _logging;
    private bool _done;
    [CompilerGeneratedAttribute]
private string <Operation>k__BackingField;
    public string Operation { get; }
    public GlobalOperationRegistration(AbstractGlobalOperationNotificationService service, string operation);
    [CompilerGeneratedAttribute]
public string get_Operation();
    public void Done();
    public sealed virtual void Dispose();
}
internal interface Microsoft.CodeAnalysis.Notification.IGlobalOperationNotificationService {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Stopped(EventHandler`1<GlobalOperationEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Stopped(EventHandler`1<GlobalOperationEventArgs> value);
    public abstract virtual GlobalOperationRegistration Start(string operation);
}
public class Microsoft.CodeAnalysis.Options.DocumentOptionSet : OptionSet {
    private OptionSet _backingOptionSet;
    private string _language;
    internal DocumentOptionSet(OptionSet backingOptionSet, string language);
    public virtual object GetOption(OptionKey optionKey);
    public T GetOption(PerLanguageOption`1<T> option);
    public virtual OptionSet WithChangedOption(OptionKey optionAndLanguage, object value);
    internal virtual IEnumerable`1<OptionKey> GetChangedOptions(OptionSet optionSet);
}
internal static class Microsoft.CodeAnalysis.Options.EditorConfigStorageLocation : object {
    private static Func`2<string, Optional`1<bool>> s_parseBool;
    private static Func`2<string, Optional`1<int>> s_parseInt32;
    private static Func`2<string, Optional`1<CodeStyleOption`1<bool>>> s_parseBoolCodeStyleOption;
    private static Func`2<string, Optional`1<CodeStyleOption`1<string>>> s_parseStringCodeStyleOption;
    private static EditorConfigStorageLocation();
    public static EditorConfigStorageLocation`1<bool> ForBoolOption(string keyName);
    public static EditorConfigStorageLocation`1<int> ForInt32Option(string keyName);
    public static EditorConfigStorageLocation`1<CodeStyleOption`1<bool>> ForBoolCodeStyleOption(string keyName);
    public static EditorConfigStorageLocation`1<CodeStyleOption`1<string>> ForStringCodeStyleOption(string keyName);
    private static Optional`1<bool> ParseBool(string str);
    private static Optional`1<int> ParseInt32(string str);
    private static Optional`1<CodeStyleOption`1<bool>> ParseBoolCodeStyleOption(string str);
    private static Optional`1<CodeStyleOption`1<string>> ParseStringCodeStyleOption(string str);
}
internal class Microsoft.CodeAnalysis.Options.EditorConfigStorageLocation`1 : OptionStorageLocation {
    [CompilerGeneratedAttribute]
private string <KeyName>k__BackingField;
    private Func`3<string, Type, Optional`1<T>> _parseValue;
    public string KeyName { get; }
    public EditorConfigStorageLocation`1(string keyName, Func`2<string, Optional`1<T>> parseValue);
    [CompilerGeneratedAttribute]
public string get_KeyName();
    public sealed virtual bool TryGetOption(object underlyingOption, IReadOnlyDictionary`2<string, object> allRawConventions, Type type, Object& result);
}
[ExportAttribute("Microsoft.CodeAnalysis.Options.IGlobalOptionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Options.GlobalOptionService : object {
    private Lazy`1<HashSet`1<IOption>> _options;
    private ImmutableArray`1<Lazy`1<IOptionPersister>> _optionSerializers;
    private object _gate;
    private ImmutableDictionary`2<OptionKey, object> _currentValues;
    [CompilerGeneratedAttribute]
private EventHandler`1<OptionChangedEventArgs> OptionChanged;
    [ImportingConstructorAttribute]
public GlobalOptionService(IEnumerable`1<Lazy`1<IOptionProvider>> optionProviders, IEnumerable`1<Lazy`1<IOptionPersister>> optionSerializers);
    private object LoadOptionFromSerializerOrGetDefault(OptionKey optionKey);
    public sealed virtual IEnumerable`1<IOption> GetRegisteredOptions();
    public sealed virtual T GetOption(Option`1<T> option);
    public sealed virtual T GetOption(PerLanguageOption`1<T> option, string language);
    public sealed virtual object GetOption(OptionKey optionKey);
    public sealed virtual void SetOptions(OptionSet optionSet);
    public sealed virtual void RefreshOption(OptionKey optionKey, object newValue);
    private void RaiseEvents(List`1<OptionChangedEventArgs> changedOptions);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OptionChanged(EventHandler`1<OptionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OptionChanged(EventHandler`1<OptionChangedEventArgs> value);
}
internal interface Microsoft.CodeAnalysis.Options.IDocumentOptions {
    public abstract virtual bool TryGetDocumentOption(OptionKey option, OptionSet underlyingOptions, Object& value);
}
internal interface Microsoft.CodeAnalysis.Options.IDocumentOptionsProvider {
    public abstract virtual Task`1<IDocumentOptions> GetOptionsForDocumentAsync(Document document, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Options.IDocumentOptionsProviderFactory {
    public abstract virtual IDocumentOptionsProvider Create(Workspace workspace);
}
internal interface Microsoft.CodeAnalysis.Options.IEditorConfigStorageLocation {
    public abstract virtual bool TryGetOption(object underlyingOption, IReadOnlyDictionary`2<string, object> allRawConventions, Type type, Object& value);
}
internal interface Microsoft.CodeAnalysis.Options.IGlobalOptionService {
    public abstract virtual T GetOption(Option`1<T> option);
    public abstract virtual T GetOption(PerLanguageOption`1<T> option, string languageName);
    public abstract virtual object GetOption(OptionKey optionKey);
    public abstract virtual void SetOptions(OptionSet optionSet);
    public abstract virtual IEnumerable`1<IOption> GetRegisteredOptions();
    [CompilerGeneratedAttribute]
public abstract virtual void add_OptionChanged(EventHandler`1<OptionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OptionChanged(EventHandler`1<OptionChangedEventArgs> value);
    public abstract virtual void RefreshOption(OptionKey optionKey, object newValue);
}
public interface Microsoft.CodeAnalysis.Options.IOption {
    public string Feature { get; }
    public string Name { get; }
    public Type Type { get; }
    public object DefaultValue { get; }
    public bool IsPerLanguage { get; }
    public ImmutableArray`1<OptionStorageLocation> StorageLocations { get; }
    public abstract virtual string get_Feature();
    public abstract virtual string get_Name();
    public abstract virtual Type get_Type();
    public abstract virtual object get_DefaultValue();
    public abstract virtual bool get_IsPerLanguage();
    public abstract virtual ImmutableArray`1<OptionStorageLocation> get_StorageLocations();
}
internal interface Microsoft.CodeAnalysis.Options.IOptionPersister {
    public abstract virtual bool TryFetch(OptionKey optionKey, Object& value);
    public abstract virtual bool TryPersist(OptionKey optionKey, object value);
}
internal interface Microsoft.CodeAnalysis.Options.IOptionService {
    public abstract virtual T GetOption(Option`1<T> option);
    public abstract virtual T GetOption(PerLanguageOption`1<T> option, string languageName);
    public abstract virtual object GetOption(OptionKey optionKey);
    public abstract virtual OptionSet GetOptions();
    public abstract virtual void SetOptions(OptionSet optionSet);
    public abstract virtual IEnumerable`1<IOption> GetRegisteredOptions();
    [CompilerGeneratedAttribute]
public abstract virtual void add_OptionChanged(EventHandler`1<OptionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OptionChanged(EventHandler`1<OptionChangedEventArgs> value);
    public abstract virtual void RegisterDocumentOptionsProvider(IDocumentOptionsProvider documentOptionsProvider);
    public abstract virtual Task`1<OptionSet> GetUpdatedOptionSetForDocumentAsync(Document document, OptionSet optionSet, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Options.IWorkspaceOptionService {
    public abstract virtual void OnWorkspaceDisposed(Workspace workspace);
}
internal class Microsoft.CodeAnalysis.Options.LocalUserProfileStorageLocation : OptionStorageLocation {
    [CompilerGeneratedAttribute]
private string <KeyName>k__BackingField;
    public string KeyName { get; }
    public LocalUserProfileStorageLocation(string keyName);
    [CompilerGeneratedAttribute]
public string get_KeyName();
}
internal class Microsoft.CodeAnalysis.Options.NamingStylePreferenceEditorConfigStorageLocation : OptionStorageLocation {
    public sealed virtual bool TryGetOption(object underlyingOption, IReadOnlyDictionary`2<string, object> allRawConventions, Type type, Object& result);
    private static ValueTuple`2<object, bool> ParseDictionary(object underlyingOption, IReadOnlyDictionary`2<string, object> allRawConventions, Type type);
}
public class Microsoft.CodeAnalysis.Options.Option`1 : object {
    [CompilerGeneratedAttribute]
private string <Feature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private T <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<OptionStorageLocation> <StorageLocations>k__BackingField;
    public string Feature { get; }
    public string Name { get; }
    public T DefaultValue { get; }
    public Type Type { get; }
    public ImmutableArray`1<OptionStorageLocation> StorageLocations { get; }
    private object Microsoft.CodeAnalysis.Options.IOption.DefaultValue { get; }
    private bool Microsoft.CodeAnalysis.Options.IOption.IsPerLanguage { get; }
    public Option`1(string feature, string name);
    public Option`1(string feature, string name, T defaultValue);
    public Option`1(string feature, string name, T defaultValue, OptionStorageLocation[] storageLocations);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Feature();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public T get_DefaultValue();
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<OptionStorageLocation> get_StorageLocations();
    private sealed virtual override object Microsoft.CodeAnalysis.Options.IOption.get_DefaultValue();
    private sealed virtual override bool Microsoft.CodeAnalysis.Options.IOption.get_IsPerLanguage();
    public virtual string ToString();
    public static OptionKey op_Implicit(Option`1<T> option);
}
internal class Microsoft.CodeAnalysis.Options.OptionChangedEventArgs : EventArgs {
    private OptionKey _optionKey;
    private object _value;
    public IOption Option { get; }
    public string Language { get; }
    public object Value { get; }
    internal OptionChangedEventArgs(OptionKey optionKey, object value);
    public IOption get_Option();
    public string get_Language();
    public object get_Value();
}
public class Microsoft.CodeAnalysis.Options.OptionKey : ValueType {
    [CompilerGeneratedAttribute]
private IOption <Option>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public IOption Option { get; }
    public string Language { get; }
    public OptionKey(IOption option, string language);
    [CompilerGeneratedAttribute]
public IOption get_Option();
    [CompilerGeneratedAttribute]
public string get_Language();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OptionKey other);
    public virtual int GetHashCode();
    public static bool op_Equality(OptionKey left, OptionKey right);
    public static bool op_Inequality(OptionKey left, OptionKey right);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Options.IOptionService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Options.OptionServiceFactory : object {
    private IGlobalOptionService _globalOptionService;
    [ImportingConstructorAttribute]
public OptionServiceFactory(IGlobalOptionService globalOptionService);
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
public abstract class Microsoft.CodeAnalysis.Options.OptionSet : object {
    public abstract virtual object GetOption(OptionKey optionKey);
    public T GetOption(Option`1<T> option);
    public T GetOption(PerLanguageOption`1<T> option, string language);
    public abstract virtual OptionSet WithChangedOption(OptionKey optionAndLanguage, object value);
    public OptionSet WithChangedOption(Option`1<T> option, T value);
    public OptionSet WithChangedOption(PerLanguageOption`1<T> option, string language, T value);
    internal abstract virtual IEnumerable`1<OptionKey> GetChangedOptions(OptionSet optionSet);
}
public abstract class Microsoft.CodeAnalysis.Options.OptionStorageLocation : object {
}
public class Microsoft.CodeAnalysis.Options.PerLanguageOption`1 : object {
    [CompilerGeneratedAttribute]
private string <Feature>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private T <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<OptionStorageLocation> <StorageLocations>k__BackingField;
    public string Feature { get; }
    public string Name { get; }
    public Type Type { get; }
    public T DefaultValue { get; }
    public ImmutableArray`1<OptionStorageLocation> StorageLocations { get; }
    private object Microsoft.CodeAnalysis.Options.IOption.DefaultValue { get; }
    private bool Microsoft.CodeAnalysis.Options.IOption.IsPerLanguage { get; }
    public PerLanguageOption`1(string feature, string name, T defaultValue);
    public PerLanguageOption`1(string feature, string name, T defaultValue, OptionStorageLocation[] storageLocations);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Feature();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public T get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<OptionStorageLocation> get_StorageLocations();
    private sealed virtual override object Microsoft.CodeAnalysis.Options.IOption.get_DefaultValue();
    private sealed virtual override bool Microsoft.CodeAnalysis.Options.IOption.get_IsPerLanguage();
    public virtual string ToString();
}
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.Options.Providers.ExportOptionProviderAttribute : ExportAttribute {
}
internal interface Microsoft.CodeAnalysis.Options.Providers.IOptionProvider {
    public ImmutableArray`1<IOption> Options { get; }
    public abstract virtual ImmutableArray`1<IOption> get_Options();
}
internal class Microsoft.CodeAnalysis.Options.RoamingProfileStorageLocation : OptionStorageLocation {
    private Func`2<string, string> _keyNameFromLanguageName;
    public RoamingProfileStorageLocation(string keyName);
    public RoamingProfileStorageLocation(Func`2<string, string> keyNameFromLanguageName);
    public string GetKeyNameForLanguage(string languageName);
}
internal class Microsoft.CodeAnalysis.Options.WorkspaceOptionSet : OptionSet {
    private IOptionService _service;
    private object _gate;
    private ImmutableDictionary`2<OptionKey, object> _values;
    internal WorkspaceOptionSet(IOptionService service);
    private WorkspaceOptionSet(IOptionService service, ImmutableDictionary`2<OptionKey, object> values);
    public virtual object GetOption(OptionKey optionKey);
    public virtual OptionSet WithChangedOption(OptionKey optionAndLanguage, object value);
    internal IEnumerable`1<OptionKey> GetAccessedOptions();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Options.WorkspaceOptionSet/<GetChangedOptions>d__8")]
internal virtual IEnumerable`1<OptionKey> GetChangedOptions(OptionSet optionSet);
}
internal class Microsoft.CodeAnalysis.OrderableMetadata : object {
    [CompilerGeneratedAttribute]
private object <After>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Before>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <AfterTyped>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <BeforeTyped>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public object After { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public object Before { get; }
    internal IEnumerable`1<string> AfterTyped { get; internal set; }
    internal IEnumerable`1<string> BeforeTyped { get; internal set; }
    public string Name { get; }
    private IEnumerable`1<string> Microsoft.CodeAnalysis.IOrderableMetadata.After { get; }
    private IEnumerable`1<string> Microsoft.CodeAnalysis.IOrderableMetadata.Before { get; }
    public OrderableMetadata(IDictionary`2<string, object> data);
    public OrderableMetadata(string name, IEnumerable`1<string> after, IEnumerable`1<string> before);
    [CompilerGeneratedAttribute]
public object get_After();
    [CompilerGeneratedAttribute]
public object get_Before();
    [CompilerGeneratedAttribute]
internal IEnumerable`1<string> get_AfterTyped();
    [CompilerGeneratedAttribute]
internal void set_AfterTyped(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
internal IEnumerable`1<string> get_BeforeTyped();
    [CompilerGeneratedAttribute]
internal void set_BeforeTyped(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    private sealed virtual override IEnumerable`1<string> Microsoft.CodeAnalysis.IOrderableMetadata.get_After();
    private sealed virtual override IEnumerable`1<string> Microsoft.CodeAnalysis.IOrderableMetadata.get_Before();
}
internal interface Microsoft.CodeAnalysis.Packaging.IPackageInstallerService {
    public ImmutableArray`1<PackageSource> PackageSources { get; }
    public abstract virtual bool IsEnabled(ProjectId projectId);
    public abstract virtual bool IsInstalled(Workspace workspace, ProjectId projectId, string packageName);
    public abstract virtual bool TryInstallPackage(Workspace workspace, DocumentId documentId, string source, string packageName, string versionOpt, bool includePrerelease, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<string> GetInstalledVersions(string packageName);
    public abstract virtual IEnumerable`1<Project> GetProjectsWithInstalledPackage(Solution solution, string packageName, string version);
    public abstract virtual void ShowManagePackagesDialog(string packageName);
    public abstract virtual ImmutableArray`1<PackageSource> get_PackageSources();
    [CompilerGeneratedAttribute]
public abstract virtual void add_PackageSourcesChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PackageSourcesChanged(EventHandler value);
}
internal class Microsoft.CodeAnalysis.Packaging.PackageSource : ValueType {
    public string Name;
    public string Source;
    public PackageSource(string name, string source);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PackageSource other);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.PatternMatching.PatternMatch : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsCaseSensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private PatternMatchKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TextSpan> <MatchedSpans>k__BackingField;
    private bool _punctuationStripped;
    public bool IsCaseSensitive { get; }
    public PatternMatchKind Kind { get; }
    public ImmutableArray`1<TextSpan> MatchedSpans { get; }
    internal PatternMatch(PatternMatchKind resultType, bool punctuationStripped, bool isCaseSensitive, Nullable`1<TextSpan> matchedSpan);
    internal PatternMatch(PatternMatchKind resultType, bool punctuationStripped, bool isCaseSensitive, ImmutableArray`1<TextSpan> matchedSpans);
    [CompilerGeneratedAttribute]
public bool get_IsCaseSensitive();
    [CompilerGeneratedAttribute]
public PatternMatchKind get_Kind();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TextSpan> get_MatchedSpans();
    public PatternMatch WithMatchedSpans(ImmutableArray`1<TextSpan> matchedSpans);
    public sealed virtual int CompareTo(PatternMatch other);
    public int CompareTo(PatternMatch other, bool ignoreCase);
    private static int ComparePunctuation(PatternMatch result1, PatternMatch result2);
    private static int CompareCase(PatternMatch result1, PatternMatch result2, bool ignoreCase);
    private static int CompareType(PatternMatch result1, PatternMatch result2);
}
internal abstract class Microsoft.CodeAnalysis.PatternMatching.PatternMatcher : object {
    private static Char[] s_dotCharacterArray;
    public static int NoBonus;
    public static int CamelCaseContiguousBonus;
    public static int CamelCaseMatchesFromStartBonus;
    public static int CamelCaseMaxWeight;
    private bool _includeMatchedSpans;
    private bool _allowFuzzyMatching;
    private CompareInfo _compareInfo;
    private TextInfo _textInfo;
    private bool _invalidPattern;
    protected PatternMatcher(bool includeMatchedSpans, CultureInfo culture, bool allowFuzzyMatching);
    private static PatternMatcher();
    private static PatternMatchKind GetCamelCaseKind(CamelCaseResult result, ArrayBuilder`1<TextSpan> candidateHumps);
    public virtual void Dispose();
    public static PatternMatcher CreatePatternMatcher(string pattern, CultureInfo culture, bool includeMatchedSpans, bool allowFuzzyMatching);
    public static PatternMatcher CreateContainerPatternMatcher(String[] patternParts, Char[] containerSplitCharacters, CultureInfo culture, bool allowFuzzyMatching);
    public static PatternMatcher CreateDotSeparatedContainerMatcher(string pattern, CultureInfo culture, bool allowFuzzyMatching);
    internal static ValueTuple`2<string, string> GetNameAndContainer(string pattern);
    public abstract virtual bool AddMatches(string candidate, ArrayBuilder`1<PatternMatch> matches);
    private bool SkipMatch(string candidate);
    private static bool ContainsUpperCaseLetter(string pattern);
    private Nullable`1<PatternMatch> MatchPatternChunk(string candidate, TextChunk patternChunk, bool punctuationStripped, bool fuzzyMatch);
    private Nullable`1<PatternMatch> FuzzyMatchPatternChunk(string candidate, TextChunk patternChunk, bool punctuationStripped);
    private Nullable`1<PatternMatch> NonFuzzyMatchPatternChunk(string candidate, TextChunk patternChunk, bool punctuationStripped);
    private Nullable`1<TextSpan> GetMatchedSpan(int start, int length);
    private static bool ContainsSpaceOrAsterisk(string text);
    private bool MatchPatternSegment(string candidate, PatternSegment segment, ArrayBuilder`1<PatternMatch> matches, bool fuzzyMatch);
    private static bool IsWordChar(char ch);
    private bool PartStartsWith(string candidate, TextSpan candidatePart, string pattern, TextSpan patternPart, CompareOptions compareOptions);
    private bool PartStartsWith(string candidate, TextSpan candidatePart, string pattern, CompareOptions compareOptions);
    private Nullable`1<PatternMatch> TryCamelCaseMatch(string candidate, TextChunk patternChunk, bool punctuationStripped, bool isLowercase, ArrayBuilder`1<TextSpan> candidateHumps);
    private Nullable`1<PatternMatchKind> TryAllLowerCamelCaseMatch(string candidate, ArrayBuilder`1<TextSpan> candidateHumps, TextChunk patternChunk, ImmutableArray`1& matchedSpans);
    private Nullable`1<PatternMatchKind> TryUpperCaseCamelCaseMatch(string candidate, ArrayBuilder`1<TextSpan> candidateHumps, TextChunk patternChunk, CompareOptions compareOption, ImmutableArray`1& matchedSpans);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.PatternMatching.PatternMatcherExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<PatternMatch> GetFirstMatch(PatternMatcher matcher, string candidate);
    [ExtensionAttribute]
public static bool Matches(PatternMatcher matcher, string candidate);
}
internal enum Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind : Enum {
    public int value__;
    public static PatternMatchKind Exact;
    public static PatternMatchKind Prefix;
    public static PatternMatchKind Substring;
    public static PatternMatchKind CamelCaseExact;
    public static PatternMatchKind CamelCasePrefix;
    public static PatternMatchKind CamelCaseNonContiguousPrefix;
    public static PatternMatchKind CamelCaseSubstring;
    public static PatternMatchKind CamelCaseNonContiguousSubstring;
    public static PatternMatchKind Fuzzy;
}
internal class Microsoft.CodeAnalysis.PooledObject`1 : ValueType {
    private Action`2<ObjectPool`1<T>, T> _releaser;
    private ObjectPool`1<T> _pool;
    private T _pooledObject;
    public T Object { get; }
    public PooledObject`1(ObjectPool`1<T> pool, Func`2<ObjectPool`1<T>, T> allocator, Action`2<ObjectPool`1<T>, T> releaser);
    public T get_Object();
    public sealed virtual void Dispose();
    public static PooledObject`1<StringBuilder> Create(ObjectPool`1<StringBuilder> pool);
    public static PooledObject`1<Stopwatch> Create(ObjectPool`1<Stopwatch> pool);
    public static PooledObject`1<Stack`1<TItem>> Create(ObjectPool`1<Stack`1<TItem>> pool);
    public static PooledObject`1<Queue`1<TItem>> Create(ObjectPool`1<Queue`1<TItem>> pool);
    public static PooledObject`1<HashSet`1<TItem>> Create(ObjectPool`1<HashSet`1<TItem>> pool);
    public static PooledObject`1<Dictionary`2<TKey, TValue>> Create(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    public static PooledObject`1<List`1<TItem>> Create(ObjectPool`1<List`1<TItem>> pool);
    private static StringBuilder Allocator(ObjectPool`1<StringBuilder> pool);
    private static void Releaser(ObjectPool`1<StringBuilder> pool, StringBuilder sb);
    private static Stopwatch Allocator(ObjectPool`1<Stopwatch> pool);
    private static void Releaser(ObjectPool`1<Stopwatch> pool, Stopwatch sb);
    private static Stack`1<TItem> Allocator(ObjectPool`1<Stack`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<Stack`1<TItem>> pool, Stack`1<TItem> obj);
    private static Queue`1<TItem> Allocator(ObjectPool`1<Queue`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<Queue`1<TItem>> pool, Queue`1<TItem> obj);
    private static HashSet`1<TItem> Allocator(ObjectPool`1<HashSet`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<HashSet`1<TItem>> pool, HashSet`1<TItem> obj);
    private static Dictionary`2<TKey, TValue> Allocator(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    private static void Releaser(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2<TKey, TValue> obj);
    private static List`1<TItem> Allocator(ObjectPool`1<List`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<List`1<TItem>> pool, List`1<TItem> obj);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count,nq}")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1/DebuggerProxy")]
internal class Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1 : object {
    private Builder<T> _builder;
    private ObjectPool`1<ArrayBuilder`1<T>> _pool;
    private static ObjectPool`1<ArrayBuilder`1<T>> s_poolInstance;
    public int Count { get; public set; }
    public T Item { get; public set; }
    public ArrayBuilder`1(int size);
    private ArrayBuilder`1(ObjectPool`1<ArrayBuilder`1<T>> pool);
    private static ArrayBuilder`1();
    public ImmutableArray`1<T> ToImmutable();
    public sealed virtual int get_Count();
    public void set_Count(int value);
    public sealed virtual T get_Item(int index);
    public void set_Item(int index, T value);
    public void SetItem(int index, T value);
    public void Add(T item);
    public void Insert(int index, T item);
    public void EnsureCapacity(int capacity);
    public void Clear();
    public bool Contains(T item);
    public int IndexOf(T item);
    public int IndexOf(T item, IEqualityComparer`1<T> equalityComparer);
    public int IndexOf(T item, int startIndex, int count);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public void RemoveAt(int index);
    public void RemoveLast();
    public void ReverseContents();
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> compare);
    public void Sort(int startIndex, IComparer`1<T> comparer);
    public T[] ToArray();
    public void CopyTo(T[] array, int start);
    public T Last();
    public T First();
    public bool Any();
    public ImmutableArray`1<T> ToImmutableOrNull();
    public ImmutableArray`1<U> ToDowncastedImmutable();
    public ImmutableArray`1<T> ToImmutableAndFree();
    public T[] ToArrayAndFree();
    public void Free();
    public static ArrayBuilder`1<T> GetInstance();
    public static ArrayBuilder`1<T> GetInstance(int capacity);
    public static ArrayBuilder`1<T> GetInstance(int capacity, T fillWithValue);
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool();
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool(int size);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    public void AddRange(ArrayBuilder`1<T> items);
    public void AddRange(ArrayBuilder`1<U> items);
    public void AddRange(ImmutableArray`1<T> items);
    public void AddRange(ImmutableArray`1<T> items, int length);
    public void AddRange(ImmutableArray`1<S> items);
    public void AddRange(T[] items, int start, int length);
    public void AddRange(IEnumerable`1<T> items);
    public void AddRange(T[] items);
    public void AddRange(T[] items, int length);
    public void Clip(int limit);
    public void ZeroInit(int count);
    public void AddMany(T item, int count);
    public void RemoveDuplicates();
    public ImmutableArray`1<S> SelectDistinct(Func`2<T, S> selector);
}
internal class Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1 : object {
    private T _firstItem;
    private Element[] _items;
    private Factory<T> _factory;
    internal ObjectPool`1(Factory<T> factory);
    internal ObjectPool`1(Factory<T> factory, int size);
    private T CreateInstance();
    internal T Allocate();
    private T AllocateSlow();
    internal void Free(T obj);
    private void FreeSlow(T obj);
    [ConditionalAttribute("DEBUG")]
internal void ForgetTrackedObject(T old, T replacement);
    [ConditionalAttribute("DEBUG")]
private void Validate(object obj);
}
internal class Microsoft.CodeAnalysis.PooledObjects.PooledDictionary`2 : Dictionary`2<K, V> {
    private ObjectPool`1<PooledDictionary`2<K, V>> _pool;
    private static ObjectPool`1<PooledDictionary`2<K, V>> s_poolInstance;
    private PooledDictionary`2(ObjectPool`1<PooledDictionary`2<K, V>> pool);
    private static PooledDictionary`2();
    public ImmutableDictionary`2<K, V> ToImmutableDictionaryAndFree();
    public void Free();
    public static ObjectPool`1<PooledDictionary`2<K, V>> CreatePool();
    public static PooledDictionary`2<K, V> GetInstance();
}
internal class Microsoft.CodeAnalysis.PooledObjects.PooledHashSet`1 : HashSet`1<T> {
    private ObjectPool`1<PooledHashSet`1<T>> _pool;
    private static ObjectPool`1<PooledHashSet`1<T>> s_poolInstance;
    private PooledHashSet`1(ObjectPool`1<PooledHashSet`1<T>> pool);
    private static PooledHashSet`1();
    public void Free();
    public static ObjectPool`1<PooledHashSet`1<T>> CreatePool();
    public static PooledHashSet`1<T> GetInstance();
}
internal class Microsoft.CodeAnalysis.PooledObjects.PooledStopwatch : Stopwatch {
    private static ObjectPool`1<PooledStopwatch> s_poolInstance;
    private ObjectPool`1<PooledStopwatch> _pool;
    private PooledStopwatch(ObjectPool`1<PooledStopwatch> pool);
    private static PooledStopwatch();
    public void Free();
    public static ObjectPool`1<PooledStopwatch> CreatePool();
    public static PooledStopwatch StartInstance();
}
internal class Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder : object {
    public StringBuilder Builder;
    private ObjectPool`1<PooledStringBuilder> _pool;
    private static ObjectPool`1<PooledStringBuilder> s_poolInstance;
    public int Length { get; }
    private PooledStringBuilder(ObjectPool`1<PooledStringBuilder> pool);
    private static PooledStringBuilder();
    public int get_Length();
    public void Free();
    [ObsoleteAttribute("Consider calling ToStringAndFree instead.")]
public string ToString();
    public string ToStringAndFree();
    public string ToStringAndFree(int startIndex, int length);
    public static ObjectPool`1<PooledStringBuilder> CreatePool(int size);
    public static PooledStringBuilder GetInstance();
    public static StringBuilder op_Implicit(PooledStringBuilder obj);
}
public enum Microsoft.CodeAnalysis.PreservationMode : Enum {
    public int value__;
    public static PreservationMode PreserveValue;
    public static PreservationMode PreserveIdentity;
}
[ExportAttribute("Microsoft.CodeAnalysis.PrimaryWorkspace")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.PrimaryWorkspace : object {
    private ReaderWriterLockSlim _registryGate;
    private Workspace _primaryWorkspace;
    public Workspace Workspace { get; }
    public Workspace get_Workspace();
    public void Register(Workspace workspace);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.Project : object {
    private Solution _solution;
    private ProjectState _projectState;
    private ImmutableHashMap`2<DocumentId, Document> _idToDocumentMap;
    private ImmutableHashMap`2<DocumentId, TextDocument> _idToAdditionalDocumentMap;
    private static Func`3<DocumentId, Project, Document> s_createDocumentFunction;
    private static Func`3<DocumentId, Project, TextDocument> s_createAdditionalDocumentFunction;
    internal ProjectState State { get; }
    public Solution Solution { get; }
    public ProjectId Id { get; }
    public string FilePath { get; }
    public string OutputFilePath { get; }
    public string OutputRefFilePath { get; }
    public bool SupportsCompilation { get; }
    public HostLanguageServices LanguageServices { get; }
    public string Language { get; }
    public string AssemblyName { get; }
    public string Name { get; }
    public IReadOnlyList`1<MetadataReference> MetadataReferences { get; }
    public IEnumerable`1<ProjectReference> ProjectReferences { get; }
    public IReadOnlyList`1<ProjectReference> AllProjectReferences { get; }
    public IReadOnlyList`1<AnalyzerReference> AnalyzerReferences { get; }
    public AnalyzerOptions AnalyzerOptions { get; }
    public CompilationOptions CompilationOptions { get; }
    public ParseOptions ParseOptions { get; }
    public bool IsSubmission { get; }
    public bool HasDocuments { get; }
    public IReadOnlyList`1<DocumentId> DocumentIds { get; }
    public IReadOnlyList`1<DocumentId> AdditionalDocumentIds { get; }
    public IEnumerable`1<Document> Documents { get; }
    public IEnumerable`1<TextDocument> AdditionalDocuments { get; }
    public VersionStamp Version { get; }
    internal Project(Solution solution, ProjectState projectState);
    private static Project();
    internal ProjectState get_State();
    public Solution get_Solution();
    public ProjectId get_Id();
    public string get_FilePath();
    public string get_OutputFilePath();
    public string get_OutputRefFilePath();
    public bool get_SupportsCompilation();
    public HostLanguageServices get_LanguageServices();
    public string get_Language();
    public string get_AssemblyName();
    public string get_Name();
    public IReadOnlyList`1<MetadataReference> get_MetadataReferences();
    public IEnumerable`1<ProjectReference> get_ProjectReferences();
    public IReadOnlyList`1<ProjectReference> get_AllProjectReferences();
    public IReadOnlyList`1<AnalyzerReference> get_AnalyzerReferences();
    public AnalyzerOptions get_AnalyzerOptions();
    public CompilationOptions get_CompilationOptions();
    public ParseOptions get_ParseOptions();
    public bool get_IsSubmission();
    public bool get_HasDocuments();
    public IReadOnlyList`1<DocumentId> get_DocumentIds();
    public IReadOnlyList`1<DocumentId> get_AdditionalDocumentIds();
    public IEnumerable`1<Document> get_Documents();
    public IEnumerable`1<TextDocument> get_AdditionalDocuments();
    public bool ContainsDocument(DocumentId documentId);
    public bool ContainsAdditionalDocument(DocumentId documentId);
    public DocumentId GetDocumentId(SyntaxTree syntaxTree);
    public Document GetDocument(SyntaxTree syntaxTree);
    public Document GetDocument(DocumentId documentId);
    public TextDocument GetAdditionalDocument(DocumentId documentId);
    internal DocumentState GetDocumentState(DocumentId documentId);
    internal TextDocumentState GetAdditionalDocumentState(DocumentId documentId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Project/<ContainsSymbolsWithNameAsync>d__61")]
internal Task`1<bool> ContainsSymbolsWithNameAsync(string name, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Project/<ContainsSymbolsWithNameAsync>d__62")]
internal Task`1<bool> ContainsSymbolsWithNameAsync(Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Project/<GetDocumentsWithNameAsync>d__63")]
internal Task`1<IEnumerable`1<Document>> GetDocumentsWithNameAsync(Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    private static Document CreateDocument(DocumentId documentId, Project project);
    private static TextDocument CreateAdditionalDocument(DocumentId documentId, Project project);
    public bool TryGetCompilation(Compilation& compilation);
    public Task`1<Compilation> GetCompilationAsync(CancellationToken cancellationToken);
    internal Task`1<bool> HasSuccessfullyLoadedAsync(CancellationToken cancellationToken);
    public ProjectChanges GetChanges(Project oldProject);
    public VersionStamp get_Version();
    public Task`1<VersionStamp> GetLatestDocumentVersionAsync(CancellationToken cancellationToken);
    public Task`1<VersionStamp> GetDependentVersionAsync(CancellationToken cancellationToken);
    public Task`1<VersionStamp> GetDependentSemanticVersionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Project/<GetSemanticVersionAsync>d__77")]
public Task`1<VersionStamp> GetSemanticVersionAsync(CancellationToken cancellationToken);
    public Project WithAssemblyName(string assemblyName);
    public Project WithCompilationOptions(CompilationOptions options);
    public Project WithParseOptions(ParseOptions options);
    public Project AddProjectReference(ProjectReference projectReference);
    public Project AddProjectReferences(IEnumerable`1<ProjectReference> projectReferences);
    public Project RemoveProjectReference(ProjectReference projectReference);
    public Project WithProjectReferences(IEnumerable`1<ProjectReference> projectReferences);
    public Project AddMetadataReference(MetadataReference metadataReference);
    public Project AddMetadataReferences(IEnumerable`1<MetadataReference> metadataReferences);
    public Project RemoveMetadataReference(MetadataReference metadataReference);
    public Project WithMetadataReferences(IEnumerable`1<MetadataReference> metadataReferences);
    public Project AddAnalyzerReference(AnalyzerReference analyzerReference);
    public Project AddAnalyzerReferences(IEnumerable`1<AnalyzerReference> analyzerReferences);
    public Project RemoveAnalyzerReference(AnalyzerReference analyzerReference);
    public Project WithAnalyzerReferences(IEnumerable`1<AnalyzerReference> analyzerReferencs);
    public Document AddDocument(string name, SyntaxNode syntaxRoot, IEnumerable`1<string> folders, string filePath);
    public Document AddDocument(string name, SourceText text, IEnumerable`1<string> folders, string filePath);
    public Document AddDocument(string name, string text, IEnumerable`1<string> folders, string filePath);
    public TextDocument AddAdditionalDocument(string name, SourceText text, IEnumerable`1<string> folders, string filePath);
    public TextDocument AddAdditionalDocument(string name, string text, IEnumerable`1<string> folders, string filePath);
    public Project RemoveDocument(DocumentId documentId);
    public Project RemoveAdditionalDocument(DocumentId documentId);
    private string GetDebuggerDisplay();
    [CompilerGeneratedAttribute]
private bool <get_ProjectReferences>b__30_0(ProjectReference pr);
    [CompilerGeneratedAttribute]
private Document <GetDocumentsWithNameAsync>b__63_0(DocumentState s);
}
public class Microsoft.CodeAnalysis.ProjectChanges : ValueType {
    private Project _newProject;
    private Project _oldProject;
    public ProjectId ProjectId { get; }
    public Project OldProject { get; }
    public Project NewProject { get; }
    internal ProjectChanges(Project newProject, Project oldProject);
    public ProjectId get_ProjectId();
    public Project get_OldProject();
    public Project get_NewProject();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetAddedProjectReferences>d__9")]
public IEnumerable`1<ProjectReference> GetAddedProjectReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetRemovedProjectReferences>d__10")]
public IEnumerable`1<ProjectReference> GetRemovedProjectReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetAddedMetadataReferences>d__11")]
public IEnumerable`1<MetadataReference> GetAddedMetadataReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetRemovedMetadataReferences>d__12")]
public IEnumerable`1<MetadataReference> GetRemovedMetadataReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetAddedAnalyzerReferences>d__13")]
public IEnumerable`1<AnalyzerReference> GetAddedAnalyzerReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetRemovedAnalyzerReferences>d__14")]
public IEnumerable`1<AnalyzerReference> GetRemovedAnalyzerReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetAddedDocuments>d__15")]
public IEnumerable`1<DocumentId> GetAddedDocuments();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetAddedAdditionalDocuments>d__16")]
public IEnumerable`1<DocumentId> GetAddedAdditionalDocuments();
    public IEnumerable`1<DocumentId> GetChangedDocuments();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetChangedDocuments>d__18")]
public IEnumerable`1<DocumentId> GetChangedDocuments(bool onlyGetDocumentsWithTextChanges);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetChangedAdditionalDocuments>d__19")]
public IEnumerable`1<DocumentId> GetChangedAdditionalDocuments();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetRemovedDocuments>d__20")]
public IEnumerable`1<DocumentId> GetRemovedDocuments();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetRemovedAdditionalDocuments>d__21")]
public IEnumerable`1<DocumentId> GetRemovedAdditionalDocuments();
}
public class Microsoft.CodeAnalysis.ProjectDependencyGraph : object {
    private ImmutableHashSet`1<ProjectId> _projectIds;
    private ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> _referencesMap;
    private NonReentrantLock _dataLock;
    private ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> _lazyReverseReferencesMap;
    private ImmutableArray`1<ProjectId> _lazyTopologicallySortedProjects;
    private ImmutableArray`1<IEnumerable`1<ProjectId>> _lazyDependencySets;
    private ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> _transitiveReferencesMap;
    private ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> _reverseTransitiveReferencesMap;
    internal static ProjectDependencyGraph Empty;
    internal ProjectDependencyGraph(ImmutableHashSet`1<ProjectId> projectIds, ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> referencesMap);
    private ProjectDependencyGraph(ImmutableHashSet`1<ProjectId> projectIds, ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> referencesMap, ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> reverseReferencesMap, ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> transitiveReferencesMap, ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> reverseTransitiveReferencesMap, ImmutableArray`1<ProjectId> topologicallySortedProjects, ImmutableArray`1<IEnumerable`1<ProjectId>> dependencySets);
    private static ProjectDependencyGraph();
    internal ProjectDependencyGraph WithAdditionalProjects(IEnumerable`1<ProjectId> projectIds);
    internal ProjectDependencyGraph WithAdditionalProjectReferences(ProjectId projectId, IReadOnlyList`1<ProjectId> referencedProjectIds);
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeNewReferencesMapForAdditionalProjectReferences(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingReferencesMap, ProjectId projectId, IReadOnlyList`1<ProjectId> referencedProjectIds);
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeNewReverseReferencesMapForAdditionalProjectReferences(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingReverseReferencesMap, ProjectId projectId, IReadOnlyList`1<ProjectId> referencedProjectIds);
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeNewTransitiveReferencesMapForAdditionalProjectReferences(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingTransitiveReferencesMap, ProjectId projectId, IReadOnlyList`1<ProjectId> referencedProjectIds);
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeNewReverseTransitiveReferencesMapForAdditionalProjectReferences(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingReverseTransitiveReferencesMap, ProjectId projectId, IReadOnlyList`1<ProjectId> referencedProjectIds);
    internal ProjectDependencyGraph WithProjectReferences(ProjectId projectId, IEnumerable`1<ProjectId> referencedProjectIds);
    public IImmutableSet`1<ProjectId> GetProjectsThatThisProjectDirectlyDependsOn(ProjectId projectId);
    public IImmutableSet`1<ProjectId> GetProjectsThatDirectlyDependOnThisProject(ProjectId projectId);
    private ImmutableHashSet`1<ProjectId> GetProjectsThatDirectlyDependOnThisProject_NoLock(ProjectId projectId);
    private ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeReverseReferencesMap();
    public IImmutableSet`1<ProjectId> GetProjectsThatThisProjectTransitivelyDependsOn(ProjectId projectId);
    private ImmutableHashSet`1<ProjectId> GetProjectsThatThisProjectTransitivelyDependsOn_NoLock(ProjectId projectId);
    private void ComputeTransitiveReferences(ProjectId project, HashSet`1<ProjectId> result);
    public IEnumerable`1<ProjectId> GetProjectsThatTransitivelyDependOnThisProject(ProjectId projectId);
    private ImmutableHashSet`1<ProjectId> GetProjectsThatTransitivelyDependOnThisProject_NoLock(ProjectId projectId);
    private void ComputeReverseTransitiveReferences(ProjectId project, HashSet`1<ProjectId> results);
    public IEnumerable`1<ProjectId> GetTopologicallySortedProjects(CancellationToken cancellationToken);
    private void GetTopologicallySortedProjects_NoLock(CancellationToken cancellationToken);
    private void TopologicalSort(IEnumerable`1<ProjectId> projectIds, HashSet`1<ProjectId> seenProjects, List`1<ProjectId> resultList, CancellationToken cancellationToken);
    public IEnumerable`1<IEnumerable`1<ProjectId>> GetDependencySets(CancellationToken cancellationToken);
    private ImmutableArray`1<IEnumerable`1<ProjectId>> GetDependencySets_NoLock(CancellationToken cancellationToken);
    private void ComputeDependencySets(HashSet`1<ProjectId> seenProjects, List`1<IEnumerable`1<ProjectId>> results, CancellationToken cancellationToken);
    private void ComputedDependencySet(ProjectId project, HashSet`1<ProjectId> result);
}
public class Microsoft.CodeAnalysis.ProjectDiagnostic : WorkspaceDiagnostic {
    [CompilerGeneratedAttribute]
private ProjectId <ProjectId>k__BackingField;
    public ProjectId ProjectId { get; }
    public ProjectDiagnostic(WorkspaceDiagnosticKind kind, string message, ProjectId projectId);
    [CompilerGeneratedAttribute]
public ProjectId get_ProjectId();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.ProjectId : object {
    private string _debugName;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public Guid Id { get; }
    internal string DebugName { get; }
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    private ProjectId(Guid guid, string debugName);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    public static ProjectId CreateNewId(string debugName);
    public static ProjectId CreateFromSerialized(Guid id, string debugName);
    internal string get_DebugName();
    private string GetDebuggerDisplay();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProjectId other);
    public static bool op_Equality(ProjectId left, ProjectId right);
    public static bool op_Inequality(ProjectId left, ProjectId right);
    public virtual int GetHashCode();
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    internal static ProjectId ReadFrom(ObjectReader reader);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.ProjectInfo : object {
    [CompilerGeneratedAttribute]
private ProjectAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private CompilationOptions <CompilationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ParseOptions <ParseOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<DocumentInfo> <Documents>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ProjectReference> <ProjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<MetadataReference> <MetadataReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<AnalyzerReference> <AnalyzerReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<DocumentInfo> <AdditionalDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <HostObjectType>k__BackingField;
    internal ProjectAttributes Attributes { get; }
    public ProjectId Id { get; }
    public VersionStamp Version { get; }
    public string Name { get; }
    public string AssemblyName { get; }
    public string Language { get; }
    public string FilePath { get; }
    public string OutputFilePath { get; }
    public string OutputRefFilePath { get; }
    public bool IsSubmission { get; }
    internal bool HasAllInformation { get; }
    public CompilationOptions CompilationOptions { get; }
    public ParseOptions ParseOptions { get; }
    public IReadOnlyList`1<DocumentInfo> Documents { get; }
    public IReadOnlyList`1<ProjectReference> ProjectReferences { get; }
    public IReadOnlyList`1<MetadataReference> MetadataReferences { get; }
    public IReadOnlyList`1<AnalyzerReference> AnalyzerReferences { get; }
    public IReadOnlyList`1<DocumentInfo> AdditionalDocuments { get; }
    public Type HostObjectType { get; }
    private ProjectInfo(ProjectAttributes attributes, CompilationOptions compilationOptions, ParseOptions parseOptions, IEnumerable`1<DocumentInfo> documents, IEnumerable`1<ProjectReference> projectReferences, IEnumerable`1<MetadataReference> metadataReferences, IEnumerable`1<AnalyzerReference> analyzerReferences, IEnumerable`1<DocumentInfo> additionalDocuments, Type hostObjectType);
    [CompilerGeneratedAttribute]
internal ProjectAttributes get_Attributes();
    public ProjectId get_Id();
    public VersionStamp get_Version();
    public string get_Name();
    public string get_AssemblyName();
    public string get_Language();
    public string get_FilePath();
    public string get_OutputFilePath();
    public string get_OutputRefFilePath();
    public bool get_IsSubmission();
    internal bool get_HasAllInformation();
    [CompilerGeneratedAttribute]
public CompilationOptions get_CompilationOptions();
    [CompilerGeneratedAttribute]
public ParseOptions get_ParseOptions();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<DocumentInfo> get_Documents();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ProjectReference> get_ProjectReferences();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<MetadataReference> get_MetadataReferences();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<AnalyzerReference> get_AnalyzerReferences();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<DocumentInfo> get_AdditionalDocuments();
    [CompilerGeneratedAttribute]
public Type get_HostObjectType();
    internal static ProjectInfo Create(ProjectId id, VersionStamp version, string name, string assemblyName, string language, string filePath, string outputFilePath, string outputRefFilePath, CompilationOptions compilationOptions, ParseOptions parseOptions, IEnumerable`1<DocumentInfo> documents, IEnumerable`1<ProjectReference> projectReferences, IEnumerable`1<MetadataReference> metadataReferences, IEnumerable`1<AnalyzerReference> analyzerReferences, IEnumerable`1<DocumentInfo> additionalDocuments, bool isSubmission, Type hostObjectType, bool hasAllInformation);
    public static ProjectInfo Create(ProjectId id, VersionStamp version, string name, string assemblyName, string language, string filePath, string outputFilePath, CompilationOptions compilationOptions, ParseOptions parseOptions, IEnumerable`1<DocumentInfo> documents, IEnumerable`1<ProjectReference> projectReferences, IEnumerable`1<MetadataReference> metadataReferences, IEnumerable`1<AnalyzerReference> analyzerReferences, IEnumerable`1<DocumentInfo> additionalDocuments, bool isSubmission, Type hostObjectType);
    public static ProjectInfo Create(ProjectId id, VersionStamp version, string name, string assemblyName, string language, string filePath, string outputFilePath, CompilationOptions compilationOptions, ParseOptions parseOptions, IEnumerable`1<DocumentInfo> documents, IEnumerable`1<ProjectReference> projectReferences, IEnumerable`1<MetadataReference> metadataReferences, IEnumerable`1<AnalyzerReference> analyzerReferences, IEnumerable`1<DocumentInfo> additionalDocuments, bool isSubmission, Type hostObjectType, string outputRefFilePath);
    private ProjectInfo With(ProjectAttributes attributes, CompilationOptions compilationOptions, ParseOptions parseOptions, IEnumerable`1<DocumentInfo> documents, IEnumerable`1<ProjectReference> projectReferences, IEnumerable`1<MetadataReference> metadataReferences, IEnumerable`1<AnalyzerReference> analyzerReferences, IEnumerable`1<DocumentInfo> additionalDocuments, Optional`1<Type> hostObjectType);
    public ProjectInfo WithDocuments(IEnumerable`1<DocumentInfo> documents);
    public ProjectInfo WithAdditionalDocuments(IEnumerable`1<DocumentInfo> additionalDocuments);
    public ProjectInfo WithVersion(VersionStamp version);
    public ProjectInfo WithName(string name);
    public ProjectInfo WithFilePath(string filePath);
    public ProjectInfo WithAssemblyName(string assemblyName);
    public ProjectInfo WithOutputFilePath(string outputFilePath);
    public ProjectInfo WithOutputRefFilePath(string outputRefFilePath);
    public ProjectInfo WithCompilationOptions(CompilationOptions compilationOptions);
    public ProjectInfo WithParseOptions(ParseOptions parseOptions);
    public ProjectInfo WithProjectReferences(IEnumerable`1<ProjectReference> projectReferences);
    public ProjectInfo WithMetadataReferences(IEnumerable`1<MetadataReference> metadataReferences);
    public ProjectInfo WithAnalyzerReferences(IEnumerable`1<AnalyzerReference> analyzerReferences);
    internal ProjectInfo WithHasAllInformation(bool hasAllInformation);
    internal string GetDebuggerDisplay();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.ProjectReference : object {
    private ProjectId _projectId;
    private ImmutableArray`1<string> _aliases;
    private bool _embedInteropTypes;
    public ProjectId ProjectId { get; }
    public ImmutableArray`1<string> Aliases { get; }
    public bool EmbedInteropTypes { get; }
    public ProjectReference(ProjectId projectId, ImmutableArray`1<string> aliases, bool embedInteropTypes);
    public ProjectId get_ProjectId();
    public ImmutableArray`1<string> get_Aliases();
    public bool get_EmbedInteropTypes();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProjectReference reference);
    public static bool op_Equality(ProjectReference left, ProjectReference right);
    public static bool op_Inequality(ProjectReference left, ProjectReference right);
    public virtual int GetHashCode();
    private string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.ProjectState : object {
    private ProjectInfo _projectInfo;
    private HostLanguageServices _languageServices;
    private SolutionServices _solutionServices;
    private ImmutableSortedDictionary`2<DocumentId, DocumentState> _documentStates;
    private ImmutableSortedDictionary`2<DocumentId, TextDocumentState> _additionalDocumentStates;
    private ImmutableList`1<DocumentId> _documentIds;
    private ImmutableList`1<DocumentId> _additionalDocumentIds;
    private AsyncLazy`1<VersionStamp> _lazyLatestDocumentVersion;
    private AsyncLazy`1<VersionStamp> _lazyLatestDocumentTopLevelChangeVersion;
    private ValueSource`1<ProjectStateChecksums> _lazyChecksums;
    private AnalyzerOptions _analyzerOptionsDoNotAccessDirectly;
    public AnalyzerOptions AnalyzerOptions { get; }
    [DebuggerBrowsableAttribute("2")]
public ProjectId Id { get; }
    [DebuggerBrowsableAttribute("2")]
public string FilePath { get; }
    [DebuggerBrowsableAttribute("2")]
public string OutputFilePath { get; }
    [DebuggerBrowsableAttribute("2")]
public string OutputRefFilePath { get; }
    [DebuggerBrowsableAttribute("2")]
public HostLanguageServices LanguageServices { get; }
    [DebuggerBrowsableAttribute("2")]
public string Language { get; }
    [DebuggerBrowsableAttribute("2")]
public string Name { get; }
    [DebuggerBrowsableAttribute("2")]
public bool IsSubmission { get; }
    [DebuggerBrowsableAttribute("2")]
public Type HostObjectType { get; }
    [DebuggerBrowsableAttribute("2")]
public bool SupportsCompilation { get; }
    [DebuggerBrowsableAttribute("2")]
public VersionStamp Version { get; }
    [DebuggerBrowsableAttribute("2")]
public ProjectInfo ProjectInfo { get; }
    [DebuggerBrowsableAttribute("2")]
public string AssemblyName { get; }
    [DebuggerBrowsableAttribute("2")]
public CompilationOptions CompilationOptions { get; }
    [DebuggerBrowsableAttribute("2")]
public ParseOptions ParseOptions { get; }
    [DebuggerBrowsableAttribute("2")]
public IReadOnlyList`1<MetadataReference> MetadataReferences { get; }
    [DebuggerBrowsableAttribute("2")]
public IReadOnlyList`1<AnalyzerReference> AnalyzerReferences { get; }
    [DebuggerBrowsableAttribute("2")]
public IReadOnlyList`1<ProjectReference> ProjectReferences { get; }
    [DebuggerBrowsableAttribute("2")]
public bool HasAllInformation { get; }
    [DebuggerBrowsableAttribute("2")]
public bool HasDocuments { get; }
    [DebuggerBrowsableAttribute("2")]
public IEnumerable`1<DocumentState> OrderedDocumentStates { get; }
    [DebuggerBrowsableAttribute("2")]
public IReadOnlyList`1<DocumentId> DocumentIds { get; }
    [DebuggerBrowsableAttribute("2")]
public IReadOnlyList`1<DocumentId> AdditionalDocumentIds { get; }
    [DebuggerBrowsableAttribute("2")]
public IImmutableDictionary`2<DocumentId, DocumentState> DocumentStates { get; }
    [DebuggerBrowsableAttribute("2")]
public IImmutableDictionary`2<DocumentId, TextDocumentState> AdditionalDocumentStates { get; }
    private ProjectState(ProjectInfo projectInfo, HostLanguageServices languageServices, SolutionServices solutionServices, ImmutableList`1<DocumentId> documentIds, ImmutableList`1<DocumentId> additionalDocumentIds, ImmutableSortedDictionary`2<DocumentId, DocumentState> documentStates, ImmutableSortedDictionary`2<DocumentId, TextDocumentState> additionalDocumentStates, AsyncLazy`1<VersionStamp> lazyLatestDocumentVersion, AsyncLazy`1<VersionStamp> lazyLatestDocumentTopLevelChangeVersion);
    public ProjectState(ProjectInfo projectInfo, HostLanguageServices languageServices, SolutionServices solutionServices);
    private static ProjectInfo ClearAllDocumentsFromProjectInfo(ProjectInfo projectInfo);
    private ProjectInfo FixProjectInfo(ProjectInfo projectInfo);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ProjectState/<ComputeLatestDocumentVersionAsync>d__15")]
private static Task`1<VersionStamp> ComputeLatestDocumentVersionAsync(IImmutableDictionary`2<DocumentId, DocumentState> documentStates, IImmutableDictionary`2<DocumentId, TextDocumentState> additionalDocumentStates, CancellationToken cancellationToken);
    private AsyncLazy`1<VersionStamp> CreateLazyLatestDocumentTopLevelChangeVersion(TextDocumentState newDocument, IImmutableDictionary`2<DocumentId, DocumentState> newDocumentStates, IImmutableDictionary`2<DocumentId, TextDocumentState> newAdditionalDocumentStates);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ProjectState/<ComputeTopLevelChangeTextVersionAsync>d__17")]
private static Task`1<VersionStamp> ComputeTopLevelChangeTextVersionAsync(VersionStamp oldVersion, TextDocumentState newDocument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ProjectState/<ComputeLatestDocumentTopLevelChangeVersionAsync>d__18")]
private static Task`1<VersionStamp> ComputeLatestDocumentTopLevelChangeVersionAsync(IImmutableDictionary`2<DocumentId, DocumentState> documentStates, IImmutableDictionary`2<DocumentId, TextDocumentState> additionalDocumentStates, CancellationToken cancellationToken);
    private static DocumentState CreateDocument(DocumentInfo documentInfo, ParseOptions parseOptions, HostLanguageServices languageServices, SolutionServices solutionServices);
    public AnalyzerOptions get_AnalyzerOptions();
    private static AnalyzerOptions CreateAnalyzerOptions(ImmutableDictionary`2<DocumentId, TextDocumentState> additionalDocStates);
    public Task`1<VersionStamp> GetLatestDocumentVersionAsync(CancellationToken cancellationToken);
    public Task`1<VersionStamp> GetLatestDocumentTopLevelChangeVersionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ProjectState/<GetSemanticVersionAsync>d__25")]
public Task`1<VersionStamp> GetSemanticVersionAsync(CancellationToken cancellationToken);
    public ProjectId get_Id();
    public string get_FilePath();
    public string get_OutputFilePath();
    public string get_OutputRefFilePath();
    public HostLanguageServices get_LanguageServices();
    public string get_Language();
    public string get_Name();
    public bool get_IsSubmission();
    public Type get_HostObjectType();
    public bool get_SupportsCompilation();
    public VersionStamp get_Version();
    public ProjectInfo get_ProjectInfo();
    public string get_AssemblyName();
    public CompilationOptions get_CompilationOptions();
    public ParseOptions get_ParseOptions();
    public IReadOnlyList`1<MetadataReference> get_MetadataReferences();
    public IReadOnlyList`1<AnalyzerReference> get_AnalyzerReferences();
    public IReadOnlyList`1<ProjectReference> get_ProjectReferences();
    public bool get_HasAllInformation();
    public bool get_HasDocuments();
    public IEnumerable`1<DocumentState> get_OrderedDocumentStates();
    public IReadOnlyList`1<DocumentId> get_DocumentIds();
    public IReadOnlyList`1<DocumentId> get_AdditionalDocumentIds();
    public IImmutableDictionary`2<DocumentId, DocumentState> get_DocumentStates();
    public IImmutableDictionary`2<DocumentId, TextDocumentState> get_AdditionalDocumentStates();
    public bool ContainsDocument(DocumentId documentId);
    public bool ContainsAdditionalDocument(DocumentId documentId);
    public DocumentState GetDocumentState(DocumentId documentId);
    public TextDocumentState GetAdditionalDocumentState(DocumentId documentId);
    private ProjectState With(ProjectInfo projectInfo, ImmutableList`1<DocumentId> documentIds, ImmutableList`1<DocumentId> additionalDocumentIds, ImmutableSortedDictionary`2<DocumentId, DocumentState> documentStates, ImmutableSortedDictionary`2<DocumentId, TextDocumentState> additionalDocumentStates, AsyncLazy`1<VersionStamp> latestDocumentVersion, AsyncLazy`1<VersionStamp> latestDocumentTopLevelChangeVersion);
    public ProjectState UpdateName(string name);
    public ProjectState UpdateFilePath(string filePath);
    public ProjectState UpdateAssemblyName(string assemblyName);
    public ProjectState UpdateOutputFilePath(string outputFilePath);
    public ProjectState UpdateOutputRefFilePath(string outputRefFilePath);
    public ProjectState UpdateCompilationOptions(CompilationOptions options);
    public ProjectState UpdateParseOptions(ParseOptions options);
    public ProjectState UpdateHasAllInformation(bool hasAllInformation);
    public static bool IsSameLanguage(ProjectState project1, ProjectState project2);
    public ProjectState RemoveProjectReference(ProjectReference projectReference);
    public ProjectState AddProjectReferences(IEnumerable`1<ProjectReference> projectReferences);
    public ProjectState WithProjectReferences(IEnumerable`1<ProjectReference> projectReferences);
    public ProjectState AddMetadataReference(MetadataReference toMetadata);
    public ProjectState RemoveMetadataReference(MetadataReference toMetadata);
    public ProjectState AddMetadataReferences(IEnumerable`1<MetadataReference> metadataReferences);
    public ProjectState WithMetadataReferences(IEnumerable`1<MetadataReference> metadataReferences);
    public ProjectState AddAnalyzerReference(AnalyzerReference analyzerReference);
    public ProjectState RemoveAnalyzerReference(AnalyzerReference analyzerReference);
    public ProjectState AddAnalyzerReferences(IEnumerable`1<AnalyzerReference> analyzerReferences);
    public ProjectState WithAnalyzerReferences(IEnumerable`1<AnalyzerReference> analyzerReferences);
    public ProjectState AddDocument(DocumentState document);
    public ProjectState AddAdditionalDocument(TextDocumentState document);
    public ProjectState RemoveDocument(DocumentId documentId);
    public ProjectState RemoveAdditionalDocument(DocumentId documentId);
    public ProjectState RemoveAllDocuments();
    public ProjectState UpdateDocument(DocumentState newDocument, bool textChanged, bool recalculateDependentVersions);
    public ProjectState UpdateAdditionalDocument(TextDocumentState newDocument, bool textChanged, bool recalculateDependentVersions);
    private void GetLatestDependentVersions(IImmutableDictionary`2<DocumentId, DocumentState> newDocumentStates, IImmutableDictionary`2<DocumentId, TextDocumentState> newAdditionalDocumentStates, TextDocumentState oldDocument, TextDocumentState newDocument, bool recalculateDependentVersions, bool textChanged, AsyncLazy`1& dependentDocumentVersion, AsyncLazy`1& dependentSemanticVersion);
    public bool TryGetStateChecksums(ProjectStateChecksums& stateChecksums);
    public Task`1<ProjectStateChecksums> GetStateChecksumsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ProjectState/<GetChecksumAsync>d__112")]
public Task`1<Checksum> GetChecksumAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ProjectState/<ComputeChecksumsAsync>d__113")]
private Task`1<ProjectStateChecksums> ComputeChecksumsAsync(CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Recommendations.AbstractRecommendationService : object {
    protected abstract virtual Task`1<Tuple`2<ImmutableArray`1<ISymbol>, SyntaxContext>> GetRecommendedSymbolsAtPositionWorkerAsync(Workspace workspace, SemanticModel semanticModel, int position, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Recommendations.AbstractRecommendationService/<GetRecommendedSymbolsAtPositionAsync>d__1")]
public sealed virtual Task`1<ImmutableArray`1<ISymbol>> GetRecommendedSymbolsAtPositionAsync(Workspace workspace, SemanticModel semanticModel, int position, OptionSet options, CancellationToken cancellationToken);
    protected static ImmutableArray`1<ISymbol> GetRecommendedNamespaceNameSymbols(SemanticModel semanticModel, SyntaxNode declarationSyntax, CancellationToken cancellationToken);
    protected static bool IsNonIntersectingNamespace(ISymbol recommendationSymbol, SyntaxNode declarationSyntax);
    protected static ImmutableArray`1<ISymbol> SuppressDefaultTupleElements(INamespaceOrTypeSymbol container, ImmutableArray`1<ISymbol> symbols);
    private static bool IsFriendlyName(int i, string elementName);
}
internal interface Microsoft.CodeAnalysis.Recommendations.IRecommendationService {
    public abstract virtual Task`1<ImmutableArray`1<ISymbol>> GetRecommendedSymbolsAtPositionAsync(Workspace workspace, SemanticModel semanticModel, int position, OptionSet options, CancellationToken cancellationToken);
}
public static class Microsoft.CodeAnalysis.Recommendations.RecommendationOptions : object {
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <HideAdvancedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <FilterOutOfScopeLocals>k__BackingField;
    public static PerLanguageOption`1<bool> HideAdvancedMembers { get; }
    public static PerLanguageOption`1<bool> FilterOutOfScopeLocals { get; }
    private static RecommendationOptions();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_HideAdvancedMembers();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_FilterOutOfScopeLocals();
}
public static class Microsoft.CodeAnalysis.Recommendations.Recommender : object {
    [ObsoleteAttribute("Use GetRecommendedSymbolsAtPositionAsync instead.")]
public static IEnumerable`1<ISymbol> GetRecommendedSymbolsAtPosition(SemanticModel semanticModel, int position, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Recommendations.Recommender/<GetRecommendedSymbolsAtPositionAsync>d__1")]
public static Task`1<IEnumerable`1<ISymbol>> GetRecommendedSymbolsAtPositionAsync(SemanticModel semanticModel, int position, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Recommendations.Recommender/<GetImmutableRecommendedSymbolsAtPositionAsync>d__2")]
internal static Task`1<ImmutableArray`1<ISymbol>> GetImmutableRecommendedSymbolsAtPositionAsync(SemanticModel semanticModel, int position, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.RecoverableTextAndVersion : ValueSource`1<TextAndVersion> {
    private ITemporaryStorageService _storageService;
    private SemaphoreSlim _gateDoNotAccessDirectly;
    private ValueSource`1<TextAndVersion> _initialSource;
    private RecoverableText _text;
    private VersionStamp _version;
    private string _filePath;
    private SemaphoreSlim Gate { get; }
    public ITemporaryTextStorage Storage { get; }
    public RecoverableTextAndVersion(ValueSource`1<TextAndVersion> initialTextAndVersion, ITemporaryStorageService storageService);
    private SemaphoreSlim get_Gate();
    public ITemporaryTextStorage get_Storage();
    public virtual bool TryGetValue(TextAndVersion& value);
    public sealed virtual bool TryGetTextVersion(VersionStamp& version);
    public virtual TextAndVersion GetValue(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RecoverableTextAndVersion/<GetValueAsync>d__14")]
public virtual Task`1<TextAndVersion> GetValueAsync(CancellationToken cancellationToken);
    private TextAndVersion InitRecoverable(TextAndVersion textAndVersion);
}
internal class Microsoft.CodeAnalysis.RelativePathResolver : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <SearchPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseDirectory>k__BackingField;
    public ImmutableArray`1<string> SearchPaths { get; }
    public string BaseDirectory { get; }
    public RelativePathResolver(ImmutableArray`1<string> searchPaths, string baseDirectory);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_SearchPaths();
    [CompilerGeneratedAttribute]
public string get_BaseDirectory();
    public string ResolvePath(string reference, string baseFilePath);
    protected virtual bool FileExists(string fullPath);
    public RelativePathResolver WithSearchPaths(ImmutableArray`1<string> searchPaths);
    public RelativePathResolver WithBaseDirectory(string baseDirectory);
    public sealed virtual bool Equals(RelativePathResolver other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Remote.IRemoteHostClientService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Remote.DefaultRemoteHostClientServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal interface Microsoft.CodeAnalysis.Remote.IRemoteHostClientFactory {
    public abstract virtual Task`1<RemoteHostClient> CreateAsync(Workspace workspace, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Remote.IRemoteHostClientService {
    public abstract virtual Task RequestNewRemoteHostAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<RemoteHostClient> TryGetRemoteHostClientAsync(CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Remote.IRemoteHostService {
    public abstract virtual string Connect(string host, int uiCultureLCID, int cultureLCID, string serializedSession, CancellationToken cancellationToken);
    public abstract virtual void UpdateSolutionStorageLocation(SolutionId solutionId, string storageLocation, CancellationToken cancellationToken);
    public abstract virtual void SetLoggingFunctionIds(List`1<string> loggerTypes, List`1<string> functionIds, CancellationToken cancellationToken);
    public abstract virtual void OnGlobalOperationStarted(string unused);
    public abstract virtual void OnGlobalOperationStopped(IReadOnlyList`1<string> operations, bool cancelled);
    public abstract virtual Task SynchronizePrimaryWorkspaceAsync(Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task SynchronizeTextAsync(DocumentId documentId, Checksum baseTextChecksum, IEnumerable`1<TextChange> textChanges, CancellationToken cancellationToken);
    public abstract virtual Task SynchronizeGlobalAssetsAsync(Checksum[] checksums, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Remote.KeepAliveSession : object {
    private object _gate;
    private IRemoteHostClientService _remoteHostClientService;
    private string _serviceName;
    private object _callbackTarget;
    private RemoteHostClient _client;
    private ReferenceCountedDisposable`1<Connection> _connectionDoNotAccessDirectly;
    public KeepAliveSession(RemoteHostClient client, Connection connection, string serviceName, object callbackTarget);
    public void Shutdown();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.KeepAliveSession/<TryInvokeAsync>d__8")]
public Task`1<bool> TryInvokeAsync(string targetName, IReadOnlyList`1<object> arguments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.KeepAliveSession/<TryInvokeAsync>d__9`1")]
public Task`1<T> TryInvokeAsync(string targetName, IReadOnlyList`1<object> arguments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.KeepAliveSession/<TryInvokeAsync>d__10")]
public Task`1<bool> TryInvokeAsync(string targetName, IReadOnlyList`1<object> arguments, Func`3<Stream, CancellationToken, Task> funcWithDirectStreamAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.KeepAliveSession/<TryInvokeAsync>d__11`1")]
public Task`1<T> TryInvokeAsync(string targetName, IReadOnlyList`1<object> arguments, Func`3<Stream, CancellationToken, Task`1<T>> funcWithDirectStreamAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.KeepAliveSession/<TryInvokeAsync>d__12")]
public Task`1<bool> TryInvokeAsync(string targetName, Solution solution, IReadOnlyList`1<object> arguments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.KeepAliveSession/<TryInvokeAsync>d__13`1")]
public Task`1<T> TryInvokeAsync(string targetName, Solution solution, IReadOnlyList`1<object> arguments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.KeepAliveSession/<TryInvokeAsync>d__14")]
public Task`1<bool> TryInvokeAsync(string targetName, Solution solution, IReadOnlyList`1<object> arguments, Func`3<Stream, CancellationToken, Task> funcWithDirectStreamAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.KeepAliveSession/<TryInvokeAsync>d__15`1")]
public Task`1<T> TryInvokeAsync(string targetName, Solution solution, IReadOnlyList`1<object> arguments, Func`3<Stream, CancellationToken, Task`1<T>> funcWithDirectStreamAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.KeepAliveSession/<TryGetConnectionAsync>d__16")]
private Task`1<ReferenceCountedDisposable`1<Connection>> TryGetConnectionAsync(CancellationToken cancellationToken);
    private void OnStatusChanged(object sender, bool connection);
    private void Initialize(RemoteHostClient client, Connection connection);
}
internal static class Microsoft.CodeAnalysis.Remote.RemoteFeatureOptions : object {
    private static string LocalRegistryPath;
    public static Option`1<bool> OutOfProcessAllowed;
    public static Option`1<bool> AddImportEnabled;
    public static Option`1<bool> DocumentHighlightingEnabled;
    public static Option`1<bool> NavigateToEnabled;
    public static Option`1<bool> SymbolSearchEnabled;
    public static Option`1<bool> SymbolFinderEnabled;
    public static Option`1<bool> DiagnosticsEnabled;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<Option`1<bool>> <AllFeatureOptions>k__BackingField;
    private static ImmutableArray`1<Option`1<bool>> AllFeatureOptions { get; }
    private static RemoteFeatureOptions();
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<Option`1<bool>> get_AllFeatureOptions();
    public static bool AnyFeatureRunsInProcess(Workspace workspace);
    public static bool ShouldComputeIndex(Workspace workspace);
}
internal abstract class Microsoft.CodeAnalysis.Remote.RemoteHostClient : object {
    public Workspace Workspace;
    [CompilerGeneratedAttribute]
private EventHandler`1<bool> StatusChanged;
    protected RemoteHostClient(Workspace workspace);
    [CompilerGeneratedAttribute]
public void add_StatusChanged(EventHandler`1<bool> value);
    [CompilerGeneratedAttribute]
public void remove_StatusChanged(EventHandler`1<bool> value);
    public abstract virtual Task`1<Connection> TryCreateConnectionAsync(string serviceName, object callbackTarget, CancellationToken cancellationToken);
    protected abstract virtual void OnStarted();
    protected abstract virtual void OnStopped();
    internal void Shutdown();
    protected void Started();
    protected void Stopped();
    private void OnStatusChanged(bool started);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions : object {
    [ExtensionAttribute]
public static Task`1<Connection> TryCreateConnectionAsync(RemoteHostClient client, string serviceName, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<SessionWithSolution> TryCreateSessionAsync(RemoteHostClient client, string serviceName, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions/<TryCreateSessionAsync>d__2")]
[ExtensionAttribute]
public static Task`1<SessionWithSolution> TryCreateSessionAsync(RemoteHostClient client, string serviceName, Solution solution, object callbackTarget, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<KeepAliveSession> TryCreateKeepAliveSessionAsync(RemoteHostClient client, string serviceName, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions/<TryCreateKeepAliveSessionAsync>d__4")]
[ExtensionAttribute]
public static Task`1<KeepAliveSession> TryCreateKeepAliveSessionAsync(RemoteHostClient client, string serviceName, object callbackTarget, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<SessionWithSolution> TryCreateCodeAnalysisSessionAsync(RemoteHostClient client, Solution solution, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<SessionWithSolution> TryCreateCodeAnalysisSessionAsync(RemoteHostClient client, Solution solution, object callbackTarget, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<KeepAliveSession> TryCreateCodeAnalysisKeepAliveSessionAsync(RemoteHostClient client, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<KeepAliveSession> TryCreateCodeAnalysisKeepAliveSessionAsync(RemoteHostClient client, object callbackTarget, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<RemoteHostClient> TryGetRemoteHostClientAsync(Workspace workspace, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsOutOfProcessEnabled(Workspace workspace, Option`1<bool> featureOption);
    [ExtensionAttribute]
public static Task`1<RemoteHostClient> TryGetRemoteHostClientAsync(Workspace workspace, Option`1<bool> featureOption, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<bool> TryRunRemoteAsync(RemoteHostClient client, string serviceName, Solution solution, string targetName, object argument, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<bool> TryRunRemoteAsync(RemoteHostClient client, string serviceName, Solution solution, string targetName, Object[] arguments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions/<TryRunRemoteAsync>d__14")]
[ExtensionAttribute]
public static Task`1<bool> TryRunRemoteAsync(RemoteHostClient client, string serviceName, Solution solution, object callbackTarget, string targetName, IReadOnlyList`1<object> arguments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions/<TryRunRemoteAsync>d__15")]
[ExtensionAttribute]
public static Task`1<bool> TryRunRemoteAsync(RemoteHostClient client, string serviceName, string targetName, IReadOnlyList`1<object> arguments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions/<TryRunRemoteAsync>d__16`1")]
[ExtensionAttribute]
public static Task`1<T> TryRunRemoteAsync(RemoteHostClient client, string serviceName, Solution solution, string targetName, IReadOnlyList`1<object> arguments, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<bool> TryRunCodeAnalysisRemoteAsync(RemoteHostClient client, Solution solution, object callbackTarget, string targetName, object argument, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<bool> TryRunCodeAnalysisRemoteAsync(RemoteHostClient client, Solution solution, object callbackTarget, string targetName, Object[] arguments, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> TryRunCodeAnalysisRemoteAsync(RemoteHostClient client, Solution solution, string targetName, object argument, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> TryRunCodeAnalysisRemoteAsync(RemoteHostClient client, Solution solution, string targetName, Object[] arguments, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<bool> TryRunCodeAnalysisRemoteAsync(RemoteHostClient client, string targetName, object argument, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<bool> TryRunCodeAnalysisRemoteAsync(RemoteHostClient client, string targetName, Object[] arguments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions/<SynchronizePrimaryWorkspaceAsync>d__23")]
[ExtensionAttribute]
public static Task SynchronizePrimaryWorkspaceAsync(Workspace workspace, Solution solution, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<PinnedRemotableDataScope> GetPinnedScopeAsync(Solution solution, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<SessionWithSolution> TryCreateCodeAnalysisSessionAsync(Solution solution, Option`1<bool> featureOption, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions/<TryCreateCodeAnalysisSessionAsync>d__26")]
[ExtensionAttribute]
public static Task`1<SessionWithSolution> TryCreateCodeAnalysisSessionAsync(Solution solution, Option`1<bool> option, object callbackTarget, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<bool> TryRunCodeAnalysisRemoteAsync(Solution solution, Option`1<bool> option, object callbackTarget, string targetName, object argument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions/<TryRunCodeAnalysisRemoteAsync>d__28")]
[ExtensionAttribute]
public static Task`1<bool> TryRunCodeAnalysisRemoteAsync(Solution solution, Option`1<bool> option, object callbackTarget, string targetName, IReadOnlyList`1<object> arguments, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<T> TryRunCodeAnalysisRemoteAsync(Solution solution, Option`1<bool> option, string targetName, Object[] arguments, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClientExtensions/<TryRunCodeAnalysisRemoteAsync>d__30`1")]
[ExtensionAttribute]
public static Task`1<T> TryRunCodeAnalysisRemoteAsync(Solution solution, Option`1<bool> option, object callbackTarget, string targetName, IReadOnlyList`1<object> arguments, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Remote.RemoteSupportedLanguages : object {
    [ExtensionAttribute]
public static bool IsSupported(string language);
}
internal class Microsoft.CodeAnalysis.Remote.SerializableReferenceLocation : object {
    [CompilerGeneratedAttribute]
private DocumentId <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private SerializableSymbolAndProjectId <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWrittenTo>k__BackingField;
    [CompilerGeneratedAttribute]
private CandidateReason <CandidateReason>k__BackingField;
    public DocumentId Document { get; public set; }
    public SerializableSymbolAndProjectId Alias { get; public set; }
    public TextSpan Location { get; public set; }
    public bool IsImplicit { get; public set; }
    internal bool IsWrittenTo { get; internal set; }
    public CandidateReason CandidateReason { get; public set; }
    [CompilerGeneratedAttribute]
public DocumentId get_Document();
    [CompilerGeneratedAttribute]
public void set_Document(DocumentId value);
    [CompilerGeneratedAttribute]
public SerializableSymbolAndProjectId get_Alias();
    [CompilerGeneratedAttribute]
public void set_Alias(SerializableSymbolAndProjectId value);
    [CompilerGeneratedAttribute]
public TextSpan get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(TextSpan value);
    [CompilerGeneratedAttribute]
public bool get_IsImplicit();
    [CompilerGeneratedAttribute]
public void set_IsImplicit(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsWrittenTo();
    [CompilerGeneratedAttribute]
internal void set_IsWrittenTo(bool value);
    [CompilerGeneratedAttribute]
public CandidateReason get_CandidateReason();
    [CompilerGeneratedAttribute]
public void set_CandidateReason(CandidateReason value);
    public static SerializableReferenceLocation Dehydrate(ReferenceLocation referenceLocation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.SerializableReferenceLocation/<RehydrateAsync>d__25")]
public Task`1<ReferenceLocation> RehydrateAsync(Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.SerializableReferenceLocation/<RehydrateAliasAsync>d__26")]
private Task`1<IAliasSymbol> RehydrateAliasAsync(Solution solution, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Remote.SerializableSymbolAndProjectId : object {
    public string SymbolKeyData;
    public ProjectId ProjectId;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SerializableSymbolAndProjectId other);
    public static SerializableSymbolAndProjectId Dehydrate(IAliasSymbol alias, Document document);
    public static SerializableSymbolAndProjectId Dehydrate(SymbolAndProjectId symbolAndProjectId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.SerializableSymbolAndProjectId/<TryRehydrateAsync>d__7")]
public Task`1<Nullable`1<SymbolAndProjectId>> TryRehydrateAsync(Solution solution, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Remote.SessionWithSolution : object {
    private Connection _connection;
    private PinnedRemotableDataScope _scope;
    private SessionWithSolution(Connection connection, PinnedRemotableDataScope scope);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.SessionWithSolution/<CreateAsync>d__2")]
public static Task`1<SessionWithSolution> CreateAsync(Connection connection, Solution solution, CancellationToken cancellationToken);
    public void AddAdditionalAssets(CustomAsset asset);
    public sealed virtual void Dispose();
    public Task InvokeAsync(string targetName, IReadOnlyList`1<object> arguments, CancellationToken cancellationToken);
    public Task`1<T> InvokeAsync(string targetName, IReadOnlyList`1<object> arguments, CancellationToken cancellationToken);
    public Task InvokeAsync(string targetName, IReadOnlyList`1<object> arguments, Func`3<Stream, CancellationToken, Task> funcWithDirectStreamAsync, CancellationToken cancellationToken);
    public Task`1<T> InvokeAsync(string targetName, IReadOnlyList`1<object> arguments, Func`3<Stream, CancellationToken, Task`1<T>> funcWithDirectStreamAsync, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Remote.WellKnownRemoteHostServices : object {
    [CompilerGeneratedAttribute]
private static string <RemoteHostService>k__BackingField;
    public static string RemoteHostService { get; private set; }
    private static WellKnownRemoteHostServices();
    public static void Set64bit(bool x64);
    [CompilerGeneratedAttribute]
public static string get_RemoteHostService();
    [CompilerGeneratedAttribute]
private static void set_RemoteHostService(string value);
}
internal static class Microsoft.CodeAnalysis.Remote.WellKnownServiceHubServices : object {
    [CompilerGeneratedAttribute]
private static string <SnapshotService>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <CodeAnalysisService>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <RemoteSymbolSearchUpdateEngine>k__BackingField;
    public static string ServiceHubServiceBase_Initialize;
    public static string AssetService_RequestAssetAsync;
    public static string SnapshotService { get; private set; }
    public static string CodeAnalysisService { get; private set; }
    public static string RemoteSymbolSearchUpdateEngine { get; private set; }
    private static WellKnownServiceHubServices();
    public static void Set64bit(bool x64);
    [CompilerGeneratedAttribute]
public static string get_SnapshotService();
    [CompilerGeneratedAttribute]
private static void set_SnapshotService(string value);
    [CompilerGeneratedAttribute]
public static string get_CodeAnalysisService();
    [CompilerGeneratedAttribute]
private static void set_CodeAnalysisService(string value);
    [CompilerGeneratedAttribute]
public static string get_RemoteSymbolSearchUpdateEngine();
    [CompilerGeneratedAttribute]
private static void set_RemoteSymbolSearchUpdateEngine(string value);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictingIdentifierTracker : object {
    private Dictionary`2<string, List`1<SyntaxToken>> _currentIdentifiersInScope;
    private HashSet`1<SyntaxToken> _conflictingTokensToReport;
    private SyntaxToken _tokenBeingRenamed;
    public IEnumerable`1<SyntaxToken> ConflictingTokens { get; }
    public ConflictingIdentifierTracker(SyntaxToken tokenBeingRenamed, IEqualityComparer`1<string> identifierComparer);
    public IEnumerable`1<SyntaxToken> get_ConflictingTokens();
    public void AddIdentifier(SyntaxToken token);
    public void AddIdentifiers(IEnumerable`1<SyntaxToken> tokens);
    public void RemoveIdentifier(SyntaxToken token);
    public void RemoveIdentifiers(IEnumerable`1<SyntaxToken> tokens);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution : object {
    private RenamedSpansTracker _renamedSpansTracker;
    private List`1<RelatedLocation> _relatedLocations;
    private Solution _oldSolution;
    private Solution _newSolution;
    private Solution _intermediateSolutionContainingOnlyModifiedDocuments;
    private ILookup`2<DocumentId, RelatedLocation> _relatedLocationsByDocumentId;
    [CompilerGeneratedAttribute]
private bool <ReplacementTextValid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReplacementText>k__BackingField;
    public IList`1<RelatedLocation> RelatedLocations { get; }
    public RenamedSpansTracker RenamedSpansTracker { get; }
    public IEnumerable`1<DocumentId> DocumentIds { get; }
    public Solution NewSolution { get; }
    public Solution OldSolution { get; }
    public bool ReplacementTextValid { get; }
    public string ReplacementText { get; }
    public ConflictResolution(Solution oldSolution, RenamedSpansTracker renamedSpansTracker, string replacementText, bool replacementTextValid);
    internal void ClearDocuments(IEnumerable`1<DocumentId> conflictLocationDocumentIds);
    internal void UpdateCurrentSolution(Solution solution);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolution/<RemoveAllRenameAnnotationsAsync>d__9")]
internal Task RemoveAllRenameAnnotationsAsync(IEnumerable`1<DocumentId> documentWithRenameAnnotations, AnnotationTable`1<RenameAnnotation> annotationSet, CancellationToken cancellationToken);
    public IList`1<RelatedLocation> get_RelatedLocations();
    public RenamedSpansTracker get_RenamedSpansTracker();
    public int GetAdjustedTokenStartingPosition(int startingPosition, DocumentId documentId);
    public TextSpan GetResolutionTextSpan(TextSpan originalSpan, DocumentId documentId);
    public IEnumerable`1<DocumentId> get_DocumentIds();
    public IEnumerable`1<RelatedLocation> GetRelatedLocationsForDocument(DocumentId documentId);
    internal void AddRelatedLocation(RelatedLocation location);
    internal void AddOrReplaceRelatedLocation(RelatedLocation location);
    public Solution get_NewSolution();
    public Solution get_OldSolution();
    [CompilerGeneratedAttribute]
public bool get_ReplacementTextValid();
    [CompilerGeneratedAttribute]
public string get_ReplacementText();
}
internal static class Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver : object {
    private static SymbolDisplayFormat s_metadataSymbolDisplayFormat;
    private static string s_metadataNameSeparators;
    private static ConflictResolver();
    public static Task`1<ConflictResolution> ResolveConflictsAsync(RenameLocations renameLocationSet, string originalText, string replacementText, OptionSet optionSet, Func`2<IEnumerable`1<ISymbol>, Nullable`1<bool>> hasConflict, CancellationToken cancellationToken);
    private static IEnumerable`1<ISymbol> SymbolsForEnclosingInvocationExpressionWorker(SyntaxNode invocationExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SyntaxNode GetExpansionTargetForLocationPerLanguage(SyntaxToken tokenOrNode, Document document);
    private static bool LocalVariableConflictPerLanguage(SyntaxToken tokenOrNode, Document document, IEnumerable`1<ISymbol> newReferencedSymbols);
    private static bool IsIdentifierValid_Worker(Solution solution, string replacementText, IEnumerable`1<ProjectId> projectIds, CancellationToken cancellationToken);
    private static bool IsRenameValid(ConflictResolution conflictResolution, ISymbol renamedSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver/<AddImplicitConflictsAsync>d__8")]
private static Task AddImplicitConflictsAsync(ISymbol renamedSymbol, ISymbol originalSymbol, IEnumerable`1<ReferenceLocation> implicitReferenceLocations, SemanticModel semanticModel, Location originalDeclarationLocation, int newDeclarationLocationStartingPosition, ConflictResolution conflictResolution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver/<AddDeclarationConflictsAsync>d__9")]
internal static Task AddDeclarationConflictsAsync(ISymbol renamedSymbol, ISymbol renameSymbol, IEnumerable`1<SymbolAndProjectId> referencedSymbols, ConflictResolution conflictResolution, IDictionary`2<Location, Location> reverseMappedLocations, CancellationToken cancellationToken);
    internal static void AddConflictingParametersOfProperties(IEnumerable`1<ISymbol> properties, string newPropertyName, ArrayBuilder`1<Location> conflicts);
    private static void AddConflictingSymbolLocations(IEnumerable`1<ISymbol> conflictingSymbols, ConflictResolution conflictResolution, IDictionary`2<Location, Location> reverseMappedLocations);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver/<CreateDeclarationLocationAnnotationsAsync>d__12")]
public static Task`1<RenameDeclarationLocationReference[]> CreateDeclarationLocationAnnotationsAsync(Solution solution, IEnumerable`1<ISymbol> symbols, CancellationToken cancellationToken);
    private static string GetString(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver/<GetSymbolLocationAsync>d__14")]
private static Task`1<Location> GetSymbolLocationAsync(Solution solution, ISymbol symbol, CancellationToken cancellationToken);
    private static bool HeuristicMetadataNameEquivalenceCheck(string oldMetadataName, string newMetadataName, string originalText, string replacementText);
    private static bool IsSubStringEqual(string str1, string str2, int index);
    private static bool IsWholeIdentifier(string metadataName, string searchText, int index);
    private static bool IsIdentifierSeparator(char element);
}
internal static class Microsoft.CodeAnalysis.Rename.ConflictEngine.DeclarationConflictHelpers : object {
    public static ImmutableArray`1<Location> GetMembersWithConflictingSignatures(IMethodSymbol renamedMethod, bool trimOptionalParameters);
    private static ImmutableArray`1<ImmutableArray`1<ITypeSymbol>> GetAllSignatures(IMethodSymbol method, bool trimOptionalParameters);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocation : object {
    [CompilerGeneratedAttribute]
private TextSpan <ConflictCheckSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private RelatedLocationType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReference>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <ComplexifiedTargetSpan>k__BackingField;
    public TextSpan ConflictCheckSpan { get; }
    public RelatedLocationType Type { get; public set; }
    public bool IsReference { get; }
    public DocumentId DocumentId { get; }
    public TextSpan ComplexifiedTargetSpan { get; }
    public RelatedLocation(TextSpan location, DocumentId documentId, RelatedLocationType type, bool isReference, TextSpan complexifiedTargetSpan);
    [CompilerGeneratedAttribute]
public TextSpan get_ConflictCheckSpan();
    [CompilerGeneratedAttribute]
public RelatedLocationType get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(RelatedLocationType value);
    [CompilerGeneratedAttribute]
public bool get_IsReference();
    [CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
    [CompilerGeneratedAttribute]
public TextSpan get_ComplexifiedTargetSpan();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType : Enum {
    public int value__;
    public static RelatedLocationType NoConflict;
    public static RelatedLocationType ResolvedReferenceConflict;
    public static RelatedLocationType ResolvedNonReferenceConflict;
    public static RelatedLocationType PossiblyResolvableConflict;
    public static RelatedLocationType UnresolvableConflict;
    public static RelatedLocationType UnresolvedConflict;
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation : RenameAnnotation {
    public TextSpan OriginalSpan;
    public bool IsRenameLocation;
    public bool IsOriginalTextLocation;
    public string Prefix;
    public string Suffix;
    public RenameDeclarationLocationReference[] RenameDeclarationLocationReferences;
    public bool IsNamespaceDeclarationReference;
    public bool IsMemberGroupReference;
    public bool IsInvocationExpression;
    public RenameActionAnnotation(TextSpan originalSpan, bool isRenameLocation, string prefix, string suffix, bool isOriginalTextLocation, RenameDeclarationLocationReference[] renameDeclarationLocations, bool isNamespaceDeclarationReference, bool isInvocationExpression, bool isMemberGroupReference);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameAnnotation : object {
    public static string Kind;
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference : object {
    public DocumentId DocumentId;
    public TextSpan TextSpan;
    public string Name;
    public int SymbolLocationsCount;
    public bool IsOverriddenFromMetadata;
    public bool IsSourceLocation { get; }
    public RenameDeclarationLocationReference(DocumentId documentId, TextSpan textSpan, bool overriddenFromMetadata, int declaringSyntaxReferencesCount);
    public RenameDeclarationLocationReference(string name, int declaringSyntaxReferencesCount);
    public bool get_IsSourceLocation();
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenamedSpansTracker : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<DocumentId, List`1<ValueTuple`2<TextSpan, TextSpan>>> _documentToModifiedSpansMap;
    private Dictionary`2<DocumentId, List`1<ComplexifiedSpan>> _documentToComplexifiedSpansMap;
    public IEnumerable`1<DocumentId> DocumentIds { get; }
    internal bool IsDocumentChanged(DocumentId documentId);
    internal void AddModifiedSpan(DocumentId documentId, TextSpan oldSpan, TextSpan newSpan);
    internal void AddComplexifiedSpan(DocumentId documentId, TextSpan oldSpan, TextSpan newSpan, List`1<ValueTuple`2<TextSpan, TextSpan>> modifiedSubSpans);
    internal TextSpan GetAdjustedComplexifiedSpan(TextSpan originalComplexifiedSpan, DocumentId documentId);
    internal int GetAdjustedPosition(int startingPosition, DocumentId documentId);
    internal TextSpan GetResolutionTextSpan(TextSpan originalSpan, DocumentId documentId);
    internal void ClearDocuments(IEnumerable`1<DocumentId> conflictLocationDocumentIds);
    internal bool ContainsResolvedNonReferenceLocation(DocumentId documentId, TextSpan originalLocation);
    public IEnumerable`1<DocumentId> get_DocumentIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.RenamedSpansTracker/<SimplifyAsync>d__14")]
internal Task`1<Solution> SimplifyAsync(Solution solution, IEnumerable`1<DocumentId> documentIds, bool replacementTextValid, AnnotationTable`1<RenameAnnotation> renameAnnotations, CancellationToken cancellationToken);
    internal Dictionary`2<TextSpan, TextSpan> GetModifiedSpanMap(DocumentId documentId);
    internal IEnumerable`1<ValueTuple`2<TextSpan, TextSpan>> GetComplexifiedSpans(DocumentId documentId);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameInvalidIdentifierAnnotation : RenameAnnotation {
    public static RenameInvalidIdentifierAnnotation Instance;
    private static RenameInvalidIdentifierAnnotation();
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameNodeSimplificationAnnotation : RenameAnnotation {
    [CompilerGeneratedAttribute]
private TextSpan <OriginalTextSpan>k__BackingField;
    public TextSpan OriginalTextSpan { get; public set; }
    [CompilerGeneratedAttribute]
public TextSpan get_OriginalTextSpan();
    [CompilerGeneratedAttribute]
public void set_OriginalTextSpan(TextSpan value);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameTokenSimplificationAnnotation : RenameAnnotation {
    [CompilerGeneratedAttribute]
private TextSpan <OriginalTextSpan>k__BackingField;
    public TextSpan OriginalTextSpan { get; public set; }
    [CompilerGeneratedAttribute]
public TextSpan get_OriginalTextSpan();
    [CompilerGeneratedAttribute]
public void set_OriginalTextSpan(TextSpan value);
}
internal interface Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService {
    public abstract virtual SyntaxNode AnnotateAndRename(RenameRewriterParameters parameters);
    public abstract virtual void TryAddPossibleNameConflicts(ISymbol symbol, string newName, ICollection`1<string> possibleNameConflicts);
    public abstract virtual Task`1<ImmutableArray`1<Location>> ComputeDeclarationConflictsAsync(string replacementText, ISymbol renamedSymbol, ISymbol renameSymbol, IEnumerable`1<SymbolAndProjectId> referencedSymbols, Solution baseSolution, Solution newSolution, IDictionary`2<Location, Location> reverseMappedLocations, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<Location>> ComputeImplicitReferenceConflictsAsync(ISymbol renameSymbol, ISymbol renamedSymbol, IEnumerable`1<ReferenceLocation> implicitReferenceLocations, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<Location> ComputePossibleImplicitUsageConflicts(ISymbol renamedSymbol, SemanticModel semanticModel, Location originalDeclarationLocation, int newDeclarationLocationStartingPosition, CancellationToken cancellationToken);
    public abstract virtual bool LocalVariableConflict(SyntaxToken token, IEnumerable`1<ISymbol> newReferencedSymbols);
    public abstract virtual bool IsIdentifierValid(string replacementText, ISyntaxFactsService syntaxFactsService);
    public abstract virtual SyntaxNode GetExpansionTargetForLocation(SyntaxToken token);
}
public enum Microsoft.CodeAnalysis.Rename.RenameEntityKind : Enum {
    public int value__;
    public static RenameEntityKind BaseSymbol;
    public static RenameEntityKind OverloadedSymbols;
}
internal class Microsoft.CodeAnalysis.Rename.RenameLocation : ValueType {
    public Location Location;
    public DocumentId DocumentId;
    public CandidateReason CandidateReason;
    public bool IsRenamableAliasUsage;
    public bool IsRenamableAccessor;
    public TextSpan ContainingLocationForStringOrComment;
    public bool IsWrittenTo;
    public bool IsRenameInStringOrComment { get; }
    public RenameLocation(Location location, DocumentId documentId, CandidateReason candidateReason, bool isRenamableAliasUsage, bool isRenamableAccessor, bool isWrittenTo, TextSpan containingLocationForStringOrComment);
    public RenameLocation(ReferenceLocation referenceLocation, DocumentId documentId);
    public bool get_IsRenameInStringOrComment();
    public sealed virtual bool Equals(RenameLocation other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal static bool ShouldRename(RenameLocation location);
    internal static bool ShouldRename(CandidateReason candidateReason);
}
internal class Microsoft.CodeAnalysis.Rename.RenameLocations : object {
    private SymbolAndProjectId _symbolAndProjectId;
    private Solution _solution;
    private SearchResult _mergedResult;
    [CompilerGeneratedAttribute]
private OptionSet <Options>k__BackingField;
    private SearchResult _originalSymbolResult;
    private List`1<SearchResult> _overloadsResult;
    private IEnumerable`1<RenameLocation> _stringsResult;
    private IEnumerable`1<RenameLocation> _commentsResult;
    internal OptionSet Options { get; }
    public ISet`1<RenameLocation> Locations { get; }
    public SymbolAndProjectId SymbolAndProjectId { get; }
    public ISymbol Symbol { get; }
    public Solution Solution { get; }
    public IEnumerable`1<SymbolAndProjectId> ReferencedSymbols { get; }
    public IEnumerable`1<ReferenceLocation> ImplicitLocations { get; }
    internal RenameLocations(ISet`1<RenameLocation> locations, SymbolAndProjectId symbolAndProjectId, Solution solution, IEnumerable`1<SymbolAndProjectId> referencedSymbols, IEnumerable`1<ReferenceLocation> implicitLocations, OptionSet options);
    private RenameLocations(SymbolAndProjectId symbolAndProjectId, Solution solution, OptionSet options, SearchResult originalSymbolResult, List`1<SearchResult> overloadsResult, IEnumerable`1<RenameLocation> stringsResult, IEnumerable`1<RenameLocation> commentsResult);
    [CompilerGeneratedAttribute]
internal OptionSet get_Options();
    public ISet`1<RenameLocation> get_Locations();
    public SymbolAndProjectId get_SymbolAndProjectId();
    public ISymbol get_Symbol();
    public Solution get_Solution();
    public IEnumerable`1<SymbolAndProjectId> get_ReferencedSymbols();
    public IEnumerable`1<ReferenceLocation> get_ImplicitLocations();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.RenameLocations/<FindAsync>d__26")]
internal static Task`1<RenameLocations> FindAsync(SymbolAndProjectId symbolAndProjectId, Solution solution, OptionSet optionSet, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.RenameLocations/<FindWithUpdatedOptionsAsync>d__27")]
internal Task`1<RenameLocations> FindWithUpdatedOptionsAsync(OptionSet optionSet, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.RenameLocations/<GetOverloadsAsync>d__28")]
private static Task`1<List`1<SearchResult>> GetOverloadsAsync(SymbolAndProjectId symbolAndProjectId, Solution solution, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Rename.RenameLocations/<GetOverloadedSymbols>d__29")]
internal static IEnumerable`1<SymbolAndProjectId> GetOverloadedSymbols(SymbolAndProjectId symbolAndProjectId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.RenameLocations/<AddLocationsReferenceSymbolsAsync>d__30")]
private static Task`1<SearchResult> AddLocationsReferenceSymbolsAsync(SymbolAndProjectId symbolAndProjectId, Solution solution, CancellationToken cancellationToken);
}
public static class Microsoft.CodeAnalysis.Rename.RenameOptions : object {
    [CompilerGeneratedAttribute]
private static Option`1<bool> <RenameOverloads>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <RenameInStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <RenameInComments>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <PreviewChanges>k__BackingField;
    public static Option`1<bool> RenameOverloads { get; }
    public static Option`1<bool> RenameInStrings { get; }
    public static Option`1<bool> RenameInComments { get; }
    public static Option`1<bool> PreviewChanges { get; }
    private static RenameOptions();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_RenameOverloads();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_RenameInStrings();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_RenameInComments();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_PreviewChanges();
}
public static class Microsoft.CodeAnalysis.Rename.Renamer : object {
    public static Task`1<Solution> RenameSymbolAsync(Solution solution, ISymbol symbol, string newName, OptionSet optionSet, CancellationToken cancellationToken);
    internal static Task`1<Solution> RenameSymbolAsync(Solution solution, SymbolAndProjectId symbolAndProjectId, string newName, OptionSet optionSet, CancellationToken cancellationToken);
    internal static Task`1<RenameLocations> GetRenameLocationsAsync(Solution solution, SymbolAndProjectId symbolAndProjectId, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.Renamer/<RenameAsync>d__3")]
internal static Task`1<Solution> RenameAsync(RenameLocations locations, string newName, Func`2<Location, bool> filter, Func`2<IEnumerable`1<ISymbol>, Nullable`1<bool>> hasConflict, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.Renamer/<RenameSymbolAsync>d__4")]
internal static Task`1<Solution> RenameSymbolAsync(Solution solution, SymbolAndProjectId symbolAndProjectId, string newName, OptionSet options, Func`2<Location, bool> filter, Func`2<IEnumerable`1<ISymbol>, Nullable`1<bool>> hasConflict, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Rename.RenameRewriterParameters : object {
    internal CancellationToken CancellationToken;
    internal ISet`1<TextSpan> ConflictLocationSpans;
    internal OptionSet OptionSet;
    internal Solution OriginalSolution;
    internal SyntaxTree OriginalSyntaxTree;
    internal string OriginalText;
    internal ICollection`1<string> PossibleNameConflicts;
    internal RenameAnnotation RenamedSymbolDeclarationAnnotation;
    internal Dictionary`2<TextSpan, RenameLocation> RenameLocations;
    internal RenamedSpansTracker RenameSpansTracker;
    internal ISymbol RenameSymbol;
    internal string ReplacementText;
    internal bool ReplacementTextValid;
    internal ISet`1<TextSpan> StringAndCommentTextSpans;
    internal SyntaxNode SyntaxRoot;
    internal Document Document;
    internal SemanticModel SemanticModel;
    internal AnnotationTable`1<RenameAnnotation> RenameAnnotations;
    public RenameRewriterParameters(RenameAnnotation renamedSymbolDeclarationAnnotation, Document document, SemanticModel semanticModel, SyntaxNode syntaxRoot, string replacementText, string originalText, ICollection`1<string> possibleNameConflicts, Dictionary`2<TextSpan, RenameLocation> renameLocations, ISet`1<TextSpan> stringAndCommentTextSpans, ISet`1<TextSpan> conflictLocationSpans, Solution originalSolution, ISymbol renameSymbol, bool replacementTextValid, RenamedSpansTracker renameSpansTracker, OptionSet optionSet, AnnotationTable`1<RenameAnnotation> renameAnnotations, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Rename.RenameUtilities : object {
    internal static SyntaxToken UpdateAliasAnnotation(SyntaxToken token, ISymbol aliasSymbol, string replacementText);
    internal static ImmutableArray`1<ISymbol> GetSymbolsTouchingPosition(int position, SemanticModel semanticModel, Workspace workspace, CancellationToken cancellationToken);
    private static bool IsSymbolDefinedInsideMethod(ISymbol symbol);
    internal static IEnumerable`1<Document> GetDocumentsAffectedByRename(ISymbol symbol, Solution solution, IEnumerable`1<RenameLocation> renameLocations);
    private static bool ShouldRenameOnlyAffectDeclaringProject(ISymbol symbol);
    internal static TokenRenameInfo GetTokenRenameInfo(ISemanticFactsService semanticFacts, SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Rename.TokenRenameInfo : object {
    [CompilerGeneratedAttribute]
private bool <HasSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ISymbol> <Symbols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMemberGroup>k__BackingField;
    public static TokenRenameInfo NoSymbolsTokenInfo;
    public bool HasSymbols { get; private set; }
    public IEnumerable`1<ISymbol> Symbols { get; private set; }
    public bool IsMemberGroup { get; private set; }
    private static TokenRenameInfo();
    [CompilerGeneratedAttribute]
public bool get_HasSymbols();
    [CompilerGeneratedAttribute]
private void set_HasSymbols(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ISymbol> get_Symbols();
    [CompilerGeneratedAttribute]
private void set_Symbols(IEnumerable`1<ISymbol> value);
    [CompilerGeneratedAttribute]
public bool get_IsMemberGroup();
    [CompilerGeneratedAttribute]
private void set_IsMemberGroup(bool value);
    public static TokenRenameInfo CreateMemberGroupTokenInfo(IEnumerable`1<ISymbol> symbols);
    public static TokenRenameInfo CreateSingleSymbolTokenInfo(ISymbol symbol);
}
internal class Microsoft.CodeAnalysis.SemanticDocument : SyntacticDocument {
    public SemanticModel SemanticModel;
    private SemanticDocument(Document document, SourceText text, SyntaxTree tree, SyntaxNode root, SemanticModel semanticModel);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SemanticDocument/<CreateAsync>d__2")]
public static Task`1<SemanticDocument> CreateAsync(Document document, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.SemanticModelWorkspaceService.ISemanticModelService {
    public abstract virtual Task`1<SemanticModel> GetSemanticModelForNodeAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.SemanticModelWorkspaceService.ISemanticModelService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SemanticModelWorkspaceService.SemanticModelWorkspaceServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal static class Microsoft.CodeAnalysis.SerializableBytes : object {
    private static int ChunkSize;
    internal static PooledStream CreateReadableStream(Byte[] bytes);
    internal static PooledStream CreateReadableStream(Byte[] bytes, int length);
    internal static PooledStream CreateReadableStream(Stream stream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SerializableBytes/<CreateReadableStreamAsync>d__4")]
internal static Task`1<PooledStream> CreateReadableStreamAsync(Stream stream, CancellationToken cancellationToken);
    private static void BlowChunks(Byte[][] chunks);
    internal static PooledStream CreateWritableStream();
}
internal class Microsoft.CodeAnalysis.Serialization.AnalyzerReferenceChecksumCollection : ChecksumCollection {
    public AnalyzerReferenceChecksumCollection(Checksum[] checksums);
    public AnalyzerReferenceChecksumCollection(Object[] checksums);
}
internal static class Microsoft.CodeAnalysis.Serialization.ChecksumCache : object {
    private static ConditionalWeakTable`2<object, object> s_cache;
    private static ChecksumCache();
    public static IReadOnlyList`1<T> GetOrCreate(IReadOnlyList`1<T> unorderedList, CreateValueCallback<object, object> orderedListGetter);
    public static Checksum GetOrCreate(object value, CreateValueCallback<object, object> checksumCreator);
    public static T GetOrCreate(object value, CreateValueCallback<object, object> checksumCreator);
}
[DefaultMemberAttribute("Item")]
internal abstract class Microsoft.CodeAnalysis.Serialization.ChecksumCollection : ChecksumWithChildren {
    public int Count { get; }
    public Checksum Item { get; }
    protected ChecksumCollection(WellKnownSynchronizationKind kind, Checksum[] checksums);
    protected ChecksumCollection(WellKnownSynchronizationKind kind, Object[] checksums);
    public int get_Count();
    public Checksum get_Item(int index);
    public sealed virtual IEnumerator`1<Checksum> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal abstract class Microsoft.CodeAnalysis.Serialization.ChecksumWithChildren : object {
    [CompilerGeneratedAttribute]
private Checksum <Checksum>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<object> <Children>k__BackingField;
    public Checksum Checksum { get; }
    public IReadOnlyList`1<object> Children { get; }
    public ChecksumWithChildren(WellKnownSynchronizationKind kind, Object[] children);
    [CompilerGeneratedAttribute]
public sealed virtual Checksum get_Checksum();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<object> get_Children();
    private static Checksum CreateChecksum(WellKnownSynchronizationKind kind, Object[] children);
}
internal class Microsoft.CodeAnalysis.Serialization.DocumentChecksumCollection : ChecksumCollection {
    public DocumentChecksumCollection(Checksum[] checksums);
    public DocumentChecksumCollection(Object[] checksums);
}
internal class Microsoft.CodeAnalysis.Serialization.DocumentStateChecksums : ChecksumWithChildren {
    public Checksum Info { get; }
    public Checksum Text { get; }
    public DocumentStateChecksums(Checksum infoChecksum, Checksum textChecksum);
    public DocumentStateChecksums(Object[] children);
    public Checksum get_Info();
    public Checksum get_Text();
    public void Find(TextDocumentState state, HashSet`1<Checksum> searchingChecksumsLeft, Dictionary`2<Checksum, object> result, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Serialization.ISerializerService {
    public abstract virtual void Serialize(object value, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void SerializeSourceText(ITemporaryStorageWithName storage, SourceText text, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void SerializeCompilationOptions(CompilationOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void SerializeParseOptions(ParseOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void SerializeProjectReference(ProjectReference reference, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void SerializeMetadataReference(MetadataReference reference, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void SerializeAnalyzerReference(AnalyzerReference reference, ObjectWriter writer, bool usePathFromAssembly, CancellationToken cancellationToken);
    public abstract virtual void SerializeChecksumWithChildren(ChecksumWithChildren checksums, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void SerializeOptionSet(OptionSet options, string language, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual T Deserialize(WellKnownSynchronizationKind kind, ObjectReader reader, CancellationToken cancellationToken);
    public abstract virtual Checksum CreateChecksum(object value, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Serialization.MetadataReferenceChecksumCollection : ChecksumCollection {
    public MetadataReferenceChecksumCollection(Checksum[] checksums);
    public MetadataReferenceChecksumCollection(Object[] checksums);
}
internal class Microsoft.CodeAnalysis.Serialization.ProjectChecksumCollection : ChecksumCollection {
    public ProjectChecksumCollection(Checksum[] checksums);
    public ProjectChecksumCollection(Object[] checksums);
}
internal class Microsoft.CodeAnalysis.Serialization.ProjectReferenceChecksumCollection : ChecksumCollection {
    public ProjectReferenceChecksumCollection(Checksum[] checksums);
    public ProjectReferenceChecksumCollection(Object[] checksums);
}
internal class Microsoft.CodeAnalysis.Serialization.ProjectStateChecksums : ChecksumWithChildren {
    public Checksum Info { get; }
    public Checksum CompilationOptions { get; }
    public Checksum ParseOptions { get; }
    public DocumentChecksumCollection Documents { get; }
    public ProjectReferenceChecksumCollection ProjectReferences { get; }
    public MetadataReferenceChecksumCollection MetadataReferences { get; }
    public AnalyzerReferenceChecksumCollection AnalyzerReferences { get; }
    public TextDocumentChecksumCollection AdditionalDocuments { get; }
    public ProjectStateChecksums(Checksum infoChecksum, Checksum compilationOptionsChecksum, Checksum parseOptionsChecksum, DocumentChecksumCollection documentChecksums, ProjectReferenceChecksumCollection projectReferenceChecksums, MetadataReferenceChecksumCollection metadataReferenceChecksums, AnalyzerReferenceChecksumCollection analyzerReferenceChecksums, TextDocumentChecksumCollection additionalDocumentChecksums);
    public ProjectStateChecksums(Object[] children);
    public Checksum get_Info();
    public Checksum get_CompilationOptions();
    public Checksum get_ParseOptions();
    public DocumentChecksumCollection get_Documents();
    public ProjectReferenceChecksumCollection get_ProjectReferences();
    public MetadataReferenceChecksumCollection get_MetadataReferences();
    public AnalyzerReferenceChecksumCollection get_AnalyzerReferences();
    public TextDocumentChecksumCollection get_AdditionalDocuments();
    public void Find(ProjectState state, HashSet`1<Checksum> searchingChecksumsLeft, Dictionary`2<Checksum, object> result, CancellationToken cancellationToken);
    private static void Find(IImmutableDictionary`2<DocumentId, T> values, HashSet`1<Checksum> searchingChecksumsLeft, Dictionary`2<Checksum, object> result, CancellationToken cancellationToken);
    private static void Find(IReadOnlyList`1<T> values, ChecksumWithChildren checksums, HashSet`1<Checksum> searchingChecksumsLeft, Dictionary`2<Checksum, object> result, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.Serialization.SerializationKinds : Enum {
    public int value__;
    public static SerializationKinds Bits;
    public static SerializationKinds FilePath;
    public static SerializationKinds MemoryMapFile;
}
internal class Microsoft.CodeAnalysis.Serialization.SerializerService : object {
    private HostWorkspaceServices _workspaceServices;
    private IReferenceSerializationService _hostSerializationService;
    private ITemporaryStorageService2 _tempService;
    private ITextFactoryService _textService;
    private ConcurrentDictionary`2<string, IOptionsSerializationService> _lazyLanguageSerializationService;
    private static byte ChecksumKind;
    private static byte ChecksumWithChildrenKind;
    private static ImmutableDictionary`2<WellKnownSynchronizationKind, Func`2<Object[], ChecksumWithChildren>> s_creatorMap;
    [ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public SerializerService(HostWorkspaceServices workspaceServices);
    private static SerializerService();
    public sealed virtual Checksum CreateChecksum(object value, CancellationToken cancellationToken);
    public sealed virtual void Serialize(object value, ObjectWriter writer, CancellationToken cancellationToken);
    public sealed virtual T Deserialize(WellKnownSynchronizationKind kind, ObjectReader reader, CancellationToken cancellationToken);
    private IOptionsSerializationService GetOptionsSerializationService(string languageName);
    public sealed virtual void SerializeSourceText(ITemporaryStorageWithName storage, SourceText text, ObjectWriter writer, CancellationToken cancellationToken);
    private SourceText DeserializeSourceText(ObjectReader reader, CancellationToken cancellationToken);
    public sealed virtual void SerializeCompilationOptions(CompilationOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    private CompilationOptions DeserializeCompilationOptions(ObjectReader reader, CancellationToken cancellationToken);
    public sealed virtual void SerializeParseOptions(ParseOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    private ParseOptions DeserializeParseOptions(ObjectReader reader, CancellationToken cancellationToken);
    public sealed virtual void SerializeProjectReference(ProjectReference reference, ObjectWriter writer, CancellationToken cancellationToken);
    private ProjectReference DeserializeProjectReference(ObjectReader reader, CancellationToken cancellationToken);
    public sealed virtual void SerializeMetadataReference(MetadataReference reference, ObjectWriter writer, CancellationToken cancellationToken);
    private MetadataReference DeserializeMetadataReference(ObjectReader reader, CancellationToken cancellationToken);
    public sealed virtual void SerializeAnalyzerReference(AnalyzerReference reference, ObjectWriter writer, bool usePathFromAssembly, CancellationToken cancellationToken);
    private AnalyzerReference DeserializeAnalyzerReference(ObjectReader reader, CancellationToken cancellationToken);
    public sealed virtual void SerializeChecksumWithChildren(ChecksumWithChildren checksums, ObjectWriter writer, CancellationToken cancellationToken);
    private ChecksumWithChildren DeserializeChecksumWithChildren(ObjectReader reader, CancellationToken cancellationToken);
    private static ImmutableDictionary`2<WellKnownSynchronizationKind, Func`2<Object[], ChecksumWithChildren>> CreateCreatorMap();
    public sealed virtual void SerializeOptionSet(OptionSet options, string language, ObjectWriter writer, CancellationToken cancellationToken);
    private OptionSet DeserializeOptionSet(ObjectReader reader, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private IOptionsSerializationService <GetOptionsSerializationService>b__9_0(string n);
}
internal class Microsoft.CodeAnalysis.Serialization.SolutionStateChecksums : ChecksumWithChildren {
    public Checksum Info { get; }
    public ProjectChecksumCollection Projects { get; }
    public SolutionStateChecksums(Checksum infoChecksum, ProjectChecksumCollection projectChecksums);
    public SolutionStateChecksums(Object[] children);
    public Checksum get_Info();
    public ProjectChecksumCollection get_Projects();
    public void Find(SolutionState state, HashSet`1<Checksum> searchingChecksumsLeft, Dictionary`2<Checksum, object> result, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Serialization.TextDocumentChecksumCollection : ChecksumCollection {
    public TextDocumentChecksumCollection(Checksum[] checksums);
    public TextDocumentChecksumCollection(Object[] checksums);
}
internal enum Microsoft.CodeAnalysis.Serialization.WellKnownSynchronizationKind : Enum {
    public int value__;
    public static WellKnownSynchronizationKind Null;
    public static WellKnownSynchronizationKind SolutionState;
    public static WellKnownSynchronizationKind ProjectState;
    public static WellKnownSynchronizationKind DocumentState;
    public static WellKnownSynchronizationKind Projects;
    public static WellKnownSynchronizationKind Documents;
    public static WellKnownSynchronizationKind TextDocuments;
    public static WellKnownSynchronizationKind ProjectReferences;
    public static WellKnownSynchronizationKind MetadataReferences;
    public static WellKnownSynchronizationKind AnalyzerReferences;
    public static WellKnownSynchronizationKind SolutionAttributes;
    public static WellKnownSynchronizationKind ProjectAttributes;
    public static WellKnownSynchronizationKind DocumentAttributes;
    public static WellKnownSynchronizationKind CompilationOptions;
    public static WellKnownSynchronizationKind ParseOptions;
    public static WellKnownSynchronizationKind ProjectReference;
    public static WellKnownSynchronizationKind MetadataReference;
    public static WellKnownSynchronizationKind AnalyzerReference;
    public static WellKnownSynchronizationKind SourceText;
    public static WellKnownSynchronizationKind OptionSet;
    public static WellKnownSynchronizationKind RecoverableSourceText;
    public static WellKnownSynchronizationKind SyntaxTreeIndex;
    public static WellKnownSynchronizationKind SymbolTreeInfo;
    public static WellKnownSynchronizationKind ProjectReferenceChecksumCollection;
    public static WellKnownSynchronizationKind MetadataReferenceChecksumCollection;
    public static WellKnownSynchronizationKind AnalyzerReferenceChecksumCollection;
    public static WellKnownSynchronizationKind TextDocumentChecksumCollection;
    public static WellKnownSynchronizationKind DocumentChecksumCollection;
    public static WellKnownSynchronizationKind ProjectChecksumCollection;
    public static WellKnownSynchronizationKind SolutionStateChecksums;
    public static WellKnownSynchronizationKind ProjectStateChecksums;
    public static WellKnownSynchronizationKind DocumentStateChecksums;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Serialization.WellKnownSynchronizationKindExtensions : object {
    private static String[] s_strings;
    private static WellKnownSynchronizationKindExtensions();
    [ExtensionAttribute]
public static string ToStringFast(WellKnownSynchronizationKind kind);
}
internal interface Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector`1 {
    public abstract virtual int GetStart(T value);
    public abstract virtual int GetLength(T value);
}
internal static class Microsoft.CodeAnalysis.Shared.Collections.IntervalTree : object {
    public static IntervalTree`1<T> Create(IIntervalIntrospector`1<T> introspector, T[] values);
    public static IntervalTree`1<T> Create(IIntervalIntrospector`1<T> introspector, IEnumerable`1<T> values);
}
internal class Microsoft.CodeAnalysis.Shared.Collections.IntervalTree`1 : object {
    public static IntervalTree`1<T> Empty;
    protected Node<T> root;
    private static TestInterval<T> s_intersectsWithTest;
    private static TestInterval<T> s_containsTest;
    private static TestInterval<T> s_overlapsWithTest;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ObjectPool`1<Stack`1<ValueTuple`2<Node<T>, bool>>> s_stackPool;
    public IntervalTree`1(IIntervalIntrospector`1<T> introspector, IEnumerable`1<T> values);
    private static IntervalTree`1();
    protected static bool Contains(T value, int start, int length, IIntervalIntrospector`1<T> introspector);
    private static bool IntersectsWith(T value, int start, int length, IIntervalIntrospector`1<T> introspector);
    private static bool OverlapsWith(T value, int start, int length, IIntervalIntrospector`1<T> introspector);
    public ImmutableArray`1<T> GetIntervalsThatOverlapWith(int start, int length, IIntervalIntrospector`1<T> introspector);
    public ImmutableArray`1<T> GetIntervalsThatIntersectWith(int start, int length, IIntervalIntrospector`1<T> introspector);
    public ImmutableArray`1<T> GetIntervalsThatContain(int start, int length, IIntervalIntrospector`1<T> introspector);
    public void FillWithIntervalsThatOverlapWith(int start, int length, ArrayBuilder`1<T> builder, IIntervalIntrospector`1<T> introspector);
    public void FillWithIntervalsThatIntersectWith(int start, int length, ArrayBuilder`1<T> builder, IIntervalIntrospector`1<T> introspector);
    public void FillWithIntervalsThatContain(int start, int length, ArrayBuilder`1<T> builder, IIntervalIntrospector`1<T> introspector);
    public bool HasIntervalThatIntersectsWith(int position, IIntervalIntrospector`1<T> introspector);
    public bool HasIntervalThatIntersectsWith(int start, int length, IIntervalIntrospector`1<T> introspector);
    public bool HasIntervalThatOverlapsWith(int start, int length, IIntervalIntrospector`1<T> introspector);
    public bool HasIntervalThatContains(int start, int length, IIntervalIntrospector`1<T> introspector);
    private bool Any(int start, int length, TestInterval<T> testInterval, IIntervalIntrospector`1<T> introspector);
    private ImmutableArray`1<T> GetIntervalsThatMatch(int start, int length, TestInterval<T> testInterval, IIntervalIntrospector`1<T> introspector);
    private void FillWithIntervalsThatMatch(int start, int length, TestInterval<T> testInterval, ArrayBuilder`1<T> builder, IIntervalIntrospector`1<T> introspector, bool stopAfterFirst);
    private void FillWithIntervalsThatMatch(int start, int length, TestInterval<T> testInterval, ArrayBuilder`1<T> builder, IIntervalIntrospector`1<T> introspector, bool stopAfterFirst, Stack`1<ValueTuple`2<Node<T>, bool>> candidates);
    public bool IsEmpty();
    protected static Node<T> Insert(Node<T> root, Node<T> newNode, IIntervalIntrospector`1<T> introspector);
    private static Node<T> Insert(Node<T> root, Node<T> newNode, int newNodeStart, IIntervalIntrospector`1<T> introspector);
    private static Node<T> Balance(Node<T> node, IIntervalIntrospector`1<T> introspector);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Collections.IntervalTree`1/<GetEnumerator>d__30")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected static int GetEnd(T value, IIntervalIntrospector`1<T> introspector);
    protected static int MaxEndValue(Node<T> node, IIntervalIntrospector`1<T> arg);
    private static int Height(Node<T> node);
    private static int BalanceFactor(Node<T> node);
}
internal class Microsoft.CodeAnalysis.Shared.Collections.SimpleIntervalTree : object {
    public static SimpleIntervalTree`1<T> Create(IIntervalIntrospector`1<T> introspector, T[] values);
    public static SimpleIntervalTree`1<T> Create(IIntervalIntrospector`1<T> introspector, IEnumerable`1<T> values);
}
internal class Microsoft.CodeAnalysis.Shared.Collections.SimpleIntervalTree`1 : IntervalTree`1<T> {
    private IIntervalIntrospector`1<T> _introspector;
    protected IIntervalIntrospector`1<T> Introspector { get; }
    public SimpleIntervalTree`1(IIntervalIntrospector`1<T> introspector, IEnumerable`1<T> values);
    protected IIntervalIntrospector`1<T> get_Introspector();
    public void AddIntervalInPlace(T value);
    public ImmutableArray`1<T> GetIntervalsThatOverlapWith(int start, int length);
    public ImmutableArray`1<T> GetIntervalsThatIntersectWith(int start, int length);
    public ImmutableArray`1<T> GetIntervalsThatContain(int start, int length);
    public void FillWithIntervalsThatOverlapWith(int start, int length, ArrayBuilder`1<T> builder);
    public void FillWithIntervalsThatIntersectWith(int start, int length, ArrayBuilder`1<T> builder);
    public void FillWithIntervalsThatContain(int start, int length, ArrayBuilder`1<T> builder);
    public bool HasIntervalThatIntersectsWith(int position);
    public bool HasIntervalThatOverlapsWith(int start, int length);
    public bool HasIntervalThatIntersectsWith(int start, int length);
    public bool HasIntervalThatContains(int start, int length);
    protected int MaxEndValue(Node<T> node);
}
internal class Microsoft.CodeAnalysis.Shared.Collections.TextSpanIntervalIntrospector : object {
    public static IIntervalIntrospector`1<TextSpan> Instance;
    private static TextSpanIntervalIntrospector();
    public sealed virtual int GetStart(TextSpan value);
    public sealed virtual int GetLength(TextSpan value);
}
internal static class Microsoft.CodeAnalysis.Shared.Extensions.AccessibilityUtilities : object {
    public static Accessibility Minimum(Accessibility accessibility1, Accessibility accessibility2);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ArrayExtensions : object {
    [ExtensionAttribute]
public static bool IsNullOrEmpty(T[] array);
    [ExtensionAttribute]
public static bool Contains(T[] array, T item);
}
internal abstract class Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext : object {
    private ISet`1<INamedTypeSymbol> _outerTypes;
    [CompilerGeneratedAttribute]
private Workspace <Workspace>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxTree <SyntaxTree>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <LeftToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <TargetToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTypeContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNamespaceContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNamespaceDeclarationNameContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPreProcessorDirectiveContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRightOfNameSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatementContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAnyExpressionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAttributeNameContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnumTypeMemberAccessContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNameOfContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInImportsDirective>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWithinAsyncMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPossibleTupleContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPatternContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ITypeSymbol> <InferredTypes>k__BackingField;
    public Workspace Workspace { get; }
    public SemanticModel SemanticModel { get; }
    public SyntaxTree SyntaxTree { get; }
    public int Position { get; }
    public SyntaxToken LeftToken { get; }
    public SyntaxToken TargetToken { get; }
    public bool IsTypeContext { get; }
    public bool IsNamespaceContext { get; }
    public bool IsNamespaceDeclarationNameContext { get; }
    public bool IsPreProcessorDirectiveContext { get; }
    public bool IsRightOfNameSeparator { get; }
    public bool IsStatementContext { get; }
    public bool IsAnyExpressionContext { get; }
    public bool IsAttributeNameContext { get; }
    public bool IsEnumTypeMemberAccessContext { get; }
    public bool IsNameOfContext { get; }
    public bool IsInQuery { get; }
    public bool IsInImportsDirective { get; }
    public bool IsWithinAsyncMethod { get; }
    public bool IsPossibleTupleContext { get; }
    public bool IsPatternContext { get; }
    public ImmutableArray`1<ITypeSymbol> InferredTypes { get; }
    protected SyntaxContext(Workspace workspace, SemanticModel semanticModel, int position, SyntaxToken leftToken, SyntaxToken targetToken, bool isTypeContext, bool isNamespaceContext, bool isNamespaceDeclarationNameContext, bool isPreProcessorDirectiveContext, bool isRightOfNameSeparator, bool isStatementContext, bool isAnyExpressionContext, bool isAttributeNameContext, bool isEnumTypeMemberAccessContext, bool isNameOfContext, bool isInQuery, bool isInImportsDirective, bool isWithinAsyncMethod, bool isPossibleTupleContext, bool isPatternContext, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public Workspace get_Workspace();
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public SyntaxTree get_SyntaxTree();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public SyntaxToken get_LeftToken();
    [CompilerGeneratedAttribute]
public SyntaxToken get_TargetToken();
    [CompilerGeneratedAttribute]
public bool get_IsTypeContext();
    [CompilerGeneratedAttribute]
public bool get_IsNamespaceContext();
    [CompilerGeneratedAttribute]
public bool get_IsNamespaceDeclarationNameContext();
    [CompilerGeneratedAttribute]
public bool get_IsPreProcessorDirectiveContext();
    [CompilerGeneratedAttribute]
public bool get_IsRightOfNameSeparator();
    [CompilerGeneratedAttribute]
public bool get_IsStatementContext();
    [CompilerGeneratedAttribute]
public bool get_IsAnyExpressionContext();
    [CompilerGeneratedAttribute]
public bool get_IsAttributeNameContext();
    [CompilerGeneratedAttribute]
public bool get_IsEnumTypeMemberAccessContext();
    [CompilerGeneratedAttribute]
public bool get_IsNameOfContext();
    [CompilerGeneratedAttribute]
public bool get_IsInQuery();
    [CompilerGeneratedAttribute]
public bool get_IsInImportsDirective();
    [CompilerGeneratedAttribute]
public bool get_IsWithinAsyncMethod();
    [CompilerGeneratedAttribute]
public bool get_IsPossibleTupleContext();
    [CompilerGeneratedAttribute]
public bool get_IsPatternContext();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ITypeSymbol> get_InferredTypes();
    private ISet`1<INamedTypeSymbol> ComputeOuterTypes(CancellationToken cancellationToken);
    protected ImmutableArray`1<ITypeSymbol> ComputeInferredTypes(Workspace workspace, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    internal abstract virtual ITypeInferenceService GetTypeInferenceServiceWithoutWorkspace();
    public ISet`1<INamedTypeSymbol> GetOuterTypes(CancellationToken cancellationToken);
    public TService GetLanguageService();
    public TService GetWorkspaceService();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions : object {
    [ExtensionAttribute]
public static TLanguageService GetLanguageService(TextDocument document);
    [ExtensionAttribute]
public static TLanguageService GetLanguageService(Document document);
    [ExtensionAttribute]
public static bool IsOpen(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetSemanticModelForSpanAsync>d__3")]
[ExtensionAttribute]
public static Task`1<SemanticModel> GetSemanticModelForSpanAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<SemanticModel> GetSemanticModelForNodeAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    private static Task`1<SemanticModel> GetSemanticModelForNodeAsync(ISemanticModelService semanticModelService, ISyntaxFactsService syntaxFactService, Document document, SyntaxNode node, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsFromPrimaryBranch(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<IsForkedDocumentWithSyntaxChangesAsync>d__7")]
[ExtensionAttribute]
public static Task`1<bool> IsForkedDocumentWithSyntaxChangesAsync(Document document, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<SyntaxTreeIndex> GetSyntaxTreeIndexAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetPartialSemanticModelAsync>d__9")]
[ExtensionAttribute]
public static Task`1<SemanticModel> GetPartialSemanticModelAsync(Document document, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsGeneratedCode(Document document, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.FileLinePositionSpanExtensions : object {
    [ExtensionAttribute]
public static string GetMappedFilePathIfExist(FileLinePositionSpan fileLinePositionSpan);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IAssemblySymbolExtensions : object {
    private static string AttributeSuffix;
    [ExtensionAttribute]
public static bool ContainsNamespaceName(List`1<IAssemblySymbol> assemblies, string namespaceName);
    [ExtensionAttribute]
public static bool ContainsTypeName(List`1<IAssemblySymbol> assemblies, string typeName, bool tryWithAttributeSuffix);
    [ExtensionAttribute]
public static bool IsSameAssemblyOrHasFriendAccessTo(IAssemblySymbol assembly, IAssemblySymbol toAssembly);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ICodeDefinitionFactoryExtensions : object {
    private static string EqualsName;
    private static string DefaultName;
    private static string ObjName;
    private static string OtherName;
    private static string GetHashCodeName;
    [ExtensionAttribute]
public static SyntaxNode CreateThrowNotImplementedStatement(SyntaxGenerator codeDefinitionFactory, Compilation compilation);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> CreateThrowNotImplementedStatementBlock(SyntaxGenerator codeDefinitionFactory, Compilation compilation);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> CreateArguments(SyntaxGenerator factory, ImmutableArray`1<IParameterSymbol> parameters);
    [ExtensionAttribute]
private static SyntaxNode CreateArgument(SyntaxGenerator factory, IParameterSymbol parameter);
    [ExtensionAttribute]
public static IMethodSymbol CreateBaseDelegatingConstructor(SyntaxGenerator factory, IMethodSymbol constructor, string typeName);
    [ExtensionAttribute]
public static ValueTuple`2<ImmutableArray`1<ISymbol>, ISymbol> CreateFieldDelegatingConstructor(SyntaxGenerator factory, Compilation compilation, string typeName, INamedTypeSymbol containingTypeOpt, ImmutableArray`1<IParameterSymbol> parameters, IDictionary`2<string, ISymbol> parameterToExistingFieldMap, IDictionary`2<string, string> parameterToNewFieldMap, bool addNullChecks, bool preferThrowExpression, CancellationToken cancellationToken);
    private static ImmutableArray`1<SyntaxNode> GetThisConstructorArguments(INamedTypeSymbol containingTypeOpt, IDictionary`2<string, ISymbol> parameterToExistingFieldMap);
    [ExtensionAttribute]
public static ImmutableArray`1<IFieldSymbol> CreateFieldsForParameters(SyntaxGenerator factory, IList`1<IParameterSymbol> parameters, IDictionary`2<string, string> parameterToNewFieldMap);
    private static bool TryGetValue(IDictionary`2<string, string> dictionary, string key, String& value);
    private static bool TryGetValue(IDictionary`2<string, ISymbol> dictionary, string key, String& value);
    [ExtensionAttribute]
public static SyntaxNode CreateThrowArgumentNullExpression(SyntaxGenerator factory, Compilation compilation, IParameterSymbol parameter);
    [ExtensionAttribute]
public static SyntaxNode CreateIfNullThrowStatement(SyntaxGenerator factory, Compilation compilation, IParameterSymbol parameter);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> CreateAssignmentStatements(SyntaxGenerator factory, Compilation compilation, IList`1<IParameterSymbol> parameters, IDictionary`2<string, ISymbol> parameterToExistingFieldMap, IDictionary`2<string, string> parameterToNewFieldMap, bool addNullChecks, bool preferThrowExpression);
    [ExtensionAttribute]
public static void AddAssignmentStatements(SyntaxGenerator factory, Compilation compilation, IParameterSymbol parameter, SyntaxNode fieldAccess, bool addNullChecks, bool preferThrowExpression, ArrayBuilder`1<SyntaxNode> nullCheckStatements, ArrayBuilder`1<SyntaxNode> assignStatements);
    [ExtensionAttribute]
public static SyntaxNode CreateAssignWithNullCheckStatement(SyntaxGenerator factory, Compilation compilation, IParameterSymbol parameter, SyntaxNode fieldAccess);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ICodeDefinitionFactoryExtensions/<OverridePropertyAsync>d__15")]
[ExtensionAttribute]
public static Task`1<IPropertySymbol> OverridePropertyAsync(SyntaxGenerator codeFactory, IPropertySymbol overriddenProperty, DeclarationModifiers modifiers, INamedTypeSymbol containingType, Document document, CancellationToken cancellationToken);
    private static SyntaxNode WrapWithRefIfNecessary(SyntaxGenerator codeFactory, IPropertySymbol overriddenProperty, SyntaxNode body);
    [ExtensionAttribute]
public static IEventSymbol OverrideEvent(SyntaxGenerator codeFactory, IEventSymbol overriddenEvent, DeclarationModifiers modifiers, INamedTypeSymbol newContainingType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ICodeDefinitionFactoryExtensions/<OverrideAsync>d__18")]
[ExtensionAttribute]
public static Task`1<ISymbol> OverrideAsync(SyntaxGenerator generator, ISymbol symbol, INamedTypeSymbol containingType, Document document, Nullable`1<DeclarationModifiers> modifiersOpt, CancellationToken cancellationToken);
    private static DeclarationModifiers GetOverrideModifiers(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ICodeDefinitionFactoryExtensions/<OverrideMethodAsync>d__20")]
[ExtensionAttribute]
private static Task`1<IMethodSymbol> OverrideMethodAsync(SyntaxGenerator codeFactory, IMethodSymbol overriddenMethod, DeclarationModifiers modifiers, INamedTypeSymbol newContainingType, Document newDocument, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol CreateEqualsMethod(SyntaxGenerator factory, Compilation compilation, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> symbols, SyntaxAnnotation statementAnnotation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol CreateEqualsMethod(Compilation compilation, ImmutableArray`1<SyntaxNode> statements);
    [ExtensionAttribute]
public static IMethodSymbol CreateIEqutableEqualsMethod(SyntaxGenerator factory, Compilation compilation, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> symbols, SyntaxAnnotation statementAnnotation, CancellationToken cancellationToken);
    private static ImmutableArray`1<SyntaxNode> CreateEqualsMethodStatements(SyntaxGenerator factory, Compilation compilation, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> members, CancellationToken cancellationToken);
    private static void AddMemberChecks(SyntaxGenerator factory, Compilation compilation, ImmutableArray`1<ISymbol> members, SyntaxNode localNameExpression, ArrayBuilder`1<SyntaxNode> expressions);
    private static ImmutableArray`1<SyntaxNode> CreateIEquatableEqualsMethodStatements(SyntaxGenerator factory, Compilation compilation, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> members, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static string GetLocalName(ITypeSymbol containingType);
    private static bool ImplementsIEquatable(ITypeSymbol memberType, INamedTypeSymbol iequatableType);
    private static bool IsPrimitiveValueType(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static SyntaxNode GetDefaultEqualityComparer(SyntaxGenerator factory, Compilation compilation, ITypeSymbol type);
    private static ITypeSymbol GetType(Compilation compilation, ISymbol symbol);
    private static bool HasExistingBaseEqualsMethod(INamedTypeSymbol containingType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> GetGetHashCodeComponents(SyntaxGenerator factory, Compilation compilation, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> members, bool justMemberReference, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> CreateGetHashCodeMethodStatements(SyntaxGenerator factory, Compilation compilation, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> members, bool useInt64, CancellationToken cancellationToken);
    private static SyntaxNode CreateLiteralExpression(SyntaxGenerator factory, int value);
    public static IMethodSymbol GetBaseGetHashCodeMethod(INamedTypeSymbol containingType, CancellationToken cancellationToken);
    private static SyntaxNode GetMemberForGetHashCode(SyntaxGenerator factory, Compilation compilation, ISymbol member, bool justMemberReference);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ICollectionExtensions : object {
    [ExtensionAttribute]
public static void RemoveRange(ICollection`1<T> collection, IEnumerable`1<T> items);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IComparerExtensions : object {
    [ExtensionAttribute]
public static IComparer`1<T> Inverse(IComparer`1<T> comparer);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ICompilationExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<Compilation> GetReferencedCompilations(Compilation compilation);
    [ExtensionAttribute]
public static ImmutableArray`1<IAssemblySymbol> GetReferencedAssemblySymbols(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol AttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ExceptionType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DesignerCategoryAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DesignerGeneratedAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol HideModuleNameAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol EventArgsType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol NotImplementedExceptionType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol EqualityComparerOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ActionType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ExpressionOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol EditorBrowsableAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol EditorBrowsableStateType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol TaskType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol TaskOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ValueTaskOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol IEnumerableOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SerializableAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol CoClassType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ComAliasNameAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SuppressMessageAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol TupleElementNamesAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DynamicAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol LazyOfTType(Compilation compilation);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IEnumerableExtensions : object {
    [ExtensionAttribute]
public static Task`1<IEnumerable`1<S>> SelectManyAsync(IEnumerable`1<T> sequence, Func`3<T, CancellationToken, Task`1<IEnumerable`1<S>>> selector, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IFindReferencesResultExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Location> GetDefinitionLocationsToShow(ISymbol definition);
    [ExtensionAttribute]
public static IEnumerable`1<ReferencedSymbol> FilterToItemsToShow(IEnumerable`1<ReferencedSymbol> result);
    [ExtensionAttribute]
public static bool ShouldShow(ReferencedSymbol referencedSymbol);
    [ExtensionAttribute]
public static bool ShouldShowWithNoReferenceLocations(ISymbol definition, bool showMetadataSymbolsWithoutReferences);
    [ExtensionAttribute]
public static IEnumerable`1<ReferencedSymbol> FilterToAliasMatches(IEnumerable`1<ReferencedSymbol> result, IAliasSymbol aliasSymbolOpt);
    [ExtensionAttribute]
public static IEnumerable`1<ReferencedSymbol> FilterNonMatchingMethodNames(IEnumerable`1<ReferencedSymbol> result, Solution solution, ISymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.IFindReferencesResultExtensions/<FilterNonMatchingMethodNamesWorker>d__6")]
private static IEnumerable`1<ReferencedSymbol> FilterNonMatchingMethodNamesWorker(IEnumerable`1<ReferencedSymbol> result, Solution solution, ISymbol symbol);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ILanguageMetadataExtensions : object {
    [ExtensionAttribute]
public static TInterface ToSpecificLanguage(IEnumerable`1<Lazy`2<TInterface, TMetadata>> services, string languageName);
    [ExtensionAttribute]
public static IEnumerable`1<TInterface> FilterToSpecificLanguage(IEnumerable`1<Lazy`2<TInterface, TMetadata>> services, string languageName);
    [ExtensionAttribute]
public static Dictionary`2<string, List`1<Lazy`2<TInterface, TMetadata>>> ToPerLanguageMap(IEnumerable`1<Lazy`2<TInterface, TMetadata>> services);
    [ExtensionAttribute]
public static Dictionary`2<string, List`1<Lazy`2<TInterface, TMetadata>>> ToPerLanguageMapWithMultipleLanguages(IEnumerable`1<Lazy`2<TInterface, TMetadata>> services);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ILanguageServiceProviderExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Lazy`2<T, TMetadata>> SelectMatchingExtensions(HostLanguageServices serviceProvider, IEnumerable`1<Lazy`2<T, TMetadata>> items);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IListExtensions : object {
    [ExtensionAttribute]
public static int IndexOf(IList`1<T> list, Func`2<T, bool> predicate);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IMethodSymbolExtensions : object {
    [ExtensionAttribute]
public static bool CompatibleSignatureToDelegate(IMethodSymbol method, INamedTypeSymbol delegateType);
    [ExtensionAttribute]
public static ImmutableArray`1<IMethodSymbol> GetAllMethodSymbolsOfPartialParts(IMethodSymbol method);
    [ExtensionAttribute]
public static IMethodSymbol RenameTypeParameters(IMethodSymbol method, IList`1<string> newNames);
    [ExtensionAttribute]
public static IMethodSymbol RenameParameters(IMethodSymbol method, IList`1<string> parameterNames);
    private static ImmutableArray`1<ITypeParameterSymbol> RenameTypeParameters(ImmutableArray`1<ITypeParameterSymbol> typeParameters, IList`1<string> newNames, ITypeGenerator typeGenerator);
    [ExtensionAttribute]
public static IMethodSymbol EnsureNonConflictingNames(IMethodSymbol method, INamedTypeSymbol containingType, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IMethodSymbol RemoveInaccessibleAttributesAndAttributesOfTypes(IMethodSymbol method, ISymbol accessibleWithin, INamedTypeSymbol[] removeAttributeTypes);
    [ExtensionAttribute]
private static IMethodSymbol RemoveAttributesCore(IMethodSymbol method, Func`2<AttributeData, bool> shouldRemoveAttribute, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> handlesExpressions);
    [ExtensionAttribute]
public static Nullable`1<bool> IsMoreSpecificThan(IMethodSymbol method1, IMethodSymbol method2);
    [ExtensionAttribute]
public static bool TryGetPredefinedComparisonOperator(IMethodSymbol symbol, PredefinedOperator& op);
    [ExtensionAttribute]
public static PredefinedOperator GetPredefinedOperator(IMethodSymbol symbol);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.INamedTypeSymbolExtensions : object {
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamedTypeSymbolExtensions/<GetBaseTypesAndThis>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypesAndThis(INamedTypeSymbol namedType);
    [ExtensionAttribute]
public static IEnumerable`1<ITypeParameterSymbol> GetAllTypeParameters(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetAllTypeArguments(INamedTypeSymbol symbol);
    private static Stack`1<INamedTypeSymbol> GetContainmentStack(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsContainedWithin(INamedTypeSymbol symbol, INamedTypeSymbol outer);
    [ExtensionAttribute]
public static ISymbol FindImplementationForAbstractMember(INamedTypeSymbol type, ISymbol symbol);
    [ExtensionAttribute]
internal static ISymbol GetOverriddenMember(ISymbol symbol);
    private static bool ImplementationExists(INamedTypeSymbol classOrStructType, ISymbol member);
    [ExtensionAttribute]
private static bool IsImplemented(INamedTypeSymbol classOrStructType, ISymbol member, Func`3<INamedTypeSymbol, ISymbol, bool> isValidImplementation, CancellationToken cancellationToken);
    private static bool IsInterfacePropertyImplemented(INamedTypeSymbol classOrStructType, IPropertySymbol propertySymbol, CancellationToken cancellationToken);
    private static bool IsAbstractPropertyImplemented(INamedTypeSymbol classOrStructType, IPropertySymbol propertySymbol, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static bool IsExplicitlyImplemented(INamedTypeSymbol classOrStructType, ISymbol member, Func`3<INamedTypeSymbol, ISymbol, bool> isValid, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> GetAllUnimplementedMembers(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> GetAllUnimplementedMembersInThis(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> GetAllUnimplementedMembersInThis(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, Func`3<INamedTypeSymbol, ISymbol, ImmutableArray`1<ISymbol>> interfaceMemberGetter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> GetAllUnimplementedExplicitMembers(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfaces, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> GetAllUnimplementedMembers(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, Func`5<INamedTypeSymbol, ISymbol, Func`3<INamedTypeSymbol, ISymbol, bool>, CancellationToken, bool> isImplemented, Func`3<INamedTypeSymbol, ISymbol, bool> isValidImplementation, Func`3<INamedTypeSymbol, ISymbol, ImmutableArray`1<ISymbol>> interfaceMemberGetter, bool allowReimplementation, CancellationToken cancellationToken);
    private static ImmutableArray`1<INamedTypeSymbol> GetTypesToImplement(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, bool allowReimplementation, CancellationToken cancellationToken);
    private static ImmutableArray`1<INamedTypeSymbol> GetAbstractClassesToImplement(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> abstractClasses, CancellationToken cancellationToken);
    private static ImmutableArray`1<INamedTypeSymbol> GetInterfacesToImplement(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfaces, bool allowReimplementation, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static ImmutableArray`1<ISymbol> GetUnimplementedMembers(INamedTypeSymbol classOrStructType, INamedTypeSymbol interfaceType, Func`5<INamedTypeSymbol, ISymbol, Func`3<INamedTypeSymbol, ISymbol, bool>, CancellationToken, bool> isImplemented, Func`3<INamedTypeSymbol, ISymbol, bool> isValidImplementation, Func`3<INamedTypeSymbol, ISymbol, ImmutableArray`1<ISymbol>> interfaceMemberGetter, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamedTypeSymbolExtensions/<GetAttributeNamedParameters>d__21")]
[ExtensionAttribute]
public static IEnumerable`1<ISymbol> GetAttributeNamedParameters(INamedTypeSymbol attributeSymbol, Compilation compilation, ISymbol within);
    private static ISymbol IsAttributeNamedParameter(ISymbol symbol, ISymbol within);
    private static ImmutableArray`1<ISymbol> GetMembers(INamedTypeSymbol type, ISymbol within);
    [ExtensionAttribute]
public static INamespaceOrTypeSymbol GenerateRootNamespaceOrType(INamedTypeSymbol namedType, String[] containers);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetOverridableMembers(INamedTypeSymbol containingType, CancellationToken cancellationToken);
    private static void AddOverridableMembers(Dictionary`2<ISymbol, int> result, INamedTypeSymbol containingType, INamedTypeSymbol type, Int32& index, CancellationToken cancellationToken);
    private static bool IsOverridable(ISymbol member, INamedTypeSymbol containingType);
    private static void RemoveOverriddenMembers(Dictionary`2<ISymbol, int> result, INamedTypeSymbol containingType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol TryConstruct(INamedTypeSymbol type, ITypeSymbol[] typeArguments);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.INamespaceOrTypeSymbolExtensions : object {
    private static ConditionalWeakTable`2<INamespaceOrTypeSymbol, List`1<string>> s_namespaceOrTypeToNameMap;
    public static CreateValueCallback<INamespaceOrTypeSymbol, List`1<string>> s_getNamePartsCallBack;
    private static SymbolDisplayFormat s_shortNameFormat;
    private static INamespaceOrTypeSymbolExtensions();
    [ExtensionAttribute]
public static string GetShortName(INamespaceOrTypeSymbol symbol);
    [ExtensionAttribute]
public static IEnumerable`1<IPropertySymbol> GetIndexers(INamespaceOrTypeSymbol symbol);
    [ExtensionAttribute]
public static IReadOnlyList`1<string> GetNameParts(INamespaceOrTypeSymbol symbol);
    public static int CompareNameParts(IReadOnlyList`1<string> names1, IReadOnlyList`1<string> names2, bool placeSystemNamespaceFirst);
    private static void GetNameParts(INamespaceOrTypeSymbol namespaceOrTypeSymbol, List`1<string> result);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamespaceOrTypeSymbolExtensions/<GetAllTypes>d__8")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetAllTypes(INamespaceOrTypeSymbol namespaceOrTypeSymbol, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.INamespaceSymbolExtensions : object {
    private static ConditionalWeakTable`2<INamespaceSymbol, List`1<string>> s_namespaceToNameMap;
    private static CreateValueCallback<INamespaceSymbol, List`1<string>> s_getNameParts;
    public static Comparison`1<INamespaceSymbol> CompareNamespaces;
    public static IEqualityComparer`1<INamespaceSymbol> EqualityComparer;
    private static INamespaceSymbolExtensions();
    private static List`1<string> GetNameParts(INamespaceSymbol namespaceSymbol);
    private static void GetNameParts(INamespaceSymbol namespaceSymbol, List`1<string> result);
    [ExtensionAttribute]
public static int CompareTo(INamespaceSymbol n1, INamespaceSymbol n2);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamespaceSymbolExtensions/<GetAllNamespacesAndTypes>d__8")]
[ExtensionAttribute]
public static IEnumerable`1<INamespaceOrTypeSymbol> GetAllNamespacesAndTypes(INamespaceSymbol namespaceSymbol, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetAllTypes(IEnumerable`1<INamespaceSymbol> namespaceSymbols, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamespaceSymbolExtensions/<FindNamespaces>d__10")]
[ExtensionAttribute]
public static IEnumerable`1<INamespaceSymbol> FindNamespaces(INamespaceSymbol namespaceSymbol, string namespaceName, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainsAccessibleTypesOrNamespaces(INamespaceSymbol namespaceSymbol, IAssemblySymbol assembly);
    [ExtensionAttribute]
public static INamespaceSymbol GetQualifiedNamespace(INamespaceSymbol globalNamespace, string namespaceName);
    [ExtensionAttribute]
private static bool ContainsAccessibleTypesOrNamespacesWorker(INamespaceSymbol namespaceSymbol, IAssemblySymbol assembly, Queue`1<INamespaceOrTypeSymbol> namespaceQueue);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IParameterSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsRefOrOut(IParameterSymbol symbol);
    [ExtensionAttribute]
public static IParameterSymbol RenameParameter(IParameterSymbol parameter, string parameterName);
    [ExtensionAttribute]
public static ImmutableArray`1<IParameterSymbol> RenameParameters(IList`1<IParameterSymbol> parameters, IList`1<string> parameterNames);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IPropertySymbolExtensions : object {
    [ExtensionAttribute]
public static IPropertySymbol RenameParameters(IPropertySymbol property, IList`1<string> parameterNames);
    [ExtensionAttribute]
public static IPropertySymbol RemoveAttributeFromParameters(IPropertySymbol property, INamedTypeSymbol[] attributesToRemove);
    [ExtensionAttribute]
public static bool IsWritableInConstructor(IPropertySymbol property);
    [ExtensionAttribute]
public static IFieldSymbol GetBackingFieldIfAny(IPropertySymbol property);
    private static bool ContainsBackingField(IPropertySymbol property);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ISolutionExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ISolutionExtensions/<GetGlobalNamespacesAsync>d__0")]
[ExtensionAttribute]
public static Task`1<ImmutableArray`1<INamespaceSymbol>> GetGlobalNamespacesAsync(Solution solution, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ISolutionExtensions/<GetChangedDocuments>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<DocumentId> GetChangedDocuments(Solution newSolution, Solution oldSolution);
    [ExtensionAttribute]
public static TextDocument GetTextDocument(Solution solution, DocumentId documentId);
    [ExtensionAttribute]
public static Solution WithTextDocumentText(Solution solution, DocumentId documentId, SourceText text, PreservationMode mode);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ISolutionExtensions/<FilterDocumentIdsByLanguage>d__4")]
[ExtensionAttribute]
public static IEnumerable`1<DocumentId> FilterDocumentIdsByLanguage(Solution solution, ImmutableArray`1<DocumentId> documentIds, string language);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions : object {
    private static int TypeLibTypeFlagsFHidden;
    private static int TypeLibFuncFlagsFHidden;
    private static int TypeLibVarFlagsFHidden;
    [ExtensionAttribute]
public static string ToNameDisplayString(ISymbol symbol);
    [ExtensionAttribute]
public static string ToSignatureDisplayString(ISymbol symbol);
    [ExtensionAttribute]
public static SymbolVisibility GetResultantVisibility(ISymbol symbol);
    [ExtensionAttribute]
public static ISymbol OverriddenMember(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> ExplicitInterfaceImplementations(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<T> ExplicitOrImplicitInterfaceImplementations(T symbol);
    [ExtensionAttribute]
public static bool IsOverridable(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsImplementableMember(ISymbol symbol);
    [ExtensionAttribute]
public static INamedTypeSymbol GetContainingTypeOrThis(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPointerType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsErrorType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsModuleType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsInterfaceType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsArrayType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsTupleType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAnonymousFunction(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsKind(ISymbol symbol, SymbolKind kind);
    [ExtensionAttribute]
public static bool MatchesKind(ISymbol symbol, SymbolKind kind);
    [ExtensionAttribute]
public static bool MatchesKind(ISymbol symbol, SymbolKind kind1, SymbolKind kind2);
    [ExtensionAttribute]
public static bool MatchesKind(ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3);
    [ExtensionAttribute]
public static bool MatchesKind(ISymbol symbol, SymbolKind[] kinds);
    [ExtensionAttribute]
public static bool IsReducedExtension(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsExtensionMethod(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsLocalFunction(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsModuleMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsConstructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsStaticConstructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsDestructor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsUserDefinedOperator(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsConversion(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsOrdinaryMethod(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsOrdinaryMethodOrLocalFunction(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsDelegateType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAnonymousType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsNormalAnonymousType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAnonymousDelegateType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAnonymousTypeProperty(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsTupleField(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsIndexer(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsWriteableFieldOrProperty(ISymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol GetMemberType(ISymbol symbol);
    [ExtensionAttribute]
public static int GetArity(ISymbol symbol);
    [ExtensionAttribute]
public static ISymbol GetOriginalUnreducedDefinition(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsFunctionValue(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsThisParameter(ISymbol symbol);
    [ExtensionAttribute]
public static ISymbol ConvertThisParameterToType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsParams(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<ITypeParameterSymbol> GetTypeParameters(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<ITypeParameterSymbol> GetAllTypeParameters(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<ITypeSymbol> GetTypeArguments(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<ITypeSymbol> GetAllTypeArguments(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAttribute(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsUnsafe(ISymbol member);
    [ExtensionAttribute]
public static ITypeSymbol ConvertToType(ISymbol symbol, Compilation compilation, bool extensionUsedAsInstance);
    [ExtensionAttribute]
public static bool IsStaticType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsNamespace(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsOrContainsAccessibleAttribute(ISymbol symbol, ISymbol withinType, IAssemblySymbol withinAssembly, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<IPropertySymbol> GetValidAnonymousTypeProperties(ISymbol symbol);
    [ExtensionAttribute]
public static Accessibility ComputeResultantAccessibility(ISymbol symbol, ITypeSymbol finalDestination);
    [ExtensionAttribute]
public static bool IsInaccessibleLocal(ISymbol symbol, int position);
    [ExtensionAttribute]
public static bool IsEditorBrowsable(ISymbol symbol, bool hideAdvancedMembers, Compilation compilation, IMethodSymbol editorBrowsableAttributeConstructor, List`1<IMethodSymbol> typeLibTypeAttributeConstructors, List`1<IMethodSymbol> typeLibFuncAttributeConstructors, List`1<IMethodSymbol> typeLibVarAttributeConstructors, INamedTypeSymbol hideModuleNameAttribute);
    private static bool IsBrowsingProhibited(ISymbol symbol, bool hideAdvancedMembers, Compilation compilation, IMethodSymbol editorBrowsableAttributeConstructor, List`1<IMethodSymbol> typeLibTypeAttributeConstructors, List`1<IMethodSymbol> typeLibFuncAttributeConstructors, List`1<IMethodSymbol> typeLibVarAttributeConstructors, INamedTypeSymbol hideModuleNameAttribute);
    private static bool IsBrowsingProhibitedByHideModuleNameAttribute(ISymbol symbol, Compilation compilation, INamedTypeSymbol hideModuleNameAttribute, ImmutableArray`1<AttributeData> attributes);
    private static bool IsBrowsingProhibitedByEditorBrowsableAttribute(ISymbol symbol, ImmutableArray`1<AttributeData> attributes, bool hideAdvancedMembers, Compilation compilation, IMethodSymbol constructor);
    private static bool IsBrowsingProhibitedByTypeLibTypeAttribute(ISymbol symbol, ImmutableArray`1<AttributeData> attributes, Compilation compilation, List`1<IMethodSymbol> constructors);
    private static bool IsBrowsingProhibitedByTypeLibFuncAttribute(ISymbol symbol, ImmutableArray`1<AttributeData> attributes, Compilation compilation, List`1<IMethodSymbol> constructors);
    private static bool IsBrowsingProhibitedByTypeLibVarAttribute(ISymbol symbol, ImmutableArray`1<AttributeData> attributes, Compilation compilation, List`1<IMethodSymbol> constructors);
    private static bool IsBrowsingProhibitedByTypeLibAttributeWorker(ISymbol symbol, ImmutableArray`1<AttributeData> attributes, List`1<IMethodSymbol> attributeConstructors, int hiddenFlag);
    [ExtensionAttribute]
public static bool IsAccessor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsPropertyAccessor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsEventAccessor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsFromSource(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsNonImplicitAndFromSource(ISymbol symbol);
    [ExtensionAttribute]
public static DeclarationModifiers GetSymbolModifiers(ISymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol GetSymbolType(ISymbol symbol);
    [ExtensionAttribute]
public static DocumentationComment GetDocumentationComment(ISymbol symbol, CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsAwaitableNonDynamic(ISymbol symbol, SemanticModel semanticModel, int position);
    private static bool VerifyGetAwaiter(IMethodSymbol getAwaiter);
    [ExtensionAttribute]
public static ImmutableArray`1<T> FilterToVisibleAndBrowsableSymbols(ImmutableArray`1<T> symbols, bool hideAdvancedMembers, Compilation compilation);
    [ExtensionAttribute]
private static ImmutableArray`1<T> RemoveOverriddenSymbolsWithinSet(ImmutableArray`1<T> symbols);
    [ExtensionAttribute]
public static ImmutableArray`1<T> FilterToVisibleAndBrowsableSymbolsAndNotUnsafeSymbols(ImmutableArray`1<T> symbols, bool hideAdvancedMembers, Compilation compilation);
    [ExtensionAttribute]
public static bool IsImplicitValueParameter(ISymbol symbolOpt);
    [ExtensionAttribute]
public static bool IsAccessibleWithin(ISymbol symbol, ISymbol within, ITypeSymbol throughTypeOpt);
    [ExtensionAttribute]
public static bool IsAccessibleWithin(ISymbol symbol, IAssemblySymbol within, ITypeSymbol throughTypeOpt);
    [ExtensionAttribute]
public static bool IsAccessibleWithin(ISymbol symbol, INamedTypeSymbol within, ITypeSymbol throughTypeOpt);
    private static bool IsSymbolAccessible(ISymbol symbol, INamedTypeSymbol within, ITypeSymbol throughTypeOpt, Boolean& failedThroughTypeCheck);
    private static bool IsSymbolAccessibleCore(ISymbol symbol, ISymbol within, ITypeSymbol throughTypeOpt, Boolean& failedThroughTypeCheck);
    private static bool IsNamedTypeAccessible(INamedTypeSymbol type, ISymbol within);
    private static bool IsNonNestedTypeAccessible(IAssemblySymbol assembly, Accessibility declaredAccessibility, ISymbol within);
    private static bool IsMemberAccessible(INamedTypeSymbol containingType, Accessibility declaredAccessibility, ISymbol within, ITypeSymbol throughTypeOpt, Boolean& failedThroughTypeCheck);
    private static bool IsProtectedSymbolAccessible(INamedTypeSymbol withinType, IAssemblySymbol withinAssembly, ITypeSymbol throughTypeOpt, INamedTypeSymbol originalContainingType, Boolean& failedThroughTypeCheck);
    private static bool IsPrivateSymbolAccessible(ISymbol within, INamedTypeSymbol originalContainingType);
    private static bool IsNestedWithinOriginalContainingType(INamedTypeSymbol withinType, INamedTypeSymbol originalContainingType);
    [CompilerGeneratedAttribute]
internal static string <ConvertToType>g__WithArity|54_1(string typeName, int arity);
}
internal interface Microsoft.CodeAnalysis.Shared.Extensions.ITypeGenerator {
    public abstract virtual ITypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    public abstract virtual ITypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType);
    public abstract virtual ITypeSymbol Construct(INamedTypeSymbol namedType, ITypeSymbol[] typeArguments);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ITypeInferenceServiceExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<ITypeSymbol> InferTypes(ITypeInferenceService service, SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ITypeSymbol> InferTypes(ITypeInferenceService service, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(ITypeInferenceService service, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(ITypeInferenceService service, SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol InferDelegateType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol InferType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, SyntaxNode expression, bool objectAsDefault, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol InferType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, SyntaxNode expression, bool objectAsDefault, string nameOpt, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol InferType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, int position, bool objectAsDefault, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol InferType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, int position, bool objectAsDefault, string nameOpt, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ITypeParameterSymbolExtensions : object {
    [ExtensionAttribute]
public static INamedTypeSymbol GetNamedTypeSymbolConstraint(ITypeParameterSymbol typeParameter);
    private static INamedTypeSymbol GetNamedTypeSymbol(ITypeSymbol type);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions : object {
    private static string DefaultParameterName;
    private static string DefaultBuiltInParameterName;
    [ExtensionAttribute]
public static bool CanAddNullCheck(ITypeSymbol type);
    [ExtensionAttribute]
public static IList`1<INamedTypeSymbol> GetAllInterfacesIncludingThis(ITypeSymbol type);
    [ExtensionAttribute]
public static bool IsAbstractClass(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsSystemVoid(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsNullable(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsErrorType(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsModuleType(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsInterfaceType(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsDelegateType(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsStructType(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsAnonymousType(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol RemoveNullableIfPresent(ITypeSymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<FindImplementationsForInterfaceMember>d__17")]
[ExtensionAttribute]
public static IEnumerable`1<SymbolAndProjectId> FindImplementationsForInterfaceMember(SymbolAndProjectId`1<ITypeSymbol> typeSymbolAndProjectId, ISymbol interfaceMember, Workspace workspace, CancellationToken cancellationToken);
    private static ISymbol FindImplementations(Workspace workspace, ISymbol constructedInterfaceMember, ITypeSymbol currentType);
    [ExtensionAttribute]
private static HashSet`1<INamedTypeSymbol> GetOriginalInterfacesAndTheirBaseInterfaces(ITypeSymbol type, HashSet`1<INamedTypeSymbol> symbols);
    private static ISymbol FindImplementations(ITypeSymbol typeSymbol, TSymbol interfaceSymbol, Workspace workspace, Func`2<TSymbol, ImmutableArray`1<TSymbol>> getExplicitInterfaceImplementations);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<GetBaseTypesAndThis>d__21")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetBaseTypesAndThis(ITypeSymbol type);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<GetBaseTypes>d__22")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypes(ITypeSymbol type);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<GetContainingTypesAndThis>d__23")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetContainingTypesAndThis(ITypeSymbol type);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<GetContainingTypes>d__24")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetContainingTypes(ITypeSymbol type);
    [ExtensionAttribute]
public static bool InheritsFromOrEquals(ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces);
    [ExtensionAttribute]
public static bool InheritsFromOrEquals(ITypeSymbol type, ITypeSymbol baseType);
    [ExtensionAttribute]
public static bool InheritsFromOrEqualsIgnoringConstruction(ITypeSymbol type, ITypeSymbol baseType);
    [ExtensionAttribute]
public static bool InheritsFromIgnoringConstruction(ITypeSymbol type, ITypeSymbol baseType);
    [ExtensionAttribute]
public static bool ImplementsIgnoringConstruction(ITypeSymbol type, ITypeSymbol interfaceType);
    [ExtensionAttribute]
public static bool Implements(ITypeSymbol type, ITypeSymbol interfaceType);
    [ExtensionAttribute]
public static bool IsAttribute(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsFormattableString(ITypeSymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol RemoveUnavailableTypeParameters(ITypeSymbol type, Compilation compilation, IEnumerable`1<ITypeParameterSymbol> availableTypeParameters);
    [ExtensionAttribute]
private static ITypeSymbol RemoveUnavailableTypeParameters(ITypeSymbol type, Compilation compilation, ISet`1<string> availableTypeParameterNames);
    [ExtensionAttribute]
public static ITypeSymbol RemoveAnonymousTypes(ITypeSymbol type, Compilation compilation);
    [ExtensionAttribute]
public static ITypeSymbol ReplaceTypeParametersBasedOnTypeConstraints(ITypeSymbol type, Compilation compilation, IEnumerable`1<ITypeParameterSymbol> availableTypeParameters, Solution solution, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol RemoveUnnamedErrorTypes(ITypeSymbol type, Compilation compilation);
    [ExtensionAttribute]
public static IList`1<ITypeParameterSymbol> GetReferencedMethodTypeParameters(ITypeSymbol type, IList`1<ITypeParameterSymbol> result);
    [ExtensionAttribute]
public static IList`1<ITypeParameterSymbol> GetReferencedTypeParameters(ITypeSymbol type, IList`1<ITypeParameterSymbol> result);
    [ExtensionAttribute]
public static ITypeSymbol SubstituteTypes(ITypeSymbol type, IDictionary`2<TType1, TType2> mapping, Compilation compilation);
    [ExtensionAttribute]
public static ITypeSymbol SubstituteTypes(ITypeSymbol type, IDictionary`2<TType1, TType2> mapping, ITypeGenerator typeGenerator);
    [ExtensionAttribute]
public static bool IsUnexpressibleTypeParameterConstraint(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool IsNumericType(ITypeSymbol type);
    [ExtensionAttribute]
public static Accessibility DetermineMinimalAccessibility(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static bool ContainsAnonymousType(ITypeSymbol symbol);
    private static bool ContainsAnonymousType(INamedTypeSymbol type);
    [ExtensionAttribute]
public static string CreateParameterName(ITypeSymbol type, bool capitalize);
    private static string GetParameterName(ITypeSymbol type);
    [ExtensionAttribute]
public static bool IsSpecialType(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool CanSupportCollectionInitializer(ITypeSymbol typeSymbol, ISymbol within);
    [ExtensionAttribute]
public static INamedTypeSymbol GetDelegateType(ITypeSymbol typeSymbol, Compilation compilation);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAccessibleMembersInBaseTypes(ITypeSymbol containingType, ISymbol within);
    [ExtensionAttribute]
public static ImmutableArray`1<T> GetAccessibleMembersInThisAndBaseTypes(ITypeSymbol containingType, ISymbol within);
    [ExtensionAttribute]
public static Nullable`1<bool> AreMoreSpecificThan(IList`1<ITypeSymbol> t1, IList`1<ITypeSymbol> t2);
    [ExtensionAttribute]
private static IEnumerable`1<T> SelectAccessibleMembers(IEnumerable`1<ITypeSymbol> types, ISymbol within);
    [ExtensionAttribute]
private static IEnumerable`1<T> SelectAccessibleMembers(IEnumerable`1<ITypeSymbol> types, string memberName, ISymbol within);
    [ExtensionAttribute]
private static Nullable`1<bool> IsMoreSpecificThan(ITypeSymbol t1, ITypeSymbol t2);
    [ExtensionAttribute]
public static bool IsOrDerivesFromExceptionType(ITypeSymbol type, Compilation compilation);
    [ExtensionAttribute]
public static bool IsEnumType(ITypeSymbol type);
}
internal class Microsoft.CodeAnalysis.Shared.Extensions.LineSpan : ValueType {
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <End>k__BackingField;
    public int Start { get; private set; }
    public int End { get; private set; }
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
private void set_Start(int value);
    [CompilerGeneratedAttribute]
public int get_End();
    [CompilerGeneratedAttribute]
private void set_End(int value);
    public static LineSpan FromBounds(int start, int end);
    public sealed virtual bool Equals(LineSpan other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.LinkedListExtensions : object {
    [ExtensionAttribute]
public static void AddRangeAtHead(LinkedList`1<T> list, IEnumerable`1<T> values);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.LocationExtensions : object {
    [ExtensionAttribute]
public static SyntaxToken FindToken(Location location, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxNode FindNode(Location location, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxNode FindNode(Location location, bool getInnermostNodeForTie, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxNode FindNode(Location location, bool findInsideTrivia, bool getInnermostNodeForTie, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsVisibleSourceLocation(Location loc);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.MethodKindExtensions : object {
    [ExtensionAttribute]
public static bool IsPropertyAccessor(MethodKind kind);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ObjectExtensions : object {
    [ExtensionAttribute]
public static string GetTypeDisplayName(object obj);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TDerivedType31, TResult> matchFunc31, Func`2<TDerivedType32, TResult> matchFunc32, Func`2<TDerivedType33, TResult> matchFunc33, Func`2<TDerivedType34, TResult> matchFunc34, Func`2<TDerivedType35, TResult> matchFunc35, Func`2<TDerivedType36, TResult> matchFunc36, Func`2<TDerivedType37, TResult> matchFunc37, Func`2<TDerivedType38, TResult> matchFunc38, Func`2<TBaseType, TResult> defaultFunc);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.PredefinedTypeExtensions : object {
    [ExtensionAttribute]
public static SpecialType ToSpecialType(PredefinedType predefinedType);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ProjectExtensions : object {
    [ExtensionAttribute]
public static bool IsFromPrimaryBranch(Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ProjectExtensions/<IsForkedProjectWithSemanticChangesAsync>d__1")]
[ExtensionAttribute]
public static Task`1<bool> IsForkedProjectWithSemanticChangesAsync(Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ProjectExtensions/<GetVersionAsync>d__2")]
[ExtensionAttribute]
public static Task`1<VersionStamp> GetVersionAsync(Project project, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SemanticEquivalence : object {
    public static bool AreEquivalent(SemanticModel semanticModel, SyntaxNode node1, SyntaxNode node2);
    public static bool AreEquivalent(SemanticModel semanticModel1, SemanticModel semanticModel2, SyntaxNode node1, SyntaxNode node2, Func`2<SyntaxNode, bool> predicate);
    private static bool AreSemanticallyEquivalentWorker(SemanticModel semanticModel1, SemanticModel semanticModel2, SyntaxNode node1, SyntaxNode node2, Func`2<SyntaxNode, bool> predicate);
    private static bool AreEquals(SemanticModel semanticModel1, SemanticModel semanticModel2, SymbolInfo info1, SymbolInfo info2);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SemanticModelExtensions : object {
    [ExtensionAttribute]
public static SemanticMap GetSemanticMap(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TSymbol GetEnclosingSymbol(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetEnclosingNamedTypeOrAssembly(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetEnclosingNamedType(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamespaceSymbol GetEnclosingNamespace(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol GetType(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TokenSemanticInfo GetSemanticInfo(SemanticModel semanticModel, SyntaxToken token, Workspace workspace, CancellationToken cancellationToken);
    private static ISymbol MapSymbol(ISymbol symbol, ITypeSymbol type);
    private static TokenSemanticInfo GetSemanticInfo(SemanticModel semanticModel, ISemanticFactsService semanticFacts, ISyntaxFactsService syntaxFacts, SyntaxToken token, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SemanticModel GetOriginalSemanticModel(SemanticModel semanticModel);
    [ExtensionAttribute]
public static HashSet`1<ISymbol> GetAllDeclaredSymbols(SemanticModel semanticModel, SyntaxNode container, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<ISymbol> GetExistingSymbols(SemanticModel semanticModel, SyntaxNode container, CancellationToken cancellationToken);
    private static void GetAllDeclaredSymbols(SemanticModel semanticModel, SyntaxNode node, HashSet`1<ISymbol> symbols, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SimpleIntervalTreeExtensions : object {
    [ExtensionAttribute]
public static bool HasIntervalThatIntersectsWith(SimpleIntervalTree`1<TextSpan> tree, TextSpan span);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SolutionExtensions : object {
    [ExtensionAttribute]
public static void WriteTo(IObjectWritable object, ObjectWriter writer);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions : object {
    internal static int SourceTextLengthThreshold;
    [ExtensionAttribute]
public static string GetLeadingWhitespaceOfLineAtPosition(SourceText text, int position);
    [ExtensionAttribute]
public static void GetLineAndOffset(SourceText text, int position, Int32& lineNumber, Int32& offset);
    [ExtensionAttribute]
public static void GetLinesAndOffsets(SourceText text, TextSpan textSpan, Int32& startLineNumber, Int32& startOffset, Int32& endLineNumber, Int32& endOffset);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SourceText text, TextSpan span, Func`3<int, CancellationToken, bool> isPositionHidden, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryOverlapsHiddenPosition(SourceText text, TextSpan span, Func`3<int, CancellationToken, bool> isPositionHidden, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TextChangeRange GetEncompassingTextChangeRange(SourceText newText, SourceText oldText);
    [ExtensionAttribute]
public static int IndexOf(SourceText text, string value, int startIndex, bool caseSensitive);
    [ExtensionAttribute]
public static int LastIndexOf(SourceText text, string value, int startIndex, bool caseSensitive);
    private static bool Match(char normalizedLeft, char right, bool caseSensitive);
    [ExtensionAttribute]
public static bool AreOnSameLine(SourceText text, SyntaxToken token1, SyntaxToken token2);
    [ExtensionAttribute]
public static void WriteTo(SourceText sourceText, ObjectWriter writer, CancellationToken cancellationToken);
    private static void WriteChunksTo(SourceText sourceText, ObjectWriter writer, int length, CancellationToken cancellationToken);
    public static SourceText ReadFrom(ITextFactoryService textService, ObjectReader reader, Encoding encoding, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SpecialTypeExtensions : object {
    [ExtensionAttribute]
public static PredefinedType ToPredefinedType(SpecialType specialType);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.StackExtensions : object {
    [ExtensionAttribute]
public static void Push(Stack`1<T> stack, IEnumerable`1<T> values);
    [ExtensionAttribute]
internal static void PushReverse(Stack`1<T> stack, IList`1<U> range);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<int> GetFirstNonWhitespaceOffset(string line);
    [ExtensionAttribute]
public static string GetLeadingWhitespace(string lineText);
    [ExtensionAttribute]
public static int GetTextColumn(string text, int tabSize, int initialColumn);
    [ExtensionAttribute]
public static int ConvertTabToSpace(string textSnippet, int tabSize, int initialColumn, int endPosition);
    [ExtensionAttribute]
public static int IndexOf(string text, Func`2<char, bool> predicate);
    [ExtensionAttribute]
public static string GetFirstLineText(string text);
    [ExtensionAttribute]
public static string GetLastLineText(string text);
    [ExtensionAttribute]
public static bool ContainsLineBreak(string text);
    [ExtensionAttribute]
public static int GetNumberOfLineBreaks(string text);
    [ExtensionAttribute]
public static bool ContainsTab(string text);
    [ExtensionAttribute]
public static ImmutableArray`1<SymbolDisplayPart> ToSymbolDisplayParts(string text);
    [ExtensionAttribute]
public static int GetColumnOfFirstNonWhitespaceCharacterOrEndOfLine(string line, int tabSize);
    [ExtensionAttribute]
public static int GetColumnFromLineOffset(string line, int endPosition, int tabSize);
    [ExtensionAttribute]
public static int GetLineOffsetFromColumn(string line, int column, int tabSize);
    [ExtensionAttribute]
public static void AppendToAliasNameSet(string alias, Builder<string> builder);
}
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SymbolDisplayFormats : object {
    public static SymbolDisplayFormat NameFormat;
    public static SymbolDisplayFormat SignatureFormat;
    private static SymbolDisplayFormats();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SymbolDisplayPartExtensions : object {
    [ExtensionAttribute]
public static string GetFullText(IEnumerable`1<SymbolDisplayPart> parts);
    [ExtensionAttribute]
public static void AddLineBreak(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddMethodName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddPunctuation(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddSpace(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddText(IList`1<SymbolDisplayPart> parts, string text);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SymbolInfoExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetAllSymbols(SymbolInfo info);
    [ExtensionAttribute]
private static ImmutableArray`1<ISymbol> GetAllSymbolsWorker(SymbolInfo info);
    [ExtensionAttribute]
public static ISymbol GetAnySymbol(SymbolInfo info);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetBestOrAllSymbols(SymbolInfo info);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions : object {
    [ExtensionAttribute]
public static Task ApplyExpressionLevelSemanticEditsAsync(SyntaxEditor editor, Document document, ImmutableArray`1<TNode> originalNodes, Func`3<SemanticModel, TNode, bool> canReplace, Func`4<SemanticModel, SyntaxNode, TNode, SyntaxNode> updateRoot, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task ApplyMethodBodySemanticEditsAsync(SyntaxEditor editor, Document document, ImmutableArray`1<TNode> originalNodes, Func`3<SemanticModel, TNode, bool> canReplace, Func`4<SemanticModel, SyntaxNode, TNode, SyntaxNode> updateRoot, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions/<ApplySemanticEditsAsync>d__2`1")]
[ExtensionAttribute]
private static Task ApplySemanticEditsAsync(SyntaxEditor editor, Document document, ImmutableArray`1<TNode> originalNodes, Func`3<ISyntaxFactsService, SyntaxNode, SyntaxNode> getSemanticBoundary, Func`3<SemanticModel, TNode, bool> canReplace, Func`4<SemanticModel, SyntaxNode, TNode, SyntaxNode> updateRoot, CancellationToken cancellationToken);
    private static SyntaxNode GetExpressionSemanticBoundary(ISyntaxFactsService syntaxFacts, SyntaxNode node);
    private static SyntaxNode GetMethodBodySemanticBoundary(ISyntaxFactsService syntaxFacts, SyntaxNode node);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions : object {
    private static Func`3<SyntaxTriviaList, int, SyntaxToken> s_findSkippedTokenForward;
    private static Func`3<SyntaxTriviaList, int, SyntaxToken> s_findSkippedTokenBackward;
    private static SyntaxNodeExtensions();
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxNodeOrToken> DepthFirstTraversal(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions/<GetAncestors>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetAncestors(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions/<GetAncestors>d__2`1")]
[ExtensionAttribute]
public static IEnumerable`1<TNode> GetAncestors(SyntaxNode node);
    [ExtensionAttribute]
public static TNode GetAncestor(SyntaxNode node);
    [ExtensionAttribute]
public static TNode GetAncestorOrThis(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions/<GetAncestorsOrThis>d__5`1")]
[ExtensionAttribute]
public static IEnumerable`1<TNode> GetAncestorsOrThis(SyntaxNode node);
    [ExtensionAttribute]
public static bool HasAncestor(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions/<Traverse>d__7`1")]
[ExtensionAttribute]
public static IEnumerable`1<TSyntaxNode> Traverse(SyntaxNode node, TextSpan searchSpan, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
public static bool CheckParent(SyntaxNode node, Func`2<T, bool> valueChecker);
    [ExtensionAttribute]
public static bool IsChildNode(SyntaxNode node, Func`2<TParent, SyntaxNode> childGetter);
    [ExtensionAttribute]
public static bool IsFoundUnder(SyntaxNode node, Func`2<TParent, SyntaxNode> childGetter);
    [ExtensionAttribute]
public static SyntaxNode GetCommonRoot(SyntaxNode node1, SyntaxNode node2);
    [ExtensionAttribute]
public static int Width(SyntaxNode node);
    [ExtensionAttribute]
public static int FullWidth(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode FindInnermostCommonNode(IEnumerable`1<SyntaxNode> nodes, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
public static TSyntaxNode FindInnermostCommonNode(IEnumerable`1<SyntaxNode> nodes);
    [ExtensionAttribute]
public static SyntaxNode AddAnnotations(SyntaxNode root, IEnumerable`1<Tuple`2<SyntaxToken, SyntaxAnnotation>> pairs);
    [ExtensionAttribute]
public static SyntaxNode AddAnnotations(SyntaxNode root, IEnumerable`1<Tuple`2<SyntaxNode, SyntaxAnnotation>> pairs);
    [ExtensionAttribute]
public static TextSpan GetContainedSpan(IEnumerable`1<SyntaxNode> nodes);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions/<GetContiguousSpans>d__19")]
[ExtensionAttribute]
public static IEnumerable`1<TextSpan> GetContiguousSpans(IEnumerable`1<SyntaxNode> nodes, Func`2<SyntaxNode, SyntaxToken> getLastToken);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SyntaxNode node, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SyntaxNode declaration, SyntaxNode startNode, SyntaxNode endNode, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAnnotatedNodes(SyntaxNode node, SyntaxAnnotation syntaxAnnotation);
    [ExtensionAttribute]
public static Task`1<TRootNode> ReplaceNodesAsync(TRootNode root, IEnumerable`1<SyntaxNode> nodes, Func`4<SyntaxNode, SyntaxNode, CancellationToken, Task`1<SyntaxNode>> computeReplacementAsync, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TRootNode> ReplaceTokensAsync(TRootNode root, IEnumerable`1<SyntaxToken> tokens, Func`4<SyntaxToken, SyntaxToken, CancellationToken, Task`1<SyntaxToken>> computeReplacementAsync, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TRoot> ReplaceTriviaAsync(TRoot root, IEnumerable`1<SyntaxTrivia> trivia, Func`4<SyntaxTrivia, SyntaxTrivia, CancellationToken, Task`1<SyntaxTrivia>> computeReplacementAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions/<ReplaceSyntaxAsync>d__27`1")]
[ExtensionAttribute]
public static Task`1<TRoot> ReplaceSyntaxAsync(TRoot root, IEnumerable`1<SyntaxNode> nodes, Func`4<SyntaxNode, SyntaxNode, CancellationToken, Task`1<SyntaxNode>> computeReplacementNodeAsync, IEnumerable`1<SyntaxToken> tokens, Func`4<SyntaxToken, SyntaxToken, CancellationToken, Task`1<SyntaxToken>> computeReplacementTokenAsync, IEnumerable`1<SyntaxTrivia> trivia, Func`4<SyntaxTrivia, SyntaxTrivia, CancellationToken, Task`1<SyntaxTrivia>> computeReplacementTriviaAsync, CancellationToken cancellationToken);
    private static SyntaxToken FindSkippedTokenForward(SyntaxTriviaList triviaList, int position);
    private static SyntaxToken FindSkippedTokenBackward(SyntaxTriviaList triviaList, int position);
    private static SyntaxToken GetInitialToken(SyntaxNode root, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOnRightOfPosition(SyntaxNode root, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOnLeftOfPosition(SyntaxNode root, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static T WithPrependedLeadingTrivia(T node, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
public static T WithPrependedLeadingTrivia(T node, SyntaxTriviaList trivia);
    [ExtensionAttribute]
public static T WithPrependedLeadingTrivia(T node, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static T WithAppendedTrailingTrivia(T node, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
public static T WithAppendedTrailingTrivia(T node, SyntaxTriviaList trivia);
    [ExtensionAttribute]
public static T WithAppendedTrailingTrivia(T node, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static T With(T node, IEnumerable`1<SyntaxTrivia> leadingTrivia, IEnumerable`1<SyntaxTrivia> trailingTrivia);
    [ExtensionAttribute]
private static SyntaxNode GetParent(SyntaxNode node);
    [ExtensionAttribute]
public static TNode FirstAncestorOrSelfUntil(SyntaxNode node, Func`2<SyntaxNode, bool> predicate);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeOrTokenExtensions : object {
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeOrTokenExtensions/<DepthFirstTraversal>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxNodeOrToken> DepthFirstTraversal(SyntaxNodeOrToken node);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTokenExtensions : object {
    [ExtensionAttribute]
public static SyntaxNode GetAncestor(SyntaxToken token, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
public static T GetAncestor(SyntaxToken token, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAncestors(SyntaxToken token);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetAncestors(SyntaxToken token, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
public static SyntaxNode GetCommonRoot(SyntaxToken token1, SyntaxToken token2);
    [ExtensionAttribute]
public static bool CheckParent(SyntaxToken token, Func`2<T, bool> valueChecker);
    [ExtensionAttribute]
public static int Width(SyntaxToken token);
    [ExtensionAttribute]
public static int FullWidth(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken FindTokenFromEnd(SyntaxNode root, int position, bool includeZeroWidth, bool findInsideTrivia);
    [ExtensionAttribute]
public static SyntaxToken GetNextTokenOrEndOfFile(SyntaxToken token, bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static SyntaxToken WithoutTrivia(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken With(SyntaxToken token, SyntaxTriviaList leading, SyntaxTriviaList trailing);
    [ExtensionAttribute]
public static SyntaxToken WithPrependedLeadingTrivia(SyntaxToken token, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
public static SyntaxToken WithPrependedLeadingTrivia(SyntaxToken token, SyntaxTriviaList trivia);
    [ExtensionAttribute]
public static SyntaxToken WithPrependedLeadingTrivia(SyntaxToken token, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static SyntaxToken WithAppendedTrailingTrivia(SyntaxToken token, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
public static SyntaxToken WithAppendedTrailingTrivia(SyntaxToken token, IEnumerable`1<SyntaxTrivia> trivia);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTokenListExtensions : object {
    [ExtensionAttribute]
public static SyntaxTokenList ToSyntaxTokenList(IEnumerable`1<SyntaxToken> tokens);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions : object {
    [ExtensionAttribute]
public static bool IsScript(SyntaxTree syntaxTree);
    [ExtensionAttribute]
public static Task`1<SyntaxToken> GetTouchingWordAsync(SyntaxTree syntaxTree, int position, ISyntaxFactsService syntaxFacts, CancellationToken cancellationToken, bool findInsideTrivia);
    [ExtensionAttribute]
public static Task`1<SyntaxToken> GetTouchingTokenAsync(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, bool findInsideTrivia);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions/<GetTouchingTokenAsync>d__3")]
[ExtensionAttribute]
public static Task`1<SyntaxToken> GetTouchingTokenAsync(SyntaxTree syntaxTree, int position, Predicate`1<SyntaxToken> predicate, CancellationToken cancellationToken, bool findInsideTrivia);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SyntaxTree tree, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyHidden(SyntaxTree tree, TextSpan span, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions/<IsBeforeFirstTokenAsync>d__6")]
[ExtensionAttribute]
public static Task`1<bool> IsBeforeFirstTokenAsync(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOrEndToken(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static SyntaxTrivia FindTriviaAndAdjustForEndOfFile(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, bool findInsideTrivia);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOnRightOfPosition(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOnLeftOfPosition(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTriviaExtensions : object {
    [ExtensionAttribute]
public static int Width(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static int FullWidth(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsElastic(SyntaxTrivia trivia);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTriviaListExtensions : object {
    [ExtensionAttribute]
public static SyntaxTrivia LastOrDefault(SyntaxTriviaList triviaList);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.TextDocumentExtensions : object {
    [ExtensionAttribute]
public static TextDocument WithText(TextDocument textDocument, SourceText text);
    [ExtensionAttribute]
public static TextDocument WithAdditionalDocumentText(TextDocument textDocument, SourceText text);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<int> GetLastNonWhitespacePosition(TextLine line);
    [ExtensionAttribute]
public static Nullable`1<int> GetFirstNonWhitespacePosition(TextLine line);
    [ExtensionAttribute]
public static Nullable`1<int> GetFirstNonWhitespaceOffset(TextLine line);
    [ExtensionAttribute]
public static string GetLeadingWhitespace(TextLine line);
    [ExtensionAttribute]
public static bool IsEmptyOrWhitespace(TextLine line);
    [ExtensionAttribute]
public static int GetColumnOfFirstNonWhitespaceCharacterOrEndOfLine(TextLine line, int tabSize);
    [ExtensionAttribute]
public static int GetColumnFromLineOffset(TextLine line, int lineOffset, int tabSize);
    [ExtensionAttribute]
public static int GetLineOffsetFromColumn(TextLine line, int column, int tabSize);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.TextSpanExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<TextSpan> ToNormalizedSpans(IEnumerable`1<TextSpan> spans);
    [ExtensionAttribute]
public static ImmutableArray`1<TextSpan> ToNormalizedSpans(ImmutableArray`1<TextSpan> spans);
    [ExtensionAttribute]
public static TextSpan Collapse(IEnumerable`1<TextSpan> spans);
}
internal class Microsoft.CodeAnalysis.Shared.Extensions.TokenSemanticInfo : ValueType {
    public static TokenSemanticInfo Empty;
    public ISymbol DeclaredSymbol;
    public IAliasSymbol AliasSymbol;
    public ImmutableArray`1<ISymbol> ReferencedSymbols;
    public ITypeSymbol Type;
    public TextSpan Span;
    public TokenSemanticInfo(ISymbol declaredSymbol, IAliasSymbol aliasSymbol, ImmutableArray`1<ISymbol> referencedSymbols, ITypeSymbol type, TextSpan span);
    private static TokenSemanticInfo();
    public ImmutableArray`1<ISymbol> GetSymbols(bool includeType);
    public ISymbol GetAnySymbol(bool includeType);
}
internal class Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection : ReadOnlyCollection`1<TextSpan> {
    public NormalizedTextSpanCollection(TextSpan span);
    public NormalizedTextSpanCollection(IEnumerable`1<TextSpan> spans);
    private NormalizedTextSpanCollection(OrderedSpanList normalizedSpans);
    public static NormalizedTextSpanCollection Union(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public static NormalizedTextSpanCollection Overlap(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public static NormalizedTextSpanCollection Intersection(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public static NormalizedTextSpanCollection Difference(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public static bool op_Equality(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public static bool op_Inequality(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public bool OverlapsWith(NormalizedTextSpanCollection set);
    public bool OverlapsWith(TextSpan span);
    public bool IntersectsWith(NormalizedTextSpanCollection set);
    public bool IntersectsWith(TextSpan span);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    private static IList`1<TextSpan> ListFromSpan(TextSpan span);
    private static void UpdateSpanUnion(TextSpan span, IList`1<TextSpan> spans, Int32& start, Int32& end);
    private static IList`1<TextSpan> NormalizeSpans(IEnumerable`1<TextSpan> spans);
}
internal static class Microsoft.CodeAnalysis.Shared.Options.RuntimeOptions : object {
    public static Option`1<bool> FullSolutionAnalysis;
    public static Option`1<bool> FullSolutionAnalysisInfoBarShown;
    private static RuntimeOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Shared.Options.RuntimeOptionsProvider : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
internal class Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListener : object {
    private object _gate;
    private string _featureName;
    private HashSet`1<TaskCompletionSource`1<bool>> _pendingTasks;
    private List`1<DiagnosticAsyncToken> _diagnosticTokenList;
    private int _counter;
    private bool _trackActiveTokens;
    public bool TrackActiveTokens { get; public set; }
    public bool HasPendingWork { get; }
    public ImmutableArray`1<DiagnosticAsyncToken> ActiveDiagnosticTokens { get; }
    public AsynchronousOperationListener(string featureName, bool enableDiagnosticTokens);
    public sealed virtual IAsyncToken BeginAsyncOperation(string name, object tag, string filePath, int lineNumber);
    private void Increment();
    private void Decrement(AsyncToken token);
    public sealed virtual Task CreateWaitTask();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListener/<WaitUntilConditionIsMetAsync>d__13")]
public Task WaitUntilConditionIsMetAsync(Func`2<IEnumerable`1<DiagnosticAsyncToken>, bool> condition);
    public sealed virtual bool get_TrackActiveTokens();
    public sealed virtual void set_TrackActiveTokens(bool value);
    public sealed virtual bool get_HasPendingWork();
    public sealed virtual ImmutableArray`1<DiagnosticAsyncToken> get_ActiveDiagnosticTokens();
}
[SharedAttribute]
[ExportAttribute("Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListenerProvider")]
[ExportAttribute("Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider")]
internal class Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider : object {
    public static IAsynchronousOperationListenerProvider NullProvider;
    public static IAsynchronousOperationListener NullListener;
    public static Nullable`1<bool> s_enabled;
    private ConcurrentDictionary`2<string, AsynchronousOperationListener> _singletonListeners;
    private Func`2<string, AsynchronousOperationListener> _createCallback;
    private Nullable`1<bool> _enableDiagnosticTokens;
    private static Nullable`1<bool> s_enableDiagnosticTokens;
    private static bool IsEnabled { get; }
    private bool DiagnosticTokensEnabled { get; }
    private static AsynchronousOperationListenerProvider();
    public static void Enable(bool enable);
    public static void Enable(bool enable, Nullable`1<bool> diagnostics);
    public sealed virtual IAsynchronousOperationListener GetListener(string featureName);
    public void EnableDiagnosticTokens(bool enable);
    public IAsynchronousOperationWaiter GetWaiter(string featureName);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider/<WaitAllAsync>d__13")]
public Task WaitAllAsync(String[] featureNames, Action eventProcessingAction);
    public bool HasPendingWaiter(String[] featureNames);
    public List`1<DiagnosticAsyncToken> GetTokens();
    private static bool get_IsEnabled();
    private bool get_DiagnosticTokensEnabled();
    private IEnumerable`1<IAsynchronousOperationWaiter> GetCandidateWaiters(String[] featureNames);
    [CompilerGeneratedAttribute]
private AsynchronousOperationListener <.ctor>b__9_0(string name);
}
internal class Microsoft.CodeAnalysis.Shared.TestHooks.EmptyAsyncToken : object {
    [CompilerGeneratedAttribute]
private static IAsyncToken <Instance>k__BackingField;
    public static IAsyncToken Instance { get; }
    private static EmptyAsyncToken();
    [CompilerGeneratedAttribute]
public static IAsyncToken get_Instance();
    public sealed virtual void Dispose();
}
internal class Microsoft.CodeAnalysis.Shared.TestHooks.FeatureAttribute : object {
    public static string AutomaticEndConstructCorrection;
    public static string AutomaticPairCompletion;
    public static string BraceHighlighting;
    public static string CallHierarchy;
    public static string Classification;
    public static string CodeModel;
    public static string CompletionSet;
    public static string DesignerAttribute;
    public static string DiagnosticService;
    public static string EncapsulateField;
    public static string ErrorList;
    public static string ErrorSquiggles;
    public static string EventHookup;
    public static string FindReferences;
    public static string GlobalOperation;
    public static string GoToImplementation;
    public static string GraphProvider;
    public static string InfoBar;
    public static string KeywordHighlighting;
    public static string LightBulb;
    public static string LineSeparators;
    public static string NavigateTo;
    public static string NavigationBar;
    public static string Outlining;
    public static string QuickInfo;
    public static string ReferenceHighlighting;
    public static string Rename;
    public static string RenameTracking;
    public static string RemoteHostClient;
    public static string RuleSetEditor;
    public static string SignatureHelp;
    public static string Snippets;
    public static string SolutionCrawler;
    public static string TodoCommentList;
    public static string Workspace;
}
internal interface Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener {
    public abstract virtual IAsyncToken BeginAsyncOperation(string name, object tag, string filePath, int lineNumber);
}
internal interface Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListenerProvider {
    public abstract virtual IAsynchronousOperationListener GetListener(string featureName);
}
internal interface Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationWaiter {
    public bool TrackActiveTokens { get; public set; }
    public ImmutableArray`1<DiagnosticAsyncToken> ActiveDiagnosticTokens { get; }
    public bool HasPendingWork { get; }
    public abstract virtual bool get_TrackActiveTokens();
    public abstract virtual void set_TrackActiveTokens(bool value);
    public abstract virtual ImmutableArray`1<DiagnosticAsyncToken> get_ActiveDiagnosticTokens();
    public abstract virtual Task CreateWaitTask();
    public abstract virtual bool get_HasPendingWork();
}
internal interface Microsoft.CodeAnalysis.Shared.TestHooks.IAsyncToken {
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions : object {
    [ExtensionAttribute]
public static Task CompletesAsyncOperation(Task task, IAsyncToken asyncToken);
    [ExtensionAttribute]
public static Task CompletesTrackingOperation(Task task, IDisposable token);
}
internal abstract class Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`7 : object {
    private TExpressionSyntax _expression;
    private TExpressionSyntax _newExpressionForReplace;
    private SemanticModel _semanticModel;
    private CancellationToken _cancellationToken;
    private bool _skipVerificationForReplacedNode;
    private bool _failOnOverloadResolutionFailuresInOriginalCode;
    private bool _isNewSemanticModelSpeculativeModel;
    private SyntaxNode _lazySemanticRootOfOriginalExpression;
    private TExpressionSyntax _lazyReplacedExpression;
    private SyntaxNode _lazySemanticRootOfReplacedExpression;
    private SemanticModel _lazySpeculativeSemanticModel;
    public TExpressionSyntax OriginalExpression { get; }
    public SyntaxNode SemanticRootOfOriginalExpression { get; }
    public SemanticModel OriginalSemanticModel { get; }
    public TExpressionSyntax ReplacedExpression { get; }
    public SyntaxNode SemanticRootOfReplacedExpression { get; }
    public SemanticModel SpeculativeSemanticModel { get; }
    public CancellationToken CancellationToken { get; }
    public AbstractSpeculationAnalyzer`7(TExpressionSyntax expression, TExpressionSyntax newExpression, SemanticModel semanticModel, CancellationToken cancellationToken, bool skipVerificationForReplacedNode, bool failOnOverloadResolutionFailuresInOriginalCode);
    public TExpressionSyntax get_OriginalExpression();
    public SyntaxNode get_SemanticRootOfOriginalExpression();
    public SemanticModel get_OriginalSemanticModel();
    public TExpressionSyntax get_ReplacedExpression();
    public SyntaxNode get_SemanticRootOfReplacedExpression();
    public SemanticModel get_SpeculativeSemanticModel();
    public CancellationToken get_CancellationToken();
    protected abstract virtual SyntaxNode GetSemanticRootForSpeculation(TExpressionSyntax expression);
    protected virtual SyntaxNode GetSemanticRootOfReplacedExpression(SyntaxNode semanticRootOfOriginalExpression, TExpressionSyntax annotatedReplacedExpression);
    private void EnsureReplacedExpressionAndSemanticRoot();
    [ConditionalAttribute("DEBUG")]
protected abstract virtual void ValidateSpeculativeSemanticModel(SemanticModel speculativeSemanticModel, SyntaxNode nodeToSpeculate);
    private void EnsureSpeculativeSemanticModel();
    protected abstract virtual SemanticModel CreateSpeculativeSemanticModel(SyntaxNode originalNode, SyntaxNode nodeToSpeculate, SemanticModel semanticModel);
    private bool ReplacementIntroducesErrorType(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    protected bool TypesAreCompatible(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    protected bool ConvertedTypesAreCompatible(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    protected bool ImplicitConversionsAreCompatible(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    private bool ImplicitConversionsAreCompatible(TExpressionSyntax originalExpression, ITypeSymbol originalTargetType, TExpressionSyntax newExpression, ITypeSymbol newTargetType);
    protected abstract virtual bool ConversionsAreCompatible(SemanticModel model1, TExpressionSyntax expression1, SemanticModel model2, TExpressionSyntax expression2);
    protected abstract virtual bool ConversionsAreCompatible(TExpressionSyntax originalExpression, ITypeSymbol originalTargetType, TExpressionSyntax newExpression, ITypeSymbol newTargetType);
    protected bool SymbolsAreCompatible(SyntaxNode originalNode, SyntaxNode newNode, bool requireNonNullSymbols);
    public static bool SymbolInfosAreCompatible(SymbolInfo originalSymbolInfo, SymbolInfo newSymbolInfo, bool performEquivalenceCheck, bool requireNonNullSymbols);
    protected bool SymbolInfosAreCompatible(SymbolInfo originalSymbolInfo, SymbolInfo newSymbolInfo, bool requireNonNullSymbols);
    protected bool SymbolsAreCompatible(ISymbol symbol, ISymbol newSymbol, bool requireNonNullSymbols);
    private static bool SymbolsAreCompatibleCore(ISymbol symbol, ISymbol newSymbol, bool performEquivalenceCheck, bool requireNonNullSymbols);
    private static bool EnumTypesAreCompatible(INamedTypeSymbol type1, INamedTypeSymbol type2);
    public bool ReplacementChangesSemantics();
    protected abstract virtual bool IsParenthesizedExpression(SyntaxNode node);
    protected bool ReplacementChangesSemantics(SyntaxNode currentOriginalNode, SyntaxNode currentReplacedNode, SyntaxNode originalRoot, bool skipVerificationForCurrentNode);
    public bool SymbolsForOriginalAndReplacedNodesAreCompatible();
    protected abstract virtual bool ReplacementChangesSemanticsForNodeLanguageSpecific(SyntaxNode currentOriginalNode, SyntaxNode currentReplacedNode, SyntaxNode previousOriginalNode, SyntaxNode previousReplacedNode);
    private bool ReplacementChangesSemanticsForNode(SyntaxNode currentOriginalNode, SyntaxNode currentReplacedNode, SyntaxNode previousOriginalNode, SyntaxNode previousReplacedNode);
    private bool ReplacementBreaksAttribute(TAttributeSyntax attribute, TAttributeSyntax newAttribute);
    protected abstract virtual TExpressionSyntax GetForEachStatementExpression(TForEachStatementSyntax forEachStatement);
    protected abstract virtual bool IsForEachTypeInferred(TForEachStatementSyntax forEachStatement, SemanticModel semanticModel);
    private bool ReplacementBreaksForEachStatement(TForEachStatementSyntax forEachStatement, TForEachStatementSyntax newForEachStatement);
    protected abstract virtual bool ForEachConversionsAreCompatible(SemanticModel originalModel, TForEachStatementSyntax originalForEach, SemanticModel newModel, TForEachStatementSyntax newForEach);
    protected abstract virtual void GetForEachSymbols(SemanticModel model, TForEachStatementSyntax forEach, IMethodSymbol& getEnumeratorMethod, ITypeSymbol& elementType);
    private bool ReplacementBreaksForEachGetEnumerator(IMethodSymbol getEnumerator, IMethodSymbol newGetEnumerator, TExpressionSyntax newForEachStatementExpression);
    protected abstract virtual TExpressionSyntax GetThrowStatementExpression(TThrowStatementSyntax throwStatement);
    private bool ReplacementBreaksThrowStatement(TThrowStatementSyntax originalThrowStatement, TThrowStatementSyntax newThrowStatement);
    protected abstract virtual bool IsInNamespaceOrTypeContext(TExpressionSyntax node);
    private bool ReplacementBreaksTypeResolution(TTypeSyntax type, TTypeSyntax newType, bool useSpeculativeModel);
    protected abstract virtual bool IsInvocableExpression(SyntaxNode node);
    private static bool IsDelegateInvoke(ISymbol symbol);
    private static bool IsAnonymousDelegateInvoke(ISymbol symbol);
    private bool ReplacementBreaksInvocableExpression(TExpressionSyntax expression, TExpressionSyntax newExpression);
    protected bool ReplacementBreaksCompoundAssignment(TExpressionSyntax originalLeft, TExpressionSyntax originalRight, TExpressionSyntax newLeft, TExpressionSyntax newRight);
    protected abstract virtual bool IsReferenceConversion(Compilation model, ITypeSymbol sourceType, ITypeSymbol targetType);
    private bool IsCompatibleInterfaceMemberImplementation(ISymbol symbol, ISymbol newSymbol, TExpressionSyntax originalInvocationExpression, TExpressionSyntax newInvocationExpression, SemanticModel speculativeSemanticModel);
    private static bool IsEffectivelySealedClass(ITypeSymbol type);
    private bool IsReceiverNonUniquePossibleValueTypeParam(TExpressionSyntax invocation, SemanticModel semanticModel);
    private static bool IsReceiverUniqueInstance(TExpressionSyntax receiver, SemanticModel semanticModel);
    protected abstract virtual ImmutableArray`1<TArgumentSyntax> GetArguments(TExpressionSyntax expression);
    protected abstract virtual TExpressionSyntax GetReceiver(TExpressionSyntax expression);
    private bool SymbolsHaveCompatibleParameterLists(ISymbol originalSymbol, ISymbol newSymbol, TExpressionSyntax originalInvocation);
    protected abstract virtual bool IsNamedArgument(TArgumentSyntax argument);
    protected abstract virtual string GetNamedArgumentIdentifierValueText(TArgumentSyntax argument);
    private bool AreCompatibleParameterLists(ImmutableArray`1<TArgumentSyntax> specifiedArguments, ImmutableArray`1<IParameterSymbol> signature1Parameters, ImmutableArray`1<IParameterSymbol> signature2Parameters);
    protected void GetConversions(TExpressionSyntax originalExpression, ITypeSymbol originalTargetType, TExpressionSyntax newExpression, ITypeSymbol newTargetType, Nullable`1& originalConversion, Nullable`1& newConversion);
    protected abstract virtual TConversion ClassifyConversion(SemanticModel model, TExpressionSyntax expression, ITypeSymbol targetType);
    protected abstract virtual TConversion ClassifyConversion(SemanticModel model, ITypeSymbol originalType, ITypeSymbol targetType);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.AliasSymbolCache : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConditionalWeakTable`2<Compilation, ConcurrentDictionary`2<ValueTuple`2<SyntaxTree, int>, ImmutableDictionary`2<INamespaceOrTypeSymbol, IAliasSymbol>>> s_treeAliasMap;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static CreateValueCallback<Compilation, ConcurrentDictionary`2<ValueTuple`2<SyntaxTree, int>, ImmutableDictionary`2<INamespaceOrTypeSymbol, IAliasSymbol>>> s_createTreeMap;
    private static Func`2<ISymbol, string> s_symbolToName;
    private static AliasSymbolCache();
    public static bool TryGetAliasSymbol(SemanticModel semanticModel, int namespaceId, INamespaceOrTypeSymbol targetSymbol, IAliasSymbol& aliasSymbol);
    public static void AddAliasSymbols(SemanticModel semanticModel, int namespaceId, IEnumerable`1<IAliasSymbol> aliasSymbols);
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.BloomFilter : object {
    private static UInt32 Compute_Hash_m;
    private static int Compute_Hash_r;
    private BitArray _bitArray;
    private int _hashFunctionCount;
    private bool _isCaseSensitive;
    private static string SerializationFormat;
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    public BloomFilter(int expectedCount, double falsePositiveProbability, bool isCaseSensitive);
    public BloomFilter(double falsePositiveProbability, bool isCaseSensitive, ICollection`1<string> values);
    public BloomFilter(double falsePositiveProbability, ICollection`1<string> stringValues, ICollection`1<long> longValues);
    private BloomFilter(BitArray bitArray, int hashFunctionCount, bool isCaseSensitive);
    private static int ComputeM(int expectedCount, double falsePositiveProbability);
    private static int ComputeK(int expectedCount, double falsePositiveProbability);
    private int ComputeHash(string key, int seed);
    private int ComputeHash(long key, int seed);
    private static UInt32 CombineLastCharacter(UInt32 h, UInt32 c);
    private static UInt32 FinalMix(UInt32 h);
    private static UInt32 CombineTwoCharacters(UInt32 h, UInt32 c1, UInt32 c2);
    private char GetCharacter(string key, int index);
    private char GetCharacter(long key, int index);
    public void AddRange(IEnumerable`1<string> values);
    public void AddRange(IEnumerable`1<long> values);
    public void Add(string value);
    private int GetBitArrayIndex(string value, int i);
    public void Add(long value);
    private int GetBitArrayIndex(long value, int i);
    public bool ProbablyContains(string value);
    public bool ProbablyContains(long value);
    public bool IsEquivalent(BloomFilter filter);
    private bool IsEquivalent(BitArray array1, BitArray array2);
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    public sealed virtual void WriteTo(ObjectWriter writer);
    private static void WriteBitArray(ObjectWriter writer, BitArray bitArray);
    public static BloomFilter ReadFrom(ObjectReader reader);
    private static BitArray ReadBitArray(ObjectReader reader);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.CommonFormattingHelpers : object {
    public static Comparison`1<SuppressOperation> SuppressOperationComparer;
    public static Comparison`1<IndentBlockOperation> IndentBlockOperationComparer;
    private static CommonFormattingHelpers();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Utilities.CommonFormattingHelpers/<ConvertToTokenPairs>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> ConvertToTokenPairs(SyntaxNode root, IList`1<TextSpan> spans);
    [ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> ConvertToTokenPair(SyntaxNode root, TextSpan textSpan);
    [ExtensionAttribute]
public static bool IsInvalidTokenRange(SyntaxNode root, SyntaxToken startToken, SyntaxToken endToken);
    [ExtensionAttribute]
public static int GetTokenColumn(SyntaxTree tree, SyntaxToken token, int tabSize);
    [ExtensionAttribute]
public static string GetText(SourceText text, SyntaxToken token1, SyntaxToken token2);
    public static string GetTextBetween(SyntaxToken token1, SyntaxToken token2);
    public static void AppendTextBetween(SyntaxToken token1, SyntaxToken token2, StringBuilder builder);
    private static void AppendTextBetweenTwoAdjacentTokens(SyntaxToken token1, SyntaxToken token2, StringBuilder builder);
    private static void AppendLeadingTriviaText(SyntaxToken token, StringBuilder builder);
    private static void AppendPartialLeadingTriviaText(SyntaxToken token, StringBuilder builder, int token1FullSpanEnd);
    private static void AppendTrailingTriviaText(SyntaxToken token, StringBuilder builder);
    public static TextSpan GetSpanIncludingTrailingAndLeadingTriviaOfAdjacentTokens(SyntaxToken startToken, SyntaxToken endToken);
    private static int GetEndPositionOfSpan(SyntaxToken token);
    public static int GetStartPositionOfSpan(SyntaxToken token);
    private static SyntaxNode GetParentThatContainsGivenSpan(SyntaxNode node, int position, bool forward);
    public static bool HasAnyWhitespaceElasticTrivia(SyntaxToken previousToken, SyntaxToken currentToken);
    public static bool IsNull(T t);
    public static bool IsNotNull(T t);
    public static TextSpan GetFormattingSpan(SyntaxNode root, TextSpan span);
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment : object {
    [CompilerGeneratedAttribute]
private bool <HadXmlParseError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullXmlFragment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExampleText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SummaryText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReturnsText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemarksText>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ParameterNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <TypeParameterNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ExceptionTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompletionListCref>k__BackingField;
    private static String[] s_NewLineAsStringArray;
    private static DocumentationComment modreq(System.Runtime.CompilerServices.IsVolatile) s_cacheLastXmlFragmentParse;
    private Dictionary`2<string, string> _parameterTexts;
    private Dictionary`2<string, string> _typeParameterTexts;
    private Dictionary`2<string, ImmutableArray`1<string>> _exceptionTexts;
    public static DocumentationComment Empty;
    public bool HadXmlParseError { get; private set; }
    public string FullXmlFragment { get; private set; }
    public string ExampleText { get; private set; }
    public string SummaryText { get; private set; }
    public string ReturnsText { get; private set; }
    public string RemarksText { get; private set; }
    public ImmutableArray`1<string> ParameterNames { get; private set; }
    public ImmutableArray`1<string> TypeParameterNames { get; private set; }
    public ImmutableArray`1<string> ExceptionTypes { get; private set; }
    public string CompletionListCref { get; private set; }
    private static DocumentationComment();
    [CompilerGeneratedAttribute]
public bool get_HadXmlParseError();
    [CompilerGeneratedAttribute]
private void set_HadXmlParseError(bool value);
    [CompilerGeneratedAttribute]
public string get_FullXmlFragment();
    [CompilerGeneratedAttribute]
private void set_FullXmlFragment(string value);
    [CompilerGeneratedAttribute]
public string get_ExampleText();
    [CompilerGeneratedAttribute]
private void set_ExampleText(string value);
    [CompilerGeneratedAttribute]
public string get_SummaryText();
    [CompilerGeneratedAttribute]
private void set_SummaryText(string value);
    [CompilerGeneratedAttribute]
public string get_ReturnsText();
    [CompilerGeneratedAttribute]
private void set_ReturnsText(string value);
    [CompilerGeneratedAttribute]
public string get_RemarksText();
    [CompilerGeneratedAttribute]
private void set_RemarksText(string value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ParameterNames();
    [CompilerGeneratedAttribute]
private void set_ParameterNames(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_TypeParameterNames();
    [CompilerGeneratedAttribute]
private void set_TypeParameterNames(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ExceptionTypes();
    [CompilerGeneratedAttribute]
private void set_ExceptionTypes(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public string get_CompletionListCref();
    [CompilerGeneratedAttribute]
private void set_CompletionListCref(string value);
    public static DocumentationComment FromXmlFragment(string xml);
    public string GetParameterText(string parameterName);
    public string GetTypeParameterText(string typeParameterName);
    public ImmutableArray`1<string> GetExceptionTexts(string exceptionName);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.EditorBrowsableHelpers : object {
    public static IMethodSymbol GetSpecialEditorBrowsableAttributeConstructor(Compilation compilation);
    public static List`1<IMethodSymbol> GetSpecialTypeLibTypeAttributeConstructors(Compilation compilation);
    public static List`1<IMethodSymbol> GetSpecialTypeLibFuncAttributeConstructors(Compilation compilation);
    public static List`1<IMethodSymbol> GetSpecialTypeLibVarAttributeConstructors(Compilation compilation);
    private static List`1<IMethodSymbol> GetSpecialTypeLibAttributeConstructorsWorker(Compilation compilation, string attributeMetadataName, string flagsMetadataName);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.EnumValueUtilities : object {
    public static object GetNextEnumValue(INamedTypeSymbol enumType, CancellationToken cancellationToken);
    private static object CreateOne(SpecialType specialType);
    private static IComparable Multiply(IComparable value, UInt32 number);
    private static IComparable Add(IComparable value, UInt32 number);
    private static bool GreaterThanOrEqualsZero(IComparable value);
    private static bool LooksLikeFlagsEnum(INamedTypeSymbol enumType, List`1<IComparable> existingConstants);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.ExtensionOrderer : object {
    internal static IList`1<Lazy`2<TExtension, TMetadata>> Order(IEnumerable`1<Lazy`2<TExtension, TMetadata>> extensions);
    internal static void CheckForCycles(IEnumerable`1<Lazy`2<TExtension, TMetadata>> extensions);
    private static Graph`2<TExtension, TMetadata> GetGraph(IEnumerable`1<Lazy`2<TExtension, TMetadata>> extensions);
    private static IEnumerable`1<string> Before(Lazy`2<TExtension, TMetadata> extension);
    private static IEnumerable`1<string> After(Lazy`2<TExtension, TMetadata> extension);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.IntegerUtilities : object {
    public static int CountOfBitsSet(long v);
    public static bool HasOneBitSet(IComparable value);
    public static bool HasOneBitSet(long v);
    public static int LogBase2(long v);
    public static long Convert(long v, SpecialType type);
    public static ulong ToUnsigned(long v);
    public static ulong ToUInt64(object o);
    public static long ToInt64(object o);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.IOUtilities : object {
    public static void PerformIO(Action action);
    public static T PerformIO(Func`1<T> function, T defaultValue);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Utilities.IOUtilities/<PerformIOAsync>d__2`1")]
public static Task`1<T> PerformIOAsync(Func`1<Task`1<T>> function, T defaultValue);
    public static bool IsNormalIOException(Exception e);
}
internal interface Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker {
    public string Description { get; public set; }
    public int CompletedItems { get; }
    public int TotalItems { get; }
    public abstract virtual string get_Description();
    public abstract virtual void set_Description(string value);
    public abstract virtual int get_CompletedItems();
    public abstract virtual int get_TotalItems();
    public abstract virtual void AddItems(int count);
    public abstract virtual void ItemCompleted();
    public abstract virtual void Clear();
}
internal interface Microsoft.CodeAnalysis.Shared.Utilities.IStreamingProgressTracker {
    public abstract virtual Task AddItemsAsync(int count);
    public abstract virtual Task ItemCompletedAsync();
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.Matcher : object {
    public static Matcher`1<T> Repeat(Matcher`1<T> matcher);
    public static Matcher`1<T> OneOrMore(Matcher`1<T> matcher);
    public static Matcher`1<T> Choice(Matcher`1[] matchers);
    public static Matcher`1<T> Sequence(Matcher`1[] matchers);
    public static Matcher`1<T> Single(Func`2<T, bool> predicate, string description);
}
internal abstract class Microsoft.CodeAnalysis.Shared.Utilities.Matcher`1 : object {
    public abstract virtual bool TryMatch(IList`1<T> sequence, Int32& index);
    internal static Matcher`1<T> Repeat(Matcher`1<T> matcher);
    internal static Matcher`1<T> OneOrMore(Matcher`1<T> matcher);
    internal static Matcher`1<T> Choice(Matcher`1[] matchers);
    internal static Matcher`1<T> Sequence(Matcher`1[] matchers);
    internal static Matcher`1<T> Single(Func`2<T, bool> predicate, string description);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.NameGenerator : object {
    public static IList`1<string> EnsureUniqueness(IList`1<string> names, Func`2<string, bool> canUse);
    public static IList`1<string> EnsureUniqueness(IList`1<string> names, IList`1<bool> isFixed, Func`2<string, bool> canUse, bool isCaseSensitive);
    internal static IList`1<string> EnsureUniqueness(IList`1<string> names, bool isCaseSensitive);
    public static string EnsureUniqueness(string baseName, IEnumerable`1<string> reservedNames, bool isCaseSensitive);
    private static void EnsureUniquenessInPlace(IList`1<string> names, IList`1<bool> isFixed, Func`2<string, bool> canUse, bool isCaseSensitive);
    private static void HandleCollisions(IList`1<bool> isFixed, IList`1<string> names, string name, List`1<int> collisionIndices, Func`2<string, bool> canUse, bool isCaseSensitive);
    private static List`1<int> GetCollisionIndices(IList`1<string> names, string name, bool isCaseSensitive);
    public static string GenerateUniqueName(string baseName, Func`2<string, bool> canUse);
    public static string GenerateUniqueName(string baseName, ISet`1<string> names, StringComparer comparer);
    public static string GenerateUniqueName(string baseName, string extension, Func`2<string, bool> canUse);
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.ProgressTracker : object {
    private string _description;
    private int _completedItems;
    private int _totalItems;
    private Action`3<string, int, int> _updateActionOpt;
    public string Description { get; public set; }
    public int CompletedItems { get; }
    public int TotalItems { get; }
    public ProgressTracker(Action`3<string, int, int> updateActionOpt);
    public sealed virtual string get_Description();
    public sealed virtual void set_Description(string value);
    public sealed virtual int get_CompletedItems();
    public sealed virtual int get_TotalItems();
    public sealed virtual void AddItems(int count);
    public sealed virtual void ItemCompleted();
    public sealed virtual void Clear();
    private void Update();
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.SemanticMap : object {
    private Dictionary`2<SyntaxNode, SymbolInfo> _expressionToInfoMap;
    private Dictionary`2<SyntaxToken, SymbolInfo> _tokenToInfoMap;
    public IEnumerable`1<ISymbol> AllReferencedSymbols { get; }
    internal static SemanticMap From(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public IEnumerable`1<ISymbol> get_AllReferencedSymbols();
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.SignatureComparer : object {
    public static SignatureComparer Instance;
    public static SignatureComparer IgnoreAssembliesInstance;
    private SymbolEquivalenceComparer _symbolEquivalenceComparer;
    private IEqualityComparer`1<IParameterSymbol> ParameterEquivalenceComparer { get; }
    private IEqualityComparer`1<ITypeSymbol> SignatureTypeEquivalenceComparer { get; }
    private SignatureComparer(SymbolEquivalenceComparer symbolEquivalenceComparer);
    private static SignatureComparer();
    private IEqualityComparer`1<IParameterSymbol> get_ParameterEquivalenceComparer();
    private IEqualityComparer`1<ITypeSymbol> get_SignatureTypeEquivalenceComparer();
    public bool HaveSameSignature(ISymbol symbol1, ISymbol symbol2, bool caseSensitive);
    private bool HaveSameSignature(IEventSymbol event1, IEventSymbol event2, bool caseSensitive);
    public bool HaveSameSignature(IPropertySymbol property1, IPropertySymbol property2, bool caseSensitive);
    private bool BadPropertyAccessor(IMethodSymbol method1, IMethodSymbol method2);
    public bool HaveSameSignature(IMethodSymbol method1, IMethodSymbol method2, bool caseSensitive, bool compareParameterName, bool isParameterCaseSensitive);
    private bool IdentifiersMatch(string identifier1, string identifier2, bool caseSensitive);
    public bool HaveSameSignature(IList`1<IParameterSymbol> parameters1, IList`1<IParameterSymbol> parameters2);
    public bool HaveSameSignature(IList`1<IParameterSymbol> parameters1, IList`1<IParameterSymbol> parameters2, bool compareParameterName, bool isCaseSensitive);
    public bool HaveSameSignatureAndConstraintsAndReturnTypeAndAccessors(ISymbol symbol1, ISymbol symbol2, bool caseSensitive);
    private bool HaveSameAccessors(IPropertySymbol property1, IPropertySymbol property2);
    private bool HaveSameSignatureAndConstraintsAndReturnType(IMethodSymbol method1, IMethodSymbol method2);
    private bool HaveSameConstraints(ITypeParameterSymbol typeParameter1, ITypeParameterSymbol typeParameter2);
    private bool HaveSameReturnType(IPropertySymbol property1, IPropertySymbol property2);
    private bool HaveSameReturnType(IEventSymbol ev1, IEventSymbol ev2);
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.StreamingProgressTracker : object {
    private int _completedItems;
    private int _totalItems;
    private Func`3<int, int, Task> _updateActionOpt;
    public StreamingProgressTracker(Func`3<int, int, Task> updateActionOpt);
    public sealed virtual Task AddItemsAsync(int count);
    public sealed virtual Task ItemCompletedAsync();
    private Task UpdateAsync();
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.StringBreaker : object {
    public static ArrayBuilder`1<TextSpan> GetWordParts(string identifier);
    public static ArrayBuilder`1<TextSpan> GetCharacterParts(string identifier);
    public static ArrayBuilder`1<TextSpan> GetParts(string text, bool word);
    public static TextSpan GenerateSpan(string identifier, int wordStart, bool word);
    private static TextSpan ScanCharacterRun(string identifier, int length, int wordStart);
    private static TextSpan ScanWordRun(string identifier, int length, int wordStart);
    private static TextSpan ScanLowerCaseRun(string identifier, int length, int wordStart);
    private static TextSpan ScanNumber(string identifier, int length, int wordStart);
    private static int SkipPunctuation(string identifier, int length, int wordStart);
    private static bool IsLower(char c);
    private static bool IsAscii(char v);
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer : object {
    private ImmutableArray`1<EquivalenceVisitor> _equivalenceVisitors;
    private ImmutableArray`1<GetHashCodeVisitor> _getHashCodeVisitors;
    public static SymbolEquivalenceComparer Instance;
    public static SymbolEquivalenceComparer IgnoreAssembliesInstance;
    private IEqualityComparer`1<IAssemblySymbol> _assemblyComparerOpt;
    [CompilerGeneratedAttribute]
private ParameterSymbolEqualityComparer <ParameterEquivalenceComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureTypeSymbolEquivalenceComparer <SignatureTypeEquivalenceComparer>k__BackingField;
    public ParameterSymbolEqualityComparer ParameterEquivalenceComparer { get; }
    public SignatureTypeSymbolEquivalenceComparer SignatureTypeEquivalenceComparer { get; }
    internal SymbolEquivalenceComparer(IEqualityComparer`1<IAssemblySymbol> assemblyComparerOpt, bool distinguishRefFromOut);
    private static SymbolEquivalenceComparer();
    [CompilerGeneratedAttribute]
public ParameterSymbolEqualityComparer get_ParameterEquivalenceComparer();
    [CompilerGeneratedAttribute]
public SignatureTypeSymbolEquivalenceComparer get_SignatureTypeEquivalenceComparer();
    private EquivalenceVisitor GetEquivalenceVisitor(bool compareMethodTypeParametersByIndex, bool objectAndDynamicCompareEqually);
    private GetHashCodeVisitor GetGetHashCodeVisitor(bool compareMethodTypeParametersByIndex, bool objectAndDynamicCompareEqually);
    private static int GetVisitorIndex(bool compareMethodTypeParametersByIndex, bool objectAndDynamicCompareEqually);
    public bool ReturnTypeEquals(IMethodSymbol x, IMethodSymbol y, Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies);
    public sealed virtual bool Equals(ISymbol x, ISymbol y);
    public bool Equals(ISymbol x, ISymbol y, Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies);
    private bool EqualsCore(ISymbol x, ISymbol y, Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies);
    public sealed virtual int GetHashCode(ISymbol x);
    private static ISymbol UnwrapAlias(ISymbol symbol);
    private static SymbolKind GetKindAndUnwrapAlias(ISymbol& symbol);
    private static bool IsConstructedFromSelf(INamedTypeSymbol symbol);
    private static bool IsConstructedFromSelf(IMethodSymbol symbol);
    private static bool IsObjectType(ISymbol symbol);
    private static bool CheckContainingType(IMethodSymbol x);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer/<Unwrap>d__27")]
private static IEnumerable`1<INamedTypeSymbol> Unwrap(INamedTypeSymbol namedType);
    private static bool IsPartialMethodDefinitionPart(IMethodSymbol symbol);
    private static bool IsPartialMethodImplementationPart(IMethodSymbol symbol);
    private static TypeKind GetTypeKind(INamedTypeSymbol x);
    public static bool AreRefKindsEquivalent(RefKind rk1, RefKind rk2, bool distinguishRefFromOut);
}
internal enum Microsoft.CodeAnalysis.Shared.Utilities.SymbolVisibility : Enum {
    public int value__;
    public static SymbolVisibility Public;
    public static SymbolVisibility Internal;
    public static SymbolVisibility Private;
}
internal abstract class Microsoft.CodeAnalysis.Shared.Utilities.TextReaderWithLength : TextReader {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Length { get; }
    public TextReaderWithLength(int length);
    [CompilerGeneratedAttribute]
public int get_Length();
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.XmlFragmentParser : object {
    private XmlReader _xmlReader;
    private Reader _textReader;
    private static ObjectPool`1<XmlFragmentParser> s_pool;
    private static XmlReaderSettings s_xmlSettings;
    private bool BeforeStart { get; }
    private bool ReachedEnd { get; }
    private static XmlFragmentParser();
    public static void ParseFragment(string xmlFragment, Action`2<XmlReader, TArg> callback, TArg arg);
    private void ParseInternal(string text, Action`2<XmlReader, TArg> callback, TArg arg);
    private bool get_BeforeStart();
    private bool get_ReachedEnd();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SharedPoolExtensions : object {
    private static int Threshold;
    [ExtensionAttribute]
public static PooledObject`1<StringBuilder> GetPooledObject(ObjectPool`1<StringBuilder> pool);
    [ExtensionAttribute]
public static PooledObject`1<Stopwatch> GetPooledObject(ObjectPool`1<Stopwatch> pool);
    [ExtensionAttribute]
public static PooledObject`1<Stack`1<TItem>> GetPooledObject(ObjectPool`1<Stack`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Queue`1<TItem>> GetPooledObject(ObjectPool`1<Queue`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<HashSet`1<TItem>> GetPooledObject(ObjectPool`1<HashSet`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Dictionary`2<TKey, TValue>> GetPooledObject(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    [ExtensionAttribute]
public static PooledObject`1<List`1<TItem>> GetPooledObject(ObjectPool`1<List`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<T> GetPooledObject(ObjectPool`1<T> pool);
    [ExtensionAttribute]
public static StringBuilder AllocateAndClear(ObjectPool`1<StringBuilder> pool);
    [ExtensionAttribute]
public static Stopwatch AllocateAndClear(ObjectPool`1<Stopwatch> pool);
    [ExtensionAttribute]
public static Stack`1<T> AllocateAndClear(ObjectPool`1<Stack`1<T>> pool);
    [ExtensionAttribute]
public static Queue`1<T> AllocateAndClear(ObjectPool`1<Queue`1<T>> pool);
    [ExtensionAttribute]
public static HashSet`1<T> AllocateAndClear(ObjectPool`1<HashSet`1<T>> pool);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> AllocateAndClear(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    [ExtensionAttribute]
public static List`1<T> AllocateAndClear(ObjectPool`1<List`1<T>> pool);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<StringBuilder> pool, StringBuilder sb);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Stopwatch> pool, Stopwatch watch);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<HashSet`1<T>> pool, HashSet`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Stack`1<T>> pool, Stack`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Queue`1<T>> pool, Queue`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2<TKey, TValue> map);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<List`1<T>> pool, List`1<T> list);
}
internal static class Microsoft.CodeAnalysis.SharedPools : object {
    public static ObjectPool`1<HashSet`1<string>> StringIgnoreCaseHashSet;
    public static ObjectPool`1<HashSet`1<string>> StringHashSet;
    public static ObjectPool`1<Byte[]> ByteArray;
    public static ObjectPool`1<Char[]> CharArray;
    public static int ByteBufferSize;
    private static int ByteBufferCount;
    private static int CharBufferCount;
    private static SharedPools();
    public static ObjectPool`1<T> BigDefault();
    public static ObjectPool`1<T> Default();
    public static ObjectPool`1<Dictionary`2<string, T>> StringIgnoreCaseDictionary();
}
internal abstract class Microsoft.CodeAnalysis.Simplification.AbstractReducer : object {
    private ObjectPool`1<IReductionRewriter> _pool;
    protected AbstractReducer(ObjectPool`1<IReductionRewriter> pool);
    public IReductionRewriter GetOrCreateRewriter();
}
internal abstract class Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService`3 : object {
    private ImmutableArray`1<AbstractReducer> _reducers;
    protected AbstractSimplificationService`3(ImmutableArray`1<AbstractReducer> reducers);
    protected abstract virtual ImmutableArray`1<NodeOrTokenToReduce> GetNodesAndTokensToReduce(SyntaxNode root, Func`2<SyntaxNodeOrToken, bool> isNodeOrTokenOutsideSimplifySpans);
    protected abstract virtual SemanticModel GetSpeculativeSemanticModel(SyntaxNode& nodeToSpeculate, SemanticModel originalSemanticModel, SyntaxNode originalNode);
    protected abstract virtual bool CanNodeBeSimplifiedWithoutSpeculation(SyntaxNode node);
    protected virtual SyntaxNode TransformReducedNode(SyntaxNode reducedNode, SyntaxNode originalNode);
    public abstract virtual SyntaxNode Expand(SyntaxNode node, SemanticModel semanticModel, SyntaxAnnotation annotationForReplacedAliasIdentifier, Func`2<SyntaxNode, bool> expandInsideNode, bool expandParameter, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken Expand(SyntaxToken token, SemanticModel semanticModel, Func`2<SyntaxNode, bool> expandInsideNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService`3/<ReduceAsync>d__8")]
public sealed virtual Task`1<Document> ReduceAsync(Document document, ImmutableArray`1<TextSpan> spans, OptionSet optionSet, ImmutableArray`1<AbstractReducer> reducers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService`3/<ReduceAsyncInternal>d__9")]
private Task`1<Document> ReduceAsyncInternal(Document document, ImmutableArray`1<TextSpan> spans, OptionSet optionSet, ImmutableArray`1<AbstractReducer> reducers, CancellationToken cancellationToken);
    private Task ReduceAsync(Document document, SyntaxNode root, ImmutableArray`1<NodeOrTokenToReduce> nodesAndTokensToReduce, ImmutableArray`1<AbstractReducer> reducers, OptionSet optionSet, SemanticModel semanticModel, ConcurrentDictionary`2<SyntaxNode, SyntaxNode> reducedNodesMap, ConcurrentDictionary`2<SyntaxToken, SyntaxToken> reducedTokensMap, CancellationToken cancellationToken);
    private SyntaxNode PrepareNamespaceImportsForRemovalIfUnused(Document document, SyntaxNode root, SyntaxAnnotation removeIfUnusedAnnotation, Func`2<SyntaxNodeOrToken, bool> isNodeOrTokenOutsideSimplifySpan);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService`3/<RemoveUnusedNamespaceImportsAsync>d__12")]
private Task`1<Document> RemoveUnusedNamespaceImportsAsync(Document document, SyntaxAnnotation removeIfUnusedAnnotation, CancellationToken cancellationToken);
    protected abstract virtual void GetUnusedNamespaceImports(SemanticModel model, HashSet`1<SyntaxNode> namespaceImports, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Simplification.AliasAnnotation : object {
    public static string Kind;
    public static string GetAliasName(SyntaxAnnotation annotation);
    public static SyntaxAnnotation Create(string aliasName);
}
internal class Microsoft.CodeAnalysis.Simplification.DoNotAddImportsAnnotation : object {
    public static SyntaxAnnotation Annotation;
    public static string Kind;
    private static DoNotAddImportsAnnotation();
}
internal class Microsoft.CodeAnalysis.Simplification.DoNotAllowVarAnnotation : object {
    public static SyntaxAnnotation Annotation;
    public static string Kind;
    private static DoNotAllowVarAnnotation();
}
internal interface Microsoft.CodeAnalysis.Simplification.ISimplificationService {
    public abstract virtual SyntaxNode Expand(SyntaxNode node, SemanticModel semanticModel, SyntaxAnnotation annotationForReplacedAliasIdentifier, Func`2<SyntaxNode, bool> expandInsideNode, bool expandParameter, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken Expand(SyntaxToken token, SemanticModel semanticModel, Func`2<SyntaxNode, bool> expandInsideNode, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> ReduceAsync(Document document, ImmutableArray`1<TextSpan> spans, OptionSet optionSet, ImmutableArray`1<AbstractReducer> reducers, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Simplification.NodeOrTokenToReduce : ValueType {
    public SyntaxNodeOrToken NodeOrToken;
    public bool SimplifyAllDescendants;
    public SyntaxNodeOrToken OriginalNodeOrToken;
    public bool CanBeSpeculated;
    public NodeOrTokenToReduce(SyntaxNodeOrToken nodeOrToken, bool simplifyAllDescendants, SyntaxNodeOrToken originalNodeOrToken, bool canBeSpeculated);
}
internal static class Microsoft.CodeAnalysis.Simplification.SimplificationHelpers : object {
    public static SyntaxAnnotation DontSimplifyAnnotation;
    public static SyntaxAnnotation SimplifyModuleNameAnnotation;
    private static SimplificationHelpers();
    public static TNode CopyAnnotations(SyntaxNode from, TNode to);
    public static SyntaxToken CopyAnnotations(SyntaxToken from, SyntaxToken to);
    internal static ISymbol GetOriginalSymbolInfo(SemanticModel semanticModel, SyntaxNode expression);
    internal static bool IsValidSymbolInfo(ISymbol symbol);
    internal static bool ShouldSimplifyMemberAccessExpression(SemanticModel semanticModel, SyntaxNode expression, OptionSet optionSet);
    internal static bool PreferPredefinedTypeKeywordInDeclarations(OptionSet optionSet, string language);
    internal static bool PreferPredefinedTypeKeywordInMemberAccess(OptionSet optionSet, string language);
}
public static class Microsoft.CodeAnalysis.Simplification.SimplificationOptions : object {
    [CompilerGeneratedAttribute]
private static Option`1<bool> <PreferAliasToQualification>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <PreferOmittingModuleNamesInQualification>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <PreferImplicitTypeInference>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <PreferImplicitTypeInLocalDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <AllowSimplificationToGenericType>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <AllowSimplificationToBaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <QualifyMemberAccessWithThisOrMe>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <QualifyFieldAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <QualifyPropertyAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <QualifyMethodAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <QualifyEventAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <PreferIntrinsicPredefinedTypeKeywordInDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <PreferIntrinsicPredefinedTypeKeywordInMemberAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<NamingStylePreferences> <NamingPreferences>k__BackingField;
    public static Option`1<bool> PreferAliasToQualification { get; }
    public static Option`1<bool> PreferOmittingModuleNamesInQualification { get; }
    public static Option`1<bool> PreferImplicitTypeInference { get; }
    public static Option`1<bool> PreferImplicitTypeInLocalDeclaration { get; }
    public static Option`1<bool> AllowSimplificationToGenericType { get; }
    public static Option`1<bool> AllowSimplificationToBaseType { get; }
    [ObsoleteAttribute]
public static PerLanguageOption`1<bool> QualifyMemberAccessWithThisOrMe { get; }
    [ObsoleteAttribute]
public static PerLanguageOption`1<bool> QualifyFieldAccess { get; }
    [ObsoleteAttribute]
public static PerLanguageOption`1<bool> QualifyPropertyAccess { get; }
    [ObsoleteAttribute]
public static PerLanguageOption`1<bool> QualifyMethodAccess { get; }
    [ObsoleteAttribute]
public static PerLanguageOption`1<bool> QualifyEventAccess { get; }
    [ObsoleteAttribute]
public static PerLanguageOption`1<bool> PreferIntrinsicPredefinedTypeKeywordInDeclaration { get; }
    [ObsoleteAttribute]
public static PerLanguageOption`1<bool> PreferIntrinsicPredefinedTypeKeywordInMemberAccess { get; }
    internal static PerLanguageOption`1<NamingStylePreferences> NamingPreferences { get; }
    private static SimplificationOptions();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_PreferAliasToQualification();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_PreferOmittingModuleNamesInQualification();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_PreferImplicitTypeInference();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_PreferImplicitTypeInLocalDeclaration();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_AllowSimplificationToGenericType();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_AllowSimplificationToBaseType();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_QualifyMemberAccessWithThisOrMe();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_QualifyFieldAccess();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_QualifyPropertyAccess();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_QualifyMethodAccess();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_QualifyEventAccess();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_PreferIntrinsicPredefinedTypeKeywordInDeclaration();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_PreferIntrinsicPredefinedTypeKeywordInMemberAccess();
    [CompilerGeneratedAttribute]
internal static PerLanguageOption`1<NamingStylePreferences> get_NamingPreferences();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Simplification.SimplificationOptionsProvider : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
public static class Microsoft.CodeAnalysis.Simplification.Simplifier : object {
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <Annotation>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <SpecialTypeAnnotation>k__BackingField;
    public static SyntaxAnnotation Annotation { get; }
    public static SyntaxAnnotation SpecialTypeAnnotation { get; }
    private static Simplifier();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_Annotation();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_SpecialTypeAnnotation();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ExpandAsync>d__6`1")]
public static Task`1<TNode> ExpandAsync(TNode node, Document document, Func`2<SyntaxNode, bool> expandInsideNode, bool expandParameter, CancellationToken cancellationToken);
    public static TNode Expand(TNode node, SemanticModel semanticModel, Workspace workspace, Func`2<SyntaxNode, bool> expandInsideNode, bool expandParameter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ExpandAsync>d__8")]
public static Task`1<SyntaxToken> ExpandAsync(SyntaxToken token, Document document, Func`2<SyntaxNode, bool> expandInsideNode, CancellationToken cancellationToken);
    public static SyntaxToken Expand(SyntaxToken token, SemanticModel semanticModel, Workspace workspace, Func`2<SyntaxNode, bool> expandInsideNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ReduceAsync>d__10")]
public static Task`1<Document> ReduceAsync(Document document, OptionSet optionSet, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ReduceAsync>d__11")]
public static Task`1<Document> ReduceAsync(Document document, SyntaxAnnotation annotation, OptionSet optionSet, CancellationToken cancellationToken);
    public static Task`1<Document> ReduceAsync(Document document, TextSpan span, OptionSet optionSet, CancellationToken cancellationToken);
    public static Task`1<Document> ReduceAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet optionSet, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ReduceAsync>d__14")]
internal static Task`1<Document> ReduceAsync(Document document, ImmutableArray`1<AbstractReducer> reducers, OptionSet optionSet, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Simplification.SpecialTypeAnnotation : object {
    public static string Kind;
    private static ConcurrentDictionary`2<SpecialType, string> s_fromSpecialTypes;
    private static ConcurrentDictionary`2<string, SpecialType> s_toSpecialTypes;
    private static SpecialTypeAnnotation();
    public static SyntaxAnnotation Create(SpecialType specialType);
    public static SpecialType GetSpecialType(SyntaxAnnotation annotation);
    private static string CreateFromSpecialTypes(SpecialType arg);
    private static SpecialType CreateToSpecialTypes(string arg);
}
internal class Microsoft.CodeAnalysis.Simplification.SymbolAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create(ISymbol symbol);
    public static ISymbol GetSymbol(SyntaxAnnotation annotation, Compilation compilation);
    public static ImmutableArray`1<ISymbol> GetSymbols(SyntaxAnnotation annotation, Compilation compilation);
}
public class Microsoft.CodeAnalysis.Solution : object {
    private SolutionState _state;
    private ImmutableHashMap`2<ProjectId, Project> _projectIdToProjectMap;
    private static Func`3<ProjectId, Solution, Project> s_createProjectFunction;
    internal SolutionState State { get; }
    internal int WorkspaceVersion { get; }
    internal SolutionServices Services { get; }
    internal BranchId BranchId { get; }
    public Workspace Workspace { get; }
    public SolutionId Id { get; }
    public string FilePath { get; }
    public VersionStamp Version { get; }
    public IReadOnlyList`1<ProjectId> ProjectIds { get; }
    public IEnumerable`1<Project> Projects { get; }
    public OptionSet Options { get; }
    private Solution(SolutionState state);
    internal Solution(Workspace workspace, SolutionInfo info);
    private static Solution();
    internal SolutionState get_State();
    internal int get_WorkspaceVersion();
    internal SolutionServices get_Services();
    internal BranchId get_BranchId();
    internal ProjectState GetProjectState(ProjectId projectId);
    public Workspace get_Workspace();
    public SolutionId get_Id();
    public string get_FilePath();
    public VersionStamp get_Version();
    public IReadOnlyList`1<ProjectId> get_ProjectIds();
    public IEnumerable`1<Project> get_Projects();
    public VersionStamp GetLatestProjectVersion();
    public bool ContainsProject(ProjectId projectId);
    public Project GetProject(ProjectId projectId);
    private static Project CreateProject(ProjectId projectId, Solution solution);
    public Project GetProject(IAssemblySymbol assemblySymbol, CancellationToken cancellationToken);
    public bool ContainsDocument(DocumentId documentId);
    public bool ContainsAdditionalDocument(DocumentId documentId);
    public DocumentId GetDocumentId(SyntaxTree syntaxTree);
    public DocumentId GetDocumentId(SyntaxTree syntaxTree, ProjectId projectId);
    public Document GetDocument(DocumentId documentId);
    public TextDocument GetAdditionalDocument(DocumentId documentId);
    public Document GetDocument(SyntaxTree syntaxTree);
    internal Document GetDocument(SyntaxTree syntaxTree, ProjectId projectId);
    public Project AddProject(string name, string assemblyName, string language);
    public Solution AddProject(ProjectId projectId, string name, string assemblyName, string language);
    public Solution AddProject(ProjectInfo projectInfo);
    public Solution RemoveProject(ProjectId projectId);
    public Solution WithProjectAssemblyName(ProjectId projectId, string assemblyName);
    public Solution WithProjectOutputFilePath(ProjectId projectId, string outputFilePath);
    public Solution WithProjectOutputRefFilePath(ProjectId projectId, string outputRefFilePath);
    public Solution WithProjectName(ProjectId projectId, string name);
    public Solution WithProjectFilePath(ProjectId projectId, string filePath);
    public Solution WithProjectCompilationOptions(ProjectId projectId, CompilationOptions options);
    public Solution WithProjectParseOptions(ProjectId projectId, ParseOptions options);
    internal Solution WithProjectOptionsChanged(ProjectId projectId);
    internal Solution WithHasAllInformation(ProjectId projectId, bool hasAllInformation);
    public Solution AddProjectReference(ProjectId projectId, ProjectReference projectReference);
    public Solution AddProjectReferences(ProjectId projectId, IEnumerable`1<ProjectReference> projectReferences);
    public Solution RemoveProjectReference(ProjectId projectId, ProjectReference projectReference);
    public Solution WithProjectReferences(ProjectId projectId, IEnumerable`1<ProjectReference> projectReferences);
    public Solution AddMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    public Solution AddMetadataReferences(ProjectId projectId, IEnumerable`1<MetadataReference> metadataReferences);
    public Solution RemoveMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    public Solution WithProjectMetadataReferences(ProjectId projectId, IEnumerable`1<MetadataReference> metadataReferences);
    public Solution AddAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    public Solution AddAnalyzerReferences(ProjectId projectId, IEnumerable`1<AnalyzerReference> analyzerReferences);
    public Solution RemoveAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    public Solution WithProjectAnalyzerReferences(ProjectId projectId, IEnumerable`1<AnalyzerReference> analyzerReferences);
    private static SourceCodeKind GetSourceCodeKind(ProjectState project);
    public Solution AddDocument(DocumentId documentId, string name, string text, IEnumerable`1<string> folders, string filePath);
    public Solution AddDocument(DocumentId documentId, string name, SourceText text, IEnumerable`1<string> folders, string filePath, bool isGenerated);
    public Solution AddDocument(DocumentId documentId, string name, SyntaxNode syntaxRoot, IEnumerable`1<string> folders, string filePath, bool isGenerated, PreservationMode preservationMode);
    public Solution AddDocument(DocumentId documentId, string name, TextLoader loader, IEnumerable`1<string> folders);
    public Solution AddDocument(DocumentInfo documentInfo);
    public Solution AddAdditionalDocument(DocumentId documentId, string name, string text, IEnumerable`1<string> folders, string filePath);
    public Solution AddAdditionalDocument(DocumentId documentId, string name, SourceText text, IEnumerable`1<string> folders, string filePath);
    public Solution AddAdditionalDocument(DocumentInfo documentInfo);
    public Solution RemoveDocument(DocumentId documentId);
    public Solution RemoveAdditionalDocument(DocumentId documentId);
    public Solution WithDocumentName(DocumentId documentId, string name);
    public Solution WithDocumentFolders(DocumentId documentId, IEnumerable`1<string> folders);
    public Solution WithDocumentFilePath(DocumentId documentId, string filePath);
    public Solution WithDocumentText(DocumentId documentId, SourceText text, PreservationMode mode);
    public Solution WithAdditionalDocumentText(DocumentId documentId, SourceText text, PreservationMode mode);
    public Solution WithDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode);
    public Solution WithAdditionalDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode);
    public Solution WithDocumentSyntaxRoot(DocumentId documentId, SyntaxNode root, PreservationMode mode);
    public Solution WithDocumentSourceCodeKind(DocumentId documentId, SourceCodeKind sourceCodeKind);
    public Solution WithDocumentTextLoader(DocumentId documentId, TextLoader loader, PreservationMode mode);
    internal Solution WithDocumentTextLoader(DocumentId documentId, TextLoader loader, SourceText textOpt, PreservationMode mode);
    public Solution WithAdditionalDocumentTextLoader(DocumentId documentId, TextLoader loader, PreservationMode mode);
    internal Solution WithFrozenPartialCompilationIncludingSpecificDocument(DocumentId documentId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Solution/<WithMergedLinkedFileChangesAsync>d__88")]
internal Task`1<Solution> WithMergedLinkedFileChangesAsync(Solution oldSolution, Nullable`1<SolutionChanges> solutionChanges, IMergeConflictHandler mergeConflictHandler, CancellationToken cancellationToken);
    internal ImmutableArray`1<DocumentId> GetRelatedDocumentIds(DocumentId documentId);
    internal Solution WithNewWorkspace(Workspace workspace, int workspaceVersion);
    public Solution GetIsolatedSolution();
    public Solution WithDocumentText(IEnumerable`1<DocumentId> documentIds, SourceText text, PreservationMode mode);
    public SolutionChanges GetChanges(Solution oldSolution);
    public ImmutableArray`1<DocumentId> GetDocumentIdsWithFilePath(string filePath);
    public ProjectDependencyGraph GetProjectDependencyGraph();
    public OptionSet get_Options();
    [CompilerGeneratedAttribute]
private Project <get_Projects>b__24_0(ProjectId id);
}
public class Microsoft.CodeAnalysis.SolutionChanges : ValueType {
    private Solution _newSolution;
    private Solution _oldSolution;
    internal SolutionChanges(Solution newSolution, Solution oldSolution);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SolutionChanges/<GetAddedProjects>d__3")]
public IEnumerable`1<Project> GetAddedProjects();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SolutionChanges/<GetProjectChanges>d__4")]
public IEnumerable`1<ProjectChanges> GetProjectChanges();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SolutionChanges/<GetRemovedProjects>d__5")]
public IEnumerable`1<Project> GetRemovedProjects();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.SolutionCrawler.ExportIncrementalAnalyzerProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private bool <HighPriorityForActiveFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <WorkspaceKinds>k__BackingField;
    public bool HighPriorityForActiveFile { get; }
    public string Name { get; }
    public String[] WorkspaceKinds { get; }
    public ExportIncrementalAnalyzerProviderAttribute(String[] workspaceKinds);
    public ExportIncrementalAnalyzerProviderAttribute(string name, String[] workspaceKinds);
    public ExportIncrementalAnalyzerProviderAttribute(bool highPriorityForActiveFile, string name, String[] workspaceKinds);
    [CompilerGeneratedAttribute]
public bool get_HighPriorityForActiveFile();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public String[] get_WorkspaceKinds();
}
internal interface Microsoft.CodeAnalysis.SolutionCrawler.IIncrementalAnalyzer {
    public abstract virtual Task NewSolutionSnapshotAsync(Solution solution, CancellationToken cancellationToken);
    public abstract virtual Task DocumentOpenAsync(Document document, CancellationToken cancellationToken);
    public abstract virtual Task DocumentCloseAsync(Document document, CancellationToken cancellationToken);
    public abstract virtual Task DocumentResetAsync(Document document, CancellationToken cancellationToken);
    public abstract virtual Task AnalyzeSyntaxAsync(Document document, InvocationReasons reasons, CancellationToken cancellationToken);
    public abstract virtual Task AnalyzeDocumentAsync(Document document, SyntaxNode bodyOpt, InvocationReasons reasons, CancellationToken cancellationToken);
    public abstract virtual Task AnalyzeProjectAsync(Project project, bool semanticsChanged, InvocationReasons reasons, CancellationToken cancellationToken);
    public abstract virtual void RemoveDocument(DocumentId documentId);
    public abstract virtual void RemoveProject(ProjectId projectId);
    public abstract virtual bool NeedsReanalysisOnOptionChanged(object sender, OptionChangedEventArgs e);
}
internal interface Microsoft.CodeAnalysis.SolutionCrawler.IIncrementalAnalyzerProvider {
    public abstract virtual IIncrementalAnalyzer CreateIncrementalAnalyzer(Workspace workspace);
}
internal class Microsoft.CodeAnalysis.SolutionCrawler.IncrementalAnalyzerProviderMetadata : object {
    [CompilerGeneratedAttribute]
private bool <HighPriorityForActiveFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <WorkspaceKinds>k__BackingField;
    public bool HighPriorityForActiveFile { get; }
    public string Name { get; }
    public String[] WorkspaceKinds { get; }
    public IncrementalAnalyzerProviderMetadata(IDictionary`2<string, object> data);
    public IncrementalAnalyzerProviderMetadata(string name, bool highPriorityForActiveFile, String[] workspaceKinds);
    [CompilerGeneratedAttribute]
public bool get_HighPriorityForActiveFile();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public String[] get_WorkspaceKinds();
}
internal class Microsoft.CodeAnalysis.SolutionCrawler.InvocationReasons : ValueType {
    public static InvocationReasons Empty;
    private ImmutableHashSet`1<string> _reasons;
    public static InvocationReasons DocumentAdded;
    public static InvocationReasons DocumentRemoved;
    public static InvocationReasons ProjectParseOptionChanged;
    public static InvocationReasons ProjectConfigurationChanged;
    public static InvocationReasons SolutionRemoved;
    public static InvocationReasons DocumentOpened;
    public static InvocationReasons DocumentClosed;
    public static InvocationReasons DocumentChanged;
    public static InvocationReasons AdditionalDocumentChanged;
    public static InvocationReasons SyntaxChanged;
    public static InvocationReasons SemanticChanged;
    public static InvocationReasons Reanalyze;
    public static InvocationReasons ReanalyzeHighPriority;
    public bool IsEmpty { get; }
    public InvocationReasons(string reason);
    private InvocationReasons(ImmutableHashSet`1<string> reasons);
    private static InvocationReasons();
    public bool Contains(string reason);
    public InvocationReasons With(InvocationReasons invocationReasons);
    public InvocationReasons With(string reason);
    public bool get_IsEmpty();
    public Enumerator<string> GetEnumerator();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
internal interface Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerRegistrationService {
    public abstract virtual void Register(Workspace workspace);
    public abstract virtual void Unregister(Workspace workspace, bool blockingShutdown);
    public abstract virtual void AddAnalyzerProvider(IIncrementalAnalyzerProvider provider, IncrementalAnalyzerProviderMetadata metadata);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerRegistrationService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SolutionCrawler.NullSolutionCrawlerRegistrationService : object {
    public sealed virtual void Register(Workspace workspace);
    public sealed virtual void Unregister(Workspace workspace, bool blockingShutdown);
    public sealed virtual void AddAnalyzerProvider(IIncrementalAnalyzerProvider provider, IncrementalAnalyzerProviderMetadata metadata);
}
internal static class Microsoft.CodeAnalysis.SolutionCrawler.PredefinedInvocationReasons : object {
    public static string SolutionRemoved;
    public static string ProjectParseOptionsChanged;
    public static string ProjectConfigurationChanged;
    public static string DocumentAdded;
    public static string DocumentRemoved;
    public static string DocumentOpened;
    public static string DocumentClosed;
    public static string HighPriority;
    public static string SyntaxChanged;
    public static string SemanticChanged;
    public static string Reanalyze;
}
internal static class Microsoft.CodeAnalysis.SolutionCrawler.WellKnownSolutionCrawlerAnalyzers : object {
    public static string Diagnostic;
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.SolutionId : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    private string _debugName;
    public Guid Id { get; }
    internal string DebugName { get; }
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    private SolutionId(Guid id, string debugName);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    public static SolutionId CreateNewId(string debugName);
    public static SolutionId CreateFromSerialized(Guid id, string debugName);
    internal string get_DebugName();
    private string GetDebuggerDisplay();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SolutionId other);
    public static bool op_Equality(SolutionId left, SolutionId right);
    public static bool op_Inequality(SolutionId left, SolutionId right);
    public virtual int GetHashCode();
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    internal static SolutionId ReadFrom(ObjectReader reader);
}
public class Microsoft.CodeAnalysis.SolutionInfo : object {
    [CompilerGeneratedAttribute]
private SolutionAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ProjectInfo> <Projects>k__BackingField;
    internal SolutionAttributes Attributes { get; }
    public SolutionId Id { get; }
    public VersionStamp Version { get; }
    public string FilePath { get; }
    public IReadOnlyList`1<ProjectInfo> Projects { get; }
    private SolutionInfo(SolutionAttributes attributes, IEnumerable`1<ProjectInfo> projects);
    [CompilerGeneratedAttribute]
internal SolutionAttributes get_Attributes();
    public SolutionId get_Id();
    public VersionStamp get_Version();
    public string get_FilePath();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ProjectInfo> get_Projects();
    public static SolutionInfo Create(SolutionId id, VersionStamp version, string filePath, IEnumerable`1<ProjectInfo> projects);
    private SolutionInfo With(SolutionAttributes attributes, IEnumerable`1<ProjectInfo> projects);
    internal SolutionInfo WithVersion(VersionStamp version);
    internal SolutionInfo WithFilePath(string filePath);
    internal SolutionInfo WithProjects(IEnumerable`1<ProjectInfo> projects);
}
internal class Microsoft.CodeAnalysis.SolutionServices : object {
    internal Workspace Workspace;
    internal ITemporaryStorageService TemporaryStorage;
    internal IMetadataService MetadataService;
    internal IProjectCacheHostService CacheService;
    internal bool SupportsCachingRecoverableObjects { get; }
    public SolutionServices(Workspace workspace);
    internal bool get_SupportsCachingRecoverableObjects();
}
internal class Microsoft.CodeAnalysis.SolutionState : object {
    private BranchId _branchId;
    private int _workspaceVersion;
    private SolutionInfo _solutionInfo;
    private SolutionServices _solutionServices;
    private IReadOnlyList`1<ProjectId> _projectIds;
    private ImmutableDictionary`2<ProjectId, ProjectState> _projectIdToProjectStateMap;
    private ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> _linkedFilesMap;
    private Lazy`1<VersionStamp> _lazyLatestProjectVersion;
    private ProjectDependencyGraph _dependencyGraph;
    private ImmutableDictionary`2<ProjectId, CompilationTracker> _projectIdToTrackerMap;
    private ValueSource`1<SolutionStateChecksums> _lazyChecksums;
    private static Func`3<ProjectId, SolutionState, CompilationTracker> s_createCompilationTrackerFunction;
    private NonReentrantLock _stateLockBackingField;
    private WeakReference`1<SolutionState> _latestSolutionWithPartialCompilation;
    private DateTime _timeOfLatestSolutionWithPartialCompilation;
    private DocumentId _documentIdOfLatestSolutionWithPartialCompilation;
    private static ConditionalWeakTable`2<ISymbol, ProjectId> s_assemblyOrModuleSymbolToProjectMap;
    public SolutionInfo SolutionInfo { get; }
    public ImmutableDictionary`2<ProjectId, ProjectState> ProjectStates { get; }
    public int WorkspaceVersion { get; }
    public SolutionServices Services { get; }
    public BranchId BranchId { get; }
    public Workspace Workspace { get; }
    public SolutionId Id { get; }
    public string FilePath { get; }
    public VersionStamp Version { get; }
    public IReadOnlyList`1<ProjectId> ProjectIds { get; }
    private NonReentrantLock StateLock { get; }
    private SolutionState(BranchId branchId, int workspaceVersion, SolutionServices solutionServices, SolutionInfo solutionInfo, IEnumerable`1<ProjectId> projectIds, ImmutableDictionary`2<ProjectId, ProjectState> idToProjectStateMap, ImmutableDictionary`2<ProjectId, CompilationTracker> projectIdToTrackerMap, ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> linkedFilesMap, ProjectDependencyGraph dependencyGraph, Lazy`1<VersionStamp> lazyLatestProjectVersion);
    public SolutionState(Workspace workspace, SolutionInfo info);
    private static SolutionState();
    public SolutionState WithNewWorkspace(Workspace workspace, int workspaceVersion);
    private VersionStamp ComputeLatestProjectVersion();
    public SolutionInfo get_SolutionInfo();
    public ImmutableDictionary`2<ProjectId, ProjectState> get_ProjectStates();
    public int get_WorkspaceVersion();
    public SolutionServices get_Services();
    public BranchId get_BranchId();
    public Workspace get_Workspace();
    public SolutionId get_Id();
    public string get_FilePath();
    public VersionStamp get_Version();
    public IReadOnlyList`1<ProjectId> get_ProjectIds();
    private void CheckInvariants();
    private SolutionState Branch(SolutionInfo solutionInfo, IEnumerable`1<ProjectId> projectIds, ImmutableDictionary`2<ProjectId, ProjectState> idToProjectStateMap, ImmutableDictionary`2<ProjectId, CompilationTracker> projectIdToTrackerMap, ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> linkedFilesMap, ProjectDependencyGraph dependencyGraph, Lazy`1<VersionStamp> lazyLatestProjectVersion);
    private SolutionState CreatePrimarySolution(BranchId branchId, int workspaceVersion, SolutionServices services);
    private BranchId GetBranchId();
    public VersionStamp GetLatestProjectVersion();
    public bool ContainsProject(ProjectId projectId);
    public bool ContainsDocument(DocumentId documentId);
    public bool ContainsAdditionalDocument(DocumentId documentId);
    private DocumentState GetDocumentState(DocumentId documentId);
    private DocumentState GetDocumentState(SyntaxTree syntaxTree, ProjectId projectId);
    private TextDocumentState GetAdditionalDocumentState(DocumentId documentId);
    public Task`1<VersionStamp> GetDependentVersionAsync(ProjectId projectId, CancellationToken cancellationToken);
    public Task`1<VersionStamp> GetDependentSemanticVersionAsync(ProjectId projectId, CancellationToken cancellationToken);
    public ProjectState GetProjectState(ProjectId projectId);
    public ProjectState GetProjectState(IAssemblySymbol assemblySymbol, CancellationToken cancellationToken);
    private bool TryGetCompilationTracker(ProjectId projectId, CompilationTracker& tracker);
    private static CompilationTracker CreateCompilationTracker(ProjectId projectId, SolutionState solution);
    private CompilationTracker GetCompilationTracker(ProjectId projectId);
    private SolutionState AddProject(ProjectId projectId, ProjectState projectState);
    public SolutionState AddProject(ProjectInfo projectInfo);
    private ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> CreateLinkedFilesMapWithAddedProject(ProjectState projectState);
    private ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> CreateLinkedFilesMapWithAddedDocuments(ProjectState projectState, IEnumerable`1<DocumentId> documentIds);
    public SolutionState RemoveProject(ProjectId projectId);
    private ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> CreateLinkedFilesMapWithRemovedProject(ProjectState projectState);
    private ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> CreateLinkedFilesMapWithRemovedDocuments(ProjectState projectState, IEnumerable`1<DocumentId> documentIds);
    public SolutionState WithProjectAssemblyName(ProjectId projectId, string assemblyName);
    public SolutionState WithProjectOutputFilePath(ProjectId projectId, string outputFilePath);
    public SolutionState WithProjectOutputRefFilePath(ProjectId projectId, string outputRefFilePath);
    public SolutionState WithProjectName(ProjectId projectId, string name);
    public SolutionState WithProjectFilePath(ProjectId projectId, string filePath);
    public SolutionState WithProjectCompilationOptions(ProjectId projectId, CompilationOptions options);
    public SolutionState WithProjectParseOptions(ProjectId projectId, ParseOptions options);
    internal SolutionState WithProjectOptionsChanged(ProjectId projectId);
    public SolutionState WithHasAllInformation(ProjectId projectId, bool hasAllInformation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionState/<ReplaceSyntaxTreesWithTreesFromNewProjectStateAsync>d__72")]
private static Task`1<Compilation> ReplaceSyntaxTreesWithTreesFromNewProjectStateAsync(Compilation compilation, ProjectState projectState, CancellationToken cancellationToken);
    public SolutionState AddProjectReferences(ProjectId projectId, IEnumerable`1<ProjectReference> projectReferences);
    public SolutionState RemoveProjectReference(ProjectId projectId, ProjectReference projectReference);
    public SolutionState WithProjectReferences(ProjectId projectId, IEnumerable`1<ProjectReference> projectReferences);
    public SolutionState AddMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    public SolutionState AddMetadataReferences(ProjectId projectId, IEnumerable`1<MetadataReference> metadataReferences);
    public SolutionState RemoveMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    public SolutionState WithProjectMetadataReferences(ProjectId projectId, IEnumerable`1<MetadataReference> metadataReferences);
    public SolutionState AddAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    public SolutionState AddAnalyzerReferences(ProjectId projectId, IEnumerable`1<AnalyzerReference> analyzerReferences);
    public SolutionState RemoveAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    public SolutionState WithProjectAnalyzerReferences(ProjectId projectId, IEnumerable`1<AnalyzerReference> analyzerReferences);
    public SolutionState AddDocument(DocumentInfo documentInfo);
    public SolutionState AddAdditionalDocument(DocumentInfo documentInfo);
    public SolutionState RemoveDocument(DocumentId documentId);
    public SolutionState RemoveAdditionalDocument(DocumentId documentId);
    public SolutionState WithDocumentName(DocumentId documentId, string name);
    public SolutionState WithDocumentFolders(DocumentId documentId, IEnumerable`1<string> folders);
    public SolutionState WithDocumentFilePath(DocumentId documentId, string filePath);
    public SolutionState WithDocumentText(DocumentId documentId, SourceText text, PreservationMode mode);
    public SolutionState WithAdditionalDocumentText(DocumentId documentId, SourceText text, PreservationMode mode);
    public SolutionState WithDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode);
    public SolutionState WithAdditionalDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode);
    public SolutionState WithDocumentSyntaxRoot(DocumentId documentId, SyntaxNode root, PreservationMode mode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionState/<UpdateDocumentInCompilationAsync>d__96")]
private static Task`1<Compilation> UpdateDocumentInCompilationAsync(Compilation compilation, DocumentState oldDocument, DocumentState newDocument, CancellationToken cancellationToken);
    public SolutionState WithDocumentSourceCodeKind(DocumentId documentId, SourceCodeKind sourceCodeKind);
    public SolutionState WithDocumentTextLoader(DocumentId documentId, TextLoader loader, SourceText textOpt, PreservationMode mode);
    public SolutionState WithAdditionalDocumentTextLoader(DocumentId documentId, TextLoader loader, PreservationMode mode);
    private SolutionState WithDocumentState(DocumentState newDocument, bool textChanged, bool recalculateDependentVersions);
    private SolutionState TouchDocument(DocumentId documentId, Func`2<ProjectState, ProjectState> touchProject);
    private SolutionState WithTextDocumentState(TextDocumentState newDocument, bool textChanged, bool recalculateDependentVersions);
    private SolutionState ForkProject(ProjectState newProjectState, CompilationTranslationAction translate, ProjectDependencyGraph newDependencyGraph, ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> newLinkedFilesMap, bool forkTracker);
    public ImmutableArray`1<DocumentId> GetDocumentIdsWithFilePath(string filePath);
    private static ProjectDependencyGraph CreateDependencyGraph(IReadOnlyList`1<ProjectId> projectIds, ImmutableDictionary`2<ProjectId, ProjectState> projectStates);
    private ImmutableDictionary`2<ProjectId, CompilationTracker> CreateCompilationTrackerMap(ProjectId projectId, ProjectDependencyGraph dependencyGraph);
    public SolutionState GetIsolatedSolution();
    private NonReentrantLock get_StateLock();
    public SolutionState WithFrozenPartialCompilationIncludingSpecificDocument(DocumentId documentId, CancellationToken cancellationToken);
    public SolutionState WithDocumentText(IEnumerable`1<DocumentId> documentIds, SourceText text, PreservationMode mode);
    public bool TryGetCompilation(ProjectId projectId, Compilation& compilation);
    private Task`1<Compilation> GetCompilationAsync(ProjectId projectId, CancellationToken cancellationToken);
    public Task`1<Compilation> GetCompilationAsync(ProjectState project, CancellationToken cancellationToken);
    public Task`1<bool> HasSuccessfullyLoadedAsync(ProjectState project, CancellationToken cancellationToken);
    private static void RecordSourceOfAssemblySymbol(ISymbol assemblyOrModuleSymbol, ProjectId projectId);
    public Task`1<MetadataReference> GetMetadataReferenceAsync(ProjectReference projectReference, ProjectState fromProject, CancellationToken cancellationToken);
    private MetadataReference GetPartialMetadataReference(ProjectReference projectReference, ProjectState fromProject, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionState/<ContainsSymbolsWithNameAsync>d__124")]
public Task`1<bool> ContainsSymbolsWithNameAsync(ProjectId id, string name, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionState/<ContainsSymbolsWithNameAsync>d__125")]
public Task`1<bool> ContainsSymbolsWithNameAsync(ProjectId id, Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionState/<GetDocumentsWithNameAsync>d__126")]
public Task`1<ImmutableArray`1<DocumentState>> GetDocumentsWithNameAsync(ProjectId id, Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    private ImmutableArray`1<DocumentState> ConvertTreesToDocuments(ProjectId id, IEnumerable`1<SyntaxTree> trees);
    public ProjectDependencyGraph GetProjectDependencyGraph();
    private void CheckNotContainsProject(ProjectId projectId);
    private void CheckContainsProject(ProjectId projectId);
    private void CheckNotContainsProjectReference(ProjectId projectId, ProjectReference referencedProject);
    private void CheckNotContainsTransitiveReference(ProjectId fromProjectId, ProjectId toProjectId);
    private void CheckNotSecondSubmissionReference(ProjectId projectId, ProjectId toProjectId);
    private void CheckNotContainsDocument(DocumentId documentId);
    private void CheckNotContainsAdditionalDocument(DocumentId documentId);
    private void CheckContainsDocument(DocumentId documentId);
    private void CheckContainsAdditionalDocument(DocumentId documentId);
    public bool TryGetStateChecksums(SolutionStateChecksums& stateChecksums);
    public Task`1<SolutionStateChecksums> GetStateChecksumsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionState/<GetChecksumAsync>d__140")]
public Task`1<Checksum> GetChecksumAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionState/<ComputeChecksumsAsync>d__141")]
private Task`1<SolutionStateChecksums> ComputeChecksumsAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private VersionStamp <.ctor>b__14_0();
    [CompilerGeneratedAttribute]
private bool <CheckNotSecondSubmissionReference>b__133_0(ProjectReference p);
}
internal static class Microsoft.CodeAnalysis.StackGuard : object {
    public static int MaxUncheckedRecursionDepth;
    public static void EnsureSufficientExecutionStack(int recursionDepth);
    public static bool IsInsufficientExecutionStackException(Exception ex);
}
internal class Microsoft.CodeAnalysis.SymbolKey : ValueType {
    private static Func`2<ITypeSymbol, bool> s_typeIsNull;
    private string _symbolKeyData;
    private static Func`2<string, string> s_removeAssemblyKeys;
    public SymbolKey(string symbolKeyData);
    private static SymbolKey();
    public static IEqualityComparer`1<SymbolKey> GetComparer(bool ignoreCase, bool ignoreAssemblyKeys);
    public static SymbolKeyResolution Resolve(string symbolKey, Compilation compilation, bool ignoreAssemblyKey, bool resolveLocations, CancellationToken cancellationToken);
    public static SymbolKey Create(ISymbol symbol, CancellationToken cancellationToken);
    public static string ToString(ISymbol symbol, CancellationToken cancellationToken);
    public SymbolKeyResolution Resolve(Compilation compilation, bool ignoreAssemblyKey, bool resolveLocations, CancellationToken cancellationToken);
    public virtual string ToString();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SymbolKey/<GetAllSymbols>d__17")]
private static IEnumerable`1<ISymbol> GetAllSymbols(SymbolKeyResolution info);
    private static IEnumerable`1<TType> GetAllSymbols(SymbolKeyResolution info);
    private static SymbolKeyResolution CreateSymbolInfo(IEnumerable`1<ISymbol> symbols);
    private static SymbolKeyResolution CreateSymbolInfo(ISymbol[] symbols);
    private static bool Equals(Compilation compilation, string name1, string name2);
    private static bool Equals(bool isCaseSensitive, string name1, string name2);
    private static string GetName(string metadataName);
    private static IEnumerable`1<INamedTypeSymbol> InstantiateTypes(Compilation compilation, bool ignoreAssemblyKey, ImmutableArray`1<INamedTypeSymbol> types, int arity, ImmutableArray`1<SymbolKeyResolution> typeArgumentKeys);
    private static TSymbol GetFirstSymbol(SymbolKeyResolution resolution);
    private static bool ParameterRefKindsMatch(ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<RefKind> refKinds);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SymbolKeyExtensions : object {
    [ExtensionAttribute]
public static SymbolKey GetSymbolKey(ISymbol symbol);
}
internal class Microsoft.CodeAnalysis.SymbolKeyResolution : ValueType {
    private ISymbol _symbol;
    private ImmutableArray`1<ISymbol> _candidateSymbols;
    private CandidateReason _candidateReason;
    public ISymbol Symbol { get; }
    public ImmutableArray`1<ISymbol> CandidateSymbols { get; }
    public CandidateReason CandidateReason { get; }
    internal SymbolKeyResolution(ISymbol symbol);
    internal SymbolKeyResolution(ImmutableArray`1<ISymbol> candidateSymbols, CandidateReason candidateReason);
    public ISymbol get_Symbol();
    public ImmutableArray`1<ISymbol> get_CandidateSymbols();
    public CandidateReason get_CandidateReason();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SymbolKeyResolutionExtensions : object {
    [ExtensionAttribute]
internal static ISymbol GetAnySymbol(SymbolKeyResolution resolution);
    [ExtensionAttribute]
internal static IEnumerable`1<ISymbol> GetAllSymbols(SymbolKeyResolution resolution);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SymbolKeyResolutionExtensions/<GetAllSymbolsWorker>d__2")]
private static IEnumerable`1<ISymbol> GetAllSymbolsWorker(SymbolKeyResolution resolution);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchProgressService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SymbolSearch.DefaultSymbolSearchProgressService : object {
    public sealed virtual Task OnDownloadFullDatabaseStartedAsync(string title);
    public sealed virtual Task OnDownloadFullDatabaseSucceededAsync();
    public sealed virtual Task OnDownloadFullDatabaseCanceledAsync();
    public sealed virtual Task OnDownloadFullDatabaseFailedAsync(string message);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SymbolSearch.DefaultSymbolSearchService : object {
    public sealed virtual Task`1<IList`1<PackageWithTypeResult>> FindPackagesWithTypeAsync(string source, string name, int arity, CancellationToken cancellationToken);
    public sealed virtual Task`1<IList`1<PackageWithAssemblyResult>> FindPackagesWithAssemblyAsync(string source, string assemblyName, CancellationToken cancellationToken);
    public sealed virtual Task`1<IList`1<ReferenceAssemblyWithTypeResult>> FindReferenceAssembliesWithTypeAsync(string name, int arity, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.SymbolSearch.IRemoteSymbolSearchUpdateEngine {
    public abstract virtual Task UpdateContinuouslyAsync(string sourceName, string localSettingsDirectory);
    public abstract virtual Task`1<IList`1<PackageWithTypeResult>> FindPackagesWithTypeAsync(string source, string name, int arity, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<PackageWithAssemblyResult>> FindPackagesWithAssemblyAsync(string source, string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<ReferenceAssemblyWithTypeResult>> FindReferenceAssembliesWithTypeAsync(string name, int arity, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchLogService {
    public abstract virtual Task LogExceptionAsync(string exception, string text);
    public abstract virtual Task LogInfoAsync(string text);
}
internal interface Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchProgressService {
    public abstract virtual Task OnDownloadFullDatabaseStartedAsync(string title);
    public abstract virtual Task OnDownloadFullDatabaseSucceededAsync();
    public abstract virtual Task OnDownloadFullDatabaseCanceledAsync();
    public abstract virtual Task OnDownloadFullDatabaseFailedAsync(string message);
}
internal interface Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService {
    public abstract virtual Task`1<IList`1<PackageWithTypeResult>> FindPackagesWithTypeAsync(string source, string name, int arity, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<PackageWithAssemblyResult>> FindPackagesWithAssemblyAsync(string source, string assemblyName, CancellationToken cancellationToken);
    public abstract virtual Task`1<IList`1<ReferenceAssemblyWithTypeResult>> FindReferenceAssembliesWithTypeAsync(string name, int arity, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchUpdateEngine {
    public abstract virtual Task UpdateContinuouslyAsync(string sourceName, string localSettingsDirectory);
    public abstract virtual Task`1<ImmutableArray`1<PackageWithTypeResult>> FindPackagesWithTypeAsync(string source, string name, int arity, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<PackageWithAssemblyResult>> FindPackagesWithAssemblyAsync(string source, string assemblyName, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<ReferenceAssemblyWithTypeResult>> FindReferenceAssembliesWithTypeAsync(string name, int arity, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.SymbolSearch.PackageResult : object {
    public string PackageName;
    internal int Rank;
    protected PackageResult(string packageName, int rank);
}
internal class Microsoft.CodeAnalysis.SymbolSearch.PackageWithAssemblyResult : PackageResult {
    public string Version;
    public PackageWithAssemblyResult(string packageName, string version, int rank);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PackageWithAssemblyResult other);
    public sealed virtual int CompareTo(PackageWithAssemblyResult other);
}
internal class Microsoft.CodeAnalysis.SymbolSearch.PackageWithTypeResult : PackageResult {
    public IList`1<string> ContainingNamespaceNames;
    public string TypeName;
    public string Version;
    public PackageWithTypeResult(string packageName, string typeName, string version, int rank, IList`1<string> containingNamespaceNames);
}
internal class Microsoft.CodeAnalysis.SymbolSearch.ReferenceAssemblyWithTypeResult : object {
    public IList`1<string> ContainingNamespaceNames;
    public string AssemblyName;
    public string TypeName;
    public ReferenceAssemblyWithTypeResult(string assemblyName, string typeName, IList`1<string> containingNamespaceNames);
}
internal static class Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchOptions : object {
    private static string LocalRegistryPath;
    public static Option`1<bool> Enabled;
    public static PerLanguageOption`1<bool> SuggestForTypesInReferenceAssemblies;
    public static PerLanguageOption`1<bool> SuggestForTypesInNuGetPackages;
    private static SymbolSearchOptions();
}
[ExportOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchOptionsProvider : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
internal class Microsoft.CodeAnalysis.SyntacticDocument : object {
    public Document Document;
    public SourceText Text;
    public SyntaxTree SyntaxTree;
    public SyntaxNode Root;
    public Project Project { get; }
    protected SyntacticDocument(Document document, SourceText text, SyntaxTree tree, SyntaxNode root);
    public Project get_Project();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SyntacticDocument/<CreateAsync>d__7")]
public static Task`1<SyntacticDocument> CreateAsync(Document document, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SyntaxTreeExtensions : object {
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
internal static void VerifySource(SyntaxTree tree, IEnumerable`1<TextChangeRange> changes);
    private static int FindFirstDifference(string s1, string s2);
    [ExtensionAttribute]
public static bool IsHiddenPosition(SyntaxTree tree, int position, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Tags.WellKnownTagArrays : object {
    internal static ImmutableArray`1<string> Assembly;
    internal static ImmutableArray`1<string> ClassPublic;
    internal static ImmutableArray`1<string> ClassProtected;
    internal static ImmutableArray`1<string> ClassPrivate;
    internal static ImmutableArray`1<string> ClassInternal;
    internal static ImmutableArray`1<string> ConstantPublic;
    internal static ImmutableArray`1<string> ConstantProtected;
    internal static ImmutableArray`1<string> ConstantPrivate;
    internal static ImmutableArray`1<string> ConstantInternal;
    internal static ImmutableArray`1<string> DelegatePublic;
    internal static ImmutableArray`1<string> DelegateProtected;
    internal static ImmutableArray`1<string> DelegatePrivate;
    internal static ImmutableArray`1<string> DelegateInternal;
    internal static ImmutableArray`1<string> EnumPublic;
    internal static ImmutableArray`1<string> EnumProtected;
    internal static ImmutableArray`1<string> EnumPrivate;
    internal static ImmutableArray`1<string> EnumInternal;
    internal static ImmutableArray`1<string> EnumMemberPublic;
    internal static ImmutableArray`1<string> EnumMemberProtected;
    internal static ImmutableArray`1<string> EnumMemberPrivate;
    internal static ImmutableArray`1<string> EnumMemberInternal;
    internal static ImmutableArray`1<string> EventPublic;
    internal static ImmutableArray`1<string> EventProtected;
    internal static ImmutableArray`1<string> EventPrivate;
    internal static ImmutableArray`1<string> EventInternal;
    internal static ImmutableArray`1<string> ExtensionMethodPublic;
    internal static ImmutableArray`1<string> ExtensionMethodProtected;
    internal static ImmutableArray`1<string> ExtensionMethodPrivate;
    internal static ImmutableArray`1<string> ExtensionMethodInternal;
    internal static ImmutableArray`1<string> FieldPublic;
    internal static ImmutableArray`1<string> FieldProtected;
    internal static ImmutableArray`1<string> FieldPrivate;
    internal static ImmutableArray`1<string> FieldInternal;
    internal static ImmutableArray`1<string> InterfacePublic;
    internal static ImmutableArray`1<string> InterfaceProtected;
    internal static ImmutableArray`1<string> InterfacePrivate;
    internal static ImmutableArray`1<string> InterfaceInternal;
    internal static ImmutableArray`1<string> Intrinsic;
    internal static ImmutableArray`1<string> Keyword;
    internal static ImmutableArray`1<string> Label;
    internal static ImmutableArray`1<string> Local;
    internal static ImmutableArray`1<string> Namespace;
    internal static ImmutableArray`1<string> MethodPublic;
    internal static ImmutableArray`1<string> MethodProtected;
    internal static ImmutableArray`1<string> MethodPrivate;
    internal static ImmutableArray`1<string> MethodInternal;
    internal static ImmutableArray`1<string> ModulePublic;
    internal static ImmutableArray`1<string> ModuleProtected;
    internal static ImmutableArray`1<string> ModulePrivate;
    internal static ImmutableArray`1<string> ModuleInternal;
    internal static ImmutableArray`1<string> Folder;
    internal static ImmutableArray`1<string> Operator;
    internal static ImmutableArray`1<string> Parameter;
    internal static ImmutableArray`1<string> PropertyPublic;
    internal static ImmutableArray`1<string> PropertyProtected;
    internal static ImmutableArray`1<string> PropertyPrivate;
    internal static ImmutableArray`1<string> PropertyInternal;
    internal static ImmutableArray`1<string> RangeVariable;
    internal static ImmutableArray`1<string> Reference;
    internal static ImmutableArray`1<string> StructurePublic;
    internal static ImmutableArray`1<string> StructureProtected;
    internal static ImmutableArray`1<string> StructurePrivate;
    internal static ImmutableArray`1<string> StructureInternal;
    internal static ImmutableArray`1<string> TypeParameter;
    internal static ImmutableArray`1<string> Snippet;
    internal static ImmutableArray`1<string> Error;
    internal static ImmutableArray`1<string> Warning;
    internal static ImmutableArray`1<string> StatusInformation;
    internal static ImmutableArray`1<string> AddReference;
    internal static ImmutableArray`1<string> NuGet;
    internal static ImmutableArray`1<string> CSharpFile;
    internal static ImmutableArray`1<string> VisualBasicFile;
    internal static ImmutableArray`1<string> CSharpProject;
    internal static ImmutableArray`1<string> VisualBasicProject;
    private static WellKnownTagArrays();
}
public static class Microsoft.CodeAnalysis.Tags.WellKnownTags : object {
    public static string Public;
    public static string Protected;
    public static string Private;
    public static string Internal;
    public static string File;
    public static string Project;
    public static string Folder;
    public static string Assembly;
    public static string Class;
    public static string Constant;
    public static string Delegate;
    public static string Enum;
    public static string EnumMember;
    public static string Event;
    public static string ExtensionMethod;
    public static string Field;
    public static string Interface;
    public static string Intrinsic;
    public static string Keyword;
    public static string Label;
    public static string Local;
    public static string Namespace;
    public static string Method;
    public static string Module;
    public static string Operator;
    public static string Parameter;
    public static string Property;
    public static string RangeVariable;
    public static string Reference;
    public static string Structure;
    public static string TypeParameter;
    public static string Snippet;
    public static string Error;
    public static string Warning;
    internal static string StatusInformation;
    internal static string AddReference;
    internal static string NuGet;
}
internal static class Microsoft.CodeAnalysis.Text.EncodedStringText : object {
    private static int LargeObjectHeapLimitInChars;
    private static Encoding s_utf8Encoding;
    private static Lazy`1<Encoding> s_fallbackEncoding;
    private static EncodedStringText();
    private static Encoding GetFallbackEncoding();
    internal static SourceText Create(Stream stream, Encoding defaultEncoding, SourceHashAlgorithm checksumAlgorithm, bool canBeEmbedded);
    internal static SourceText Create(Stream stream, Lazy`1<Encoding> getEncoding, Encoding defaultEncoding, SourceHashAlgorithm checksumAlgorithm, bool canBeEmbedded);
    internal static SourceText Decode(Stream data, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected, bool canBeEmbedded);
    internal static bool TryGetBytesFromStream(Stream data, ArraySegment`1& bytes);
    private static bool TryGetBytesFromFileStream(FileStream stream, ArraySegment`1& bytes);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Text.TextExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Document> GetRelatedDocumentsWithChanges(SourceText text);
    [ExtensionAttribute]
public static Document GetOpenDocumentInCurrentContextWithChanges(SourceText text);
    [ExtensionAttribute]
public static IEnumerable`1<Document> GetRelatedDocuments(SourceTextContainer container);
    [ExtensionAttribute]
public static Document GetOpenDocumentInCurrentContext(SourceTextContainer container);
}
public class Microsoft.CodeAnalysis.TextAndVersion : object {
    [CompilerGeneratedAttribute]
private SourceText <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionStamp <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public SourceText Text { get; }
    public VersionStamp Version { get; }
    public string FilePath { get; }
    private TextAndVersion(SourceText text, VersionStamp version, string filePath);
    [CompilerGeneratedAttribute]
public SourceText get_Text();
    [CompilerGeneratedAttribute]
public VersionStamp get_Version();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    public static TextAndVersion Create(SourceText text, VersionStamp version, string filePath);
}
public class Microsoft.CodeAnalysis.TextDocument : object {
    internal TextDocumentState State;
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    public Project Project { get; protected set; }
    public DocumentId Id { get; }
    public string FilePath { get; }
    public string Name { get; }
    public IReadOnlyList`1<string> Folders { get; }
    internal TextDocument(Project project, TextDocumentState state);
    [CompilerGeneratedAttribute]
public Project get_Project();
    [CompilerGeneratedAttribute]
protected void set_Project(Project value);
    public DocumentId get_Id();
    public string get_FilePath();
    public string get_Name();
    public IReadOnlyList`1<string> get_Folders();
    public bool TryGetText(SourceText& text);
    public bool TryGetTextVersion(VersionStamp& version);
    public Task`1<SourceText> GetTextAsync(CancellationToken cancellationToken);
    internal SourceText GetTextSynchronously(CancellationToken cancellationToken);
    public Task`1<VersionStamp> GetTextVersionAsync(CancellationToken cancellationToken);
    internal VersionStamp GetTextVersionSynchronously(CancellationToken cancellationToken);
    internal Task`1<VersionStamp> GetTopLevelChangeTextVersionAsync(CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.TextDocumentState : object {
    protected SolutionServices solutionServices;
    protected DocumentInfo info;
    protected SourceText sourceTextOpt;
    protected ValueSource`1<TextAndVersion> textAndVersionSource;
    private ValueSource`1<DocumentStateChecksums> _lazyChecksums;
    private static double MaxDelaySecs;
    private static int MaxRetries;
    internal static TimeSpan RetryDelay;
    public DocumentId Id { get; }
    public string FilePath { get; }
    public DocumentInfo Info { get; }
    public IReadOnlyList`1<string> Folders { get; }
    public string Name { get; }
    public ITemporaryTextStorage Storage { get; }
    protected TextDocumentState(SolutionServices solutionServices, DocumentInfo info, SourceText sourceTextOpt, ValueSource`1<TextAndVersion> textAndVersionSource, ValueSource`1<DocumentStateChecksums> lazyChecksums);
    private static TextDocumentState();
    public DocumentId get_Id();
    public string get_FilePath();
    public DocumentInfo get_Info();
    public IReadOnlyList`1<string> get_Folders();
    public string get_Name();
    public static TextDocumentState Create(DocumentInfo info, SolutionServices services);
    protected static ValueSource`1<TextAndVersion> CreateStrongText(TextAndVersion text);
    protected static ValueSource`1<TextAndVersion> CreateStrongText(TextLoader loader, DocumentId documentId, SolutionServices services, bool reportInvalidDataException);
    protected static ValueSource`1<TextAndVersion> CreateRecoverableText(TextAndVersion text, SolutionServices services);
    protected static ValueSource`1<TextAndVersion> CreateRecoverableText(TextLoader loader, DocumentId documentId, SolutionServices services, bool reportInvalidDataException);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentState/<LoadTextAsync>d__24")]
protected static Task`1<TextAndVersion> LoadTextAsync(TextLoader loader, DocumentId documentId, SolutionServices services, bool reportInvalidDataException, CancellationToken cancellationToken);
    protected static TextAndVersion LoadTextSynchronously(TextLoader loader, DocumentId documentId, SolutionServices services, bool reportInvalidDataException, CancellationToken cancellationToken);
    public ITemporaryTextStorage get_Storage();
    public bool TryGetText(SourceText& text);
    public bool TryGetTextVersion(VersionStamp& version);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentState/<GetTextAsync>d__30")]
public Task`1<SourceText> GetTextAsync(CancellationToken cancellationToken);
    public SourceText GetTextSynchronously(CancellationToken cancellationToken);
    public VersionStamp GetTextVersionSynchronously(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentState/<GetTextVersionAsync>d__33")]
public Task`1<VersionStamp> GetTextVersionAsync(CancellationToken cancellationToken);
    public TextDocumentState UpdateText(TextAndVersion newTextAndVersion, PreservationMode mode);
    public TextDocumentState UpdateText(SourceText newText, PreservationMode mode);
    public TextDocumentState UpdateText(TextLoader loader, PreservationMode mode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentState/<GetTextAndVersionAsync>d__37")]
private Task`1<TextAndVersion> GetTextAndVersionAsync(CancellationToken cancellationToken);
    private VersionStamp GetNewerVersion();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentState/<GetTopLevelChangeTextVersionAsync>d__39")]
public virtual Task`1<VersionStamp> GetTopLevelChangeTextVersionAsync(CancellationToken cancellationToken);
    public bool TryGetStateChecksums(DocumentStateChecksums& stateChecksums);
    public Task`1<DocumentStateChecksums> GetStateChecksumsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentState/<GetChecksumAsync>d__42")]
public Task`1<Checksum> GetChecksumAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentState/<ComputeChecksumsAsync>d__43")]
private Task`1<DocumentStateChecksums> ComputeChecksumsAsync(CancellationToken cancellationToken);
}
public abstract class Microsoft.CodeAnalysis.TextLoader : object {
    public abstract virtual Task`1<TextAndVersion> LoadTextAndVersionAsync(Workspace workspace, DocumentId documentId, CancellationToken cancellationToken);
    internal virtual TextAndVersion LoadTextAndVersionSynchronously(Workspace workspace, DocumentId documentId, CancellationToken cancellationToken);
    public static TextLoader From(TextAndVersion textAndVersion);
    public static TextLoader From(SourceTextContainer container, VersionStamp version, string filePath);
}
internal class Microsoft.CodeAnalysis.TreeAndVersion : object {
    [CompilerGeneratedAttribute]
private SyntaxTree <Tree>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionStamp <Version>k__BackingField;
    public SyntaxTree Tree { get; }
    public VersionStamp Version { get; }
    private TreeAndVersion(SyntaxTree tree, VersionStamp version);
    [CompilerGeneratedAttribute]
public SyntaxTree get_Tree();
    [CompilerGeneratedAttribute]
public VersionStamp get_Version();
    public static TreeAndVersion Create(SyntaxTree tree, VersionStamp version);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.ITemporaryStorageService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.TrivialTemporaryStorageService : object {
    public sealed virtual ITemporaryStreamStorage CreateTemporaryStreamStorage(CancellationToken cancellationToken);
    public sealed virtual ITemporaryTextStorage CreateTemporaryTextStorage(CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.UnmergedDocumentChanges : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<TextChange> <UnmergedChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    public IEnumerable`1<TextChange> UnmergedChanges { get; }
    public string ProjectName { get; }
    public DocumentId DocumentId { get; }
    public UnmergedDocumentChanges(IEnumerable`1<TextChange> unmergedChanges, string projectName, DocumentId documentId);
    [CompilerGeneratedAttribute]
public IEnumerable`1<TextChange> get_UnmergedChanges();
    [CompilerGeneratedAttribute]
public string get_ProjectName();
    [CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
}
internal static class Microsoft.CodeAnalysis.Utilities.ForegroundThreadDataInfo : object {
    private static ForegroundThreadDataKind s_fallbackForegroundThreadDataKind;
    private static Nullable`1<ForegroundThreadDataKind> s_currentForegroundThreadDataKind;
    internal static ForegroundThreadDataKind CurrentForegroundThreadDataKind { get; }
    private static ForegroundThreadDataInfo();
    internal static ForegroundThreadDataKind CreateDefault(ForegroundThreadDataKind defaultKind);
    internal static ForegroundThreadDataKind get_CurrentForegroundThreadDataKind();
    internal static void SetCurrentForegroundThreadDataKind(Nullable`1<ForegroundThreadDataKind> kind);
}
internal enum Microsoft.CodeAnalysis.Utilities.ForegroundThreadDataKind : Enum {
    public int value__;
    public static ForegroundThreadDataKind Wpf;
    public static ForegroundThreadDataKind WinForms;
    public static ForegroundThreadDataKind StaUnitTest;
    public static ForegroundThreadDataKind JoinableTask;
    public static ForegroundThreadDataKind ForcedByPackageInitialize;
    public static ForegroundThreadDataKind MonoDevelopGtk;
    public static ForegroundThreadDataKind MonoDevelopXwt;
    public static ForegroundThreadDataKind Unknown;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Utilities.IReadOnlyListExtensions : object {
    [ExtensionAttribute]
public static IReadOnlyList`1<T> ToReadOnlyList(IList`1<T> list);
    [ExtensionAttribute]
public static T Last(IReadOnlyList`1<T> list);
}
internal class Microsoft.CodeAnalysis.Utilities.ParameterName : ValueType {
    public string NameBasedOnArgument;
    public string BestNameForParameter;
    public ParameterName(string nameBasedOnArgument, bool isFixed);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ParameterName other);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Utilities.StringSlice : ValueType {
    private string _underlyingString;
    private TextSpan _span;
    public int Length { get; }
    public char Item { get; }
    public StringSlice(string underlyingString, TextSpan span);
    public StringSlice(string value);
    public int get_Length();
    public char get_Item(int index);
    public Enumerator GetEnumerator();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(StringSlice other);
    internal bool EqualsOrdinal(StringSlice other);
    internal bool EqualsOrdinalIgnoreCase(StringSlice other);
    private static bool EqualsOrdinalIgnoreCase(char thisChar, char otherChar);
    public virtual int GetHashCode();
    internal int GetHashCodeOrdinal();
    internal int GetHashCodeOrdinalIgnoreCase();
    internal int CompareToOrdinal(StringSlice other);
    internal int CompareToOrdinalIgnoreCase(StringSlice other);
}
internal abstract class Microsoft.CodeAnalysis.Utilities.StringSliceComparer : object {
    public static StringSliceComparer Ordinal;
    public static StringSliceComparer OrdinalIgnoreCase;
    private static StringSliceComparer();
    public abstract virtual int Compare(StringSlice x, StringSlice y);
    public abstract virtual bool Equals(StringSlice x, StringSlice y);
    public abstract virtual int GetHashCode(StringSlice obj);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Versions.Extensions : object {
    [ExtensionAttribute]
public static bool CanReusePersistedTextVersion(Document document, VersionStamp textVersion, VersionStamp persistedVersion);
    [ExtensionAttribute]
public static bool CanReusePersistedSyntaxTreeVersion(Document document, VersionStamp syntaxVersion, VersionStamp persistedVersion);
    [ExtensionAttribute]
public static bool CanReusePersistedProjectVersion(Project project, VersionStamp projectVersion, VersionStamp persistedVersion);
    [ExtensionAttribute]
public static bool CanReusePersistedDependentProjectVersion(Project project, VersionStamp dependentProjectVersion, VersionStamp persistedVersion);
}
internal static class Microsoft.CodeAnalysis.Versions.PersistedVersionStampLogger : object {
    private static string Text;
    private static string SyntaxTree;
    private static string Project;
    private static string DependentProject;
    private static LogAggregator s_logAggregator;
    private static PersistedVersionStampLogger();
    public static void LogPersistedTextVersionUsage(bool succeeded);
    public static void LogPersistedSyntaxTreeVersionUsage(bool succeeded);
    public static void LogPersistedProjectVersionUsage(bool succeeded);
    public static void LogPersistedDependentProjectVersionUsage(bool succeeded);
    public static void LogSummary();
}
public class Microsoft.CodeAnalysis.VersionStamp : ValueType {
    private static int GlobalVersionMarker;
    private static int InitialGlobalVersion;
    private static int s_globalVersion;
    private DateTime _utcLastModified;
    private int _localIncrement;
    private int _globalIncrement;
    public static VersionStamp Default { get; }
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    private VersionStamp(DateTime utcLastModified);
    private VersionStamp(DateTime utcLastModified, int localIncrement);
    private VersionStamp(DateTime utcLastModified, int localIncrement, int globalIncrement);
    private static VersionStamp();
    public static VersionStamp get_Default();
    public static VersionStamp Create();
    public static VersionStamp Create(DateTime utcTimeLastModified);
    public VersionStamp GetNewerVersion(VersionStamp version);
    public VersionStamp GetNewerVersion();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(VersionStamp version);
    public static bool op_Equality(VersionStamp left, VersionStamp right);
    public static bool op_Inequality(VersionStamp left, VersionStamp right);
    internal static bool CanReusePersistedVersion(VersionStamp baseVersion, VersionStamp persistedVersion);
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    internal void WriteTo(ObjectWriter writer);
    internal static VersionStamp ReadFrom(ObjectReader reader);
    private static int GetGlobalVersion(VersionStamp version);
    private static int GetNextGlobalVersion();
    internal bool TestOnly_IsNewerThan(VersionStamp version);
}
public abstract class Microsoft.CodeAnalysis.Workspace : object {
    private string _workspaceKind;
    private HostWorkspaceServices _services;
    private BranchId _primaryBranchId;
    private IWorkspaceOptionService _workspaceOptionService;
    private SemaphoreSlim _serializationLock;
    private NonReentrantLock _stateLock;
    private Solution _latestSolution;
    private IWorkspaceTaskScheduler _taskQueue;
    internal static bool TestHookStandaloneProjectsDoNotHoldReferences;
    [CompilerGeneratedAttribute]
private bool <TestHookPartialSolutionsDisabled>k__BackingField;
    private Action`1<string> _testMessageLogger;
    private ThreadLocal`1<bool> _isProjectUnloading;
    private Dictionary`2<ProjectId, ISet`1<DocumentId>> _projectToOpenDocumentsMap;
    private Dictionary`2<SourceTextContainer, DocumentId> _bufferToDocumentInCurrentContextMap;
    private Dictionary`2<SourceTextContainer, OneOrMany`1<DocumentId>> _bufferToAssociatedDocumentsMap;
    private Dictionary`2<DocumentId, TextTracker> _textTrackers;
    private EventMap _eventMap;
    private static string WorkspaceChangeEventName;
    private static string WorkspaceFailedEventName;
    private static string DocumentOpenedEventName;
    private static string DocumentClosedEventName;
    private static string DocumentActiveContextChangedName;
    private static ConditionalWeakTable`2<SourceTextContainer, WorkspaceRegistration> s_bufferToWorkspaceRegistrationMap;
    private static CreateValueCallback<SourceTextContainer, WorkspaceRegistration> s_createRegistration;
    internal bool TestHookPartialSolutionsDisabled { get; internal set; }
    public HostWorkspaceServices Services { get; }
    internal BranchId PrimaryBranchId { get; }
    protected internal bool PartialSemanticsEnabled { get; }
    public string Kind { get; }
    public Solution CurrentSolution { get; }
    public OptionSet Options { get; public set; }
    public bool CanOpenDocuments { get; }
    internal bool CanChangeActiveContextDocument { get; }
    protected Workspace(HostServices host, string workspaceKind);
    private static Workspace();
    [CompilerGeneratedAttribute]
internal bool get_TestHookPartialSolutionsDisabled();
    [CompilerGeneratedAttribute]
internal void set_TestHookPartialSolutionsDisabled(bool value);
    internal void LogTestMessage(string message);
    internal void SetTestLogger(Action`1<string> writeLineMessageLogger);
    public HostWorkspaceServices get_Services();
    internal BranchId get_PrimaryBranchId();
    protected internal virtual bool get_PartialSemanticsEnabled();
    public string get_Kind();
    protected internal Solution CreateSolution(SolutionInfo solutionInfo);
    protected internal Solution CreateSolution(SolutionId id);
    public Solution get_CurrentSolution();
    protected Solution SetCurrentSolution(Solution solution);
    public OptionSet get_Options();
    public void set_Options(OptionSet value);
    protected internal Task ScheduleTask(Action action, string taskName);
    protected internal Task`1<T> ScheduleTask(Func`1<T> func, string taskName);
    protected virtual void OnDocumentTextChanged(Document document);
    protected virtual void OnDocumentClosing(DocumentId documentId);
    protected void ClearSolution();
    protected virtual void ClearSolutionData();
    protected virtual void ClearProjectData(ProjectId projectId);
    protected virtual void ClearDocumentData(DocumentId documentId);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool finalize);
    protected internal void OnSolutionAdded(SolutionInfo solutionInfo);
    protected internal void OnSolutionReloaded(SolutionInfo reloadedSolutionInfo);
    protected internal void OnSolutionRemoved();
    protected internal void OnProjectAdded(ProjectInfo projectInfo);
    private void OnProjectAdded(ProjectInfo projectInfo, bool silent);
    private void OnProjectAdded_NoLock(ProjectInfo projectInfo, bool silent);
    protected internal virtual void OnProjectReloaded(ProjectInfo reloadedProjectInfo);
    protected internal virtual void OnProjectRemoved(ProjectId projectId);
    protected virtual void CheckProjectCanBeRemoved(ProjectId projectId);
    protected internal void OnAssemblyNameChanged(ProjectId projectId, string assemblyName);
    protected internal void OnOutputFilePathChanged(ProjectId projectId, string outputFilePath);
    protected internal void OnOutputRefFilePathChanged(ProjectId projectId, string outputFilePath);
    protected internal void OnProjectNameChanged(ProjectId projectId, string name, string filePath);
    protected internal void OnCompilationOptionsChanged(ProjectId projectId, CompilationOptions options);
    protected internal void OnParseOptionsChanged(ProjectId projectId, ParseOptions options);
    protected internal void OnProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference);
    protected internal void OnProjectReferenceRemoved(ProjectId projectId, ProjectReference projectReference);
    protected internal void OnMetadataReferenceAdded(ProjectId projectId, MetadataReference metadataReference);
    protected internal void OnMetadataReferenceRemoved(ProjectId projectId, MetadataReference metadataReference);
    protected internal void OnAnalyzerReferenceAdded(ProjectId projectId, AnalyzerReference analyzerReference);
    protected internal void OnAnalyzerReferenceRemoved(ProjectId projectId, AnalyzerReference analyzerReference);
    private static ImmutableHashSet`1<string> GetFilePaths(ImmutableArray`1<DocumentInfo> documents);
    protected internal void OnDocumentAdded(DocumentInfo documentInfo);
    private void OnDocumentAdded_NoLock(DocumentInfo documentInfo);
    protected internal void OnDocumentReloaded(DocumentInfo newDocumentInfo);
    protected internal void OnDocumentRemoved(DocumentId documentId);
    private void OnDocumentRemoved_NoLock(DocumentId documentId);
    protected virtual void CheckDocumentCanBeRemoved(DocumentId documentId);
    protected internal void OnDocumentTextLoaderChanged(DocumentId documentId, TextLoader loader);
    protected internal void OnAdditionalDocumentTextLoaderChanged(DocumentId documentId, TextLoader loader);
    internal void OnHasAllInformationChanged(ProjectId projectId, bool hasAllInformation);
    protected internal void OnDocumentInfoChanged(DocumentId documentId, DocumentInfo newInfo);
    protected internal void OnDocumentTextChanged(DocumentId documentId, SourceText newText, PreservationMode mode);
    protected internal void OnAdditionalDocumentTextChanged(DocumentId documentId, SourceText newText, PreservationMode mode);
    private void OnAnyDocumentTextChanged(DocumentId documentId, SourceText newText, PreservationMode mode, Action`1<DocumentId> checkIsInCurrentSolution, Func`3<Solution, DocumentId, ImmutableArray`1<DocumentId>> getRelatedDocuments, Func`5<Solution, DocumentId, SourceText, PreservationMode, Solution> updateSolutionWithText, WorkspaceChangeKind changeKind, bool isCodeDocument);
    protected internal void OnDocumentSourceCodeKindChanged(DocumentId documentId, SourceCodeKind sourceCodeKind);
    protected internal void OnAdditionalDocumentAdded(DocumentInfo documentInfo);
    protected internal void OnAdditionalDocumentRemoved(DocumentId documentId);
    protected void UpdateReferencesAfterAdd();
    private static Solution UpdateReferencesAfterAdd(Solution solution);
    internal virtual bool CanRenameFilesDuringCodeActions(Project project);
    public virtual bool CanApplyChange(ApplyChangesKind feature);
    internal virtual bool CanAddProjectReference(ProjectId referencingProject, ProjectId referencedProject);
    public virtual bool TryApplyChanges(Solution newSolution);
    internal virtual bool TryApplyChanges(Solution newSolution, IProgressTracker progressTracker);
    private void CheckAllowedSolutionChanges(SolutionChanges solutionChanges);
    private void CheckAllowedProjectChanges(ProjectChanges projectChanges);
    protected virtual bool CanApplyParseOptionChange(ParseOptions oldOptions, ParseOptions newOptions, Project project);
    protected virtual void ApplyProjectChanges(ProjectChanges projectChanges);
    private void ApplyChangedDocument(ProjectChanges projectChanges, DocumentId documentId);
    [ConditionalAttribute("DEBUG")]
private void CheckNoChanges(Solution oldSolution, Solution newSolution);
    private ProjectInfo CreateProjectInfo(Project project);
    private DocumentInfo CreateDocumentInfoWithText(TextDocument doc);
    internal DocumentInfo CreateDocumentInfoWithoutText(TextDocument doc);
    protected virtual void ApplyProjectAdded(ProjectInfo project);
    protected virtual void ApplyProjectRemoved(ProjectId projectId);
    protected virtual void ApplyCompilationOptionsChanged(ProjectId projectId, CompilationOptions options);
    protected virtual void ApplyParseOptionsChanged(ProjectId projectId, ParseOptions options);
    protected virtual void ApplyProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference);
    protected virtual void ApplyProjectReferenceRemoved(ProjectId projectId, ProjectReference projectReference);
    protected virtual void ApplyMetadataReferenceAdded(ProjectId projectId, MetadataReference metadataReference);
    protected virtual void ApplyMetadataReferenceRemoved(ProjectId projectId, MetadataReference metadataReference);
    protected virtual void ApplyAnalyzerReferenceAdded(ProjectId projectId, AnalyzerReference analyzerReference);
    protected virtual void ApplyAnalyzerReferenceRemoved(ProjectId projectId, AnalyzerReference analyzerReference);
    protected virtual void ApplyDocumentAdded(DocumentInfo info, SourceText text);
    protected virtual void ApplyDocumentRemoved(DocumentId documentId);
    protected virtual void ApplyDocumentTextChanged(DocumentId id, SourceText text);
    protected virtual void ApplyDocumentInfoChanged(DocumentId id, DocumentInfo info);
    protected virtual void ApplyAdditionalDocumentAdded(DocumentInfo info, SourceText text);
    protected virtual void ApplyAdditionalDocumentRemoved(DocumentId documentId);
    protected virtual void ApplyAdditionalDocumentTextChanged(DocumentId id, SourceText text);
    protected void CheckSolutionIsEmpty();
    protected void CheckProjectIsInCurrentSolution(ProjectId projectId);
    protected void CheckProjectIsNotInCurrentSolution(ProjectId projectId);
    protected void CheckProjectHasProjectReference(ProjectId fromProjectId, ProjectReference projectReference);
    protected void CheckProjectDoesNotHaveProjectReference(ProjectId fromProjectId, ProjectReference projectReference);
    protected void CheckProjectDoesNotHaveTransitiveProjectReference(ProjectId fromProjectId, ProjectId toProjectId);
    protected void CheckProjectHasMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    protected void CheckProjectDoesNotHaveMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    protected void CheckProjectHasAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    protected void CheckProjectDoesNotHaveAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    protected void CheckDocumentIsInCurrentSolution(DocumentId documentId);
    protected void CheckAdditionalDocumentIsInCurrentSolution(DocumentId documentId);
    protected void CheckDocumentIsNotInCurrentSolution(DocumentId documentId);
    protected void CheckAdditionalDocumentIsNotInCurrentSolution(DocumentId documentId);
    protected virtual string GetProjectName(ProjectId projectId);
    protected virtual string GetDocumentName(DocumentId documentId);
    protected virtual string GetAdditionalDocumentName(DocumentId documentId);
    public virtual bool get_CanOpenDocuments();
    internal virtual bool get_CanChangeActiveContextDocument();
    private static void RemoveIfEmpty(IDictionary`2<TKey, ISet`1<TValue>> dictionary, TKey key);
    private void ClearOpenDocuments();
    private void ClearOpenDocuments(ProjectId projectId);
    protected void ClearOpenDocument(DocumentId documentId, bool isSolutionClosing);
    private DocumentId ClearOpenDocument_NoLock(DocumentId documentId);
    public virtual void OpenDocument(DocumentId documentId, bool activate);
    public virtual void CloseDocument(DocumentId documentId);
    public virtual void OpenAdditionalDocument(DocumentId documentId, bool activate);
    public virtual void CloseAdditionalDocument(DocumentId documentId);
    protected void CheckCanOpenDocuments();
    protected void CheckProjectDoesNotContainOpenDocuments(ProjectId projectId);
    private bool ProjectHasOpenDocuments(ProjectId projectId);
    public virtual bool IsDocumentOpen(DocumentId documentId);
    public virtual IEnumerable`1<DocumentId> GetOpenDocumentIds(ProjectId projectId);
    public virtual IEnumerable`1<DocumentId> GetRelatedDocumentIds(SourceTextContainer container);
    private ImmutableArray`1<DocumentId> GetRelatedDocumentIds_NoLock(SourceTextContainer container);
    public virtual DocumentId GetDocumentIdInCurrentContext(SourceTextContainer container);
    internal virtual DocumentId GetDocumentIdInCurrentContext(DocumentId documentId);
    private SourceTextContainer GetOpenDocumentSourceTextContainer_NoLock(DocumentId documentId);
    private DocumentId GetDocumentIdInCurrentContext_NoLock(SourceTextContainer container);
    internal virtual void SetDocumentContext(DocumentId documentId);
    protected void OnDocumentContextUpdated(DocumentId documentId);
    internal void OnDocumentContextUpdated(DocumentId documentId, SourceTextContainer container);
    internal void OnDocumentContextUpdated_NoSerializationLock(DocumentId documentId, SourceTextContainer container);
    protected void CheckDocumentIsClosed(DocumentId documentId);
    protected void CheckDocumentIsOpen(DocumentId documentId);
    private ISet`1<DocumentId> GetProjectOpenDocuments_NoLock(ProjectId project);
    protected internal void OnDocumentOpened(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext);
    private static TextAndVersion GetProperTextAndVersion(SourceText oldText, SourceText newText, VersionStamp version, string filePath);
    private void SignupForTextChanges(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext, Action`4<Workspace, DocumentId, SourceText, PreservationMode> onChangedHandler);
    private void AddToOpenDocumentMap(DocumentId documentId);
    protected internal void OnAdditionalDocumentOpened(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext);
    protected internal void OnDocumentClosed(DocumentId documentId, TextLoader reloader, bool updateActiveContext);
    private DocumentId ForgetAnyOpenDocumentInfo(DocumentId documentId);
    protected internal void OnAdditionalDocumentClosed(DocumentId documentId, TextLoader reloader);
    private void UpdateCurrentContextMapping_NoLock(SourceTextContainer textContainer, DocumentId id, bool isCurrentContext);
    private DocumentId UpdateCurrentContextMapping_NoLock(SourceTextContainer textContainer, DocumentId closedDocumentId);
    private SourceText GetOpenDocumentText(Solution solution, DocumentId documentId);
    protected virtual Solution AdjustReloadedSolution(Solution oldSolution, Solution reloadedSolution);
    protected virtual Project AdjustReloadedProject(Project oldProject, Project reloadedProject);
    internal void OnProjectOptionsChanged(ProjectId projectId);
    public void add_WorkspaceChanged(EventHandler`1<WorkspaceChangeEventArgs> value);
    public void remove_WorkspaceChanged(EventHandler`1<WorkspaceChangeEventArgs> value);
    protected Task RaiseWorkspaceChangedEventAsync(WorkspaceChangeKind kind, Solution oldSolution, Solution newSolution, ProjectId projectId, DocumentId documentId);
    public void add_WorkspaceFailed(EventHandler`1<WorkspaceDiagnosticEventArgs> value);
    public void remove_WorkspaceFailed(EventHandler`1<WorkspaceDiagnosticEventArgs> value);
    protected internal virtual void OnWorkspaceFailed(WorkspaceDiagnostic diagnostic);
    public void add_DocumentOpened(EventHandler`1<DocumentEventArgs> value);
    public void remove_DocumentOpened(EventHandler`1<DocumentEventArgs> value);
    protected Task RaiseDocumentOpenedEventAsync(Document document);
    public void add_DocumentClosed(EventHandler`1<DocumentEventArgs> value);
    public void remove_DocumentClosed(EventHandler`1<DocumentEventArgs> value);
    protected Task RaiseDocumentClosedEventAsync(Document document);
    public void add_DocumentActiveContextChanged(EventHandler`1<DocumentActiveContextChangedEventArgs> value);
    public void remove_DocumentActiveContextChanged(EventHandler`1<DocumentActiveContextChangedEventArgs> value);
    [ObsoleteAttribute("This member is obsolete. Use the RaiseDocumentActiveContextChangedEventAsync(SourceTextContainer, DocumentId, DocumentId) overload instead.", "True")]
protected Task RaiseDocumentActiveContextChangedEventAsync(Document document);
    protected Task RaiseDocumentActiveContextChangedEventAsync(SourceTextContainer sourceTextContainer, DocumentId oldActiveContextDocumentId, DocumentId newActiveContextDocumentId);
    public static bool TryGetWorkspace(SourceTextContainer textContainer, Workspace& workspace);
    protected void RegisterText(SourceTextContainer textContainer);
    protected void UnregisterText(SourceTextContainer textContainer);
    private static WorkspaceRegistration CreateRegistration(SourceTextContainer container);
    public static WorkspaceRegistration GetWorkspaceRegistration(SourceTextContainer textContainer);
    [CompilerGeneratedAttribute]
private void <OnSolutionAdded>b__44_0(ProjectInfo p);
    [CompilerGeneratedAttribute]
private void <OnSolutionReloaded>b__45_0(ProjectInfo pi);
    [CompilerGeneratedAttribute]
private DocumentInfo <CreateProjectInfo>b__95_0(Document d);
    [CompilerGeneratedAttribute]
private DocumentInfo <CreateProjectInfo>b__95_1(TextDocument d);
}
public class Microsoft.CodeAnalysis.WorkspaceChangeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private WorkspaceChangeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private Solution <OldSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private Solution <NewSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectId <ProjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    public WorkspaceChangeKind Kind { get; }
    public Solution OldSolution { get; }
    public Solution NewSolution { get; }
    public ProjectId ProjectId { get; }
    public DocumentId DocumentId { get; }
    public WorkspaceChangeEventArgs(WorkspaceChangeKind kind, Solution oldSolution, Solution newSolution, ProjectId projectId, DocumentId documentId);
    [CompilerGeneratedAttribute]
public WorkspaceChangeKind get_Kind();
    [CompilerGeneratedAttribute]
public Solution get_OldSolution();
    [CompilerGeneratedAttribute]
public Solution get_NewSolution();
    [CompilerGeneratedAttribute]
public ProjectId get_ProjectId();
    [CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
}
public enum Microsoft.CodeAnalysis.WorkspaceChangeKind : Enum {
    public int value__;
    public static WorkspaceChangeKind SolutionChanged;
    public static WorkspaceChangeKind SolutionAdded;
    public static WorkspaceChangeKind SolutionRemoved;
    public static WorkspaceChangeKind SolutionCleared;
    public static WorkspaceChangeKind SolutionReloaded;
    public static WorkspaceChangeKind ProjectAdded;
    public static WorkspaceChangeKind ProjectRemoved;
    public static WorkspaceChangeKind ProjectChanged;
    public static WorkspaceChangeKind ProjectReloaded;
    public static WorkspaceChangeKind DocumentAdded;
    public static WorkspaceChangeKind DocumentRemoved;
    public static WorkspaceChangeKind DocumentReloaded;
    public static WorkspaceChangeKind DocumentChanged;
    public static WorkspaceChangeKind AdditionalDocumentAdded;
    public static WorkspaceChangeKind AdditionalDocumentRemoved;
    public static WorkspaceChangeKind AdditionalDocumentReloaded;
    public static WorkspaceChangeKind AdditionalDocumentChanged;
    public static WorkspaceChangeKind DocumentInfoChanged;
}
public class Microsoft.CodeAnalysis.WorkspaceDiagnostic : object {
    [CompilerGeneratedAttribute]
private WorkspaceDiagnosticKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public WorkspaceDiagnosticKind Kind { get; }
    public string Message { get; }
    public WorkspaceDiagnostic(WorkspaceDiagnosticKind kind, string message);
    [CompilerGeneratedAttribute]
public WorkspaceDiagnosticKind get_Kind();
    [CompilerGeneratedAttribute]
public string get_Message();
    public virtual string ToString();
}
public class Microsoft.CodeAnalysis.WorkspaceDiagnosticEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private WorkspaceDiagnostic <Diagnostic>k__BackingField;
    public WorkspaceDiagnostic Diagnostic { get; }
    public WorkspaceDiagnosticEventArgs(WorkspaceDiagnostic diagnostic);
    [CompilerGeneratedAttribute]
public WorkspaceDiagnostic get_Diagnostic();
}
public enum Microsoft.CodeAnalysis.WorkspaceDiagnosticKind : Enum {
    public int value__;
    public static WorkspaceDiagnosticKind Failure;
    public static WorkspaceDiagnosticKind Warning;
}
public static class Microsoft.CodeAnalysis.WorkspaceKind : object {
    public static string Host;
    public static string Debugger;
    public static string Interactive;
    public static string MetadataAsSource;
    public static string MiscellaneousFiles;
    public static string Preview;
    public static string MSBuild;
    internal static string Test;
    internal static string AnyCodeRoslynWorkspace;
    internal static string RemoteWorkspace;
    internal static string RemoteTemporaryWorkspace;
}
public class Microsoft.CodeAnalysis.WorkspaceRegistration : object {
    private Workspace _registeredWorkspace;
    [CompilerGeneratedAttribute]
private EventHandler WorkspaceChanged;
    public Workspace Workspace { get; }
    public Workspace get_Workspace();
    [CompilerGeneratedAttribute]
public void add_WorkspaceChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_WorkspaceChanged(EventHandler value);
    internal void SetWorkspaceAndRaiseEvents(Workspace workspace);
    internal void SetWorkspace(Workspace workspace);
    internal void RaiseEvents();
}
internal class Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResult : ValueType {
    public bool FromBuild;
    public ProjectId ProjectId;
    public VersionStamp Version;
    public ImmutableHashSet`1<DocumentId> DocumentIds;
    public bool IsEmpty;
    private ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> _syntaxLocals;
    private ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> _semanticLocals;
    private ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> _nonLocals;
    private ImmutableArray`1<DiagnosticData> _others;
    public bool IsAggregatedForm { get; }
    public bool IsDefault { get; }
    public ImmutableHashSet`1<DocumentId> DocumentIdsOrEmpty { get; }
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> SyntaxLocals { get; }
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> SemanticLocals { get; }
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> NonLocals { get; }
    public ImmutableArray`1<DiagnosticData> Others { get; }
    public DiagnosticAnalysisResult(ProjectId projectId, VersionStamp version);
    public DiagnosticAnalysisResult(ProjectId projectId, VersionStamp version, ImmutableHashSet`1<DocumentId> documentIds, bool isEmpty, bool fromBuild);
    public DiagnosticAnalysisResult(ProjectId projectId, VersionStamp version, ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> syntaxLocals, ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> semanticLocals, ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> nonLocals, ImmutableArray`1<DiagnosticData> others, ImmutableHashSet`1<DocumentId> documentIds, bool fromBuild);
    public DiagnosticAnalysisResult(DiagnosticAnalysisResultBuilder builder);
    public bool get_IsAggregatedForm();
    public bool get_IsDefault();
    public ImmutableHashSet`1<DocumentId> get_DocumentIdsOrEmpty();
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> get_SyntaxLocals();
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> get_SemanticLocals();
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> get_NonLocals();
    public ImmutableArray`1<DiagnosticData> get_Others();
    public ImmutableArray`1<DiagnosticData> GetResultOrEmpty(ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> map, DocumentId key);
    public DiagnosticAnalysisResult ToAggregatedForm();
    private T ReturnIfNotDefault(T value);
    private ImmutableHashSet`1<DocumentId> CreateDocumentIds();
}
internal class Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResultBuilder : ValueType {
    public Project Project;
    public VersionStamp Version;
    private HashSet`1<DocumentId> _lazySet;
    private Dictionary`2<DocumentId, List`1<DiagnosticData>> _lazySyntaxLocals;
    private Dictionary`2<DocumentId, List`1<DiagnosticData>> _lazySemanticLocals;
    private Dictionary`2<DocumentId, List`1<DiagnosticData>> _lazyNonLocals;
    private List`1<DiagnosticData> _lazyOthers;
    public ImmutableHashSet`1<DocumentId> DocumentIds { get; }
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> SyntaxLocals { get; }
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> SemanticLocals { get; }
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> NonLocals { get; }
    public ImmutableArray`1<DiagnosticData> Others { get; }
    public DiagnosticAnalysisResultBuilder(Project project, VersionStamp version);
    public ImmutableHashSet`1<DocumentId> get_DocumentIds();
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> get_SyntaxLocals();
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> get_SemanticLocals();
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> get_NonLocals();
    public ImmutableArray`1<DiagnosticData> get_Others();
    public void AddExternalSyntaxDiagnostics(DocumentId documentId, IEnumerable`1<Diagnostic> diagnostics);
    public void AddExternalSemanticDiagnostics(DocumentId documentId, IEnumerable`1<Diagnostic> diagnostics);
    private void AddExternalDiagnostics(Dictionary`2& lazyLocals, DocumentId documentId, IEnumerable`1<Diagnostic> diagnostics);
    public void AddSyntaxDiagnostics(SyntaxTree tree, IEnumerable`1<Diagnostic> diagnostics);
    public void AddSemanticDiagnostics(SyntaxTree tree, IEnumerable`1<Diagnostic> diagnostics);
    public void AddCompilationDiagnostics(IEnumerable`1<Diagnostic> diagnostics);
    private void AddDiagnostics(Dictionary`2& lazyLocals, SyntaxTree tree, IEnumerable`1<Diagnostic> diagnostics);
    private void AddDocumentToSet(Document document);
    private Document GetDocument(Diagnostic diagnostic);
    private DocumentId GetExternalDocumentId(Diagnostic diagnostic);
    private static ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> Convert(Dictionary`2<DocumentId, List`1<DiagnosticData>> map);
}
internal static class Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResultMap : object {
    public static DiagnosticAnalysisResultMap`2<TKey, TValue> Create(ImmutableDictionary`2<TKey, TValue> analysisResult, ImmutableDictionary`2<TKey, AnalyzerTelemetryInfo> telemetryInfo);
    public static DiagnosticAnalysisResultMap`2<TKey, TValue> Create(ImmutableDictionary`2<TKey, TValue> analysisResult, ImmutableDictionary`2<TKey, AnalyzerTelemetryInfo> telemetryInfo, ImmutableDictionary`2<TKey, ImmutableArray`1<DiagnosticData>> exceptions);
}
internal class Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResultMap`2 : ValueType {
    public ImmutableDictionary`2<TKey, TValue> AnalysisResult;
    public ImmutableDictionary`2<TKey, AnalyzerTelemetryInfo> TelemetryInfo;
    public ImmutableDictionary`2<TKey, ImmutableArray`1<DiagnosticData>> Exceptions;
    public DiagnosticAnalysisResultMap`2(ImmutableDictionary`2<TKey, TValue> analysisResult, ImmutableDictionary`2<TKey, AnalyzerTelemetryInfo> telemetryInfo, ImmutableDictionary`2<TKey, ImmutableArray`1<DiagnosticData>> exceptions);
}
internal class Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticDataSerializer : ValueType {
    private static int FormatVersion;
    public VersionStamp AnalyzerVersion;
    public VersionStamp Version;
    public DiagnosticDataSerializer(VersionStamp analyzerVersion, VersionStamp version);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticDataSerializer/<SerializeAsync>d__4")]
public Task`1<bool> SerializeAsync(object documentOrProject, string key, ImmutableArray`1<DiagnosticData> items, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticDataSerializer/<DeserializeAsync>d__5")]
public Task`1<StrongBox`1<ImmutableArray`1<DiagnosticData>>> DeserializeAsync(object documentOrProject, string key, CancellationToken cancellationToken);
    private Task`1<bool> WriteStreamAsync(IPersistentStorage storage, object documentOrProject, string key, Stream stream, CancellationToken cancellationToken);
    public void WriteTo(ObjectWriter writer, ImmutableArray`1<DiagnosticData> items, CancellationToken cancellationToken);
    private static void WriteTo(ObjectWriter writer, IReadOnlyCollection`1<DiagnosticDataLocation> additionalLocations, CancellationToken cancellationToken);
    private static void WriteTo(ObjectWriter writer, DiagnosticDataLocation item, CancellationToken cancellationToken);
    private Task`1<Stream> ReadStreamAsync(IPersistentStorage storage, string key, object documentOrProject, CancellationToken cancellationToken);
    public StrongBox`1<ImmutableArray`1<DiagnosticData>> ReadFrom(ObjectReader reader, object documentOrProject, CancellationToken cancellationToken);
    private StrongBox`1<ImmutableArray`1<DiagnosticData>> ReadFrom(ObjectReader reader, Project project, Document document, CancellationToken cancellationToken);
    private static void ReadFrom(ObjectReader reader, Project project, Document document, List`1<DiagnosticData> list, CancellationToken cancellationToken);
    private static DiagnosticDataLocation ReadLocation(Project project, ObjectReader reader, Document documentOpt);
    private static IReadOnlyCollection`1<DiagnosticDataLocation> ReadAdditionalLocations(Project project, ObjectReader reader);
    private static ImmutableDictionary`2<string, string> GetProperties(ObjectReader reader, int count);
    private static IReadOnlyList`1<string> GetCustomTags(ObjectReader reader, int count);
    private static Solution GetSolution(object documentOrProject);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.CodeAnalysis.WorkspacesResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string _0_encountered_an_error_and_has_been_disabled { get; }
    internal static string _0_is_already_part_of_the_workspace { get; }
    internal static string _0_is_already_present { get; }
    internal static string _0_is_already_referenced { get; }
    internal static string _0_is_not_open { get; }
    internal static string _0_is_not_part_of_the_workspace { get; }
    internal static string _0_is_not_present { get; }
    internal static string _0_is_not_referenced { get; }
    internal static string _0_is_still_open { get; }
    internal static string _0_must_be_a_non_null_and_non_empty_string { get; }
    internal static string _0_returned_an_uninitialized_ImmutableArray { get; }
    internal static string _0_still_contains_open_documents { get; }
    internal static string A_language_name_cannot_be_specified_for_this_option { get; }
    internal static string A_language_name_must_be_specified_for_this_option { get; }
    internal static string Absolute_path_expected { get; }
    internal static string Abstract_Method { get; }
    internal static string Add_braces_to_0_statement { get; }
    internal static string Added_colon { get; }
    internal static string Adding_additional_documents_is_not_supported { get; }
    internal static string Adding_analyzer_references_is_not_supported { get; }
    internal static string Adding_documents_is_not_supported { get; }
    internal static string Adding_metadata_references_is_not_supported { get; }
    internal static string Adding_project_reference_from_0_to_1_will_cause_a_circular_reference { get; }
    internal static string Adding_project_references_is_not_supported { get; }
    internal static string Adding_projects_is_not_supported { get; }
    internal static string After_colon { get; }
    internal static string An_element_with_the_same_key_but_a_different_value_already_exists { get; }
    internal static string An_error_occurred_while_reading_the_specified_configuration_file_colon_0 { get; }
    internal static string Arrays_with_more_than_one_dimension_cannot_be_serialized { get; }
    internal static string Async_Method { get; }
    internal static string At_least_one_diagnostic_must_be_supplied { get; }
    internal static string Before_colon { get; }
    internal static string Begins_with_I { get; }
    internal static string Can_t_resolve_analyzer_reference_colon_0 { get; }
    internal static string Can_t_resolve_metadata_reference_colon_0 { get; }
    internal static string Cannot_deserialize_type_0 { get; }
    internal static string Cannot_generate_code_for_unsupported_operator_0 { get; }
    internal static string Cannot_open_project_0_because_the_file_extension_1_is_not_associated_with_a_language { get; }
    internal static string Cannot_open_project_0_because_the_language_1_is_not_supported { get; }
    internal static string Cannot_serialize_type_0 { get; }
    internal static string Cast_is_redundant { get; }
    internal static string Changing_additional_documents_is_not_supported { get; }
    internal static string Changing_compilation_options_is_not_supported { get; }
    internal static string Changing_document_property_is_not_supported { get; }
    internal static string Changing_documents_is_not_supported { get; }
    internal static string Changing_parse_options_is_not_supported { get; }
    internal static string Changing_project_properties_is_not_supported { get; }
    internal static string Class { get; }
    internal static string Could_not_find_location_to_generation_symbol_into { get; }
    internal static string Cycle_detected_in_extensions { get; }
    internal static string Delegate { get; }
    internal static string Deserialization_reader_for_0_read_incorrect_number_of_values { get; }
    internal static string Destination_location_was_from_a_different_tree { get; }
    internal static string Destination_location_was_not_in_source { get; }
    internal static string Destination_type_must_be_a_0_1_or_2_but_given_one_is_3 { get; }
    internal static string Destination_type_must_be_a_0_but_given_one_is_1 { get; }
    internal static string Destination_type_must_be_a_0_or_a_1_but_given_one_is_2 { get; }
    internal static string Diagnostic_must_have_span_0 { get; }
    internal static string Documentation_comment_id_must_start_with_E_F_M_N_P_or_T { get; }
    internal static string Duplicate_source_file_0_in_project_1 { get; }
    internal static string Enable { get; }
    internal static string Enable_and_ignore_future_errors { get; }
    internal static string Enum { get; }
    internal static string Error { get; }
    internal static string Event { get; }
    internal static string Exceptions_colon { get; }
    internal static string Expected_0 { get; }
    internal static string Expected_0_line { get; }
    internal static string Expected_end_of_file { get; }
    internal static string Expected_header_colon_0 { get; }
    internal static string Failure { get; }
    internal static string File_0_size_of_1_exceeds_maximum_allowed_size_of_2 { get; }
    internal static string File_was_externally_modified_colon_0 { get; }
    internal static string Fix_all_0 { get; }
    internal static string Fix_all_0_in_1 { get; }
    internal static string Fix_all_0_in_Solution { get; }
    internal static string Interface { get; }
    internal static string Invalid_CodePage_value_colon_0 { get; }
    internal static string Invalid_number_of_parameters_for_binary_operator { get; }
    internal static string Invalid_number_of_parameters_for_unary_operator { get; }
    internal static string Invalid_project_block_expected_after_Project { get; }
    internal static string Invalid_project_block_expected_after_project_name { get; }
    internal static string Invalid_project_block_expected_after_project_path { get; }
    internal static string Invalid_project_file_path_colon_0 { get; }
    internal static string Invalid_solution_file_path_colon_0 { get; }
    internal static string Label_for_node_0_is_invalid_it_must_be_within_bracket_0_1 { get; }
    internal static string Location_must_be_null_or_from_source { get; }
    internal static string Matching_nodes_0_and_1_must_have_the_same_label { get; }
    internal static string Member_access_should_be_qualified { get; }
    internal static string Metadata_is_already_referenced { get; }
    internal static string Metadata_is_not_referenced { get; }
    internal static string Method { get; }
    internal static string Missing_prefix_colon_0 { get; }
    internal static string Missing_suffix_colon_0 { get; }
    internal static string Name_can_be_simplified { get; }
    internal static string No_location_provided_to_add_statements_to { get; }
    internal static string Node_0_must_be_contained_in_the_new_tree { get; }
    internal static string Node_0_must_be_contained_in_the_old_tree { get; }
    internal static string Node_is_of_the_wrong_type { get; }
    internal static string Non_Field_Members { get; }
    internal static string None { get; }
    internal static string Options_did_not_come_from_Workspace { get; }
    internal static string Pascal_Case { get; }
    internal static string Populate_switch { get; }
    internal static string Private_Method { get; }
    internal static string Private_or_Internal_Field { get; }
    internal static string Private_or_Internal_Static_Field { get; }
    internal static string Project_file_not_found_colon_0 { get; }
    internal static string Property { get; }
    internal static string Public_or_Protected_Field { get; }
    internal static string Refactoring_Only { get; }
    internal static string Removed_colon { get; }
    internal static string Removing_additional_documents_is_not_supported { get; }
    internal static string Removing_analyzer_references_is_not_supported { get; }
    internal static string Removing_documents_is_not_supported { get; }
    internal static string Removing_metadata_references_is_not_supported { get; }
    internal static string Removing_project_references_is_not_supported { get; }
    internal static string Removing_projects_is_not_supported { get; }
    internal static string Service_of_type_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_workspace { get; }
    internal static string Show_Stack_Trace { get; }
    internal static string Solution_file_not_found_colon_0 { get; }
    internal static string Specified_path_must_be_absolute { get; }
    internal static string Static_Field { get; }
    internal static string Static_Method { get; }
    internal static string Stream_is_too_long { get; }
    internal static string Struct { get; }
    internal static string Suggestion { get; }
    internal static string Supplied_diagnostic_cannot_be_null { get; }
    internal static string Symbol_0_is_not_from_source { get; }
    internal static string Temporary_storage_cannot_be_written_more_than_once { get; }
    internal static string The_first_word_0_must_begin_with_a_lower_case_character { get; }
    internal static string The_first_word_0_must_begin_with_an_upper_case_character { get; }
    internal static string The_language_0_is_not_supported { get; }
    internal static string The_member_0_is_not_declared_within_the_declaration_of_the_symbol { get; }
    internal static string The_node_is_not_part_of_the_tree { get; }
    internal static string The_position_is_not_within_the_symbol_s_declaration { get; }
    internal static string The_project_already_references_the_target_project { get; }
    internal static string The_project_already_transitively_references_the_target_project { get; }
    internal static string The_solution_already_contains_the_specified_document { get; }
    internal static string The_solution_already_contains_the_specified_project { get; }
    internal static string The_solution_does_not_contain_the_specified_document { get; }
    internal static string The_solution_does_not_contain_the_specified_project { get; }
    internal static string The_specified_document_is_not_a_version_of_this_document { get; }
    internal static string The_symbol_0_cannot_be_located_within_the_current_solution { get; }
    internal static string The_type_0_is_not_understood_by_the_serialization_binder { get; }
    internal static string These_non_leading_words_must_begin_with_a_lowercase_letter_colon_0 { get; }
    internal static string These_non_leading_words_must_begin_with_an_upper_case_letter_colon_0 { get; }
    internal static string These_words_cannot_contain_lower_case_characters_colon_0 { get; }
    internal static string These_words_cannot_contain_upper_case_characters_colon_0 { get; }
    internal static string These_words_must_begin_with_upper_case_characters_colon_0 { get; }
    internal static string This_submission_already_references_another_submission_project { get; }
    internal static string This_workspace_does_not_support_opening_and_closing_documents { get; }
    internal static string Types { get; }
    internal static string Unknown_identifier { get; }
    internal static string Unmerged_change_from_project_0 { get; }
    internal static string Unrecognized_language_name { get; }
    internal static string Usage_colon { get; }
    internal static string Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer { get; }
    internal static string Variables_captured_colon { get; }
    internal static string Warning { get; }
    internal static string Workspace_is_not_empty { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get__0_encountered_an_error_and_has_been_disabled();
    internal static string get__0_is_already_part_of_the_workspace();
    internal static string get__0_is_already_present();
    internal static string get__0_is_already_referenced();
    internal static string get__0_is_not_open();
    internal static string get__0_is_not_part_of_the_workspace();
    internal static string get__0_is_not_present();
    internal static string get__0_is_not_referenced();
    internal static string get__0_is_still_open();
    internal static string get__0_must_be_a_non_null_and_non_empty_string();
    internal static string get__0_returned_an_uninitialized_ImmutableArray();
    internal static string get__0_still_contains_open_documents();
    internal static string get_A_language_name_cannot_be_specified_for_this_option();
    internal static string get_A_language_name_must_be_specified_for_this_option();
    internal static string get_Absolute_path_expected();
    internal static string get_Abstract_Method();
    internal static string get_Add_braces_to_0_statement();
    internal static string get_Added_colon();
    internal static string get_Adding_additional_documents_is_not_supported();
    internal static string get_Adding_analyzer_references_is_not_supported();
    internal static string get_Adding_documents_is_not_supported();
    internal static string get_Adding_metadata_references_is_not_supported();
    internal static string get_Adding_project_reference_from_0_to_1_will_cause_a_circular_reference();
    internal static string get_Adding_project_references_is_not_supported();
    internal static string get_Adding_projects_is_not_supported();
    internal static string get_After_colon();
    internal static string get_An_element_with_the_same_key_but_a_different_value_already_exists();
    internal static string get_An_error_occurred_while_reading_the_specified_configuration_file_colon_0();
    internal static string get_Arrays_with_more_than_one_dimension_cannot_be_serialized();
    internal static string get_Async_Method();
    internal static string get_At_least_one_diagnostic_must_be_supplied();
    internal static string get_Before_colon();
    internal static string get_Begins_with_I();
    internal static string get_Can_t_resolve_analyzer_reference_colon_0();
    internal static string get_Can_t_resolve_metadata_reference_colon_0();
    internal static string get_Cannot_deserialize_type_0();
    internal static string get_Cannot_generate_code_for_unsupported_operator_0();
    internal static string get_Cannot_open_project_0_because_the_file_extension_1_is_not_associated_with_a_language();
    internal static string get_Cannot_open_project_0_because_the_language_1_is_not_supported();
    internal static string get_Cannot_serialize_type_0();
    internal static string get_Cast_is_redundant();
    internal static string get_Changing_additional_documents_is_not_supported();
    internal static string get_Changing_compilation_options_is_not_supported();
    internal static string get_Changing_document_property_is_not_supported();
    internal static string get_Changing_documents_is_not_supported();
    internal static string get_Changing_parse_options_is_not_supported();
    internal static string get_Changing_project_properties_is_not_supported();
    internal static string get_Class();
    internal static string get_Could_not_find_location_to_generation_symbol_into();
    internal static string get_Cycle_detected_in_extensions();
    internal static string get_Delegate();
    internal static string get_Deserialization_reader_for_0_read_incorrect_number_of_values();
    internal static string get_Destination_location_was_from_a_different_tree();
    internal static string get_Destination_location_was_not_in_source();
    internal static string get_Destination_type_must_be_a_0_1_or_2_but_given_one_is_3();
    internal static string get_Destination_type_must_be_a_0_but_given_one_is_1();
    internal static string get_Destination_type_must_be_a_0_or_a_1_but_given_one_is_2();
    internal static string get_Diagnostic_must_have_span_0();
    internal static string get_Documentation_comment_id_must_start_with_E_F_M_N_P_or_T();
    internal static string get_Duplicate_source_file_0_in_project_1();
    internal static string get_Enable();
    internal static string get_Enable_and_ignore_future_errors();
    internal static string get_Enum();
    internal static string get_Error();
    internal static string get_Event();
    internal static string get_Exceptions_colon();
    internal static string get_Expected_0();
    internal static string get_Expected_0_line();
    internal static string get_Expected_end_of_file();
    internal static string get_Expected_header_colon_0();
    internal static string get_Failure();
    internal static string get_File_0_size_of_1_exceeds_maximum_allowed_size_of_2();
    internal static string get_File_was_externally_modified_colon_0();
    internal static string get_Fix_all_0();
    internal static string get_Fix_all_0_in_1();
    internal static string get_Fix_all_0_in_Solution();
    internal static string get_Interface();
    internal static string get_Invalid_CodePage_value_colon_0();
    internal static string get_Invalid_number_of_parameters_for_binary_operator();
    internal static string get_Invalid_number_of_parameters_for_unary_operator();
    internal static string get_Invalid_project_block_expected_after_Project();
    internal static string get_Invalid_project_block_expected_after_project_name();
    internal static string get_Invalid_project_block_expected_after_project_path();
    internal static string get_Invalid_project_file_path_colon_0();
    internal static string get_Invalid_solution_file_path_colon_0();
    internal static string get_Label_for_node_0_is_invalid_it_must_be_within_bracket_0_1();
    internal static string get_Location_must_be_null_or_from_source();
    internal static string get_Matching_nodes_0_and_1_must_have_the_same_label();
    internal static string get_Member_access_should_be_qualified();
    internal static string get_Metadata_is_already_referenced();
    internal static string get_Metadata_is_not_referenced();
    internal static string get_Method();
    internal static string get_Missing_prefix_colon_0();
    internal static string get_Missing_suffix_colon_0();
    internal static string get_Name_can_be_simplified();
    internal static string get_No_location_provided_to_add_statements_to();
    internal static string get_Node_0_must_be_contained_in_the_new_tree();
    internal static string get_Node_0_must_be_contained_in_the_old_tree();
    internal static string get_Node_is_of_the_wrong_type();
    internal static string get_Non_Field_Members();
    internal static string get_None();
    internal static string get_Options_did_not_come_from_Workspace();
    internal static string get_Pascal_Case();
    internal static string get_Populate_switch();
    internal static string get_Private_Method();
    internal static string get_Private_or_Internal_Field();
    internal static string get_Private_or_Internal_Static_Field();
    internal static string get_Project_file_not_found_colon_0();
    internal static string get_Property();
    internal static string get_Public_or_Protected_Field();
    internal static string get_Refactoring_Only();
    internal static string get_Removed_colon();
    internal static string get_Removing_additional_documents_is_not_supported();
    internal static string get_Removing_analyzer_references_is_not_supported();
    internal static string get_Removing_documents_is_not_supported();
    internal static string get_Removing_metadata_references_is_not_supported();
    internal static string get_Removing_project_references_is_not_supported();
    internal static string get_Removing_projects_is_not_supported();
    internal static string get_Service_of_type_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_workspace();
    internal static string get_Show_Stack_Trace();
    internal static string get_Solution_file_not_found_colon_0();
    internal static string get_Specified_path_must_be_absolute();
    internal static string get_Static_Field();
    internal static string get_Static_Method();
    internal static string get_Stream_is_too_long();
    internal static string get_Struct();
    internal static string get_Suggestion();
    internal static string get_Supplied_diagnostic_cannot_be_null();
    internal static string get_Symbol_0_is_not_from_source();
    internal static string get_Temporary_storage_cannot_be_written_more_than_once();
    internal static string get_The_first_word_0_must_begin_with_a_lower_case_character();
    internal static string get_The_first_word_0_must_begin_with_an_upper_case_character();
    internal static string get_The_language_0_is_not_supported();
    internal static string get_The_member_0_is_not_declared_within_the_declaration_of_the_symbol();
    internal static string get_The_node_is_not_part_of_the_tree();
    internal static string get_The_position_is_not_within_the_symbol_s_declaration();
    internal static string get_The_project_already_references_the_target_project();
    internal static string get_The_project_already_transitively_references_the_target_project();
    internal static string get_The_solution_already_contains_the_specified_document();
    internal static string get_The_solution_already_contains_the_specified_project();
    internal static string get_The_solution_does_not_contain_the_specified_document();
    internal static string get_The_solution_does_not_contain_the_specified_project();
    internal static string get_The_specified_document_is_not_a_version_of_this_document();
    internal static string get_The_symbol_0_cannot_be_located_within_the_current_solution();
    internal static string get_The_type_0_is_not_understood_by_the_serialization_binder();
    internal static string get_These_non_leading_words_must_begin_with_a_lowercase_letter_colon_0();
    internal static string get_These_non_leading_words_must_begin_with_an_upper_case_letter_colon_0();
    internal static string get_These_words_cannot_contain_lower_case_characters_colon_0();
    internal static string get_These_words_cannot_contain_upper_case_characters_colon_0();
    internal static string get_These_words_must_begin_with_upper_case_characters_colon_0();
    internal static string get_This_submission_already_references_another_submission_project();
    internal static string get_This_workspace_does_not_support_opening_and_closing_documents();
    internal static string get_Types();
    internal static string get_Unknown_identifier();
    internal static string get_Unmerged_change_from_project_0();
    internal static string get_Unrecognized_language_name();
    internal static string get_Usage_colon();
    internal static string get_Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer();
    internal static string get_Variables_captured_colon();
    internal static string get_Warning();
    internal static string get_Workspace_is_not_empty();
}
public abstract class Microsoft.CodeAnalysis.XmlDocumentationProvider : DocumentationProvider {
    private NonReentrantLock _gate;
    private Dictionary`2<string, string> _docComments;
    private static XmlReaderSettings s_xmlSettings;
    private static XmlDocumentationProvider();
    protected abstract virtual Stream GetSourceStream(CancellationToken cancellationToken);
    public static XmlDocumentationProvider CreateFromBytes(Byte[] xmlDocCommentBytes);
    public static XmlDocumentationProvider CreateFromFile(string xmlDocCommentFilePath);
    private XDocument GetXDocument(CancellationToken cancellationToken);
    protected virtual string GetDocumentationForSymbol(string documentationMemberID, CultureInfo preferredCulture, CancellationToken cancellationToken);
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("Roslyn.Collections.Immutable.ImmutableHashMap`2/DebuggerProxy")]
internal class Roslyn.Collections.Immutable.ImmutableHashMap`2 : object {
    private static ImmutableHashMap`2<TKey, TValue> s_emptySingleton;
    private Bucket<TKey, TValue> _root;
    private IEqualityComparer`1<TKey> _keyComparer;
    private IEqualityComparer`1<TValue> _valueComparer;
    public static ImmutableHashMap`2<TKey, TValue> Empty { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public TValue Item { get; }
    private ImmutableHashMap`2(Bucket<TKey, TValue> root, IEqualityComparer`1<TKey> comparer, IEqualityComparer`1<TValue> valueComparer);
    internal ImmutableHashMap`2(IEqualityComparer`1<TKey> comparer, IEqualityComparer`1<TValue> valueComparer);
    private static ImmutableHashMap`2();
    public static ImmutableHashMap`2<TKey, TValue> get_Empty();
    public ImmutableHashMap`2<TKey, TValue> Clear();
    public ImmutableHashMap`2<TKey, TValue> Add(TKey key, TValue value);
    public ImmutableHashMap`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    public ImmutableHashMap`2<TKey, TValue> SetItem(TKey key, TValue value);
    public ImmutableHashMap`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public ImmutableHashMap`2<TKey, TValue> Remove(TKey key);
    public ImmutableHashMap`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public ImmutableHashMap`2<TKey, TValue> WithComparers(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public ImmutableHashMap`2<TKey, TValue> WithComparers(IEqualityComparer`1<TKey> keyComparer);
    public bool ContainsValue(TValue value);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    [IteratorStateMachineAttribute("Roslyn.Collections.Immutable.ImmutableHashMap`2/<get_Keys>d__23")]
public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    internal bool TryExchangeKey(TKey key, TKey& existingKey);
    private static bool TryCastToImmutableMap(IEnumerable`1<KeyValuePair`2<TKey, TValue>> sequence, ImmutableHashMap`2& other);
    private ImmutableHashMap`2<TKey, TValue> Wrap(Bucket<TKey, TValue> root);
    private ImmutableHashMap`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs, bool overwriteOnCollision, bool avoidToHashMap);
    [IteratorStateMachineAttribute("Roslyn.Collections.Immutable.ImmutableHashMap`2/<GetValueBuckets>d__39")]
private IEnumerable`1<ValueBucket<TKey, TValue>> GetValueBuckets();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Clear();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItem(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.RemoveRange(IEnumerable`1<TKey> keys);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Remove(TKey key);
}
internal class Roslyn.Utilities.AnnotationTable`1 : object {
    private int _globalId;
    private Dictionary`2<TAnnotation, SyntaxAnnotation> _realAnnotationMap;
    private Dictionary`2<string, TAnnotation> _annotationMap;
    private string _annotationKind;
    public AnnotationTable`1(string annotationKind);
    [IteratorStateMachineAttribute("Roslyn.Utilities.AnnotationTable`1/<GetOrCreateRealAnnotations>d__5")]
private IEnumerable`1<SyntaxAnnotation> GetOrCreateRealAnnotations(TAnnotation[] annotations);
    private SyntaxAnnotation GetOrCreateRealAnnotation(TAnnotation annotation);
    [IteratorStateMachineAttribute("Roslyn.Utilities.AnnotationTable`1/<GetRealAnnotations>d__7")]
private IEnumerable`1<SyntaxAnnotation> GetRealAnnotations(TAnnotation[] annotations);
    private SyntaxAnnotation GetRealAnnotation(TAnnotation annotation);
    public TSyntaxNode WithAdditionalAnnotations(TSyntaxNode node, TAnnotation[] annotations);
    public SyntaxToken WithAdditionalAnnotations(SyntaxToken token, TAnnotation[] annotations);
    public SyntaxTrivia WithAdditionalAnnotations(SyntaxTrivia trivia, TAnnotation[] annotations);
    public SyntaxNodeOrToken WithAdditionalAnnotations(SyntaxNodeOrToken nodeOrToken, TAnnotation[] annotations);
    public TSyntaxNode WithoutAnnotations(TSyntaxNode node, TAnnotation[] annotations);
    public SyntaxToken WithoutAnnotations(SyntaxToken token, TAnnotation[] annotations);
    public SyntaxTrivia WithoutAnnotations(SyntaxTrivia trivia, TAnnotation[] annotations);
    public SyntaxNodeOrToken WithoutAnnotations(SyntaxNodeOrToken nodeOrToken, TAnnotation[] annotations);
    [IteratorStateMachineAttribute("Roslyn.Utilities.AnnotationTable`1/<GetAnnotations>d__17")]
private IEnumerable`1<TAnnotation> GetAnnotations(IEnumerable`1<SyntaxAnnotation> realAnnotations);
    public IEnumerable`1<TAnnotation> GetAnnotations(SyntaxNode node);
    public IEnumerable`1<TAnnotation> GetAnnotations(SyntaxToken token);
    public IEnumerable`1<TAnnotation> GetAnnotations(SyntaxTrivia trivia);
    public IEnumerable`1<TAnnotation> GetAnnotations(SyntaxNodeOrToken nodeOrToken);
    public IEnumerable`1<TSpecificAnnotation> GetAnnotations(SyntaxNode node);
    public IEnumerable`1<TSpecificAnnotation> GetAnnotations(SyntaxToken token);
    public IEnumerable`1<TSpecificAnnotation> GetAnnotations(SyntaxTrivia trivia);
    public IEnumerable`1<TSpecificAnnotation> GetAnnotations(SyntaxNodeOrToken nodeOrToken);
    public bool HasAnnotations(SyntaxNode node);
    public bool HasAnnotations(SyntaxToken token);
    public bool HasAnnotations(SyntaxTrivia trivia);
    public bool HasAnnotations(SyntaxNodeOrToken nodeOrToken);
    public bool HasAnnotations(SyntaxNode node);
    public bool HasAnnotations(SyntaxToken token);
    public bool HasAnnotations(SyntaxTrivia trivia);
    public bool HasAnnotations(SyntaxNodeOrToken nodeOrToken);
    public bool HasAnnotation(SyntaxNode node, TAnnotation annotation);
    public bool HasAnnotation(SyntaxToken token, TAnnotation annotation);
    public bool HasAnnotation(SyntaxTrivia trivia, TAnnotation annotation);
    public bool HasAnnotation(SyntaxNodeOrToken nodeOrToken, TAnnotation annotation);
    public IEnumerable`1<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(SyntaxNode node);
    public IEnumerable`1<SyntaxNode> GetAnnotatedNodes(SyntaxNode node);
    public IEnumerable`1<SyntaxToken> GetAnnotatedTokens(SyntaxNode node);
    public IEnumerable`1<SyntaxTrivia> GetAnnotatedTrivia(SyntaxNode node);
    public IEnumerable`1<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(SyntaxNode node);
    public IEnumerable`1<SyntaxNode> GetAnnotatedNodes(SyntaxNode node);
    public IEnumerable`1<SyntaxToken> GetAnnotatedTokens(SyntaxNode node);
    public IEnumerable`1<SyntaxTrivia> GetAnnotatedTrivia(SyntaxNode node);
    [CompilerGeneratedAttribute]
private bool <GetAnnotatedNodesAndTokens>b__42_0(SyntaxNodeOrToken nt);
    [CompilerGeneratedAttribute]
private bool <GetAnnotatedNodes>b__43_0(SyntaxNodeOrToken nt);
    [CompilerGeneratedAttribute]
private bool <GetAnnotatedTokens>b__44_0(SyntaxNodeOrToken nt);
    [CompilerGeneratedAttribute]
private bool <GetAnnotatedTrivia>b__45_0(SyntaxTrivia tr);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ArrayExtensions : object {
    [ExtensionAttribute]
internal static T[] Copy(T[] array, int start, int length);
    [ExtensionAttribute]
internal static bool ValueEquals(UInt32[] array, UInt32[] other);
    [ExtensionAttribute]
internal static T[] InsertAt(T[] array, int position, T item);
    [ExtensionAttribute]
internal static T[] Append(T[] array, T item);
    [ExtensionAttribute]
internal static T[] InsertAt(T[] array, int position, T[] items);
    [ExtensionAttribute]
internal static T[] Append(T[] array, T[] items);
    [ExtensionAttribute]
internal static T[] RemoveAt(T[] array, int position);
    [ExtensionAttribute]
internal static T[] RemoveAt(T[] array, int position, int length);
    [ExtensionAttribute]
internal static T[] ReplaceAt(T[] array, int position, T item);
    [ExtensionAttribute]
internal static T[] ReplaceAt(T[] array, int position, int length, T[] items);
    [ExtensionAttribute]
internal static void ReverseContents(T[] array);
    [ExtensionAttribute]
internal static void ReverseContents(T[] array, int start, int count);
    [ExtensionAttribute]
internal static int BinarySearch(Int32[] array, int value);
    [ExtensionAttribute]
internal static int BinarySearchUpperBound(Int32[] array, int value);
}
internal static class Roslyn.Utilities.ArrayPool`1 : object {
    private static int MaxPooledArraySize;
    private static SimplePool`1<T[]> s_pool;
    private static ArrayPool`1();
    public static T[] GetArray(int size);
    public static void ReleaseArray(T[] array);
}
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.ArraySlice`1 : ValueType {
    private T[] _array;
    private int _start;
    private int _length;
    public int Length { get; }
    public T Item { get; }
    public ArraySlice`1(T[] array);
    public ArraySlice`1(T[] array, TextSpan span);
    public ArraySlice`1(T[] array, int start, int length);
    public int get_Length();
    public T get_Item(int i);
    private void SetStartAndLength(int start, int length);
    private void CheckLength(int start, int length);
    public void MoveStartForward(int amount);
    public void SetLength(int length);
}
internal class Roslyn.Utilities.AsyncLazy`1 : ValueSource`1<T> {
    private Func`2<CancellationToken, Task`1<T>> _asynchronousComputeFunction;
    private Func`2<CancellationToken, T> _synchronousComputeFunction;
    private bool _cacheResult;
    private Task`1<T> _cachedResult;
    private static NonReentrantLock s_gate;
    private HashSet`1<Request<T>> _requests;
    private CancellationTokenSource _asynchronousComputationCancellationSource;
    private bool _computationActive;
    public AsyncLazy`1(T value);
    public AsyncLazy`1(Func`2<CancellationToken, Task`1<T>> asynchronousComputeFunction, bool cacheResult);
    public AsyncLazy`1(Func`2<CancellationToken, Task`1<T>> asynchronousComputeFunction, Func`2<CancellationToken, T> synchronousComputeFunction, bool cacheResult);
    private static AsyncLazy`1();
    private WaitThatValidatesInvariants<T> TakeLock(CancellationToken cancellationToken);
    private void AssertInvariants_NoLock();
    public virtual bool TryGetValue(T& result);
    public virtual T GetValue(CancellationToken cancellationToken);
    private Request<T> CreateNewRequest_NoLock();
    public virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
    private AsynchronousComputationToStart<T> RegisterAsynchronousComputation_NoLock();
    private void StartAsynchronousComputation(AsynchronousComputationToStart<T> computationToStart, Request<T> requestToCompleteSynchronously, CancellationToken callerCancellationToken);
    private static bool CrashIfCanceledWithDifferentToken(OperationCanceledException exception, CancellationToken cancellationToken);
    private void CompleteWithTask(Task`1<T> task, CancellationToken cancellationToken);
    private Task`1<T> GetCachedValueAndCacheThisValueIfNoneCached_NoLock(Task`1<T> task);
    private void OnAsynchronousRequestCancelled(object state);
    [CompilerGeneratedAttribute]
private void <StartAsynchronousComputation>b__20_0(Task`1<T> t, object s);
}
internal class Roslyn.Utilities.BidirectionalMap`2 : object {
    public static IBidirectionalMap`2<TKey, TValue> Empty;
    private ImmutableDictionary`2<TKey, TValue> _forwardMap;
    private ImmutableDictionary`2<TValue, TKey> _backwardMap;
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public BidirectionalMap`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    private BidirectionalMap`2(ImmutableDictionary`2<TKey, TValue> forwardMap, ImmutableDictionary`2<TValue, TKey> backwardMap);
    private static BidirectionalMap`2();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool TryGetKey(TValue value, TKey& key);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool ContainsValue(TValue value);
    public sealed virtual IBidirectionalMap`2<TKey, TValue> RemoveKey(TKey key);
    public sealed virtual IBidirectionalMap`2<TKey, TValue> RemoveValue(TValue value);
    public sealed virtual IBidirectionalMap`2<TKey, TValue> Add(TKey key, TValue value);
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<TValue> get_Values();
    public sealed virtual bool get_IsEmpty();
    public int get_Count();
    public sealed virtual TValue GetValueOrDefault(TKey key);
    public sealed virtual TKey GetKeyOrDefault(TValue value);
}
internal static class Roslyn.Utilities.BitArithmeticUtilities : object {
    public static int CountBits(int v);
    public static int CountBits(UInt32 v);
    public static int CountBits(long v);
    public static int CountBits(ulong v);
    internal static UInt32 Align(UInt32 position, UInt32 alignment);
    internal static int Align(int position, int alignment);
}
internal class Roslyn.Utilities.BKTree : object {
    public static BKTree Empty;
    private Char[] _concatenatedLowerCaseWords;
    private ImmutableArray`1<Node> _nodes;
    private ImmutableArray`1<Edge> _edges;
    private BKTree(Char[] concatenatedLowerCaseWords, ImmutableArray`1<Node> nodes, ImmutableArray`1<Edge> edges);
    private static BKTree();
    public static BKTree Create(String[] values);
    public static BKTree Create(IEnumerable`1<StringSlice> values);
    public IList`1<string> Find(string value, Nullable`1<int> threshold);
    private void Lookup(Node currentNode, Char[] queryCharacters, int queryLength, int threshold, List`1<string> result, int recursionCount);
    internal void WriteTo(ObjectWriter writer);
    internal static BKTree ReadFrom(ObjectReader reader);
}
internal static class Roslyn.Utilities.CancellableLazy : object {
    public static CancellableLazy`1<T> Create(T value);
    public static CancellableLazy`1<T> Create(Func`2<CancellationToken, T> valueFactory);
}
internal class Roslyn.Utilities.CancellableLazy`1 : object {
    private NonReentrantLock _gate;
    private Func`2<CancellationToken, T> _valueFactory;
    private T _value;
    public bool HasValue { get; }
    public CancellableLazy`1(Func`2<CancellationToken, T> valueFactory);
    public CancellableLazy`1(T value);
    public bool get_HasValue();
    public bool TryGetValue(T& value);
    public T GetValue(CancellationToken cancellationToken);
}
internal static class Roslyn.Utilities.CompilerOptionParseUtilities : object {
    public static IList`1<string> ParseFeatureFromMSBuild(string features);
    public static void ParseFeatures(IDictionary`2<string, string> builder, List`1<string> values);
    private static void ParseFeatureCore(IDictionary`2<string, string> builder, string feature);
}
internal static class Roslyn.Utilities.CompilerPathUtilities : object {
    internal static void RequireAbsolutePath(string path, string argumentName);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Roslyn.Utilities.ConcurrentSet`1 : object {
    private static int DefaultConcurrencyLevel;
    private static int DefaultCapacity;
    private ConcurrentDictionary`2<T, byte> _dictionary;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsReadOnly { get; }
    public ConcurrentSet`1(IEqualityComparer`1<T> equalityComparer);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Contains(T value);
    public bool Add(T value);
    public void AddRange(IEnumerable`1<T> values);
    public sealed virtual bool Remove(T value);
    public sealed virtual void Clear();
    public KeyEnumerator<T> GetEnumerator();
    [IteratorStateMachineAttribute("Roslyn.Utilities.ConcurrentSet`1/<GetEnumeratorImpl>d__18")]
private IEnumerator`1<T> GetEnumeratorImpl();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
}
internal class Roslyn.Utilities.ConsList`1 : object {
    public static ConsList`1<T> Empty;
    private T _head;
    private ConsList`1<T> _tail;
    [DebuggerBrowsableAttribute("0")]
public T Head { get; }
    [DebuggerBrowsableAttribute("0")]
public ConsList`1<T> Tail { get; }
    public ConsList`1(T head, ConsList`1<T> tail);
    private static ConsList`1();
    public T get_Head();
    public ConsList`1<T> get_Tail();
    public bool Any();
    public ConsList`1<T> Push(T value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public Enumerator<T> GetEnumerator();
    public virtual string ToString();
}
internal class Roslyn.Utilities.ConstantValueSource`1 : ValueSource`1<T> {
    private T _value;
    private Task`1<T> _task;
    public ConstantValueSource`1(T value);
    public virtual T GetValue(CancellationToken cancellationToken);
    public virtual bool TryGetValue(T& value);
    public virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
}
internal static class Roslyn.Utilities.Contract : object {
    [ConditionalAttribute("DEBUG")]
[DebuggerHiddenAttribute]
public static void Requires(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
[DebuggerHiddenAttribute]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void Assume(bool condition, string message);
    public static void ThrowIfNull(T value, string message);
    public static void ThrowIfFalse(bool condition, string message);
    public static void ThrowIfTrue(bool condition, string message);
    [DebuggerHiddenAttribute]
public static void Fail(string message);
    [DebuggerHiddenAttribute]
public static T FailWithReturn(string message);
    public static void InvalidEnumValue(T value);
}
internal static class Roslyn.Utilities.CorLightup : object {
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.DecimalUtilities : object {
    [ExtensionAttribute]
public static int GetScale(decimal value);
    [ExtensionAttribute]
public static void GetBits(decimal value, Boolean& isNegative, Byte& scale, UInt32& low, UInt32& mid, UInt32& high);
}
internal static class Roslyn.Utilities.DocumentationCommentXmlNames : object {
    public static string CElementName;
    public static string CodeElementName;
    public static string CompletionListElementName;
    public static string DescriptionElementName;
    public static string ExampleElementName;
    public static string ExceptionElementName;
    public static string IncludeElementName;
    public static string ItemElementName;
    public static string ListElementName;
    public static string ListHeaderElementName;
    public static string ParaElementName;
    public static string ParameterElementName;
    public static string ParameterReferenceElementName;
    public static string PermissionElementName;
    public static string PlaceholderElementName;
    public static string PreliminaryElementName;
    public static string RemarksElementName;
    public static string ReturnsElementName;
    public static string SeeElementName;
    public static string SeeAlsoElementName;
    public static string SummaryElementName;
    public static string TermElementName;
    public static string ThreadSafetyElementName;
    public static string TypeParameterElementName;
    public static string TypeParameterReferenceElementName;
    public static string ValueElementName;
    public static string CrefAttributeName;
    public static string FileAttributeName;
    public static string InstanceAttributeName;
    public static string LangwordAttributeName;
    public static string NameAttributeName;
    public static string PathAttributeName;
    public static string StaticAttributeName;
    public static string TypeAttributeName;
    public static bool ElementEquals(string name1, string name2, bool fromVb);
    public static bool AttributeEquals(string name1, string name2);
    public static bool Equals(object left, object right);
}
internal class Roslyn.Utilities.EditDistance : object {
    private static int Infinity;
    public static int BeyondThreshold;
    private string _source;
    private Char[] _sourceLowerCaseCharacters;
    private static int MaxMatrixPoolDimension;
    private static ThreadLocal`1<Int32[0...,0...]> t_matrixPool;
    private static int LastSeenIndexLength;
    private static ThreadLocal`1<Int32[]> t_lastSeenIndexPool;
    public EditDistance(string text);
    private static EditDistance();
    private static Char[] ConvertToLowercaseArray(string text);
    public sealed virtual void Dispose();
    public static int GetEditDistance(string source, string target, int threshold);
    public static int GetEditDistance(Char[] source, Char[] target, int threshold);
    public int GetEditDistance(string target, int threshold);
    private static Int32[0...,0...] GetMatrix(int width, int height);
    private static Int32[0...,0...] InitializeMatrix(Int32[0...,0...] matrix);
    public static int GetEditDistance(ArraySlice`1<char> source, ArraySlice`1<char> target, int threshold);
    private static int GetEditDistanceWorker(ArraySlice`1<char> source, ArraySlice`1<char> target, int threshold);
    private static string ToString(Int32[0...,0...] matrix, int width, int height);
    private static int GetValue(Dictionary`2<char, int> da, char c);
    private static int Min(int v1, int v2, int v3, int v4);
    private static void SetValue(Int32[0...,0...] matrix, int i, int j, int val);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.EncodingExtensions : object {
    [ExtensionAttribute]
internal static int GetMaxCharCountOrThrowIfHuge(Encoding encoding, Stream stream);
    [ExtensionAttribute]
internal static bool TryGetMaxCharCount(Encoding encoding, long length, Int32& maxCharCount);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.EnumerableExtensions : object {
    private static Func`2<object, bool> s_notNullTest;
    private static EnumerableExtensions();
    [ExtensionAttribute]
public static IEnumerable`1<T> Do(IEnumerable`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnlyCollection(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> source, T value);
    [IteratorStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<ConcatWorker>d__3`1")]
[ExtensionAttribute]
private static IEnumerable`1<T> ConcatWorker(IEnumerable`1<T> source, T value);
    [ExtensionAttribute]
public static bool SetEquals(IEnumerable`1<T> source1, IEnumerable`1<T> source2, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool SetEquals(IEnumerable`1<T> source1, IEnumerable`1<T> source2);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static Nullable`1<T> FirstOrNullable(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static Nullable`1<T> FirstOrNullable(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static Nullable`1<T> LastOrNullable(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsSingle(IEnumerable`1<T> list);
    [ExtensionAttribute]
public static bool IsEmpty(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(IReadOnlyCollection`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(ICollection`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(string source);
    [ExtensionAttribute]
public static bool IsEmpty(T[] source);
    [ExtensionAttribute]
public static bool IsEmpty(List`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static bool All(IEnumerable`1<bool> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Flatten(IEnumerable`1<IEnumerable`1<T>> sequence);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderBy(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderBy(IEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> Order(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> ThenBy(IOrderedEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> ThenBy(IOrderedEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> ThenBy(IOrderedEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsSorted(IEnumerable`1<T> enumerable, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<T> sequence, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<string> sequence, string s);
    [ExtensionAttribute]
public static IComparer`1<T> ToComparer(Comparison`1<T> comparison);
}
internal static class Roslyn.Utilities.EnumUtilities : object {
    internal static ulong ConvertEnumUnderlyingTypeToUInt64(object value, SpecialType specialType);
    internal static T[] GetValues();
}
internal class Roslyn.Utilities.EventMap : object {
    private NonReentrantLock _guard;
    private Dictionary`2<string, object> _eventNameToRegistries;
    public void AddEventHandler(string eventName, TEventHandler eventHandler);
    public void RemoveEventHandler(string eventName, TEventHandler eventHandler);
    public EventHandlerSet`1<TEventHandler> GetEventHandlers(string eventName);
    private ImmutableArray`1<Registry`1<TEventHandler>> GetRegistries(string eventName);
    private ImmutableArray`1<Registry`1<TEventHandler>> GetRegistries_NoLock(string eventName);
    private void SetRegistries_NoLock(string eventName, ImmutableArray`1<Registry`1<TEventHandler>> registries);
}
internal static class Roslyn.Utilities.ExceptionHelpers : object {
    public static FailFastReset SuppressFailFast();
    public static bool IsFailFastSuppressed();
}
internal static class Roslyn.Utilities.ExceptionUtilities : object {
    internal static Exception Unreachable { get; }
    internal static Exception UnexpectedValue(object o);
    internal static Exception get_Unreachable();
}
internal static class Roslyn.Utilities.FileNameUtilities : object {
    private static string DirectorySeparatorStr;
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static char VolumeSeparatorChar;
    internal static bool IsFileName(string path);
    private static int IndexOfExtension(string path);
    internal static string GetExtension(string path);
    private static string RemoveExtension(string path);
    internal static string ChangeExtension(string path, string extension);
    internal static int IndexOfFileName(string path);
    internal static string GetFileName(string path, bool includeExtension);
}
internal static class Roslyn.Utilities.FileUtilities : object {
    private static Char[] s_invalidPathChars;
    private static FileUtilities();
    internal static string ResolveRelativePath(string path, string basePath, string baseDirectory, IEnumerable`1<string> searchPaths, Func`2<string, bool> fileExists);
    internal static string ResolveRelativePath(string path, string baseDirectory);
    internal static string ResolveRelativePath(string path, string basePath, string baseDirectory);
    private static string ResolveRelativePath(PathKind kind, string path, string basePath, string baseDirectory);
    private static string GetBaseDirectory(string basePath, string baseDirectory);
    internal static string NormalizeRelativePath(string path, string basePath, string baseDirectory);
    internal static string NormalizeAbsolutePath(string path);
    internal static string NormalizeDirectoryPath(string path);
    internal static string TryNormalizeAbsolutePath(string path);
    internal static Stream OpenRead(string fullPath);
    internal static Stream OpenAsyncRead(string fullPath);
    internal static T RethrowExceptionsAsIOException(Func`1<T> operation);
    internal static Stream CreateFileStreamChecked(Func`2<string, Stream> factory, string path, string paramName);
    internal static DateTime GetFileTimeStamp(string fullPath);
    internal static long GetFileLength(string fullPath);
    internal static Stream OpenFileStream(string path);
}
internal static class Roslyn.Utilities.Functions`1 : object {
    public static Func`2<T, T> Identity;
    public static Func`2<T, bool> True;
    private static Functions`1();
}
internal static class Roslyn.Utilities.GeneratedCodeUtilities : object {
    private static String[] s_autoGeneratedStrings;
    private static GeneratedCodeUtilities();
    internal static bool IsGeneratedSymbolWithGeneratedCodeAttribute(ISymbol symbol, INamedTypeSymbol generatedCodeAttribute);
    internal static bool IsGeneratedCode(SyntaxTree tree, Func`2<SyntaxTrivia, bool> isComment, CancellationToken cancellationToken);
    private static bool IsGeneratedCodeFile(string filePath);
    private static bool BeginsWithAutoGeneratedComment(SyntaxTree tree, Func`2<SyntaxTrivia, bool> isComment, CancellationToken cancellationToken);
}
internal static class Roslyn.Utilities.Hash : object {
    internal static int FnvOffsetBias;
    internal static int FnvPrime;
    internal static int Combine(int newKey, int currentKey);
    internal static int Combine(bool newKeyPart, int currentKey);
    internal static int Combine(T newKeyPart, int currentKey);
    internal static int CombineValues(IEnumerable`1<T> values, int maxItemsToHash);
    internal static int CombineValues(T[] values, int maxItemsToHash);
    internal static int CombineValues(ImmutableArray`1<T> values, int maxItemsToHash);
    internal static int CombineValues(IEnumerable`1<string> values, StringComparer stringComparer, int maxItemsToHash);
    internal static int GetFNVHashCode(Byte[] data);
    internal static int GetFNVHashCode(Byte* data, int length, Boolean& isAscii);
    internal static int GetFNVHashCode(ImmutableArray`1<byte> data);
    internal static int GetFNVHashCode(string text, int start, int length);
    internal static int GetCaseInsensitiveFNVHashCode(string text);
    internal static int GetCaseInsensitiveFNVHashCode(string text, int start, int length);
    internal static int GetFNVHashCode(string text, int start);
    internal static int GetFNVHashCode(string text);
    internal static int GetFNVHashCode(StringBuilder text);
    internal static int GetFNVHashCode(Char[] text, int start, int length);
    internal static int GetFNVHashCode(char ch);
    internal static int CombineFNVHash(int hashCode, string text);
    internal static int CombineFNVHash(int hashCode, char ch);
}
internal interface Roslyn.Utilities.IBidirectionalMap`2 {
    public bool IsEmpty { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
    public abstract virtual bool TryGetKey(TValue value, TKey& key);
    public abstract virtual TValue GetValueOrDefault(TKey key);
    public abstract virtual TKey GetKeyOrDefault(TValue value);
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool ContainsValue(TValue value);
    public abstract virtual IBidirectionalMap`2<TKey, TValue> RemoveKey(TKey key);
    public abstract virtual IBidirectionalMap`2<TKey, TValue> RemoveValue(TValue value);
    public abstract virtual IBidirectionalMap`2<TKey, TValue> Add(TKey key, TValue value);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ICollectionExtensions : object {
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, ImmutableArray`1<T> values);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.IDictionaryExtensions : object {
    [ExtensionAttribute]
public static V GetOrAdd(IDictionary`2<K, V> dictionary, K key, Func`2<K, V> function);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static void MultiAdd(IDictionary`2<TKey, TCollection> dictionary, TKey key, TValue value);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.IGroupingExtensions : object {
    [ExtensionAttribute]
public static void Deconstruct(IGrouping`2<TKey, TElement> grouping, TKey& key, IEnumerable`1& values);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
internal static bool Contains(ImmutableArray`1<T> items, T item, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> ToImmutableArrayOrEmpty(T[] items);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> ToImmutableArrayOrEmpty(IEnumerable`1<T> items);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> ToImmutableArrayOrEmpty(ImmutableArray`1<T> items);
    [ExtensionAttribute]
internal static IReadOnlyList`1<T> ToImmutableReadOnlyListOrEmpty(IEnumerable`1<T> items);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableDictionaryExtensions : object {
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableHashSet`1<V>> AddAll(ImmutableDictionary`2<K, ImmutableHashSet`1<V>> map, IEnumerable`1<K> keys, V value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableHashSet`1<V>> Add(ImmutableDictionary`2<K, ImmutableHashSet`1<V>> map, K key, V value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableHashSet`1<V>> RemoveAll(ImmutableDictionary`2<K, ImmutableHashSet`1<V>> map, IEnumerable`1<K> keys, V value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableHashSet`1<V>> Remove(ImmutableDictionary`2<K, ImmutableHashSet`1<V>> map, K key, V value);
}
internal static class Roslyn.Utilities.ImmutableHashMapExtensions : object {
    public static TValue GetOrAdd(ImmutableHashMap`2& location, TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableListExtensions : object {
    [ExtensionAttribute]
internal static ImmutableList`1<T> ToImmutableListOrEmpty(T[] items);
    [ExtensionAttribute]
internal static ImmutableList`1<T> ToImmutableListOrEmpty(IEnumerable`1<T> items);
}
internal interface Roslyn.Utilities.IObjectWritable {
    public bool ShouldReuseInSerialization { get; }
    public abstract virtual void WriteTo(ObjectWriter writer);
    public abstract virtual bool get_ShouldReuseInSerialization();
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.IReadOnlyDictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetEnumerableMetadata(IReadOnlyDictionary`2<string, object> metadata, string name);
}
internal interface Roslyn.Utilities.IReadOnlySet`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool Contains(T item);
}
internal interface Roslyn.Utilities.IReferenceCountedDisposable`1 {
    public T Target { get; }
    public abstract virtual T get_Target();
    public abstract virtual IReferenceCountedDisposable`1<T> TryAddReference();
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ISetExtensions : object {
    [ExtensionAttribute]
public static bool AddAll(ISet`1<T> set, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool RemoveAll(ISet`1<T> set, IEnumerable`1<T> values);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.KeyValuePairUtil : object {
    public static KeyValuePair`2<K, V> Create(K key, V value);
    [ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> keyValuePair, TKey& key, TValue& value);
}
internal static class Roslyn.Utilities.LazyInitialization : object {
    internal static T InterlockedStore(T& target, T value);
    public static T EnsureInitialized(T& target, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Func`2<U, T> valueFactory, U state);
}
internal class Roslyn.Utilities.LinkedHashQueue`1 : object {
    private LinkedList`1<T> _list;
    private Dictionary`2<T, LinkedListNode`1<T>> _map;
    private int _insertionIndex;
    public int Count { get; }
    public T First { get; }
    public LinkedHashQueue`1(IEqualityComparer`1<T> comparer);
    public int get_Count();
    public void Clear();
    public T get_First();
    public bool Enqueue(T value);
    public T Dequeue();
    public bool Contains(T value);
    public void Remove(T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.MultiDictionary`2 : object {
    private Dictionary`2<K, ValueSet<K, V>> _dictionary;
    public int Count { get; }
    public IEnumerable`1<K> Keys { get; }
    public ValueSet<K, V> Item { get; }
    public MultiDictionary`2(IEqualityComparer`1<K> comparer);
    public MultiDictionary`2(int capacity, IEqualityComparer`1<K> comparer);
    public int get_Count();
    public IEnumerable`1<K> get_Keys();
    public ValueSet<K, V> get_Item(K k);
    public void Add(K k, V v);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, ValueSet<K, V>>> GetEnumerator();
    public bool ContainsKey(K k);
    internal void Clear();
    public void Remove(K key);
}
internal class Roslyn.Utilities.NonReentrantLock : object {
    private object _syncLock;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _owningThreadId;
    public static Func`1<NonReentrantLock> Factory;
    private static Action`1<object> s_cancellationTokenCanceledEventHandler;
    private bool IsLocked { get; }
    private bool IsOwnedByMe { get; }
    public NonReentrantLock(bool useThisInstanceForSynchronization);
    private static NonReentrantLock();
    public void Wait(CancellationToken cancellationToken);
    public void Release();
    public bool LockHeldByMe();
    public void AssertHasLock();
    private bool get_IsLocked();
    private bool get_IsOwnedByMe();
    private void TakeOwnership();
    private void ReleaseOwnership();
    private static void CancellationTokenCanceledEventHandler(object obj);
    public SemaphoreDisposer DisposableWait(CancellationToken cancellationToken);
}
internal static class Roslyn.Utilities.ObjectBinder : object {
    private static object s_gate;
    private static Nullable`1<ObjectBinderSnapshot> s_lastSnapshot;
    private static Dictionary`2<Type, int> s_typeToIndex;
    private static List`1<Type> s_types;
    private static List`1<Func`2<ObjectReader, IObjectWritable>> s_typeReaders;
    private static ObjectBinder();
    public static ObjectBinderSnapshot GetSnapshot();
    public static void RegisterTypeReader(Type type, Func`2<ObjectReader, IObjectWritable> typeReader);
}
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.ObjectBinderSnapshot : ValueType {
    private Dictionary`2<Type, int> _typeToIndex;
    private ImmutableArray`1<Type> _types;
    private ImmutableArray`1<Func`2<ObjectReader, IObjectWritable>> _typeReaders;
    public ObjectBinderSnapshot(Dictionary`2<Type, int> typeToIndex, List`1<Type> types, List`1<Func`2<ObjectReader, IObjectWritable>> typeReaders);
    public int GetTypeId(Type type);
    public Type GetTypeFromId(int typeId);
    public Func`2<ObjectReader, IObjectWritable> GetTypeReaderFromId(int typeId);
}
internal class Roslyn.Utilities.ObjectReader : object {
    internal static byte VersionByte1;
    internal static byte VersionByte2;
    private BinaryReader _reader;
    private CancellationToken _cancellationToken;
    private ReaderReferenceMap`1<object> _objectReferenceMap;
    private ReaderReferenceMap`1<string> _stringReferenceMap;
    private ObjectBinderSnapshot _binderSnapshot;
    private int _recursionDepth;
    private ObjectReader(Stream stream, CancellationToken cancellationToken);
    public static ObjectReader TryGetReader(Stream stream, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    public bool ReadBoolean();
    public byte ReadByte();
    public char ReadChar();
    public decimal ReadDecimal();
    public double ReadDouble();
    public float ReadSingle();
    public int ReadInt32();
    public long ReadInt64();
    public sbyte ReadSByte();
    public short ReadInt16();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public ushort ReadUInt16();
    public string ReadString();
    public Guid ReadGuid();
    public object ReadValue();
    private object ReadValueWorker();
    internal UInt32 ReadCompressedUInt();
    private string ReadStringValue();
    private string ReadStringValue(EncodingKind kind);
    private string ReadStringLiteral(EncodingKind kind);
    private Array ReadArray(EncodingKind kind);
    private Array ReadPrimitiveTypeArrayElements(Type type, EncodingKind kind, int length);
    private Boolean[] ReadBooleanArrayElements(Boolean[] array);
    private static T[] CreateArray(int length);
    private String[] ReadStringArrayElements(String[] array);
    private SByte[] ReadInt8ArrayElements(SByte[] array);
    private Int16[] ReadInt16ArrayElements(Int16[] array);
    private Int32[] ReadInt32ArrayElements(Int32[] array);
    private Int64[] ReadInt64ArrayElements(Int64[] array);
    private UInt16[] ReadUInt16ArrayElements(UInt16[] array);
    private UInt32[] ReadUInt32ArrayElements(UInt32[] array);
    private UInt64[] ReadUInt64ArrayElements(UInt64[] array);
    private Decimal[] ReadDecimalArrayElements(Decimal[] array);
    private Single[] ReadFloat4ArrayElements(Single[] array);
    private Double[] ReadFloat8ArrayElements(Double[] array);
    public Type ReadType();
    private Type ReadTypeAfterTag();
    private object ReadObject();
    private static Exception DeserializationReadIncorrectNumberOfValuesException(string typeName);
    private static Exception NoSerializationTypeException(string typeName);
    private static Exception NoSerializationReaderException(string typeName);
    [CompilerGeneratedAttribute]
private object <ReadValue>b__26_0();
}
internal class Roslyn.Utilities.ObjectWriter : object {
    private BinaryWriter _writer;
    private CancellationToken _cancellationToken;
    private WriterReferenceMap _objectReferenceMap;
    private WriterReferenceMap _stringReferenceMap;
    private ObjectBinderSnapshot _binderSnapshot;
    private int _recursionDepth;
    internal static int MaxRecursionDepth;
    internal static Dictionary`2<Type, EncodingKind> s_typeMap;
    internal static ImmutableArray`1<Type> s_reverseTypeMap;
    internal static byte ByteMarkerMask;
    internal static byte Byte1Marker;
    internal static byte Byte2Marker;
    internal static byte Byte4Marker;
    public ObjectWriter(Stream stream, CancellationToken cancellationToken);
    private static ObjectWriter();
    private void WriteVersion();
    public sealed virtual void Dispose();
    public void WriteBoolean(bool value);
    public void WriteByte(byte value);
    public void WriteChar(char ch);
    public void WriteDecimal(decimal value);
    public void WriteDouble(double value);
    public void WriteSingle(float value);
    public void WriteInt32(int value);
    public void WriteInt64(long value);
    public void WriteSByte(sbyte value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteUInt64(ulong value);
    public void WriteUInt16(ushort value);
    public void WriteString(string value);
    public void WriteGuid(Guid guid);
    public void WriteValue(object value);
    public void WriteValue(IObjectWritable value);
    private void WriteEncodedInt32(int v);
    private void WriteEncodedUInt32(UInt32 v);
    internal void WriteCompressedUInt(UInt32 value);
    private void WriteStringValue(string value);
    private void WriteArray(Array array);
    private void WriteArrayValues(Array array);
    private void WritePrimitiveTypeArrayElements(Type type, EncodingKind kind, Array instance);
    private void WriteBooleanArrayElements(Boolean[] array);
    private void WriteStringArrayElements(String[] array);
    private void WriteInt8ArrayElements(SByte[] array);
    private void WriteInt16ArrayElements(Int16[] array);
    private void WriteInt32ArrayElements(Int32[] array);
    private void WriteInt64ArrayElements(Int64[] array);
    private void WriteUInt16ArrayElements(UInt16[] array);
    private void WriteUInt32ArrayElements(UInt32[] array);
    private void WriteUInt64ArrayElements(UInt64[] array);
    private void WriteDecimalArrayElements(Decimal[] array);
    private void WriteFloat4ArrayElements(Single[] array);
    private void WriteFloat8ArrayElements(Double[] array);
    private void WritePrimitiveType(Type type, EncodingKind kind);
    public void WriteType(Type type);
    private void WriteKnownType(Type type);
    private void WriteObject(object instance, IObjectWritable instanceAsWritableOpt);
    private void WriteObjectWorker(IObjectWritable writable);
    private static Exception NoSerializationTypeException(string typeName);
    private static Exception NoSerializationWriterException(string typeName);
    [CompilerGeneratedAttribute]
private void <WriteArray>b__33_0(object a);
    [CompilerGeneratedAttribute]
private void <WriteObject>b__51_0(object obj);
}
internal static class Roslyn.Utilities.OneOrMany : object {
    public static OneOrMany`1<T> Create(T one);
    public static OneOrMany`1<T> Create(ImmutableArray`1<T> many);
}
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.OneOrMany`1 : ValueType {
    private T _one;
    private ImmutableArray`1<T> _many;
    public T Item { get; }
    public int Count { get; }
    public OneOrMany`1(T one);
    public OneOrMany`1(ImmutableArray`1<T> many);
    public T get_Item(int index);
    public int get_Count();
    public OneOrMany`1<T> Add(T one);
    public bool Contains(T item);
    public OneOrMany`1<T> RemoveAll(T item);
    public Enumerator<T> GetEnumerator();
}
internal enum Roslyn.Utilities.PathKind : Enum {
    public int value__;
    public static PathKind Empty;
    public static PathKind Relative;
    public static PathKind RelativeToCurrentDirectory;
    public static PathKind RelativeToCurrentParent;
    public static PathKind RelativeToCurrentRoot;
    public static PathKind RelativeToDriveDirectory;
    public static PathKind Absolute;
}
internal static class Roslyn.Utilities.PathUtilities : object {
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static string ParentRelativeDirectory;
    internal static string ThisDirectory;
    internal static string DirectorySeparatorStr;
    internal static char VolumeSeparatorChar;
    private static Char[] s_pathChars;
    public static IEqualityComparer`1<string> Comparer;
    internal static bool IsUnixLikePlatform { get; }
    private static PathUtilities();
    internal static bool get_IsUnixLikePlatform();
    public static bool IsDirectorySeparator(char c);
    public static bool IsAnyDirectorySeparator(char c);
    public static string TrimTrailingSeparators(string s);
    public static string EnsureTrailingSeparator(string s);
    public static string GetExtension(string path);
    public static string ChangeExtension(string path, string extension);
    public static string RemoveExtension(string path);
    public static string GetFileName(string path, bool includeExtension);
    public static string GetDirectoryName(string path);
    internal static string GetDirectoryName(string path, bool isUnixLike);
    internal static bool IsSameDirectoryOrChildOf(string child, string parent);
    public static string GetPathRoot(string path);
    private static string GetPathRoot(string path, bool isUnixLike);
    private static string GetWindowsRoot(string path);
    private static int ConsumeDirectorySeparators(string path, int length, int i);
    private static string GetUnixRoot(string path);
    public static PathKind GetPathKind(string path);
    public static bool IsAbsolute(string path);
    private static bool IsDriveRootedAbsolutePath(string path);
    public static string CombineAbsoluteAndRelativePaths(string root, string relativePath);
    public static string CombinePossiblyRelativeAndRelativePaths(string rootOpt, string relativePath);
    public static string CombinePathsUnchecked(string root, string relativePath);
    private static string RemoveTrailingDirectorySeparator(string path);
    public static bool IsFilePath(string assemblyDisplayNameOrPath);
    public static bool ContainsPathComponent(string path, string component, bool ignoreCase);
    public static string GetRelativePath(string directory, string fullPath);
    public static bool IsChildPath(string parentPath, string childPath);
    private static string GetRelativeChildPath(string parentPath, string childPath);
    private static String[] GetPathParts(string path);
    public static bool PathsEqual(string path1, string path2);
    private static bool PathsEqual(string path1, string path2, int length);
    private static bool PathCharEqual(char x, char y);
    private static int PathHashCode(string path);
    public static string NormalizePathPrefix(string filePath, ImmutableArray`1<KeyValuePair`2<string, string>> pathMap);
    public static bool IsValidFilePath(string fullPath);
}
[ConditionalAttribute("EMIT_CODE_ANALYSIS_ATTRIBUTES")]
[AttributeUsageAttribute("480")]
internal class Roslyn.Utilities.PerformanceSensitiveAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Constraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowCaptures>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowGenericEnumeration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowLocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OftenCompletesSynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParallelEntry>k__BackingField;
    public string Uri { get; }
    public string Constraint { get; public set; }
    public bool AllowCaptures { get; public set; }
    public bool AllowGenericEnumeration { get; public set; }
    public bool AllowLocks { get; public set; }
    public bool OftenCompletesSynchronously { get; public set; }
    public bool IsParallelEntry { get; public set; }
    public PerformanceSensitiveAttribute(string uri);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public string get_Constraint();
    [CompilerGeneratedAttribute]
public void set_Constraint(string value);
    [CompilerGeneratedAttribute]
public bool get_AllowCaptures();
    [CompilerGeneratedAttribute]
public void set_AllowCaptures(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowGenericEnumeration();
    [CompilerGeneratedAttribute]
public void set_AllowGenericEnumeration(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowLocks();
    [CompilerGeneratedAttribute]
public void set_AllowLocks(bool value);
    [CompilerGeneratedAttribute]
public bool get_OftenCompletesSynchronously();
    [CompilerGeneratedAttribute]
public void set_OftenCompletesSynchronously(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsParallelEntry();
    [CompilerGeneratedAttribute]
public void set_IsParallelEntry(bool value);
}
internal static class Roslyn.Utilities.PlatformInformation : object {
    public static bool IsWindows { get; }
    public static bool IsUnix { get; }
    public static bool IsRunningOnMono { get; }
    public static bool get_IsWindows();
    public static bool get_IsUnix();
    public static bool get_IsRunningOnMono();
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.PooledBuilderExtensions : object {
    [ExtensionAttribute]
public static Dictionary`2<K, V> ToDictionaryAndFree(PooledDictionary`2<K, V> builders);
    [ExtensionAttribute]
public static Dictionary`2<K, ImmutableArray`1<V>> ToDictionaryAndFree(PooledDictionary`2<K, ArrayBuilder`1<V>> builders);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableArray`1<V>> ToImmutableDictionaryAndFree(PooledDictionary`2<K, ArrayBuilder`1<V>> builders);
    [ExtensionAttribute]
public static ImmutableArray`1<T> ToFlattenedImmutableArrayAndFree(ArrayBuilder`1<ArrayBuilder`1<T>> builders);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ReaderWriterLockSlimExtensions : object {
    [ExtensionAttribute]
internal static ReadLockExiter DisposableRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static WriteLockExiter DisposableWrite(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static void AssertCanRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static void AssertCanWrite(ReaderWriterLockSlim lock);
}
internal class Roslyn.Utilities.ReferenceCountedDisposable`1 : object {
    private T _instance;
    private StrongBox`1<int> _boxedReferenceCount;
    public T Target { get; }
    public ReferenceCountedDisposable`1(T instance);
    private ReferenceCountedDisposable`1(T instance, StrongBox`1<int> referenceCount);
    public sealed virtual T get_Target();
    public ReferenceCountedDisposable`1<T> TryAddReference();
    private sealed virtual override IReferenceCountedDisposable`1<T> Roslyn.Utilities.IReferenceCountedDisposable<T>.TryAddReference();
    private static ReferenceCountedDisposable`1<T> TryAddReferenceImpl(T target, StrongBox`1<int> referenceCount);
    public sealed virtual void Dispose();
}
internal class Roslyn.Utilities.ReferenceEqualityComparer : object {
    public static ReferenceEqualityComparer Instance;
    private static ReferenceEqualityComparer();
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object a, object b);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Object>.GetHashCode(object a);
    public static int GetHashCode(object a);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ReflectionUtilities : object {
    private static Type Missing;
    private static ReflectionUtilities();
    public static Type TryGetType(string assemblyQualifiedName);
    public static Type TryGetType(Type& lazyType, string assemblyQualifiedName);
    public static Type GetTypeFromEither(string contractName, string desktopName);
    public static Type GetTypeFromEither(Type& lazyType, string contractName, string desktopName);
    public static T FindItem(IEnumerable`1<T> collection, Type[] paramTypes);
    [ExtensionAttribute]
internal static MethodInfo GetDeclaredMethod(TypeInfo typeInfo, string name, Type[] paramTypes);
    [ExtensionAttribute]
internal static ConstructorInfo GetDeclaredConstructor(TypeInfo typeInfo, Type[] paramTypes);
    [ExtensionAttribute]
public static T CreateDelegate(MethodInfo methodInfo);
    [ExtensionAttribute]
public static T InvokeConstructor(ConstructorInfo constructorInfo, Object[] args);
    [ExtensionAttribute]
public static object InvokeConstructor(ConstructorInfo constructorInfo, Object[] args);
    [ExtensionAttribute]
public static T Invoke(MethodInfo methodInfo, object obj, Object[] args);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.SemaphoreExtensions : object {
    [ExtensionAttribute]
public static SemaphoreDisposer DisposableWait(Semaphore semaphore, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<SemaphoreDisposer> DisposableWaitAsync(Semaphore semaphore, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.SemaphoreSlimExtensions : object {
    [ExtensionAttribute]
public static SemaphoreDisposer DisposableWait(SemaphoreSlim semaphore, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslyn.Utilities.SemaphoreSlimExtensions/<DisposableWaitAsync>d__1")]
[ExtensionAttribute]
public static Task`1<SemaphoreDisposer> DisposableWaitAsync(SemaphoreSlim semaphore, CancellationToken cancellationToken);
}
internal static class Roslyn.Utilities.SemaphoreSlimFactory : object {
    public static Func`1<SemaphoreSlim> Instance;
    private static SemaphoreSlimFactory();
}
internal class Roslyn.Utilities.SimplePool`1 : object {
    private object _gate;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
internal class Roslyn.Utilities.SimpleTaskQueue : object {
    private TaskScheduler _taskScheduler;
    private object _gate;
    private Task _latestTask;
    private int _taskCount;
    public Task LastScheduledTask { get; }
    public SimpleTaskQueue(TaskScheduler taskScheduler);
    private TTask ScheduleTaskWorker(Func`2<int, TTask> taskCreator, CancellationToken cancellationToken);
    public Task ScheduleTask(Action taskAction, CancellationToken cancellationToken);
    public Task`1<T> ScheduleTask(Func`1<T> taskFunc, CancellationToken cancellationToken);
    public Task ScheduleTask(Func`1<Task> taskFuncAsync, CancellationToken cancellationToken);
    public Task`1<T> ScheduleTask(Func`1<Task`1<T>> taskFuncAsync, CancellationToken cancellationToken);
    public Task get_LastScheduledTask();
}
internal class Roslyn.Utilities.SoftCrashException : OperationCanceledException {
    public SoftCrashException(string message);
    public SoftCrashException(CancellationToken token);
    public SoftCrashException(string message, Exception innerException);
    public SoftCrashException(string message, CancellationToken token);
    public SoftCrashException(string message, Exception innerException, CancellationToken token);
}
internal static class Roslyn.Utilities.SpecializedCollections : object {
    public static IEnumerator`1<T> EmptyEnumerator();
    public static IEnumerable`1<T> EmptyEnumerable();
    public static ICollection`1<T> EmptyCollection();
    public static IList`1<T> EmptyList();
    public static IReadOnlyList`1<T> EmptyReadOnlyList();
    public static ISet`1<T> EmptySet();
    public static IReadOnlySet`1<T> EmptyReadOnlySet();
    public static IDictionary`2<TKey, TValue> EmptyDictionary();
    public static IReadOnlyDictionary`2<TKey, TValue> EmptyReadOnlyDictionary();
    public static IEnumerable`1<T> SingletonEnumerable(T value);
    public static ICollection`1<T> SingletonCollection(T value);
    public static IEnumerator`1<T> SingletonEnumerator(T value);
    public static IList`1<T> SingletonList(T value);
    public static IEnumerable`1<T> ReadOnlyEnumerable(IEnumerable`1<T> values);
    public static ICollection`1<T> ReadOnlyCollection(ICollection`1<T> collection);
    public static ISet`1<T> ReadOnlySet(ISet`1<T> set);
    public static IReadOnlySet`1<T> StronglyTypedReadOnlySet(ISet`1<T> set);
}
internal static class Roslyn.Utilities.SpecializedTasks : object {
    public static Task`1<bool> True;
    public static Task`1<bool> False;
    [ObsoleteAttribute("Use Task.CompletedTask instead which is available in the framework.")]
public static Task EmptyTask;
    private static SpecializedTasks();
    public static Task`1<T> Default();
    public static Task`1<T> DefaultOrResult(T value);
    public static Task`1<IReadOnlyList`1<T>> EmptyReadOnlyList();
    public static Task`1<IList`1<T>> EmptyList();
    public static Task`1<ImmutableArray`1<T>> EmptyImmutableArray();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T> FromResult(T t);
}
internal class Roslyn.Utilities.SpellChecker : object {
    private static string SerializationFormat;
    [CompilerGeneratedAttribute]
private Checksum <Checksum>k__BackingField;
    private BKTree _bkTree;
    public Checksum Checksum { get; }
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    public SpellChecker(Checksum checksum, BKTree bKTree);
    public SpellChecker(Checksum checksum, IEnumerable`1<StringSlice> corpus);
    [CompilerGeneratedAttribute]
public sealed virtual Checksum get_Checksum();
    public IList`1<string> FindSimilarWords(string value);
    public IList`1<string> FindSimilarWords(string value, bool substringsAreSimilar);
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    internal static SpellChecker TryReadFrom(ObjectReader reader);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.StreamExtensions : object {
    [ExtensionAttribute]
public static int TryReadAll(Stream stream, Byte[] buffer, int offset, int count);
    [ExtensionAttribute]
public static Byte[] ReadAllBytes(Stream stream);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.StringEscapeEncoder : object {
    [ExtensionAttribute]
public static string Escape(string text, char escapePrefix, Char[] prohibitedCharacters);
    [ExtensionAttribute]
public static string Unescape(string text, char escapePrefix);
    private static int ParseHex(string text, int start, int length);
    private static bool IsHexDigit(char ch);
    private static int GetHexValue(char ch);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.StringExtensions : object {
    private static ImmutableArray`1<string> s_lazyNumerals;
    private static Func`2<char, char> s_toLower;
    private static Func`2<char, char> s_toUpper;
    private static StringExtensions();
    internal static string GetNumeral(int number);
    [ExtensionAttribute]
public static string Join(IEnumerable`1<string> source, string separator);
    [ExtensionAttribute]
public static bool LooksLikeInterfaceName(string name);
    [ExtensionAttribute]
public static bool LooksLikeTypeParameterName(string name);
    [ExtensionAttribute]
public static string ToPascalCase(string shortName, bool trimLeadingTypePrefix);
    [ExtensionAttribute]
public static string ToCamelCase(string shortName, bool trimLeadingTypePrefix);
    [ExtensionAttribute]
private static string ConvertCase(string shortName, bool trimLeadingTypePrefix, Func`2<char, char> convert);
    [ExtensionAttribute]
internal static bool IsValidClrTypeName(string name);
    [ExtensionAttribute]
internal static bool IsValidClrNamespaceName(string name);
    [ExtensionAttribute]
internal static string GetWithSingleAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool TryGetWithoutAttributeSuffix(string name, String& result);
    [ExtensionAttribute]
internal static string GetWithoutAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool TryGetWithoutAttributeSuffix(string name, bool isCaseSensitive, String& result);
    [ExtensionAttribute]
internal static bool IsValidUnicodeString(string str);
    [ExtensionAttribute]
internal static string Unquote(string arg);
    [ExtensionAttribute]
internal static string Unquote(string arg, Boolean& quoted);
    [ExtensionAttribute]
internal static int IndexOfBalancedParenthesis(string str, int openingOffset, char closing);
    [ExtensionAttribute]
internal static char First(string arg);
    [ExtensionAttribute]
internal static char Last(string arg);
    [ExtensionAttribute]
internal static bool All(string arg, Predicate`1<char> predicate);
    [ExtensionAttribute]
public static int GetCaseInsensitivePrefixLength(string string1, string string2);
}
internal class Roslyn.Utilities.StringTable : object {
    private static int LocalSizeBits;
    private static int LocalSize;
    private static int LocalSizeMask;
    private static int SharedSizeBits;
    private static int SharedSize;
    private static int SharedSizeMask;
    private static int SharedBucketBits;
    private static int SharedBucketSize;
    private static int SharedBucketSizeMask;
    private Entry[] _localTable;
    private static Entry[] s_sharedTable;
    private int _localRandom;
    private static int s_sharedRandom;
    private ObjectPool`1<StringTable> _pool;
    private static ObjectPool`1<StringTable> s_staticPool;
    private StringTable(ObjectPool`1<StringTable> pool);
    private static StringTable();
    private static ObjectPool`1<StringTable> CreatePool();
    public static StringTable GetInstance();
    public void Free();
    internal string Add(Char[] chars, int start, int len);
    internal string Add(string chars, int start, int len);
    internal string Add(char chars);
    internal string Add(StringBuilder chars);
    internal string Add(string chars);
    private static string FindSharedEntry(Char[] chars, int start, int len, int hashCode);
    private static string FindSharedEntry(string chars, int start, int len, int hashCode);
    private static string FindSharedEntryASCII(int hashCode, Byte* asciiChars, int length);
    private static string FindSharedEntry(char chars, int hashCode);
    private static string FindSharedEntry(StringBuilder chars, int hashCode);
    private static string FindSharedEntry(string chars, int hashCode);
    private string AddItem(Char[] chars, int start, int len, int hashCode);
    private string AddItem(string chars, int start, int len, int hashCode);
    private string AddItem(char chars, int hashCode);
    private string AddItem(StringBuilder chars, int hashCode);
    private void AddCore(string chars, int hashCode);
    private void AddSharedEntry(int hashCode, string text);
    internal static string AddShared(StringBuilder chars);
    private static string AddSharedSlow(int hashCode, StringBuilder builder);
    internal static string AddSharedUTF8(Byte* bytes, int byteCount);
    private static string AddSharedSlow(int hashCode, Byte* utf8Bytes, int byteCount, bool isAscii);
    private static void AddSharedSlow(int hashCode, string text);
    private static int LocalIdxFromHash(int hash);
    private static int SharedIdxFromHash(int hash);
    private int LocalNextRandom();
    private static int SharedNextRandom();
    internal static bool TextEquals(string array, string text, int start, int length);
    internal static bool TextEquals(string array, StringBuilder text);
    internal static bool TextEqualsASCII(string text, Byte* ascii, int length);
    internal static bool TextEquals(string array, Char[] text, int start, int length);
    private static bool TextEqualsCore(string array, Char[] text, int start);
}
internal class Roslyn.Utilities.SyntaxPath : object {
    private List`1<PathSegment> _segments;
    private int _kind;
    private bool _trackKinds;
    public SyntaxPath(SyntaxNodeOrToken nodeOrToken, bool trackKinds);
    private void AddSegment(SyntaxNodeOrToken nodeOrToken);
    public bool TryResolve(SyntaxNode root, SyntaxNodeOrToken& nodeOrToken);
    private SyntaxNodeOrToken FindChild(SyntaxNodeOrToken current, PathSegment segment);
    public bool TryResolve(SyntaxTree syntaxTree, CancellationToken cancellationToken, TNode& node);
    public bool TryResolve(SyntaxNode root, TNode& node);
    public static bool op_Equality(SyntaxPath left, SyntaxPath right);
    public static bool op_Inequality(SyntaxPath left, SyntaxPath right);
    public virtual bool Equals(object obj);
    public bool Equals(SyntaxPath other);
    public virtual int GetHashCode();
    private int GetSegmentHashCode();
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.TaskExtensions : object {
    [AsyncStateMachineAttribute("Roslyn.Utilities.TaskExtensions/<FireAndForget>d__0")]
[ExtensionAttribute]
public static void FireAndForget(Task task);
    [ExtensionAttribute]
public static T WaitAndGetResult(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static T WaitAndGetResult_CanCallOnBackground(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task task, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWith(Task`1<TInput> task, Func`2<Task`1<TInput>, TResult> continuationFunction, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWith(Task`1<TInput> task, Func`2<Task`1<TInput>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task`1<TInput> task, Action`1<Task`1<TInput>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWith(Task task, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWith(Task task, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task task, Action`1<Task> continuationAction, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task`1<TInput> task, Action`1<Task`1<TInput>> continuationFunction, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWith(Task`1<TInput> task, Func`2<Task`1<TInput>, TResult> continuationFunction, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task task, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> ContinueWithAfterDelay(Task`1<TInput> task, Func`2<Task`1<TInput>, TResult> continuationFunction, CancellationToken cancellationToken, int millisecondsDelay, TaskContinuationOptions taskContinuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TNResult> ContinueWithAfterDelay(Task task, Func`2<Task, TNResult> continuationFunction, CancellationToken cancellationToken, int millisecondsDelay, TaskContinuationOptions taskContinuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task ContinueWithAfterDelay(Task task, Action continuationAction, CancellationToken cancellationToken, int millisecondsDelay, TaskContinuationOptions taskContinuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWithFromAsync(Task`1<TInput> task, Func`2<Task`1<TInput>, Task`1<TResult>> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWithFromAsync(Task task, Func`2<Task, Task`1<TResult>> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWithFromAsync(Task task, Func`2<Task, Task> continuationFunction, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWithFromAsync(Task task, Func`2<Task, Task> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TNResult> ContinueWithAfterDelayFromAsync(Task task, Func`2<Task, Task`1<TNResult>> continuationFunction, CancellationToken cancellationToken, int millisecondsDelay, TaskContinuationOptions taskContinuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task ContinueWithAfterDelayFromAsync(Task task, Func`2<Task, Task> continuationFunction, CancellationToken cancellationToken, int millisecondsDelay, TaskContinuationOptions taskContinuationOptions, TaskScheduler scheduler);
    internal static void ReportFatalError(Task task, object continuationFunction);
    private static void ReportFatalErrorWorker(Task task, object continuationFunction);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.TaskFactoryExtensions : object {
    [ExtensionAttribute]
public static Task SafeStartNew(TaskFactory factory, Action action, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeStartNew(TaskFactory factory, Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeStartNew(TaskFactory factory, Func`1<TResult> func, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeStartNew(TaskFactory factory, Func`1<TResult> func, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeStartNewFromAsync(TaskFactory factory, Func`1<Task> actionAsync, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeStartNewFromAsync(TaskFactory factory, Func`1<Task> actionAsync, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeStartNewFromAsync(TaskFactory factory, Func`1<Task`1<TResult>> funcAsync, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeStartNewFromAsync(TaskFactory factory, Func`1<Task`1<TResult>> funcAsync, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.TextChangeRangeExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<TextChangeRange> Accumulate(Nullable`1<TextChangeRange> accumulatedTextChangeSoFar, IEnumerable`1<TextChangeRange> changesInNextVersion);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.TopologicalSorter : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> TopologicalSort(IEnumerable`1<T> items, Func`2<T, IEnumerable`1<T>> itemsBefore);
    [ExtensionAttribute]
public static IEnumerable`1<T> TopologicalSort(IEnumerable`1<T> items, Func`2<T, IEnumerable`1<T>> itemsBefore, Func`2<T, IEnumerable`1<T>> itemsAfter);
    private static void Visit(T item, Func`2<T, IEnumerable`1<T>> itemsBefore, List`1<T> result, HashSet`1<T> visited);
    private static Func`2<T, IEnumerable`1<T>> CreateCombinedItemsBefore(IEnumerable`1<T> items, Func`2<T, IEnumerable`1<T>> itemsBefore, Func`2<T, IEnumerable`1<T>> itemsAfter);
}
internal static class Roslyn.Utilities.UnicodeCharacterUtilities : object {
    public static bool IsIdentifierStartCharacter(char ch);
    public static bool IsIdentifierPartCharacter(char ch);
    public static bool IsValidIdentifier(string name);
    private static bool IsLetterChar(UnicodeCategory cat);
    private static bool IsCombiningChar(UnicodeCategory cat);
    private static bool IsDecimalDigitChar(UnicodeCategory cat);
    private static bool IsConnectingChar(UnicodeCategory cat);
    internal static bool IsFormattingChar(char ch);
    private static bool IsFormattingChar(UnicodeCategory cat);
}
internal abstract class Roslyn.Utilities.ValueSource`1 : object {
    public static ConstantValueSource`1<T> Empty;
    public bool HasValue { get; }
    private static ValueSource`1();
    public abstract virtual bool TryGetValue(T& value);
    public abstract virtual T GetValue(CancellationToken cancellationToken);
    public abstract virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
    public bool get_HasValue();
}
internal class Roslyn.Utilities.VoidResult : ValueType {
}
internal class Roslyn.Utilities.WeakConstantValueSource`1 : ValueSource`1<T> {
    private WeakReference`1<T> _weakValue;
    public WeakConstantValueSource`1(T value);
    public virtual T GetValue(CancellationToken cancellationToken);
    public virtual bool TryGetValue(T& value);
    public virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
}
internal static class Roslyn.Utilities.WeakEventHandler`1 : object {
    public static EventHandler`1<TArgs> Create(TTarget target, Action`3<TTarget, object, TArgs> invoker);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.WeakReferenceExtensions : object {
    [ExtensionAttribute]
public static T GetTarget(WeakReference`1<T> reference);
    [ExtensionAttribute]
public static bool IsNull(WeakReference`1<T> reference);
}
internal class Roslyn.Utilities.WordSimilarityChecker : object {
    private CacheResult _lastAreSimilarResult;
    private string _source;
    private EditDistance _editDistance;
    private int _threshold;
    private bool _substringsAreSimilar;
    private static object s_poolGate;
    private static Stack`1<WordSimilarityChecker> s_pool;
    private static WordSimilarityChecker();
    public static WordSimilarityChecker Allocate(string text, bool substringsAreSimilar);
    private void Initialize(string text, bool substringsAreSimilar);
    public void Free();
    public static bool AreSimilar(string originalText, string candidateText);
    public static bool AreSimilar(string originalText, string candidateText, bool substringsAreSimilar);
    public static bool AreSimilar(string originalText, string candidateText, Double& similarityWeight);
    public static bool AreSimilar(string originalText, string candidateText, bool substringsAreSimilar, Double& similarityWeight);
    internal static int GetThreshold(string value);
    public bool AreSimilar(string candidateText);
    public bool AreSimilar(string candidateText, Double& similarityWeight);
    private bool AreSimilarWorker(string candidateText, Double& similarityWeight);
    private static double Penalty(string candidateText, string originalText);
}
[ExtensionAttribute]
internal static class System.Linq.EnumerableExtensions : object {
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<T> first, IEnumerable`1<T> second, Func`3<T, T, bool> comparer);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
