internal class Microsoft.Cci.AssemblyReferenceAlias : ValueType {
    public string Name;
    public IAssemblyReference Assembly;
    internal AssemblyReferenceAlias(string name, IAssemblyReference assembly);
}
[FlagsAttribute]
internal enum Microsoft.Cci.CallingConvention : Enum {
    public int value__;
    public static CallingConvention C;
    public static CallingConvention Default;
    public static CallingConvention ExtraArguments;
    public static CallingConvention FastCall;
    public static CallingConvention Standard;
    public static CallingConvention ThisCall;
    public static CallingConvention Generic;
    public static CallingConvention HasThis;
    public static CallingConvention ExplicitThis;
}
internal static class Microsoft.Cci.Constants : object {
    public static CharSet CharSet_None;
    public static CharSet CharSet_Auto;
    public static CallingConvention CallingConvention_FastCall;
    public static UnmanagedType UnmanagedType_CustomMarshaler;
    public static UnmanagedType UnmanagedType_IDispatch;
    public static UnmanagedType UnmanagedType_SafeArray;
    public static UnmanagedType UnmanagedType_VBByRefStr;
    public static UnmanagedType UnmanagedType_AnsiBStr;
    public static UnmanagedType UnmanagedType_TBStr;
    public static ComInterfaceType ComInterfaceType_InterfaceIsDual;
    public static ComInterfaceType ComInterfaceType_InterfaceIsIDispatch;
    public static ClassInterfaceType ClassInterfaceType_AutoDispatch;
    public static ClassInterfaceType ClassInterfaceType_AutoDual;
    public static int CompilationRelaxations_NoStringInterning;
    public static TypeAttributes TypeAttributes_TypeForwarder;
}
internal class Microsoft.Cci.CustomDebugInfoWriter : object {
    private MethodDefinitionHandle _methodWithModuleInfo;
    private IMethodBody _methodBodyWithModuleInfo;
    private MethodDefinitionHandle _previousMethodWithUsingInfo;
    private IMethodBody _previousMethodBodyWithUsingInfo;
    private PdbWriter _pdbWriter;
    public CustomDebugInfoWriter(PdbWriter pdbWriter);
    public bool ShouldForwardNamespaceScopes(EmitContext context, IMethodBody methodBody, MethodDefinitionHandle methodHandle, IMethodDefinition& forwardToMethod);
    public Byte[] SerializeMethodDebugInfo(EmitContext context, IMethodBody methodBody, MethodDefinitionHandle methodHandle, bool emitEncInfo, bool suppressNewCustomDebugInfo, Boolean& emitExternNamespaces);
    internal static void SerializeCustomDebugInformation(CustomDebugInfoEncoder& encoder, EditAndContinueMethodDebugInformation debugInfo);
    private static ArrayBuilder`1<T> GetLocalInfoToSerialize(IMethodBody methodBody, Func`2<ILocalDefinition, bool> filter, Func`3<LocalScope, ILocalDefinition, T> getInfo);
    private static void SerializeDynamicLocalInfo(CustomDebugInfoEncoder& encoder, IMethodBody methodBody);
    private static void SerializeTupleElementNames(CustomDebugInfoEncoder& encoder, IMethodBody methodBody);
    private void SerializeNamespaceScopeMetadata(CustomDebugInfoEncoder& encoder, EmitContext context, IMethodBody methodBody);
    private bool ShouldForwardToPreviousMethodWithUsingInfo(EmitContext context, IMethodBody methodBody);
    [CompilerGeneratedAttribute]
internal static Byte[] <SerializeDynamicLocalInfo>g__GetDynamicFlags|10_0(ILocalDefinition local);
}
internal class Microsoft.Cci.DebugSourceDocument : object {
    internal static Guid CorSymLanguageTypeCSharp;
    internal static Guid CorSymLanguageTypeBasic;
    private static Guid s_corSymLanguageVendorMicrosoft;
    private static Guid s_corSymDocumentTypeText;
    private string _location;
    private Guid _language;
    private bool _isComputedChecksum;
    private Task`1<DebugSourceInfo> _sourceInfo;
    public Guid DocumentType { get; }
    public Guid Language { get; }
    public Guid LanguageVendor { get; }
    public string Location { get; }
    internal bool IsComputedChecksum { get; }
    public DebugSourceDocument(string location, Guid language);
    public DebugSourceDocument(string location, Guid language, Func`1<DebugSourceInfo> sourceInfo);
    public DebugSourceDocument(string location, Guid language, ImmutableArray`1<byte> checksum, Guid algorithm);
    private static DebugSourceDocument();
    internal static bool IsSupportedAlgorithm(SourceHashAlgorithm algorithm);
    internal static Guid GetAlgorithmGuid(SourceHashAlgorithm algorithm);
    public Guid get_DocumentType();
    public Guid get_Language();
    public Guid get_LanguageVendor();
    public string get_Location();
    public DebugSourceInfo GetSourceInfo();
    internal bool get_IsComputedChecksum();
}
internal class Microsoft.Cci.DebugSourceInfo : ValueType {
    public Guid ChecksumAlgorithmId;
    public ImmutableArray`1<byte> Checksum;
    public ImmutableArray`1<byte> EmbeddedTextBlob;
    public DebugSourceInfo(ImmutableArray`1<byte> checksum, SourceHashAlgorithm checksumAlgorithm, ImmutableArray`1<byte> embeddedTextBlob);
    public DebugSourceInfo(ImmutableArray`1<byte> checksum, Guid checksumAlgorithmId, ImmutableArray`1<byte> embeddedTextBlob);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.Cci.DefinitionWithLocation : ValueType {
    public IDefinition Definition;
    public int StartLine;
    public int StartColumn;
    public int EndLine;
    public int EndColumn;
    public DefinitionWithLocation(IDefinition definition, int startLine, int startColumn, int endLine, int endColumn);
    private string GetDebuggerDisplay();
}
internal class Microsoft.Cci.DynamicAnalysisDataWriter : object {
    private Dictionary`2<ImmutableArray`1<byte>, BlobHandle> _blobs;
    private int _blobHeapSize;
    private Dictionary`2<Guid, GuidHandle> _guids;
    private BlobBuilder _guidWriter;
    private List`1<DocumentRow> _documentTable;
    private List`1<MethodRow> _methodTable;
    private Dictionary`2<DebugSourceDocument, int> _documentIndex;
    private static Char[] s_separator1;
    private static Char[] s_separator2;
    public DynamicAnalysisDataWriter(int documentCountEstimate, int methodCountEstimate);
    private static DynamicAnalysisDataWriter();
    internal void SerializeMethodDynamicAnalysisData(IMethodBody bodyOpt);
    private BlobHandle GetOrAddBlob(BlobBuilder builder);
    private BlobHandle GetOrAddBlob(ImmutableArray`1<byte> blob);
    private static int GetCompressedIntegerLength(int length);
    private GuidHandle GetOrAddGuid(Guid guid);
    private BlobHandle SerializeSpans(ImmutableArray`1<SourceSpan> spans, Dictionary`2<DebugSourceDocument, int> documentIndex);
    private void SerializeDeltaLinesAndColumns(BlobBuilder writer, SourceSpan span);
    internal int GetOrAddDocument(DebugSourceDocument document);
    private int GetOrAddDocument(DebugSourceDocument document, Dictionary`2<DebugSourceDocument, int> index);
    private BlobHandle SerializeDocumentName(string name);
    private static int Count(string str, char c);
    internal void SerializeMetadataTables(BlobBuilder writer);
    private void WriteBlobHeap(BlobBuilder builder);
    private void SerializeHeader(BlobBuilder writer, Sizes sizes);
    private void SerializeDocumentTable(BlobBuilder writer, Sizes sizes);
    private void SerializeMethodTable(BlobBuilder writer, Sizes sizes);
}
internal abstract class Microsoft.Cci.ExceptionHandlerRegion : object {
    [CompilerGeneratedAttribute]
private int <TryStartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TryEndOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HandlerStartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HandlerEndOffset>k__BackingField;
    public int TryStartOffset { get; }
    public int TryEndOffset { get; }
    public int HandlerStartOffset { get; }
    public int HandlerEndOffset { get; }
    public int HandlerLength { get; }
    public int TryLength { get; }
    public ExceptionRegionKind HandlerKind { get; }
    public ITypeReference ExceptionType { get; }
    public int FilterDecisionStartOffset { get; }
    public ExceptionHandlerRegion(int tryStartOffset, int tryEndOffset, int handlerStartOffset, int handlerEndOffset);
    [CompilerGeneratedAttribute]
public int get_TryStartOffset();
    [CompilerGeneratedAttribute]
public int get_TryEndOffset();
    [CompilerGeneratedAttribute]
public int get_HandlerStartOffset();
    [CompilerGeneratedAttribute]
public int get_HandlerEndOffset();
    public int get_HandlerLength();
    public int get_TryLength();
    public abstract virtual ExceptionRegionKind get_HandlerKind();
    public virtual ITypeReference get_ExceptionType();
    public virtual int get_FilterDecisionStartOffset();
}
internal class Microsoft.Cci.ExceptionHandlerRegionCatch : ExceptionHandlerRegion {
    private ITypeReference _exceptionType;
    public ExceptionRegionKind HandlerKind { get; }
    public ITypeReference ExceptionType { get; }
    public ExceptionHandlerRegionCatch(int tryStartOffset, int tryEndOffset, int handlerStartOffset, int handlerEndOffset, ITypeReference exceptionType);
    public virtual ExceptionRegionKind get_HandlerKind();
    public virtual ITypeReference get_ExceptionType();
}
internal class Microsoft.Cci.ExceptionHandlerRegionFault : ExceptionHandlerRegion {
    public ExceptionRegionKind HandlerKind { get; }
    public ExceptionHandlerRegionFault(int tryStartOffset, int tryEndOffset, int handlerStartOffset, int handlerEndOffset);
    public virtual ExceptionRegionKind get_HandlerKind();
}
internal class Microsoft.Cci.ExceptionHandlerRegionFilter : ExceptionHandlerRegion {
    private int _filterDecisionStartOffset;
    public ExceptionRegionKind HandlerKind { get; }
    public int FilterDecisionStartOffset { get; }
    public ExceptionHandlerRegionFilter(int tryStartOffset, int tryEndOffset, int handlerStartOffset, int handlerEndOffset, int filterDecisionStartOffset);
    public virtual ExceptionRegionKind get_HandlerKind();
    public virtual int get_FilterDecisionStartOffset();
}
internal class Microsoft.Cci.ExceptionHandlerRegionFinally : ExceptionHandlerRegion {
    public ExceptionRegionKind HandlerKind { get; }
    public ExceptionHandlerRegionFinally(int tryStartOffset, int tryEndOffset, int handlerStartOffset, int handlerEndOffset);
    public virtual ExceptionRegionKind get_HandlerKind();
}
internal class Microsoft.Cci.ExportedType : ValueType {
    public ITypeReference Type;
    public bool IsForwarder;
    public int ParentIndex;
    public ExportedType(ITypeReference type, int parentIndex, bool isForwarder);
}
internal class Microsoft.Cci.ExtendedPEBuilder : ManagedPEBuilder {
    private static string MvidSectionName;
    public static int SizeOfGuid;
    private Blob _mvidSectionFixup;
    private bool _withMvidSection;
    public ExtendedPEBuilder(PEHeaderBuilder header, MetadataRootBuilder metadataRootBuilder, BlobBuilder ilStream, BlobBuilder mappedFieldData, BlobBuilder managedResources, ResourceSectionBuilder nativeResources, DebugDirectoryBuilder debugDirectoryBuilder, int strongNameSignatureSize, MethodDefinitionHandle entryPoint, CorFlags flags, Func`2<IEnumerable`1<Blob>, BlobContentId> deterministicIdProvider, bool withMvidSection);
    protected virtual ImmutableArray`1<Section> CreateSections();
    protected virtual BlobBuilder SerializeSection(string name, SectionLocation location);
    internal BlobContentId Serialize(BlobBuilder peBlob, Blob& mvidSectionFixup);
    private BlobBuilder SerializeMvidSection(SectionLocation location);
}
[ExtensionAttribute]
internal static class Microsoft.Cci.Extensions : object {
    [ExtensionAttribute]
internal static bool HasBody(IMethodDefinition methodDef);
    [ExtensionAttribute]
public static bool ShouldInclude(ITypeDefinitionMember member, EmitContext context);
}
internal class Microsoft.Cci.FullMetadataWriter : MetadataWriter {
    private DefinitionIndex`1<ITypeDefinition> _typeDefs;
    private DefinitionIndex`1<IEventDefinition> _eventDefs;
    private DefinitionIndex`1<IFieldDefinition> _fieldDefs;
    private DefinitionIndex`1<IMethodDefinition> _methodDefs;
    private DefinitionIndex`1<IPropertyDefinition> _propertyDefs;
    private DefinitionIndex`1<IParameterDefinition> _parameterDefs;
    private DefinitionIndex`1<IGenericParameter> _genericParameters;
    private Dictionary`2<ITypeDefinition, int> _fieldDefIndex;
    private Dictionary`2<ITypeDefinition, int> _methodDefIndex;
    private Dictionary`2<IMethodDefinition, int> _parameterListIndex;
    private HeapOrReferenceIndex`1<AssemblyIdentity> _assemblyRefIndex;
    private HeapOrReferenceIndex`1<string> _moduleRefIndex;
    private InstanceAndStructuralReferenceIndex`1<ITypeMemberReference> _memberRefIndex;
    private InstanceAndStructuralReferenceIndex`1<IGenericMethodInstanceReference> _methodSpecIndex;
    private HeapOrReferenceIndex`1<ITypeReference> _typeRefIndex;
    private InstanceAndStructuralReferenceIndex`1<ITypeReference> _typeSpecIndex;
    private HeapOrReferenceIndex`1<BlobHandle> _standAloneSignatureIndex;
    protected ushort Generation { get; }
    protected Guid EncId { get; }
    protected Guid EncBaseId { get; }
    protected int GreatestMethodDefIndex { get; }
    private FullMetadataWriter(EmitContext context, MetadataBuilder builder, MetadataBuilder debugBuilderOpt, DynamicAnalysisDataWriter dynamicAnalysisDataWriterOpt, CommonMessageProvider messageProvider, bool metadataOnly, bool deterministic, bool emitTestCoverageData, CancellationToken cancellationToken);
    public static MetadataWriter Create(EmitContext context, CommonMessageProvider messageProvider, bool metadataOnly, bool deterministic, bool emitTestCoverageData, bool hasPdbStream, CancellationToken cancellationToken);
    protected virtual ushort get_Generation();
    protected virtual Guid get_EncId();
    protected virtual Guid get_EncBaseId();
    protected virtual bool TryGetTypeDefinitionHandle(ITypeDefinition def, TypeDefinitionHandle& handle);
    protected virtual TypeDefinitionHandle GetTypeDefinitionHandle(ITypeDefinition def);
    protected virtual ITypeDefinition GetTypeDef(TypeDefinitionHandle handle);
    protected virtual IReadOnlyList`1<ITypeDefinition> GetTypeDefs();
    protected virtual EventDefinitionHandle GetEventDefinitionHandle(IEventDefinition def);
    protected virtual IReadOnlyList`1<IEventDefinition> GetEventDefs();
    protected virtual FieldDefinitionHandle GetFieldDefinitionHandle(IFieldDefinition def);
    protected virtual IReadOnlyList`1<IFieldDefinition> GetFieldDefs();
    protected virtual bool TryGetMethodDefinitionHandle(IMethodDefinition def, MethodDefinitionHandle& handle);
    protected virtual MethodDefinitionHandle GetMethodDefinitionHandle(IMethodDefinition def);
    protected virtual IMethodDefinition GetMethodDef(MethodDefinitionHandle handle);
    protected virtual IReadOnlyList`1<IMethodDefinition> GetMethodDefs();
    protected virtual PropertyDefinitionHandle GetPropertyDefIndex(IPropertyDefinition def);
    protected virtual IReadOnlyList`1<IPropertyDefinition> GetPropertyDefs();
    protected virtual ParameterHandle GetParameterHandle(IParameterDefinition def);
    protected virtual IReadOnlyList`1<IParameterDefinition> GetParameterDefs();
    protected virtual IReadOnlyList`1<IGenericParameter> GetGenericParameters();
    protected virtual FieldDefinitionHandle GetFirstFieldDefinitionHandle(INamedTypeDefinition typeDef);
    protected virtual MethodDefinitionHandle GetFirstMethodDefinitionHandle(INamedTypeDefinition typeDef);
    protected virtual ParameterHandle GetFirstParameterHandle(IMethodDefinition methodDef);
    protected virtual AssemblyReferenceHandle GetOrAddAssemblyReferenceHandle(IAssemblyReference reference);
    protected virtual IReadOnlyList`1<AssemblyIdentity> GetAssemblyRefs();
    protected virtual ModuleReferenceHandle GetOrAddModuleReferenceHandle(string reference);
    protected virtual IReadOnlyList`1<string> GetModuleRefs();
    protected virtual MemberReferenceHandle GetOrAddMemberReferenceHandle(ITypeMemberReference reference);
    protected virtual IReadOnlyList`1<ITypeMemberReference> GetMemberRefs();
    protected virtual MethodSpecificationHandle GetOrAddMethodSpecificationHandle(IGenericMethodInstanceReference reference);
    protected virtual IReadOnlyList`1<IGenericMethodInstanceReference> GetMethodSpecs();
    protected virtual int get_GreatestMethodDefIndex();
    protected virtual bool TryGetTypeReferenceHandle(ITypeReference reference, TypeReferenceHandle& handle);
    protected virtual TypeReferenceHandle GetOrAddTypeReferenceHandle(ITypeReference reference);
    protected virtual IReadOnlyList`1<ITypeReference> GetTypeRefs();
    protected virtual TypeSpecificationHandle GetOrAddTypeSpecificationHandle(ITypeReference reference);
    protected virtual IReadOnlyList`1<ITypeReference> GetTypeSpecs();
    protected virtual StandaloneSignatureHandle GetOrAddStandaloneSignatureHandle(BlobHandle blobIndex);
    protected virtual IReadOnlyList`1<BlobHandle> GetStandaloneSignatureBlobHandles();
    protected virtual ReferenceIndexer CreateReferenceVisitor();
    protected virtual void ReportReferencesToAddedSymbols();
    protected virtual void PopulateEncLogTableRows(ImmutableArray`1<int> rowCounts);
    protected virtual void PopulateEncMapTableRows(ImmutableArray`1<int> rowCounts);
    protected virtual void PopulateEventMapTableRows();
    protected virtual void PopulatePropertyMapTableRows();
    protected virtual IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypes(CommonPEModuleBuilder module);
    protected virtual void CreateIndicesForNonTypeMembers(ITypeDefinition typeDef);
    private void CreateIndicesFor(IMethodDefinition methodDef);
}
internal interface Microsoft.Cci.IArrayTypeReference {
    public bool IsSZArray { get; }
    public ImmutableArray`1<int> LowerBounds { get; }
    public int Rank { get; }
    public ImmutableArray`1<int> Sizes { get; }
    public abstract virtual ITypeReference GetElementType(EmitContext context);
    public abstract virtual bool get_IsSZArray();
    public abstract virtual ImmutableArray`1<int> get_LowerBounds();
    public abstract virtual int get_Rank();
    public abstract virtual ImmutableArray`1<int> get_Sizes();
}
internal interface Microsoft.Cci.IAssemblyReference {
    public AssemblyIdentity Identity { get; }
    public Version AssemblyVersionPattern { get; }
    public abstract virtual AssemblyIdentity get_Identity();
    public abstract virtual Version get_AssemblyVersionPattern();
}
internal interface Microsoft.Cci.IContextualNamedEntity {
    public abstract virtual void AssociateWithMetadataWriter(MetadataWriter metadataWriter);
}
internal interface Microsoft.Cci.ICustomAttribute {
    public int ArgumentCount { get; }
    public ushort NamedArgumentCount { get; }
    public bool AllowMultiple { get; }
    public abstract virtual ImmutableArray`1<IMetadataExpression> GetArguments(EmitContext context);
    public abstract virtual IMethodReference Constructor(EmitContext context, bool reportDiagnostics);
    public abstract virtual ImmutableArray`1<IMetadataNamedArgument> GetNamedArguments(EmitContext context);
    public abstract virtual int get_ArgumentCount();
    public abstract virtual ushort get_NamedArgumentCount();
    public abstract virtual ITypeReference GetType(EmitContext context);
    public abstract virtual bool get_AllowMultiple();
}
internal interface Microsoft.Cci.ICustomModifier {
    public bool IsOptional { get; }
    public abstract virtual bool get_IsOptional();
    public abstract virtual ITypeReference GetModifier(EmitContext context);
}
internal interface Microsoft.Cci.IDefinition {
}
internal interface Microsoft.Cci.IEventDefinition {
    public IMethodReference Adder { get; }
    public IMethodReference Caller { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public IMethodReference Remover { get; }
    public abstract virtual IEnumerable`1<IMethodReference> GetAccessors(EmitContext context);
    public abstract virtual IMethodReference get_Adder();
    public abstract virtual IMethodReference get_Caller();
    public abstract virtual bool get_IsRuntimeSpecial();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual IMethodReference get_Remover();
    public abstract virtual ITypeReference GetType(EmitContext context);
}
internal interface Microsoft.Cci.IFieldDefinition {
    public ImmutableArray`1<byte> MappedData { get; }
    public bool IsCompileTimeConstant { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsNotSerialized { get; }
    public bool IsReadOnly { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ImmutableArray`1<byte> MarshallingDescriptor { get; }
    public int Offset { get; }
    public abstract virtual MetadataConstant GetCompileTimeValue(EmitContext context);
    public abstract virtual ImmutableArray`1<byte> get_MappedData();
    public abstract virtual bool get_IsCompileTimeConstant();
    public abstract virtual bool get_IsMarshalledExplicitly();
    public abstract virtual bool get_IsNotSerialized();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsRuntimeSpecial();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsStatic();
    public abstract virtual IMarshallingInformation get_MarshallingInformation();
    public abstract virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    public abstract virtual int get_Offset();
}
internal interface Microsoft.Cci.IFieldReference {
    public ISpecializedFieldReference AsSpecializedFieldReference { get; }
    public bool IsContextualNamedEntity { get; }
    public abstract virtual ITypeReference GetType(EmitContext context);
    public abstract virtual IFieldDefinition GetResolvedField(EmitContext context);
    public abstract virtual ISpecializedFieldReference get_AsSpecializedFieldReference();
    public abstract virtual bool get_IsContextualNamedEntity();
}
internal interface Microsoft.Cci.IFileReference {
    public bool HasMetadata { get; }
    public string FileName { get; }
    public abstract virtual bool get_HasMetadata();
    public abstract virtual string get_FileName();
    public abstract virtual ImmutableArray`1<byte> GetHashValue(AssemblyHashAlgorithm algorithmId);
}
internal interface Microsoft.Cci.IGenericMethodInstanceReference {
    public abstract virtual IEnumerable`1<ITypeReference> GetGenericArguments(EmitContext context);
    public abstract virtual IMethodReference GetGenericMethod(EmitContext context);
}
internal interface Microsoft.Cci.IGenericMethodParameter {
    public IMethodDefinition DefiningMethod { get; }
    public abstract virtual IMethodDefinition get_DefiningMethod();
}
internal interface Microsoft.Cci.IGenericMethodParameterReference {
    public IMethodReference DefiningMethod { get; }
    public abstract virtual IMethodReference get_DefiningMethod();
}
internal interface Microsoft.Cci.IGenericParameter {
    public bool MustBeReferenceType { get; }
    public bool MustBeValueType { get; }
    public bool MustHaveDefaultConstructor { get; }
    public TypeParameterVariance Variance { get; }
    public IGenericMethodParameter AsGenericMethodParameter { get; }
    public IGenericTypeParameter AsGenericTypeParameter { get; }
    public abstract virtual IEnumerable`1<TypeReferenceWithAttributes> GetConstraints(EmitContext context);
    public abstract virtual bool get_MustBeReferenceType();
    public abstract virtual bool get_MustBeValueType();
    public abstract virtual bool get_MustHaveDefaultConstructor();
    public abstract virtual TypeParameterVariance get_Variance();
    public abstract virtual IGenericMethodParameter get_AsGenericMethodParameter();
    public abstract virtual IGenericTypeParameter get_AsGenericTypeParameter();
}
internal interface Microsoft.Cci.IGenericParameterReference {
}
internal interface Microsoft.Cci.IGenericTypeInstanceReference {
    public abstract virtual ImmutableArray`1<ITypeReference> GetGenericArguments(EmitContext context);
    public abstract virtual INamedTypeReference GetGenericType(EmitContext context);
}
internal interface Microsoft.Cci.IGenericTypeParameter {
    public ITypeDefinition DefiningType { get; }
    public abstract virtual ITypeDefinition get_DefiningType();
}
internal interface Microsoft.Cci.IGenericTypeParameterReference {
    public ITypeReference DefiningType { get; }
    public abstract virtual ITypeReference get_DefiningType();
}
internal interface Microsoft.Cci.IGlobalFieldDefinition {
}
internal interface Microsoft.Cci.IGlobalMethodDefinition {
    public string Name { get; }
    public abstract virtual string get_Name();
}
internal interface Microsoft.Cci.IImportScope {
    public IImportScope Parent { get; }
    public abstract virtual ImmutableArray`1<UsedNamespaceOrType> GetUsedNamespaces();
    public abstract virtual IImportScope get_Parent();
}
internal interface Microsoft.Cci.ILocalDefinition {
    public MetadataConstant CompileTimeValue { get; }
    public ImmutableArray`1<ICustomModifier> CustomModifiers { get; }
    public bool IsPinned { get; }
    public bool IsReference { get; }
    public LocalSlotConstraints Constraints { get; }
    public LocalVariableAttributes PdbAttributes { get; }
    public ImmutableArray`1<bool> DynamicTransformFlags { get; }
    public ImmutableArray`1<string> TupleElementNames { get; }
    public ITypeReference Type { get; }
    public Location Location { get; }
    public int SlotIndex { get; }
    public Byte[] Signature { get; }
    public LocalSlotDebugInfo SlotInfo { get; }
    public abstract virtual MetadataConstant get_CompileTimeValue();
    public abstract virtual ImmutableArray`1<ICustomModifier> get_CustomModifiers();
    public abstract virtual bool get_IsPinned();
    public abstract virtual bool get_IsReference();
    public abstract virtual LocalSlotConstraints get_Constraints();
    public abstract virtual LocalVariableAttributes get_PdbAttributes();
    public abstract virtual ImmutableArray`1<bool> get_DynamicTransformFlags();
    public abstract virtual ImmutableArray`1<string> get_TupleElementNames();
    public abstract virtual ITypeReference get_Type();
    public abstract virtual Location get_Location();
    public abstract virtual int get_SlotIndex();
    public abstract virtual Byte[] get_Signature();
    public abstract virtual LocalSlotDebugInfo get_SlotInfo();
}
internal interface Microsoft.Cci.IMarshallingInformation {
    public string CustomMarshallerRuntimeArgument { get; }
    public UnmanagedType ElementType { get; }
    public int IidParameterIndex { get; }
    public UnmanagedType UnmanagedType { get; }
    public int NumberOfElements { get; }
    public short ParamIndex { get; }
    public VarEnum SafeArrayElementSubtype { get; }
    public abstract virtual object GetCustomMarshaller(EmitContext context);
    public abstract virtual string get_CustomMarshallerRuntimeArgument();
    public abstract virtual UnmanagedType get_ElementType();
    public abstract virtual int get_IidParameterIndex();
    public abstract virtual UnmanagedType get_UnmanagedType();
    public abstract virtual int get_NumberOfElements();
    public abstract virtual short get_ParamIndex();
    public abstract virtual VarEnum get_SafeArrayElementSubtype();
    public abstract virtual ITypeReference GetSafeArrayElementUserDefinedSubtype(EmitContext context);
}
internal interface Microsoft.Cci.IMetadataExpression {
    public ITypeReference Type { get; }
    public abstract virtual void Dispatch(MetadataVisitor visitor);
    public abstract virtual ITypeReference get_Type();
}
internal interface Microsoft.Cci.IMetadataNamedArgument {
    public string ArgumentName { get; }
    public IMetadataExpression ArgumentValue { get; }
    public bool IsField { get; }
    public abstract virtual string get_ArgumentName();
    public abstract virtual IMetadataExpression get_ArgumentValue();
    public abstract virtual bool get_IsField();
}
internal interface Microsoft.Cci.IMethodBody {
    public ImmutableArray`1<ExceptionHandlerRegion> ExceptionRegions { get; }
    public bool LocalsAreZeroed { get; }
    public ImmutableArray`1<ILocalDefinition> LocalVariables { get; }
    public IMethodDefinition MethodDefinition { get; }
    public StateMachineMoveNextBodyDebugInfo MoveNextBodyInfo { get; }
    public ushort MaxStack { get; }
    public ImmutableArray`1<byte> IL { get; }
    public ImmutableArray`1<SequencePoint> SequencePoints { get; }
    public bool HasDynamicLocalVariables { get; }
    public ImmutableArray`1<LocalScope> LocalScopes { get; }
    public IImportScope ImportScope { get; }
    public DebugId MethodId { get; }
    public ImmutableArray`1<StateMachineHoistedLocalScope> StateMachineHoistedLocalScopes { get; }
    public string StateMachineTypeName { get; }
    public ImmutableArray`1<EncHoistedLocalInfo> StateMachineHoistedLocalSlots { get; }
    public ImmutableArray`1<ITypeReference> StateMachineAwaiterSlots { get; }
    public ImmutableArray`1<ClosureDebugInfo> ClosureDebugInfo { get; }
    public ImmutableArray`1<LambdaDebugInfo> LambdaDebugInfo { get; }
    public DynamicAnalysisMethodBodyData DynamicAnalysisData { get; }
    public abstract virtual ImmutableArray`1<ExceptionHandlerRegion> get_ExceptionRegions();
    public abstract virtual bool get_LocalsAreZeroed();
    public abstract virtual ImmutableArray`1<ILocalDefinition> get_LocalVariables();
    public abstract virtual IMethodDefinition get_MethodDefinition();
    public abstract virtual StateMachineMoveNextBodyDebugInfo get_MoveNextBodyInfo();
    public abstract virtual ushort get_MaxStack();
    public abstract virtual ImmutableArray`1<byte> get_IL();
    public abstract virtual ImmutableArray`1<SequencePoint> get_SequencePoints();
    public abstract virtual bool get_HasDynamicLocalVariables();
    public abstract virtual ImmutableArray`1<LocalScope> get_LocalScopes();
    public abstract virtual IImportScope get_ImportScope();
    public abstract virtual DebugId get_MethodId();
    public abstract virtual ImmutableArray`1<StateMachineHoistedLocalScope> get_StateMachineHoistedLocalScopes();
    public abstract virtual string get_StateMachineTypeName();
    public abstract virtual ImmutableArray`1<EncHoistedLocalInfo> get_StateMachineHoistedLocalSlots();
    public abstract virtual ImmutableArray`1<ITypeReference> get_StateMachineAwaiterSlots();
    public abstract virtual ImmutableArray`1<ClosureDebugInfo> get_ClosureDebugInfo();
    public abstract virtual ImmutableArray`1<LambdaDebugInfo> get_LambdaDebugInfo();
    public abstract virtual DynamicAnalysisMethodBodyData get_DynamicAnalysisData();
}
internal interface Microsoft.Cci.IMethodDefinition {
    public IEnumerable`1<IGenericMethodParameter> GenericParameters { get; }
    public bool IsImplicitlyDeclared { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool IsAbstract { get; }
    public bool IsAccessCheckedOnOverride { get; }
    public bool IsConstructor { get; }
    public bool IsExternal { get; }
    public bool IsHiddenBySignature { get; }
    public bool IsNewSlot { get; }
    public bool IsPlatformInvoke { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSealed { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public ImmutableArray`1<IParameterDefinition> Parameters { get; }
    public IPlatformInvokeInformation PlatformInvokeData { get; }
    public bool RequiresSecurityObject { get; }
    public bool ReturnValueIsMarshalledExplicitly { get; }
    public IMarshallingInformation ReturnValueMarshallingInformation { get; }
    public ImmutableArray`1<byte> ReturnValueMarshallingDescriptor { get; }
    public IEnumerable`1<SecurityAttribute> SecurityAttributes { get; }
    public INamespace ContainingNamespace { get; }
    public abstract virtual IMethodBody GetBody(EmitContext context);
    public abstract virtual IEnumerable`1<IGenericMethodParameter> get_GenericParameters();
    public abstract virtual bool get_IsImplicitlyDeclared();
    public abstract virtual bool get_HasDeclarativeSecurity();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsAccessCheckedOnOverride();
    public abstract virtual bool get_IsConstructor();
    public abstract virtual bool get_IsExternal();
    public abstract virtual bool get_IsHiddenBySignature();
    public abstract virtual bool get_IsNewSlot();
    public abstract virtual bool get_IsPlatformInvoke();
    public abstract virtual bool get_IsRuntimeSpecial();
    public abstract virtual bool get_IsSealed();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual MethodImplAttributes GetImplementationAttributes(EmitContext context);
    public abstract virtual ImmutableArray`1<IParameterDefinition> get_Parameters();
    public abstract virtual IPlatformInvokeInformation get_PlatformInvokeData();
    public abstract virtual bool get_RequiresSecurityObject();
    public abstract virtual IEnumerable`1<ICustomAttribute> GetReturnValueAttributes(EmitContext context);
    public abstract virtual bool get_ReturnValueIsMarshalledExplicitly();
    public abstract virtual IMarshallingInformation get_ReturnValueMarshallingInformation();
    public abstract virtual ImmutableArray`1<byte> get_ReturnValueMarshallingDescriptor();
    public abstract virtual IEnumerable`1<SecurityAttribute> get_SecurityAttributes();
    public abstract virtual INamespace get_ContainingNamespace();
}
internal interface Microsoft.Cci.IMethodReference {
    public bool AcceptsExtraArguments { get; }
    public ushort GenericParameterCount { get; }
    public bool IsGeneric { get; }
    public ImmutableArray`1<IParameterTypeInformation> ExtraParameters { get; }
    public IGenericMethodInstanceReference AsGenericMethodInstanceReference { get; }
    public ISpecializedMethodReference AsSpecializedMethodReference { get; }
    public abstract virtual bool get_AcceptsExtraArguments();
    public abstract virtual ushort get_GenericParameterCount();
    public abstract virtual bool get_IsGeneric();
    public abstract virtual IMethodDefinition GetResolvedMethod(EmitContext context);
    public abstract virtual ImmutableArray`1<IParameterTypeInformation> get_ExtraParameters();
    public abstract virtual IGenericMethodInstanceReference get_AsGenericMethodInstanceReference();
    public abstract virtual ISpecializedMethodReference get_AsSpecializedMethodReference();
}
internal interface Microsoft.Cci.IModifiedTypeReference {
    public ImmutableArray`1<ICustomModifier> CustomModifiers { get; }
    public ITypeReference UnmodifiedType { get; }
    public abstract virtual ImmutableArray`1<ICustomModifier> get_CustomModifiers();
    public abstract virtual ITypeReference get_UnmodifiedType();
}
internal interface Microsoft.Cci.IModuleReference {
    public abstract virtual IAssemblyReference GetContainingAssembly(EmitContext context);
}
internal interface Microsoft.Cci.INamedEntity {
    public string Name { get; }
    public abstract virtual string get_Name();
}
internal interface Microsoft.Cci.INamedTypeDefinition {
}
internal interface Microsoft.Cci.INamedTypeReference {
    public ushort GenericParameterCount { get; }
    public bool MangleName { get; }
    public abstract virtual ushort get_GenericParameterCount();
    public abstract virtual bool get_MangleName();
}
internal interface Microsoft.Cci.INamespace {
    public INamespace ContainingNamespace { get; }
    public abstract virtual INamespace get_ContainingNamespace();
}
internal interface Microsoft.Cci.INamespaceTypeDefinition {
    public bool IsPublic { get; }
    public abstract virtual bool get_IsPublic();
}
internal interface Microsoft.Cci.INamespaceTypeReference {
    public string NamespaceName { get; }
    public abstract virtual IUnitReference GetUnit(EmitContext context);
    public abstract virtual string get_NamespaceName();
}
internal interface Microsoft.Cci.INestedTypeDefinition {
}
internal interface Microsoft.Cci.INestedTypeReference {
}
internal class Microsoft.Cci.InheritedTypeParameter : object {
    private ushort _index;
    private ITypeDefinition _inheritingType;
    private IGenericTypeParameter _parentParameter;
    public ITypeDefinition DefiningType { get; }
    public bool MustBeReferenceType { get; }
    public bool MustBeValueType { get; }
    public bool MustHaveDefaultConstructor { get; }
    public TypeParameterVariance Variance { get; }
    public ushort Alignment { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool IsEnum { get; }
    public IArrayTypeReference AsArrayTypeReference { get; }
    public IGenericMethodParameter AsGenericMethodParameter { get; }
    public IGenericMethodParameterReference AsGenericMethodParameterReference { get; }
    public IGenericTypeInstanceReference AsGenericTypeInstanceReference { get; }
    public IGenericTypeParameter AsGenericTypeParameter { get; }
    public IGenericTypeParameterReference AsGenericTypeParameterReference { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    public ISpecializedNestedTypeReference AsSpecializedNestedTypeReference { get; }
    public IModifiedTypeReference AsModifiedTypeReference { get; }
    public IPointerTypeReference AsPointerTypeReference { get; }
    public TypeDefinitionHandle TypeDef { get; }
    public bool IsAlias { get; }
    public bool IsValueType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public ushort Index { get; }
    public string Name { get; }
    private ITypeReference Microsoft.Cci.IGenericTypeParameterReference.DefiningType { get; }
    public bool MangleName { get; }
    public bool IsNested { get; }
    public bool IsSpecializedNested { get; }
    public ITypeReference UnspecializedVersion { get; }
    public bool IsNamespaceTypeReference { get; }
    public bool IsGenericTypeInstance { get; }
    internal InheritedTypeParameter(ushort index, ITypeDefinition inheritingType, IGenericTypeParameter parentParameter);
    public sealed virtual ITypeDefinition get_DefiningType();
    public sealed virtual IEnumerable`1<TypeReferenceWithAttributes> GetConstraints(EmitContext context);
    public sealed virtual bool get_MustBeReferenceType();
    public sealed virtual bool get_MustBeValueType();
    public sealed virtual bool get_MustHaveDefaultConstructor();
    public sealed virtual TypeParameterVariance get_Variance();
    public ushort get_Alignment();
    public bool get_HasDeclarativeSecurity();
    public sealed virtual bool get_IsEnum();
    public IArrayTypeReference get_AsArrayTypeReference();
    public sealed virtual IGenericMethodParameter get_AsGenericMethodParameter();
    public sealed virtual IGenericMethodParameterReference get_AsGenericMethodParameterReference();
    public sealed virtual IGenericTypeInstanceReference get_AsGenericTypeInstanceReference();
    public sealed virtual IGenericTypeParameter get_AsGenericTypeParameter();
    public sealed virtual IGenericTypeParameterReference get_AsGenericTypeParameterReference();
    public sealed virtual INamespaceTypeDefinition AsNamespaceTypeDefinition(EmitContext context);
    public sealed virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    public sealed virtual INestedTypeDefinition AsNestedTypeDefinition(EmitContext context);
    public sealed virtual INestedTypeReference get_AsNestedTypeReference();
    public sealed virtual ISpecializedNestedTypeReference get_AsSpecializedNestedTypeReference();
    public IModifiedTypeReference get_AsModifiedTypeReference();
    public IPointerTypeReference get_AsPointerTypeReference();
    public sealed virtual ITypeDefinition AsTypeDefinition(EmitContext context);
    public sealed virtual IDefinition AsDefinition(EmitContext context);
    public sealed virtual IEnumerable`1<ICustomAttribute> GetAttributes(EmitContext context);
    public sealed virtual void Dispatch(MetadataVisitor visitor);
    public sealed virtual TypeDefinitionHandle get_TypeDef();
    public bool get_IsAlias();
    public sealed virtual bool get_IsValueType();
    public sealed virtual ITypeDefinition GetResolvedType(EmitContext context);
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual ushort get_Index();
    public sealed virtual string get_Name();
    private sealed virtual override ITypeReference Microsoft.Cci.IGenericTypeParameterReference.get_DefiningType();
    public bool get_MangleName();
    public bool get_IsNested();
    public bool get_IsSpecializedNested();
    public ITypeReference get_UnspecializedVersion();
    public bool get_IsNamespaceTypeReference();
    public bool get_IsGenericTypeInstance();
}
internal static class Microsoft.Cci.InstructionOperandTypes : object {
    internal static Byte[] OneByte;
    internal static Byte[] TwoByte;
    private static InstructionOperandTypes();
    internal static OperandType ReadOperandType(ImmutableArray`1<byte> il, Int32& position);
}
internal interface Microsoft.Cci.IParameterDefinition {
    public bool HasDefaultValue { get; }
    public bool IsIn { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ImmutableArray`1<byte> MarshallingDescriptor { get; }
    public abstract virtual MetadataConstant GetDefaultValue(EmitContext context);
    public abstract virtual bool get_HasDefaultValue();
    public abstract virtual bool get_IsIn();
    public abstract virtual bool get_IsMarshalledExplicitly();
    public abstract virtual bool get_IsOptional();
    public abstract virtual bool get_IsOut();
    public abstract virtual IMarshallingInformation get_MarshallingInformation();
    public abstract virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
}
internal interface Microsoft.Cci.IParameterListEntry {
    public ushort Index { get; }
    public abstract virtual ushort get_Index();
}
internal interface Microsoft.Cci.IParameterTypeInformation {
    public ImmutableArray`1<ICustomModifier> CustomModifiers { get; }
    public ImmutableArray`1<ICustomModifier> RefCustomModifiers { get; }
    public bool IsByReference { get; }
    public abstract virtual ImmutableArray`1<ICustomModifier> get_CustomModifiers();
    public abstract virtual ImmutableArray`1<ICustomModifier> get_RefCustomModifiers();
    public abstract virtual bool get_IsByReference();
    public abstract virtual ITypeReference GetType(EmitContext context);
}
internal interface Microsoft.Cci.IPlatformInvokeInformation {
    public string ModuleName { get; }
    public string EntryPointName { get; }
    public MethodImportAttributes Flags { get; }
    public abstract virtual string get_ModuleName();
    public abstract virtual string get_EntryPointName();
    public abstract virtual MethodImportAttributes get_Flags();
}
internal interface Microsoft.Cci.IPointerTypeReference {
    public abstract virtual ITypeReference GetTargetType(EmitContext context);
}
internal interface Microsoft.Cci.IPropertyDefinition {
    public MetadataConstant DefaultValue { get; }
    public IMethodReference Getter { get; }
    public bool HasDefaultValue { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public ImmutableArray`1<IParameterDefinition> Parameters { get; }
    public IMethodReference Setter { get; }
    public abstract virtual IEnumerable`1<IMethodReference> GetAccessors(EmitContext context);
    public abstract virtual MetadataConstant get_DefaultValue();
    public abstract virtual IMethodReference get_Getter();
    public abstract virtual bool get_HasDefaultValue();
    public abstract virtual bool get_IsRuntimeSpecial();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual ImmutableArray`1<IParameterDefinition> get_Parameters();
    public abstract virtual IMethodReference get_Setter();
}
internal interface Microsoft.Cci.IReference {
    public abstract virtual IEnumerable`1<ICustomAttribute> GetAttributes(EmitContext context);
    public abstract virtual void Dispatch(MetadataVisitor visitor);
    public abstract virtual IDefinition AsDefinition(EmitContext context);
}
internal interface Microsoft.Cci.ISignature {
    public CallingConvention CallingConvention { get; }
    public ushort ParameterCount { get; }
    public ImmutableArray`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    public ImmutableArray`1<ICustomModifier> RefCustomModifiers { get; }
    public bool ReturnValueIsByRef { get; }
    public abstract virtual CallingConvention get_CallingConvention();
    public abstract virtual ushort get_ParameterCount();
    public abstract virtual ImmutableArray`1<IParameterTypeInformation> GetParameters(EmitContext context);
    public abstract virtual ImmutableArray`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public abstract virtual ImmutableArray`1<ICustomModifier> get_RefCustomModifiers();
    public abstract virtual bool get_ReturnValueIsByRef();
    public abstract virtual ITypeReference GetType(EmitContext context);
}
internal interface Microsoft.Cci.ISpecializedEventDefinition {
    public IEventDefinition UnspecializedVersion { get; }
    public abstract virtual IEventDefinition get_UnspecializedVersion();
}
internal interface Microsoft.Cci.ISpecializedFieldReference {
    public IFieldReference UnspecializedVersion { get; }
    public abstract virtual IFieldReference get_UnspecializedVersion();
}
internal interface Microsoft.Cci.ISpecializedMethodReference {
    public IMethodReference UnspecializedVersion { get; }
    public abstract virtual IMethodReference get_UnspecializedVersion();
}
internal interface Microsoft.Cci.ISpecializedNestedTypeReference {
    public abstract virtual INestedTypeReference GetUnspecializedVersion(EmitContext context);
}
internal interface Microsoft.Cci.ISpecializedPropertyDefinition {
    public IPropertyDefinition UnspecializedVersion { get; }
    public abstract virtual IPropertyDefinition get_UnspecializedVersion();
}
internal static class Microsoft.Cci.IteratorHelper : object {
    public static bool EnumerableIsNotEmpty(IEnumerable`1<T> enumerable);
    public static bool EnumerableIsEmpty(IEnumerable`1<T> enumerable);
    public static UInt32 EnumerableCount(IEnumerable`1<T> enumerable);
}
internal interface Microsoft.Cci.ITypeDefinition {
    public ushort Alignment { get; }
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsComObject { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsWindowsRuntimeImport { get; }
    public bool IsSealed { get; }
    public LayoutKind Layout { get; }
    public IEnumerable`1<SecurityAttribute> SecurityAttributes { get; }
    public UInt32 SizeOf { get; }
    public CharSet StringFormat { get; }
    public abstract virtual ushort get_Alignment();
    public abstract virtual ITypeReference GetBaseClass(EmitContext context);
    public abstract virtual IEnumerable`1<IEventDefinition> GetEvents(EmitContext context);
    public abstract virtual IEnumerable`1<MethodImplementation> GetExplicitImplementationOverrides(EmitContext context);
    public abstract virtual IEnumerable`1<IFieldDefinition> GetFields(EmitContext context);
    public abstract virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public abstract virtual ushort get_GenericParameterCount();
    public abstract virtual bool get_HasDeclarativeSecurity();
    public abstract virtual IEnumerable`1<TypeReferenceWithAttributes> Interfaces(EmitContext context);
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsBeforeFieldInit();
    public abstract virtual bool get_IsComObject();
    public abstract virtual bool get_IsGeneric();
    public abstract virtual bool get_IsInterface();
    public abstract virtual bool get_IsRuntimeSpecial();
    public abstract virtual bool get_IsSerializable();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual bool get_IsWindowsRuntimeImport();
    public abstract virtual bool get_IsSealed();
    public abstract virtual LayoutKind get_Layout();
    public abstract virtual IEnumerable`1<IMethodDefinition> GetMethods(EmitContext context);
    public abstract virtual IEnumerable`1<INestedTypeDefinition> GetNestedTypes(EmitContext context);
    public abstract virtual IEnumerable`1<IPropertyDefinition> GetProperties(EmitContext context);
    public abstract virtual IEnumerable`1<SecurityAttribute> get_SecurityAttributes();
    public abstract virtual UInt32 get_SizeOf();
    public abstract virtual CharSet get_StringFormat();
}
internal interface Microsoft.Cci.ITypeDefinitionMember {
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public abstract virtual ITypeDefinition get_ContainingTypeDefinition();
    public abstract virtual TypeMemberVisibility get_Visibility();
}
internal interface Microsoft.Cci.ITypeMemberReference {
    public abstract virtual ITypeReference GetContainingType(EmitContext context);
}
internal interface Microsoft.Cci.ITypeReference {
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public TypeDefinitionHandle TypeDef { get; }
    public IGenericMethodParameterReference AsGenericMethodParameterReference { get; }
    public IGenericTypeInstanceReference AsGenericTypeInstanceReference { get; }
    public IGenericTypeParameterReference AsGenericTypeParameterReference { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    public ISpecializedNestedTypeReference AsSpecializedNestedTypeReference { get; }
    public abstract virtual bool get_IsEnum();
    public abstract virtual bool get_IsValueType();
    public abstract virtual ITypeDefinition GetResolvedType(EmitContext context);
    public abstract virtual PrimitiveTypeCode get_TypeCode();
    public abstract virtual TypeDefinitionHandle get_TypeDef();
    public abstract virtual IGenericMethodParameterReference get_AsGenericMethodParameterReference();
    public abstract virtual IGenericTypeInstanceReference get_AsGenericTypeInstanceReference();
    public abstract virtual IGenericTypeParameterReference get_AsGenericTypeParameterReference();
    public abstract virtual INamespaceTypeDefinition AsNamespaceTypeDefinition(EmitContext context);
    public abstract virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    public abstract virtual INestedTypeDefinition AsNestedTypeDefinition(EmitContext context);
    public abstract virtual INestedTypeReference get_AsNestedTypeReference();
    public abstract virtual ISpecializedNestedTypeReference get_AsSpecializedNestedTypeReference();
    public abstract virtual ITypeDefinition AsTypeDefinition(EmitContext context);
}
[ExtensionAttribute]
internal static class Microsoft.Cci.ITypeReferenceExtensions : object {
    [ExtensionAttribute]
internal static void GetConsolidatedTypeArguments(ITypeReference typeReference, ArrayBuilder`1<ITypeReference> consolidatedTypeArguments, EmitContext context);
    [ExtensionAttribute]
internal static ITypeReference GetUninstantiatedGenericType(ITypeReference typeReference, EmitContext context);
    [ExtensionAttribute]
internal static bool IsTypeSpecification(ITypeReference typeReference);
}
internal interface Microsoft.Cci.IUnit {
}
internal interface Microsoft.Cci.IUnitReference {
}
internal interface Microsoft.Cci.IWin32Resource {
    public string TypeName { get; }
    public int TypeId { get; }
    public string Name { get; }
    public int Id { get; }
    public UInt32 LanguageId { get; }
    public UInt32 CodePage { get; }
    public IEnumerable`1<byte> Data { get; }
    public abstract virtual string get_TypeName();
    public abstract virtual int get_TypeId();
    public abstract virtual string get_Name();
    public abstract virtual int get_Id();
    public abstract virtual UInt32 get_LanguageId();
    public abstract virtual UInt32 get_CodePage();
    public abstract virtual IEnumerable`1<byte> get_Data();
}
internal class Microsoft.Cci.LocalScope : ValueType {
    public int StartOffset;
    public int EndOffset;
    private ImmutableArray`1<ILocalDefinition> _constants;
    private ImmutableArray`1<ILocalDefinition> _locals;
    public int Length { get; }
    public ImmutableArray`1<ILocalDefinition> Constants { get; }
    public ImmutableArray`1<ILocalDefinition> Variables { get; }
    internal LocalScope(int offset, int endOffset, ImmutableArray`1<ILocalDefinition> constants, ImmutableArray`1<ILocalDefinition> locals);
    public int get_Length();
    public ImmutableArray`1<ILocalDefinition> get_Constants();
    public ImmutableArray`1<ILocalDefinition> get_Variables();
}
internal class Microsoft.Cci.ManagedResource : object {
    private Func`1<Stream> _streamProvider;
    private IFileReference _fileReference;
    private UInt32 _offset;
    private string _name;
    private bool _isPublic;
    public IFileReference ExternalFile { get; }
    public UInt32 Offset { get; }
    public IEnumerable`1<ICustomAttribute> Attributes { get; }
    public bool IsPublic { get; }
    public string Name { get; }
    internal ManagedResource(string name, bool isPublic, Func`1<Stream> streamProvider, IFileReference fileReference, UInt32 offset);
    public void WriteData(BlobBuilder resourceWriter);
    public IFileReference get_ExternalFile();
    public UInt32 get_Offset();
    public IEnumerable`1<ICustomAttribute> get_Attributes();
    public bool get_IsPublic();
    public string get_Name();
}
internal class Microsoft.Cci.MemberRefComparer : object {
    private MetadataWriter _metadataWriter;
    internal MemberRefComparer(MetadataWriter metadataWriter);
    public sealed virtual bool Equals(ITypeMemberReference x, ITypeMemberReference y);
    public sealed virtual int GetHashCode(ITypeMemberReference memberRef);
}
internal abstract class Microsoft.Cci.MetadataVisitor : object {
    public EmitContext Context;
    public MetadataVisitor(EmitContext context);
    public virtual void Visit(IArrayTypeReference arrayTypeReference);
    public void Visit(IEnumerable`1<IAssemblyReference> assemblyReferences);
    public virtual void Visit(IAssemblyReference assemblyReference);
    public void Visit(IEnumerable`1<ICustomAttribute> customAttributes);
    public virtual void Visit(ICustomAttribute customAttribute);
    public void Visit(ImmutableArray`1<ICustomModifier> customModifiers);
    public virtual void Visit(ICustomModifier customModifier);
    public void Visit(IEnumerable`1<IEventDefinition> events);
    public virtual void Visit(IEventDefinition eventDefinition);
    public void Visit(IEnumerable`1<IFieldDefinition> fields);
    public virtual void Visit(IFieldDefinition fieldDefinition);
    public virtual void Visit(IFieldReference fieldReference);
    public void Visit(IEnumerable`1<IFileReference> fileReferences);
    public virtual void Visit(IFileReference fileReference);
    public virtual void Visit(IGenericMethodInstanceReference genericMethodInstanceReference);
    public void Visit(IEnumerable`1<IGenericMethodParameter> genericParameters);
    public virtual void Visit(IGenericMethodParameter genericMethodParameter);
    public virtual void Visit(IGenericMethodParameterReference genericMethodParameterReference);
    public virtual void Visit(IGenericParameter genericParameter);
    public abstract virtual void Visit(IGenericTypeInstanceReference genericTypeInstanceReference);
    public void Visit(IEnumerable`1<IGenericParameter> genericParameters);
    public virtual void Visit(IGenericTypeParameter genericTypeParameter);
    public virtual void Visit(IGenericTypeParameterReference genericTypeParameterReference);
    public virtual void Visit(IGlobalFieldDefinition globalFieldDefinition);
    public virtual void Visit(IGlobalMethodDefinition globalMethodDefinition);
    public void Visit(ImmutableArray`1<ILocalDefinition> localDefinitions);
    public virtual void Visit(ILocalDefinition localDefinition);
    public virtual void Visit(IMarshallingInformation marshallingInformation);
    public virtual void Visit(MetadataConstant constant);
    public virtual void Visit(MetadataCreateArray createArray);
    public void Visit(IEnumerable`1<IMetadataExpression> expressions);
    public virtual void Visit(IMetadataExpression expression);
    public void Visit(IEnumerable`1<IMetadataNamedArgument> namedArguments);
    public virtual void Visit(IMetadataNamedArgument namedArgument);
    public virtual void Visit(MetadataTypeOf typeOf);
    public virtual void Visit(IMethodBody methodBody);
    public void Visit(IEnumerable`1<IMethodDefinition> methods);
    public virtual void Visit(IMethodDefinition method);
    public void Visit(IEnumerable`1<MethodImplementation> methodImplementations);
    public virtual void Visit(MethodImplementation methodImplementation);
    public void Visit(IEnumerable`1<IMethodReference> methodReferences);
    public virtual void Visit(IMethodReference methodReference);
    public virtual void Visit(IModifiedTypeReference modifiedTypeReference);
    public abstract virtual void Visit(CommonPEModuleBuilder module);
    public void Visit(IEnumerable`1<IModuleReference> moduleReferences);
    public virtual void Visit(IModuleReference moduleReference);
    public void Visit(IEnumerable`1<INamedTypeDefinition> types);
    public virtual void Visit(INamespaceTypeDefinition namespaceTypeDefinition);
    public virtual void Visit(INamespaceTypeReference namespaceTypeReference);
    public void VisitNestedTypes(IEnumerable`1<INamedTypeDefinition> nestedTypes);
    public virtual void Visit(INestedTypeDefinition nestedTypeDefinition);
    public virtual void Visit(INestedTypeReference nestedTypeReference);
    public void Visit(ImmutableArray`1<ExceptionHandlerRegion> exceptionRegions);
    public virtual void Visit(ExceptionHandlerRegion exceptionRegion);
    public void Visit(ImmutableArray`1<IParameterDefinition> parameters);
    public virtual void Visit(IParameterDefinition parameterDefinition);
    public void Visit(ImmutableArray`1<IParameterTypeInformation> parameterTypeInformations);
    public virtual void Visit(IParameterTypeInformation parameterTypeInformation);
    public virtual void Visit(IPlatformInvokeInformation platformInvokeInformation);
    public virtual void Visit(IPointerTypeReference pointerTypeReference);
    public void Visit(IEnumerable`1<IPropertyDefinition> properties);
    public virtual void Visit(IPropertyDefinition propertyDefinition);
    public void Visit(IEnumerable`1<ManagedResource> resources);
    public virtual void Visit(ManagedResource resource);
    public virtual void Visit(SecurityAttribute securityAttribute);
    public void Visit(IEnumerable`1<SecurityAttribute> securityAttributes);
    public void Visit(IEnumerable`1<ITypeDefinitionMember> typeMembers);
    public void Visit(IEnumerable`1<ITypeDefinition> types);
    public abstract virtual void Visit(ITypeDefinition typeDefinition);
    public virtual void Visit(ITypeDefinitionMember typeMember);
    public virtual void Visit(ITypeMemberReference typeMemberReference);
    public void Visit(IEnumerable`1<ITypeReference> typeReferences);
    public void Visit(IEnumerable`1<TypeReferenceWithAttributes> typeRefsWithAttributes);
    public virtual void Visit(ITypeReference typeReference);
    protected void DispatchAsReference(ITypeReference typeReference);
    public void Visit(IEnumerable`1<IUnitReference> unitReferences);
    public virtual void Visit(IUnitReference unitReference);
    private void DispatchAsReference(IUnitReference unitReference);
    public virtual void Visit(IWin32Resource win32Resource);
}
internal abstract class Microsoft.Cci.MetadataWriter : object {
    internal static Encoding s_utf8Encoding;
    internal static int NameLengthLimit;
    internal static int PathLengthLimit;
    internal static int PdbLengthLimit;
    private int _numTypeDefsEstimate;
    private bool _deterministic;
    internal bool MetadataOnly;
    internal bool EmitTestCoverageData;
    private Dictionary`2<ImmutableArray`1<byte>, int> _smallMethodBodies;
    private static byte TinyFormat;
    private static int ThrowNullCodeSize;
    private static ImmutableArray`1<byte> ThrowNullEncodedBody;
    private CancellationToken _cancellationToken;
    protected CommonPEModuleBuilder module;
    public EmitContext Context;
    protected CommonMessageProvider messageProvider;
    private bool _tableIndicesAreComplete;
    private EntityHandle[] _pseudoSymbolTokenToTokenMap;
    private IReference[] _pseudoSymbolTokenToReferenceMap;
    private UserStringHandle[] _pseudoStringTokenToTokenMap;
    private bool _userStringTokenOverflow;
    private List`1<string> _pseudoStringTokenToStringMap;
    private ReferenceIndexer _referenceVisitor;
    protected MetadataBuilder metadata;
    protected MetadataBuilder _debugMetadataOpt;
    private DynamicAnalysisDataWriter _dynamicAnalysisDataWriterOpt;
    private Dictionary`2<ICustomAttribute, BlobHandle> _customAttributeSignatureIndex;
    private Dictionary`2<ITypeReference, BlobHandle> _typeSpecSignatureIndex;
    private List`1<ITypeReference> _exportedTypeList;
    private Dictionary`2<string, int> _fileRefIndex;
    private List`1<IFileReference> _fileRefList;
    private Dictionary`2<IFieldReference, BlobHandle> _fieldSignatureIndex;
    private Dictionary`2<ISignature, KeyValuePair`2<BlobHandle, ImmutableArray`1<byte>>> _signatureIndex;
    private Dictionary`2<IMarshallingInformation, BlobHandle> _marshallingDescriptorIndex;
    protected List`1<MethodImplementation> methodImplList;
    private Dictionary`2<IGenericMethodInstanceReference, BlobHandle> _methodInstanceSignatureIndex;
    internal static string dummyAssemblyAttributeParentNamespace;
    internal static string dummyAssemblyAttributeParentName;
    internal static String[0...,0...] dummyAssemblyAttributeParentQualifier;
    private TypeReferenceHandle[0...,0...] _dummyAssemblyAttributeParent;
    internal static UInt32 LiteralMethodDefinitionToken;
    internal static UInt32 LiteralGreatestMethodDefinitionToken;
    internal static UInt32 SourceDocumentIndex;
    internal static UInt32 ModuleVersionIdStringToken;
    private Dictionary`2<DebugSourceDocument, DocumentHandle> _documentIndex;
    private Dictionary`2<IImportScope, ImportScopeHandle> _scopeIndex;
    private static ImportScopeHandle ModuleImportScopeHandle;
    private int NumberOfTypeDefsEstimate { get; }
    internal bool IsFullMetadata { get; }
    private bool IsMinimalDelta { get; }
    private bool EmitAssemblyDefinition { get; }
    protected ushort Generation { get; }
    protected Guid EncId { get; }
    protected Guid EncBaseId { get; }
    protected int GreatestMethodDefIndex { get; }
    internal bool EmitPortableDebugMetadata { get; }
    internal CommonPEModuleBuilder Module { get; }
    protected MetadataWriter(MetadataBuilder metadata, MetadataBuilder debugMetadataOpt, DynamicAnalysisDataWriter dynamicAnalysisDataWriterOpt, EmitContext context, CommonMessageProvider messageProvider, bool metadataOnly, bool deterministic, bool emitTestCoverageData, CancellationToken cancellationToken);
    private static MetadataWriter();
    private int get_NumberOfTypeDefsEstimate();
    internal bool get_IsFullMetadata();
    private bool get_IsMinimalDelta();
    private bool get_EmitAssemblyDefinition();
    protected abstract virtual ushort get_Generation();
    protected abstract virtual Guid get_EncId();
    protected abstract virtual Guid get_EncBaseId();
    protected abstract virtual bool TryGetTypeDefinitionHandle(ITypeDefinition def, TypeDefinitionHandle& handle);
    protected abstract virtual TypeDefinitionHandle GetTypeDefinitionHandle(ITypeDefinition def);
    protected abstract virtual ITypeDefinition GetTypeDef(TypeDefinitionHandle handle);
    protected abstract virtual IReadOnlyList`1<ITypeDefinition> GetTypeDefs();
    protected abstract virtual EventDefinitionHandle GetEventDefinitionHandle(IEventDefinition def);
    protected abstract virtual IReadOnlyList`1<IEventDefinition> GetEventDefs();
    protected abstract virtual FieldDefinitionHandle GetFieldDefinitionHandle(IFieldDefinition def);
    protected abstract virtual IReadOnlyList`1<IFieldDefinition> GetFieldDefs();
    protected abstract virtual bool TryGetMethodDefinitionHandle(IMethodDefinition def, MethodDefinitionHandle& handle);
    protected abstract virtual MethodDefinitionHandle GetMethodDefinitionHandle(IMethodDefinition def);
    protected abstract virtual IMethodDefinition GetMethodDef(MethodDefinitionHandle handle);
    protected abstract virtual IReadOnlyList`1<IMethodDefinition> GetMethodDefs();
    protected abstract virtual PropertyDefinitionHandle GetPropertyDefIndex(IPropertyDefinition def);
    protected abstract virtual IReadOnlyList`1<IPropertyDefinition> GetPropertyDefs();
    protected abstract virtual ParameterHandle GetParameterHandle(IParameterDefinition def);
    protected abstract virtual IReadOnlyList`1<IParameterDefinition> GetParameterDefs();
    protected abstract virtual IReadOnlyList`1<IGenericParameter> GetGenericParameters();
    protected abstract virtual FieldDefinitionHandle GetFirstFieldDefinitionHandle(INamedTypeDefinition typeDef);
    protected abstract virtual MethodDefinitionHandle GetFirstMethodDefinitionHandle(INamedTypeDefinition typeDef);
    protected abstract virtual ParameterHandle GetFirstParameterHandle(IMethodDefinition methodDef);
    protected abstract virtual AssemblyReferenceHandle GetOrAddAssemblyReferenceHandle(IAssemblyReference reference);
    protected abstract virtual IReadOnlyList`1<AssemblyIdentity> GetAssemblyRefs();
    protected abstract virtual ModuleReferenceHandle GetOrAddModuleReferenceHandle(string reference);
    protected abstract virtual IReadOnlyList`1<string> GetModuleRefs();
    protected abstract virtual MemberReferenceHandle GetOrAddMemberReferenceHandle(ITypeMemberReference reference);
    protected abstract virtual IReadOnlyList`1<ITypeMemberReference> GetMemberRefs();
    protected abstract virtual MethodSpecificationHandle GetOrAddMethodSpecificationHandle(IGenericMethodInstanceReference reference);
    protected abstract virtual IReadOnlyList`1<IGenericMethodInstanceReference> GetMethodSpecs();
    protected abstract virtual int get_GreatestMethodDefIndex();
    protected abstract virtual bool TryGetTypeReferenceHandle(ITypeReference reference, TypeReferenceHandle& handle);
    protected abstract virtual TypeReferenceHandle GetOrAddTypeReferenceHandle(ITypeReference reference);
    protected abstract virtual IReadOnlyList`1<ITypeReference> GetTypeRefs();
    protected abstract virtual TypeSpecificationHandle GetOrAddTypeSpecificationHandle(ITypeReference reference);
    protected abstract virtual IReadOnlyList`1<ITypeReference> GetTypeSpecs();
    protected abstract virtual StandaloneSignatureHandle GetOrAddStandaloneSignatureHandle(BlobHandle handle);
    protected abstract virtual IReadOnlyList`1<BlobHandle> GetStandaloneSignatureBlobHandles();
    protected abstract virtual IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypes(CommonPEModuleBuilder module);
    protected abstract virtual void CreateIndicesForNonTypeMembers(ITypeDefinition typeDef);
    protected abstract virtual ReferenceIndexer CreateReferenceVisitor();
    protected abstract virtual void PopulateEventMapTableRows();
    protected abstract virtual void PopulatePropertyMapTableRows();
    protected abstract virtual void PopulateEncLogTableRows(ImmutableArray`1<int> rowCounts);
    protected abstract virtual void PopulateEncMapTableRows(ImmutableArray`1<int> rowCounts);
    protected abstract virtual void ReportReferencesToAddedSymbols();
    internal bool get_EmitPortableDebugMetadata();
    internal CommonPEModuleBuilder get_Module();
    private void CreateMethodBodyReferenceIndex();
    private void CreateIndices();
    private void CreateUserStringIndices();
    private void CreateIndicesForModule();
    protected virtual void OnIndicesCreated();
    private void CreateIndicesFor(ITypeDefinition typeDef, Queue`1<INestedTypeDefinition> nestedTypes);
    protected IEnumerable`1<IGenericTypeParameter> GetConsolidatedTypeParameters(ITypeDefinition typeDef);
    private List`1<IGenericTypeParameter> GetConsolidatedTypeParameters(ITypeDefinition typeDef, ITypeDefinition owner);
    protected ImmutableArray`1<IParameterDefinition> GetParametersToEmit(IMethodDefinition methodDef);
    private ImmutableArray`1<IParameterDefinition> GetParametersToEmitCore(IMethodDefinition methodDef);
    public static IUnitReference GetDefiningUnitReference(ITypeReference typeReference, EmitContext context);
    private void CreateInitialAssemblyRefIndex();
    private void CreateInitialFileRefIndex();
    internal AssemblyReferenceHandle GetAssemblyReferenceHandle(IAssemblyReference assemblyReference);
    internal ModuleReferenceHandle GetModuleReferenceHandle(string moduleName);
    private BlobHandle GetCustomAttributeSignatureIndex(ICustomAttribute customAttribute);
    private EntityHandle GetCustomAttributeTypeCodedIndex(IMethodReference methodReference);
    public static EventAttributes GetEventAttributes(IEventDefinition eventDef);
    public static FieldAttributes GetFieldAttributes(IFieldDefinition fieldDef);
    internal BlobHandle GetFieldSignatureIndex(IFieldReference fieldReference);
    internal EntityHandle GetFieldHandle(IFieldReference fieldReference);
    internal AssemblyFileHandle GetAssemblyFileHandle(IFileReference fileReference);
    private AssemblyFileHandle GetAssemblyFileHandle(IModuleReference mref);
    private static GenericParameterAttributes GetGenericParameterAttributes(IGenericParameter genPar);
    private EntityHandle GetExportedTypeImplementation(INamespaceTypeReference namespaceRef);
    private static UInt32 GetManagedResourceOffset(ManagedResource resource, BlobBuilder resourceWriter);
    private static UInt32 GetManagedResourceOffset(BlobBuilder resource, BlobBuilder resourceWriter);
    public static string GetMangledName(INamedTypeReference namedType);
    internal MemberReferenceHandle GetMemberReferenceHandle(ITypeMemberReference memberRef);
    internal EntityHandle GetMemberReferenceParent(ITypeMemberReference memberRef);
    internal EntityHandle GetMethodDefinitionOrReferenceHandle(IMethodReference methodReference);
    public static MethodAttributes GetMethodAttributes(IMethodDefinition methodDef);
    internal BlobHandle GetMethodSpecificationSignatureHandle(IGenericMethodInstanceReference methodInstanceReference);
    private BlobHandle GetMarshallingDescriptorHandle(IMarshallingInformation marshallingInformation);
    private BlobHandle GetMarshallingDescriptorHandle(ImmutableArray`1<byte> descriptor);
    private BlobHandle GetMemberReferenceSignatureHandle(ITypeMemberReference memberRef);
    internal BlobHandle GetMethodSignatureHandle(IMethodReference methodReference);
    internal Byte[] GetMethodSignature(IMethodReference methodReference);
    private BlobHandle GetMethodSignatureHandleAndBlob(IMethodReference methodReference, ImmutableArray`1& signatureBlob);
    private BlobHandle GetMethodSpecificationBlobHandle(IGenericMethodInstanceReference genericMethodInstanceReference);
    private MethodSpecificationHandle GetMethodSpecificationHandle(IGenericMethodInstanceReference methodSpec);
    internal EntityHandle GetMethodHandle(IMethodReference methodReference);
    public static ParameterAttributes GetParameterAttributes(IParameterDefinition parDef);
    private BlobHandle GetPermissionSetBlobHandle(ImmutableArray`1<ICustomAttribute> permissionSet);
    public static PropertyAttributes GetPropertyAttributes(IPropertyDefinition propertyDef);
    private BlobHandle GetPropertySignatureHandle(IPropertyDefinition propertyDef);
    private EntityHandle GetResolutionScopeHandle(IUnitReference unitReference);
    private StringHandle GetStringHandleForPathAndCheckLength(string path, INamedEntity errorEntity);
    private StringHandle GetStringHandleForNameAndCheckLength(string name, INamedEntity errorEntity);
    private StringHandle GetStringHandleForNamespaceAndCheckLength(INamespaceTypeReference namespaceType, string mangledTypeName);
    private void CheckNameLength(string name, INamedEntity errorEntity);
    private void CheckPathLength(string path, INamedEntity errorEntity);
    private void CheckNamespaceLength(string namespaceName, string mangledTypeName, INamespaceTypeReference errorEntity);
    internal bool IsUsingStringTooLong(string usingString, INamedEntity errorEntity);
    internal bool IsLocalNameTooLong(ILocalDefinition localDefinition);
    internal static bool IsTooLongInternal(string str, int maxLength);
    private static Location GetNamedEntityLocation(INamedEntity errorEntity);
    protected static Location GetSymbolLocation(ISymbol symbolOpt);
    internal TypeAttributes GetTypeAttributes(ITypeDefinition typeDef);
    public static TypeAttributes GetTypeAttributes(ITypeDefinition typeDef, EmitContext context);
    private EntityHandle GetDeclaringTypeOrMethodHandle(IGenericParameter genPar);
    private TypeReferenceHandle GetTypeReferenceHandle(ITypeReference typeReference);
    private TypeSpecificationHandle GetTypeSpecificationHandle(ITypeReference typeReference);
    internal ITypeDefinition GetTypeDefinition(int token);
    internal IMethodDefinition GetMethodDefinition(int token);
    internal INestedTypeReference GetNestedTypeReference(int token);
    internal BlobHandle GetTypeSpecSignatureIndex(ITypeReference typeReference);
    internal EntityHandle GetTypeHandle(ITypeReference typeReference, bool treatRefAsPotentialTypeSpec);
    internal EntityHandle GetDefinitionHandle(IDefinition definition);
    public void WriteMetadataAndIL(PdbWriter nativePdbWriterOpt, Stream metadataStream, Stream ilStream, Stream portablePdbStreamOpt, MetadataSizes& metadataSizes);
    public void BuildMetadataAndIL(PdbWriter nativePdbWriterOpt, BlobBuilder ilBuilder, BlobBuilder mappedFieldDataBuilder, BlobBuilder managedResourceDataBuilder, Blob& mvidFixup, Blob& mvidStringFixup);
    public void PopulateEncTables(ImmutableArray`1<int> typeSystemRowCounts);
    public MetadataRootBuilder GetRootBuilder();
    public PortablePdbBuilder GetPortablePdbBuilder(ImmutableArray`1<int> typeSystemRowCounts, MethodDefinitionHandle debugEntryPoint, Func`2<IEnumerable`1<Blob>, BlobContentId> deterministicIdProviderOpt);
    internal void GetEntryPoints(MethodDefinitionHandle& entryPointHandle, MethodDefinitionHandle& debugEntryPointHandle);
    private ImmutableArray`1<IGenericParameter> GetSortedGenericParameters();
    private void PopulateTypeSystemTables(Int32[] methodBodyOffsets, BlobBuilder mappedFieldDataWriter, BlobBuilder resourceWriter, BlobBuilder dynamicAnalysisDataOpt, Blob& mvidFixup);
    private void PopulateAssemblyRefTableRows();
    private void PopulateAssemblyTableRows();
    private void PopulateCustomAttributeTableRows(ImmutableArray`1<IGenericParameter> sortedGenericParameters);
    private void AddAssemblyAttributesToTable();
    private void AddAssemblyAttributesToTable(IEnumerable`1<ICustomAttribute> assemblyAttributes, bool needsDummyParent, bool isSecurity);
    private TypeReferenceHandle GetDummyAssemblyAttributeParent(bool isSecurity, bool allowMultiple);
    private void AddModuleAttributesToTable(CommonPEModuleBuilder module);
    private void AddCustomAttributesToTable(IEnumerable`1<T> parentList, TableIndex tableIndex);
    private void AddCustomAttributesToTable(IEnumerable`1<T> parentList, Func`2<T, EntityHandle> getDefinitionHandle);
    private void AddCustomAttributesToTable(EntityHandle handle, ImmutableArray`1<ICustomAttribute> attributes);
    private void AddCustomAttributesToTable(IEnumerable`1<TypeReferenceWithAttributes> typeRefsWithAttributes);
    private void AddCustomAttributeToTable(EntityHandle parentHandle, ICustomAttribute customAttribute);
    private void PopulateDeclSecurityTableRows();
    private void PopulateDeclSecurityTableRowsFor(EntityHandle parentHandle, IEnumerable`1<SecurityAttribute> attributes);
    private void PopulateEventTableRows();
    private void PopulateExportedTypeTableRows();
    private void PopulateFieldLayoutTableRows();
    private void PopulateFieldMarshalTableRows();
    private void PopulateFieldRvaTableRows(BlobBuilder mappedFieldDataWriter);
    private void PopulateFieldTableRows();
    private void PopulateConstantTableRows();
    private void PopulateFileTableRows();
    private void PopulateGenericParameters(ImmutableArray`1<IGenericParameter> sortedGenericParameters);
    private void PopulateImplMapTableRows();
    private void PopulateInterfaceImplTableRows();
    private void PopulateManifestResourceTableRows(BlobBuilder resourceDataWriter, BlobBuilder dynamicAnalysisDataOpt);
    private void PopulateMemberRefTableRows();
    private void PopulateMethodImplTableRows();
    private void PopulateMethodSpecTableRows();
    private void PopulateMethodTableRows(Int32[] methodBodyOffsets);
    private void PopulateMethodSemanticsTableRows();
    private void PopulateModuleRefTableRows();
    private void PopulateModuleTableRow(Blob& mvidFixup);
    private void PopulateParamTableRows();
    private void PopulatePropertyTableRows();
    private void PopulateTypeDefTableRows();
    private void PopulateNestedClassTableRows();
    private void PopulateClassLayoutTableRows();
    private void PopulateTypeRefTableRows();
    private void PopulateTypeSpecTableRows();
    private void PopulateStandaloneSignatures();
    private Int32[] SerializeThrowNullMethodBodies(BlobBuilder ilBuilder);
    private Int32[] SerializeMethodBodies(BlobBuilder ilBuilder, PdbWriter nativePdbWriterOpt, Blob& mvidStringFixup);
    private int SerializeMethodBody(MethodBodyStreamEncoder encoder, IMethodBody methodBody, StandaloneSignatureHandle localSignatureHandleOpt, UserStringHandle& mvidStringHandle, Blob& mvidStringFixup);
    protected virtual StandaloneSignatureHandle SerializeLocalVariablesSignature(IMethodBody body);
    protected void SerializeLocalVariableType(LocalVariableTypeEncoder encoder, ILocalDefinition local);
    internal StandaloneSignatureHandle SerializeLocalConstantStandAloneSignature(ILocalDefinition localConstant);
    private static byte ReadByte(ImmutableArray`1<byte> buffer, int pos);
    private static int ReadInt32(ImmutableArray`1<byte> buffer, int pos);
    private EntityHandle GetHandle(IReference reference);
    private EntityHandle ResolveEntityHandleFromPseudoToken(int pseudoSymbolToken);
    private UserStringHandle ResolveUserStringHandleFromPseudoToken(int pseudoStringToken);
    private UserStringHandle GetOrAddUserString(string str);
    private ReservedBlob`1<UserStringHandle> ReserveUserString(int length);
    private void WriteInstructions(Blob finalIL, ImmutableArray`1<byte> generatedIL, UserStringHandle& mvidStringHandle, Blob& mvidStringFixup);
    private void SerializeMethodBodyExceptionHandlerTable(ExceptionRegionEncoder encoder, ImmutableArray`1<ExceptionHandlerRegion> regions);
    private static bool MayUseSmallExceptionHeaders(ImmutableArray`1<ExceptionHandlerRegion> exceptionRegions);
    private void SerializeParameterInformation(ParameterTypeEncoder encoder, IParameterTypeInformation parameterTypeInformation);
    private void SerializeFieldSignature(IFieldReference fieldReference, BlobBuilder builder);
    private void SerializeMethodSpecificationSignature(BlobBuilder builder, IGenericMethodInstanceReference genericMethodInstanceReference);
    private void SerializeCustomAttributeSignature(ICustomAttribute customAttribute, BlobBuilder builder);
    private void SerializeCustomAttributeNamedArguments(NamedArgumentsEncoder encoder, ICustomAttribute customAttribute);
    private void SerializeNamedArgumentType(NamedArgumentTypeEncoder encoder, ITypeReference type);
    private void SerializeMetadataExpression(LiteralEncoder encoder, IMetadataExpression expression, ITypeReference targetType);
    private void SerializeMarshallingDescriptor(IMarshallingInformation marshallingInformation, BlobBuilder writer);
    private void SerializeTypeName(ITypeReference typeReference, BlobBuilder writer);
    internal static string StrongName(IAssemblyReference assemblyReference);
    private void SerializePermissionSet(ImmutableArray`1<ICustomAttribute> permissionSet, BlobBuilder writer);
    private void SerializeReturnValueAndParameters(MethodSignatureEncoder encoder, ISignature signature, ImmutableArray`1<IParameterTypeInformation> varargParameters);
    private void SerializeTypeReference(SignatureTypeEncoder encoder, ITypeReference typeReference);
    private static void SerializePrimitiveType(SignatureTypeEncoder encoder, PrimitiveTypeCode primitiveType);
    private void SerializeCustomAttributeArrayType(CustomAttributeArrayTypeEncoder encoder, IArrayTypeReference arrayTypeReference);
    private void SerializeCustomAttributeElementType(CustomAttributeElementTypeEncoder encoder, ITypeReference typeReference);
    private static void SerializePrimitiveType(CustomAttributeElementTypeEncoder encoder, PrimitiveTypeCode primitiveType);
    private void SerializeCustomModifiers(CustomModifiersEncoder encoder, ImmutableArray`1<ICustomModifier> modifiers);
    private int GetNumberOfInheritedTypeParameters(ITypeReference type);
    internal static EditAndContinueMethodDebugInformation GetEncMethodDebugInfo(IMethodBody methodBody);
    internal static ImmutableArray`1<LocalSlotDebugInfo> GetLocalSlotDebugInfos(ImmutableArray`1<ILocalDefinition> locals);
    internal static ImmutableArray`1<LocalSlotDebugInfo> GetLocalSlotDebugInfos(ImmutableArray`1<EncHoistedLocalInfo> locals);
    private void SerializeMethodDebugInfo(IMethodBody bodyOpt, int methodRid, StandaloneSignatureHandle localSignatureHandleOpt, LocalVariableHandle& lastLocalVariableHandle, LocalConstantHandle& lastLocalConstantHandle);
    private static LocalVariableHandle NextHandle(LocalVariableHandle handle);
    private static LocalConstantHandle NextHandle(LocalConstantHandle handle);
    private BlobHandle SerializeLocalConstantSignature(ILocalDefinition localConstant);
    private static SignatureTypeCode GetConstantTypeCode(object value);
    private void SerializeImport(BlobBuilder writer, AssemblyReferenceAlias alias);
    private void SerializeImport(BlobBuilder writer, UsedNamespaceOrType import);
    private void DefineModuleImportScope();
    private ImportScopeHandle GetImportScopeIndex(IImportScope scope, Dictionary`2<IImportScope, ImportScopeHandle> scopeIndex);
    private BlobHandle SerializeImportsBlob(IImportScope scope);
    private void SerializeModuleDefaultNamespace();
    private void SerializeLocalInfo(ILocalDefinition local, EntityHandle parent);
    private static ImmutableArray`1<byte> SerializeBitVector(ImmutableArray`1<bool> vector);
    private static void SerializeTupleElementNames(BlobBuilder builder, ImmutableArray`1<string> names);
    private static void WriteUtf8String(BlobBuilder builder, string str);
    private void SerializeAsyncMethodSteppingInfo(AsyncMoveNextBodyDebugInfo asyncInfo, MethodDefinitionHandle moveNextMethod);
    private void SerializeStateMachineLocalScopes(IMethodBody methodBody, MethodDefinitionHandle method);
    private BlobHandle SerializeSequencePoints(StandaloneSignatureHandle localSignatureHandleOpt, ImmutableArray`1<SequencePoint> sequencePoints, Dictionary`2<DebugSourceDocument, DocumentHandle> documentIndex, DocumentHandle& singleDocumentHandle);
    private static DebugSourceDocument TryGetSingleDocument(ImmutableArray`1<SequencePoint> sequencePoints);
    private void SerializeDeltaLinesAndColumns(BlobBuilder writer, SequencePoint sequencePoint);
    private DocumentHandle GetOrAddDocument(DebugSourceDocument document, Dictionary`2<DebugSourceDocument, DocumentHandle> index);
    public void AddRemainingEmbeddedDocuments(IEnumerable`1<DebugSourceDocument> documents);
    private void SerializeEncMethodDebugInformation(IMethodBody methodBody, MethodDefinitionHandle method);
    private void EmbedSourceLink(Stream stream);
    [CompilerGeneratedAttribute]
private int <GetSortedGenericParameters>b__179_0(IGenericParameter x, IGenericParameter y);
    [CompilerGeneratedAttribute]
private EntityHandle <PopulateCustomAttributeTableRows>b__183_0(IMethodDefinition def);
    [CompilerGeneratedAttribute]
private EntityHandle <PopulateCustomAttributeTableRows>b__183_1(IFieldDefinition def);
    [CompilerGeneratedAttribute]
private EntityHandle <PopulateCustomAttributeTableRows>b__183_2(ITypeDefinition def);
    [CompilerGeneratedAttribute]
private EntityHandle <PopulateCustomAttributeTableRows>b__183_3(IParameterDefinition def);
    [CompilerGeneratedAttribute]
private EntityHandle <PopulateCustomAttributeTableRows>b__183_4(IPropertyDefinition def);
    [CompilerGeneratedAttribute]
private EntityHandle <PopulateCustomAttributeTableRows>b__183_5(IEventDefinition def);
}
internal class Microsoft.Cci.MethodImplementation : ValueType {
    public IMethodDefinition ImplementingMethod;
    public IMethodReference ImplementedMethod;
    public ITypeDefinition ContainingType { get; }
    public MethodImplementation(IMethodDefinition ImplementingMethod, IMethodReference ImplementedMethod);
    public ITypeDefinition get_ContainingType();
}
internal class Microsoft.Cci.MethodSpecComparer : object {
    private MetadataWriter _metadataWriter;
    internal MethodSpecComparer(MetadataWriter metadataWriter);
    public sealed virtual bool Equals(IGenericMethodInstanceReference x, IGenericMethodInstanceReference y);
    public sealed virtual int GetHashCode(IGenericMethodInstanceReference methodInstanceReference);
}
internal class Microsoft.Cci.ModifiedTypeReference : object {
    private ITypeReference _modifiedType;
    private ImmutableArray`1<ICustomModifier> _customModifiers;
    private ImmutableArray`1<ICustomModifier> Microsoft.Cci.IModifiedTypeReference.CustomModifiers { get; }
    private ITypeReference Microsoft.Cci.IModifiedTypeReference.UnmodifiedType { get; }
    private bool Microsoft.Cci.ITypeReference.IsEnum { get; }
    private bool Microsoft.Cci.ITypeReference.IsValueType { get; }
    private PrimitiveTypeCode Microsoft.Cci.ITypeReference.TypeCode { get; }
    private TypeDefinitionHandle Microsoft.Cci.ITypeReference.TypeDef { get; }
    private IGenericMethodParameterReference Microsoft.Cci.ITypeReference.AsGenericMethodParameterReference { get; }
    private IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.AsGenericTypeInstanceReference { get; }
    private IGenericTypeParameterReference Microsoft.Cci.ITypeReference.AsGenericTypeParameterReference { get; }
    private INamespaceTypeReference Microsoft.Cci.ITypeReference.AsNamespaceTypeReference { get; }
    private INestedTypeReference Microsoft.Cci.ITypeReference.AsNestedTypeReference { get; }
    private ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.AsSpecializedNestedTypeReference { get; }
    public ModifiedTypeReference(ITypeReference modifiedType, ImmutableArray`1<ICustomModifier> customModifiers);
    private sealed virtual override ImmutableArray`1<ICustomModifier> Microsoft.Cci.IModifiedTypeReference.get_CustomModifiers();
    private sealed virtual override ITypeReference Microsoft.Cci.IModifiedTypeReference.get_UnmodifiedType();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsEnum();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsValueType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.GetResolvedType(EmitContext context);
    private sealed virtual override PrimitiveTypeCode Microsoft.Cci.ITypeReference.get_TypeCode();
    private sealed virtual override TypeDefinitionHandle Microsoft.Cci.ITypeReference.get_TypeDef();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.GetAttributes(EmitContext context);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override IGenericMethodParameterReference Microsoft.Cci.ITypeReference.get_AsGenericMethodParameterReference();
    private sealed virtual override IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.get_AsGenericTypeInstanceReference();
    private sealed virtual override IGenericTypeParameterReference Microsoft.Cci.ITypeReference.get_AsGenericTypeParameterReference();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.ITypeReference.AsNamespaceTypeDefinition(EmitContext context);
    private sealed virtual override INamespaceTypeReference Microsoft.Cci.ITypeReference.get_AsNamespaceTypeReference();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.ITypeReference.AsNestedTypeDefinition(EmitContext context);
    private sealed virtual override INestedTypeReference Microsoft.Cci.ITypeReference.get_AsNestedTypeReference();
    private sealed virtual override ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.get_AsSpecializedNestedTypeReference();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.AsTypeDefinition(EmitContext context);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
}
internal class Microsoft.Cci.ModulePropertiesForSerialization : object {
    public int FileAlignment;
    public int SectionAlignment;
    public string TargetRuntimeVersion;
    public Machine Machine;
    public Guid PersistentIdentifier;
    public ulong BaseAddress;
    public ulong SizeOfHeapReserve;
    public ulong SizeOfHeapCommit;
    public ulong SizeOfStackReserve;
    public ulong SizeOfStackCommit;
    public ushort MajorSubsystemVersion;
    public ushort MinorSubsystemVersion;
    public byte LinkerMajorVersion;
    public byte LinkerMinorVersion;
    [CompilerGeneratedAttribute]
private DllCharacteristics <DllCharacteristics>k__BackingField;
    [CompilerGeneratedAttribute]
private Characteristics <ImageCharacteristics>k__BackingField;
    [CompilerGeneratedAttribute]
private Subsystem <Subsystem>k__BackingField;
    [CompilerGeneratedAttribute]
private CorFlags <CorFlags>k__BackingField;
    public static ulong DefaultExeBaseAddress32Bit;
    public static ulong DefaultExeBaseAddress64Bit;
    public static ulong DefaultDllBaseAddress32Bit;
    public static ulong DefaultDllBaseAddress64Bit;
    public static ulong DefaultSizeOfHeapReserve32Bit;
    public static ulong DefaultSizeOfHeapReserve64Bit;
    public static ulong DefaultSizeOfHeapCommit32Bit;
    public static ulong DefaultSizeOfHeapCommit64Bit;
    public static ulong DefaultSizeOfStackReserve32Bit;
    public static ulong DefaultSizeOfStackReserve64Bit;
    public static ulong DefaultSizeOfStackCommit32Bit;
    public static ulong DefaultSizeOfStackCommit64Bit;
    public static ushort DefaultFileAlignment32Bit;
    public static ushort DefaultFileAlignment64Bit;
    public static ushort DefaultSectionAlignment;
    public DllCharacteristics DllCharacteristics { get; }
    public Characteristics ImageCharacteristics { get; }
    public Subsystem Subsystem { get; }
    public CorFlags CorFlags { get; }
    internal ModulePropertiesForSerialization(Guid persistentIdentifier, CorFlags corFlags, int fileAlignment, int sectionAlignment, string targetRuntimeVersion, Machine machine, ulong baseAddress, ulong sizeOfHeapReserve, ulong sizeOfHeapCommit, ulong sizeOfStackReserve, ulong sizeOfStackCommit, DllCharacteristics dllCharacteristics, Characteristics imageCharacteristics, Subsystem subsystem, ushort majorSubsystemVersion, ushort minorSubsystemVersion, byte linkerMajorVersion, byte linkerMinorVersion);
    [CompilerGeneratedAttribute]
public DllCharacteristics get_DllCharacteristics();
    [CompilerGeneratedAttribute]
public Characteristics get_ImageCharacteristics();
    [CompilerGeneratedAttribute]
public Subsystem get_Subsystem();
    [CompilerGeneratedAttribute]
public CorFlags get_CorFlags();
}
internal static class Microsoft.Cci.NativeResourceWriter : object {
    private static int CompareResources(IWin32Resource left, IWin32Resource right);
    private static int CompareResourceIdentifiers(int xOrdinal, string xString, int yOrdinal, string yString);
    internal static IEnumerable`1<IWin32Resource> SortResources(IEnumerable`1<IWin32Resource> resources);
    public static void SerializeWin32Resources(BlobBuilder builder, IEnumerable`1<IWin32Resource> theResources, int resourcesRva);
    private static void WriteDirectory(Directory directory, BlobBuilder writer, UInt32 offset, UInt32 level, UInt32 sizeOfDirectoryTree, int virtualAddressBase, BlobBuilder dataWriter);
    private static UInt32 SizeOfDirectory(Directory directory);
    public static void SerializeWin32Resources(BlobBuilder builder, ResourceSection resourceSections, int resourcesRva);
}
internal class Microsoft.Cci.NoPiaReferenceIndexer : ReferenceIndexerBase {
    internal NoPiaReferenceIndexer(EmitContext context);
    public virtual void Visit(CommonPEModuleBuilder module);
    protected virtual void RecordAssemblyReference(IAssemblyReference assemblyReference);
    protected virtual void RecordFileReference(IFileReference fileReference);
    protected virtual void RecordModuleReference(IModuleReference moduleReference);
    public virtual void Visit(IPlatformInvokeInformation platformInvokeInformation);
    protected virtual void ProcessMethodBody(IMethodDefinition method);
    protected virtual void RecordTypeReference(ITypeReference typeReference);
    protected virtual void ReserveFieldToken(IFieldReference fieldReference);
    protected virtual void ReserveMethodToken(IMethodReference methodReference);
    protected virtual void RecordTypeMemberReference(ITypeMemberReference typeMemberReference);
}
internal class Microsoft.Cci.PdbWriter : object {
    internal static UInt32 Age;
    private HashAlgorithmName _hashAlgorithmNameOpt;
    private string _fileName;
    private Func`2<ISymWriterMetadataProvider, SymUnmanagedWriter> _symWriterFactory;
    private Dictionary`2<DebugSourceDocument, int> _documentIndex;
    private MetadataWriter _metadataWriter;
    private SymUnmanagedWriter _symWriter;
    private SymUnmanagedSequencePointsWriter _sequencePointsWriter;
    private Dictionary`2<object, string> _qualifiedNameCache;
    private bool IsDeterministic { get; }
    private CommonPEModuleBuilder Module { get; }
    private EmitContext Context { get; }
    public PdbWriter(string fileName, Func`2<ISymWriterMetadataProvider, SymUnmanagedWriter> symWriterFactory, HashAlgorithmName hashAlgorithmNameOpt);
    private bool get_IsDeterministic();
    public void WriteTo(Stream stream);
    public sealed virtual void Dispose();
    private CommonPEModuleBuilder get_Module();
    private EmitContext get_Context();
    public void SerializeDebugInfo(IMethodBody methodBody, StandaloneSignatureHandle localSignatureHandleOpt, CustomDebugInfoWriter customDebugInfoWriter);
    private void DefineNamespaceScopes(IMethodBody methodBody);
    private void DefineAssemblyReferenceAliases();
    private string TryEncodeImport(UsedNamespaceOrType import, HashSet`1<string> declaredExternAliasesOpt, bool isProjectLevel);
    internal string GetOrCreateSerializedNamespaceName(INamespace namespace);
    internal string GetOrCreateSerializedTypeName(ITypeReference typeReference);
    private string SerializeVisualBasicImportTypeReference(ITypeReference typeReference);
    private string GetAssemblyReferenceAlias(IAssemblyReference assembly, HashSet`1<string> declaredExternAliases);
    private void DefineLocalScopes(ImmutableArray`1<LocalScope> scopes, StandaloneSignatureHandle localSignatureHandleOpt);
    private void DefineScopeLocals(LocalScope currentScope, StandaloneSignatureHandle localSignatureHandleOpt);
    public void SetMetadataEmitter(MetadataWriter metadataWriter);
    public BlobContentId GetContentId();
    public void SetEntryPoint(int entryMethodToken);
    private int GetDocumentIndex(DebugSourceDocument document);
    private void OpenMethod(int methodToken, IMethodDefinition method);
    private void CloseMethod(int ilLength);
    private void UsingNamespace(string fullName, INamedEntity errorEntity);
    private void EmitSequencePoints(ImmutableArray`1<SequencePoint> sequencePoints);
    [ConditionalAttribute("DEBUG")]
public void AssertAllDefinitionsHaveTokens(MultiDictionary`2<DebugSourceDocument, DefinitionWithLocation> file2definitions);
    public void WriteDefinitionLocations(MultiDictionary`2<DebugSourceDocument, DefinitionWithLocation> file2definitions);
    public void EmbedSourceLink(Stream stream);
    public void WriteRemainingEmbeddedDocuments(IEnumerable`1<DebugSourceDocument> embeddedDocuments);
}
internal static class Microsoft.Cci.PeWriter : object {
    private static MethodInfo s_calculateChecksumMethod;
    internal static bool WritePeToStream(EmitContext context, CommonMessageProvider messageProvider, Func`1<Stream> getPeStream, Func`1<Stream> getPortablePdbStreamOpt, PdbWriter nativePdbWriterOpt, string pdbPathOpt, bool metadataOnly, bool isDeterministic, bool emitTestCoverageData, Nullable`1<RSAParameters> privateKeyOpt, CancellationToken cancellationToken);
    internal static UInt32 CalculateChecksum(BlobBuilder peBlob, Blob checksumBlob);
    private static void PatchModuleVersionIds(Blob guidFixup, Blob guidSectionFixup, Blob stringFixup, Guid mvid);
    private static string PadPdbPath(string path);
    private static ResourceSectionBuilder CreateNativeResourceSectionSerializer(CommonPEModuleBuilder module);
}
internal class Microsoft.Cci.PeWritingException : Exception {
    public PeWritingException(Exception inner);
}
internal enum Microsoft.Cci.PlatformType : Enum {
    public int value__;
    public static PlatformType SystemObject;
    public static PlatformType SystemDecimal;
    public static PlatformType SystemTypedReference;
    public static PlatformType SystemType;
    public static PlatformType SystemInt32;
    public static PlatformType SystemVoid;
    public static PlatformType SystemString;
}
internal class Microsoft.Cci.PooledBlobBuilder : BlobBuilder {
    private static int PoolSize;
    private static int ChunkSize;
    private static ObjectPool`1<PooledBlobBuilder> s_chunkPool;
    private PooledBlobBuilder(int size);
    private static PooledBlobBuilder();
    public static PooledBlobBuilder GetInstance(int size);
    protected virtual BlobBuilder AllocateChunk(int minimalSize);
    protected virtual void FreeChunk();
    public void Free();
    private sealed virtual override void System.IDisposable.Dispose();
}
internal enum Microsoft.Cci.PrimitiveTypeCode : Enum {
    public int value__;
    public static PrimitiveTypeCode Boolean;
    public static PrimitiveTypeCode Char;
    public static PrimitiveTypeCode Int8;
    public static PrimitiveTypeCode Float32;
    public static PrimitiveTypeCode Float64;
    public static PrimitiveTypeCode Int16;
    public static PrimitiveTypeCode Int32;
    public static PrimitiveTypeCode Int64;
    public static PrimitiveTypeCode IntPtr;
    public static PrimitiveTypeCode Pointer;
    public static PrimitiveTypeCode Reference;
    public static PrimitiveTypeCode String;
    public static PrimitiveTypeCode UInt8;
    public static PrimitiveTypeCode UInt16;
    public static PrimitiveTypeCode UInt32;
    public static PrimitiveTypeCode UInt64;
    public static PrimitiveTypeCode UIntPtr;
    public static PrimitiveTypeCode Void;
    public static PrimitiveTypeCode NotPrimitive;
    public static PrimitiveTypeCode Invalid;
}
internal abstract class Microsoft.Cci.ReferenceIndexer : ReferenceIndexerBase {
    protected MetadataWriter metadataWriter;
    private HashSet`1<IImportScope> _alreadySeenScopes;
    internal ReferenceIndexer(MetadataWriter metadataWriter);
    public virtual void Visit(CommonPEModuleBuilder module);
    private void VisitExportedType(ITypeReference exportedType);
    public void VisitMethodBodyReference(IReference reference);
    protected virtual void RecordAssemblyReference(IAssemblyReference assemblyReference);
    protected virtual void ProcessMethodBody(IMethodDefinition method);
    private void VisitImports(ImmutableArray`1<UsedNamespaceOrType> imports);
    protected virtual void RecordTypeReference(ITypeReference typeReference);
    protected virtual void RecordTypeMemberReference(ITypeMemberReference typeMemberReference);
    protected virtual void RecordFileReference(IFileReference fileReference);
    protected virtual void ReserveMethodToken(IMethodReference methodReference);
    protected virtual void ReserveFieldToken(IFieldReference fieldReference);
    protected virtual void RecordModuleReference(IModuleReference moduleReference);
    public virtual void Visit(IPlatformInvokeInformation platformInvokeInformation);
}
internal abstract class Microsoft.Cci.ReferenceIndexerBase : MetadataVisitor {
    private HashSet`1<IReference> _alreadySeen;
    private HashSet`1<IReference> _alreadyHasToken;
    protected bool typeReferenceNeedsToken;
    internal ReferenceIndexerBase(EmitContext context);
    public virtual void Visit(IAssemblyReference assemblyReference);
    protected abstract virtual void RecordAssemblyReference(IAssemblyReference assemblyReference);
    public virtual void Visit(ICustomModifier customModifier);
    public virtual void Visit(IEventDefinition eventDefinition);
    public virtual void Visit(IFieldReference fieldReference);
    protected abstract virtual void ReserveFieldToken(IFieldReference fieldReference);
    public virtual void Visit(IFileReference fileReference);
    protected abstract virtual void RecordFileReference(IFileReference fileReference);
    public virtual void Visit(IGenericMethodInstanceReference genericMethodInstanceReference);
    public virtual void Visit(IGenericParameter genericParameter);
    public virtual void Visit(IGenericTypeInstanceReference genericTypeInstanceReference);
    public virtual void Visit(IMarshallingInformation marshallingInformation);
    public virtual void Visit(IMethodDefinition method);
    protected abstract virtual void ProcessMethodBody(IMethodDefinition method);
    public virtual void Visit(IMethodReference methodReference);
    protected abstract virtual void ReserveMethodToken(IMethodReference methodReference);
    public abstract virtual void Visit(CommonPEModuleBuilder module);
    public virtual void Visit(IModuleReference moduleReference);
    protected abstract virtual void RecordModuleReference(IModuleReference moduleReference);
    public abstract virtual void Visit(IPlatformInvokeInformation platformInvokeInformation);
    public virtual void Visit(INamespaceTypeReference namespaceTypeReference);
    protected abstract virtual void RecordTypeReference(ITypeReference typeReference);
    public virtual void Visit(INestedTypeReference nestedTypeReference);
    public virtual void Visit(IPropertyDefinition propertyDefinition);
    public virtual void Visit(ManagedResource resourceReference);
    public virtual void Visit(SecurityAttribute securityAttribute);
    public void VisitTypeDefinitionNoMembers(ITypeDefinition typeDefinition);
    public virtual void Visit(ITypeDefinition typeDefinition);
    public void VisitTypeReferencesThatNeedTokens(IEnumerable`1<TypeReferenceWithAttributes> refsWithAttributes);
    private void VisitTypeReferencesThatNeedTokens(ITypeReference typeReference);
    public virtual void Visit(ITypeMemberReference typeMemberReference);
    protected abstract virtual void RecordTypeMemberReference(ITypeMemberReference typeMemberReference);
    public virtual void Visit(IArrayTypeReference arrayTypeReference);
    public virtual void Visit(IPointerTypeReference pointerTypeReference);
    public virtual void Visit(ITypeReference typeReference);
    private bool VisitTypeReference(ITypeReference typeReference);
}
internal class Microsoft.Cci.ResourceSection : object {
    internal Byte[] SectionBytes;
    internal UInt32[] Relocations;
    internal ResourceSection(Byte[] sectionBytes, UInt32[] relocations);
}
internal class Microsoft.Cci.ReturnValueParameter : object {
    private IMethodDefinition _containingMethod;
    public ISignature ContainingSignature { get; }
    public MetadataConstant Constant { get; }
    public ImmutableArray`1<ICustomModifier> RefCustomModifiers { get; }
    public ImmutableArray`1<ICustomModifier> CustomModifiers { get; }
    public bool HasDefaultValue { get; }
    public ushort Index { get; }
    public bool IsIn { get; }
    public bool IsByReference { get; }
    public bool IsMarshalledExplicitly { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ImmutableArray`1<byte> MarshallingDescriptor { get; }
    public string Name { get; }
    internal ReturnValueParameter(IMethodDefinition containingMethod);
    public sealed virtual IEnumerable`1<ICustomAttribute> GetAttributes(EmitContext context);
    public ISignature get_ContainingSignature();
    public MetadataConstant get_Constant();
    public sealed virtual ImmutableArray`1<ICustomModifier> get_RefCustomModifiers();
    public sealed virtual ImmutableArray`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual MetadataConstant GetDefaultValue(EmitContext context);
    public sealed virtual void Dispatch(MetadataVisitor visitor);
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual ushort get_Index();
    public sealed virtual bool get_IsIn();
    public sealed virtual bool get_IsByReference();
    public sealed virtual bool get_IsMarshalledExplicitly();
    public sealed virtual bool get_IsOptional();
    public sealed virtual bool get_IsOut();
    public sealed virtual IMarshallingInformation get_MarshallingInformation();
    public sealed virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    public sealed virtual string get_Name();
    public sealed virtual ITypeReference GetType(EmitContext context);
    public sealed virtual IDefinition AsDefinition(EmitContext context);
}
internal class Microsoft.Cci.RootModuleType : object {
    public TypeDefinitionHandle TypeDef { get; }
    public ITypeDefinition ResolvedType { get; }
    public bool MangleName { get; }
    public string Name { get; }
    public ushort Alignment { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsComObject { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsWindowsRuntimeImport { get; }
    public bool IsSealed { get; }
    public LayoutKind Layout { get; }
    public UInt32 SizeOf { get; }
    public CharSet StringFormat { get; }
    public bool IsPublic { get; }
    public bool IsNested { get; }
    private IEnumerable`1<IGenericTypeParameter> Microsoft.Cci.ITypeDefinition.GenericParameters { get; }
    private ushort Microsoft.Cci.ITypeDefinition.GenericParameterCount { get; }
    private IEnumerable`1<SecurityAttribute> Microsoft.Cci.ITypeDefinition.SecurityAttributes { get; }
    private bool Microsoft.Cci.ITypeReference.IsEnum { get; }
    private bool Microsoft.Cci.ITypeReference.IsValueType { get; }
    private PrimitiveTypeCode Microsoft.Cci.ITypeReference.TypeCode { get; }
    private ushort Microsoft.Cci.INamedTypeReference.GenericParameterCount { get; }
    private string Microsoft.Cci.INamespaceTypeReference.NamespaceName { get; }
    private IGenericMethodParameterReference Microsoft.Cci.ITypeReference.AsGenericMethodParameterReference { get; }
    private IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.AsGenericTypeInstanceReference { get; }
    private IGenericTypeParameterReference Microsoft.Cci.ITypeReference.AsGenericTypeParameterReference { get; }
    private INamespaceTypeReference Microsoft.Cci.ITypeReference.AsNamespaceTypeReference { get; }
    private INestedTypeReference Microsoft.Cci.ITypeReference.AsNestedTypeReference { get; }
    private ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.AsSpecializedNestedTypeReference { get; }
    public sealed virtual TypeDefinitionHandle get_TypeDef();
    public ITypeDefinition get_ResolvedType();
    public sealed virtual IEnumerable`1<ICustomAttribute> GetAttributes(EmitContext context);
    public sealed virtual bool get_MangleName();
    public sealed virtual string get_Name();
    public sealed virtual ushort get_Alignment();
    public sealed virtual ITypeReference GetBaseClass(EmitContext context);
    public sealed virtual IEnumerable`1<IEventDefinition> GetEvents(EmitContext context);
    public sealed virtual IEnumerable`1<MethodImplementation> GetExplicitImplementationOverrides(EmitContext context);
    public sealed virtual IEnumerable`1<IFieldDefinition> GetFields(EmitContext context);
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<TypeReferenceWithAttributes> Interfaces(EmitContext context);
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsWindowsRuntimeImport();
    public sealed virtual bool get_IsSealed();
    public sealed virtual LayoutKind get_Layout();
    public sealed virtual IEnumerable`1<IMethodDefinition> GetMethods(EmitContext context);
    public sealed virtual IEnumerable`1<INestedTypeDefinition> GetNestedTypes(EmitContext context);
    public sealed virtual IEnumerable`1<IPropertyDefinition> GetProperties(EmitContext context);
    public sealed virtual UInt32 get_SizeOf();
    public sealed virtual CharSet get_StringFormat();
    public sealed virtual bool get_IsPublic();
    public bool get_IsNested();
    private sealed virtual override IEnumerable`1<IGenericTypeParameter> Microsoft.Cci.ITypeDefinition.get_GenericParameters();
    private sealed virtual override ushort Microsoft.Cci.ITypeDefinition.get_GenericParameterCount();
    private sealed virtual override IEnumerable`1<SecurityAttribute> Microsoft.Cci.ITypeDefinition.get_SecurityAttributes();
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsEnum();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsValueType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.GetResolvedType(EmitContext context);
    private sealed virtual override PrimitiveTypeCode Microsoft.Cci.ITypeReference.get_TypeCode();
    private sealed virtual override ushort Microsoft.Cci.INamedTypeReference.get_GenericParameterCount();
    private sealed virtual override IUnitReference Microsoft.Cci.INamespaceTypeReference.GetUnit(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamespaceTypeReference.get_NamespaceName();
    private sealed virtual override IGenericMethodParameterReference Microsoft.Cci.ITypeReference.get_AsGenericMethodParameterReference();
    private sealed virtual override IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.get_AsGenericTypeInstanceReference();
    private sealed virtual override IGenericTypeParameterReference Microsoft.Cci.ITypeReference.get_AsGenericTypeParameterReference();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.ITypeReference.AsNamespaceTypeDefinition(EmitContext context);
    private sealed virtual override INamespaceTypeReference Microsoft.Cci.ITypeReference.get_AsNamespaceTypeReference();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.ITypeReference.AsNestedTypeDefinition(EmitContext context);
    private sealed virtual override INestedTypeReference Microsoft.Cci.ITypeReference.get_AsNestedTypeReference();
    private sealed virtual override ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.get_AsSpecializedNestedTypeReference();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.AsTypeDefinition(EmitContext context);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
}
internal class Microsoft.Cci.SecurityAttribute : ValueType {
    [CompilerGeneratedAttribute]
private DeclarativeSecurityAction <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private ICustomAttribute <Attribute>k__BackingField;
    public DeclarativeSecurityAction Action { get; }
    public ICustomAttribute Attribute { get; }
    public SecurityAttribute(DeclarativeSecurityAction action, ICustomAttribute attribute);
    [CompilerGeneratedAttribute]
public DeclarativeSecurityAction get_Action();
    [CompilerGeneratedAttribute]
public ICustomAttribute get_Attribute();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.Cci.SequencePoint : ValueType {
    public int Offset;
    public int StartLine;
    public int StartColumn;
    public int EndLine;
    public int EndColumn;
    public DebugSourceDocument Document;
    public bool IsHidden { get; }
    public SequencePoint(DebugSourceDocument document, int offset, int startLine, int startColumn, int endLine, int endColumn);
    public bool get_IsHidden();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private string GetDebuggerDisplay();
}
internal class Microsoft.Cci.SymWriterMetadataProvider : object {
    private MetadataWriter _writer;
    private int _lastTypeDef;
    private string _lastTypeDefName;
    private string _lastTypeDefNamespace;
    internal SymWriterMetadataProvider(MetadataWriter writer);
    public sealed virtual bool TryGetTypeDefinitionInfo(int typeDefinitionToken, String& namespaceName, String& typeName, TypeAttributes& attributes);
    public sealed virtual bool TryGetMethodInfo(int methodDefinitionToken, String& methodName, Int32& declaringTypeToken);
    public sealed virtual bool TryGetEnclosingType(int nestedTypeToken, Int32& enclosingTypeToken);
}
[FlagsAttribute]
internal enum Microsoft.Cci.TypeLibTypeFlags : Enum {
    public int value__;
    public static TypeLibTypeFlags FAppObject;
    public static TypeLibTypeFlags FCanCreate;
    public static TypeLibTypeFlags FLicensed;
    public static TypeLibTypeFlags FPreDeclId;
    public static TypeLibTypeFlags FHidden;
    public static TypeLibTypeFlags FControl;
    public static TypeLibTypeFlags FDual;
    public static TypeLibTypeFlags FNonExtensible;
    public static TypeLibTypeFlags FOleAutomation;
    public static TypeLibTypeFlags FRestricted;
    public static TypeLibTypeFlags FAggregatable;
    public static TypeLibTypeFlags FReplaceable;
    public static TypeLibTypeFlags FDispatchable;
    public static TypeLibTypeFlags FReverseBind;
}
internal enum Microsoft.Cci.TypeMemberVisibility : Enum {
    public int value__;
    public static TypeMemberVisibility Private;
    public static TypeMemberVisibility FamilyAndAssembly;
    public static TypeMemberVisibility Assembly;
    public static TypeMemberVisibility Family;
    public static TypeMemberVisibility FamilyOrAssembly;
    public static TypeMemberVisibility Public;
}
[ExtensionAttribute]
internal static class Microsoft.Cci.TypeNameSerializer : object {
    [ExtensionAttribute]
internal static string GetSerializedTypeName(ITypeReference typeReference, EmitContext context);
    [ExtensionAttribute]
internal static string GetSerializedTypeName(ITypeReference typeReference, EmitContext context, Boolean& isAssemblyQualified);
    private static void AppendSerializedTypeName(StringBuilder sb, ITypeReference type, Boolean& isAssemQualified, EmitContext context);
    private static void AppendAssemblyQualifierIfNecessary(StringBuilder sb, ITypeReference typeReference, Boolean& isAssemQualified, EmitContext context);
    private static string GetMangledAndEscapedName(INamedTypeReference namedType);
    private static ITypeReference UnwrapTypeReference(ITypeReference typeReference, EmitContext context);
    internal static string BuildQualifiedNamespaceName(INamespace namespace);
}
internal enum Microsoft.Cci.TypeParameterVariance : Enum {
    public int value__;
    public static TypeParameterVariance NonVariant;
    public static TypeParameterVariance Covariant;
    public static TypeParameterVariance Contravariant;
}
internal class Microsoft.Cci.TypeReferenceWithAttributes : ValueType {
    [CompilerGeneratedAttribute]
private ITypeReference <TypeRef>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ICustomAttribute> <Attributes>k__BackingField;
    public ITypeReference TypeRef { get; }
    public ImmutableArray`1<ICustomAttribute> Attributes { get; }
    public TypeReferenceWithAttributes(ITypeReference typeRef, ImmutableArray`1<ICustomAttribute> attributes);
    [CompilerGeneratedAttribute]
public ITypeReference get_TypeRef();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ICustomAttribute> get_Attributes();
}
internal class Microsoft.Cci.TypeSpecComparer : object {
    private MetadataWriter _metadataWriter;
    internal TypeSpecComparer(MetadataWriter metadataWriter);
    public sealed virtual bool Equals(ITypeReference x, ITypeReference y);
    public sealed virtual int GetHashCode(ITypeReference typeReference);
}
internal class Microsoft.Cci.UsedNamespaceOrType : ValueType {
    public string AliasOpt;
    public IAssemblyReference TargetAssemblyOpt;
    public INamespace TargetNamespaceOpt;
    public ITypeReference TargetTypeOpt;
    public string TargetXmlNamespaceOpt;
    private UsedNamespaceOrType(string alias, IAssemblyReference targetAssembly, INamespace targetNamespace, ITypeReference targetType, string targetXmlNamespace);
    internal static UsedNamespaceOrType CreateType(ITypeReference type, string aliasOpt);
    internal static UsedNamespaceOrType CreateNamespace(INamespace namespace, IAssemblyReference assemblyOpt, string aliasOpt);
    internal static UsedNamespaceOrType CreateExternAlias(string alias);
    internal static UsedNamespaceOrType CreateXmlNamespace(string prefix, string xmlNamespace);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UsedNamespaceOrType other);
    public virtual int GetHashCode();
}
internal enum Microsoft.Cci.VarEnum : Enum {
    public int value__;
    public static VarEnum VT_EMPTY;
    public static VarEnum VT_NULL;
    public static VarEnum VT_I2;
    public static VarEnum VT_I4;
    public static VarEnum VT_R4;
    public static VarEnum VT_R8;
    public static VarEnum VT_CY;
    public static VarEnum VT_DATE;
    public static VarEnum VT_BSTR;
    public static VarEnum VT_DISPATCH;
    public static VarEnum VT_ERROR;
    public static VarEnum VT_BOOL;
    public static VarEnum VT_VARIANT;
    public static VarEnum VT_UNKNOWN;
    public static VarEnum VT_DECIMAL;
    public static VarEnum VT_I1;
    public static VarEnum VT_UI1;
    public static VarEnum VT_UI2;
    public static VarEnum VT_UI4;
    public static VarEnum VT_I8;
    public static VarEnum VT_UI8;
    public static VarEnum VT_INT;
    public static VarEnum VT_UINT;
    public static VarEnum VT_VOID;
    public static VarEnum VT_HRESULT;
    public static VarEnum VT_PTR;
    public static VarEnum VT_SAFEARRAY;
    public static VarEnum VT_CARRAY;
    public static VarEnum VT_USERDEFINED;
    public static VarEnum VT_LPSTR;
    public static VarEnum VT_LPWSTR;
    public static VarEnum VT_RECORD;
    public static VarEnum VT_FILETIME;
    public static VarEnum VT_BLOB;
    public static VarEnum VT_STREAM;
    public static VarEnum VT_STORAGE;
    public static VarEnum VT_STREAMED_OBJECT;
    public static VarEnum VT_STORED_OBJECT;
    public static VarEnum VT_BLOB_OBJECT;
    public static VarEnum VT_CF;
    public static VarEnum VT_CLSID;
    public static VarEnum VT_VECTOR;
    public static VarEnum VT_ARRAY;
    public static VarEnum VT_BYREF;
}
internal abstract class Microsoft.CodeAnalysis.AbstractLookupSymbolsInfo`1 : object {
    private IEqualityComparer`1<string> _comparer;
    private Dictionary`2<string, UniqueSymbolOrArities<TSymbol>> _nameMap;
    [CompilerGeneratedAttribute]
private string <FilterName>k__BackingField;
    internal string FilterName { get; internal set; }
    public ICollection`1<string> Names { get; }
    public int Count { get; }
    protected AbstractLookupSymbolsInfo`1(IEqualityComparer`1<string> comparer);
    [CompilerGeneratedAttribute]
internal string get_FilterName();
    [CompilerGeneratedAttribute]
internal void set_FilterName(string value);
    public bool CanBeAdded(string name);
    public void AddSymbol(TSymbol symbol, string name, int arity);
    public ICollection`1<string> get_Names();
    public int get_Count();
    public bool TryGetAritiesAndUniqueSymbol(string name, IArityEnumerable& arities, TSymbol& uniqueSymbol);
    public void Clear();
}
public enum Microsoft.CodeAnalysis.Accessibility : Enum {
    public int value__;
    public static Accessibility NotApplicable;
    public static Accessibility Private;
    public static Accessibility ProtectedAndInternal;
    public static Accessibility ProtectedAndFriend;
    public static Accessibility Protected;
    public static Accessibility Internal;
    public static Accessibility Friend;
    public static Accessibility ProtectedOrInternal;
    public static Accessibility ProtectedOrFriend;
    public static Accessibility Public;
}
public abstract class Microsoft.CodeAnalysis.AdditionalText : object {
    public string Path { get; }
    public abstract virtual string get_Path();
    public abstract virtual SourceText GetText(CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.AdditionalTextFile : AdditionalText {
    private CommandLineSourceFile _sourceFile;
    private CommonCompiler _compiler;
    private SourceText _text;
    private IList`1<DiagnosticInfo> _diagnostics;
    private object _lockObject;
    public string Path { get; }
    internal IList`1<DiagnosticInfo> Diagnostics { get; }
    public AdditionalTextFile(CommandLineSourceFile sourceFile, CommonCompiler compiler);
    public virtual string get_Path();
    public virtual SourceText GetText(CancellationToken cancellationToken);
    internal IList`1<DiagnosticInfo> get_Diagnostics();
}
internal abstract class Microsoft.CodeAnalysis.AnalyzerAssemblyLoader : object {
    private object _guard;
    private Dictionary`2<string, Assembly> _loadedAssembliesByPath;
    private Dictionary`2<string, AssemblyIdentity> _loadedAssemblyIdentitiesByPath;
    private Dictionary`2<AssemblyIdentity, Assembly> _loadedAssembliesByIdentity;
    private Dictionary`2<string, List`1<string>> _knownAssemblyPathsBySimpleName;
    protected abstract virtual Assembly LoadFromPathImpl(string fullPath);
    public sealed virtual void AddDependencyLocation(string fullPath);
    public sealed virtual Assembly LoadFromPath(string fullPath);
    private Assembly LoadFromPathUnchecked(string fullPath);
    private Assembly LoadFromPathUncheckedCore(string fullPath, AssemblyIdentity identity);
    private Assembly AddToCache(Assembly assembly, string fullPath, AssemblyIdentity identity);
    private AssemblyIdentity GetOrAddAssemblyIdentity(string fullPath);
    private AssemblyIdentity AddToCache(string fullPath, AssemblyIdentity identity);
    public Assembly Load(string displayName);
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.AnnotationExtensions : object {
    [ExtensionAttribute]
public static TNode WithAdditionalAnnotations(TNode node, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static TNode WithAdditionalAnnotations(TNode node, IEnumerable`1<SyntaxAnnotation> annotations);
    [ExtensionAttribute]
public static TNode WithoutAnnotations(TNode node, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static TNode WithoutAnnotations(TNode node, IEnumerable`1<SyntaxAnnotation> annotations);
    [ExtensionAttribute]
public static TNode WithoutAnnotations(TNode node, string annotationKind);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ArrayBuilderExtensions : object {
    [ExtensionAttribute]
public static bool Any(ArrayBuilder`1<T> builder, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Any(ArrayBuilder`1<T> builder, Func`3<T, A, bool> predicate, A arg);
    [ExtensionAttribute]
public static bool All(ArrayBuilder`1<T> builder, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ArrayBuilder`1<TItem> items, Func`2<TItem, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ArrayBuilder`1<TItem> items, Func`3<TItem, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static void AddOptional(ArrayBuilder`1<T> builder, T item);
    [ExtensionAttribute]
public static void Push(ArrayBuilder`1<T> builder, T e);
    [ExtensionAttribute]
public static T Pop(ArrayBuilder`1<T> builder);
    [ExtensionAttribute]
public static T Peek(ArrayBuilder`1<T> builder);
    [ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableOrEmptyAndFree(ArrayBuilder`1<T> builderOpt);
    [ExtensionAttribute]
public static void AddIfNotNull(ArrayBuilder`1<T> builder, Nullable`1<T> value);
    [ExtensionAttribute]
public static void AddIfNotNull(ArrayBuilder`1<T> builder, T value);
}
[DebuggerDisplayAttribute("{Value,nq}")]
internal class Microsoft.CodeAnalysis.ArrayElement`1 : ValueType {
    internal T Value;
    public static T op_Implicit(ArrayElement`1<T> element);
    public static ArrayElement`1[] MakeElementArray(T[] items);
    public static T[] MakeArray(ArrayElement`1[] items);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.AssemblyIdentity : object {
    private AssemblyContentType _contentType;
    private string _name;
    private Version _version;
    private string _cultureName;
    private ImmutableArray`1<byte> _publicKey;
    private ImmutableArray`1<byte> _lazyPublicKeyToken;
    private bool _isRetargetable;
    private string _lazyDisplayName;
    private int _lazyHashCode;
    internal static int PublicKeyTokenSize;
    internal static Version NullVersion;
    internal static string InvariantCultureDisplay;
    private static int PublicKeyTokenBytes;
    public string Name { get; }
    public Version Version { get; }
    public string CultureName { get; }
    public AssemblyNameFlags Flags { get; }
    public AssemblyContentType ContentType { get; }
    public bool HasPublicKey { get; }
    public ImmutableArray`1<byte> PublicKey { get; }
    public ImmutableArray`1<byte> PublicKeyToken { get; }
    public bool IsStrongName { get; }
    public bool IsRetargetable { get; }
    private AssemblyIdentity(AssemblyIdentity other, Version version);
    public AssemblyIdentity(string name, Version version, string cultureName, ImmutableArray`1<byte> publicKeyOrToken, bool hasPublicKey, bool isRetargetable, AssemblyContentType contentType);
    internal AssemblyIdentity(string name, Version version, string cultureName, ImmutableArray`1<byte> publicKeyOrToken, bool hasPublicKey);
    internal AssemblyIdentity(bool noThrow, string name, Version version, string cultureName, ImmutableArray`1<byte> publicKeyOrToken, bool hasPublicKey, bool isRetargetable, AssemblyContentType contentType);
    private static AssemblyIdentity();
    internal AssemblyIdentity WithVersion(Version version);
    private static string NormalizeCultureName(string cultureName);
    private static void InitializeKey(ImmutableArray`1<byte> publicKeyOrToken, bool hasPublicKey, ImmutableArray`1& publicKey, ImmutableArray`1& publicKeyToken);
    internal static bool IsValidCultureName(string name);
    private static bool IsValidName(string name);
    private static bool IsValid(Version value);
    private static bool IsValid(AssemblyContentType value);
    public string get_Name();
    public Version get_Version();
    public string get_CultureName();
    public AssemblyNameFlags get_Flags();
    public AssemblyContentType get_ContentType();
    public bool get_HasPublicKey();
    public ImmutableArray`1<byte> get_PublicKey();
    public ImmutableArray`1<byte> get_PublicKeyToken();
    public bool get_IsStrongName();
    public bool get_IsRetargetable();
    internal static bool IsFullName(AssemblyIdentityParts parts);
    public static bool op_Equality(AssemblyIdentity left, AssemblyIdentity right);
    public static bool op_Inequality(AssemblyIdentity left, AssemblyIdentity right);
    public sealed virtual bool Equals(AssemblyIdentity obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal int GetHashCodeIgnoringNameAndVersion();
    internal static ImmutableArray`1<byte> CalculatePublicKeyToken(ImmutableArray`1<byte> publicKey);
    internal static Nullable`1<bool> MemberwiseEqual(AssemblyIdentity x, AssemblyIdentity y);
    internal static bool EqualIgnoringNameAndVersion(AssemblyIdentity x, AssemblyIdentity y);
    internal static bool KeysEqual(AssemblyIdentity x, AssemblyIdentity y);
    public static AssemblyIdentity FromAssemblyDefinition(Assembly assembly);
    internal static AssemblyIdentity FromAssemblyDefinition(AssemblyName name);
    internal static AssemblyIdentity FromAssemblyReference(AssemblyName name);
    public string GetDisplayName(bool fullKey);
    public virtual string ToString();
    internal static string PublicKeyToString(ImmutableArray`1<byte> key);
    private string BuildDisplayName(bool fullKey);
    private static void AppendKey(StringBuilder sb, ImmutableArray`1<byte> key);
    private string GetDebuggerDisplay();
    public static bool TryParseDisplayName(string displayName, AssemblyIdentity& identity);
    public static bool TryParseDisplayName(string displayName, AssemblyIdentity& identity, AssemblyIdentityParts& parts);
    private static bool TryParseNameToken(string displayName, Int32& position, String& value);
    private static bool IsNameTokenTerminator(char c);
    private static bool IsQuote(char c);
    internal static Version ToVersion(ulong version);
    internal static bool TryParseVersion(string str, UInt64& result, AssemblyIdentityParts& parts);
    private static bool TryParsePublicKey(string value, ImmutableArray`1& key);
    private static bool TryParsePublicKeyToken(string value, ImmutableArray`1& token);
    private static bool TryParseHexBytes(string value, ImmutableArray`1& result);
    internal static int HexValue(char c);
    private static bool IsWhiteSpace(char c);
    private static void EscapeName(StringBuilder result, string name);
    private static bool TryUnescape(string str, int start, int end, String& value);
    private static bool Unescape(StringBuilder sb, string str, Int32& i);
}
public class Microsoft.CodeAnalysis.AssemblyIdentityComparer : object {
    [CompilerGeneratedAttribute]
private static AssemblyIdentityComparer <Default>k__BackingField;
    public static AssemblyIdentityComparer Default { get; }
    public static StringComparer SimpleNameComparer { get; }
    public static StringComparer CultureComparer { get; }
    private static AssemblyIdentityComparer();
    [CompilerGeneratedAttribute]
public static AssemblyIdentityComparer get_Default();
    public static StringComparer get_SimpleNameComparer();
    public static StringComparer get_CultureComparer();
    public bool ReferenceMatchesDefinition(string referenceDisplayName, AssemblyIdentity definition);
    public bool ReferenceMatchesDefinition(AssemblyIdentity reference, AssemblyIdentity definition);
    public ComparisonResult Compare(AssemblyIdentity reference, AssemblyIdentity definition);
    internal ComparisonResult Compare(AssemblyIdentity reference, string referenceDisplayName, AssemblyIdentity definition, Boolean& unificationApplied, bool ignoreVersion);
    private static Nullable`1<bool> TriviallyEquivalent(AssemblyIdentity x, AssemblyIdentity y);
    internal virtual bool ApplyUnificationPolicies(AssemblyIdentity& reference, AssemblyIdentity& definition, AssemblyIdentityParts referenceParts, Boolean& isDefinitionFxAssembly);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.AssemblyIdentityExtensions : object {
    [ExtensionAttribute]
internal static bool IsWindowsComponent(AssemblyIdentity identity);
    [ExtensionAttribute]
internal static bool IsWindowsRuntime(AssemblyIdentity identity);
}
internal class Microsoft.CodeAnalysis.AssemblyIdentityMap`1 : object {
    private Dictionary`2<string, OneOrMany`1<KeyValuePair`2<AssemblyIdentity, TValue>>> _map;
    public bool Contains(AssemblyIdentity identity, bool allowHigherVersion);
    public bool TryGetValue(AssemblyIdentity identity, TValue& value, bool allowHigherVersion);
    public bool TryGetValue(AssemblyIdentity identity, TValue& value, Func`4<Version, Version, TValue, bool> comparer);
    public void Add(AssemblyIdentity identity, TValue value);
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.AssemblyIdentityParts : Enum {
    public int value__;
    public static AssemblyIdentityParts Name;
    public static AssemblyIdentityParts Version;
    public static AssemblyIdentityParts VersionMajor;
    public static AssemblyIdentityParts VersionMinor;
    public static AssemblyIdentityParts VersionBuild;
    public static AssemblyIdentityParts VersionRevision;
    public static AssemblyIdentityParts Culture;
    public static AssemblyIdentityParts PublicKey;
    public static AssemblyIdentityParts PublicKeyToken;
    public static AssemblyIdentityParts PublicKeyOrToken;
    public static AssemblyIdentityParts Retargetability;
    public static AssemblyIdentityParts ContentType;
    public static AssemblyIdentityParts Unknown;
}
internal static class Microsoft.CodeAnalysis.AssemblyIdentityUtils : object {
    public static AssemblyIdentity TryGetAssemblyIdentity(string filePath);
}
public class Microsoft.CodeAnalysis.AssemblyMetadata : Metadata {
    private Func`2<string, ModuleMetadata> _moduleFactoryOpt;
    private ImmutableArray`1<ModuleMetadata> _initialModules;
    private Data _lazyData;
    private ImmutableArray`1<ModuleMetadata> _lazyPublishedModules;
    internal WeakList`1<IAssemblySymbol> CachedSymbols;
    public MetadataImageKind Kind { get; }
    private AssemblyMetadata(AssemblyMetadata other);
    internal AssemblyMetadata(ImmutableArray`1<ModuleMetadata> modules);
    internal AssemblyMetadata(ModuleMetadata manifestModule, Func`2<string, ModuleMetadata> moduleFactory);
    public static AssemblyMetadata CreateFromImage(ImmutableArray`1<byte> peImage);
    public static AssemblyMetadata CreateFromImage(IEnumerable`1<byte> peImage);
    public static AssemblyMetadata CreateFromStream(Stream peStream, bool leaveOpen);
    public static AssemblyMetadata CreateFromStream(Stream peStream, PEStreamOptions options);
    public static AssemblyMetadata CreateFromFile(string path);
    internal static AssemblyMetadata CreateFromFile(ModuleMetadata manifestModule, string path);
    public static AssemblyMetadata Create(ModuleMetadata module);
    public static AssemblyMetadata Create(ImmutableArray`1<ModuleMetadata> modules);
    public static AssemblyMetadata Create(IEnumerable`1<ModuleMetadata> modules);
    public static AssemblyMetadata Create(ModuleMetadata[] modules);
    internal AssemblyMetadata Copy();
    protected virtual Metadata CommonCopy();
    public ImmutableArray`1<ModuleMetadata> GetModules();
    internal PEAssembly GetAssembly();
    private Data GetOrCreateData();
    public virtual void Dispose();
    internal bool IsValidAssembly();
    public virtual MetadataImageKind get_Kind();
    public PortableExecutableReference GetReference(DocumentationProvider documentation, ImmutableArray`1<string> aliases, bool embedInteropTypes, string filePath, string display);
}
internal class Microsoft.CodeAnalysis.AssemblyPortabilityPolicy : ValueType {
    public bool SuppressSilverlightPlatformAssembliesPortability;
    public bool SuppressSilverlightLibraryAssembliesPortability;
    private static XmlReaderSettings s_xmlSettings;
    public AssemblyPortabilityPolicy(bool suppressSilverlightPlatformAssembliesPortability, bool suppressSilverlightLibraryAssembliesPortability);
    private static AssemblyPortabilityPolicy();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AssemblyPortabilityPolicy other);
    public virtual int GetHashCode();
    private static bool ReadToChild(XmlReader reader, int depth, string elementName, string elementNamespace);
    internal static AssemblyPortabilityPolicy LoadFromXml(Stream input);
}
internal class Microsoft.CodeAnalysis.AssemblyVersion : ValueType {
    private ushort _major;
    private ushort _minor;
    private ushort _build;
    private ushort _revision;
    public int Major { get; }
    public int Minor { get; }
    public int Build { get; }
    public int Revision { get; }
    public AssemblyVersion(ushort major, ushort minor, ushort build, ushort revision);
    public int get_Major();
    public int get_Minor();
    public int get_Build();
    public int get_Revision();
    private ulong ToInteger();
    public sealed virtual int CompareTo(AssemblyVersion other);
    public sealed virtual bool Equals(AssemblyVersion other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AssemblyVersion left, AssemblyVersion right);
    public static bool op_Inequality(AssemblyVersion left, AssemblyVersion right);
    public static bool op_LessThan(AssemblyVersion left, AssemblyVersion right);
    public static bool op_LessThanOrEqual(AssemblyVersion left, AssemblyVersion right);
    public static bool op_GreaterThan(AssemblyVersion left, AssemblyVersion right);
    public static bool op_GreaterThanOrEqual(AssemblyVersion left, AssemblyVersion right);
    public static AssemblyVersion op_Explicit(Version version);
    public static Version op_Explicit(AssemblyVersion version);
}
public abstract class Microsoft.CodeAnalysis.AttributeData : object {
    public INamedTypeSymbol AttributeClass { get; }
    protected INamedTypeSymbol CommonAttributeClass { get; }
    public IMethodSymbol AttributeConstructor { get; }
    protected IMethodSymbol CommonAttributeConstructor { get; }
    public SyntaxReference ApplicationSyntaxReference { get; }
    protected SyntaxReference CommonApplicationSyntaxReference { get; }
    public ImmutableArray`1<TypedConstant> ConstructorArguments { get; }
    protected internal ImmutableArray`1<TypedConstant> CommonConstructorArguments { get; }
    public ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> NamedArguments { get; }
    protected internal ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> CommonNamedArguments { get; }
    internal bool IsConditionallyOmitted { get; }
    internal bool HasErrors { get; }
    public INamedTypeSymbol get_AttributeClass();
    protected abstract virtual INamedTypeSymbol get_CommonAttributeClass();
    public IMethodSymbol get_AttributeConstructor();
    protected abstract virtual IMethodSymbol get_CommonAttributeConstructor();
    public SyntaxReference get_ApplicationSyntaxReference();
    protected abstract virtual SyntaxReference get_CommonApplicationSyntaxReference();
    public ImmutableArray`1<TypedConstant> get_ConstructorArguments();
    protected internal abstract virtual ImmutableArray`1<TypedConstant> get_CommonConstructorArguments();
    public ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> get_NamedArguments();
    protected internal abstract virtual ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> get_CommonNamedArguments();
    internal virtual bool get_IsConditionallyOmitted();
    internal virtual bool get_HasErrors();
    internal static bool IsTargetEarlyAttribute(INamedTypeSymbol attributeType, int attributeArgCount, AttributeDescription description);
    internal T GetConstructorArgument(int i, SpecialType specialType);
    internal T DecodeNamedArgument(string name, SpecialType specialType, T defaultValue);
    private static T DecodeNamedArgument(ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments, string name, SpecialType specialType, T defaultValue);
    private static int IndexOfNamedArgument(ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments, string name);
    internal ConstantValue DecodeDecimalConstantValue();
    internal ConstantValue DecodeDateTimeConstantValue();
    internal ObsoleteAttributeData DecodeObsoleteAttribute(ObsoleteAttributeKind kind);
    private ObsoleteAttributeData DecodeObsoleteAttribute();
    private ObsoleteAttributeData DecodeDeprecatedAttribute();
    private ObsoleteAttributeData DecodeExperimentalAttribute();
    internal static void DecodeMethodImplAttribute(DecodeWellKnownAttributeArguments`3& arguments, CommonMessageProvider messageProvider);
    internal static void DecodeStructLayoutAttribute(DecodeWellKnownAttributeArguments`3& arguments, CharSet defaultCharSet, int defaultAutoLayoutSize, CommonMessageProvider messageProvider);
    internal AttributeUsageInfo DecodeAttributeUsageAttribute();
    internal static AttributeUsageInfo DecodeAttributeUsageAttribute(TypedConstant positionalArg, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArgs);
}
internal class Microsoft.CodeAnalysis.AttributeDescription : ValueType {
    public string Namespace;
    public string Name;
    public Byte[][] Signatures;
    public bool MatchIgnoringCase;
    private static byte Void;
    private static byte Boolean;
    private static byte Char;
    private static byte SByte;
    private static byte Byte;
    private static byte Int16;
    private static byte UInt16;
    private static byte Int32;
    private static byte UInt32;
    private static byte Int64;
    private static byte UInt64;
    private static byte Single;
    private static byte Double;
    private static byte String;
    private static byte Object;
    private static byte SzArray;
    private static byte TypeHandle;
    internal static ImmutableArray`1<TypeHandleTargetInfo> TypeHandleTargets;
    private static Byte[] s_signature_HasThis_Void;
    private static Byte[] s_signature_HasThis_Void_Int16;
    private static Byte[] s_signature_HasThis_Void_Int32;
    private static Byte[] s_signature_HasThis_Void_UInt32;
    private static Byte[] s_signature_HasThis_Void_Int32_Int32;
    private static Byte[] s_signature_HasThis_Void_Int32_Int32_Int32_Int32;
    private static Byte[] s_signature_HasThis_Void_String;
    private static Byte[] s_signature_HasThis_Void_Object;
    private static Byte[] s_signature_HasThis_Void_String_String;
    private static Byte[] s_signature_HasThis_Void_String_Boolean;
    private static Byte[] s_signature_HasThis_Void_String_String_String;
    private static Byte[] s_signature_HasThis_Void_String_String_String_String;
    private static Byte[] s_signature_HasThis_Void_AttributeTargets;
    private static Byte[] s_signature_HasThis_Void_AssemblyNameFlags;
    private static Byte[] s_signature_HasThis_Void_MethodImplOptions;
    private static Byte[] s_signature_HasThis_Void_CharSet;
    private static Byte[] s_signature_HasThis_Void_LayoutKind;
    private static Byte[] s_signature_HasThis_Void_UnmanagedType;
    private static Byte[] s_signature_HasThis_Void_TypeLibTypeFlags;
    private static Byte[] s_signature_HasThis_Void_ClassInterfaceType;
    private static Byte[] s_signature_HasThis_Void_ComInterfaceType;
    private static Byte[] s_signature_HasThis_Void_CompilationRelaxations;
    private static Byte[] s_signature_HasThis_Void_DebuggingModes;
    private static Byte[] s_signature_HasThis_Void_SecurityCriticalScope;
    private static Byte[] s_signature_HasThis_Void_CallingConvention;
    private static Byte[] s_signature_HasThis_Void_AssemblyHashAlgorithm;
    private static Byte[] s_signature_HasThis_Void_Int64;
    private static Byte[] s_signature_HasThis_Void_UInt8_UInt8_UInt32_UInt32_UInt32;
    private static Byte[] s_signature_HasThis_Void_UIn8_UInt8_Int32_Int32_Int32;
    private static Byte[] s_signature_HasThis_Void_Boolean;
    private static Byte[] s_signature_HasThis_Void_Boolean_Boolean;
    private static Byte[] s_signature_HasThis_Void_Boolean_TransactionOption;
    private static Byte[] s_signature_HasThis_Void_Boolean_TransactionOption_Int32;
    private static Byte[] s_signature_HasThis_Void_Boolean_TransactionOption_Int32_Boolean;
    private static Byte[] s_signature_HasThis_Void_SecurityAction;
    private static Byte[] s_signature_HasThis_Void_Type;
    private static Byte[] s_signature_HasThis_Void_Type_Type;
    private static Byte[] s_signature_HasThis_Void_Type_Type_Type;
    private static Byte[] s_signature_HasThis_Void_Type_Type_Type_Type;
    private static Byte[] s_signature_HasThis_Void_Type_Int32;
    private static Byte[] s_signature_HasThis_Void_SzArray_Boolean;
    private static Byte[] s_signature_HasThis_Void_SzArray_String;
    private static Byte[] s_signature_HasThis_Void_String_DeprecationType_UInt32;
    private static Byte[] s_signature_HasThis_Void_String_DeprecationType_UInt32_Platform;
    private static Byte[] s_signature_HasThis_Void_String_DeprecationType_UInt32_Type;
    private static Byte[] s_signature_HasThis_Void_String_DeprecationType_UInt32_String;
    private static Byte[][] s_signaturesOfTypeIdentifierAttribute;
    private static Byte[][] s_signaturesOfStandardModuleAttribute;
    private static Byte[][] s_signaturesOfExtensionAttribute;
    private static Byte[][] s_signaturesOfAttributeUsage;
    private static Byte[][] s_signaturesOfAssemblySignatureKeyAttribute;
    private static Byte[][] s_signaturesOfAssemblyKeyFileAttribute;
    private static Byte[][] s_signaturesOfAssemblyKeyNameAttribute;
    private static Byte[][] s_signaturesOfAssemblyDelaySignAttribute;
    private static Byte[][] s_signaturesOfAssemblyVersionAttribute;
    private static Byte[][] s_signaturesOfAssemblyFileVersionAttribute;
    private static Byte[][] s_signaturesOfAssemblyTitleAttribute;
    private static Byte[][] s_signaturesOfAssemblyDescriptionAttribute;
    private static Byte[][] s_signaturesOfAssemblyCultureAttribute;
    private static Byte[][] s_signaturesOfAssemblyCompanyAttribute;
    private static Byte[][] s_signaturesOfAssemblyProductAttribute;
    private static Byte[][] s_signaturesOfAssemblyInformationalVersionAttribute;
    private static Byte[][] s_signaturesOfAssemblyCopyrightAttribute;
    private static Byte[][] s_signaturesOfSatelliteContractVersionAttribute;
    private static Byte[][] s_signaturesOfAssemblyTrademarkAttribute;
    private static Byte[][] s_signaturesOfAssemblyFlagsAttribute;
    private static Byte[][] s_signaturesOfDefaultMemberAttribute;
    private static Byte[][] s_signaturesOfAccessedThroughPropertyAttribute;
    private static Byte[][] s_signaturesOfIndexerNameAttribute;
    private static Byte[][] s_signaturesOfInternalsVisibleToAttribute;
    private static Byte[][] s_signaturesOfOptionalAttribute;
    private static Byte[][] s_signaturesOfDefaultParameterValueAttribute;
    private static Byte[][] s_signaturesOfDateTimeConstantAttribute;
    private static Byte[][] s_signaturesOfDecimalConstantAttribute;
    private static Byte[][] s_signaturesOfIUnknownConstantAttribute;
    private static Byte[][] s_signaturesOfCallerFilePathAttribute;
    private static Byte[][] s_signaturesOfCallerLineNumberAttribute;
    private static Byte[][] s_signaturesOfCallerMemberNameAttribute;
    private static Byte[][] s_signaturesOfIDispatchConstantAttribute;
    private static Byte[][] s_signaturesOfParamArrayAttribute;
    private static Byte[][] s_signaturesOfDllImportAttribute;
    private static Byte[][] s_signaturesOfUnverifiableCodeAttribute;
    private static Byte[][] s_signaturesOfSecurityPermissionAttribute;
    private static Byte[][] s_signaturesOfCoClassAttribute;
    private static Byte[][] s_signaturesOfComImportAttribute;
    private static Byte[][] s_signaturesOfGuidAttribute;
    private static Byte[][] s_signaturesOfCLSCompliantAttribute;
    private static Byte[][] s_signaturesOfMethodImplAttribute;
    private static Byte[][] s_signaturesOfPreserveSigAttribute;
    private static Byte[][] s_signaturesOfDefaultCharSetAttribute;
    private static Byte[][] s_signaturesOfSpecialNameAttribute;
    private static Byte[][] s_signaturesOfNonSerializedAttribute;
    private static Byte[][] s_signaturesOfFieldOffsetAttribute;
    private static Byte[][] s_signaturesOfSerializableAttribute;
    private static Byte[][] s_signaturesOfInAttribute;
    private static Byte[][] s_signaturesOfOutAttribute;
    private static Byte[][] s_signaturesOfIsReadOnlyAttribute;
    private static Byte[][] s_signaturesOfIsUnmanagedAttribute;
    private static Byte[][] s_signaturesOfFixedBufferAttribute;
    private static Byte[][] s_signaturesOfSuppressUnmanagedCodeSecurityAttribute;
    private static Byte[][] s_signaturesOfPrincipalPermissionAttribute;
    private static Byte[][] s_signaturesOfPermissionSetAttribute;
    private static Byte[][] s_signaturesOfStructLayoutAttribute;
    private static Byte[][] s_signaturesOfMarshalAsAttribute;
    private static Byte[][] s_signaturesOfTypeLibTypeAttribute;
    private static Byte[][] s_signaturesOfWebMethodAttribute;
    private static Byte[][] s_signaturesOfHostProtectionAttribute;
    private static Byte[][] s_signaturesOfVisualBasicEmbedded;
    private static Byte[][] s_signaturesOfCodeAnalysisEmbedded;
    private static Byte[][] s_signaturesOfVisualBasicComClassAttribute;
    private static Byte[][] s_signaturesOfClassInterfaceAttribute;
    private static Byte[][] s_signaturesOfInterfaceTypeAttribute;
    private static Byte[][] s_signaturesOfCompilationRelaxationsAttribute;
    private static Byte[][] s_signaturesOfReferenceAssemblyAttribute;
    private static Byte[][] s_signaturesOfDebuggableAttribute;
    private static Byte[][] s_signaturesOfComSourceInterfacesAttribute;
    private static Byte[][] s_signaturesOfComVisibleAttribute;
    private static Byte[][] s_signaturesOfConditionalAttribute;
    private static Byte[][] s_signaturesOfTypeLibVersionAttribute;
    private static Byte[][] s_signaturesOfComCompatibleVersionAttribute;
    private static Byte[][] s_signaturesOfWindowsRuntimeImportAttribute;
    private static Byte[][] s_signaturesOfDynamicSecurityMethodAttribute;
    private static Byte[][] s_signaturesOfRequiredAttributeAttribute;
    private static Byte[][] s_signaturesOfAsyncMethodBuilderAttribute;
    private static Byte[][] s_signaturesOfAsyncStateMachineAttribute;
    private static Byte[][] s_signaturesOfIteratorStateMachineAttribute;
    private static Byte[][] s_signaturesOfRuntimeCompatibilityAttribute;
    private static Byte[][] s_signaturesOfTypeForwardedToAttribute;
    private static Byte[][] s_signaturesOfSTAThreadAttribute;
    private static Byte[][] s_signaturesOfMTAThreadAttribute;
    private static Byte[][] s_signaturesOfOptionCompareAttribute;
    private static Byte[][] s_signaturesOfObsoleteAttribute;
    private static Byte[][] s_signaturesOfDynamicAttribute;
    private static Byte[][] s_signaturesOfTupleElementNamesAttribute;
    private static Byte[][] s_signaturesOfIsByRefLikeAttribute;
    private static Byte[][] s_signaturesOfDebuggerHiddenAttribute;
    private static Byte[][] s_signaturesOfDebuggerNonUserCodeAttribute;
    private static Byte[][] s_signaturesOfDebuggerStepperBoundaryAttribute;
    private static Byte[][] s_signaturesOfDebuggerStepThroughAttribute;
    private static Byte[][] s_signaturesOfSecurityCriticalAttribute;
    private static Byte[][] s_signaturesOfSecuritySafeCriticalAttribute;
    private static Byte[][] s_signaturesOfDesignerGeneratedAttribute;
    private static Byte[][] s_signaturesOfMyGroupCollectionAttribute;
    private static Byte[][] s_signaturesOfComEventInterfaceAttribute;
    private static Byte[][] s_signaturesOfBestFitMappingAttribute;
    private static Byte[][] s_signaturesOfFlagsAttribute;
    private static Byte[][] s_signaturesOfLCIDConversionAttribute;
    private static Byte[][] s_signaturesOfUnmanagedFunctionPointerAttribute;
    private static Byte[][] s_signaturesOfPrimaryInteropAssemblyAttribute;
    private static Byte[][] s_signaturesOfImportedFromTypeLibAttribute;
    private static Byte[][] s_signaturesOfDefaultEventAttribute;
    private static Byte[][] s_signaturesOfAssemblyConfigurationAttribute;
    private static Byte[][] s_signaturesOfAssemblyAlgorithmIdAttribute;
    private static Byte[][] s_signaturesOfDeprecatedAttribute;
    private static Byte[][] s_signaturesOfExperimentalAttribute;
    private static Byte[][] s_signaturesOfExcludeFromCodeCoverageAttribute;
    internal static AttributeDescription OptionalAttribute;
    internal static AttributeDescription ComImportAttribute;
    internal static AttributeDescription AttributeUsageAttribute;
    internal static AttributeDescription ConditionalAttribute;
    internal static AttributeDescription CaseInsensitiveExtensionAttribute;
    internal static AttributeDescription CaseSensitiveExtensionAttribute;
    internal static AttributeDescription InternalsVisibleToAttribute;
    internal static AttributeDescription AssemblySignatureKeyAttribute;
    internal static AttributeDescription AssemblyKeyFileAttribute;
    internal static AttributeDescription AssemblyKeyNameAttribute;
    internal static AttributeDescription ParamArrayAttribute;
    internal static AttributeDescription DefaultMemberAttribute;
    internal static AttributeDescription IndexerNameAttribute;
    internal static AttributeDescription AssemblyDelaySignAttribute;
    internal static AttributeDescription AssemblyVersionAttribute;
    internal static AttributeDescription AssemblyFileVersionAttribute;
    internal static AttributeDescription AssemblyTitleAttribute;
    internal static AttributeDescription AssemblyDescriptionAttribute;
    internal static AttributeDescription AssemblyCultureAttribute;
    internal static AttributeDescription AssemblyCompanyAttribute;
    internal static AttributeDescription AssemblyProductAttribute;
    internal static AttributeDescription AssemblyInformationalVersionAttribute;
    internal static AttributeDescription AssemblyCopyrightAttribute;
    internal static AttributeDescription SatelliteContractVersionAttribute;
    internal static AttributeDescription AssemblyTrademarkAttribute;
    internal static AttributeDescription AssemblyFlagsAttribute;
    internal static AttributeDescription DecimalConstantAttribute;
    internal static AttributeDescription IUnknownConstantAttribute;
    internal static AttributeDescription CallerFilePathAttribute;
    internal static AttributeDescription CallerLineNumberAttribute;
    internal static AttributeDescription CallerMemberNameAttribute;
    internal static AttributeDescription IDispatchConstantAttribute;
    internal static AttributeDescription DefaultParameterValueAttribute;
    internal static AttributeDescription UnverifiableCodeAttribute;
    internal static AttributeDescription SecurityPermissionAttribute;
    internal static AttributeDescription DllImportAttribute;
    internal static AttributeDescription MethodImplAttribute;
    internal static AttributeDescription PreserveSigAttribute;
    internal static AttributeDescription DefaultCharSetAttribute;
    internal static AttributeDescription SpecialNameAttribute;
    internal static AttributeDescription SerializableAttribute;
    internal static AttributeDescription NonSerializedAttribute;
    internal static AttributeDescription StructLayoutAttribute;
    internal static AttributeDescription FieldOffsetAttribute;
    internal static AttributeDescription FixedBufferAttribute;
    internal static AttributeDescription MarshalAsAttribute;
    internal static AttributeDescription InAttribute;
    internal static AttributeDescription OutAttribute;
    internal static AttributeDescription IsReadOnlyAttribute;
    internal static AttributeDescription IsUnmanagedAttribute;
    internal static AttributeDescription CoClassAttribute;
    internal static AttributeDescription GuidAttribute;
    internal static AttributeDescription CLSCompliantAttribute;
    internal static AttributeDescription HostProtectionAttribute;
    internal static AttributeDescription SuppressUnmanagedCodeSecurityAttribute;
    internal static AttributeDescription PrincipalPermissionAttribute;
    internal static AttributeDescription PermissionSetAttribute;
    internal static AttributeDescription TypeIdentifierAttribute;
    internal static AttributeDescription VisualBasicEmbeddedAttribute;
    internal static AttributeDescription CodeAnalysisEmbeddedAttribute;
    internal static AttributeDescription VisualBasicComClassAttribute;
    internal static AttributeDescription StandardModuleAttribute;
    internal static AttributeDescription OptionCompareAttribute;
    internal static AttributeDescription AccessedThroughPropertyAttribute;
    internal static AttributeDescription WebMethodAttribute;
    internal static AttributeDescription DateTimeConstantAttribute;
    internal static AttributeDescription ClassInterfaceAttribute;
    internal static AttributeDescription ComSourceInterfacesAttribute;
    internal static AttributeDescription ComVisibleAttribute;
    internal static AttributeDescription DispIdAttribute;
    internal static AttributeDescription TypeLibVersionAttribute;
    internal static AttributeDescription ComCompatibleVersionAttribute;
    internal static AttributeDescription InterfaceTypeAttribute;
    internal static AttributeDescription WindowsRuntimeImportAttribute;
    internal static AttributeDescription DynamicSecurityMethodAttribute;
    internal static AttributeDescription RequiredAttributeAttribute;
    internal static AttributeDescription AsyncMethodBuilderAttribute;
    internal static AttributeDescription AsyncStateMachineAttribute;
    internal static AttributeDescription IteratorStateMachineAttribute;
    internal static AttributeDescription CompilationRelaxationsAttribute;
    internal static AttributeDescription ReferenceAssemblyAttribute;
    internal static AttributeDescription RuntimeCompatibilityAttribute;
    internal static AttributeDescription DebuggableAttribute;
    internal static AttributeDescription TypeForwardedToAttribute;
    internal static AttributeDescription STAThreadAttribute;
    internal static AttributeDescription MTAThreadAttribute;
    internal static AttributeDescription ObsoleteAttribute;
    internal static AttributeDescription TypeLibTypeAttribute;
    internal static AttributeDescription DynamicAttribute;
    internal static AttributeDescription TupleElementNamesAttribute;
    internal static AttributeDescription IsByRefLikeAttribute;
    internal static AttributeDescription DebuggerHiddenAttribute;
    internal static AttributeDescription DebuggerNonUserCodeAttribute;
    internal static AttributeDescription DebuggerStepperBoundaryAttribute;
    internal static AttributeDescription DebuggerStepThroughAttribute;
    internal static AttributeDescription SecurityCriticalAttribute;
    internal static AttributeDescription SecuritySafeCriticalAttribute;
    internal static AttributeDescription DesignerGeneratedAttribute;
    internal static AttributeDescription MyGroupCollectionAttribute;
    internal static AttributeDescription ComEventInterfaceAttribute;
    internal static AttributeDescription BestFitMappingAttribute;
    internal static AttributeDescription FlagsAttribute;
    internal static AttributeDescription LCIDConversionAttribute;
    internal static AttributeDescription UnmanagedFunctionPointerAttribute;
    internal static AttributeDescription PrimaryInteropAssemblyAttribute;
    internal static AttributeDescription ImportedFromTypeLibAttribute;
    internal static AttributeDescription DefaultEventAttribute;
    internal static AttributeDescription AssemblyConfigurationAttribute;
    internal static AttributeDescription AssemblyAlgorithmIdAttribute;
    internal static AttributeDescription DeprecatedAttribute;
    internal static AttributeDescription ExperimentalAttribute;
    internal static AttributeDescription ExcludeFromCodeCoverageAttribute;
    public string FullName { get; }
    public AttributeDescription(string namespace, string name, Byte[][] signatures, bool matchIgnoringCase);
    private static AttributeDescription();
    public string get_FullName();
    public virtual string ToString();
    internal int GetParameterCount(int signatureIndex);
}
internal class Microsoft.CodeAnalysis.AttributeUsageInfo : ValueType {
    private PackedAttributeUsage _flags;
    internal static AttributeUsageInfo Default;
    internal static AttributeUsageInfo Null;
    public bool IsNull { get; }
    internal AttributeTargets ValidTargets { get; }
    internal bool AllowMultiple { get; }
    internal bool Inherited { get; }
    internal bool HasValidAttributeTargets { get; }
    internal AttributeUsageInfo(AttributeTargets validTargets, bool allowMultiple, bool inherited);
    private static AttributeUsageInfo();
    public bool get_IsNull();
    internal AttributeTargets get_ValidTargets();
    internal bool get_AllowMultiple();
    internal bool get_Inherited();
    public static bool op_Equality(AttributeUsageInfo left, AttributeUsageInfo right);
    public static bool op_Inequality(AttributeUsageInfo left, AttributeUsageInfo right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AttributeUsageInfo other);
    public virtual int GetHashCode();
    internal bool get_HasValidAttributeTargets();
    internal object GetValidTargetsErrorArgument();
    private static string GetErrorDisplayNameResourceId(AttributeTargets target);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.BitVector : ValueType {
    private static UInt32 ZeroWord;
    private static int Log2BitsPerWord;
    public static int BitsPerWord;
    private static UInt32[] s_emptyArray;
    private static BitVector s_nullValue;
    private static BitVector s_emptyValue;
    private UInt32 _bits0;
    private UInt32[] _bits;
    private int _capacity;
    public int Capacity { get; }
    public bool IsNull { get; }
    public static BitVector Null { get; }
    public static BitVector Empty { get; }
    public bool Item { get; public set; }
    private BitVector(UInt32 bits0, UInt32[] bits, int capacity);
    private static BitVector();
    public sealed virtual bool Equals(BitVector other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(BitVector left, BitVector right);
    public static bool op_Inequality(BitVector left, BitVector right);
    public virtual int GetHashCode();
    private static int WordsForCapacity(int capacity);
    public int get_Capacity();
    [ConditionalAttribute("DEBUG_BITARRAY")]
private void Check();
    public void EnsureCapacity(int newCapacity);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.BitVector/<Words>d__20")]
public IEnumerable`1<UInt32> Words();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.BitVector/<TrueBits>d__21")]
public IEnumerable`1<int> TrueBits();
    public static BitVector Create(int capacity);
    public static BitVector AllSet(int capacity);
    public BitVector Clone();
    public bool get_IsNull();
    public static BitVector get_Null();
    public static BitVector get_Empty();
    public bool IntersectWith(BitVector& other);
    public bool UnionWith(BitVector& other);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public void Clear();
    public static bool IsTrue(UInt32 word, int index);
    public static int WordsRequired(int capacity);
}
internal static class Microsoft.CodeAnalysis.Boxes : object {
    public static object BoxedTrue;
    public static object BoxedFalse;
    public static object BoxedByteZero;
    public static object BoxedSByteZero;
    public static object BoxedInt16Zero;
    public static object BoxedUInt16Zero;
    public static object BoxedInt32Zero;
    public static object BoxedInt32One;
    public static object BoxedUInt32Zero;
    public static object BoxedInt64Zero;
    public static object BoxedUInt64Zero;
    public static object BoxedSingleZero;
    public static object BoxedDoubleZero;
    public static object BoxedDecimalZero;
    private static Object[] s_boxedAsciiChars;
    private static Boxes();
    public static object Box(bool b);
    public static object Box(byte b);
    public static object Box(sbyte sb);
    public static object Box(short s);
    public static object Box(ushort us);
    public static object Box(int i);
    public static object Box(UInt32 u);
    public static object Box(long l);
    public static object Box(ulong ul);
    public static object Box(float f);
    public static object Box(double d);
    public static object Box(char c);
    public static object Box(decimal d);
}
internal class Microsoft.CodeAnalysis.BuildPaths : ValueType {
    [CompilerGeneratedAttribute]
private string <ClientDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SdkDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TempDirectory>k__BackingField;
    internal string ClientDirectory { get; }
    internal string WorkingDirectory { get; }
    internal string SdkDirectory { get; }
    internal string TempDirectory { get; }
    internal BuildPaths(string clientDir, string workingDir, string sdkDir, string tempDir);
    [CompilerGeneratedAttribute]
internal string get_ClientDirectory();
    [CompilerGeneratedAttribute]
internal string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
internal string get_SdkDirectory();
    [CompilerGeneratedAttribute]
internal string get_TempDirectory();
}
internal abstract class Microsoft.CodeAnalysis.CachingBase`1 : object {
    protected int mask;
    protected TEntry[] entries;
    internal CachingBase`1(int size);
    private static int AlignSize(int size);
}
internal class Microsoft.CodeAnalysis.CachingFactory`2 : CachingBase`1<Entry<TKey, TValue>> {
    private int _size;
    private Func`2<TKey, TValue> _valueFactory;
    private Func`2<TKey, int> _keyHash;
    private Func`3<TKey, TValue, bool> _keyValueEquality;
    public CachingFactory`2(int size, Func`2<TKey, TValue> valueFactory, Func`2<TKey, int> keyHash, Func`3<TKey, TValue, bool> keyValueEquality);
    public void Add(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public TValue GetOrMakeValue(TKey key);
    private int GetKeyHash(TKey key);
}
internal class Microsoft.CodeAnalysis.CachingIdentityFactory`2 : CachingBase`1<Entry<TKey, TValue>> {
    private Func`2<TKey, TValue> _valueFactory;
    private ObjectPool`1<CachingIdentityFactory`2<TKey, TValue>> _pool;
    public CachingIdentityFactory`2(int size, Func`2<TKey, TValue> valueFactory);
    public CachingIdentityFactory`2(int size, Func`2<TKey, TValue> valueFactory, ObjectPool`1<CachingIdentityFactory`2<TKey, TValue>> pool);
    public void Add(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
    public TValue GetOrMakeValue(TKey key);
    public static ObjectPool`1<CachingIdentityFactory`2<TKey, TValue>> CreatePool(int size, Func`2<TKey, TValue> valueFactory);
    public void Free();
}
public enum Microsoft.CodeAnalysis.CandidateReason : Enum {
    public int value__;
    public static CandidateReason None;
    public static CandidateReason NotATypeOrNamespace;
    public static CandidateReason NotAnEvent;
    public static CandidateReason NotAWithEventsMember;
    public static CandidateReason NotAnAttributeType;
    public static CandidateReason WrongArity;
    public static CandidateReason NotCreatable;
    public static CandidateReason NotReferencable;
    public static CandidateReason Inaccessible;
    public static CandidateReason NotAValue;
    public static CandidateReason NotAVariable;
    public static CandidateReason NotInvocable;
    public static CandidateReason StaticInstanceMismatch;
    public static CandidateReason OverloadResolutionFailure;
    public static CandidateReason LateBound;
    public static CandidateReason Ambiguous;
    public static CandidateReason MemberGroup;
}
public static class Microsoft.CodeAnalysis.CaseInsensitiveComparison : object {
    private static TextInfo s_unicodeCultureTextInfo;
    private static OneToOneUnicodeComparer s_comparer;
    public static StringComparer Comparer { get; }
    private static CaseInsensitiveComparison();
    private static CultureInfo GetUnicodeCulture();
    public static char ToLower(char c);
    private static char ToLowerNonAscii(char c);
    public static StringComparer get_Comparer();
    public static bool Equals(string left, string right);
    public static bool EndsWith(string value, string possibleEnd);
    public static bool StartsWith(string value, string possibleStart);
    public static int Compare(string left, string right);
    public static int GetHashCode(string value);
    public static string ToLower(string value);
    public static void ToLower(StringBuilder builder);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.ChildSyntaxList : ValueType {
    private SyntaxNode _node;
    private int _count;
    public int Count { get; }
    public SyntaxNodeOrToken Item { get; }
    internal SyntaxNode Node { get; }
    private SyntaxNodeOrToken[] Nodes { get; }
    internal ChildSyntaxList(SyntaxNode node);
    public sealed virtual int get_Count();
    internal static int CountNodes(GreenNode green);
    public sealed virtual SyntaxNodeOrToken get_Item(int index);
    internal SyntaxNode get_Node();
    private static int Occupancy(GreenNode green);
    internal static SyntaxNodeOrToken ItemInternal(SyntaxNode node, int index);
    internal static SyntaxNodeOrToken ChildThatContainsPosition(SyntaxNode node, int targetPosition);
    internal static SyntaxNode ItemInternalAsNode(SyntaxNode node, int index);
    private SyntaxNodeOrToken[] get_Nodes();
    public bool Any();
    public SyntaxNodeOrToken First();
    public SyntaxNodeOrToken Last();
    public Reversed Reverse();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<SyntaxNodeOrToken> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ChildSyntaxList other);
    public virtual int GetHashCode();
    public static bool op_Equality(ChildSyntaxList list1, ChildSyntaxList list2);
    public static bool op_Inequality(ChildSyntaxList list1, ChildSyntaxList list2);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "15.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.CodeAnalysis.CodeAnalysisResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AbsolutePathExpected { get; }
    internal static string AnalyzerDriverFailure { get; }
    internal static string AnalyzerDriverThrows { get; }
    internal static string AnalyzerDriverThrowsDescription { get; }
    internal static string AnalyzerExecutionTimeColumnHeader { get; }
    internal static string AnalyzerNameColumnHeader { get; }
    internal static string AnalyzerTotalExecutionTime { get; }
    internal static string AnonymousTypeArgumentCountMismatch2 { get; }
    internal static string AnonymousTypeMemberAndNamesCountMismatch2 { get; }
    internal static string ArgumentCannotBeEmpty { get; }
    internal static string ArgumentElementCannotBeNull { get; }
    internal static string Arrays_with_more_than_one_dimension_cannot_be_serialized { get; }
    internal static string Assembly { get; }
    internal static string AssemblyFileNotFound { get; }
    internal static string AssemblyMustHaveAtLeastOneModule { get; }
    internal static string AssemblySigningNotSupported { get; }
    internal static string AsyncAnalyzerActionCannotBeRegistered { get; }
    internal static string Cannot_deserialize_type_0 { get; }
    internal static string Cannot_serialize_type_0 { get; }
    internal static string CannotAliasModule { get; }
    internal static string CannotCreateReferenceToModule { get; }
    internal static string CannotCreateReferenceToSubmission { get; }
    internal static string CannotEmbedInteropTypesFromModule { get; }
    internal static string CannotTargetNetModuleWhenEmittingRefAssembly { get; }
    internal static string CantCreateModuleReferenceToAssembly { get; }
    internal static string CantCreateReferenceToAssemblyWithoutLocation { get; }
    internal static string CantCreateReferenceToDynamicAssembly { get; }
    internal static string ChangesMustNotOverlap { get; }
    internal static string Class1 { get; }
    internal static string CoffResourceInvalidRelocation { get; }
    internal static string CoffResourceInvalidSectionSize { get; }
    internal static string CoffResourceInvalidSymbol { get; }
    internal static string CoffResourceMissingSection { get; }
    internal static string CompilationOptionsMustNotHaveErrors { get; }
    internal static string CompilationReferencesAssembliesWithDifferentAutoGeneratedVersion { get; }
    internal static string CompilerAnalyzerFailure { get; }
    internal static string CompilerAnalyzerThrows { get; }
    internal static string CompilerAnalyzerThrowsDescription { get; }
    internal static string Constructor { get; }
    internal static string Delegate1 { get; }
    internal static string Deserialization_reader_for_0_read_incorrect_number_of_values { get; }
    internal static string DiagnosticIdCantBeNullOrWhitespace { get; }
    internal static string DuplicateAnalyzerInstances { get; }
    internal static string ElementIsExpected { get; }
    internal static string EmbeddedTextsRequirePdb { get; }
    internal static string EmbeddingPdbUnexpectedWhenEmittingMetadata { get; }
    internal static string EmptyKeyInPathMap { get; }
    internal static string EmptyOrInvalidFileName { get; }
    internal static string EmptyOrInvalidResourceName { get; }
    internal static string EndMustNotBeLessThanStart { get; }
    internal static string Enum1 { get; }
    internal static string Event1 { get; }
    internal static string ExceptionContext { get; }
    internal static string ExceptionEnablingMulticoreJit { get; }
    internal static string ExpectedNonEmptyPublicKey { get; }
    internal static string FailedToResolveRuleSetName { get; }
    internal static string Field { get; }
    internal static string FileNotFound { get; }
    internal static string FileSizeExceedsMaximumAllowed { get; }
    internal static string FlowAnalysisFeatureDisabled { get; }
    internal static string GetMetadataMustReturnInstance { get; }
    internal static string IconStreamUnexpectedFormat { get; }
    internal static string IncludingPrivateMembersUnexpectedWhenEmittingToMetadataPeStream { get; }
    internal static string InconsistentLanguageVersions { get; }
    internal static string InconsistentSyntaxTreeFeature { get; }
    internal static string InMemoryAssembly { get; }
    internal static string InMemoryModule { get; }
    internal static string Interface1 { get; }
    internal static string InvalidAlias { get; }
    internal static string InvalidAssemblyName { get; }
    internal static string InvalidCharactersInAssemblyCultureName { get; }
    internal static string InvalidCharactersInAssemblyName { get; }
    internal static string InvalidCompilationOptions { get; }
    internal static string InvalidContentType { get; }
    internal static string InvalidCultureName { get; }
    internal static string InvalidDataAtOffset { get; }
    internal static string InvalidDiagnosticIdReported { get; }
    internal static string InvalidDiagnosticLocationReported { get; }
    internal static string InvalidDiagnosticSpanReported { get; }
    internal static string InvalidHash { get; }
    internal static string InvalidModuleName { get; }
    internal static string InvalidNodeToTrack { get; }
    internal static string InvalidOperationBlockForAnalysisContext { get; }
    internal static string InvalidOutputKindForSubmission { get; }
    internal static string InvalidPublicKey { get; }
    internal static string InvalidPublicKeyToken { get; }
    internal static string InvalidRuleSetInclude { get; }
    internal static string InvalidSizeOfPublicKeyToken { get; }
    internal static string InvalidTree { get; }
    internal static string KeepAliveIsNotAnInteger { get; }
    internal static string KeepAliveIsTooSmall { get; }
    internal static string KeepAliveWithoutShared { get; }
    internal static string MetadataPeStreamUnexpectedWhenEmittingMetadataOnly { get; }
    internal static string MetadataRefNotFoundToRemove1 { get; }
    internal static string Method { get; }
    internal static string MismatchedVersion { get; }
    internal static string MissingKeepAlive { get; }
    internal static string MissingListItem { get; }
    internal static string Module { get; }
    internal static string ModuleCopyCannotBeUsedToCreateAssemblyMetadata { get; }
    internal static string MultithreadedAnalyzerExecutionNote { get; }
    internal static string MustIncludePrivateMembersUnlessRefAssembly { get; }
    internal static string NameCannotBeEmpty { get; }
    internal static string NameCannotBeNull { get; }
    internal static string NameCannotStartWithWhitespace { get; }
    internal static string NameContainsInvalidCharacter { get; }
    internal static string NoAnalyzersFound { get; }
    internal static string NodeOrTokenOutOfSequence { get; }
    internal static string NotARootOperation { get; }
    internal static string NullValueInPathMap { get; }
    internal static string OperationHasNullSemanticModel { get; }
    internal static string OutputKindNotSupported { get; }
    internal static string Parameter { get; }
    internal static string PathReturnedByResolveMetadataFileMustBeAbsolute { get; }
    internal static string PathReturnedByResolveStrongNameKeyFileMustBeAbsolute { get; }
    internal static string PdbStreamUnexpectedWhenEmbedding { get; }
    internal static string PdbStreamUnexpectedWhenEmittingMetadataOnly { get; }
    internal static string PEImageDoesntContainManagedMetadata { get; }
    internal static string PEImageNotAvailable { get; }
    internal static string PreviousSubmissionHasErrors { get; }
    internal static string Property { get; }
    internal static string ReferenceOfTypeIsInvalid1 { get; }
    internal static string ReferenceResolverShouldReturnReadableNonNullStream { get; }
    internal static string ResourceDataProviderShouldReturnNonNullStream { get; }
    internal static string ResourceStreamEndedUnexpectedly { get; }
    internal static string ResourceStreamProviderShouldReturnNonNullStream { get; }
    internal static string Return1 { get; }
    internal static string ReturnTypeCannotBeValuePointerbyRefOrOpen { get; }
    internal static string ReturnTypeCannotBeVoidByRefOrOpen { get; }
    internal static string RuleSetBadAttributeValue { get; }
    internal static string RuleSetHasDuplicateRules { get; }
    internal static string RuleSetMissingAttribute { get; }
    internal static string SeparatorIsExpected { get; }
    internal static string SharedArgumentMissing { get; }
    internal static string SizeHasToBePositive { get; }
    internal static string SourceTextCannotBeEmbedded { get; }
    internal static string SpanDoesNotIncludeEndOfLine { get; }
    internal static string SpanDoesNotIncludeStartOfLine { get; }
    internal static string StartMustNotBeNegative { get; }
    internal static string Stream_contains_invalid_data { get; }
    internal static string StreamIsTooLong { get; }
    internal static string StreamMustSupportRead { get; }
    internal static string StreamMustSupportReadAndSeek { get; }
    internal static string StreamMustSupportWrite { get; }
    internal static string Struct1 { get; }
    internal static string SymWriterDoesNotSupportSourceLink { get; }
    internal static string SymWriterNotDeterministic { get; }
    internal static string SymWriterOlderVersionThanRequired { get; }
    internal static string The_type_0_is_not_understood_by_the_serialization_binder { get; }
    internal static string TheStreamCannotBeReadFrom { get; }
    internal static string TheStreamCannotBeWrittenTo { get; }
    internal static string TupleElementLocationCountMismatch { get; }
    internal static string TupleElementNameCountMismatch { get; }
    internal static string TupleElementNameEmpty { get; }
    internal static string TuplesNeedAtLeastTwoElements { get; }
    internal static string TupleUnderlyingTypeMustBeTupleCompatible { get; }
    internal static string TypeMustBeASubclassOfSyntaxAnnotation { get; }
    internal static string TypeMustBeSameAsHostObjectTypeOfPreviousSubmission { get; }
    internal static string TypeParameter { get; }
    internal static string UnexpectedTypeOfNodeInList { get; }
    internal static string UnrecognizedResourceFileFormat { get; }
    internal static string Unresolved { get; }
    internal static string UnsupportedAnalyzerInstance { get; }
    internal static string UnsupportedDiagnosticReported { get; }
    internal static string UnsupportedHashAlgorithm { get; }
    internal static string Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer { get; }
    internal static string WinRTIdentityCantBeRetargetable { get; }
    internal static string XmlReferencesNotSupported { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AbsolutePathExpected();
    internal static string get_AnalyzerDriverFailure();
    internal static string get_AnalyzerDriverThrows();
    internal static string get_AnalyzerDriverThrowsDescription();
    internal static string get_AnalyzerExecutionTimeColumnHeader();
    internal static string get_AnalyzerNameColumnHeader();
    internal static string get_AnalyzerTotalExecutionTime();
    internal static string get_AnonymousTypeArgumentCountMismatch2();
    internal static string get_AnonymousTypeMemberAndNamesCountMismatch2();
    internal static string get_ArgumentCannotBeEmpty();
    internal static string get_ArgumentElementCannotBeNull();
    internal static string get_Arrays_with_more_than_one_dimension_cannot_be_serialized();
    internal static string get_Assembly();
    internal static string get_AssemblyFileNotFound();
    internal static string get_AssemblyMustHaveAtLeastOneModule();
    internal static string get_AssemblySigningNotSupported();
    internal static string get_AsyncAnalyzerActionCannotBeRegistered();
    internal static string get_Cannot_deserialize_type_0();
    internal static string get_Cannot_serialize_type_0();
    internal static string get_CannotAliasModule();
    internal static string get_CannotCreateReferenceToModule();
    internal static string get_CannotCreateReferenceToSubmission();
    internal static string get_CannotEmbedInteropTypesFromModule();
    internal static string get_CannotTargetNetModuleWhenEmittingRefAssembly();
    internal static string get_CantCreateModuleReferenceToAssembly();
    internal static string get_CantCreateReferenceToAssemblyWithoutLocation();
    internal static string get_CantCreateReferenceToDynamicAssembly();
    internal static string get_ChangesMustNotOverlap();
    internal static string get_Class1();
    internal static string get_CoffResourceInvalidRelocation();
    internal static string get_CoffResourceInvalidSectionSize();
    internal static string get_CoffResourceInvalidSymbol();
    internal static string get_CoffResourceMissingSection();
    internal static string get_CompilationOptionsMustNotHaveErrors();
    internal static string get_CompilationReferencesAssembliesWithDifferentAutoGeneratedVersion();
    internal static string get_CompilerAnalyzerFailure();
    internal static string get_CompilerAnalyzerThrows();
    internal static string get_CompilerAnalyzerThrowsDescription();
    internal static string get_Constructor();
    internal static string get_Delegate1();
    internal static string get_Deserialization_reader_for_0_read_incorrect_number_of_values();
    internal static string get_DiagnosticIdCantBeNullOrWhitespace();
    internal static string get_DuplicateAnalyzerInstances();
    internal static string get_ElementIsExpected();
    internal static string get_EmbeddedTextsRequirePdb();
    internal static string get_EmbeddingPdbUnexpectedWhenEmittingMetadata();
    internal static string get_EmptyKeyInPathMap();
    internal static string get_EmptyOrInvalidFileName();
    internal static string get_EmptyOrInvalidResourceName();
    internal static string get_EndMustNotBeLessThanStart();
    internal static string get_Enum1();
    internal static string get_Event1();
    internal static string get_ExceptionContext();
    internal static string get_ExceptionEnablingMulticoreJit();
    internal static string get_ExpectedNonEmptyPublicKey();
    internal static string get_FailedToResolveRuleSetName();
    internal static string get_Field();
    internal static string get_FileNotFound();
    internal static string get_FileSizeExceedsMaximumAllowed();
    internal static string get_FlowAnalysisFeatureDisabled();
    internal static string get_GetMetadataMustReturnInstance();
    internal static string get_IconStreamUnexpectedFormat();
    internal static string get_IncludingPrivateMembersUnexpectedWhenEmittingToMetadataPeStream();
    internal static string get_InconsistentLanguageVersions();
    internal static string get_InconsistentSyntaxTreeFeature();
    internal static string get_InMemoryAssembly();
    internal static string get_InMemoryModule();
    internal static string get_Interface1();
    internal static string get_InvalidAlias();
    internal static string get_InvalidAssemblyName();
    internal static string get_InvalidCharactersInAssemblyCultureName();
    internal static string get_InvalidCharactersInAssemblyName();
    internal static string get_InvalidCompilationOptions();
    internal static string get_InvalidContentType();
    internal static string get_InvalidCultureName();
    internal static string get_InvalidDataAtOffset();
    internal static string get_InvalidDiagnosticIdReported();
    internal static string get_InvalidDiagnosticLocationReported();
    internal static string get_InvalidDiagnosticSpanReported();
    internal static string get_InvalidHash();
    internal static string get_InvalidModuleName();
    internal static string get_InvalidNodeToTrack();
    internal static string get_InvalidOperationBlockForAnalysisContext();
    internal static string get_InvalidOutputKindForSubmission();
    internal static string get_InvalidPublicKey();
    internal static string get_InvalidPublicKeyToken();
    internal static string get_InvalidRuleSetInclude();
    internal static string get_InvalidSizeOfPublicKeyToken();
    internal static string get_InvalidTree();
    internal static string get_KeepAliveIsNotAnInteger();
    internal static string get_KeepAliveIsTooSmall();
    internal static string get_KeepAliveWithoutShared();
    internal static string get_MetadataPeStreamUnexpectedWhenEmittingMetadataOnly();
    internal static string get_MetadataRefNotFoundToRemove1();
    internal static string get_Method();
    internal static string get_MismatchedVersion();
    internal static string get_MissingKeepAlive();
    internal static string get_MissingListItem();
    internal static string get_Module();
    internal static string get_ModuleCopyCannotBeUsedToCreateAssemblyMetadata();
    internal static string get_MultithreadedAnalyzerExecutionNote();
    internal static string get_MustIncludePrivateMembersUnlessRefAssembly();
    internal static string get_NameCannotBeEmpty();
    internal static string get_NameCannotBeNull();
    internal static string get_NameCannotStartWithWhitespace();
    internal static string get_NameContainsInvalidCharacter();
    internal static string get_NoAnalyzersFound();
    internal static string get_NodeOrTokenOutOfSequence();
    internal static string get_NotARootOperation();
    internal static string get_NullValueInPathMap();
    internal static string get_OperationHasNullSemanticModel();
    internal static string get_OutputKindNotSupported();
    internal static string get_Parameter();
    internal static string get_PathReturnedByResolveMetadataFileMustBeAbsolute();
    internal static string get_PathReturnedByResolveStrongNameKeyFileMustBeAbsolute();
    internal static string get_PdbStreamUnexpectedWhenEmbedding();
    internal static string get_PdbStreamUnexpectedWhenEmittingMetadataOnly();
    internal static string get_PEImageDoesntContainManagedMetadata();
    internal static string get_PEImageNotAvailable();
    internal static string get_PreviousSubmissionHasErrors();
    internal static string get_Property();
    internal static string get_ReferenceOfTypeIsInvalid1();
    internal static string get_ReferenceResolverShouldReturnReadableNonNullStream();
    internal static string get_ResourceDataProviderShouldReturnNonNullStream();
    internal static string get_ResourceStreamEndedUnexpectedly();
    internal static string get_ResourceStreamProviderShouldReturnNonNullStream();
    internal static string get_Return1();
    internal static string get_ReturnTypeCannotBeValuePointerbyRefOrOpen();
    internal static string get_ReturnTypeCannotBeVoidByRefOrOpen();
    internal static string get_RuleSetBadAttributeValue();
    internal static string get_RuleSetHasDuplicateRules();
    internal static string get_RuleSetMissingAttribute();
    internal static string get_SeparatorIsExpected();
    internal static string get_SharedArgumentMissing();
    internal static string get_SizeHasToBePositive();
    internal static string get_SourceTextCannotBeEmbedded();
    internal static string get_SpanDoesNotIncludeEndOfLine();
    internal static string get_SpanDoesNotIncludeStartOfLine();
    internal static string get_StartMustNotBeNegative();
    internal static string get_Stream_contains_invalid_data();
    internal static string get_StreamIsTooLong();
    internal static string get_StreamMustSupportRead();
    internal static string get_StreamMustSupportReadAndSeek();
    internal static string get_StreamMustSupportWrite();
    internal static string get_Struct1();
    internal static string get_SymWriterDoesNotSupportSourceLink();
    internal static string get_SymWriterNotDeterministic();
    internal static string get_SymWriterOlderVersionThanRequired();
    internal static string get_The_type_0_is_not_understood_by_the_serialization_binder();
    internal static string get_TheStreamCannotBeReadFrom();
    internal static string get_TheStreamCannotBeWrittenTo();
    internal static string get_TupleElementLocationCountMismatch();
    internal static string get_TupleElementNameCountMismatch();
    internal static string get_TupleElementNameEmpty();
    internal static string get_TuplesNeedAtLeastTwoElements();
    internal static string get_TupleUnderlyingTypeMustBeTupleCompatible();
    internal static string get_TypeMustBeASubclassOfSyntaxAnnotation();
    internal static string get_TypeMustBeSameAsHostObjectTypeOfPreviousSubmission();
    internal static string get_TypeParameter();
    internal static string get_UnexpectedTypeOfNodeInList();
    internal static string get_UnrecognizedResourceFileFormat();
    internal static string get_Unresolved();
    internal static string get_UnsupportedAnalyzerInstance();
    internal static string get_UnsupportedDiagnosticReported();
    internal static string get_UnsupportedHashAlgorithm();
    internal static string get_Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer();
    internal static string get_WinRTIdentityCantBeRetargetable();
    internal static string get_XmlReferencesNotSupported();
}
internal class Microsoft.CodeAnalysis.CodeAnalysisResourcesLocalizableErrorArgument : ValueType {
    private string _targetResourceId;
    internal CodeAnalysisResourcesLocalizableErrorArgument(string targetResourceId);
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
}
internal abstract class Microsoft.CodeAnalysis.CodeGen.ArrayMethod : object {
    private ImmutableArray`1<ArrayMethodParameterInfo> _parameters;
    protected IArrayTypeReference arrayType;
    public string Name { get; }
    public bool ReturnValueIsByRef { get; }
    public bool AcceptsExtraArguments { get; }
    public ushort GenericParameterCount { get; }
    public bool IsGeneric { get; }
    public ImmutableArray`1<IParameterTypeInformation> ExtraParameters { get; }
    public IGenericMethodInstanceReference AsGenericMethodInstanceReference { get; }
    public ISpecializedMethodReference AsSpecializedMethodReference { get; }
    public CallingConvention CallingConvention { get; }
    public ushort ParameterCount { get; }
    public ImmutableArray`1<ICustomModifier> RefCustomModifiers { get; }
    public ImmutableArray`1<ICustomModifier> ReturnValueCustomModifiers { get; }
    protected ArrayMethod(IArrayTypeReference arrayType);
    public abstract virtual string get_Name();
    public abstract virtual ITypeReference GetType(EmitContext context);
    public virtual bool get_ReturnValueIsByRef();
    protected virtual ImmutableArray`1<ArrayMethodParameterInfo> MakeParameters();
    public sealed virtual ImmutableArray`1<IParameterTypeInformation> GetParameters(EmitContext context);
    public sealed virtual bool get_AcceptsExtraArguments();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual IMethodDefinition GetResolvedMethod(EmitContext context);
    public sealed virtual ImmutableArray`1<IParameterTypeInformation> get_ExtraParameters();
    public sealed virtual IGenericMethodInstanceReference get_AsGenericMethodInstanceReference();
    public sealed virtual ISpecializedMethodReference get_AsSpecializedMethodReference();
    public sealed virtual CallingConvention get_CallingConvention();
    public sealed virtual ushort get_ParameterCount();
    public sealed virtual ImmutableArray`1<ICustomModifier> get_RefCustomModifiers();
    public sealed virtual ImmutableArray`1<ICustomModifier> get_ReturnValueCustomModifiers();
    public sealed virtual ITypeReference GetContainingType(EmitContext context);
    public sealed virtual IEnumerable`1<ICustomAttribute> GetAttributes(EmitContext context);
    public sealed virtual void Dispatch(MetadataVisitor visitor);
    public sealed virtual IDefinition AsDefinition(EmitContext context);
    public virtual string ToString();
}
internal class Microsoft.CodeAnalysis.CodeGen.ArrayMethodParameterInfo : object {
    private ushort _index;
    private static ArrayMethodParameterInfo s_index0;
    private static ArrayMethodParameterInfo s_index1;
    private static ArrayMethodParameterInfo s_index2;
    private static ArrayMethodParameterInfo s_index3;
    public ImmutableArray`1<ICustomModifier> RefCustomModifiers { get; }
    public ImmutableArray`1<ICustomModifier> CustomModifiers { get; }
    public bool IsByReference { get; }
    public ushort Index { get; }
    protected ArrayMethodParameterInfo(ushort index);
    private static ArrayMethodParameterInfo();
    public static ArrayMethodParameterInfo GetIndexParameter(ushort index);
    public sealed virtual ImmutableArray`1<ICustomModifier> get_RefCustomModifiers();
    public sealed virtual ImmutableArray`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual bool get_IsByReference();
    public virtual ITypeReference GetType(EmitContext context);
    public sealed virtual ushort get_Index();
}
internal class Microsoft.CodeAnalysis.CodeGen.ArrayMethods : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<ValueTuple`2<byte, IArrayTypeReference>, ArrayMethod> _dict;
    public ArrayMethod GetArrayConstructor(IArrayTypeReference arrayType);
    public ArrayMethod GetArrayGet(IArrayTypeReference arrayType);
    public ArrayMethod GetArraySet(IArrayTypeReference arrayType);
    public ArrayMethod GetArrayAddress(IArrayTypeReference arrayType);
    private ArrayMethod GetArrayMethod(IArrayTypeReference arrayType, ArrayMethodKind id);
    private static ArrayMethod MakeArrayMethod(IArrayTypeReference arrayType, ArrayMethodKind id);
}
internal class Microsoft.CodeAnalysis.CodeGen.ArraySetValueParameterInfo : ArrayMethodParameterInfo {
    private IArrayTypeReference _arrayType;
    internal ArraySetValueParameterInfo(ushort index, IArrayTypeReference arrayType);
    public virtual ITypeReference GetType(EmitContext context);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo : ValueType {
    public int SyntaxOffset;
    public DebugId ClosureId;
    public ClosureDebugInfo(int syntaxOffset, DebugId closureId);
    public sealed virtual bool Equals(ClosureDebugInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.CodeGen.CompilationTestData : object {
    public ConcurrentDictionary`2<IMethodSymbol, MethodData> Methods;
    public CommonPEModuleBuilder Module;
    public Func`2<ISymWriterMetadataProvider, SymUnmanagedWriter> SymWriterFactory;
    private ImmutableDictionary`2<string, MethodData> _lazyMethodsByName;
    private static SymbolDisplayFormat _testDataKeyFormat;
    private static SymbolDisplayFormat _testDataOperatorKeyFormat;
    private static CompilationTestData();
    public ILBuilder GetIL(Func`2<IMethodSymbol, bool> predicate);
    public ImmutableDictionary`2<string, MethodData> GetMethodsByName();
    private static string GetMethodName(IMethodSymbol methodSymbol);
}
internal class Microsoft.CodeAnalysis.CodeGen.DebugDocumentProvider : MulticastDelegate {
    public DebugDocumentProvider(object object, IntPtr method);
    public virtual DebugSourceDocument Invoke(string path, string basePath);
    public virtual IAsyncResult BeginInvoke(string path, string basePath, AsyncCallback callback, object object);
    public virtual DebugSourceDocument EndInvoke(IAsyncResult result);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.CodeGen.DebugId : ValueType {
    public static int UndefinedOrdinal;
    public int Ordinal;
    public int Generation;
    public DebugId(int ordinal, int generation);
    public sealed virtual bool Equals(DebugId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal string GetDebuggerDisplay();
}
internal abstract class Microsoft.CodeAnalysis.CodeGen.DefaultTypeDef : object {
    public IEnumerable`1<IGenericTypeParameter> GenericParameters { get; }
    public ushort GenericParameterCount { get; }
    public bool HasDeclarativeSecurity { get; }
    public bool IsAbstract { get; }
    public bool IsBeforeFieldInit { get; }
    public bool IsComObject { get; }
    public bool IsGeneric { get; }
    public bool IsInterface { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSerializable { get; }
    public bool IsSpecialName { get; }
    public bool IsWindowsRuntimeImport { get; }
    public bool IsSealed { get; }
    public IEnumerable`1<SecurityAttribute> SecurityAttributes { get; }
    public CharSet StringFormat { get; }
    public bool IsEnum { get; }
    public PrimitiveTypeCode TypeCode { get; }
    public TypeDefinitionHandle TypeDef { get; }
    public IGenericMethodParameterReference AsGenericMethodParameterReference { get; }
    public IGenericTypeInstanceReference AsGenericTypeInstanceReference { get; }
    public IGenericTypeParameterReference AsGenericTypeParameterReference { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public ISpecializedNestedTypeReference AsSpecializedNestedTypeReference { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    public bool MangleName { get; }
    public ushort Alignment { get; }
    public LayoutKind Layout { get; }
    public UInt32 SizeOf { get; }
    public bool IsValueType { get; }
    public sealed virtual IEnumerable`1<IEventDefinition> GetEvents(EmitContext context);
    public sealed virtual IEnumerable`1<MethodImplementation> GetExplicitImplementationOverrides(EmitContext context);
    public virtual IEnumerable`1<IFieldDefinition> GetFields(EmitContext context);
    public sealed virtual IEnumerable`1<IGenericTypeParameter> get_GenericParameters();
    public sealed virtual ushort get_GenericParameterCount();
    public sealed virtual bool get_HasDeclarativeSecurity();
    public sealed virtual IEnumerable`1<TypeReferenceWithAttributes> Interfaces(EmitContext context);
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsBeforeFieldInit();
    public sealed virtual bool get_IsComObject();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual bool get_IsInterface();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsWindowsRuntimeImport();
    public sealed virtual bool get_IsSealed();
    public virtual IEnumerable`1<IMethodDefinition> GetMethods(EmitContext context);
    public virtual IEnumerable`1<INestedTypeDefinition> GetNestedTypes(EmitContext context);
    public sealed virtual IEnumerable`1<IPropertyDefinition> GetProperties(EmitContext context);
    public sealed virtual IEnumerable`1<SecurityAttribute> get_SecurityAttributes();
    public sealed virtual CharSet get_StringFormat();
    public virtual IEnumerable`1<ICustomAttribute> GetAttributes(EmitContext context);
    public sealed virtual IDefinition AsDefinition(EmitContext context);
    public sealed virtual bool get_IsEnum();
    public sealed virtual ITypeDefinition GetResolvedType(EmitContext context);
    public sealed virtual PrimitiveTypeCode get_TypeCode();
    public sealed virtual TypeDefinitionHandle get_TypeDef();
    public sealed virtual IGenericMethodParameterReference get_AsGenericMethodParameterReference();
    public sealed virtual IGenericTypeInstanceReference get_AsGenericTypeInstanceReference();
    public sealed virtual IGenericTypeParameterReference get_AsGenericTypeParameterReference();
    public virtual INamespaceTypeDefinition AsNamespaceTypeDefinition(EmitContext context);
    public virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    public sealed virtual ISpecializedNestedTypeReference get_AsSpecializedNestedTypeReference();
    public virtual INestedTypeDefinition AsNestedTypeDefinition(EmitContext context);
    public virtual INestedTypeReference get_AsNestedTypeReference();
    public sealed virtual ITypeDefinition AsTypeDefinition(EmitContext context);
    public sealed virtual bool get_MangleName();
    public virtual ushort get_Alignment();
    public virtual ITypeReference GetBaseClass(EmitContext context);
    public virtual LayoutKind get_Layout();
    public virtual UInt32 get_SizeOf();
    public virtual void Dispatch(MetadataVisitor visitor);
    public virtual bool get_IsValueType();
}
internal class Microsoft.CodeAnalysis.CodeGen.DynamicAnalysisMethodBodyData : object {
    public ImmutableArray`1<SourceSpan> Spans;
    public DynamicAnalysisMethodBodyData(ImmutableArray`1<SourceSpan> spans);
}
internal class Microsoft.CodeAnalysis.CodeGen.ExplicitSizeStruct : DefaultTypeDef {
    private UInt32 _size;
    private INamedTypeDefinition _containingType;
    private ITypeReference _sysValueType;
    public ushort Alignment { get; }
    public LayoutKind Layout { get; }
    public UInt32 SizeOf { get; }
    public string Name { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public bool IsValueType { get; }
    public INestedTypeReference AsNestedTypeReference { get; }
    internal ExplicitSizeStruct(UInt32 size, PrivateImplementationDetails containingType, ITypeReference sysValueType);
    public virtual string ToString();
    public virtual ushort get_Alignment();
    public virtual ITypeReference GetBaseClass(EmitContext context);
    public virtual LayoutKind get_Layout();
    public virtual UInt32 get_SizeOf();
    public virtual void Dispatch(MetadataVisitor visitor);
    public sealed virtual string get_Name();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public virtual bool get_IsValueType();
    public sealed virtual ITypeReference GetContainingType(EmitContext context);
    public virtual INestedTypeDefinition AsNestedTypeDefinition(EmitContext context);
    public virtual INestedTypeReference get_AsNestedTypeReference();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.CodeGen.ILBuilder : object {
    private OptimizationLevel _optimizations;
    internal LocalSlotManager LocalSlotManager;
    private LocalScopeManager _scopeManager;
    internal ITokenDeferral module;
    internal BasicBlock leaderBlock;
    private EmitState _emitState;
    private BasicBlock _lastCompleteBlock;
    private BasicBlock _currentBlock;
    private SyntaxTree _lastSeqPointTree;
    private SmallDictionary`2<object, LabelInfo> _labelInfos;
    private int _instructionCountAtLastLabel;
    internal ImmutableArray`1<byte> RealizedIL;
    internal ImmutableArray`1<ExceptionHandlerRegion> RealizedExceptionHandlers;
    internal SequencePointList RealizedSequencePoints;
    public ArrayBuilder`1<RawSequencePoint> SeqPointsOpt;
    private ArrayBuilder`1<ILMarker> _allocatedILMarkers;
    private bool _pendingBlockCreate;
    private int _initialHiddenSequencePointMarker;
    [CompilerGeneratedAttribute]
private bool <HasDynamicLocal>k__BackingField;
    private ExceptionHandlerScope EnclosingExceptionHandler { get; }
    internal bool InExceptionHandler { get; }
    internal ushort MaxStack { get; }
    internal int InstructionsEmitted { get; }
    internal bool HasDynamicLocal { get; private set; }
    internal bool IsStackEmpty { get; }
    internal ILBuilder(ITokenDeferral module, LocalSlotManager localSlotManager, OptimizationLevel optimizations);
    private BasicBlock GetCurrentBlock();
    private void CreateBlock();
    private SwitchBlock CreateSwitchBlock();
    private void UpdatesForCreatedBlock(BasicBlock block);
    private void CreateBlockIfPending();
    private void EndBlock();
    private void ReconcileTrailingMarkers();
    private ExceptionHandlerScope get_EnclosingExceptionHandler();
    internal bool get_InExceptionHandler();
    internal void Realize();
    internal ImmutableArray`1<LocalScope> GetAllScopes();
    internal ImmutableArray`1<StateMachineHoistedLocalScope> GetHoistedLocalScopes();
    internal void FreeBasicBlocks();
    internal ushort get_MaxStack();
    internal int get_InstructionsEmitted();
    private void MarkReachableBlocks();
    private static void PushReachableBlockToProcess(ArrayBuilder`1<BasicBlock> reachableBlocks, BasicBlock block);
    private static void MarkReachableFrom(ArrayBuilder`1<BasicBlock> reachableBlocks, BasicBlock block);
    private static void MarkReachableFromBranch(ArrayBuilder`1<BasicBlock> reachableBlocks, BasicBlock block);
    private static void RedirectBranchToBlockedDestination(BasicBlock block, object blockedDest);
    private static object BlockedBranchDestination(BasicBlock src, BasicBlock dest);
    private static object BlockedBranchDestinationSlow(ExceptionHandlerScope destHandler, ExceptionHandlerScope srcHandler);
    private static void MarkReachableFromTry(ArrayBuilder`1<BasicBlock> reachableBlocks, BasicBlock block);
    private static void MarkReachableFromSwitch(ArrayBuilder`1<BasicBlock> reachableBlocks, BasicBlock block);
    private bool OptimizeLabels();
    private bool ForwardLabelsNoLeaving();
    private bool ForwardLabelsAllowLeaving();
    private static bool CanMoveLabelToAnotherHandler(ExceptionHandlerScope currentHandler, ExceptionHandlerScope newHandler);
    private bool DropUnreachableBlocks();
    private void MarkAllBlocksUnreachable();
    private void ComputeOffsets();
    private void RewriteSpecialBlocks();
    private static bool IsSpecialEndHandlerBlock(BasicBlock block);
    private void RewriteBranchesAcrossExceptionHandlers();
    private bool ComputeOffsetsAndAdjustBranches();
    private void RealizeBlocks();
    private void RealizeSequencePoints();
    internal void DefineSequencePoint(SyntaxTree syntaxTree, TextSpan span);
    internal void DefineHiddenSequencePoint();
    internal void DefineInitialHiddenSequencePoint();
    internal void SetInitialDebugDocument(SyntaxTree initialSequencePointTree);
    [ConditionalAttribute("DEBUG")]
internal void AssertStackEmpty();
    internal bool IsJustPastLabel();
    internal void OpenLocalScope(ScopeType scopeType, ITypeReference exceptionType);
    internal bool PossiblyDefinedOutsideOfTry(LocalDefinition local);
    internal void MarkFilterConditionEnd();
    internal void CloseLocalScope();
    internal void DefineUserDefinedStateMachineHoistedLocal(int slotIndex);
    internal void AddLocalToScope(LocalDefinition local);
    internal void AddLocalConstantToScope(LocalConstantDefinition localConstant);
    [CompilerGeneratedAttribute]
internal bool get_HasDynamicLocal();
    [CompilerGeneratedAttribute]
private void set_HasDynamicLocal(bool value);
    internal ILBuilder GetSnapshot();
    private bool AllBlocks(Func`2<BasicBlock, bool> predicate);
    internal int AllocateILMarker();
    public int GetILOffsetFromMarker(int ilMarker);
    private string GetDebuggerDisplay();
    public void EmitNumericConversion(PrimitiveTypeCode fromPredefTypeKind, PrimitiveTypeCode toPredefTypeKind, bool checked);
    internal void AdjustStack(int stackAdjustment);
    internal bool get_IsStackEmpty();
    internal void EmitOpCode(ILOpCode code);
    internal void EmitOpCode(ILOpCode code, int stackAdjustment);
    internal void EmitToken(string value);
    internal void EmitToken(IReference value, SyntaxNode syntaxNode, DiagnosticBag diagnostics, bool encodeAsRawToken);
    internal void EmitGreatestMethodToken();
    internal void EmitModuleVersionIdStringToken();
    internal void EmitSourceDocumentIndexToken(DebugSourceDocument document);
    internal void EmitArrayBlockInitializer(ImmutableArray`1<byte> data, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    internal void EmitStackAllocBlockInitializer(ImmutableArray`1<byte> data, SyntaxNode syntaxNode, bool emitInitBlock, DiagnosticBag diagnostics);
    internal void EmitArrayBlockFieldRef(ImmutableArray`1<byte> data, ITypeSymbol elementType, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    internal void MarkLabel(object label);
    internal void EmitBranch(ILOpCode code, object label, ILOpCode revOpCode);
    internal void EmitStringSwitchJumpTable(KeyValuePair`2[] caseLabels, object fallThroughLabel, LocalOrParameter key, LocalDefinition keyHash, EmitStringCompareAndBranch emitStringCondBranchDelegate, GetStringHashCode computeStringHashcodeDelegate);
    internal void EmitIntegerSwitchJumpTable(KeyValuePair`2[] caseLabels, object fallThroughLabel, LocalOrParameter key, PrimitiveTypeCode keyTypeCode);
    internal void EmitSwitch(Object[] labels);
    internal void EmitRet(bool isVoid);
    internal void EmitThrow(bool isRethrow);
    private void EmitEndFinally();
    private BasicBlock FinishFilterCondition();
    internal void EmitArrayCreation(IArrayTypeReference arrayType, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    internal void EmitArrayElementLoad(IArrayTypeReference arrayType, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    internal void EmitArrayElementAddress(IArrayTypeReference arrayType, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    internal void EmitArrayElementStore(IArrayTypeReference arrayType, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    internal void EmitLoad(LocalOrParameter localOrParameter);
    internal void EmitLocalLoad(LocalDefinition local);
    internal void EmitLocalStore(LocalDefinition local);
    internal void EmitLocalAddress(LocalDefinition local);
    internal void EmitLoadArgumentOpcode(int argNumber);
    internal void EmitLoadArgumentAddrOpcode(int argNumber);
    internal void EmitStoreArgumentOpcode(int argNumber);
    internal void EmitConstantValue(ConstantValue value);
    internal void EmitIntConstant(int value);
    internal void EmitBoolConstant(bool value);
    internal void EmitByteConstant(byte value);
    internal void EmitSByteConstant(sbyte value);
    internal void EmitShortConstant(short value);
    internal void EmitUShortConstant(ushort value);
    internal void EmitLongConstant(long value);
    internal void EmitSingleConstant(float value);
    internal void EmitDoubleConstant(double value);
    internal void EmitNullConstant();
    internal void EmitStringConstant(string value);
    private void EmitInt8(sbyte int8);
    private void EmitInt32(int int32);
    private void EmitInt64(long int64);
    private void EmitFloat(float floatValue);
    private void EmitDouble(double doubleValue);
    private static void WriteOpCode(BlobBuilder writer, ILOpCode code);
    private BlobBuilder GetCurrentWriter();
}
internal enum Microsoft.CodeAnalysis.CodeGen.ILEmitStyle : Enum {
    public byte value__;
    public static ILEmitStyle Debug;
    public static ILEmitStyle DebugFriendlyRelease;
    public static ILEmitStyle Release;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeGen.ILOpCodeExtensions : object {
    [ExtensionAttribute]
public static int Size(ILOpCode opcode);
    [ExtensionAttribute]
public static ILOpCode GetLeaveOpcode(ILOpCode opcode);
    [ExtensionAttribute]
public static bool HasVariableStackBehavior(ILOpCode opcode);
    [ExtensionAttribute]
public static bool IsControlTransfer(ILOpCode opcode);
    [ExtensionAttribute]
public static bool IsConditionalBranch(ILOpCode opcode);
    [ExtensionAttribute]
public static bool IsRelationalBranch(ILOpCode opcode);
    [ExtensionAttribute]
public static bool CanFallThrough(ILOpCode opcode);
    [ExtensionAttribute]
public static int NetStackBehavior(ILOpCode opcode);
    [ExtensionAttribute]
public static int StackPopCount(ILOpCode opcode);
    [ExtensionAttribute]
public static int StackPushCount(ILOpCode opcode);
}
internal class Microsoft.CodeAnalysis.CodeGen.InstrumentationPayloadRootField : SynthesizedStaticField {
    public ImmutableArray`1<byte> MappedData { get; }
    internal InstrumentationPayloadRootField(INamedTypeDefinition containingType, int analysisIndex, ITypeReference payloadType);
    public virtual ImmutableArray`1<byte> get_MappedData();
}
internal class Microsoft.CodeAnalysis.CodeGen.ItemTokenMap`1 : object {
    private ConcurrentDictionary`2<T, UInt32> _itemToToken;
    private ArrayBuilder`1<T> _items;
    public UInt32 GetOrAddTokenFor(T item);
    private UInt32 AddItem(T item);
    public T GetItem(UInt32 token);
    public IEnumerable`1<T> GetAllItems();
}
internal interface Microsoft.CodeAnalysis.CodeGen.ITokenDeferral {
    public ArrayMethods ArrayMethods { get; }
    public abstract virtual UInt32 GetFakeStringTokenForIL(string value);
    public abstract virtual UInt32 GetFakeSymbolTokenForIL(IReference value, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    public abstract virtual UInt32 GetSourceDocumentIndexForIL(DebugSourceDocument document);
    public abstract virtual IFieldReference GetFieldForData(ImmutableArray`1<byte> data, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    public abstract virtual IMethodReference GetInitArrayHelper();
    public abstract virtual string GetStringFromToken(UInt32 token);
    public abstract virtual IReference GetReferenceFromToken(UInt32 token);
    public abstract virtual ArrayMethods get_ArrayMethods();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo : ValueType {
    public int SyntaxOffset;
    public int ClosureOrdinal;
    public DebugId LambdaId;
    public static int StaticClosureOrdinal;
    public static int ThisOnlyClosureOrdinal;
    public static int MinClosureOrdinal;
    public LambdaDebugInfo(int syntaxOffset, DebugId lambdaId, int closureOrdinal);
    public sealed virtual bool Equals(LambdaDebugInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.CodeGen.LocalConstantDefinition : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataConstant <CompileTimeValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<bool> <DynamicTransformFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <TupleElementNames>k__BackingField;
    public string Name { get; }
    public Location Location { get; }
    public MetadataConstant CompileTimeValue { get; }
    public ITypeReference Type { get; }
    public bool IsConstant { get; }
    public ImmutableArray`1<ICustomModifier> CustomModifiers { get; }
    public bool IsModified { get; }
    public bool IsPinned { get; }
    public bool IsReference { get; }
    public LocalSlotConstraints Constraints { get; }
    public LocalVariableAttributes PdbAttributes { get; }
    public ImmutableArray`1<bool> DynamicTransformFlags { get; }
    public ImmutableArray`1<string> TupleElementNames { get; }
    public int SlotIndex { get; }
    public Byte[] Signature { get; }
    public LocalSlotDebugInfo SlotInfo { get; }
    public LocalConstantDefinition(string name, Location location, MetadataConstant compileTimeValue, ImmutableArray`1<bool> dynamicTransformFlags, ImmutableArray`1<string> tupleElementNames);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual Location get_Location();
    [CompilerGeneratedAttribute]
public sealed virtual MetadataConstant get_CompileTimeValue();
    public sealed virtual ITypeReference get_Type();
    public bool get_IsConstant();
    public sealed virtual ImmutableArray`1<ICustomModifier> get_CustomModifiers();
    public bool get_IsModified();
    public sealed virtual bool get_IsPinned();
    public sealed virtual bool get_IsReference();
    public sealed virtual LocalSlotConstraints get_Constraints();
    public sealed virtual LocalVariableAttributes get_PdbAttributes();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<bool> get_DynamicTransformFlags();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<string> get_TupleElementNames();
    public sealed virtual int get_SlotIndex();
    public sealed virtual Byte[] get_Signature();
    public sealed virtual LocalSlotDebugInfo get_SlotInfo();
}
internal class Microsoft.CodeAnalysis.CodeGen.LocalDebugId : ValueType {
    public int SyntaxOffset;
    public int Ordinal;
    public static LocalDebugId None;
    public bool IsNone { get; }
    private LocalDebugId(bool isNone);
    public LocalDebugId(int syntaxOffset, int ordinal);
    private static LocalDebugId();
    public bool get_IsNone();
    public sealed virtual bool Equals(LocalDebugId other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.CodeGen.LocalDefinition : object {
    private ILocalSymbol _symbolOpt;
    private string _nameOpt;
    private ITypeReference _type;
    private LocalSlotConstraints _constraints;
    private int _slot;
    private LocalSlotDebugInfo _slotInfo;
    private LocalVariableAttributes _pdbAttributes;
    private ImmutableArray`1<bool> _dynamicTransformFlags;
    private ImmutableArray`1<string> _tupleElementNames;
    public ILocalSymbol SymbolOpt { get; }
    public Location Location { get; }
    public int SlotIndex { get; }
    public MetadataConstant CompileTimeValue { get; }
    public ImmutableArray`1<ICustomModifier> CustomModifiers { get; }
    public bool IsConstant { get; }
    public bool IsModified { get; }
    public LocalSlotConstraints Constraints { get; }
    public bool IsPinned { get; }
    public bool IsReference { get; }
    public LocalVariableAttributes PdbAttributes { get; }
    public ImmutableArray`1<bool> DynamicTransformFlags { get; }
    public ImmutableArray`1<string> TupleElementNames { get; }
    public ITypeReference Type { get; }
    public string Name { get; }
    public Byte[] Signature { get; }
    public LocalSlotDebugInfo SlotInfo { get; }
    public LocalDefinition(ILocalSymbol symbolOpt, string nameOpt, ITypeReference type, int slot, SynthesizedLocalKind synthesizedKind, LocalDebugId id, LocalVariableAttributes pdbAttributes, LocalSlotConstraints constraints, ImmutableArray`1<bool> dynamicTransformFlags, ImmutableArray`1<string> tupleElementNames);
    internal string GetDebuggerDisplay();
    public ILocalSymbol get_SymbolOpt();
    public sealed virtual Location get_Location();
    public sealed virtual int get_SlotIndex();
    public sealed virtual MetadataConstant get_CompileTimeValue();
    public sealed virtual ImmutableArray`1<ICustomModifier> get_CustomModifiers();
    public bool get_IsConstant();
    public bool get_IsModified();
    public sealed virtual LocalSlotConstraints get_Constraints();
    public sealed virtual bool get_IsPinned();
    public sealed virtual bool get_IsReference();
    public sealed virtual LocalVariableAttributes get_PdbAttributes();
    public sealed virtual ImmutableArray`1<bool> get_DynamicTransformFlags();
    public sealed virtual ImmutableArray`1<string> get_TupleElementNames();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual string get_Name();
    public sealed virtual Byte[] get_Signature();
    public sealed virtual LocalSlotDebugInfo get_SlotInfo();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.CodeGen.LocalOrParameter : ValueType {
    public LocalDefinition Local;
    public int ParameterIndex;
    private LocalOrParameter(LocalDefinition local, int parameterIndex);
    public static LocalOrParameter op_Implicit(LocalDefinition local);
    public static LocalOrParameter op_Implicit(int parameterIndex);
    private string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.CodeGen.LocalSlotDebugInfo : ValueType {
    public SynthesizedLocalKind SynthesizedKind;
    public LocalDebugId Id;
    public LocalSlotDebugInfo(SynthesizedLocalKind synthesizedKind, LocalDebugId id);
    public sealed virtual bool Equals(LocalSlotDebugInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Microsoft.CodeAnalysis.CodeGen.LocalSlotManager : object {
    private Dictionary`2<ILocalSymbol, LocalDefinition> _localMap;
    private KeyedStack`2<LocalSignature, LocalDefinition> _freeSlots;
    private ArrayBuilder`1<ILocalDefinition> _lazyAllLocals;
    private VariableSlotAllocator _slotAllocatorOpt;
    private Dictionary`2<ILocalSymbol, LocalDefinition> LocalMap { get; }
    private KeyedStack`2<LocalSignature, LocalDefinition> FreeSlots { get; }
    public LocalSlotManager(VariableSlotAllocator slotAllocatorOpt);
    private Dictionary`2<ILocalSymbol, LocalDefinition> get_LocalMap();
    private KeyedStack`2<LocalSignature, LocalDefinition> get_FreeSlots();
    internal LocalDefinition DeclareLocal(ITypeReference type, ILocalSymbolInternal symbol, string name, SynthesizedLocalKind kind, LocalDebugId id, LocalVariableAttributes pdbAttributes, LocalSlotConstraints constraints, ImmutableArray`1<bool> dynamicTransformFlags, ImmutableArray`1<string> tupleElementNames, bool isSlotReusable);
    internal LocalDefinition GetLocal(ILocalSymbol symbol);
    internal void FreeLocal(ILocalSymbol symbol);
    internal LocalDefinition AllocateSlot(ITypeReference type, LocalSlotConstraints constraints, ImmutableArray`1<bool> dynamicTransformFlags, ImmutableArray`1<string> tupleElementNames);
    private LocalDefinition DeclareLocalImpl(ITypeReference type, ILocalSymbolInternal symbolOpt, string nameOpt, SynthesizedLocalKind kind, LocalDebugId id, LocalVariableAttributes pdbAttributes, LocalSlotConstraints constraints, ImmutableArray`1<bool> dynamicTransformFlags, ImmutableArray`1<string> tupleElementNames);
    internal void FreeSlot(LocalDefinition slot);
    public ImmutableArray`1<ILocalDefinition> LocalsInOrder();
}
internal class Microsoft.CodeAnalysis.CodeGen.MappedField : SynthesizedStaticField {
    private ImmutableArray`1<byte> _block;
    public ImmutableArray`1<byte> MappedData { get; }
    internal MappedField(string name, INamedTypeDefinition containingType, ITypeReference type, ImmutableArray`1<byte> block);
    public virtual ImmutableArray`1<byte> get_MappedData();
}
internal class Microsoft.CodeAnalysis.CodeGen.MetadataConstant : object {
    [CompilerGeneratedAttribute]
private ITypeReference <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public ITypeReference Type { get; }
    public object Value { get; }
    public MetadataConstant(ITypeReference type, object value);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeReference get_Type();
    [CompilerGeneratedAttribute]
public object get_Value();
    private sealed virtual override void Microsoft.Cci.IMetadataExpression.Dispatch(MetadataVisitor visitor);
    [ConditionalAttribute("DEBUG")]
internal static void AssertValidConstant(object value);
}
internal class Microsoft.CodeAnalysis.CodeGen.MetadataCreateArray : object {
    [CompilerGeneratedAttribute]
private IArrayTypeReference <ArrayType>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeReference <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMetadataExpression> <Elements>k__BackingField;
    public IArrayTypeReference ArrayType { get; }
    public ITypeReference ElementType { get; }
    public ImmutableArray`1<IMetadataExpression> Elements { get; }
    private ITypeReference Microsoft.Cci.IMetadataExpression.Type { get; }
    public MetadataCreateArray(IArrayTypeReference arrayType, ITypeReference elementType, ImmutableArray`1<IMetadataExpression> initializers);
    [CompilerGeneratedAttribute]
public IArrayTypeReference get_ArrayType();
    [CompilerGeneratedAttribute]
public ITypeReference get_ElementType();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMetadataExpression> get_Elements();
    private sealed virtual override ITypeReference Microsoft.Cci.IMetadataExpression.get_Type();
    private sealed virtual override void Microsoft.Cci.IMetadataExpression.Dispatch(MetadataVisitor visitor);
}
internal class Microsoft.CodeAnalysis.CodeGen.MetadataNamedArgument : object {
    private ISymbol _entity;
    private ITypeReference _type;
    private IMetadataExpression _value;
    private string Microsoft.Cci.IMetadataNamedArgument.ArgumentName { get; }
    private IMetadataExpression Microsoft.Cci.IMetadataNamedArgument.ArgumentValue { get; }
    private bool Microsoft.Cci.IMetadataNamedArgument.IsField { get; }
    private ITypeReference Microsoft.Cci.IMetadataExpression.Type { get; }
    public MetadataNamedArgument(ISymbol entity, ITypeReference type, IMetadataExpression value);
    private sealed virtual override string Microsoft.Cci.IMetadataNamedArgument.get_ArgumentName();
    private sealed virtual override IMetadataExpression Microsoft.Cci.IMetadataNamedArgument.get_ArgumentValue();
    private sealed virtual override bool Microsoft.Cci.IMetadataNamedArgument.get_IsField();
    private sealed virtual override void Microsoft.Cci.IMetadataExpression.Dispatch(MetadataVisitor visitor);
    private sealed virtual override ITypeReference Microsoft.Cci.IMetadataExpression.get_Type();
}
internal class Microsoft.CodeAnalysis.CodeGen.MetadataTypeOf : object {
    private ITypeReference _typeToGet;
    private ITypeReference _systemType;
    public ITypeReference TypeToGet { get; }
    private ITypeReference Microsoft.Cci.IMetadataExpression.Type { get; }
    public MetadataTypeOf(ITypeReference typeToGet, ITypeReference systemType);
    public ITypeReference get_TypeToGet();
    private sealed virtual override void Microsoft.Cci.IMetadataExpression.Dispatch(MetadataVisitor visitor);
    private sealed virtual override ITypeReference Microsoft.Cci.IMetadataExpression.get_Type();
}
internal class Microsoft.CodeAnalysis.CodeGen.MethodBody : object {
    private IMethodDefinition _parent;
    private ImmutableArray`1<byte> _ilBits;
    private ushort _maxStack;
    private ImmutableArray`1<ILocalDefinition> _locals;
    private ImmutableArray`1<ExceptionHandlerRegion> _exceptionHandlers;
    private ImmutableArray`1<SequencePoint> _sequencePoints;
    private ImmutableArray`1<LocalScope> _localScopes;
    private IImportScope _importScopeOpt;
    private string _stateMachineTypeNameOpt;
    private ImmutableArray`1<StateMachineHoistedLocalScope> _stateMachineHoistedLocalScopes;
    private bool _hasDynamicLocalVariables;
    private StateMachineMoveNextBodyDebugInfo _stateMachineMoveNextDebugInfoOpt;
    private DebugId _methodId;
    private ImmutableArray`1<EncHoistedLocalInfo> _stateMachineHoistedLocalSlots;
    private ImmutableArray`1<LambdaDebugInfo> _lambdaDebugInfo;
    private ImmutableArray`1<ClosureDebugInfo> _closureDebugInfo;
    private ImmutableArray`1<ITypeReference> _stateMachineAwaiterSlots;
    private DynamicAnalysisMethodBodyData _dynamicAnalysisDataOpt;
    private DynamicAnalysisMethodBodyData Microsoft.Cci.IMethodBody.DynamicAnalysisData { get; }
    private ImmutableArray`1<ExceptionHandlerRegion> Microsoft.Cci.IMethodBody.ExceptionRegions { get; }
    private bool Microsoft.Cci.IMethodBody.LocalsAreZeroed { get; }
    private ImmutableArray`1<ILocalDefinition> Microsoft.Cci.IMethodBody.LocalVariables { get; }
    private IMethodDefinition Microsoft.Cci.IMethodBody.MethodDefinition { get; }
    private StateMachineMoveNextBodyDebugInfo Microsoft.Cci.IMethodBody.MoveNextBodyInfo { get; }
    private ushort Microsoft.Cci.IMethodBody.MaxStack { get; }
    public ImmutableArray`1<byte> IL { get; }
    public ImmutableArray`1<SequencePoint> SequencePoints { get; }
    private ImmutableArray`1<LocalScope> Microsoft.Cci.IMethodBody.LocalScopes { get; }
    private IImportScope Microsoft.Cci.IMethodBody.ImportScope { get; }
    private string Microsoft.Cci.IMethodBody.StateMachineTypeName { get; }
    private ImmutableArray`1<StateMachineHoistedLocalScope> Microsoft.Cci.IMethodBody.StateMachineHoistedLocalScopes { get; }
    private ImmutableArray`1<EncHoistedLocalInfo> Microsoft.Cci.IMethodBody.StateMachineHoistedLocalSlots { get; }
    private ImmutableArray`1<ITypeReference> Microsoft.Cci.IMethodBody.StateMachineAwaiterSlots { get; }
    private bool Microsoft.Cci.IMethodBody.HasDynamicLocalVariables { get; }
    public DebugId MethodId { get; }
    public ImmutableArray`1<LambdaDebugInfo> LambdaDebugInfo { get; }
    public ImmutableArray`1<ClosureDebugInfo> ClosureDebugInfo { get; }
    public MethodBody(ImmutableArray`1<byte> ilBits, ushort maxStack, IMethodDefinition parent, DebugId methodId, ImmutableArray`1<ILocalDefinition> locals, SequencePointList sequencePoints, DebugDocumentProvider debugDocumentProvider, ImmutableArray`1<ExceptionHandlerRegion> exceptionHandlers, ImmutableArray`1<LocalScope> localScopes, bool hasDynamicLocalVariables, IImportScope importScopeOpt, ImmutableArray`1<LambdaDebugInfo> lambdaDebugInfo, ImmutableArray`1<ClosureDebugInfo> closureDebugInfo, string stateMachineTypeNameOpt, ImmutableArray`1<StateMachineHoistedLocalScope> stateMachineHoistedLocalScopes, ImmutableArray`1<EncHoistedLocalInfo> stateMachineHoistedLocalSlots, ImmutableArray`1<ITypeReference> stateMachineAwaiterSlots, StateMachineMoveNextBodyDebugInfo stateMachineMoveNextDebugInfoOpt, DynamicAnalysisMethodBodyData dynamicAnalysisDataOpt);
    private static ImmutableArray`1<SequencePoint> GetSequencePoints(SequencePointList sequencePoints, DebugDocumentProvider debugDocumentProvider);
    private sealed virtual override DynamicAnalysisMethodBodyData Microsoft.Cci.IMethodBody.get_DynamicAnalysisData();
    private sealed virtual override ImmutableArray`1<ExceptionHandlerRegion> Microsoft.Cci.IMethodBody.get_ExceptionRegions();
    private sealed virtual override bool Microsoft.Cci.IMethodBody.get_LocalsAreZeroed();
    private sealed virtual override ImmutableArray`1<ILocalDefinition> Microsoft.Cci.IMethodBody.get_LocalVariables();
    private sealed virtual override IMethodDefinition Microsoft.Cci.IMethodBody.get_MethodDefinition();
    private sealed virtual override StateMachineMoveNextBodyDebugInfo Microsoft.Cci.IMethodBody.get_MoveNextBodyInfo();
    private sealed virtual override ushort Microsoft.Cci.IMethodBody.get_MaxStack();
    public sealed virtual ImmutableArray`1<byte> get_IL();
    public sealed virtual ImmutableArray`1<SequencePoint> get_SequencePoints();
    private sealed virtual override ImmutableArray`1<LocalScope> Microsoft.Cci.IMethodBody.get_LocalScopes();
    private sealed virtual override IImportScope Microsoft.Cci.IMethodBody.get_ImportScope();
    private sealed virtual override string Microsoft.Cci.IMethodBody.get_StateMachineTypeName();
    private sealed virtual override ImmutableArray`1<StateMachineHoistedLocalScope> Microsoft.Cci.IMethodBody.get_StateMachineHoistedLocalScopes();
    private sealed virtual override ImmutableArray`1<EncHoistedLocalInfo> Microsoft.Cci.IMethodBody.get_StateMachineHoistedLocalSlots();
    private sealed virtual override ImmutableArray`1<ITypeReference> Microsoft.Cci.IMethodBody.get_StateMachineAwaiterSlots();
    private sealed virtual override bool Microsoft.Cci.IMethodBody.get_HasDynamicLocalVariables();
    public sealed virtual DebugId get_MethodId();
    public sealed virtual ImmutableArray`1<LambdaDebugInfo> get_LambdaDebugInfo();
    public sealed virtual ImmutableArray`1<ClosureDebugInfo> get_ClosureDebugInfo();
}
internal class Microsoft.CodeAnalysis.CodeGen.ModuleVersionIdField : SynthesizedStaticField {
    public ImmutableArray`1<byte> MappedData { get; }
    internal ModuleVersionIdField(INamedTypeDefinition containingType, ITypeReference type);
    public virtual ImmutableArray`1<byte> get_MappedData();
}
internal class Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference : object {
    private ICustomAttribute _sourceAttribute;
    private string _resolvedPermissionSetFilePath;
    internal static string FilePropertyName;
    internal static string HexPropertyName;
    public int ArgumentCount { get; }
    public ushort NamedArgumentCount { get; }
    public bool AllowMultiple { get; }
    public PermissionSetAttributeWithFileReference(ICustomAttribute sourceAttribute, string resolvedPermissionSetFilePath);
    public sealed virtual ImmutableArray`1<IMetadataExpression> GetArguments(EmitContext context);
    public sealed virtual IMethodReference Constructor(EmitContext context, bool reportDiagnostics);
    public sealed virtual ImmutableArray`1<IMetadataNamedArgument> GetNamedArguments(EmitContext context);
    internal static string ConvertToHex(Stream stream);
    private static char ConvertHexToChar(int b);
    public sealed virtual int get_ArgumentCount();
    public sealed virtual ushort get_NamedArgumentCount();
    public sealed virtual ITypeReference GetType(EmitContext context);
    public sealed virtual bool get_AllowMultiple();
}
internal class Microsoft.CodeAnalysis.CodeGen.PermissionSetFileReadException : Exception {
    private string _file;
    public string FileName { get; }
    public string PropertyName { get; }
    public PermissionSetFileReadException(string message, string file);
    public string get_FileName();
    public string get_PropertyName();
}
internal class Microsoft.CodeAnalysis.CodeGen.PrivateImplementationDetails : DefaultTypeDef {
    internal static string SynthesizedStringHashFunctionName;
    private CommonPEModuleBuilder _moduleBuilder;
    private ITypeReference _systemObject;
    private ITypeReference _systemValueType;
    private ITypeReference _systemInt8Type;
    private ITypeReference _systemInt16Type;
    private ITypeReference _systemInt32Type;
    private ITypeReference _systemInt64Type;
    private ICustomAttribute _compilerGeneratedAttribute;
    private string _name;
    private int _frozen;
    private ImmutableArray`1<SynthesizedStaticField> _orderedSynthesizedFields;
    private ConcurrentDictionary`2<ImmutableArray`1<byte>, MappedField> _mappedFields;
    private ModuleVersionIdField _mvidField;
    private ConcurrentDictionary`2<int, InstrumentationPayloadRootField> _instrumentationPayloadRootFields;
    private ImmutableArray`1<IMethodDefinition> _orderedSynthesizedMethods;
    private ConcurrentDictionary`2<string, IMethodDefinition> _synthesizedMethods;
    private ImmutableArray`1<ITypeReference> _orderedProxyTypes;
    private ConcurrentDictionary`2<UInt32, ITypeReference> _proxyTypes;
    private bool IsFrozen { get; }
    public INamespaceTypeReference AsNamespaceTypeReference { get; }
    public string Name { get; }
    public bool IsPublic { get; }
    public string NamespaceName { get; }
    internal PrivateImplementationDetails(CommonPEModuleBuilder moduleBuilder, string moduleName, int submissionSlotIndex, ITypeReference systemObject, ITypeReference systemValueType, ITypeReference systemInt8Type, ITypeReference systemInt16Type, ITypeReference systemInt32Type, ITypeReference systemInt64Type, ICustomAttribute compilerGeneratedAttribute);
    private static string GetClassName(string moduleName, int submissionSlotIndex, bool isNetModule);
    internal void Freeze();
    private bool get_IsFrozen();
    internal IFieldReference CreateDataField(ImmutableArray`1<byte> data);
    private ITypeReference GetStorageStruct(UInt32 size);
    internal IFieldReference GetModuleVersionId(ITypeReference mvidType);
    internal IFieldReference GetOrAddInstrumentationPayloadRoot(int analysisKind, ITypeReference payloadRootType);
    internal IOrderedEnumerable`1<KeyValuePair`2<int, InstrumentationPayloadRootField>> GetInstrumentationPayloadRoots();
    internal bool TryAddSynthesizedMethod(IMethodDefinition method);
    public virtual IEnumerable`1<IFieldDefinition> GetFields(EmitContext context);
    public virtual IEnumerable`1<IMethodDefinition> GetMethods(EmitContext context);
    internal IMethodDefinition GetMethod(string name);
    public virtual IEnumerable`1<INestedTypeDefinition> GetNestedTypes(EmitContext context);
    public virtual string ToString();
    public virtual ITypeReference GetBaseClass(EmitContext context);
    public virtual IEnumerable`1<ICustomAttribute> GetAttributes(EmitContext context);
    public virtual void Dispatch(MetadataVisitor visitor);
    public virtual INamespaceTypeDefinition AsNamespaceTypeDefinition(EmitContext context);
    public virtual INamespaceTypeReference get_AsNamespaceTypeReference();
    public sealed virtual string get_Name();
    public sealed virtual bool get_IsPublic();
    public sealed virtual IUnitReference GetUnit(EmitContext context);
    public sealed virtual string get_NamespaceName();
    internal static string GenerateDataFieldName(ImmutableArray`1<byte> data);
    private static char Hexchar(int x);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.CodeGen.RawSequencePoint : ValueType {
    internal SyntaxTree SyntaxTree;
    internal int ILMarker;
    internal TextSpan Span;
    internal static TextSpan HiddenSequencePointSpan;
    internal RawSequencePoint(SyntaxTree syntaxTree, int ilMarker, TextSpan span);
    private static RawSequencePoint();
    private string GetDebuggerDisplay();
}
internal static class Microsoft.CodeAnalysis.CodeGen.ReferenceDependencyWalker : object {
    public static void VisitReference(IReference reference, EmitContext context);
    private static void VisitTypeReference(ITypeReference typeReference, EmitContext context);
    private static void VisitMethodReference(IMethodReference methodReference, EmitContext context);
    private static void VisitParameters(ImmutableArray`1<IParameterTypeInformation> parameters, EmitContext context);
    private static void VisitFieldReference(IFieldReference fieldReference, EmitContext context);
}
internal enum Microsoft.CodeAnalysis.CodeGen.ScopeType : Enum {
    public int value__;
    public static ScopeType Variable;
    public static ScopeType TryCatchFinally;
    public static ScopeType Try;
    public static ScopeType Catch;
    public static ScopeType Filter;
    public static ScopeType Finally;
    public static ScopeType Fault;
    public static ScopeType StateMachineVariable;
}
internal class Microsoft.CodeAnalysis.CodeGen.SequencePointList : object {
    internal static int HiddenSequencePointLine;
    private SyntaxTree _tree;
    private OffsetAndSpan[] _points;
    private SequencePointList _next;
    private static SequencePointList s_empty;
    public bool IsEmpty { get; }
    private SequencePointList(SyntaxTree tree, OffsetAndSpan[] points);
    private static SequencePointList();
    public static SequencePointList Create(ArrayBuilder`1<RawSequencePoint> seqPointBuilder, ILBuilder builder);
    public bool get_IsEmpty();
    private static OffsetAndSpan[] GetSubArray(ArrayBuilder`1<RawSequencePoint> seqPointBuilder, int start, int length, ILBuilder builder);
    public void GetSequencePoints(DebugDocumentProvider documentProvider, ArrayBuilder`1<SequencePoint> builder);
    private Nullable`1<FileLinePositionSpan> FindFirstRealSequencePoint();
}
internal class Microsoft.CodeAnalysis.CodeGen.SignatureOnlyLocalDefinition : object {
    private Byte[] _signature;
    private int _slot;
    public MetadataConstant CompileTimeValue { get; }
    public ImmutableArray`1<ICustomModifier> CustomModifiers { get; }
    public ImmutableArray`1<bool> DynamicTransformFlags { get; }
    public ImmutableArray`1<string> TupleElementNames { get; }
    public LocalVariableAttributes PdbAttributes { get; }
    public bool IsPinned { get; }
    public bool IsReference { get; }
    public LocalSlotConstraints Constraints { get; }
    public Location Location { get; }
    public string Name { get; }
    public int SlotIndex { get; }
    public ITypeReference Type { get; }
    public Byte[] Signature { get; }
    public LocalSlotDebugInfo SlotInfo { get; }
    internal SignatureOnlyLocalDefinition(Byte[] signature, int slot);
    public sealed virtual MetadataConstant get_CompileTimeValue();
    public sealed virtual ImmutableArray`1<ICustomModifier> get_CustomModifiers();
    public sealed virtual ImmutableArray`1<bool> get_DynamicTransformFlags();
    public sealed virtual ImmutableArray`1<string> get_TupleElementNames();
    public sealed virtual LocalVariableAttributes get_PdbAttributes();
    public sealed virtual bool get_IsPinned();
    public sealed virtual bool get_IsReference();
    public sealed virtual LocalSlotConstraints get_Constraints();
    public sealed virtual Location get_Location();
    public sealed virtual string get_Name();
    public sealed virtual int get_SlotIndex();
    public sealed virtual ITypeReference get_Type();
    public sealed virtual Byte[] get_Signature();
    public sealed virtual LocalSlotDebugInfo get_SlotInfo();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.CodeGen.SourceSpan : ValueType {
    public int StartLine;
    public int StartColumn;
    public int EndLine;
    public int EndColumn;
    public DebugSourceDocument Document;
    public SourceSpan(DebugSourceDocument document, int startLine, int startColumn, int endLine, int endColumn);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.CodeGen.SwitchIntegralJumpTableEmitter : ValueType {
    private ILBuilder _builder;
    private LocalOrParameter _key;
    private PrimitiveTypeCode _keyTypeCode;
    private object _fallThroughLabel;
    private ImmutableArray`1<KeyValuePair`2<ConstantValue, object>> _sortedCaseLabels;
    private static int LinearSearchThreshold;
    internal SwitchIntegralJumpTableEmitter(ILBuilder builder, KeyValuePair`2[] caseLabels, object fallThroughLabel, PrimitiveTypeCode keyTypeCode, LocalOrParameter key);
    internal void EmitJumpTable();
    private static int CompareIntegralSwitchLabels(KeyValuePair`2<ConstantValue, object> first, KeyValuePair`2<ConstantValue, object> second);
    private ImmutableArray`1<SwitchBucket> GenerateSwitchBuckets(int startLabelIndex, int endLabelIndex);
    private SwitchBucket CreateNextBucket(int startLabelIndex, int endLabelIndex);
    private void EmitSwitchBucketsLinearLeaf(ImmutableArray`1<SwitchBucket> switchBuckets, int low, int high);
    private void EmitSwitchBuckets(ImmutableArray`1<SwitchBucket> switchBuckets, int low, int high);
    private void EmitSwitchBucket(SwitchBucket switchBucket, object bucketFallThroughLabel);
    private Object[] CreateBucketLabels(SwitchBucket switchBucket);
    private void EmitCondBranchForSwitch(ILOpCode branchCode, ConstantValue constant, object targetLabel);
    private void EmitEqBranchForSwitch(ConstantValue constant, object targetLabel);
    private void EmitRangeCheckedBranch(ConstantValue startConstant, ConstantValue endConstant, object targetLabel);
    private static ILOpCode GetReverseBranchCode(ILOpCode branchCode);
    private void EmitNormalizedSwitchKey(ConstantValue startConstant, ConstantValue endConstant, object bucketFallThroughLabel);
    private void EmitRangeCheckIfNeeded(ConstantValue startConstant, ConstantValue endConstant, object bucketFallThroughLabel);
    [CompilerGeneratedAttribute]
internal static int <EmitRangeCheckedBranch>g__Int32Value|17_0(ConstantValue value);
}
internal class Microsoft.CodeAnalysis.CodeGen.SwitchStringJumpTableEmitter : ValueType {
    private ILBuilder _builder;
    private LocalOrParameter _key;
    private KeyValuePair`2[] _caseLabels;
    private object _fallThroughLabel;
    private EmitStringCompareAndBranch _emitStringCondBranchDelegate;
    private GetStringHashCode _computeStringHashcodeDelegate;
    private LocalDefinition _keyHash;
    internal SwitchStringJumpTableEmitter(ILBuilder builder, LocalOrParameter key, KeyValuePair`2[] caseLabels, object fallThroughLabel, LocalDefinition keyHash, EmitStringCompareAndBranch emitStringCondBranchDelegate, GetStringHashCode computeStringHashcodeDelegate);
    internal void EmitJumpTable();
    private void EmitHashTableSwitch();
    private Dictionary`2<UInt32, object> EmitHashBucketJumpTable(Dictionary`2<UInt32, List`1<KeyValuePair`2<ConstantValue, object>>> stringHashMap);
    private void EmitNonHashTableSwitch(KeyValuePair`2[] labels);
    private void EmitCondBranchForStringSwitch(ConstantValue stringConstant, object targetLabel);
    private static Dictionary`2<UInt32, List`1<KeyValuePair`2<ConstantValue, object>>> ComputeStringHashMap(KeyValuePair`2[] caseLabels, GetStringHashCode computeStringHashcodeDelegate);
    internal static bool ShouldGenerateHashTableSwitch(CommonPEModuleBuilder module, int labelsCount);
    private static bool ShouldGenerateHashTableSwitch(int labelsCount);
}
internal class Microsoft.CodeAnalysis.CodeGen.SynthesizedLocalOrdinalsDispenser : object {
    private PooledDictionary`2<long, int> _lazyMap;
    private static long MakeKey(SynthesizedLocalKind localKind, int syntaxOffset);
    public void Free();
    public int AssignLocalOrdinal(SynthesizedLocalKind localKind, int syntaxOffset);
}
internal abstract class Microsoft.CodeAnalysis.CodeGen.SynthesizedStaticField : object {
    private INamedTypeDefinition _containingType;
    private ITypeReference _type;
    private string _name;
    public ImmutableArray`1<byte> MappedData { get; }
    public bool IsCompileTimeConstant { get; }
    public bool IsNotSerialized { get; }
    public bool IsReadOnly { get; }
    public bool IsRuntimeSpecial { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsMarshalledExplicitly { get; }
    public IMarshallingInformation MarshallingInformation { get; }
    public ImmutableArray`1<byte> MarshallingDescriptor { get; }
    public int Offset { get; }
    public ITypeDefinition ContainingTypeDefinition { get; }
    public TypeMemberVisibility Visibility { get; }
    public string Name { get; }
    public bool IsContextualNamedEntity { get; }
    internal ITypeReference Type { get; }
    public ISpecializedFieldReference AsSpecializedFieldReference { get; }
    public MetadataConstant Constant { get; }
    internal SynthesizedStaticField(string name, INamedTypeDefinition containingType, ITypeReference type);
    public virtual string ToString();
    public sealed virtual MetadataConstant GetCompileTimeValue(EmitContext context);
    public abstract virtual ImmutableArray`1<byte> get_MappedData();
    public sealed virtual bool get_IsCompileTimeConstant();
    public sealed virtual bool get_IsNotSerialized();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsRuntimeSpecial();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsMarshalledExplicitly();
    public sealed virtual IMarshallingInformation get_MarshallingInformation();
    public sealed virtual ImmutableArray`1<byte> get_MarshallingDescriptor();
    public sealed virtual int get_Offset();
    public sealed virtual ITypeDefinition get_ContainingTypeDefinition();
    public sealed virtual TypeMemberVisibility get_Visibility();
    public sealed virtual ITypeReference GetContainingType(EmitContext context);
    public sealed virtual IEnumerable`1<ICustomAttribute> GetAttributes(EmitContext context);
    public sealed virtual void Dispatch(MetadataVisitor visitor);
    public sealed virtual IDefinition AsDefinition(EmitContext context);
    public sealed virtual string get_Name();
    public sealed virtual bool get_IsContextualNamedEntity();
    public sealed virtual ITypeReference GetType(EmitContext context);
    internal ITypeReference get_Type();
    public sealed virtual IFieldDefinition GetResolvedField(EmitContext context);
    public sealed virtual ISpecializedFieldReference get_AsSpecializedFieldReference();
    public MetadataConstant get_Constant();
}
internal class Microsoft.CodeAnalysis.CodeGen.TokenMap`1 : object {
    private ConcurrentDictionary`2<T, UInt32> _itemIdentityToToken;
    private Dictionary`2<T, UInt32> _itemToToken;
    private ArrayBuilder`1<T> _items;
    public UInt32 GetOrAddTokenFor(T item, Boolean& referenceAdded);
    private UInt32 AddItem(T item, Boolean& referenceAdded);
    public T GetItem(UInt32 token);
    public IEnumerable`1<T> GetAllItems();
    public IEnumerable`1<T> GetAllItemsAndCount(Int32& count);
}
internal abstract class Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator : object {
    public string PreviousStateMachineTypeName { get; }
    public int PreviousHoistedLocalSlotCount { get; }
    public int PreviousAwaiterSlotCount { get; }
    public Nullable`1<DebugId> MethodId { get; }
    public abstract virtual void AddPreviousLocals(ArrayBuilder`1<ILocalDefinition> builder);
    public abstract virtual LocalDefinition GetPreviousLocal(ITypeReference type, ILocalSymbolInternal symbol, string nameOpt, SynthesizedLocalKind kind, LocalDebugId id, LocalVariableAttributes pdbAttributes, LocalSlotConstraints constraints, ImmutableArray`1<bool> dynamicTransformFlags, ImmutableArray`1<string> tupleElementNames);
    public abstract virtual string get_PreviousStateMachineTypeName();
    public abstract virtual bool TryGetPreviousHoistedLocalSlotIndex(SyntaxNode currentDeclarator, ITypeReference currentType, SynthesizedLocalKind synthesizedKind, LocalDebugId currentId, DiagnosticBag diagnostics, Int32& slotIndex);
    public abstract virtual int get_PreviousHoistedLocalSlotCount();
    public abstract virtual bool TryGetPreviousAwaiterSlotIndex(ITypeReference currentType, DiagnosticBag diagnostics, Int32& slotIndex);
    public abstract virtual int get_PreviousAwaiterSlotCount();
    public abstract virtual Nullable`1<DebugId> get_MethodId();
    public abstract virtual bool TryGetPreviousClosure(SyntaxNode closureSyntax, DebugId& closureId);
    public abstract virtual bool TryGetPreviousLambda(SyntaxNode lambdaOrLambdaBodySyntax, bool isLambdaBody, DebugId& lambdaId);
}
internal class Microsoft.CodeAnalysis.CodeGen.Win32Resource : object {
    private Byte[] _data;
    private UInt32 _codePage;
    private UInt32 _languageId;
    private int _id;
    private string _name;
    private int _typeId;
    private string _typeName;
    public string TypeName { get; }
    public int TypeId { get; }
    public string Name { get; }
    public int Id { get; }
    public UInt32 LanguageId { get; }
    public UInt32 CodePage { get; }
    public IEnumerable`1<byte> Data { get; }
    internal Win32Resource(Byte[] data, UInt32 codePage, UInt32 languageId, int id, string name, int typeId, string typeName);
    public sealed virtual string get_TypeName();
    public sealed virtual int get_TypeId();
    public sealed virtual string get_Name();
    public sealed virtual int get_Id();
    public sealed virtual UInt32 get_LanguageId();
    public sealed virtual UInt32 get_CodePage();
    public sealed virtual IEnumerable`1<byte> get_Data();
}
internal static class Microsoft.CodeAnalysis.COFFResourceReader : object {
    private static void ConfirmSectionValues(SectionHeader hdr, long fileSize);
    internal static ResourceSection ReadWin32ResourcesFromCOFF(Stream stream);
}
internal class Microsoft.CodeAnalysis.Collections.ByteSequenceComparer : object {
    internal static ByteSequenceComparer Instance;
    private static ByteSequenceComparer();
    internal static bool Equals(ImmutableArray`1<byte> x, ImmutableArray`1<byte> y);
    internal static bool Equals(Byte[] left, int leftStart, Byte[] right, int rightStart, int length);
    internal static bool Equals(Byte[] left, Byte[] right);
    internal static int GetHashCode(Byte[] x);
    internal static int GetHashCode(ImmutableArray`1<byte> x);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Byte[]>.Equals(Byte[] x, Byte[] y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Byte[]>.GetHashCode(Byte[] x);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Collections.Immutable.ImmutableArray<System.Byte>>.Equals(ImmutableArray`1<byte> x, ImmutableArray`1<byte> y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Collections.Immutable.ImmutableArray<System.Byte>>.GetHashCode(ImmutableArray`1<byte> x);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.CachingDictionary`2 : object {
    private Func`2<TKey, ImmutableArray`1<TElement>> _getElementsOfKey;
    private Func`2<IEqualityComparer`1<TKey>, HashSet`1<TKey>> _getKeys;
    private IEqualityComparer`1<TKey> _comparer;
    private IDictionary`2<TKey, ImmutableArray`1<TElement>> _map;
    private static ImmutableArray`1<TElement> s_emptySentinel;
    public ImmutableArray`1<TElement> Item { get; }
    public int Count { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public CachingDictionary`2(Func`2<TKey, ImmutableArray`1<TElement>> getElementsOfKey, Func`2<IEqualityComparer`1<TKey>, HashSet`1<TKey>> getKeys, IEqualityComparer`1<TKey> comparer);
    private static CachingDictionary`2();
    public bool Contains(TKey key);
    public ImmutableArray`1<TElement> get_Item(TKey key);
    public int get_Count();
    public IEnumerable`1<TKey> get_Keys();
    public void AddValues(ArrayBuilder`1<TElement> array);
    private ConcurrentDictionary`2<TKey, ImmutableArray`1<TElement>> CreateConcurrentDictionary();
    private IDictionary`2<TKey, ImmutableArray`1<TElement>> CreateDictionaryForFullyPopulatedMap(int capacity);
    private ImmutableArray`1<TElement> GetOrCreateValue(TKey key);
    private ImmutableArray`1<TElement> AddToConcurrentMap(ConcurrentDictionary`2<TKey, ImmutableArray`1<TElement>> map, TKey key);
    private static bool IsNotFullyPopulatedMap(IDictionary`2<TKey, ImmutableArray`1<TElement>> existingMap);
    private IDictionary`2<TKey, ImmutableArray`1<TElement>> CreateFullyPopulatedMap(IDictionary`2<TKey, ImmutableArray`1<TElement>> existingMap);
    private IDictionary`2<TKey, ImmutableArray`1<TElement>> EnsureFullyPopulated();
}
internal class Microsoft.CodeAnalysis.Collections.ImmutableMemoryStream : Stream {
    private ImmutableArray`1<byte> _array;
    private int _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal ImmutableMemoryStream(ImmutableArray`1<byte> array);
    public ImmutableArray`1<byte> GetBuffer();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class Microsoft.CodeAnalysis.Collections.KeyedStack`2 : object {
    private Dictionary`2<T, Stack`1<R>> _dict;
    public void Push(T key, R value);
    public bool TryPop(T key, R& value);
}
internal class Microsoft.CodeAnalysis.Collections.OrderedSet`1 : object {
    private HashSet`1<T> _set;
    private ArrayBuilder`1<T> _list;
    public int Count { get; }
    public OrderedSet`1(IEnumerable`1<T> items);
    public void AddRange(IEnumerable`1<T> items);
    public bool Add(T item);
    public sealed virtual int get_Count();
    public sealed virtual bool Contains(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void Clear();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2 : object {
    private ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> _pool;
    private static ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> s_poolInstance;
    private static Dictionary`2<K, ValueSet<K, V>> s_emptyDictionary;
    private PooledDictionary`2<K, ValueSet<K, V>> _dictionary;
    public bool IsEmpty { get; }
    public ImmutableArray`1<V> Item { get; }
    public KeyCollection<K, ValueSet<K, V>> Keys { get; }
    private OrderPreservingMultiDictionary`2(ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> pool);
    private static OrderPreservingMultiDictionary`2();
    public void Free();
    public static ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> CreatePool();
    public static OrderPreservingMultiDictionary`2<K, V> GetInstance();
    private void EnsureDictionary();
    public bool get_IsEmpty();
    public void Add(K k, V v);
    public Enumerator<K, ValueSet<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<K, ValueSet<K, V>>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K,V>.ValueSet>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ImmutableArray`1<V> get_Item(K k);
    public bool Contains(K key, V value);
    public KeyCollection<K, ValueSet<K, V>> get_Keys();
}
internal class Microsoft.CodeAnalysis.Collections.SmallConcurrentSetOfInts : object {
    private int _v1;
    private int _v2;
    private int _v3;
    private int _v4;
    private SmallConcurrentSetOfInts _next;
    private static int unoccupied;
    private SmallConcurrentSetOfInts(int initialValue);
    public bool Contains(int i);
    private static bool Contains(SmallConcurrentSetOfInts set, int i);
    public bool Add(int i);
    private static bool Add(SmallConcurrentSetOfInts set, int i);
    private static bool AddHelper(Int32& slot, int i, Boolean& added);
}
[DebuggerDisplayAttribute("{FilePath,nq}")]
public class Microsoft.CodeAnalysis.CommandLineAnalyzerReference : ValueType {
    private string _path;
    public string FilePath { get; }
    public CommandLineAnalyzerReference(string path);
    public string get_FilePath();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CommandLineAnalyzerReference other);
    public virtual int GetHashCode();
}
public abstract class Microsoft.CodeAnalysis.CommandLineArguments : object {
    [CompilerGeneratedAttribute]
private bool <IsScriptRunner>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InteractiveMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<KeyValuePair`2<string, string>> <PathMap>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ReferencePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <SourcePaths>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <KeyFileSearchPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Utf8Output>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompilationName>k__BackingField;
    [CompilerGeneratedAttribute]
private EmitOptions <EmitOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputRefFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PdbPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceLink>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuleSetPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmitPdb>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DocumentationPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorLogPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppConfigPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Diagnostic> <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CommandLineReference> <MetadataReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CommandLineAnalyzerReference> <AnalyzerReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CommandLineSourceFile> <AdditionalFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CommandLineSourceFile> <EmbeddedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportAnalyzer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisplayLogo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisplayHelp>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisplayVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisplayLangVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Win32ResourceFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Win32Icon>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Win32Manifest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoWin32Manifest>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ResourceDescription> <ManifestResources>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceHashAlgorithm <ChecksumAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ScriptArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CommandLineSourceFile> <SourceFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TouchedFilesPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrintFullPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <PreferredUILang>k__BackingField;
    internal bool IsScriptRunner { get; internal set; }
    public bool InteractiveMode { get; internal set; }
    public string BaseDirectory { get; internal set; }
    public ImmutableArray`1<KeyValuePair`2<string, string>> PathMap { get; internal set; }
    public ImmutableArray`1<string> ReferencePaths { get; internal set; }
    public ImmutableArray`1<string> SourcePaths { get; internal set; }
    public ImmutableArray`1<string> KeyFileSearchPaths { get; internal set; }
    public bool Utf8Output { get; internal set; }
    public string CompilationName { get; internal set; }
    public EmitOptions EmitOptions { get; internal set; }
    public string OutputFileName { get; internal set; }
    public string OutputRefFilePath { get; internal set; }
    public string PdbPath { get; internal set; }
    public string SourceLink { get; internal set; }
    public string RuleSetPath { get; internal set; }
    public bool EmitPdb { get; internal set; }
    public string OutputDirectory { get; internal set; }
    public string DocumentationPath { get; internal set; }
    public string ErrorLogPath { get; internal set; }
    public string AppConfigPath { get; internal set; }
    public ImmutableArray`1<Diagnostic> Errors { get; internal set; }
    public ImmutableArray`1<CommandLineReference> MetadataReferences { get; internal set; }
    public ImmutableArray`1<CommandLineAnalyzerReference> AnalyzerReferences { get; internal set; }
    public ImmutableArray`1<CommandLineSourceFile> AdditionalFiles { get; internal set; }
    public ImmutableArray`1<CommandLineSourceFile> EmbeddedFiles { get; internal set; }
    public bool ReportAnalyzer { get; internal set; }
    public bool DisplayLogo { get; internal set; }
    public bool DisplayHelp { get; internal set; }
    public bool DisplayVersion { get; internal set; }
    public bool DisplayLangVersions { get; internal set; }
    public string Win32ResourceFile { get; internal set; }
    public string Win32Icon { get; internal set; }
    public string Win32Manifest { get; internal set; }
    public bool NoWin32Manifest { get; internal set; }
    public ImmutableArray`1<ResourceDescription> ManifestResources { get; internal set; }
    public Encoding Encoding { get; internal set; }
    public SourceHashAlgorithm ChecksumAlgorithm { get; internal set; }
    public ImmutableArray`1<string> ScriptArguments { get; internal set; }
    public ImmutableArray`1<CommandLineSourceFile> SourceFiles { get; internal set; }
    public string TouchedFilesPath { get; internal set; }
    public bool PrintFullPaths { get; internal set; }
    public ParseOptions ParseOptions { get; }
    public CompilationOptions CompilationOptions { get; }
    protected ParseOptions ParseOptionsCore { get; }
    protected CompilationOptions CompilationOptionsCore { get; }
    public CultureInfo PreferredUILang { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_IsScriptRunner();
    [CompilerGeneratedAttribute]
internal void set_IsScriptRunner(bool value);
    [CompilerGeneratedAttribute]
public bool get_InteractiveMode();
    [CompilerGeneratedAttribute]
internal void set_InteractiveMode(bool value);
    [CompilerGeneratedAttribute]
public string get_BaseDirectory();
    [CompilerGeneratedAttribute]
internal void set_BaseDirectory(string value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<KeyValuePair`2<string, string>> get_PathMap();
    [CompilerGeneratedAttribute]
internal void set_PathMap(ImmutableArray`1<KeyValuePair`2<string, string>> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ReferencePaths();
    [CompilerGeneratedAttribute]
internal void set_ReferencePaths(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_SourcePaths();
    [CompilerGeneratedAttribute]
internal void set_SourcePaths(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_KeyFileSearchPaths();
    [CompilerGeneratedAttribute]
internal void set_KeyFileSearchPaths(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_Utf8Output();
    [CompilerGeneratedAttribute]
internal void set_Utf8Output(bool value);
    [CompilerGeneratedAttribute]
public string get_CompilationName();
    [CompilerGeneratedAttribute]
internal void set_CompilationName(string value);
    [CompilerGeneratedAttribute]
public EmitOptions get_EmitOptions();
    [CompilerGeneratedAttribute]
internal void set_EmitOptions(EmitOptions value);
    [CompilerGeneratedAttribute]
public string get_OutputFileName();
    [CompilerGeneratedAttribute]
internal void set_OutputFileName(string value);
    [CompilerGeneratedAttribute]
public string get_OutputRefFilePath();
    [CompilerGeneratedAttribute]
internal void set_OutputRefFilePath(string value);
    [CompilerGeneratedAttribute]
public string get_PdbPath();
    [CompilerGeneratedAttribute]
internal void set_PdbPath(string value);
    [CompilerGeneratedAttribute]
public string get_SourceLink();
    [CompilerGeneratedAttribute]
internal void set_SourceLink(string value);
    [CompilerGeneratedAttribute]
public string get_RuleSetPath();
    [CompilerGeneratedAttribute]
internal void set_RuleSetPath(string value);
    [CompilerGeneratedAttribute]
public bool get_EmitPdb();
    [CompilerGeneratedAttribute]
internal void set_EmitPdb(bool value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
internal void set_OutputDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_DocumentationPath();
    [CompilerGeneratedAttribute]
internal void set_DocumentationPath(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorLogPath();
    [CompilerGeneratedAttribute]
internal void set_ErrorLogPath(string value);
    [CompilerGeneratedAttribute]
public string get_AppConfigPath();
    [CompilerGeneratedAttribute]
internal void set_AppConfigPath(string value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<Diagnostic> get_Errors();
    [CompilerGeneratedAttribute]
internal void set_Errors(ImmutableArray`1<Diagnostic> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CommandLineReference> get_MetadataReferences();
    [CompilerGeneratedAttribute]
internal void set_MetadataReferences(ImmutableArray`1<CommandLineReference> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CommandLineAnalyzerReference> get_AnalyzerReferences();
    [CompilerGeneratedAttribute]
internal void set_AnalyzerReferences(ImmutableArray`1<CommandLineAnalyzerReference> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CommandLineSourceFile> get_AdditionalFiles();
    [CompilerGeneratedAttribute]
internal void set_AdditionalFiles(ImmutableArray`1<CommandLineSourceFile> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CommandLineSourceFile> get_EmbeddedFiles();
    [CompilerGeneratedAttribute]
internal void set_EmbeddedFiles(ImmutableArray`1<CommandLineSourceFile> value);
    [CompilerGeneratedAttribute]
public bool get_ReportAnalyzer();
    [CompilerGeneratedAttribute]
internal void set_ReportAnalyzer(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisplayLogo();
    [CompilerGeneratedAttribute]
internal void set_DisplayLogo(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisplayHelp();
    [CompilerGeneratedAttribute]
internal void set_DisplayHelp(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisplayVersion();
    [CompilerGeneratedAttribute]
internal void set_DisplayVersion(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisplayLangVersions();
    [CompilerGeneratedAttribute]
internal void set_DisplayLangVersions(bool value);
    [CompilerGeneratedAttribute]
public string get_Win32ResourceFile();
    [CompilerGeneratedAttribute]
internal void set_Win32ResourceFile(string value);
    [CompilerGeneratedAttribute]
public string get_Win32Icon();
    [CompilerGeneratedAttribute]
internal void set_Win32Icon(string value);
    [CompilerGeneratedAttribute]
public string get_Win32Manifest();
    [CompilerGeneratedAttribute]
internal void set_Win32Manifest(string value);
    [CompilerGeneratedAttribute]
public bool get_NoWin32Manifest();
    [CompilerGeneratedAttribute]
internal void set_NoWin32Manifest(bool value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ResourceDescription> get_ManifestResources();
    [CompilerGeneratedAttribute]
internal void set_ManifestResources(ImmutableArray`1<ResourceDescription> value);
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    [CompilerGeneratedAttribute]
internal void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public SourceHashAlgorithm get_ChecksumAlgorithm();
    [CompilerGeneratedAttribute]
internal void set_ChecksumAlgorithm(SourceHashAlgorithm value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ScriptArguments();
    [CompilerGeneratedAttribute]
internal void set_ScriptArguments(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CommandLineSourceFile> get_SourceFiles();
    [CompilerGeneratedAttribute]
internal void set_SourceFiles(ImmutableArray`1<CommandLineSourceFile> value);
    [CompilerGeneratedAttribute]
public string get_TouchedFilesPath();
    [CompilerGeneratedAttribute]
internal void set_TouchedFilesPath(string value);
    [CompilerGeneratedAttribute]
public bool get_PrintFullPaths();
    [CompilerGeneratedAttribute]
internal void set_PrintFullPaths(bool value);
    public ParseOptions get_ParseOptions();
    public CompilationOptions get_CompilationOptions();
    protected abstract virtual ParseOptions get_ParseOptionsCore();
    protected abstract virtual CompilationOptions get_CompilationOptionsCore();
    [CompilerGeneratedAttribute]
public CultureInfo get_PreferredUILang();
    [CompilerGeneratedAttribute]
internal void set_PreferredUILang(CultureInfo value);
    internal StrongNameProvider GetStrongNameProvider(StrongNameFileSystem fileSystem, string tempDirectory);
    public IEnumerable`1<MetadataReference> ResolveMetadataReferences(MetadataReferenceResolver metadataResolver);
    internal IEnumerable`1<MetadataReference> ResolveMetadataReferences(MetadataReferenceResolver metadataResolver, List`1<DiagnosticInfo> diagnosticsOpt, CommonMessageProvider messageProviderOpt);
    internal virtual bool ResolveMetadataReferences(MetadataReferenceResolver metadataResolver, List`1<DiagnosticInfo> diagnosticsOpt, CommonMessageProvider messageProviderOpt, List`1<MetadataReference> resolved);
    internal static ImmutableArray`1<PortableExecutableReference> ResolveMetadataReference(CommandLineReference cmdReference, MetadataReferenceResolver metadataResolver, List`1<DiagnosticInfo> diagnosticsOpt, CommonMessageProvider messageProviderOpt);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CommandLineArguments/<ResolveAnalyzerReferences>d__182")]
public IEnumerable`1<AnalyzerReference> ResolveAnalyzerReferences(IAnalyzerAssemblyLoader analyzerLoader);
    internal ImmutableArray`1<DiagnosticAnalyzer> ResolveAnalyzersFromArguments(string language, List`1<DiagnosticInfo> diagnostics, CommonMessageProvider messageProvider, IAnalyzerAssemblyLoader analyzerLoader);
    private AnalyzerFileReference ResolveAnalyzerReference(CommandLineAnalyzerReference reference, IAnalyzerAssemblyLoader analyzerLoader);
}
public abstract class Microsoft.CodeAnalysis.CommandLineParser : object {
    private CommonMessageProvider _messageProvider;
    internal bool IsScriptCommandLineParser;
    private static Char[] s_searchPatternTrimChars;
    private static Char[] s_resourceSeparators;
    private static Char[] s_pathSeparators;
    private static Char[] s_wildcards;
    internal CommonMessageProvider MessageProvider { get; }
    protected string RegularFileExtension { get; }
    protected string ScriptFileExtension { get; }
    internal static string MismatchedVersionErrorText { get; }
    internal CommandLineParser(CommonMessageProvider messageProvider, bool isScriptCommandLineParser);
    private static CommandLineParser();
    internal CommonMessageProvider get_MessageProvider();
    protected abstract virtual string get_RegularFileExtension();
    protected abstract virtual string get_ScriptFileExtension();
    internal virtual TextReader CreateTextFileReader(string fullPath);
    internal virtual IEnumerable`1<string> EnumerateFiles(string directory, string fileNamePattern, SearchOption searchOption);
    internal abstract virtual CommandLineArguments CommonParse(IEnumerable`1<string> args, string baseDirectory, string sdkDirectoryOpt, string additionalReferenceDirectories);
    public CommandLineArguments Parse(IEnumerable`1<string> args, string baseDirectory, string sdkDirectory, string additionalReferenceDirectories);
    private static bool IsOption(string arg);
    internal static bool TryParseOption(string arg, String& name, String& value);
    internal static void ParseAndNormalizeFile(string unquoted, string baseDirectory, String& outputFileName, String& outputDirectory, String& invalidPath);
    internal static string RemoveTrailingSpacesAndDots(string path);
    protected ImmutableArray`1<KeyValuePair`2<string, string>> ParsePathMap(string pathMap, IList`1<Diagnostic> errors);
    internal void ParseOutputFile(string value, IList`1<Diagnostic> errors, string baseDirectory, String& outputFileName, String& outputDirectory);
    internal string ParsePdbPath(string value, IList`1<Diagnostic> errors, string baseDirectory);
    internal string ParseGenericPathToFile(string unquoted, IList`1<Diagnostic> errors, string baseDirectory, bool generateDiagnostic);
    internal void FlattenArgs(IEnumerable`1<string> rawArguments, IList`1<Diagnostic> diagnostics, List`1<string> processedArgs, List`1<string> scriptArgsOpt, string baseDirectory, List`1<string> responsePaths);
    internal static bool TryParseClientArgs(IEnumerable`1<string> args, List`1& parsedArgs, Boolean& containsShared, String& keepAliveValue, String& sessionKey, String& errorMessage);
    internal static bool IsClientArgsOption(string arg, string optionName, Boolean& hasValue, String& optionValue);
    internal static string get_MismatchedVersionErrorText();
    internal IEnumerable`1<string> ParseResponseFile(string fullPath, IList`1<Diagnostic> errors);
    internal static IEnumerable`1<string> ParseResponseLines(IEnumerable`1<string> lines);
    internal static void ParseResourceDescription(string resourceDescriptor, string baseDirectory, bool skipLeadingSeparators, String& filePath, String& fullPath, String& fileName, String& resourceName, String& accessibility);
    public static IEnumerable`1<string> SplitCommandLineIntoArguments(string commandLine, bool removeHashComments);
    internal static string RemoveQuotesAndSlashes(string arg);
    internal static void ProcessSlashes(StringBuilder builder, string arg, Int32& i);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CommandLineParser/<Split>d__34")]
private static IEnumerable`1<string> Split(string str, Func`2<char, bool> splitHere);
    internal static IEnumerable`1<string> ParseSeparatedPaths(string str);
    internal static IEnumerable`1<string> ParseSeparatedStrings(string str, Char[] separators, StringSplitOptions options);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CommandLineParser/<ResolveRelativePaths>d__39")]
internal IEnumerable`1<string> ResolveRelativePaths(IEnumerable`1<string> paths, string baseDirectory, IList`1<Diagnostic> errors);
    private CommandLineSourceFile ToCommandLineSourceFile(string resolvedPath);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CommandLineParser/<ParseFileArgument>d__41")]
internal IEnumerable`1<CommandLineSourceFile> ParseFileArgument(string arg, string baseDirectory, IList`1<Diagnostic> errors);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CommandLineParser/<ParseSeparatedFileArgument>d__42")]
internal IEnumerable`1<CommandLineSourceFile> ParseSeparatedFileArgument(string value, string baseDirectory, IList`1<Diagnostic> errors);
    internal IEnumerable`1<CommandLineSourceFile> ParseRecurseArgument(string arg, string baseDirectory, IList`1<Diagnostic> errors);
    internal static Encoding TryParseEncodingName(string arg);
    internal static SourceHashAlgorithm TryParseHashAlgorithmName(string arg);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CommandLineParser/<ExpandFileNamePattern>d__46")]
private IEnumerable`1<CommandLineSourceFile> ExpandFileNamePattern(string path, string baseDirectory, SearchOption searchOption, IList`1<Diagnostic> errors);
    internal abstract virtual void GenerateErrorForNoFilesFoundInRecurse(string path, IList`1<Diagnostic> errors);
    internal ReportDiagnostic GetDiagnosticOptionsFromRulesetFile(string fullPath, Dictionary`2& diagnosticOptions, IList`1<Diagnostic> diagnostics);
    internal static bool TryParseUInt64(string value, UInt64& result);
    internal static bool TryParseUInt16(string value, UInt16& result);
    internal static ImmutableDictionary`2<string, string> ParseFeatures(List`1<string> features);
}
[DebuggerDisplayAttribute("{Reference,nq}")]
public class Microsoft.CodeAnalysis.CommandLineReference : ValueType {
    private string _reference;
    private MetadataReferenceProperties _properties;
    public string Reference { get; }
    public MetadataReferenceProperties Properties { get; }
    public CommandLineReference(string reference, MetadataReferenceProperties properties);
    public string get_Reference();
    public MetadataReferenceProperties get_Properties();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CommandLineReference other);
    public virtual int GetHashCode();
}
[DebuggerDisplayAttribute("{Path,nq}")]
public class Microsoft.CodeAnalysis.CommandLineSourceFile : ValueType {
    private string _path;
    private bool _isScript;
    public string Path { get; }
    public bool IsScript { get; }
    public CommandLineSourceFile(string path, bool isScript);
    public string get_Path();
    public bool get_IsScript();
}
[AttributeUsageAttribute("1")]
internal class Microsoft.CodeAnalysis.CommitHashAttribute : Attribute {
    internal string Hash;
    public CommitHashAttribute(string hash);
}
internal class Microsoft.CodeAnalysis.CommonAssemblyWellKnownAttributeData`1 : WellKnownAttributeData {
    private string _assemblySignatureKeyAttributeSetting;
    private ThreeState _assemblyDelaySignAttributeSetting;
    private string _assemblyKeyFileAttributeSetting;
    private string _assemblyKeyContainerAttributeSetting;
    private Version _assemblyVersionAttributeSetting;
    private string _assemblyFileVersionAttributeSetting;
    private string _assemblyTitleAttributeSetting;
    private string _assemblyDescriptionAttributeSetting;
    private string _assemblyCultureAttributeSetting;
    private string _assemblyCompanyAttributeSetting;
    private string _assemblyProductAttributeSetting;
    private string _assemblyInformationalVersionAttributeSetting;
    private string _assemblyCopyrightAttributeSetting;
    private string _assemblyTrademarkAttributeSetting;
    private AssemblyFlags _assemblyFlagsAttributeSetting;
    private Nullable`1<AssemblyHashAlgorithm> _assemblyAlgorithmIdAttributeSetting;
    private bool _hasCompilationRelaxationsAttribute;
    private bool _hasReferenceAssemblyAttribute;
    private Nullable`1<bool> _runtimeCompatibilityWrapNonExceptionThrows;
    internal static bool WrapNonExceptionThrowsDefault;
    private bool _hasDebuggableAttribute;
    private SecurityWellKnownAttributeData _lazySecurityAttributeData;
    private HashSet`1<TNamedTypeSymbol> _forwardedTypes;
    public string AssemblySignatureKeyAttributeSetting { get; public set; }
    public ThreeState AssemblyDelaySignAttributeSetting { get; public set; }
    public string AssemblyKeyFileAttributeSetting { get; public set; }
    public string AssemblyKeyContainerAttributeSetting { get; public set; }
    public Version AssemblyVersionAttributeSetting { get; public set; }
    public string AssemblyFileVersionAttributeSetting { get; public set; }
    public string AssemblyTitleAttributeSetting { get; public set; }
    public string AssemblyDescriptionAttributeSetting { get; public set; }
    public string AssemblyCultureAttributeSetting { get; public set; }
    public string AssemblyCompanyAttributeSetting { get; public set; }
    public string AssemblyProductAttributeSetting { get; public set; }
    public string AssemblyInformationalVersionAttributeSetting { get; public set; }
    public string AssemblyCopyrightAttributeSetting { get; public set; }
    public string AssemblyTrademarkAttributeSetting { get; public set; }
    public AssemblyFlags AssemblyFlagsAttributeSetting { get; public set; }
    public Nullable`1<AssemblyHashAlgorithm> AssemblyAlgorithmIdAttributeSetting { get; public set; }
    public bool HasCompilationRelaxationsAttribute { get; public set; }
    public bool HasReferenceAssemblyAttribute { get; public set; }
    public bool HasRuntimeCompatibilityAttribute { get; }
    public bool RuntimeCompatibilityWrapNonExceptionThrows { get; public set; }
    public bool HasDebuggableAttribute { get; public set; }
    public SecurityWellKnownAttributeData SecurityInformation { get; }
    public HashSet`1<TNamedTypeSymbol> ForwardedTypes { get; public set; }
    public string get_AssemblySignatureKeyAttributeSetting();
    public void set_AssemblySignatureKeyAttributeSetting(string value);
    public ThreeState get_AssemblyDelaySignAttributeSetting();
    public void set_AssemblyDelaySignAttributeSetting(ThreeState value);
    public string get_AssemblyKeyFileAttributeSetting();
    public void set_AssemblyKeyFileAttributeSetting(string value);
    public string get_AssemblyKeyContainerAttributeSetting();
    public void set_AssemblyKeyContainerAttributeSetting(string value);
    public Version get_AssemblyVersionAttributeSetting();
    public void set_AssemblyVersionAttributeSetting(Version value);
    public string get_AssemblyFileVersionAttributeSetting();
    public void set_AssemblyFileVersionAttributeSetting(string value);
    public string get_AssemblyTitleAttributeSetting();
    public void set_AssemblyTitleAttributeSetting(string value);
    public string get_AssemblyDescriptionAttributeSetting();
    public void set_AssemblyDescriptionAttributeSetting(string value);
    public string get_AssemblyCultureAttributeSetting();
    public void set_AssemblyCultureAttributeSetting(string value);
    public string get_AssemblyCompanyAttributeSetting();
    public void set_AssemblyCompanyAttributeSetting(string value);
    public string get_AssemblyProductAttributeSetting();
    public void set_AssemblyProductAttributeSetting(string value);
    public string get_AssemblyInformationalVersionAttributeSetting();
    public void set_AssemblyInformationalVersionAttributeSetting(string value);
    public string get_AssemblyCopyrightAttributeSetting();
    public void set_AssemblyCopyrightAttributeSetting(string value);
    public string get_AssemblyTrademarkAttributeSetting();
    public void set_AssemblyTrademarkAttributeSetting(string value);
    public AssemblyFlags get_AssemblyFlagsAttributeSetting();
    public void set_AssemblyFlagsAttributeSetting(AssemblyFlags value);
    public Nullable`1<AssemblyHashAlgorithm> get_AssemblyAlgorithmIdAttributeSetting();
    public void set_AssemblyAlgorithmIdAttributeSetting(Nullable`1<AssemblyHashAlgorithm> value);
    public bool get_HasCompilationRelaxationsAttribute();
    public void set_HasCompilationRelaxationsAttribute(bool value);
    public bool get_HasReferenceAssemblyAttribute();
    public void set_HasReferenceAssemblyAttribute(bool value);
    public bool get_HasRuntimeCompatibilityAttribute();
    public bool get_RuntimeCompatibilityWrapNonExceptionThrows();
    public void set_RuntimeCompatibilityWrapNonExceptionThrows(bool value);
    public bool get_HasDebuggableAttribute();
    public void set_HasDebuggableAttribute(bool value);
    private sealed virtual override SecurityWellKnownAttributeData Microsoft.CodeAnalysis.ISecurityAttributeTarget.GetOrCreateData();
    public SecurityWellKnownAttributeData get_SecurityInformation();
    public HashSet`1<TNamedTypeSymbol> get_ForwardedTypes();
    public void set_ForwardedTypes(HashSet`1<TNamedTypeSymbol> value);
}
internal class Microsoft.CodeAnalysis.CommonAttributeDataComparer : object {
    public static CommonAttributeDataComparer Instance;
    private static CommonAttributeDataComparer();
    public sealed virtual bool Equals(AttributeData attr1, AttributeData attr2);
    public sealed virtual int GetHashCode(AttributeData attr);
    private static int GetHashCodeForConstructorArguments(ImmutableArray`1<TypedConstant> constructorArguments);
    private static int GetHashCodeForNamedArguments(ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CommonAttributeDataExtensions : object {
    [ExtensionAttribute]
public static bool TryGetGuidAttributeValue(AttributeData attrData, String& guidString);
}
internal abstract class Microsoft.CodeAnalysis.CommonCompiler : object {
    internal static int Failed;
    internal static int Succeeded;
    private string _clientDirectory;
    [CompilerGeneratedAttribute]
private CommonMessageProvider <MessageProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandLineArguments <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IAnalyzerAssemblyLoader <AssemblyLoader>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlySet`1<string> <EmbeddedSourcePaths>k__BackingField;
    private HashSet`1<Diagnostic> _reportedDiagnostics;
    private Func`5<string, FileMode, FileAccess, FileShare, Stream> _fileOpen;
    public CommonMessageProvider MessageProvider { get; }
    public CommandLineArguments Arguments { get; }
    public IAnalyzerAssemblyLoader AssemblyLoader { get; private set; }
    public DiagnosticFormatter DiagnosticFormatter { get; }
    public IReadOnlySet`1<string> EmbeddedSourcePaths { get; }
    internal Type Type { get; }
    internal Func`5<string, FileMode, FileAccess, FileShare, Stream> FileOpen { get; internal set; }
    protected CultureInfo Culture { get; }
    public CommonCompiler(CommandLineParser parser, string responseFile, String[] args, BuildPaths buildPaths, string additionalReferenceDirectories, IAnalyzerAssemblyLoader assemblyLoader);
    [CompilerGeneratedAttribute]
public CommonMessageProvider get_MessageProvider();
    [CompilerGeneratedAttribute]
public CommandLineArguments get_Arguments();
    [CompilerGeneratedAttribute]
public IAnalyzerAssemblyLoader get_AssemblyLoader();
    [CompilerGeneratedAttribute]
private void set_AssemblyLoader(IAnalyzerAssemblyLoader value);
    public abstract virtual DiagnosticFormatter get_DiagnosticFormatter();
    [CompilerGeneratedAttribute]
public IReadOnlySet`1<string> get_EmbeddedSourcePaths();
    public abstract virtual Compilation CreateCompilation(TextWriter consoleOutput, TouchedFileLogger touchedFilesLogger, ErrorLogger errorLoggerOpt);
    public abstract virtual void PrintLogo(TextWriter consoleOutput);
    public abstract virtual void PrintHelp(TextWriter consoleOutput);
    public abstract virtual void PrintLangVersions(TextWriter consoleOutput);
    public virtual void PrintVersion(TextWriter consoleOutput);
    protected abstract virtual bool TryGetCompilerDiagnosticCode(string diagnosticId, UInt32& code);
    protected abstract virtual ImmutableArray`1<DiagnosticAnalyzer> ResolveAnalyzersFromArguments(List`1<DiagnosticInfo> diagnostics, CommonMessageProvider messageProvider);
    internal abstract virtual bool SuppressDefaultResponseFile(IEnumerable`1<string> args);
    internal abstract virtual Type get_Type();
    internal virtual string GetAssemblyFileVersion();
    internal static string GetAssemblyFileVersion(Assembly assembly);
    internal static string ExtractShortCommitHash(string hash);
    internal abstract virtual string GetToolName();
    internal Version GetAssemblyVersion();
    internal string GetCultureName();
    internal virtual Func`3<string, MetadataReferenceProperties, PortableExecutableReference> GetMetadataProvider();
    internal virtual MetadataReferenceResolver GetCommandLineMetadataReferenceResolver(TouchedFileLogger loggerOpt);
    internal List`1<MetadataReference> ResolveMetadataReferences(List`1<DiagnosticInfo> diagnostics, TouchedFileLogger touchedFiles, MetadataReferenceResolver& referenceDirectiveResolver);
    internal SourceText TryReadFileContent(CommandLineSourceFile file, IList`1<DiagnosticInfo> diagnostics);
    internal SourceText TryReadFileContent(CommandLineSourceFile file, IList`1<DiagnosticInfo> diagnostics, String& normalizedFilePath);
    private static FileStream OpenFileForReadWithSmallBufferOptimization(string filePath);
    internal EmbeddedText TryReadEmbeddedFileContent(string filePath, DiagnosticBag diagnostics);
    private ImmutableArray`1<EmbeddedText> AcquireEmbeddedTexts(Compilation compilation, DiagnosticBag diagnostics);
    protected abstract virtual void ResolveEmbeddedFilesFromExternalSourceDirectives(SyntaxTree tree, SourceReferenceResolver resolver, OrderedSet`1<string> embeddedFiles, DiagnosticBag diagnostics);
    private static IReadOnlySet`1<string> GetEmbeddedSourcePaths(CommandLineArguments arguments);
    internal static DiagnosticInfo ToFileReadDiagnostics(CommonMessageProvider messageProvider, Exception e, string filePath);
    internal bool ReportErrors(IEnumerable`1<Diagnostic> diagnostics, TextWriter consoleOutput, ErrorLogger errorLoggerOpt);
    private bool ReportErrors(DiagnosticBag diagnostics, TextWriter consoleOutput, ErrorLogger errorLoggerOpt);
    private static bool IsReportedError(Diagnostic diagnostic);
    public bool ReportErrors(IEnumerable`1<DiagnosticInfo> diagnostics, TextWriter consoleOutput, ErrorLogger errorLoggerOpt);
    protected virtual void PrintError(Diagnostic diagnostic, TextWriter consoleOutput);
    public StreamErrorLogger GetErrorLogger(TextWriter consoleOutput, CancellationToken cancellationToken);
    public virtual int Run(TextWriter consoleOutput, CancellationToken cancellationToken);
    private int RunCore(TextWriter consoleOutput, ErrorLogger errorLogger, CancellationToken cancellationToken);
    private void CompileAndEmit(TouchedFileLogger touchedFilesLogger, Compilation& compilation, ImmutableArray`1<DiagnosticAnalyzer> analyzers, ImmutableArray`1<AdditionalTextFile> additionalTextFiles, ImmutableArray`1<EmbeddedText> embeddedTexts, DiagnosticBag diagnostics, CancellationToken cancellationToken, CancellationTokenSource& analyzerCts, Boolean& reportAnalyzer, AnalyzerDriver& analyzerDriver);
    private bool WriteTouchedFiles(DiagnosticBag diagnostics, TouchedFileLogger touchedFilesLogger, string finalXmlFilePath);
    protected virtual ImmutableArray`1<AdditionalTextFile> ResolveAdditionalFilesFromArguments(List`1<DiagnosticInfo> diagnostics, CommonMessageProvider messageProvider, TouchedFileLogger touchedFilesLogger);
    private static void ReportAnalyzerExecutionTime(TextWriter consoleOutput, AnalyzerDriver analyzerDriver, CultureInfo culture, bool isConcurrentBuild);
    protected virtual string GetOutputFileName(Compilation compilation, CancellationToken cancellationToken);
    internal Func`5<string, FileMode, FileAccess, FileShare, Stream> get_FileOpen();
    internal void set_FileOpen(Func`5<string, FileMode, FileAccess, FileShare, Stream> value);
    private Stream OpenFile(string filePath, DiagnosticBag diagnostics, FileMode mode, FileAccess access, FileShare share);
    internal static Stream GetWin32ResourcesInternal(CommonMessageProvider messageProvider, CommandLineArguments arguments, Compilation compilation, IEnumerable`1& errors);
    private static Stream GetWin32Resources(CommonMessageProvider messageProvider, CommandLineArguments arguments, Compilation compilation, DiagnosticBag diagnostics);
    private static Stream OpenManifestStream(CommonMessageProvider messageProvider, OutputKind outputKind, CommandLineArguments arguments, DiagnosticBag diagnostics);
    private static Stream OpenStream(CommonMessageProvider messageProvider, string path, string baseDirectory, int errorCode, DiagnosticBag diagnostics);
    private static string ResolveRelativePath(CommonMessageProvider messageProvider, string path, string baseDirectory, DiagnosticBag diagnostics);
    internal static bool TryGetCompilerDiagnosticCode(string diagnosticId, string expectedPrefix, UInt32& code);
    protected virtual CultureInfo get_Culture();
    private static void EmitDeterminismKey(CommandLineArguments args, String[] rawArgs, string baseDirectory, CommandLineParser parser);
    private static string CreateDeterminismKey(CommandLineArguments args, String[] rawArgs, string baseDirectory, CommandLineParser parser);
}
internal class Microsoft.CodeAnalysis.CommonDiagnosticComparer : object {
    internal static CommonDiagnosticComparer Instance;
    private static CommonDiagnosticComparer();
    public sealed virtual bool Equals(Diagnostic x, Diagnostic y);
    public sealed virtual int GetHashCode(Diagnostic obj);
}
internal class Microsoft.CodeAnalysis.CommonEventEarlyWellKnownAttributeData : EarlyWellKnownAttributeData {
    private ObsoleteAttributeData _obsoleteAttributeData;
    public ObsoleteAttributeData ObsoleteAttributeData { get; public set; }
    public ObsoleteAttributeData get_ObsoleteAttributeData();
    public void set_ObsoleteAttributeData(ObsoleteAttributeData value);
}
internal class Microsoft.CodeAnalysis.CommonEventWellKnownAttributeData : WellKnownAttributeData {
    private bool _hasSpecialNameAttribute;
    private bool _hasExcludeFromCodeCoverageAttribute;
    public bool HasSpecialNameAttribute { get; public set; }
    public bool HasExcludeFromCodeCoverageAttribute { get; public set; }
    public bool get_HasSpecialNameAttribute();
    public void set_HasSpecialNameAttribute(bool value);
    public bool get_HasExcludeFromCodeCoverageAttribute();
    public void set_HasExcludeFromCodeCoverageAttribute(bool value);
}
internal class Microsoft.CodeAnalysis.CommonFieldEarlyWellKnownAttributeData : EarlyWellKnownAttributeData {
    private ObsoleteAttributeData _obsoleteAttributeData;
    public ObsoleteAttributeData ObsoleteAttributeData { get; public set; }
    public ObsoleteAttributeData get_ObsoleteAttributeData();
    public void set_ObsoleteAttributeData(ObsoleteAttributeData value);
}
internal class Microsoft.CodeAnalysis.CommonFieldWellKnownAttributeData : WellKnownAttributeData {
    private int _offset;
    private static int Uninitialized;
    private ConstantValue _constValue;
    private bool _hasSpecialNameAttribute;
    private bool _hasNonSerializedAttribute;
    private MarshalPseudoCustomAttributeData _lazyMarshalAsData;
    public Nullable`1<int> Offset { get; }
    public ConstantValue ConstValue { get; public set; }
    public bool HasSpecialNameAttribute { get; public set; }
    public bool HasNonSerializedAttribute { get; public set; }
    public MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    public void SetFieldOffset(int offset);
    public Nullable`1<int> get_Offset();
    public ConstantValue get_ConstValue();
    public void set_ConstValue(ConstantValue value);
    public bool get_HasSpecialNameAttribute();
    public void set_HasSpecialNameAttribute(bool value);
    public bool get_HasNonSerializedAttribute();
    public void set_HasNonSerializedAttribute(bool value);
    private sealed virtual override MarshalPseudoCustomAttributeData Microsoft.CodeAnalysis.IMarshalAsAttributeTarget.GetOrCreateData();
    public MarshalPseudoCustomAttributeData get_MarshallingInformation();
}
internal abstract class Microsoft.CodeAnalysis.CommonMessageProvider : object {
    public string CodePrefix { get; }
    public Type ErrorCodeType { get; }
    public int ERR_FailedToCreateTempFile { get; }
    public int ERR_ExpectedSingleScript { get; }
    public int ERR_OpenResponseFile { get; }
    public int ERR_InvalidPathMap { get; }
    public int FTL_InvalidInputFileName { get; }
    public int ERR_FileNotFound { get; }
    public int ERR_NoSourceFile { get; }
    public int ERR_CantOpenFileWrite { get; }
    public int ERR_OutputWriteFailed { get; }
    public int WRN_NoConfigNotOnCommandLine { get; }
    public int ERR_BinaryFile { get; }
    public int WRN_UnableToLoadAnalyzer { get; }
    public int INF_UnableToLoadSomeTypesInAnalyzer { get; }
    public int WRN_AnalyzerCannotBeCreated { get; }
    public int WRN_NoAnalyzerInAssembly { get; }
    public int ERR_CantReadRulesetFile { get; }
    public int ERR_CompileCancelled { get; }
    public int ERR_BadSourceCodeKind { get; }
    public int ERR_BadDocumentationMode { get; }
    public int ERR_BadCompilationOptionValue { get; }
    public int ERR_MutuallyExclusiveOptions { get; }
    public int ERR_InvalidDebugInformationFormat { get; }
    public int ERR_InvalidFileAlignment { get; }
    public int ERR_InvalidSubsystemVersion { get; }
    public int ERR_InvalidOutputName { get; }
    public int ERR_InvalidInstrumentationKind { get; }
    public int ERR_InvalidHashAlgorithmName { get; }
    public int ERR_MetadataFileNotAssembly { get; }
    public int ERR_MetadataFileNotModule { get; }
    public int ERR_InvalidAssemblyMetadata { get; }
    public int ERR_InvalidModuleMetadata { get; }
    public int ERR_ErrorOpeningAssemblyFile { get; }
    public int ERR_ErrorOpeningModuleFile { get; }
    public int ERR_MetadataFileNotFound { get; }
    public int ERR_MetadataReferencesNotSupported { get; }
    public int ERR_LinkedNetmoduleMetadataMustProvideFullPEImage { get; }
    public int ERR_PublicKeyFileFailure { get; }
    public int ERR_PublicKeyContainerFailure { get; }
    public int ERR_OptionMustBeAbsolutePath { get; }
    public int ERR_CantReadResource { get; }
    public int ERR_CantOpenWin32Resource { get; }
    public int ERR_CantOpenWin32Manifest { get; }
    public int ERR_CantOpenWin32Icon { get; }
    public int ERR_BadWin32Resource { get; }
    public int ERR_ErrorBuildingWin32Resource { get; }
    public int ERR_ResourceNotUnique { get; }
    public int ERR_ResourceFileNameNotUnique { get; }
    public int ERR_ResourceInModule { get; }
    public int ERR_PermissionSetAttributeFileReadError { get; }
    public int ERR_EncodinglessSyntaxTree { get; }
    public int WRN_PdbUsingNameTooLong { get; }
    public int WRN_PdbLocalNameTooLong { get; }
    public int ERR_PdbWritingFailed { get; }
    public int ERR_MetadataNameTooLong { get; }
    public int ERR_EncReferenceToAddedMember { get; }
    public int ERR_TooManyUserStrings { get; }
    public int ERR_PeWritingFailure { get; }
    public int ERR_ModuleEmitFailure { get; }
    public int ERR_EncUpdateFailedMissingAttribute { get; }
    public int ERR_InvalidDebugInfo { get; }
    public int ERR_BadAssemblyName { get; }
    public abstract virtual DiagnosticSeverity GetSeverity(int code);
    public abstract virtual string LoadMessage(int code, CultureInfo language);
    public abstract virtual LocalizableString GetTitle(int code);
    public abstract virtual LocalizableString GetDescription(int code);
    public abstract virtual LocalizableString GetMessageFormat(int code);
    public abstract virtual string GetHelpLink(int code);
    public abstract virtual string GetCategory(int code);
    public abstract virtual string get_CodePrefix();
    public abstract virtual int GetWarningLevel(int code);
    public abstract virtual Type get_ErrorCodeType();
    public Diagnostic CreateDiagnostic(int code, Location location);
    public abstract virtual Diagnostic CreateDiagnostic(DiagnosticInfo info);
    public abstract virtual Diagnostic CreateDiagnostic(int code, Location location, Object[] args);
    public abstract virtual string GetMessagePrefix(string id, DiagnosticSeverity severity, bool isWarningAsError, CultureInfo culture);
    public abstract virtual string GetErrorDisplayString(ISymbol symbol);
    public string GetIdForErrorCode(int errorCode);
    public abstract virtual ReportDiagnostic GetDiagnosticReport(DiagnosticInfo diagnosticInfo, CompilationOptions options);
    public DiagnosticInfo FilterDiagnosticInfo(DiagnosticInfo diagnosticInfo, CompilationOptions options);
    public abstract virtual int get_ERR_FailedToCreateTempFile();
    public abstract virtual int get_ERR_ExpectedSingleScript();
    public abstract virtual int get_ERR_OpenResponseFile();
    public abstract virtual int get_ERR_InvalidPathMap();
    public abstract virtual int get_FTL_InvalidInputFileName();
    public abstract virtual int get_ERR_FileNotFound();
    public abstract virtual int get_ERR_NoSourceFile();
    public abstract virtual int get_ERR_CantOpenFileWrite();
    public abstract virtual int get_ERR_OutputWriteFailed();
    public abstract virtual int get_WRN_NoConfigNotOnCommandLine();
    public abstract virtual int get_ERR_BinaryFile();
    public abstract virtual int get_WRN_UnableToLoadAnalyzer();
    public abstract virtual int get_INF_UnableToLoadSomeTypesInAnalyzer();
    public abstract virtual int get_WRN_AnalyzerCannotBeCreated();
    public abstract virtual int get_WRN_NoAnalyzerInAssembly();
    public abstract virtual int get_ERR_CantReadRulesetFile();
    public abstract virtual int get_ERR_CompileCancelled();
    public abstract virtual int get_ERR_BadSourceCodeKind();
    public abstract virtual int get_ERR_BadDocumentationMode();
    public abstract virtual int get_ERR_BadCompilationOptionValue();
    public abstract virtual int get_ERR_MutuallyExclusiveOptions();
    public abstract virtual int get_ERR_InvalidDebugInformationFormat();
    public abstract virtual int get_ERR_InvalidFileAlignment();
    public abstract virtual int get_ERR_InvalidSubsystemVersion();
    public abstract virtual int get_ERR_InvalidOutputName();
    public abstract virtual int get_ERR_InvalidInstrumentationKind();
    public abstract virtual int get_ERR_InvalidHashAlgorithmName();
    public abstract virtual int get_ERR_MetadataFileNotAssembly();
    public abstract virtual int get_ERR_MetadataFileNotModule();
    public abstract virtual int get_ERR_InvalidAssemblyMetadata();
    public abstract virtual int get_ERR_InvalidModuleMetadata();
    public abstract virtual int get_ERR_ErrorOpeningAssemblyFile();
    public abstract virtual int get_ERR_ErrorOpeningModuleFile();
    public abstract virtual int get_ERR_MetadataFileNotFound();
    public abstract virtual int get_ERR_MetadataReferencesNotSupported();
    public abstract virtual int get_ERR_LinkedNetmoduleMetadataMustProvideFullPEImage();
    public abstract virtual void ReportDuplicateMetadataReferenceStrong(DiagnosticBag diagnostics, Location location, MetadataReference reference, AssemblyIdentity identity, MetadataReference equivalentReference, AssemblyIdentity equivalentIdentity);
    public abstract virtual void ReportDuplicateMetadataReferenceWeak(DiagnosticBag diagnostics, Location location, MetadataReference reference, AssemblyIdentity identity, MetadataReference equivalentReference, AssemblyIdentity equivalentIdentity);
    public abstract virtual int get_ERR_PublicKeyFileFailure();
    public abstract virtual int get_ERR_PublicKeyContainerFailure();
    public abstract virtual int get_ERR_OptionMustBeAbsolutePath();
    public abstract virtual int get_ERR_CantReadResource();
    public abstract virtual int get_ERR_CantOpenWin32Resource();
    public abstract virtual int get_ERR_CantOpenWin32Manifest();
    public abstract virtual int get_ERR_CantOpenWin32Icon();
    public abstract virtual int get_ERR_BadWin32Resource();
    public abstract virtual int get_ERR_ErrorBuildingWin32Resource();
    public abstract virtual int get_ERR_ResourceNotUnique();
    public abstract virtual int get_ERR_ResourceFileNameNotUnique();
    public abstract virtual int get_ERR_ResourceInModule();
    public abstract virtual int get_ERR_PermissionSetAttributeFileReadError();
    public abstract virtual int get_ERR_EncodinglessSyntaxTree();
    public abstract virtual int get_WRN_PdbUsingNameTooLong();
    public abstract virtual int get_WRN_PdbLocalNameTooLong();
    public abstract virtual int get_ERR_PdbWritingFailed();
    public abstract virtual int get_ERR_MetadataNameTooLong();
    public abstract virtual int get_ERR_EncReferenceToAddedMember();
    public abstract virtual int get_ERR_TooManyUserStrings();
    public abstract virtual int get_ERR_PeWritingFailure();
    public abstract virtual int get_ERR_ModuleEmitFailure();
    public abstract virtual int get_ERR_EncUpdateFailedMissingAttribute();
    public abstract virtual int get_ERR_InvalidDebugInfo();
    public void ReportStreamWriteException(Exception e, string filePath, DiagnosticBag diagnostics);
    public abstract virtual void ReportInvalidAttributeArgument(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int parameterIndex, AttributeData attribute);
    public abstract virtual void ReportInvalidNamedArgument(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int namedArgumentIndex, ITypeSymbol attributeClass, string parameterName);
    public abstract virtual void ReportParameterNotValidForType(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int namedArgumentIndex);
    public abstract virtual void ReportMarshalUnmanagedTypeNotValidForFields(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int parameterIndex, string unmanagedTypeName, AttributeData attribute);
    public abstract virtual void ReportMarshalUnmanagedTypeOnlyValidForFields(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, int parameterIndex, string unmanagedTypeName, AttributeData attribute);
    public abstract virtual void ReportAttributeParameterRequired(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, string parameterName);
    public abstract virtual void ReportAttributeParameterRequired(DiagnosticBag diagnostics, SyntaxNode attributeSyntax, string parameterName1, string parameterName2);
    public abstract virtual int get_ERR_BadAssemblyName();
}
internal class Microsoft.CodeAnalysis.CommonMethodEarlyWellKnownAttributeData : EarlyWellKnownAttributeData {
    private ImmutableArray`1<string> _lazyConditionalSymbols;
    private ObsoleteAttributeData _obsoleteAttributeData;
    public ImmutableArray`1<string> ConditionalSymbols { get; }
    public ObsoleteAttributeData ObsoleteAttributeData { get; public set; }
    public void AddConditionalSymbol(string name);
    public ImmutableArray`1<string> get_ConditionalSymbols();
    public ObsoleteAttributeData get_ObsoleteAttributeData();
    public void set_ObsoleteAttributeData(ObsoleteAttributeData value);
}
internal class Microsoft.CodeAnalysis.CommonMethodWellKnownAttributeData : WellKnownAttributeData {
    private bool _preserveSigFirstWriteWins;
    private DllImportData _platformInvokeInfo;
    private bool _dllImportPreserveSig;
    private int _dllImportIndex;
    private int _methodImplIndex;
    private MethodImplAttributes _attributes;
    private int _preserveSigIndex;
    private bool _hasSpecialNameAttribute;
    private bool _hasDynamicSecurityMethodAttribute;
    private bool _hasSuppressUnmanagedCodeSecurityAttribute;
    private SecurityWellKnownAttributeData _lazySecurityAttributeData;
    private bool _hasExcludeFromCodeCoverageAttribute;
    public DllImportData DllImportPlatformInvokeData { get; }
    public MethodImplAttributes MethodImplAttributes { get; }
    public bool HasSpecialNameAttribute { get; public set; }
    public bool HasDynamicSecurityMethodAttribute { get; public set; }
    public bool HasSuppressUnmanagedCodeSecurityAttribute { get; public set; }
    internal bool HasDeclarativeSecurity { get; }
    public SecurityWellKnownAttributeData SecurityInformation { get; }
    public bool HasExcludeFromCodeCoverageAttribute { get; public set; }
    public CommonMethodWellKnownAttributeData(bool preserveSigFirstWriteWins);
    public void SetPreserveSignature(int attributeIndex);
    public void SetMethodImplementation(int attributeIndex, MethodImplAttributes attributes);
    public void SetDllImport(int attributeIndex, string moduleName, string entryPointName, MethodImportAttributes flags, bool preserveSig);
    public DllImportData get_DllImportPlatformInvokeData();
    public MethodImplAttributes get_MethodImplAttributes();
    public bool get_HasSpecialNameAttribute();
    public void set_HasSpecialNameAttribute(bool value);
    public bool get_HasDynamicSecurityMethodAttribute();
    public void set_HasDynamicSecurityMethodAttribute(bool value);
    public bool get_HasSuppressUnmanagedCodeSecurityAttribute();
    public void set_HasSuppressUnmanagedCodeSecurityAttribute(bool value);
    private sealed virtual override SecurityWellKnownAttributeData Microsoft.CodeAnalysis.ISecurityAttributeTarget.GetOrCreateData();
    internal bool get_HasDeclarativeSecurity();
    public SecurityWellKnownAttributeData get_SecurityInformation();
    public bool get_HasExcludeFromCodeCoverageAttribute();
    public void set_HasExcludeFromCodeCoverageAttribute(bool value);
}
internal class Microsoft.CodeAnalysis.CommonModuleCompilationState : object {
    private bool _frozen;
    internal bool Frozen { get; }
    internal void Freeze();
    internal bool get_Frozen();
}
internal class Microsoft.CodeAnalysis.CommonModuleWellKnownAttributeData : WellKnownAttributeData {
    private bool _hasDebuggableAttribute;
    private byte _defaultCharacterSet;
    public bool HasDebuggableAttribute { get; public set; }
    internal CharSet DefaultCharacterSet { get; internal set; }
    internal bool HasDefaultCharSetAttribute { get; }
    public bool get_HasDebuggableAttribute();
    public void set_HasDebuggableAttribute(bool value);
    internal CharSet get_DefaultCharacterSet();
    internal void set_DefaultCharacterSet(CharSet value);
    internal bool get_HasDefaultCharSetAttribute();
    internal static bool IsValidCharSet(CharSet value);
}
internal abstract class Microsoft.CodeAnalysis.CommonParameterEarlyWellKnownAttributeData : EarlyWellKnownAttributeData {
    private ConstantValue _defaultParameterValue;
    private bool _hasCallerLineNumberAttribute;
    private bool _hasCallerFilePathAttribute;
    private bool _hasCallerMemberNameAttribute;
    public ConstantValue DefaultParameterValue { get; public set; }
    public bool HasCallerLineNumberAttribute { get; public set; }
    public bool HasCallerFilePathAttribute { get; public set; }
    public bool HasCallerMemberNameAttribute { get; public set; }
    public ConstantValue get_DefaultParameterValue();
    public void set_DefaultParameterValue(ConstantValue value);
    public bool get_HasCallerLineNumberAttribute();
    public void set_HasCallerLineNumberAttribute(bool value);
    public bool get_HasCallerFilePathAttribute();
    public void set_HasCallerFilePathAttribute(bool value);
    public bool get_HasCallerMemberNameAttribute();
    public void set_HasCallerMemberNameAttribute(bool value);
}
internal class Microsoft.CodeAnalysis.CommonParameterWellKnownAttributeData : WellKnownAttributeData {
    private bool _hasOutAttribute;
    private bool _hasInAttribute;
    private MarshalPseudoCustomAttributeData _lazyMarshalAsData;
    private bool _hasIDispatchConstantAttribute;
    private bool _hasIUnknownConstantAttribute;
    public bool HasOutAttribute { get; public set; }
    public bool HasInAttribute { get; public set; }
    public MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    public bool HasIDispatchConstantAttribute { get; public set; }
    public bool HasIUnknownConstantAttribute { get; public set; }
    public bool get_HasOutAttribute();
    public void set_HasOutAttribute(bool value);
    public bool get_HasInAttribute();
    public void set_HasInAttribute(bool value);
    private sealed virtual override MarshalPseudoCustomAttributeData Microsoft.CodeAnalysis.IMarshalAsAttributeTarget.GetOrCreateData();
    public MarshalPseudoCustomAttributeData get_MarshallingInformation();
    public bool get_HasIDispatchConstantAttribute();
    public void set_HasIDispatchConstantAttribute(bool value);
    public bool get_HasIUnknownConstantAttribute();
    public void set_HasIUnknownConstantAttribute(bool value);
}
internal class Microsoft.CodeAnalysis.CommonPropertyEarlyWellKnownAttributeData : EarlyWellKnownAttributeData {
    private ObsoleteAttributeData _obsoleteAttributeData;
    public ObsoleteAttributeData ObsoleteAttributeData { get; public set; }
    public ObsoleteAttributeData get_ObsoleteAttributeData();
    public void set_ObsoleteAttributeData(ObsoleteAttributeData value);
}
internal class Microsoft.CodeAnalysis.CommonPropertyWellKnownAttributeData : WellKnownAttributeData {
    private bool _hasSpecialNameAttribute;
    private bool _hasExcludeFromCodeCoverageAttribute;
    public bool HasSpecialNameAttribute { get; public set; }
    public bool HasExcludeFromCodeCoverageAttribute { get; public set; }
    public bool get_HasSpecialNameAttribute();
    public void set_HasSpecialNameAttribute(bool value);
    public bool get_HasExcludeFromCodeCoverageAttribute();
    public void set_HasExcludeFromCodeCoverageAttribute(bool value);
}
internal abstract class Microsoft.CodeAnalysis.CommonReferenceManager : object {
    internal static object SymbolCacheAndReferenceManagerStateGuard;
    internal ImmutableArray`1<MetadataReference> ExplicitReferences { get; }
    internal ImmutableArray`1<MetadataReference> ImplicitReferences { get; }
    private static CommonReferenceManager();
    internal abstract virtual IEnumerable`1<KeyValuePair`2<MetadataReference, IAssemblySymbol>> GetReferencedAssemblies();
    internal abstract virtual IEnumerable`1<ValueTuple`2<IAssemblySymbol, ImmutableArray`1<string>>> GetReferencedAssemblyAliases();
    internal abstract virtual MetadataReference GetMetadataReference(IAssemblySymbol assemblySymbol);
    internal abstract virtual ImmutableArray`1<MetadataReference> get_ExplicitReferences();
    internal abstract virtual ImmutableArray`1<MetadataReference> get_ImplicitReferences();
    internal abstract virtual IEnumerable`1<KeyValuePair`2<AssemblyIdentity, PortableExecutableReference>> GetImplicitlyResolvedAssemblyReferences();
}
internal abstract class Microsoft.CodeAnalysis.CommonReferenceManager`2 : CommonReferenceManager {
    internal string SimpleAssemblyName;
    internal AssemblyIdentityComparer IdentityComparer;
    internal Dictionary`2<MetadataReference, object> ObservedMetadata;
    private int _isBound;
    private ThreeState _lazyHasCircularReference;
    private Dictionary`2<MetadataReference, int> _lazyReferencedAssembliesMap;
    private Dictionary`2<MetadataReference, int> _lazyReferencedModuleIndexMap;
    private IDictionary`2<ValueTuple`2<string, string>, MetadataReference> _lazyReferenceDirectiveMap;
    private ImmutableArray`1<MetadataReference> _lazyDirectiveReferences;
    private ImmutableArray`1<MetadataReference> _lazyExplicitReferences;
    private ImmutableArray`1<MetadataReference> _lazyImplicitReferences;
    private ImmutableArray`1<Diagnostic> _lazyDiagnostics;
    private TAssemblySymbol _lazyCorLibraryOpt;
    private ImmutableArray`1<PEModule> _lazyReferencedModules;
    private ImmutableArray`1<ModuleReferences`1<TAssemblySymbol>> _lazyReferencedModulesReferences;
    private ImmutableArray`1<TAssemblySymbol> _lazyReferencedAssemblies;
    private ImmutableArray`1<ImmutableArray`1<string>> _lazyAliasesOfReferencedAssemblies;
    private ImmutableArray`1<UnifiedAssembly`1<TAssemblySymbol>> _lazyUnifiedAssemblies;
    private static ImmutableArray`1<string> s_supersededAlias;
    protected CommonMessageProvider MessageProvider { get; }
    internal ImmutableArray`1<Diagnostic> Diagnostics { get; }
    internal bool HasCircularReference { get; }
    internal Dictionary`2<MetadataReference, int> ReferencedAssembliesMap { get; }
    internal Dictionary`2<MetadataReference, int> ReferencedModuleIndexMap { get; }
    internal IDictionary`2<ValueTuple`2<string, string>, MetadataReference> ReferenceDirectiveMap { get; }
    internal ImmutableArray`1<MetadataReference> DirectiveReferences { get; }
    internal ImmutableArray`1<MetadataReference> ImplicitReferences { get; }
    internal ImmutableArray`1<MetadataReference> ExplicitReferences { get; }
    internal TAssemblySymbol CorLibraryOpt { get; }
    internal ImmutableArray`1<PEModule> ReferencedModules { get; }
    internal ImmutableArray`1<ModuleReferences`1<TAssemblySymbol>> ReferencedModulesReferences { get; }
    internal ImmutableArray`1<TAssemblySymbol> ReferencedAssemblies { get; }
    internal ImmutableArray`1<ImmutableArray`1<string>> AliasesOfReferencedAssemblies { get; }
    internal ImmutableArray`1<UnifiedAssembly`1<TAssemblySymbol>> UnifiedAssemblies { get; }
    internal bool IsBound { get; }
    internal IEnumerable`1<string> ExternAliases { get; }
    public CommonReferenceManager`2(string simpleAssemblyName, AssemblyIdentityComparer identityComparer, Dictionary`2<MetadataReference, object> observedMetadata);
    private static CommonReferenceManager`2();
    protected BoundInputAssembly[] Bind(TCompilation compilation, ImmutableArray`1<AssemblyData<TCompilation, TAssemblySymbol>> explicitAssemblies, ImmutableArray`1<PEModule> explicitModules, ImmutableArray`1<MetadataReference> explicitReferences, ImmutableArray`1<ResolvedReference<TCompilation, TAssemblySymbol>> explicitReferenceMap, MetadataReferenceResolver resolverOpt, MetadataImportOptions importOptions, bool supersedeLowerVersions, Dictionary`2<string, List`1<ReferencedAssemblyIdentity<TCompilation, TAssemblySymbol>>> assemblyReferencesBySimpleName, ImmutableArray`1& allAssemblies, ImmutableArray`1& implicitlyResolvedReferences, ImmutableArray`1& implicitlyResolvedReferenceMap, DiagnosticBag resolutionDiagnostics, Boolean& hasCircularReference, Int32& corLibraryIndex);
    private void ResolveAndBindMissingAssemblies(TCompilation compilation, ImmutableArray`1<AssemblyData<TCompilation, TAssemblySymbol>> explicitAssemblies, ImmutableArray`1<PEModule> explicitModules, ImmutableArray`1<MetadataReference> explicitReferences, ImmutableArray`1<ResolvedReference<TCompilation, TAssemblySymbol>> explicitReferenceMap, MetadataReferenceResolver resolver, MetadataImportOptions importOptions, bool supersedeLowerVersions, ArrayBuilder`1<AssemblyReferenceBinding[]> referenceBindings, Dictionary`2<string, List`1<ReferencedAssemblyIdentity<TCompilation, TAssemblySymbol>>> assemblyReferencesBySimpleName, ImmutableArray`1& allAssemblies, ImmutableArray`1& metadataReferences, ImmutableArray`1& resolvedReferences, DiagnosticBag resolutionDiagnostics);
    private void GetInitialReferenceBindingsToProcess(ImmutableArray`1<PEModule> explicitModules, ImmutableArray`1<MetadataReference> explicitReferences, ImmutableArray`1<ResolvedReference<TCompilation, TAssemblySymbol>> explicitReferenceMap, ArrayBuilder`1<AssemblyReferenceBinding[]> referenceBindings, int totalReferencedAssemblyCount, ArrayBuilder`1<ValueTuple`2<MetadataReference, ArraySegment`1<AssemblyReferenceBinding<TCompilation, TAssemblySymbol>>>> result);
    private static ImmutableArray`1<int> CalculateModuleToReferenceMap(ImmutableArray`1<PEModule> modules, ImmutableArray`1<ResolvedReference<TCompilation, TAssemblySymbol>> resolvedReferences);
    private static ImmutableArray`1<ResolvedReference<TCompilation, TAssemblySymbol>> ToResolvedAssemblyReferences(ImmutableArray`1<MetadataReference> references, Dictionary`2<MetadataReference, MergedAliases> propertyMapOpt, int explicitAssemblyCount);
    private static void UpdateBindingsOfAssemblyBeingBuilt(ArrayBuilder`1<AssemblyReferenceBinding[]> referenceBindings, int explicitAssemblyCount, ArrayBuilder`1<AssemblyData<TCompilation, TAssemblySymbol>> implicitAssemblies);
    internal AssemblyData<TCompilation, TAssemblySymbol> ResolveMissingAssembly(AssemblyIdentity referenceIdentity, PortableExecutableReference peReference, MetadataImportOptions importOptions, DiagnosticBag diagnostics);
    private bool ReuseAssemblySymbolsWithNoPiaLocalTypes(BoundInputAssembly[] boundInputs, TAssemblySymbol[] candidateInputAssemblySymbols, ImmutableArray`1<AssemblyData<TCompilation, TAssemblySymbol>> assemblies, int corLibraryIndex);
    private void ReuseAssemblySymbols(BoundInputAssembly[] boundInputs, TAssemblySymbol[] candidateInputAssemblySymbols, ImmutableArray`1<AssemblyData<TCompilation, TAssemblySymbol>> assemblies, int corLibraryIndex);
    private static bool CheckCircularReference(IReadOnlyList`1<AssemblyReferenceBinding[]> referenceBindings);
    private static bool IsSuperseded(AssemblyIdentity identity, IReadOnlyDictionary`2<string, List`1<ReferencedAssemblyIdentity<TCompilation, TAssemblySymbol>>> assemblyReferencesBySimpleName);
    private static int IndexOfCorLibrary(ImmutableArray`1<AssemblyData<TCompilation, TAssemblySymbol>> assemblies, IReadOnlyDictionary`2<string, List`1<ReferencedAssemblyIdentity<TCompilation, TAssemblySymbol>>> assemblyReferencesBySimpleName, bool supersedeLowerVersions);
    internal static bool InternalsMayBeVisibleToAssemblyBeingCompiled(string compilationName, PEAssembly assembly);
    protected abstract virtual TAssemblySymbol[] GetActualBoundReferencesUsedBy(TAssemblySymbol assemblySymbol);
    protected abstract virtual ImmutableArray`1<TAssemblySymbol> GetNoPiaResolutionAssemblies(TAssemblySymbol candidateAssembly);
    protected abstract virtual bool IsLinked(TAssemblySymbol candidateAssembly);
    protected abstract virtual TAssemblySymbol GetCorLibrary(TAssemblySymbol candidateAssembly);
    protected abstract virtual CommonMessageProvider get_MessageProvider();
    protected abstract virtual AssemblyData<TCompilation, TAssemblySymbol> CreateAssemblyDataForFile(PEAssembly assembly, WeakList`1<IAssemblySymbol> cachedSymbols, DocumentationProvider documentationProvider, string sourceAssemblySimpleName, MetadataImportOptions importOptions, bool embedInteropTypes);
    protected abstract virtual AssemblyData<TCompilation, TAssemblySymbol> CreateAssemblyDataForCompilation(CompilationReference compilationReference);
    protected abstract virtual bool CheckPropertiesConsistency(MetadataReference primaryReference, MetadataReference duplicateReference, DiagnosticBag diagnostics);
    protected abstract virtual bool WeakIdentityPropertiesEquivalent(AssemblyIdentity identity1, AssemblyIdentity identity2);
    protected ImmutableArray`1<ResolvedReference<TCompilation, TAssemblySymbol>> ResolveMetadataReferences(TCompilation compilation, Dictionary`2<string, List`1<ReferencedAssemblyIdentity<TCompilation, TAssemblySymbol>>> assemblyReferencesBySimpleName, ImmutableArray`1& references, IDictionary`2& boundReferenceDirectiveMap, ImmutableArray`1& boundReferenceDirectives, ImmutableArray`1& assemblies, ImmutableArray`1& modules, DiagnosticBag diagnostics);
    private static ResolvedReference<TCompilation, TAssemblySymbol> GetResolvedReferenceAndFreePropertyMapEntry(MetadataReference reference, int index, MetadataImageKind kind, Dictionary`2<MetadataReference, MergedAliases> propertyMapOpt);
    private Metadata GetMetadata(PortableExecutableReference peReference, CommonMessageProvider messageProvider, Location location, DiagnosticBag diagnostics);
    private bool TryGetObservedMetadata(PortableExecutableReference peReference, DiagnosticBag diagnostics, Metadata& metadata);
    private void MergeReferenceProperties(MetadataReference primaryReference, MetadataReference newReference, DiagnosticBag diagnostics, Dictionary`2& lazyAliasMap);
    private static void AddAssembly(AssemblyData<TCompilation, TAssemblySymbol> data, int referenceIndex, ResolvedReference[] referenceMap, ArrayBuilder`1<AssemblyData<TCompilation, TAssemblySymbol>> assemblies);
    private static void AddModule(PEModule module, int referenceIndex, ResolvedReference[] referenceMap, ArrayBuilder`1& modules);
    private MetadataReference TryAddAssembly(AssemblyIdentity identity, MetadataReference reference, int assemblyIndex, DiagnosticBag diagnostics, Location location, Dictionary`2<string, List`1<ReferencedAssemblyIdentity<TCompilation, TAssemblySymbol>>> referencesBySimpleName, bool supersedeLowerVersions);
    protected void GetCompilationReferences(TCompilation compilation, DiagnosticBag diagnostics, ImmutableArray`1& references, IDictionary`2& boundReferenceDirectives, ImmutableArray`1& referenceDirectiveLocations);
    private static PortableExecutableReference ResolveReferenceDirective(string reference, Location location, TCompilation compilation);
    internal static AssemblyReferenceBinding[] ResolveReferencedAssemblies(ImmutableArray`1<AssemblyIdentity> references, ImmutableArray`1<AssemblyData<TCompilation, TAssemblySymbol>> definitions, int definitionStartIndex, AssemblyIdentityComparer assemblyIdentityComparer);
    internal static AssemblyReferenceBinding<TCompilation, TAssemblySymbol> ResolveReferencedAssembly(AssemblyIdentity reference, ImmutableArray`1<AssemblyData<TCompilation, TAssemblySymbol>> definitions, int definitionStartIndex, AssemblyIdentityComparer assemblyIdentityComparer);
    internal ImmutableArray`1<Diagnostic> get_Diagnostics();
    internal bool get_HasCircularReference();
    internal Dictionary`2<MetadataReference, int> get_ReferencedAssembliesMap();
    internal Dictionary`2<MetadataReference, int> get_ReferencedModuleIndexMap();
    internal IDictionary`2<ValueTuple`2<string, string>, MetadataReference> get_ReferenceDirectiveMap();
    internal ImmutableArray`1<MetadataReference> get_DirectiveReferences();
    internal virtual ImmutableArray`1<MetadataReference> get_ImplicitReferences();
    internal virtual ImmutableArray`1<MetadataReference> get_ExplicitReferences();
    internal TAssemblySymbol get_CorLibraryOpt();
    internal ImmutableArray`1<PEModule> get_ReferencedModules();
    internal ImmutableArray`1<ModuleReferences`1<TAssemblySymbol>> get_ReferencedModulesReferences();
    internal ImmutableArray`1<TAssemblySymbol> get_ReferencedAssemblies();
    internal ImmutableArray`1<ImmutableArray`1<string>> get_AliasesOfReferencedAssemblies();
    internal ImmutableArray`1<UnifiedAssembly`1<TAssemblySymbol>> get_UnifiedAssemblies();
    [ConditionalAttribute("DEBUG")]
internal void AssertUnbound();
    [ConditionalAttribute("DEBUG")]
internal void AssertBound();
    [ConditionalAttribute("DEBUG")]
internal void AssertCanReuseForCompilation(TCompilation compilation);
    internal bool get_IsBound();
    internal void InitializeNoLock(Dictionary`2<MetadataReference, int> referencedAssembliesMap, Dictionary`2<MetadataReference, int> referencedModulesMap, IDictionary`2<ValueTuple`2<string, string>, MetadataReference> boundReferenceDirectiveMap, ImmutableArray`1<MetadataReference> directiveReferences, ImmutableArray`1<MetadataReference> explicitReferences, ImmutableArray`1<MetadataReference> implicitReferences, bool containsCircularReferences, ImmutableArray`1<Diagnostic> diagnostics, TAssemblySymbol corLibraryOpt, ImmutableArray`1<PEModule> referencedModules, ImmutableArray`1<ModuleReferences`1<TAssemblySymbol>> referencedModulesReferences, ImmutableArray`1<TAssemblySymbol> referencedAssemblies, ImmutableArray`1<ImmutableArray`1<string>> aliasesOfReferencedAssemblies, ImmutableArray`1<UnifiedAssembly`1<TAssemblySymbol>> unifiedAssemblies);
    protected static void BuildReferencedAssembliesAndModulesMaps(BoundInputAssembly[] bindingResult, ImmutableArray`1<MetadataReference> references, ImmutableArray`1<ResolvedReference<TCompilation, TAssemblySymbol>> referenceMap, int referencedModuleCount, int explicitlyReferencedAssemblyCount, IReadOnlyDictionary`2<string, List`1<ReferencedAssemblyIdentity<TCompilation, TAssemblySymbol>>> assemblyReferencesBySimpleName, bool supersedeLowerVersions, Dictionary`2& referencedAssembliesMap, Dictionary`2& referencedModulesMap, ImmutableArray`1& aliasesOfReferencedAssemblies);
    internal static ImmutableDictionary`2<AssemblyIdentity, AssemblyIdentity> GetAssemblyReferenceIdentityBaselineMap(ImmutableArray`1<TAssemblySymbol> symbols, ImmutableArray`1<AssemblyIdentity> originalIdentities);
    internal static bool CompareVersionPartsSpecifiedInSource(Version version, Version candidateVersion, TAssemblySymbol candidateSymbol);
    private static void PropagateRecursiveAliases(BoundInputAssembly[] bindingResult, ImmutableArray`1<ResolvedReference<TCompilation, TAssemblySymbol>> referenceMap, ArrayBuilder`1<ImmutableArray`1<string>> aliasesOfReferencedAssembliesBuilder);
    internal IEnumerable`1<string> get_ExternAliases();
    internal sealed virtual IEnumerable`1<KeyValuePair`2<MetadataReference, IAssemblySymbol>> GetReferencedAssemblies();
    internal TAssemblySymbol GetReferencedAssemblySymbol(MetadataReference reference);
    internal int GetReferencedModuleIndex(MetadataReference reference);
    internal virtual MetadataReference GetMetadataReference(IAssemblySymbol assemblySymbol);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CommonReferenceManager`2/<GetReferencedAssemblyAliases>d__107")]
internal virtual IEnumerable`1<ValueTuple`2<IAssemblySymbol, ImmutableArray`1<string>>> GetReferencedAssemblyAliases();
    public bool DeclarationsAccessibleWithoutAlias(int referencedAssemblyIndex);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.CommonReferenceManager`2/<GetImplicitlyResolvedAssemblyReferences>d__109")]
internal virtual IEnumerable`1<KeyValuePair`2<AssemblyIdentity, PortableExecutableReference>> GetImplicitlyResolvedAssemblyReferences();
    [CompilerGeneratedAttribute]
private KeyValuePair`2<MetadataReference, IAssemblySymbol> <GetReferencedAssemblies>b__103_0(KeyValuePair`2<MetadataReference, int> ra);
}
internal class Microsoft.CodeAnalysis.CommonReturnTypeWellKnownAttributeData : WellKnownAttributeData {
    private MarshalPseudoCustomAttributeData _lazyMarshalAsData;
    public MarshalPseudoCustomAttributeData MarshallingInformation { get; }
    private sealed virtual override MarshalPseudoCustomAttributeData Microsoft.CodeAnalysis.IMarshalAsAttributeTarget.GetOrCreateData();
    public MarshalPseudoCustomAttributeData get_MarshallingInformation();
}
internal abstract class Microsoft.CodeAnalysis.CommonSyntaxAndDeclarationManager : object {
    internal ImmutableArray`1<SyntaxTree> ExternalSyntaxTrees;
    internal string ScriptClassName;
    internal SourceReferenceResolver Resolver;
    internal CommonMessageProvider MessageProvider;
    internal bool IsSubmission;
    public CommonSyntaxAndDeclarationManager(ImmutableArray`1<SyntaxTree> externalSyntaxTrees, string scriptClassName, SourceReferenceResolver resolver, CommonMessageProvider messageProvider, bool isSubmission);
}
internal class Microsoft.CodeAnalysis.CommonTypeEarlyWellKnownAttributeData : EarlyWellKnownAttributeData {
    private AttributeUsageInfo _attributeUsageInfo;
    private bool _hasComImportAttribute;
    private ImmutableArray`1<string> _lazyConditionalSymbols;
    private ObsoleteAttributeData _obsoleteAttributeData;
    private bool _hasCodeAnalysisEmbeddedAttribute;
    public AttributeUsageInfo AttributeUsageInfo { get; public set; }
    public bool HasComImportAttribute { get; public set; }
    public ImmutableArray`1<string> ConditionalSymbols { get; }
    public ObsoleteAttributeData ObsoleteAttributeData { get; public set; }
    public bool HasCodeAnalysisEmbeddedAttribute { get; public set; }
    public AttributeUsageInfo get_AttributeUsageInfo();
    public void set_AttributeUsageInfo(AttributeUsageInfo value);
    public bool get_HasComImportAttribute();
    public void set_HasComImportAttribute(bool value);
    public void AddConditionalSymbol(string name);
    public ImmutableArray`1<string> get_ConditionalSymbols();
    public ObsoleteAttributeData get_ObsoleteAttributeData();
    public void set_ObsoleteAttributeData(ObsoleteAttributeData value);
    public bool get_HasCodeAnalysisEmbeddedAttribute();
    public void set_HasCodeAnalysisEmbeddedAttribute(bool value);
}
internal class Microsoft.CodeAnalysis.CommonTypeWellKnownAttributeData : WellKnownAttributeData {
    private bool _hasSpecialNameAttribute;
    private bool _hasSerializableAttribute;
    private bool _hasDefaultMemberAttribute;
    private bool _hasSuppressUnmanagedCodeSecurityAttribute;
    private SecurityWellKnownAttributeData _lazySecurityAttributeData;
    private bool _hasWindowsRuntimeImportAttribute;
    private string _guidString;
    private TypeLayout _layout;
    private CharSet _charSet;
    private bool _hasSecurityCriticalAttributes;
    private bool _hasExcludeFromCodeCoverageAttribute;
    public bool HasSpecialNameAttribute { get; public set; }
    public bool HasSerializableAttribute { get; public set; }
    public bool HasDefaultMemberAttribute { get; public set; }
    public bool HasSuppressUnmanagedCodeSecurityAttribute { get; public set; }
    internal bool HasDeclarativeSecurity { get; }
    public SecurityWellKnownAttributeData SecurityInformation { get; }
    public bool HasWindowsRuntimeImportAttribute { get; public set; }
    public string GuidString { get; public set; }
    public bool HasStructLayoutAttribute { get; }
    public TypeLayout Layout { get; }
    public CharSet MarshallingCharSet { get; }
    public bool HasSecurityCriticalAttributes { get; public set; }
    public bool HasExcludeFromCodeCoverageAttribute { get; public set; }
    public bool get_HasSpecialNameAttribute();
    public void set_HasSpecialNameAttribute(bool value);
    public bool get_HasSerializableAttribute();
    public void set_HasSerializableAttribute(bool value);
    public bool get_HasDefaultMemberAttribute();
    public void set_HasDefaultMemberAttribute(bool value);
    public bool get_HasSuppressUnmanagedCodeSecurityAttribute();
    public void set_HasSuppressUnmanagedCodeSecurityAttribute(bool value);
    private sealed virtual override SecurityWellKnownAttributeData Microsoft.CodeAnalysis.ISecurityAttributeTarget.GetOrCreateData();
    internal bool get_HasDeclarativeSecurity();
    public SecurityWellKnownAttributeData get_SecurityInformation();
    public bool get_HasWindowsRuntimeImportAttribute();
    public void set_HasWindowsRuntimeImportAttribute(bool value);
    public string get_GuidString();
    public void set_GuidString(string value);
    public void SetStructLayout(TypeLayout layout, CharSet charSet);
    public bool get_HasStructLayoutAttribute();
    public TypeLayout get_Layout();
    public CharSet get_MarshallingCharSet();
    public bool get_HasSecurityCriticalAttributes();
    public void set_HasSecurityCriticalAttributes(bool value);
    public bool get_HasExcludeFromCodeCoverageAttribute();
    public void set_HasExcludeFromCodeCoverageAttribute(bool value);
}
public abstract class Microsoft.CodeAnalysis.Compilation : object {
    private SmallDictionary`2<int, bool> _lazyMakeWellKnownTypeMissingMap;
    private SmallDictionary`2<int, bool> _lazyMakeMemberMissingMap;
    private IReadOnlyDictionary`2<string, string> _features;
    internal static string UnspecifiedModuleAssemblyName;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    private int _lazySubmissionSlotIndex;
    private static int SubmissionSlotIndexNotApplicable;
    private static int SubmissionSlotIndexToBeAllocated;
    internal AsyncQueue`1<CompilationEvent> EventQueue;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<MetadataReference> <ExternalReferences>k__BackingField;
    internal static CompilationStage DefaultDiagnosticsStage;
    private ConcurrentDictionary`2<SyntaxTree, SmallConcurrentSetOfInts> _lazyTreeToUsedImportDirectivesMap;
    private static Func`2<SyntaxTree, SmallConcurrentSetOfInts> s_createSetCallback;
    private WeakList`1<IAssemblySymbol> _retargetingAssemblySymbols;
    public bool IsCaseSensitive { get; }
    public ScriptCompilationInfo ScriptCompilationInfo { get; }
    internal ScriptCompilationInfo CommonScriptCompilationInfo { get; }
    public string Language { get; }
    public string AssemblyName { get; }
    public CompilationOptions Options { get; }
    protected CompilationOptions CommonOptions { get; }
    internal bool IsSubmission { get; }
    internal Type SubmissionReturnType { get; }
    internal Type HostObjectType { get; }
    public IEnumerable`1<SyntaxTree> SyntaxTrees { get; }
    protected IEnumerable`1<SyntaxTree> CommonSyntaxTrees { get; }
    public ImmutableArray`1<MetadataReference> ExternalReferences { get; }
    public ImmutableArray`1<MetadataReference> DirectiveReferences { get; }
    internal IEnumerable`1<ReferenceDirective> ReferenceDirectives { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IDictionary`2<ValueTuple`2<string, string>, MetadataReference> ReferenceDirectiveMap { get; }
    public IEnumerable`1<MetadataReference> References { get; }
    public IEnumerable`1<AssemblyIdentity> ReferencedAssemblyNames { get; }
    public IAssemblySymbol Assembly { get; }
    protected IAssemblySymbol CommonAssembly { get; }
    public IModuleSymbol SourceModule { get; }
    protected IModuleSymbol CommonSourceModule { get; }
    public INamespaceSymbol GlobalNamespace { get; }
    protected INamespaceSymbol CommonGlobalNamespace { get; }
    internal CommonAnonymousTypeManager CommonAnonymousTypeManager { get; }
    public INamedTypeSymbol ObjectType { get; }
    protected INamedTypeSymbol CommonObjectType { get; }
    public ITypeSymbol DynamicType { get; }
    protected ITypeSymbol CommonDynamicType { get; }
    public INamedTypeSymbol ScriptClass { get; }
    protected INamedTypeSymbol CommonScriptClass { get; }
    internal CommonMessageProvider MessageProvider { get; }
    internal byte LinkerMajorVersion { get; }
    internal bool HasStrongName { get; }
    internal bool IsRealSigned { get; }
    internal bool IsDelaySigned { get; }
    internal StrongNameKeys StrongNameKeys { get; }
    internal Guid DebugSourceDocumentLanguageId { get; }
    internal bool IsEmitDeterministic { get; }
    private ConcurrentDictionary`2<SyntaxTree, SmallConcurrentSetOfInts> TreeToUsedImportDirectivesMap { get; }
    internal WeakList`1<IAssemblySymbol> RetargetingAssemblySymbols { get; }
    internal Compilation(string name, ImmutableArray`1<MetadataReference> references, IReadOnlyDictionary`2<string, string> features, bool isSubmission, AsyncQueue`1<CompilationEvent> eventQueue);
    private static Compilation();
    public abstract virtual bool get_IsCaseSensitive();
    public ScriptCompilationInfo get_ScriptCompilationInfo();
    internal abstract virtual ScriptCompilationInfo get_CommonScriptCompilationInfo();
    protected static IReadOnlyDictionary`2<string, string> SyntaxTreeCommonFeatures(IEnumerable`1<SyntaxTree> trees);
    internal abstract virtual AnalyzerDriver AnalyzerForLanguage(ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerManager analyzerManager);
    public abstract virtual string get_Language();
    internal static void ValidateScriptCompilationParameters(Compilation previousScriptCompilation, Type returnType, Type& globalsType);
    internal static void CheckSubmissionOptions(CompilationOptions options);
    public Compilation Clone();
    protected abstract virtual Compilation CommonClone();
    internal abstract virtual Compilation WithEventQueue(AsyncQueue`1<CompilationEvent> eventQueue);
    public SemanticModel GetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility);
    protected abstract virtual SemanticModel CommonGetSemanticModel(SyntaxTree syntaxTree, bool ignoreAccessibility);
    public INamedTypeSymbol CreateErrorTypeSymbol(INamespaceOrTypeSymbol container, string name, int arity);
    protected abstract virtual INamedTypeSymbol CommonCreateErrorTypeSymbol(INamespaceOrTypeSymbol container, string name, int arity);
    public INamespaceSymbol CreateErrorNamespaceSymbol(INamespaceSymbol container, string name);
    protected abstract virtual INamespaceSymbol CommonCreateErrorNamespaceSymbol(INamespaceSymbol container, string name);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    internal void CheckAssemblyName(DiagnosticBag diagnostics);
    internal string MakeSourceAssemblySimpleName();
    internal string MakeSourceModuleName();
    public Compilation WithAssemblyName(string assemblyName);
    protected abstract virtual Compilation CommonWithAssemblyName(string outputName);
    public CompilationOptions get_Options();
    protected abstract virtual CompilationOptions get_CommonOptions();
    public Compilation WithOptions(CompilationOptions options);
    protected abstract virtual Compilation CommonWithOptions(CompilationOptions options);
    internal bool get_IsSubmission();
    internal int GetSubmissionSlotIndex();
    internal Type get_SubmissionReturnType();
    internal static bool IsValidSubmissionReturnType(Type type);
    internal Type get_HostObjectType();
    internal static bool IsValidHostObjectType(Type type);
    internal abstract virtual bool HasSubmissionResult();
    public Compilation WithScriptCompilationInfo(ScriptCompilationInfo info);
    protected abstract virtual Compilation CommonWithScriptCompilationInfo(ScriptCompilationInfo info);
    public IEnumerable`1<SyntaxTree> get_SyntaxTrees();
    protected abstract virtual IEnumerable`1<SyntaxTree> get_CommonSyntaxTrees();
    public Compilation AddSyntaxTrees(SyntaxTree[] trees);
    public Compilation AddSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    protected abstract virtual Compilation CommonAddSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    public Compilation RemoveSyntaxTrees(SyntaxTree[] trees);
    public Compilation RemoveSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    protected abstract virtual Compilation CommonRemoveSyntaxTrees(IEnumerable`1<SyntaxTree> trees);
    public Compilation RemoveAllSyntaxTrees();
    protected abstract virtual Compilation CommonRemoveAllSyntaxTrees();
    public Compilation ReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree);
    protected abstract virtual Compilation CommonReplaceSyntaxTree(SyntaxTree oldTree, SyntaxTree newTree);
    public bool ContainsSyntaxTree(SyntaxTree syntaxTree);
    protected abstract virtual bool CommonContainsSyntaxTree(SyntaxTree syntaxTree);
    internal static ImmutableArray`1<MetadataReference> ValidateReferences(IEnumerable`1<MetadataReference> references);
    internal CommonReferenceManager GetBoundReferenceManager();
    internal abstract virtual CommonReferenceManager CommonGetBoundReferenceManager();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<MetadataReference> get_ExternalReferences();
    public abstract virtual ImmutableArray`1<MetadataReference> get_DirectiveReferences();
    internal abstract virtual IEnumerable`1<ReferenceDirective> get_ReferenceDirectives();
    internal abstract virtual IDictionary`2<ValueTuple`2<string, string>, MetadataReference> get_ReferenceDirectiveMap();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Compilation/<get_References>d__87")]
public IEnumerable`1<MetadataReference> get_References();
    public abstract virtual CompilationReference ToMetadataReference(ImmutableArray`1<string> aliases, bool embedInteropTypes);
    public Compilation WithReferences(IEnumerable`1<MetadataReference> newReferences);
    public Compilation WithReferences(MetadataReference[] newReferences);
    protected abstract virtual Compilation CommonWithReferences(IEnumerable`1<MetadataReference> newReferences);
    public Compilation AddReferences(MetadataReference[] references);
    public Compilation AddReferences(IEnumerable`1<MetadataReference> references);
    public Compilation RemoveReferences(MetadataReference[] references);
    public Compilation RemoveReferences(IEnumerable`1<MetadataReference> references);
    public Compilation RemoveAllReferences();
    public Compilation ReplaceReference(MetadataReference oldReference, MetadataReference newReference);
    public ISymbol GetAssemblyOrModuleSymbol(MetadataReference reference);
    protected abstract virtual ISymbol CommonGetAssemblyOrModuleSymbol(MetadataReference reference);
    public MetadataReference GetMetadataReference(IAssemblySymbol assemblySymbol);
    public abstract virtual IEnumerable`1<AssemblyIdentity> get_ReferencedAssemblyNames();
    public IAssemblySymbol get_Assembly();
    protected abstract virtual IAssemblySymbol get_CommonAssembly();
    public IModuleSymbol get_SourceModule();
    protected abstract virtual IModuleSymbol get_CommonSourceModule();
    public INamespaceSymbol get_GlobalNamespace();
    protected abstract virtual INamespaceSymbol get_CommonGlobalNamespace();
    public INamespaceSymbol GetCompilationNamespace(INamespaceSymbol namespaceSymbol);
    protected abstract virtual INamespaceSymbol CommonGetCompilationNamespace(INamespaceSymbol namespaceSymbol);
    internal abstract virtual CommonAnonymousTypeManager get_CommonAnonymousTypeManager();
    public IMethodSymbol GetEntryPoint(CancellationToken cancellationToken);
    protected abstract virtual IMethodSymbol CommonGetEntryPoint(CancellationToken cancellationToken);
    public INamedTypeSymbol GetSpecialType(SpecialType specialType);
    internal abstract virtual ISymbol CommonGetSpecialTypeMember(SpecialMember specialMember);
    internal abstract virtual bool IsSystemTypeReference(ITypeSymbol type);
    protected abstract virtual INamedTypeSymbol CommonGetSpecialType(SpecialType specialType);
    internal abstract virtual ISymbol CommonGetWellKnownTypeMember(WellKnownMember member);
    internal abstract virtual bool IsAttributeType(ITypeSymbol type);
    public INamedTypeSymbol get_ObjectType();
    protected abstract virtual INamedTypeSymbol get_CommonObjectType();
    public ITypeSymbol get_DynamicType();
    protected abstract virtual ITypeSymbol get_CommonDynamicType();
    public INamedTypeSymbol get_ScriptClass();
    protected abstract virtual INamedTypeSymbol get_CommonScriptClass();
    protected INamedTypeSymbol CommonBindScriptClass();
    [ConditionalAttribute("DEBUG")]
private void AssertNoScriptTrees();
    public IArrayTypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    protected abstract virtual IArrayTypeSymbol CommonCreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    public IPointerTypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType);
    protected abstract virtual IPointerTypeSymbol CommonCreatePointerTypeSymbol(ITypeSymbol elementType);
    public INamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName);
    protected abstract virtual INamedTypeSymbol CommonGetTypeByMetadataName(string metadataName);
    public INamedTypeSymbol CreateTupleTypeSymbol(ImmutableArray`1<ITypeSymbol> elementTypes, ImmutableArray`1<string> elementNames, ImmutableArray`1<Location> elementLocations);
    protected static ImmutableArray`1<string> CheckTupleElementNames(int cardinality, ImmutableArray`1<string> elementNames);
    protected static void CheckTupleElementLocations(int cardinality, ImmutableArray`1<Location> elementLocations);
    protected abstract virtual INamedTypeSymbol CommonCreateTupleTypeSymbol(ImmutableArray`1<ITypeSymbol> elementTypes, ImmutableArray`1<string> elementNames, ImmutableArray`1<Location> elementLocations);
    public INamedTypeSymbol CreateTupleTypeSymbol(INamedTypeSymbol underlyingType, ImmutableArray`1<string> elementNames, ImmutableArray`1<Location> elementLocations);
    protected abstract virtual INamedTypeSymbol CommonCreateTupleTypeSymbol(INamedTypeSymbol underlyingType, ImmutableArray`1<string> elementNames, ImmutableArray`1<Location> elementLocations);
    public INamedTypeSymbol CreateAnonymousTypeSymbol(ImmutableArray`1<ITypeSymbol> memberTypes, ImmutableArray`1<string> memberNames, ImmutableArray`1<bool> memberIsReadOnly, ImmutableArray`1<Location> memberLocations);
    protected abstract virtual INamedTypeSymbol CommonCreateAnonymousTypeSymbol(ImmutableArray`1<ITypeSymbol> memberTypes, ImmutableArray`1<string> memberNames, ImmutableArray`1<Location> memberLocations, ImmutableArray`1<bool> memberIsReadOnly);
    public abstract virtual CommonConversion ClassifyCommonConversion(ITypeSymbol source, ITypeSymbol destination);
    public bool HasImplicitConversion(ITypeSymbol fromType, ITypeSymbol toType);
    internal abstract virtual IConvertibleConversion ClassifyConvertibleConversion(IOperation source, ITypeSymbol destination, Optional`1& constantValue);
    public abstract virtual ImmutableArray`1<Diagnostic> GetParseDiagnostics(CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<Diagnostic> GetDeclarationDiagnostics(CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<Diagnostic> GetMethodBodyDiagnostics(CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<Diagnostic> GetDiagnostics(CancellationToken cancellationToken);
    internal abstract virtual void GetDiagnostics(CompilationStage stage, bool includeEarlierStages, DiagnosticBag diagnostics, CancellationToken cancellationToken);
    internal void EnsureCompilationEventQueueCompleted();
    internal void CompleteCompilationEventQueue_NoLock();
    internal abstract virtual CommonMessageProvider get_MessageProvider();
    internal bool FilterAndAppendAndFreeDiagnostics(DiagnosticBag accumulator, DiagnosticBag& incoming);
    internal bool FilterAndAppendDiagnostics(DiagnosticBag accumulator, IEnumerable`1<Diagnostic> incoming, HashSet`1<int> exclude);
    public Stream CreateDefaultWin32Resources(bool versionResource, bool noManifest, Stream manifestContents, Stream iconInIcoFormat);
    internal static void AppendNullResource(Stream resourceStream);
    protected abstract virtual void AppendDefaultVersionResource(Stream resourceStream);
    internal static Win32ResourceForm DetectWin32ResourceForm(Stream win32Resources);
    internal ResourceSection MakeWin32ResourcesFromCOFF(Stream win32Resources, DiagnosticBag diagnostics);
    internal List`1<Win32Resource> MakeWin32ResourceList(Stream win32Resources, DiagnosticBag diagnostics);
    internal void SetupWin32Resources(CommonPEModuleBuilder moduleBeingBuilt, Stream win32Resources, DiagnosticBag diagnostics);
    internal void ReportManifestResourceDuplicates(IEnumerable`1<ResourceDescription> manifestResources, IEnumerable`1<string> addedModuleNames, IEnumerable`1<string> addedModuleResourceNames, DiagnosticBag diagnostics);
    internal ModulePropertiesForSerialization ConstructModuleSerializationProperties(EmitOptions emitOptions, string targetRuntimeVersion, Guid moduleVersionId);
    private static CorFlags GetCorHeaderFlags(Machine machine, bool strongNameSigned, bool prefers32Bit);
    internal static DllCharacteristics GetDllCharacteristics(bool enableHighEntropyVA, bool configureToExecuteInAppContainer);
    private static Characteristics GetCharacteristics(OutputKind outputKind, bool requires32Bit);
    private static Subsystem GetSubsystem(OutputKind outputKind);
    internal abstract virtual byte get_LinkerMajorVersion();
    internal bool get_HasStrongName();
    internal bool get_IsRealSigned();
    internal abstract virtual bool HasCodeToEmit();
    internal abstract virtual bool get_IsDelaySigned();
    internal abstract virtual StrongNameKeys get_StrongNameKeys();
    internal abstract virtual CommonPEModuleBuilder CreateModuleBuilder(EmitOptions emitOptions, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1<EmbeddedText> embeddedTexts, IEnumerable`1<ResourceDescription> manifestResources, CompilationTestData testData, DiagnosticBag diagnostics, CancellationToken cancellationToken);
    internal abstract virtual bool CompileMethods(CommonPEModuleBuilder moduleBuilder, bool emittingPdb, bool emitMetadataOnly, bool emitTestCoverageData, DiagnosticBag diagnostics, Predicate`1<ISymbol> filterOpt, CancellationToken cancellationToken);
    internal bool CreateDebugDocuments(DebugDocumentsBuilder documentsBuilder, IEnumerable`1<EmbeddedText> embeddedTexts, DiagnosticBag diagnostics);
    internal abstract virtual Guid get_DebugSourceDocumentLanguageId();
    internal abstract virtual void AddDebugSourceDocumentsForChecksumDirectives(DebugDocumentsBuilder documentsBuilder, SyntaxTree tree, DiagnosticBag diagnostics);
    internal abstract virtual bool GenerateResourcesAndDocumentationComments(CommonPEModuleBuilder moduleBeingBuilt, Stream xmlDocumentationStream, Stream win32ResourcesStream, string outputNameOverride, DiagnosticBag diagnostics, CancellationToken cancellationToken);
    internal abstract virtual void ReportUnusedImports(SyntaxTree filterTree, DiagnosticBag diagnostics, CancellationToken cancellationToken);
    internal abstract virtual void CompleteTrees(SyntaxTree filterTree);
    internal bool Compile(CommonPEModuleBuilder moduleBuilder, bool emittingPdb, DiagnosticBag diagnostics, Predicate`1<ISymbol> filterOpt, CancellationToken cancellationToken);
    internal void EnsureAnonymousTypeTemplates(CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public EmitResult Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1<ResourceDescription> manifestResources, EmitOptions options, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public EmitResult Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1<ResourceDescription> manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, CancellationToken cancellationToken);
    public EmitResult Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1<ResourceDescription> manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1<EmbeddedText> embeddedTexts, CancellationToken cancellationToken);
    public EmitResult Emit(Stream peStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1<ResourceDescription> manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1<EmbeddedText> embeddedTexts, Stream metadataPEStream, CancellationToken cancellationToken);
    internal EmitResult Emit(Stream peStream, Stream metadataPEStream, Stream pdbStream, Stream xmlDocumentationStream, Stream win32Resources, IEnumerable`1<ResourceDescription> manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1<EmbeddedText> embeddedTexts, CompilationTestData testData, CancellationToken cancellationToken);
    public EmitDifferenceResult EmitDifference(EmitBaseline baseline, IEnumerable`1<SemanticEdit> edits, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection`1<MethodDefinitionHandle> updatedMethods, CancellationToken cancellationToken);
    public EmitDifferenceResult EmitDifference(EmitBaseline baseline, IEnumerable`1<SemanticEdit> edits, Func`2<ISymbol, bool> isAddedSymbol, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection`1<MethodDefinitionHandle> updatedMethods, CancellationToken cancellationToken);
    internal abstract virtual EmitDifferenceResult EmitDifference(EmitBaseline baseline, IEnumerable`1<SemanticEdit> edits, Func`2<ISymbol, bool> isAddedSymbol, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection`1<MethodDefinitionHandle> updatedMethodHandles, CompilationTestData testData, CancellationToken cancellationToken);
    internal CommonPEModuleBuilder CheckOptionsAndCreateModuleBuilder(DiagnosticBag diagnostics, IEnumerable`1<ResourceDescription> manifestResources, EmitOptions options, IMethodSymbol debugEntryPoint, Stream sourceLinkStream, IEnumerable`1<EmbeddedText> embeddedTexts, CompilationTestData testData, CancellationToken cancellationToken);
    internal abstract virtual void ValidateDebugEntryPoint(IMethodSymbol debugEntryPoint, DiagnosticBag diagnostics);
    internal bool get_IsEmitDeterministic();
    internal bool SerializeToPeStream(CommonPEModuleBuilder moduleBeingBuilt, EmitStreamProvider peStreamProvider, EmitStreamProvider metadataPEStreamProvider, EmitStreamProvider pdbStreamProvider, Func`2<ISymWriterMetadataProvider, SymUnmanagedWriter> testSymWriterFactory, DiagnosticBag diagnostics, bool metadataOnly, bool includePrivateMembers, bool emitTestCoverageData, string pePdbFilePath, Nullable`1<RSAParameters> privateKeyOpt, CancellationToken cancellationToken);
    private static Stream ConditionalGetOrCreateStream(EmitStreamProvider metadataPEStreamProvider, DiagnosticBag metadataDiagnostics);
    private ValueTuple`3<Stream, Stream, Stream> GetPeStream(DiagnosticBag metadataDiagnostics, EmitStreamProvider peStreamProvider, bool metadataOnly);
    internal static bool SerializePeToStream(CommonPEModuleBuilder moduleBeingBuilt, DiagnosticBag metadataDiagnostics, CommonMessageProvider messageProvider, Func`1<Stream> getPeStream, Func`1<Stream> getMetadataPeStreamOpt, Func`1<Stream> getPortablePdbStreamOpt, PdbWriter nativePdbWriterOpt, string pdbPathOpt, bool metadataOnly, bool includePrivateMembers, bool isDeterministic, bool emitTestCoverageData, Nullable`1<RSAParameters> privateKeyOpt, CancellationToken cancellationToken);
    internal EmitBaseline SerializeToDeltaStreams(CommonPEModuleBuilder moduleBeingBuilt, EmitBaseline baseline, DefinitionMap definitionMap, SymbolChanges changes, Stream metadataStream, Stream ilStream, Stream pdbStream, ICollection`1<MethodDefinitionHandle> updatedMethods, DiagnosticBag diagnostics, Func`2<ISymWriterMetadataProvider, SymUnmanagedWriter> testSymWriterFactory, string pdbFilePath, CancellationToken cancellationToken);
    internal string Feature(string p);
    private ConcurrentDictionary`2<SyntaxTree, SmallConcurrentSetOfInts> get_TreeToUsedImportDirectivesMap();
    internal void MarkImportDirectiveAsUsed(SyntaxNode node);
    internal void MarkImportDirectiveAsUsed(SyntaxTree syntaxTree, int position);
    internal bool IsImportDirectiveUsed(SyntaxTree syntaxTree, int position);
    internal int CompareSyntaxTreeOrdering(SyntaxTree tree1, SyntaxTree tree2);
    internal abstract virtual int GetSyntaxTreeOrdinal(SyntaxTree tree);
    internal abstract virtual int CompareSourceLocations(Location loc1, Location loc2);
    internal abstract virtual int CompareSourceLocations(SyntaxReference loc1, SyntaxReference loc2);
    internal TLocation FirstSourceLocation(TLocation first, TLocation second);
    internal TLocation FirstSourceLocation(ImmutableArray`1<TLocation> locations);
    internal string GetMessage(CompilationStage stage);
    internal string GetMessage(ITypeSymbol source, ITypeSymbol destination);
    public abstract virtual bool ContainsSymbolsWithName(Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<ISymbol> GetSymbolsWithName(Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    public abstract virtual bool ContainsSymbolsWithName(string name, SymbolFilter filter, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<ISymbol> GetSymbolsWithName(string name, SymbolFilter filter, CancellationToken cancellationToken);
    internal void MakeMemberMissing(WellKnownMember member);
    internal void MakeMemberMissing(SpecialMember member);
    internal bool IsMemberMissing(WellKnownMember member);
    internal bool IsMemberMissing(SpecialMember member);
    private void MakeMemberMissing(int member);
    private bool IsMemberMissing(int member);
    internal void MakeTypeMissing(WellKnownType type);
    internal bool IsTypeMissing(WellKnownType type);
    public ImmutableArray`1<AssemblyIdentity> GetUnreferencedAssemblyIdentities(Diagnostic diagnostic);
    internal abstract virtual bool IsUnreferencedAssemblyIdentityDiagnosticCode(int code);
    public static string GetRequiredLanguageVersion(Diagnostic diagnostic);
    internal void CacheRetargetingAssemblySymbolNoLock(IAssemblySymbol assembly);
    internal void AddRetargetingAssemblySymbolsNoLock(List`1<T> result);
    internal WeakList`1<IAssemblySymbol> get_RetargetingAssemblySymbols();
}
public abstract class Microsoft.CodeAnalysis.CompilationOptions : object {
    [CompilerGeneratedAttribute]
private OutputKind <OutputKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScriptClassName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MainTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<byte> <CryptoPublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CryptoKeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CryptoKeyContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DelaySign>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PublicSign>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckOverflow>k__BackingField;
    [CompilerGeneratedAttribute]
private Platform <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private OptimizationLevel <OptimizationLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private ReportDiagnostic <GeneralDiagnosticOption>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WarningLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConcurrentBuild>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Deterministic>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <CurrentLocalTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DebugPlusMode>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataImportOptions <MetadataImportOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReferencesSupersedeLowerVersions>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, ReportDiagnostic> <SpecificDiagnosticOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportSuppressedDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataReferenceResolver <MetadataReferenceResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlReferenceResolver <XmlReferenceResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceReferenceResolver <SourceReferenceResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private StrongNameProvider <StrongNameProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyIdentityComparer <AssemblyIdentityComparer>k__BackingField;
    private Lazy`1<ImmutableArray`1<Diagnostic>> _lazyErrors;
    public OutputKind OutputKind { get; protected set; }
    public string ModuleName { get; protected set; }
    public string ScriptClassName { get; protected set; }
    public string MainTypeName { get; protected set; }
    public ImmutableArray`1<byte> CryptoPublicKey { get; protected set; }
    public string CryptoKeyFile { get; protected set; }
    public string CryptoKeyContainer { get; protected set; }
    public Nullable`1<bool> DelaySign { get; protected set; }
    public bool PublicSign { get; protected set; }
    public bool CheckOverflow { get; protected set; }
    public Platform Platform { get; protected set; }
    public OptimizationLevel OptimizationLevel { get; protected set; }
    public ReportDiagnostic GeneralDiagnosticOption { get; protected set; }
    public int WarningLevel { get; protected set; }
    public bool ConcurrentBuild { get; protected set; }
    public bool Deterministic { get; protected set; }
    internal DateTime CurrentLocalTime { get; private set; }
    unknown DateTime CurrentLocalTime_internal_protected_set {internal set; }
    internal bool DebugPlusMode { get; private set; }
    unknown bool DebugPlusMode_internal_protected_set {internal set; }
    public MetadataImportOptions MetadataImportOptions { get; protected set; }
    internal bool ReferencesSupersedeLowerVersions { get; private set; }
    unknown bool ReferencesSupersedeLowerVersions_internal_protected_set {internal set; }
    public ImmutableDictionary`2<string, ReportDiagnostic> SpecificDiagnosticOptions { get; protected set; }
    public bool ReportSuppressedDiagnostics { get; protected set; }
    public MetadataReferenceResolver MetadataReferenceResolver { get; protected set; }
    public XmlReferenceResolver XmlReferenceResolver { get; protected set; }
    public SourceReferenceResolver SourceReferenceResolver { get; protected set; }
    public StrongNameProvider StrongNameProvider { get; protected set; }
    public AssemblyIdentityComparer AssemblyIdentityComparer { get; protected set; }
    [ObsoleteAttribute]
protected internal ImmutableArray`1<string> Features { get; protected set; }
    public string Language { get; }
    internal bool EnableEditAndContinue { get; }
    public ImmutableArray`1<Diagnostic> Errors { get; }
    internal CompilationOptions(OutputKind outputKind, bool reportSuppressedDiagnostics, string moduleName, string mainTypeName, string scriptClassName, string cryptoKeyContainer, string cryptoKeyFile, ImmutableArray`1<byte> cryptoPublicKey, Nullable`1<bool> delaySign, bool publicSign, OptimizationLevel optimizationLevel, bool checkOverflow, Platform platform, ReportDiagnostic generalDiagnosticOption, int warningLevel, ImmutableDictionary`2<string, ReportDiagnostic> specificDiagnosticOptions, bool concurrentBuild, bool deterministic, DateTime currentLocalTime, bool debugPlusMode, XmlReferenceResolver xmlReferenceResolver, SourceReferenceResolver sourceReferenceResolver, MetadataReferenceResolver metadataReferenceResolver, AssemblyIdentityComparer assemblyIdentityComparer, StrongNameProvider strongNameProvider, MetadataImportOptions metadataImportOptions, bool referencesSupersedeLowerVersions);
    [CompilerGeneratedAttribute]
public OutputKind get_OutputKind();
    [CompilerGeneratedAttribute]
protected void set_OutputKind(OutputKind value);
    [CompilerGeneratedAttribute]
public string get_ModuleName();
    [CompilerGeneratedAttribute]
protected void set_ModuleName(string value);
    [CompilerGeneratedAttribute]
public string get_ScriptClassName();
    [CompilerGeneratedAttribute]
protected void set_ScriptClassName(string value);
    [CompilerGeneratedAttribute]
public string get_MainTypeName();
    [CompilerGeneratedAttribute]
protected void set_MainTypeName(string value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<byte> get_CryptoPublicKey();
    [CompilerGeneratedAttribute]
protected void set_CryptoPublicKey(ImmutableArray`1<byte> value);
    [CompilerGeneratedAttribute]
public string get_CryptoKeyFile();
    [CompilerGeneratedAttribute]
protected void set_CryptoKeyFile(string value);
    [CompilerGeneratedAttribute]
public string get_CryptoKeyContainer();
    [CompilerGeneratedAttribute]
protected void set_CryptoKeyContainer(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_DelaySign();
    [CompilerGeneratedAttribute]
protected void set_DelaySign(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_PublicSign();
    [CompilerGeneratedAttribute]
protected void set_PublicSign(bool value);
    [CompilerGeneratedAttribute]
public bool get_CheckOverflow();
    [CompilerGeneratedAttribute]
protected void set_CheckOverflow(bool value);
    [CompilerGeneratedAttribute]
public Platform get_Platform();
    [CompilerGeneratedAttribute]
protected void set_Platform(Platform value);
    [CompilerGeneratedAttribute]
public OptimizationLevel get_OptimizationLevel();
    [CompilerGeneratedAttribute]
protected void set_OptimizationLevel(OptimizationLevel value);
    [CompilerGeneratedAttribute]
public ReportDiagnostic get_GeneralDiagnosticOption();
    [CompilerGeneratedAttribute]
protected void set_GeneralDiagnosticOption(ReportDiagnostic value);
    [CompilerGeneratedAttribute]
public int get_WarningLevel();
    [CompilerGeneratedAttribute]
protected void set_WarningLevel(int value);
    [CompilerGeneratedAttribute]
public bool get_ConcurrentBuild();
    [CompilerGeneratedAttribute]
protected void set_ConcurrentBuild(bool value);
    [CompilerGeneratedAttribute]
public bool get_Deterministic();
    [CompilerGeneratedAttribute]
protected void set_Deterministic(bool value);
    [CompilerGeneratedAttribute]
internal DateTime get_CurrentLocalTime();
    [CompilerGeneratedAttribute]
private void set_CurrentLocalTime(DateTime value);
    internal void set_CurrentLocalTime_internal_protected_set(DateTime value);
    [CompilerGeneratedAttribute]
internal bool get_DebugPlusMode();
    [CompilerGeneratedAttribute]
private void set_DebugPlusMode(bool value);
    internal void set_DebugPlusMode_internal_protected_set(bool value);
    [CompilerGeneratedAttribute]
public MetadataImportOptions get_MetadataImportOptions();
    [CompilerGeneratedAttribute]
protected void set_MetadataImportOptions(MetadataImportOptions value);
    [CompilerGeneratedAttribute]
internal bool get_ReferencesSupersedeLowerVersions();
    [CompilerGeneratedAttribute]
private void set_ReferencesSupersedeLowerVersions(bool value);
    internal void set_ReferencesSupersedeLowerVersions_internal_protected_set(bool value);
    internal abstract virtual Diagnostic FilterDiagnostic(Diagnostic diagnostic);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<string, ReportDiagnostic> get_SpecificDiagnosticOptions();
    [CompilerGeneratedAttribute]
protected void set_SpecificDiagnosticOptions(ImmutableDictionary`2<string, ReportDiagnostic> value);
    [CompilerGeneratedAttribute]
public bool get_ReportSuppressedDiagnostics();
    [CompilerGeneratedAttribute]
protected void set_ReportSuppressedDiagnostics(bool value);
    [CompilerGeneratedAttribute]
public MetadataReferenceResolver get_MetadataReferenceResolver();
    [CompilerGeneratedAttribute]
protected void set_MetadataReferenceResolver(MetadataReferenceResolver value);
    [CompilerGeneratedAttribute]
public XmlReferenceResolver get_XmlReferenceResolver();
    [CompilerGeneratedAttribute]
protected void set_XmlReferenceResolver(XmlReferenceResolver value);
    [CompilerGeneratedAttribute]
public SourceReferenceResolver get_SourceReferenceResolver();
    [CompilerGeneratedAttribute]
protected void set_SourceReferenceResolver(SourceReferenceResolver value);
    [CompilerGeneratedAttribute]
public StrongNameProvider get_StrongNameProvider();
    [CompilerGeneratedAttribute]
protected void set_StrongNameProvider(StrongNameProvider value);
    [CompilerGeneratedAttribute]
public AssemblyIdentityComparer get_AssemblyIdentityComparer();
    [CompilerGeneratedAttribute]
protected void set_AssemblyIdentityComparer(AssemblyIdentityComparer value);
    protected internal ImmutableArray`1<string> get_Features();
    protected void set_Features(ImmutableArray`1<string> value);
    internal bool CanReuseCompilationReferenceManager(CompilationOptions other);
    public abstract virtual string get_Language();
    internal bool get_EnableEditAndContinue();
    internal static bool IsValidFileAlignment(int value);
    internal abstract virtual ImmutableArray`1<string> GetImports();
    public CompilationOptions WithGeneralDiagnosticOption(ReportDiagnostic value);
    public CompilationOptions WithSpecificDiagnosticOptions(ImmutableDictionary`2<string, ReportDiagnostic> value);
    public CompilationOptions WithSpecificDiagnosticOptions(IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> value);
    public CompilationOptions WithReportSuppressedDiagnostics(bool value);
    public CompilationOptions WithConcurrentBuild(bool concurrent);
    public CompilationOptions WithDeterministic(bool deterministic);
    public CompilationOptions WithOutputKind(OutputKind kind);
    public CompilationOptions WithPlatform(Platform platform);
    public CompilationOptions WithPublicSign(bool publicSign);
    public CompilationOptions WithOptimizationLevel(OptimizationLevel value);
    public CompilationOptions WithXmlReferenceResolver(XmlReferenceResolver resolver);
    public CompilationOptions WithSourceReferenceResolver(SourceReferenceResolver resolver);
    public CompilationOptions WithMetadataReferenceResolver(MetadataReferenceResolver resolver);
    public CompilationOptions WithAssemblyIdentityComparer(AssemblyIdentityComparer comparer);
    public CompilationOptions WithStrongNameProvider(StrongNameProvider provider);
    public CompilationOptions WithModuleName(string moduleName);
    public CompilationOptions WithMainTypeName(string mainTypeName);
    public CompilationOptions WithScriptClassName(string scriptClassName);
    public CompilationOptions WithCryptoKeyContainer(string cryptoKeyContainer);
    public CompilationOptions WithCryptoKeyFile(string cryptoKeyFile);
    public CompilationOptions WithCryptoPublicKey(ImmutableArray`1<byte> cryptoPublicKey);
    public CompilationOptions WithDelaySign(Nullable`1<bool> delaySign);
    public CompilationOptions WithOverflowChecks(bool checkOverflow);
    public CompilationOptions WithMetadataImportOptions(MetadataImportOptions value);
    protected abstract virtual CompilationOptions CommonWithConcurrentBuild(bool concurrent);
    protected abstract virtual CompilationOptions CommonWithDeterministic(bool deterministic);
    protected abstract virtual CompilationOptions CommonWithOutputKind(OutputKind kind);
    protected abstract virtual CompilationOptions CommonWithPlatform(Platform platform);
    protected abstract virtual CompilationOptions CommonWithPublicSign(bool publicSign);
    protected abstract virtual CompilationOptions CommonWithOptimizationLevel(OptimizationLevel value);
    protected abstract virtual CompilationOptions CommonWithXmlReferenceResolver(XmlReferenceResolver resolver);
    protected abstract virtual CompilationOptions CommonWithSourceReferenceResolver(SourceReferenceResolver resolver);
    protected abstract virtual CompilationOptions CommonWithMetadataReferenceResolver(MetadataReferenceResolver resolver);
    protected abstract virtual CompilationOptions CommonWithAssemblyIdentityComparer(AssemblyIdentityComparer comparer);
    protected abstract virtual CompilationOptions CommonWithStrongNameProvider(StrongNameProvider provider);
    protected abstract virtual CompilationOptions CommonWithGeneralDiagnosticOption(ReportDiagnostic generalDiagnosticOption);
    protected abstract virtual CompilationOptions CommonWithSpecificDiagnosticOptions(ImmutableDictionary`2<string, ReportDiagnostic> specificDiagnosticOptions);
    protected abstract virtual CompilationOptions CommonWithSpecificDiagnosticOptions(IEnumerable`1<KeyValuePair`2<string, ReportDiagnostic>> specificDiagnosticOptions);
    protected abstract virtual CompilationOptions CommonWithReportSuppressedDiagnostics(bool reportSuppressedDiagnostics);
    protected abstract virtual CompilationOptions CommonWithModuleName(string moduleName);
    protected abstract virtual CompilationOptions CommonWithMainTypeName(string mainTypeName);
    protected abstract virtual CompilationOptions CommonWithScriptClassName(string scriptClassName);
    protected abstract virtual CompilationOptions CommonWithCryptoKeyContainer(string cryptoKeyContainer);
    protected abstract virtual CompilationOptions CommonWithCryptoKeyFile(string cryptoKeyFile);
    protected abstract virtual CompilationOptions CommonWithCryptoPublicKey(ImmutableArray`1<byte> cryptoPublicKey);
    protected abstract virtual CompilationOptions CommonWithDelaySign(Nullable`1<bool> delaySign);
    protected abstract virtual CompilationOptions CommonWithCheckOverflow(bool checkOverflow);
    protected abstract virtual CompilationOptions CommonWithMetadataImportOptions(MetadataImportOptions value);
    [ObsoleteAttribute]
protected abstract virtual CompilationOptions CommonWithFeatures(ImmutableArray`1<string> features);
    internal abstract virtual void ValidateOptions(ArrayBuilder`1<Diagnostic> builder);
    internal void ValidateOptions(ArrayBuilder`1<Diagnostic> builder, CommonMessageProvider messageProvider);
    public ImmutableArray`1<Diagnostic> get_Errors();
    public abstract virtual bool Equals(object obj);
    protected bool EqualsHelper(CompilationOptions other);
    public abstract virtual int GetHashCode();
    protected int GetHashCodeHelper();
    public static bool op_Equality(CompilationOptions left, CompilationOptions right);
    public static bool op_Inequality(CompilationOptions left, CompilationOptions right);
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Diagnostic> <.ctor>b__119_0();
}
public abstract class Microsoft.CodeAnalysis.CompilationReference : MetadataReference {
    public Compilation Compilation { get; }
    internal Compilation CompilationCore { get; }
    public string Display { get; }
    internal CompilationReference(MetadataReferenceProperties properties);
    public Compilation get_Compilation();
    internal abstract virtual Compilation get_CompilationCore();
    internal static MetadataReferenceProperties GetProperties(Compilation compilation, ImmutableArray`1<string> aliases, bool embedInteropTypes);
    public CompilationReference WithAliases(IEnumerable`1<string> aliases);
    public CompilationReference WithAliases(ImmutableArray`1<string> aliases);
    public CompilationReference WithEmbedInteropTypes(bool value);
    public CompilationReference WithProperties(MetadataReferenceProperties properties);
    internal sealed virtual MetadataReference WithPropertiesImplReturningMetadataReference(MetadataReferenceProperties properties);
    internal abstract virtual CompilationReference WithPropertiesImpl(MetadataReferenceProperties properties);
    public virtual string get_Display();
    public sealed virtual bool Equals(CompilationReference other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal enum Microsoft.CodeAnalysis.CompilationStage : Enum {
    public int value__;
    public static CompilationStage Parse;
    public static CompilationStage Declare;
    public static CompilationStage Compile;
    public static CompilationStage Emit;
}
internal class Microsoft.CodeAnalysis.ConcurrentCache`2 : CachingBase`1<Entry<TKey, TValue>> {
    public ConcurrentCache`2(int size);
    public bool TryAdd(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ConsListExtensions : object {
    [ExtensionAttribute]
public static ConsList`1<T> Prepend(ConsList`1<T> list, T head);
    [ExtensionAttribute]
public static bool ContainsReference(ConsList`1<T> list, T element);
}
internal abstract class Microsoft.CodeAnalysis.ConstantValue : object {
    public static ConstantValue NotAvailable;
    public ConstantValueTypeDiscriminator Discriminator { get; }
    internal SpecialType SpecialType { get; }
    public string StringValue { get; }
    public bool BooleanValue { get; }
    public sbyte SByteValue { get; }
    public byte ByteValue { get; }
    public short Int16Value { get; }
    public ushort UInt16Value { get; }
    public int Int32Value { get; }
    public UInt32 UInt32Value { get; }
    public long Int64Value { get; }
    public ulong UInt64Value { get; }
    public char CharValue { get; }
    public decimal DecimalValue { get; }
    public DateTime DateTimeValue { get; }
    public double DoubleValue { get; }
    public float SingleValue { get; }
    public bool IsDefaultValue { get; }
    public static ConstantValue Bad { get; }
    public static ConstantValue Null { get; }
    public static ConstantValue Nothing { get; }
    public static ConstantValue Unset { get; }
    public static ConstantValue True { get; }
    public static ConstantValue False { get; }
    public object Value { get; }
    public bool IsIntegral { get; }
    public bool IsNegativeNumeric { get; }
    public bool IsNumeric { get; }
    public bool IsUnsigned { get; }
    public bool IsBoolean { get; }
    public bool IsChar { get; }
    public bool IsString { get; }
    public bool IsDecimal { get; }
    public bool IsDateTime { get; }
    public bool IsFloating { get; }
    public bool IsBad { get; }
    public bool IsNull { get; }
    public bool IsNothing { get; }
    public abstract virtual ConstantValueTypeDiscriminator get_Discriminator();
    internal abstract virtual SpecialType get_SpecialType();
    public virtual string get_StringValue();
    public virtual bool get_BooleanValue();
    public virtual sbyte get_SByteValue();
    public virtual byte get_ByteValue();
    public virtual short get_Int16Value();
    public virtual ushort get_UInt16Value();
    public virtual int get_Int32Value();
    public virtual UInt32 get_UInt32Value();
    public virtual long get_Int64Value();
    public virtual ulong get_UInt64Value();
    public virtual char get_CharValue();
    public virtual decimal get_DecimalValue();
    public virtual DateTime get_DateTimeValue();
    public virtual double get_DoubleValue();
    public virtual float get_SingleValue();
    public virtual bool get_IsDefaultValue();
    public static ConstantValue get_Bad();
    public static ConstantValue get_Null();
    public static ConstantValue get_Nothing();
    public static ConstantValue get_Unset();
    public static ConstantValue get_True();
    public static ConstantValue get_False();
    public static ConstantValue Create(string value);
    public static ConstantValue Create(char value);
    public static ConstantValue Create(sbyte value);
    public static ConstantValue Create(byte value);
    public static ConstantValue Create(short value);
    public static ConstantValue Create(ushort value);
    public static ConstantValue Create(int value);
    public static ConstantValue Create(UInt32 value);
    public static ConstantValue Create(long value);
    public static ConstantValue Create(ulong value);
    public static ConstantValue Create(bool value);
    public static ConstantValue Create(float value);
    public static ConstantValue CreateSingle(double value);
    public static ConstantValue Create(double value);
    public static ConstantValue Create(decimal value);
    public static ConstantValue Create(DateTime value);
    public static ConstantValue Create(object value, SpecialType st);
    public static ConstantValue CreateSizeOf(SpecialType st);
    public static ConstantValue Create(object value, ConstantValueTypeDiscriminator discriminator);
    public static ConstantValue Default(SpecialType st);
    public static ConstantValue Default(ConstantValueTypeDiscriminator discriminator);
    internal static ConstantValueTypeDiscriminator GetDiscriminator(SpecialType st);
    private static SpecialType GetSpecialType(ConstantValueTypeDiscriminator discriminator);
    public object get_Value();
    public static bool IsIntegralType(ConstantValueTypeDiscriminator discriminator);
    public bool get_IsIntegral();
    public bool get_IsNegativeNumeric();
    public bool get_IsNumeric();
    public static bool IsUnsignedIntegralType(ConstantValueTypeDiscriminator discriminator);
    public bool get_IsUnsigned();
    public static bool IsBooleanType(ConstantValueTypeDiscriminator discriminator);
    public bool get_IsBoolean();
    public static bool IsCharType(ConstantValueTypeDiscriminator discriminator);
    public bool get_IsChar();
    public static bool IsStringType(ConstantValueTypeDiscriminator discriminator);
    public bool get_IsString();
    public static bool IsDecimalType(ConstantValueTypeDiscriminator discriminator);
    public bool get_IsDecimal();
    public static bool IsDateTimeType(ConstantValueTypeDiscriminator discriminator);
    public bool get_IsDateTime();
    public static bool IsFloatingType(ConstantValueTypeDiscriminator discriminator);
    public bool get_IsFloating();
    public bool get_IsBad();
    public bool get_IsNull();
    public bool get_IsNothing();
    public void Serialize(BlobBuilder writer);
    public virtual string ToString();
    internal virtual string GetValueToDisplay();
    public virtual bool Equals(ConstantValue other);
    public static bool op_Equality(ConstantValue left, ConstantValue right);
    public static bool op_Inequality(ConstantValue left, ConstantValue right);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
internal enum Microsoft.CodeAnalysis.ConstantValueTypeDiscriminator : Enum {
    public byte value__;
    public static ConstantValueTypeDiscriminator Nothing;
    public static ConstantValueTypeDiscriminator Null;
    public static ConstantValueTypeDiscriminator Bad;
    public static ConstantValueTypeDiscriminator SByte;
    public static ConstantValueTypeDiscriminator Byte;
    public static ConstantValueTypeDiscriminator Int16;
    public static ConstantValueTypeDiscriminator UInt16;
    public static ConstantValueTypeDiscriminator Int32;
    public static ConstantValueTypeDiscriminator UInt32;
    public static ConstantValueTypeDiscriminator Int64;
    public static ConstantValueTypeDiscriminator UInt64;
    public static ConstantValueTypeDiscriminator Char;
    public static ConstantValueTypeDiscriminator Boolean;
    public static ConstantValueTypeDiscriminator Single;
    public static ConstantValueTypeDiscriminator Double;
    public static ConstantValueTypeDiscriminator String;
    public static ConstantValueTypeDiscriminator Decimal;
    public static ConstantValueTypeDiscriminator DateTime;
}
public abstract class Microsoft.CodeAnalysis.ControlFlowAnalysis : object {
    public ImmutableArray`1<SyntaxNode> EntryPoints { get; }
    public ImmutableArray`1<SyntaxNode> ExitPoints { get; }
    public bool EndPointIsReachable { get; }
    public bool StartPointIsReachable { get; }
    public ImmutableArray`1<SyntaxNode> ReturnStatements { get; }
    public bool Succeeded { get; }
    public abstract virtual ImmutableArray`1<SyntaxNode> get_EntryPoints();
    public abstract virtual ImmutableArray`1<SyntaxNode> get_ExitPoints();
    public abstract virtual bool get_EndPointIsReachable();
    public abstract virtual bool get_StartPointIsReachable();
    public abstract virtual ImmutableArray`1<SyntaxNode> get_ReturnStatements();
    public abstract virtual bool get_Succeeded();
}
internal static class Microsoft.CodeAnalysis.CoreClrShim : object {
    internal static bool IsRunningOnCoreClr { get; }
    internal static bool get_IsRunningOnCoreClr();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CryptoBlobParser : object {
    private static ImmutableArray`1<byte> s_ecmaKey;
    private static int SnPublicKeyBlobSize;
    private static byte PublicKeyBlobId;
    private static byte PrivateKeyBlobId;
    internal static int s_publicKeyHeaderSize;
    private static int BlobHeaderSize;
    private static int RsaPubKeySize;
    private static UInt32 RSA1;
    private static UInt32 RSA2;
    private static int s_offsetToKeyData;
    private static CryptoBlobParser();
    internal static bool IsValidPublicKey(ImmutableArray`1<byte> blob);
    private static ImmutableArray`1<byte> CreateSnPublicKeyBlob(byte type, byte version, UInt32 algId, UInt32 magic, UInt32 bitLen, UInt32 pubExp, Byte[] pubKeyData);
    public static bool TryParseKey(ImmutableArray`1<byte> blob, ImmutableArray`1& snKey, Nullable`1& privateKey);
    [ExtensionAttribute]
internal static RSAParameters ToRSAParameters(Byte[] cspBlob, bool includePrivateParameters);
    private static Byte[] ExponentAsBytes(UInt32 exponent);
    [ExtensionAttribute]
private static Byte[] ReadReversed(BinaryReader br, int count);
}
internal abstract class Microsoft.CodeAnalysis.CryptographicHashProvider : object {
    private ImmutableArray`1<byte> _lazySHA1Hash;
    private ImmutableArray`1<byte> _lazySHA256Hash;
    private ImmutableArray`1<byte> _lazySHA384Hash;
    private ImmutableArray`1<byte> _lazySHA512Hash;
    private ImmutableArray`1<byte> _lazyMD5Hash;
    internal static int Sha1HashSize;
    internal abstract virtual ImmutableArray`1<byte> ComputeHash(HashAlgorithm algorithm);
    internal ImmutableArray`1<byte> GetHash(AssemblyHashAlgorithm algorithmId);
    internal static int GetHashSize(SourceHashAlgorithm algorithmId);
    internal static HashAlgorithm TryGetAlgorithm(SourceHashAlgorithm algorithmId);
    internal static HashAlgorithmName GetAlgorithmName(SourceHashAlgorithm algorithmId);
    internal static HashAlgorithm TryGetAlgorithm(AssemblyHashAlgorithm algorithmId);
    internal static bool IsSupportedAlgorithm(AssemblyHashAlgorithm algorithmId);
    private ImmutableArray`1<byte> GetHash(ImmutableArray`1& lazyHash, HashAlgorithm algorithm);
    internal static ImmutableArray`1<byte> ComputeSha1(Stream stream);
    internal static ImmutableArray`1<byte> ComputeSha1(ImmutableArray`1<byte> bytes);
    internal static ImmutableArray`1<byte> ComputeSha1(Byte[] bytes);
    internal static ImmutableArray`1<byte> ComputeHash(HashAlgorithmName algorithmName, IEnumerable`1<Blob> bytes);
    internal static ImmutableArray`1<byte> ComputeHash(HashAlgorithmName algorithmName, IEnumerable`1<ArraySegment`1<byte>> bytes);
}
internal class Microsoft.CodeAnalysis.CustomAttributesBag`1 : object {
    private ImmutableArray`1<T> _customAttributes;
    private WellKnownAttributeData _decodedWellKnownAttributeData;
    private EarlyWellKnownAttributeData _earlyDecodedWellKnownAttributeData;
    private int _state;
    public static CustomAttributesBag`1<T> Empty;
    public bool IsEmpty { get; }
    public ImmutableArray`1<T> Attributes { get; }
    public WellKnownAttributeData DecodedWellKnownAttributeData { get; }
    public EarlyWellKnownAttributeData EarlyDecodedWellKnownAttributeData { get; }
    private CustomAttributeBagCompletionPart<T> State { get; private set; }
    internal bool IsSealed { get; }
    internal bool IsEarlyDecodedWellKnownAttributeDataComputed { get; }
    internal bool IsDecodedWellKnownAttributeDataComputed { get; }
    private CustomAttributesBag`1(CustomAttributeBagCompletionPart<T> part, ImmutableArray`1<T> customAttributes);
    private static CustomAttributesBag`1();
    public static CustomAttributesBag`1<T> WithEmptyData();
    public bool get_IsEmpty();
    public bool SetEarlyDecodedWellKnownAttributeData(EarlyWellKnownAttributeData data);
    public bool SetDecodedWellKnownAttributeData(WellKnownAttributeData data);
    public bool SetAttributes(ImmutableArray`1<T> newCustomAttributes);
    public ImmutableArray`1<T> get_Attributes();
    public WellKnownAttributeData get_DecodedWellKnownAttributeData();
    public EarlyWellKnownAttributeData get_EarlyDecodedWellKnownAttributeData();
    private CustomAttributeBagCompletionPart<T> get_State();
    private void set_State(CustomAttributeBagCompletionPart<T> value);
    private void NotePartComplete(CustomAttributeBagCompletionPart<T> part);
    internal bool IsPartComplete(CustomAttributeBagCompletionPart<T> part);
    internal bool get_IsSealed();
    internal bool get_IsEarlyDecodedWellKnownAttributeDataComputed();
    internal bool get_IsDecodedWellKnownAttributeDataComputed();
}
public abstract class Microsoft.CodeAnalysis.CustomModifier : object {
    public bool IsOptional { get; }
    public INamedTypeSymbol Modifier { get; }
    private bool Microsoft.Cci.ICustomModifier.IsOptional { get; }
    public abstract virtual bool get_IsOptional();
    public abstract virtual INamedTypeSymbol get_Modifier();
    private sealed virtual override bool Microsoft.Cci.ICustomModifier.get_IsOptional();
    private sealed virtual override ITypeReference Microsoft.Cci.ICustomModifier.GetModifier(EmitContext context);
}
internal class Microsoft.CodeAnalysis.CustomModifiersTuple : object {
    private ImmutableArray`1<CustomModifier> _typeCustomModifiers;
    private ImmutableArray`1<CustomModifier> _refCustomModifiers;
    public static CustomModifiersTuple Empty;
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public ImmutableArray`1<CustomModifier> RefCustomModifiers { get; }
    private CustomModifiersTuple(ImmutableArray`1<CustomModifier> typeCustomModifiers, ImmutableArray`1<CustomModifier> refCustomModifiers);
    private static CustomModifiersTuple();
    public static CustomModifiersTuple Create(ImmutableArray`1<CustomModifier> typeCustomModifiers, ImmutableArray`1<CustomModifier> refCustomModifiers);
    public ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
    public ImmutableArray`1<CustomModifier> get_RefCustomModifiers();
}
internal class Microsoft.CodeAnalysis.CvtResFile : object {
    private static ushort RT_DLGINCLUDE;
    internal static List`1<RESOURCE> ReadResFile(Stream stream);
    private static RESOURCE_STRING ReadStringOrID(BinaryReader fhIn);
}
public abstract class Microsoft.CodeAnalysis.DataFlowAnalysis : object {
    public ImmutableArray`1<ISymbol> VariablesDeclared { get; }
    public ImmutableArray`1<ISymbol> DataFlowsIn { get; }
    public ImmutableArray`1<ISymbol> DataFlowsOut { get; }
    public ImmutableArray`1<ISymbol> AlwaysAssigned { get; }
    public ImmutableArray`1<ISymbol> ReadInside { get; }
    public ImmutableArray`1<ISymbol> WrittenInside { get; }
    public ImmutableArray`1<ISymbol> ReadOutside { get; }
    public ImmutableArray`1<ISymbol> WrittenOutside { get; }
    public ImmutableArray`1<ISymbol> Captured { get; }
    public ImmutableArray`1<ISymbol> CapturedInside { get; }
    public ImmutableArray`1<ISymbol> CapturedOutside { get; }
    public ImmutableArray`1<ISymbol> UnsafeAddressTaken { get; }
    public bool Succeeded { get; }
    public abstract virtual ImmutableArray`1<ISymbol> get_VariablesDeclared();
    public abstract virtual ImmutableArray`1<ISymbol> get_DataFlowsIn();
    public abstract virtual ImmutableArray`1<ISymbol> get_DataFlowsOut();
    public abstract virtual ImmutableArray`1<ISymbol> get_AlwaysAssigned();
    public abstract virtual ImmutableArray`1<ISymbol> get_ReadInside();
    public abstract virtual ImmutableArray`1<ISymbol> get_WrittenInside();
    public abstract virtual ImmutableArray`1<ISymbol> get_ReadOutside();
    public abstract virtual ImmutableArray`1<ISymbol> get_WrittenOutside();
    public abstract virtual ImmutableArray`1<ISymbol> get_Captured();
    public abstract virtual ImmutableArray`1<ISymbol> get_CapturedInside();
    public abstract virtual ImmutableArray`1<ISymbol> get_CapturedOutside();
    public abstract virtual ImmutableArray`1<ISymbol> get_UnsafeAddressTaken();
    public abstract virtual bool get_Succeeded();
}
internal static class Microsoft.CodeAnalysis.Debugging.CustomDebugInfoConstants : object {
    internal static byte Version;
    internal static int GlobalHeaderSize;
    internal static int RecordHeaderSize;
}
internal class Microsoft.CodeAnalysis.Debugging.CustomDebugInfoEncoder : ValueType {
    [CompilerGeneratedAttribute]
private BlobBuilder <Builder>k__BackingField;
    private Blob _recordCountFixup;
    private int _recordCount;
    internal static int DynamicAttributeSize;
    internal static int IdentifierSize;
    public BlobBuilder Builder { get; }
    public int RecordCount { get; }
    public CustomDebugInfoEncoder(BlobBuilder builder);
    [CompilerGeneratedAttribute]
public BlobBuilder get_Builder();
    public int get_RecordCount();
    public Byte[] ToArray();
    public void AddStateMachineTypeName(string typeName);
    public void AddForwardMethodInfo(MethodDefinitionHandle methodHandle);
    public void AddForwardModuleInfo(MethodDefinitionHandle methodHandle);
    public void AddUsingGroups(IReadOnlyCollection`1<int> groupSizes);
    public void AddStateMachineHoistedLocalScopes(ImmutableArray`1<StateMachineHoistedLocalScope> scopes);
    public void AddDynamicLocals(IReadOnlyCollection`1<ValueTuple`4<string, Byte[], int, int>> dynamicLocals);
    public void AddTupleElementNames(IReadOnlyCollection`1<ValueTuple`5<string, int, int, int, ImmutableArray`1<string>>> tupleLocals);
    public void AddRecord(CustomDebugInfoKind kind, T debugInfo, Action`2<T, BlobBuilder> recordSerializer);
}
internal enum Microsoft.CodeAnalysis.Debugging.CustomDebugInfoKind : Enum {
    public byte value__;
    public static CustomDebugInfoKind UsingGroups;
    public static CustomDebugInfoKind ForwardMethodInfo;
    public static CustomDebugInfoKind ForwardModuleInfo;
    public static CustomDebugInfoKind StateMachineHoistedLocalScopes;
    public static CustomDebugInfoKind StateMachineTypeName;
    public static CustomDebugInfoKind DynamicLocals;
    public static CustomDebugInfoKind EditAndContinueLocalSlotMap;
    public static CustomDebugInfoKind EditAndContinueLambdaMap;
    public static CustomDebugInfoKind TupleElementNames;
}
internal static class Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader : object {
    private static void ReadGlobalHeader(Byte[] bytes, Int32& offset, Byte& version, Byte& count);
    private static void ReadRecordHeader(Byte[] bytes, Int32& offset, Byte& version, CustomDebugInfoKind& kind, Int32& size, Int32& alignmentSize);
    public static ImmutableArray`1<byte> TryGetCustomDebugInfoRecord(Byte[] customDebugInfo, CustomDebugInfoKind recordKind);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Debugging.CustomDebugInfoReader/<GetCustomDebugInfoRecords>d__3")]
public static IEnumerable`1<CustomDebugInfoRecord> GetCustomDebugInfoRecords(Byte[] customDebugInfo);
    public static ImmutableArray`1<short> DecodeUsingRecord(ImmutableArray`1<byte> bytes);
    public static int DecodeForwardRecord(ImmutableArray`1<byte> bytes);
    public static int DecodeForwardToModuleRecord(ImmutableArray`1<byte> bytes);
    public static ImmutableArray`1<StateMachineHoistedLocalScope> DecodeStateMachineHoistedLocalScopesRecord(ImmutableArray`1<byte> bytes);
    public static string DecodeForwardIteratorRecord(ImmutableArray`1<byte> bytes);
    public static ImmutableArray`1<DynamicLocalInfo> DecodeDynamicLocalsRecord(ImmutableArray`1<byte> bytes);
    public static ImmutableArray`1<TupleElementNamesInfo> DecodeTupleElementNamesRecord(ImmutableArray`1<byte> bytes);
    private static TupleElementNamesInfo DecodeTupleElementNamesInfo(ImmutableArray`1<byte> bytes, Int32& offset);
    private static void ReadRawRecordBody(Byte[] bytes, Int32& offset, int size, ImmutableArray`1& body);
    private static void SkipRecord(Byte[] bytes, Int32& offset, int size);
    public static ImmutableArray`1<ImmutableArray`1<string>> GetCSharpGroupedImportStrings(int methodToken, TArg arg, Func`3<int, TArg, Byte[]> getMethodCustomDebugInfo, Func`3<int, TArg, ImmutableArray`1<string>> getMethodImportStrings, ImmutableArray`1& externAliasStrings);
    public static ImmutableArray`1<string> GetVisualBasicImportStrings(int methodToken, TArg arg, Func`3<int, TArg, ImmutableArray`1<string>> getMethodImportStrings);
    private static void CheckVersion(byte globalVersion, int methodToken);
    private static int ReadInt32(ImmutableArray`1<byte> bytes, Int32& offset);
    private static short ReadInt16(ImmutableArray`1<byte> bytes, Int32& offset);
    private static byte ReadByte(ImmutableArray`1<byte> bytes, Int32& offset);
    private static bool IsCSharpExternAliasInfo(string import);
    public static bool TryParseCSharpImportString(string import, String& alias, String& externAlias, String& target, ImportTargetKind& kind);
    public static bool TryParseVisualBasicImportString(string import, String& alias, String& target, ImportTargetKind& kind, VBImportScopeKind& scope);
    private static bool TrySplit(string input, int offset, char separator, String& before, String& after);
    private static string FormatMethodToken(int methodToken);
    private static string ReadUtf8String(ImmutableArray`1<byte> bytes, Int32& offset);
}
internal class Microsoft.CodeAnalysis.Debugging.CustomDebugInfoRecord : ValueType {
    public CustomDebugInfoKind Kind;
    public byte Version;
    public ImmutableArray`1<byte> Data;
    public CustomDebugInfoRecord(CustomDebugInfoKind kind, byte version, ImmutableArray`1<byte> data);
}
internal class Microsoft.CodeAnalysis.Debugging.DynamicLocalInfo : ValueType {
    public ImmutableArray`1<bool> Flags;
    public int SlotId;
    public string LocalName;
    public DynamicLocalInfo(ImmutableArray`1<bool> flags, int slotId, string localName);
}
internal enum Microsoft.CodeAnalysis.Debugging.ImportTargetKind : Enum {
    public int value__;
    public static ImportTargetKind Namespace;
    public static ImportTargetKind Type;
    public static ImportTargetKind NamespaceOrType;
    public static ImportTargetKind Assembly;
    public static ImportTargetKind XmlNamespace;
    public static ImportTargetKind MethodToken;
    public static ImportTargetKind CurrentNamespace;
    public static ImportTargetKind DefaultNamespace;
    public static ImportTargetKind Defunct;
}
internal static class Microsoft.CodeAnalysis.Debugging.PortableCustomDebugInfoKinds : object {
    public static Guid AsyncMethodSteppingInformationBlob;
    public static Guid StateMachineHoistedLocalScopes;
    public static Guid DynamicLocalVariables;
    public static Guid TupleElementNames;
    public static Guid DefaultNamespace;
    public static Guid EncLocalSlotMap;
    public static Guid EncLambdaAndClosureMap;
    public static Guid SourceLink;
    public static Guid EmbeddedSource;
    private static PortableCustomDebugInfoKinds();
}
internal class Microsoft.CodeAnalysis.Debugging.StateMachineHoistedLocalScope : ValueType {
    public int StartOffset;
    public int EndOffset;
    public int Length { get; }
    public bool IsDefault { get; }
    public StateMachineHoistedLocalScope(int startOffset, int endOffset);
    public int get_Length();
    public bool get_IsDefault();
}
internal class Microsoft.CodeAnalysis.Debugging.TupleElementNamesInfo : ValueType {
    internal ImmutableArray`1<string> ElementNames;
    internal int SlotIndex;
    internal string LocalName;
    internal int ScopeStart;
    internal int ScopeEnd;
    internal TupleElementNamesInfo(ImmutableArray`1<string> elementNames, int slotIndex, string localName, int scopeStart, int scopeEnd);
}
internal enum Microsoft.CodeAnalysis.Debugging.VBImportScopeKind : Enum {
    public int value__;
    public static VBImportScopeKind Unspecified;
    public static VBImportScopeKind File;
    public static VBImportScopeKind Project;
}
internal class Microsoft.CodeAnalysis.DeclarationComputer : object {
    internal static DeclarationInfo GetDeclarationInfo(SemanticModel model, SyntaxNode node, bool getSymbol, IEnumerable`1<SyntaxNode> executableCodeBlocks, CancellationToken cancellationToken);
    internal static DeclarationInfo GetDeclarationInfo(SemanticModel model, SyntaxNode node, bool getSymbol, CancellationToken cancellationToken);
    internal static DeclarationInfo GetDeclarationInfo(SemanticModel model, SyntaxNode node, bool getSymbol, SyntaxNode executableCodeBlock, CancellationToken cancellationToken);
    internal static DeclarationInfo GetDeclarationInfo(SemanticModel model, SyntaxNode node, bool getSymbol, CancellationToken cancellationToken, SyntaxNode[] executableCodeBlocks);
    private static ISymbol GetDeclaredSymbol(SemanticModel model, SyntaxNode node, bool getSymbol, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.DeclarationInfo : ValueType {
    private SyntaxNode _declaredNode;
    private ImmutableArray`1<SyntaxNode> _executableCodeBlocks;
    private ISymbol _declaredSymbol;
    public SyntaxNode DeclaredNode { get; }
    public ImmutableArray`1<SyntaxNode> ExecutableCodeBlocks { get; }
    public ISymbol DeclaredSymbol { get; }
    internal DeclarationInfo(SyntaxNode declaredNode, ImmutableArray`1<SyntaxNode> executableCodeBlocks, ISymbol declaredSymbol);
    public SyntaxNode get_DeclaredNode();
    public ImmutableArray`1<SyntaxNode> get_ExecutableCodeBlocks();
    public ISymbol get_DeclaredSymbol();
}
internal class Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments`3 : ValueType {
    private WellKnownAttributeData _lazyDecodeData;
    [CompilerGeneratedAttribute]
private TAttributeSyntax <AttributeSyntaxOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private TAttributeData <Attribute>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AttributesCount>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticBag <Diagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private TAttributeLocation <SymbolPart>k__BackingField;
    public bool HasDecodedData { get; }
    public WellKnownAttributeData DecodedData { get; }
    public TAttributeSyntax AttributeSyntaxOpt { get; public set; }
    public TAttributeData Attribute { get; public set; }
    public int Index { get; public set; }
    public int AttributesCount { get; public set; }
    public DiagnosticBag Diagnostics { get; public set; }
    public TAttributeLocation SymbolPart { get; public set; }
    public T GetOrCreateData();
    public bool get_HasDecodedData();
    public WellKnownAttributeData get_DecodedData();
    [CompilerGeneratedAttribute]
public TAttributeSyntax get_AttributeSyntaxOpt();
    [CompilerGeneratedAttribute]
public void set_AttributeSyntaxOpt(TAttributeSyntax value);
    [CompilerGeneratedAttribute]
public TAttributeData get_Attribute();
    [CompilerGeneratedAttribute]
public void set_Attribute(TAttributeData value);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public void set_Index(int value);
    [CompilerGeneratedAttribute]
public int get_AttributesCount();
    [CompilerGeneratedAttribute]
public void set_AttributesCount(int value);
    [CompilerGeneratedAttribute]
public DiagnosticBag get_Diagnostics();
    [CompilerGeneratedAttribute]
public void set_Diagnostics(DiagnosticBag value);
    [CompilerGeneratedAttribute]
public TAttributeLocation get_SymbolPart();
    [CompilerGeneratedAttribute]
public void set_SymbolPart(TAttributeLocation value);
}
public class Microsoft.CodeAnalysis.DesktopAssemblyIdentityComparer : AssemblyIdentityComparer {
    [CompilerGeneratedAttribute]
private static DesktopAssemblyIdentityComparer <Default>k__BackingField;
    internal AssemblyPortabilityPolicy policy;
    private static ImmutableArray`1<byte> s_NETCF_PUBLIC_KEY_TOKEN_1;
    private static ImmutableArray`1<byte> s_NETCF_PUBLIC_KEY_TOKEN_2;
    private static ImmutableArray`1<byte> s_NETCF_PUBLIC_KEY_TOKEN_3;
    private static ImmutableArray`1<byte> s_SQL_PUBLIC_KEY_TOKEN;
    private static ImmutableArray`1<byte> s_SQL_MOBILE_PUBLIC_KEY_TOKEN;
    private static ImmutableArray`1<byte> s_ECMA_PUBLICKEY_STR_L;
    private static ImmutableArray`1<byte> s_SHAREDLIB_PUBLICKEY_STR_L;
    private static ImmutableArray`1<byte> s_MICROSOFT_PUBLICKEY_STR_L;
    private static ImmutableArray`1<byte> s_SILVERLIGHT_PLATFORM_PUBLICKEY_STR_L;
    private static ImmutableArray`1<byte> s_SILVERLIGHT_PUBLICKEY_STR_L;
    private static ImmutableArray`1<byte> s_RIA_SERVICES_KEY_TOKEN;
    private static AssemblyVersion s_VER_VS_COMPATIBILITY_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion s_VER_VS_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion s_VER_SQL_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion s_VER_LINQ_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion s_VER_LINQ_ASSEMBLYVERSION_STR_2_L;
    private static AssemblyVersion s_VER_SQL_ORCAS_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion s_VER_ASSEMBLYVERSION_STR_L;
    private static AssemblyVersion s_VER_VC_STLCLR_ASSEMBLYVERSION_STR_L;
    private static string NULL;
    private static bool TRUE;
    private static FrameworkRetargetingDictionary s_arRetargetPolicy;
    private static FrameworkAssemblyDictionary s_arFxPolicy;
    public static DesktopAssemblyIdentityComparer Default { get; }
    internal AssemblyPortabilityPolicy PortabilityPolicy { get; }
    internal DesktopAssemblyIdentityComparer(AssemblyPortabilityPolicy policy);
    private static DesktopAssemblyIdentityComparer();
    [CompilerGeneratedAttribute]
public static DesktopAssemblyIdentityComparer get_Default();
    public static DesktopAssemblyIdentityComparer LoadFromXml(Stream input);
    internal AssemblyPortabilityPolicy get_PortabilityPolicy();
    internal virtual bool ApplyUnificationPolicies(AssemblyIdentity& reference, AssemblyIdentity& definition, AssemblyIdentityParts referenceParts, Boolean& isDefinitionFxAssembly);
    private static bool IsFrameworkAssembly(AssemblyIdentity identity);
    private static bool IsRetargetableAssembly(AssemblyIdentity identity);
    private static bool IsOptionallyRetargetableAssembly(AssemblyIdentity identity);
    private static bool IsTriviallyNonRetargetable(AssemblyIdentity identity);
    private static void IsRetargetableAssembly(AssemblyIdentity identity, Boolean& retargetable, Boolean& portable);
    private static AssemblyIdentity Retarget(AssemblyIdentity identity);
    private AssemblyIdentity Port(AssemblyIdentity identity);
}
public class Microsoft.CodeAnalysis.DesktopStrongNameProvider : StrongNameProvider {
    private ImmutableArray`1<string> _keyFileSearchPaths;
    private string _tempPath;
    [CompilerGeneratedAttribute]
private StrongNameFileSystem <FileSystem>k__BackingField;
    internal Func`1<IClrStrongName> TestStrongNameInterfaceFactory;
    internal StrongNameFileSystem FileSystem { get; }
    internal SigningCapability Capability { get; }
    public DesktopStrongNameProvider(ImmutableArray`1<string> keyFileSearchPaths);
    public DesktopStrongNameProvider(ImmutableArray`1<string> keyFileSearchPaths, string tempPath);
    internal DesktopStrongNameProvider(ImmutableArray`1<string> keyFileSearchPaths, string tempPath, StrongNameFileSystem strongNameFileSystem);
    [CompilerGeneratedAttribute]
internal StrongNameFileSystem get_FileSystem();
    internal virtual SigningCapability get_Capability();
    internal virtual Stream CreateInputStream();
    internal virtual StrongNameKeys CreateKeys(string keyFilePath, string keyContainerName, CommonMessageProvider messageProvider);
    internal virtual void ReadKeysFromContainer(string keyContainer, ImmutableArray`1& publicKey);
    internal virtual void SignStream(StrongNameKeys keys, Stream inputStream, Stream outputStream);
    internal IClrStrongName GetStrongNameInterface();
    internal ImmutableArray`1<byte> GetPublicKey(string keyContainer);
    private void Sign(string filePath, string keyName);
    private void Sign(string filePath, ImmutableArray`1<byte> keyPair);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public abstract class Microsoft.CodeAnalysis.Diagnostic : object {
    internal static string CompilerDiagnosticCategory;
    internal static int HighestValidWarningLevel;
    public DiagnosticDescriptor Descriptor { get; }
    public string Id { get; }
    internal string Category { get; }
    public DiagnosticSeverity DefaultSeverity { get; }
    public DiagnosticSeverity Severity { get; }
    public int WarningLevel { get; }
    public bool IsSuppressed { get; }
    internal bool IsEnabledByDefault { get; }
    public bool IsWarningAsError { get; }
    public Location Location { get; }
    public IReadOnlyList`1<Location> AdditionalLocations { get; }
    internal IReadOnlyList`1<string> CustomTags { get; }
    public ImmutableDictionary`2<string, string> Properties { get; }
    internal int Code { get; }
    internal IReadOnlyList`1<object> Arguments { get; }
    public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, Object[] messageArgs);
    public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, Object[] messageArgs);
    public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, IEnumerable`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    public static Diagnostic Create(DiagnosticDescriptor descriptor, Location location, DiagnosticSeverity effectiveSeverity, IEnumerable`1<Location> additionalLocations, ImmutableDictionary`2<string, string> properties, Object[] messageArgs);
    public static Diagnostic Create(string id, string category, LocalizableString message, DiagnosticSeverity severity, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, LocalizableString title, LocalizableString description, string helpLink, Location location, IEnumerable`1<Location> additionalLocations, IEnumerable`1<string> customTags, ImmutableDictionary`2<string, string> properties);
    public static Diagnostic Create(string id, string category, LocalizableString message, DiagnosticSeverity severity, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, bool isSuppressed, LocalizableString title, LocalizableString description, string helpLink, Location location, IEnumerable`1<Location> additionalLocations, IEnumerable`1<string> customTags, ImmutableDictionary`2<string, string> properties);
    internal static Diagnostic Create(CommonMessageProvider messageProvider, int errorCode);
    internal static Diagnostic Create(CommonMessageProvider messageProvider, int errorCode, Object[] arguments);
    internal static Diagnostic Create(DiagnosticInfo info);
    public abstract virtual DiagnosticDescriptor get_Descriptor();
    public abstract virtual string get_Id();
    internal virtual string get_Category();
    public abstract virtual string GetMessage(IFormatProvider formatProvider);
    public virtual DiagnosticSeverity get_DefaultSeverity();
    public abstract virtual DiagnosticSeverity get_Severity();
    public abstract virtual int get_WarningLevel();
    public abstract virtual bool get_IsSuppressed();
    public SuppressionInfo GetSuppressionInfo(Compilation compilation);
    internal virtual bool get_IsEnabledByDefault();
    public bool get_IsWarningAsError();
    public abstract virtual Location get_Location();
    public abstract virtual IReadOnlyList`1<Location> get_AdditionalLocations();
    internal virtual IReadOnlyList`1<string> get_CustomTags();
    public virtual ImmutableDictionary`2<string, string> get_Properties();
    private sealed virtual override string System.IFormattable.ToString(string ignored, IFormatProvider formatProvider);
    public virtual string ToString();
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    public abstract virtual bool Equals(Diagnostic obj);
    private string GetDebuggerDisplay();
    internal abstract virtual Diagnostic WithLocation(Location location);
    internal abstract virtual Diagnostic WithSeverity(DiagnosticSeverity severity);
    internal abstract virtual Diagnostic WithIsSuppressed(bool isSuppressed);
    internal virtual int get_Code();
    internal virtual IReadOnlyList`1<object> get_Arguments();
    internal bool HasIntersectingLocation(SyntaxTree tree, Nullable`1<TextSpan> filterSpanWithinTree);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostic/<GetDiagnosticLocationsWithinTree>d__54")]
private IEnumerable`1<Location> GetDiagnosticLocationsWithinTree(SyntaxTree tree);
    internal Diagnostic WithReportDiagnostic(ReportDiagnostic reportAction);
    internal static int GetDefaultWarningLevel(DiagnosticSeverity severity);
    internal virtual bool IsNotConfigurable();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.DiagnosticBag/DebuggerProxy")]
internal class Microsoft.CodeAnalysis.DiagnosticBag : object {
    private ConcurrentQueue`1<Diagnostic> _lazyBag;
    private static ObjectPool`1<DiagnosticBag> s_poolInstance;
    public bool IsEmptyWithoutResolution { get; }
    private ConcurrentQueue`1<Diagnostic> Bag { get; }
    private static DiagnosticBag();
    public bool get_IsEmptyWithoutResolution();
    public bool HasAnyErrors();
    internal bool HasAnyResolvedErrors();
    public void Add(Diagnostic diag);
    public void AddRange(ImmutableArray`1<T> diagnostics);
    public void AddRange(IEnumerable`1<Diagnostic> diagnostics);
    public void AddRange(DiagnosticBag bag);
    public void AddRangeAndFree(DiagnosticBag bag);
    public ImmutableArray`1<TDiagnostic> ToReadOnlyAndFree();
    public ImmutableArray`1<Diagnostic> ToReadOnlyAndFree();
    public ImmutableArray`1<TDiagnostic> ToReadOnly();
    public ImmutableArray`1<Diagnostic> ToReadOnly();
    private static ImmutableArray`1<TDiagnostic> ToReadOnlyCore(ConcurrentQueue`1<Diagnostic> oldBag);
    public IEnumerable`1<Diagnostic> AsEnumerable();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.DiagnosticBag/<AsEnumerableFiltered>d__16")]
private IEnumerable`1<Diagnostic> AsEnumerableFiltered();
    internal IEnumerable`1<Diagnostic> AsEnumerableWithoutResolution();
    public virtual string ToString();
    private ConcurrentQueue`1<Diagnostic> get_Bag();
    internal void Clear();
    internal static DiagnosticBag GetInstance();
    internal void Free();
    private static ObjectPool`1<DiagnosticBag> CreatePool(int size);
    private string GetDebuggerDisplay();
}
public class Microsoft.CodeAnalysis.DiagnosticDescriptor : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalizableString <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalizableString <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpLinkUri>k__BackingField;
    [CompilerGeneratedAttribute]
private LocalizableString <MessageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticSeverity <DefaultSeverity>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnabledByDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <CustomTags>k__BackingField;
    public string Id { get; }
    public LocalizableString Title { get; }
    public LocalizableString Description { get; }
    public string HelpLinkUri { get; }
    public LocalizableString MessageFormat { get; }
    public string Category { get; }
    public DiagnosticSeverity DefaultSeverity { get; }
    public bool IsEnabledByDefault { get; }
    public IEnumerable`1<string> CustomTags { get; }
    public DiagnosticDescriptor(string id, string title, string messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, string description, string helpLinkUri, String[] customTags);
    public DiagnosticDescriptor(string id, LocalizableString title, LocalizableString messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, LocalizableString description, string helpLinkUri, String[] customTags);
    internal DiagnosticDescriptor(string id, LocalizableString title, LocalizableString messageFormat, string category, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, LocalizableString description, string helpLinkUri, ImmutableArray`1<string> customTags);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public LocalizableString get_Title();
    [CompilerGeneratedAttribute]
public LocalizableString get_Description();
    [CompilerGeneratedAttribute]
public string get_HelpLinkUri();
    [CompilerGeneratedAttribute]
public LocalizableString get_MessageFormat();
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public DiagnosticSeverity get_DefaultSeverity();
    [CompilerGeneratedAttribute]
public bool get_IsEnabledByDefault();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_CustomTags();
    public sealed virtual bool Equals(DiagnosticDescriptor other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public ReportDiagnostic GetEffectiveSeverity(CompilationOptions compilationOptions);
    private static ReportDiagnostic MapSeverityToReport(DiagnosticSeverity severity);
    internal bool IsNotConfigurable();
}
public class Microsoft.CodeAnalysis.DiagnosticFormatter : object {
    internal static DiagnosticFormatter Instance;
    private static DiagnosticFormatter();
    public virtual string Format(Diagnostic diagnostic, IFormatProvider formatter);
    internal virtual string FormatSourcePath(string path, string basePath, IFormatProvider formatter);
    internal virtual string FormatSourceSpan(LinePositionSpan span, IFormatProvider formatter);
    internal string GetMessagePrefix(Diagnostic diagnostic);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.DiagnosticInfo : object {
    private CommonMessageProvider _messageProvider;
    private int _errorCode;
    private DiagnosticSeverity _defaultSeverity;
    private DiagnosticSeverity _effectiveSeverity;
    private Object[] _arguments;
    private static ImmutableDictionary`2<int, DiagnosticDescriptor> s_errorCodeToDescriptorMap;
    private static ImmutableArray`1<string> s_compilerErrorCustomTags;
    private static ImmutableArray`1<string> s_compilerNonErrorCustomTags;
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    public int Code { get; }
    public DiagnosticDescriptor Descriptor { get; }
    public DiagnosticSeverity Severity { get; }
    public DiagnosticSeverity DefaultSeverity { get; }
    public int WarningLevel { get; }
    public bool IsWarningAsError { get; }
    public string Category { get; }
    internal ImmutableArray`1<string> CustomTags { get; }
    public IReadOnlyList`1<Location> AdditionalLocations { get; }
    public string MessageIdentifier { get; }
    internal Object[] Arguments { get; }
    internal CommonMessageProvider MessageProvider { get; }
    private static DiagnosticInfo();
    internal DiagnosticInfo(CommonMessageProvider messageProvider, int errorCode);
    internal DiagnosticInfo(CommonMessageProvider messageProvider, int errorCode, Object[] arguments);
    private DiagnosticInfo(DiagnosticInfo original, DiagnosticSeverity overriddenSeverity);
    internal DiagnosticInfo(CommonMessageProvider messageProvider, bool isWarningAsError, int errorCode, Object[] arguments);
    protected DiagnosticInfo(ObjectReader reader);
    internal static DiagnosticDescriptor GetDescriptor(int errorCode, CommonMessageProvider messageProvider);
    private static DiagnosticDescriptor GetOrCreateDescriptor(int errorCode, DiagnosticSeverity defaultSeverity, CommonMessageProvider messageProvider);
    private static DiagnosticDescriptor CreateDescriptor(int errorCode, DiagnosticSeverity defaultSeverity, CommonMessageProvider messageProvider);
    [ConditionalAttribute("DEBUG")]
internal static void AssertMessageSerializable(Object[] args);
    internal DiagnosticInfo GetInstanceWithSeverity(DiagnosticSeverity severity);
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    protected virtual void WriteTo(ObjectWriter writer);
    public int get_Code();
    public DiagnosticDescriptor get_Descriptor();
    public DiagnosticSeverity get_Severity();
    public DiagnosticSeverity get_DefaultSeverity();
    public int get_WarningLevel();
    public bool get_IsWarningAsError();
    public string get_Category();
    internal ImmutableArray`1<string> get_CustomTags();
    private static ImmutableArray`1<string> GetCustomTags(DiagnosticSeverity defaultSeverity);
    internal bool IsNotConfigurable();
    public virtual IReadOnlyList`1<Location> get_AdditionalLocations();
    public string get_MessageIdentifier();
    public virtual string GetMessage(IFormatProvider formatProvider);
    protected Object[] GetArgumentsToUse(IFormatProvider formatProvider);
    private Object[] InitializeArgumentListIfNeeded(Object[] argumentsToUse);
    internal Object[] get_Arguments();
    internal CommonMessageProvider get_MessageProvider();
    public virtual string ToString();
    public string ToString(IFormatProvider formatProvider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    public sealed virtual int GetHashCode();
    public sealed virtual bool Equals(object obj);
    private string GetDebuggerDisplay();
    internal virtual DiagnosticInfo GetResolvedInfo();
}
public abstract class Microsoft.CodeAnalysis.Diagnostics.AnalysisContext : object {
    public abstract virtual void RegisterCompilationStartAction(Action`1<CompilationStartAnalysisContext> action);
    public abstract virtual void RegisterCompilationAction(Action`1<CompilationAnalysisContext> action);
    public abstract virtual void RegisterSemanticModelAction(Action`1<SemanticModelAnalysisContext> action);
    public void RegisterSymbolAction(Action`1<SymbolAnalysisContext> action, SymbolKind[] symbolKinds);
    public abstract virtual void RegisterSymbolAction(Action`1<SymbolAnalysisContext> action, ImmutableArray`1<SymbolKind> symbolKinds);
    public abstract virtual void RegisterCodeBlockStartAction(Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> action);
    public abstract virtual void RegisterCodeBlockAction(Action`1<CodeBlockAnalysisContext> action);
    public abstract virtual void RegisterSyntaxTreeAction(Action`1<SyntaxTreeAnalysisContext> action);
    public void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, TLanguageKindEnum[] syntaxKinds);
    public abstract virtual void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
    public virtual void RegisterOperationBlockStartAction(Action`1<OperationBlockStartAnalysisContext> action);
    public virtual void RegisterOperationBlockAction(Action`1<OperationBlockAnalysisContext> action);
    public void RegisterOperationAction(Action`1<OperationAnalysisContext> action, OperationKind[] operationKinds);
    public virtual void RegisterOperationAction(Action`1<OperationAnalysisContext> action, ImmutableArray`1<OperationKind> operationKinds);
    public virtual void EnableConcurrentExecution();
    public virtual void ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags analysisMode);
    public bool TryGetValue(SourceText text, SourceTextValueProvider`1<TValue> valueProvider, TValue& value);
    private bool TryGetValue(TKey key, AnalysisValueProvider`2<TKey, TValue> valueProvider, TValue& value);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalysisContextInfo : ValueType {
    private Compilation _compilation;
    private IOperation _operation;
    private ISymbol _symbol;
    private SyntaxTree _tree;
    private SyntaxNode _node;
    public AnalysisContextInfo(Compilation compilation);
    public AnalysisContextInfo(SemanticModel model);
    public AnalysisContextInfo(Compilation compilation, ISymbol symbol);
    public AnalysisContextInfo(Compilation compilation, SyntaxTree tree);
    public AnalysisContextInfo(Compilation compilation, SyntaxNode node);
    public AnalysisContextInfo(Compilation compilation, IOperation operation);
    public AnalysisContextInfo(Compilation compilation, ISymbol symbol, SyntaxNode node);
    public AnalysisContextInfo(Compilation compilation, IOperation operation, ISymbol symbol, SyntaxTree tree, SyntaxNode node);
    public string GetContext();
    private string GetFlattenedNodeText(SyntaxNode node);
}
public class Microsoft.CodeAnalysis.Diagnostics.AnalysisResult : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticAnalyzer> <Analyzers>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<SyntaxTree, ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>>> <SyntaxDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<SyntaxTree, ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>>> <SemanticDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>> <CompilationDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<DiagnosticAnalyzer, AnalyzerTelemetryInfo> <AnalyzerTelemetryInfo>k__BackingField;
    public ImmutableArray`1<DiagnosticAnalyzer> Analyzers { get; private set; }
    public ImmutableDictionary`2<SyntaxTree, ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>>> SyntaxDiagnostics { get; private set; }
    public ImmutableDictionary`2<SyntaxTree, ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>>> SemanticDiagnostics { get; private set; }
    public ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>> CompilationDiagnostics { get; private set; }
    public ImmutableDictionary`2<DiagnosticAnalyzer, AnalyzerTelemetryInfo> AnalyzerTelemetryInfo { get; private set; }
    internal AnalysisResult(ImmutableArray`1<DiagnosticAnalyzer> analyzers, ImmutableDictionary`2<SyntaxTree, ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>>> localSyntaxDiagnostics, ImmutableDictionary`2<SyntaxTree, ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>>> localSemanticDiagnostics, ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>> nonLocalDiagnostics, ImmutableDictionary`2<DiagnosticAnalyzer, AnalyzerTelemetryInfo> analyzerTelemetryInfo);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DiagnosticAnalyzer> get_Analyzers();
    [CompilerGeneratedAttribute]
private void set_Analyzers(ImmutableArray`1<DiagnosticAnalyzer> value);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<SyntaxTree, ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>>> get_SyntaxDiagnostics();
    [CompilerGeneratedAttribute]
private void set_SyntaxDiagnostics(ImmutableDictionary`2<SyntaxTree, ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>>> value);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<SyntaxTree, ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>>> get_SemanticDiagnostics();
    [CompilerGeneratedAttribute]
private void set_SemanticDiagnostics(ImmutableDictionary`2<SyntaxTree, ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>>> value);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>> get_CompilationDiagnostics();
    [CompilerGeneratedAttribute]
private void set_CompilationDiagnostics(ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>> value);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<DiagnosticAnalyzer, AnalyzerTelemetryInfo> get_AnalyzerTelemetryInfo();
    [CompilerGeneratedAttribute]
private void set_AnalyzerTelemetryInfo(ImmutableDictionary`2<DiagnosticAnalyzer, AnalyzerTelemetryInfo> value);
    public ImmutableArray`1<Diagnostic> GetAllDiagnostics(DiagnosticAnalyzer analyzer);
    public ImmutableArray`1<Diagnostic> GetAllDiagnostics();
    internal ImmutableArray`1<Diagnostic> GetSyntaxDiagnostics(ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    internal ImmutableArray`1<Diagnostic> GetSemanticDiagnostics(ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    internal ImmutableArray`1<Diagnostic> GetDiagnostics(IEnumerable`1<DiagnosticAnalyzer> analyzers, bool getLocalSyntaxDiagnostics, bool getLocalSemanticDiagnostics, bool getNonLocalDiagnostics);
    private ImmutableArray`1<Diagnostic> GetDiagnostics(ImmutableHashSet`1<DiagnosticAnalyzer> excludedAnalyzers, bool getLocalSyntaxDiagnostics, bool getLocalSemanticDiagnostics, bool getNonLocalDiagnostics);
    private static void AddLocalDiagnostics(ImmutableDictionary`2<SyntaxTree, ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>>> localDiagnostics, ImmutableHashSet`1<DiagnosticAnalyzer> excludedAnalyzers, Builder<Diagnostic> builder);
    private static void AddNonLocalDiagnostics(ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>> nonLocalDiagnostics, ImmutableHashSet`1<DiagnosticAnalyzer> excludedAnalyzers, Builder<Diagnostic> builder);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalysisResultBuilder : object {
    private object _gate;
    private Dictionary`2<DiagnosticAnalyzer, TimeSpan> _analyzerExecutionTimeOpt;
    private HashSet`1<DiagnosticAnalyzer> _completedAnalyzers;
    private Dictionary`2<DiagnosticAnalyzer, AnalyzerActionCounts> _analyzerActionCounts;
    private Dictionary`2<SyntaxTree, Dictionary`2<DiagnosticAnalyzer, Builder<Diagnostic>>> _localSemanticDiagnosticsOpt;
    private Dictionary`2<SyntaxTree, Dictionary`2<DiagnosticAnalyzer, Builder<Diagnostic>>> _localSyntaxDiagnosticsOpt;
    private Dictionary`2<DiagnosticAnalyzer, Builder<Diagnostic>> _nonLocalDiagnosticsOpt;
    internal AnalysisResultBuilder(bool logAnalyzerExecutionTime, ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    private static Dictionary`2<DiagnosticAnalyzer, TimeSpan> CreateAnalyzerExecutionTimeMap(ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    public TimeSpan GetAnalyzerExecutionTime(DiagnosticAnalyzer analyzer);
    internal ImmutableArray`1<DiagnosticAnalyzer> GetPendingAnalyzers(ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    internal void StoreAnalysisResult(AnalysisScope analysisScope, AnalyzerDriver driver, Compilation compilation, Func`2<DiagnosticAnalyzer, AnalyzerActionCounts> getAnalyzerActionCounts, bool fullAnalysisResultForAnalyzersInScope);
    private void UpdateLocalDiagnostics_NoLock(DiagnosticAnalyzer analyzer, ImmutableArray`1<Diagnostic> diagnostics, bool overwrite, Dictionary`2& lazyLocalDiagnostics);
    private void UpdateNonLocalDiagnostics_NoLock(DiagnosticAnalyzer analyzer, ImmutableArray`1<Diagnostic> diagnostics, bool overwrite);
    internal ImmutableArray`1<Diagnostic> GetDiagnostics(AnalysisScope analysisScope, bool getLocalDiagnostics, bool getNonLocalDiagnostics);
    private ImmutableArray`1<Diagnostic> GetDiagnostics_NoLock(AnalysisScope analysisScope, bool getLocalDiagnostics, bool getNonLocalDiagnostics);
    private static void AddAllLocalDiagnostics_NoLock(Dictionary`2<SyntaxTree, Dictionary`2<DiagnosticAnalyzer, Builder<Diagnostic>>> localDiagnostics, AnalysisScope analysisScope, Builder<Diagnostic> builder);
    private static void AddLocalDiagnosticsForPartialAnalysis_NoLock(Dictionary`2<SyntaxTree, Dictionary`2<DiagnosticAnalyzer, Builder<Diagnostic>>> localDiagnostics, AnalysisScope analysisScope, Builder<Diagnostic> builder);
    private static void AddDiagnostics_NoLock(Dictionary`2<DiagnosticAnalyzer, Builder<Diagnostic>> diagnostics, AnalysisScope analysisScope, Builder<Diagnostic> builder);
    internal AnalysisResult ToAnalysisResult(ImmutableArray`1<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    private static ImmutableDictionary`2<SyntaxTree, ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>>> GetImmutable(ImmutableHashSet`1<DiagnosticAnalyzer> analyzers, Dictionary`2<SyntaxTree, Dictionary`2<DiagnosticAnalyzer, Builder<Diagnostic>>> localDiagnosticsOpt);
    private static ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>> GetImmutable(ImmutableHashSet`1<DiagnosticAnalyzer> analyzers, Dictionary`2<DiagnosticAnalyzer, Builder<Diagnostic>> nonLocalDiagnosticsOpt);
    private ImmutableDictionary`2<DiagnosticAnalyzer, AnalyzerTelemetryInfo> GetTelemetryInfo(ImmutableArray`1<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalysisScope : object {
    [CompilerGeneratedAttribute]
private SyntaxTree <FilterTreeOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TextSpan> <FilterSpanOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticAnalyzer> <Analyzers>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SyntaxTree> <SyntaxTrees>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConcurrentAnalysis>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CategorizeDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSyntaxOnlyTreeAnalysis>k__BackingField;
    public SyntaxTree FilterTreeOpt { get; }
    public Nullable`1<TextSpan> FilterSpanOpt { get; }
    public ImmutableArray`1<DiagnosticAnalyzer> Analyzers { get; }
    public IEnumerable`1<SyntaxTree> SyntaxTrees { get; }
    public bool ConcurrentAnalysis { get; }
    public bool CategorizeDiagnostics { get; }
    public bool IsSyntaxOnlyTreeAnalysis { get; }
    public bool IsTreeAnalysis { get; }
    public AnalysisScope(Compilation compilation, ImmutableArray`1<DiagnosticAnalyzer> analyzers, bool concurrentAnalysis, bool categorizeDiagnostics);
    public AnalysisScope(ImmutableArray`1<DiagnosticAnalyzer> analyzers, SyntaxTree filterTree, Nullable`1<TextSpan> filterSpan, bool syntaxAnalysis, bool concurrentAnalysis, bool categorizeDiagnostics);
    private AnalysisScope(IEnumerable`1<SyntaxTree> trees, ImmutableArray`1<DiagnosticAnalyzer> analyzers, SyntaxTree filterTreeOpt, Nullable`1<TextSpan> filterSpanOpt, bool isSyntaxOnlyTreeAnalysis, bool concurrentAnalysis, bool categorizeDiagnostics);
    [CompilerGeneratedAttribute]
public SyntaxTree get_FilterTreeOpt();
    [CompilerGeneratedAttribute]
public Nullable`1<TextSpan> get_FilterSpanOpt();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DiagnosticAnalyzer> get_Analyzers();
    [CompilerGeneratedAttribute]
public IEnumerable`1<SyntaxTree> get_SyntaxTrees();
    [CompilerGeneratedAttribute]
public bool get_ConcurrentAnalysis();
    [CompilerGeneratedAttribute]
public bool get_CategorizeDiagnostics();
    [CompilerGeneratedAttribute]
public bool get_IsSyntaxOnlyTreeAnalysis();
    public bool get_IsTreeAnalysis();
    public AnalysisScope WithAnalyzers(ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    public static bool ShouldSkipSymbolAnalysis(SymbolDeclaredCompilationEvent symbolEvent);
    public static bool ShouldSkipDeclarationAnalysis(ISymbol symbol);
    public bool ShouldAnalyze(SyntaxTree tree);
    public bool ShouldAnalyze(ISymbol symbol);
    public bool ShouldAnalyze(SyntaxNode node);
    private bool ShouldInclude(TextSpan filterSpan);
    public bool ContainsSpan(TextSpan filterSpan);
    public bool ShouldInclude(Diagnostic diagnostic);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalysisState : object {
    private object _gate;
    private ImmutableDictionary`2<DiagnosticAnalyzer, int> _analyzerStateMap;
    private ImmutableArray`1<PerAnalyzerState> _analyzerStates;
    private Dictionary`2<SyntaxTree, HashSet`1<CompilationEvent>> _pendingSourceEvents;
    private HashSet`1<CompilationEvent> _pendingNonSourceEvents;
    private ImmutableDictionary`2<DiagnosticAnalyzer, AnalyzerActionCounts> _lazyAnalyzerActionCountsMap;
    private HashSet`1<SyntaxTree> _treesWithGeneratedSourceEvents;
    private HashSet`1<ISymbol> _partialSymbolsWithGeneratedSourceEvents;
    private CompilationData _compilationData;
    private CompilationOptions _compilationOptions;
    private bool _compilationStartGenerated;
    private bool _compilationEndGenerated;
    private ObjectPool`1<HashSet`1<CompilationEvent>> _compilationEventsPool;
    private HashSet`1<CompilationEvent> _pooledEventsWithAnyActionsSet;
    public AnalysisState(ImmutableArray`1<DiagnosticAnalyzer> analyzers, CompilationData compilationData, CompilationOptions compilationOptions);
    private static ImmutableDictionary`2<DiagnosticAnalyzer, int> CreateAnalyzerStateMap(ImmutableArray`1<DiagnosticAnalyzer> analyzers, ImmutableArray`1& analyzerStates);
    private PerAnalyzerState GetAnalyzerState(DiagnosticAnalyzer analyzer);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalysisState/<GenerateSimulatedCompilationEventsAsync>d__18")]
public Task GenerateSimulatedCompilationEventsAsync(AnalysisScope analysisScope, Compilation compilation, Func`4<SyntaxTree, Compilation, CancellationToken, SemanticModel> getCachedSemanticModel, AnalyzerDriver driver, CancellationToken cancellationToken);
    private void GenerateSimulatedCompilationSourceEvents(SyntaxTree tree, Compilation compilation, Func`4<SyntaxTree, Compilation, CancellationToken, SemanticModel> getCachedSemanticModel, AnalyzerDriver driver, CancellationToken cancellationToken);
    private ImmutableArray`1<ISymbol> GetDeclaredSymbolsInTree(SyntaxTree tree, Compilation compilation, Func`4<SyntaxTree, Compilation, CancellationToken, SemanticModel> getCachedSemanticModel, CancellationToken cancellationToken);
    private static ImmutableArray`1<CompilationEvent> CreateCompilationEventsForTree(IEnumerable`1<ISymbol> declaredSymbols, SyntaxTree tree, Compilation compilation);
    private void GenerateSimulatedCompilationNonSourceEvent(Compilation compilation, AnalyzerDriver driver, bool started, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalysisState/<OnCompilationEventsGeneratedAsync>d__23")]
public Task OnCompilationEventsGeneratedAsync(ImmutableArray`1<CompilationEvent> compilationEvents, AnalyzerDriver driver, CancellationToken cancellationToken);
    private void OnCompilationEventsGenerated_NoLock(ImmutableArray`1<CompilationEvent> compilationEvents, SyntaxTree filterTreeOpt, AnalyzerDriver driver, CancellationToken cancellationToken);
    private void AddToEventsMap_NoLock(ImmutableArray`1<CompilationEvent> compilationEvents, SyntaxTree filterTreeOpt);
    private void UpdateEventsMap_NoLock(CompilationEvent compilationEvent, bool add);
    private void AddPendingSourceEvents_NoLock(ImmutableArray`1<CompilationEvent> compilationEvents, SyntaxTree tree);
    private void AddPendingSourceEvent_NoLock(SyntaxTree tree, CompilationEvent compilationEvent);
    private void RemovePendingSourceEvent_NoLock(SyntaxTree tree, CompilationEvent compilationEvent);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalysisState/<EnsureAnalyzerActionCountsInitializedAsync>d__30")]
private Task EnsureAnalyzerActionCountsInitializedAsync(AnalyzerDriver driver, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalysisState/<GetOrComputeAnalyzerActionCountsAsync>d__31")]
internal Task`1<AnalyzerActionCounts> GetOrComputeAnalyzerActionCountsAsync(DiagnosticAnalyzer analyzer, AnalyzerDriver driver, CancellationToken cancellationToken);
    internal AnalyzerActionCounts GetAnalyzerActionCounts(DiagnosticAnalyzer analyzer);
    private static bool HasActionsForEvent(CompilationEvent compilationEvent, AnalyzerActionCounts actionCounts);
    private void OnSymbolDeclaredEventProcessed(SymbolDeclaredCompilationEvent symbolDeclaredEvent, ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    public void OnCompilationEventProcessed(CompilationEvent compilationEvent, AnalysisScope analysisScope);
    public ImmutableArray`1<CompilationEvent> GetPendingEvents(ImmutableArray`1<DiagnosticAnalyzer> analyzers, SyntaxTree tree);
    private HashSet`1<CompilationEvent> GetPendingEvents_NoLock(ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    private ImmutableArray`1<CompilationEvent> GetPendingEvents_NoLock(ImmutableArray`1<DiagnosticAnalyzer> analyzers, SyntaxTree tree);
    public ImmutableArray`1<CompilationEvent> GetPendingEvents(ImmutableArray`1<DiagnosticAnalyzer> analyzers, bool includeSourceEvents, bool includeNonSourceEvents);
    private ImmutableArray`1<CompilationEvent> GetPendingEvents_NoLock(ImmutableArray`1<DiagnosticAnalyzer> analyzers, bool includeSourceEvents, bool includeNonSourceEvents);
    private void Free(HashSet`1<CompilationEvent> events);
    public bool HasPendingSyntaxAnalysis(AnalysisScope analysisScope);
    public bool HasPendingSymbolAnalysis(AnalysisScope analysisScope);
    private ImmutableArray`1<SymbolDeclaredCompilationEvent> GetPendingSymbolDeclaredEvents(SyntaxTree tree);
    public bool TryStartProcessingEvent(CompilationEvent compilationEvent, DiagnosticAnalyzer analyzer, AnalyzerStateData& state);
    public void MarkEventComplete(CompilationEvent compilationEvent, DiagnosticAnalyzer analyzer);
    public void MarkEventComplete(CompilationEvent compilationEvent, IEnumerable`1<DiagnosticAnalyzer> analyzers);
    public bool IsEventComplete(CompilationEvent compilationEvent, DiagnosticAnalyzer analyzer);
    public bool TryStartAnalyzingSymbol(ISymbol symbol, DiagnosticAnalyzer analyzer, AnalyzerStateData& state);
    public void MarkSymbolComplete(ISymbol symbol, DiagnosticAnalyzer analyzer);
    public bool TryStartAnalyzingDeclaration(ISymbol symbol, int declarationIndex, DiagnosticAnalyzer analyzer, DeclarationAnalyzerStateData& state);
    public bool IsDeclarationComplete(ISymbol symbol, int declarationIndex);
    public bool IsDeclarationComplete(ISymbol symbol, int declarationIndex, DiagnosticAnalyzer analyzer);
    private static bool IsDeclarationComplete(ISymbol symbol, int declarationIndex, IEnumerable`1<PerAnalyzerState> analyzerStates);
    public void MarkDeclarationComplete(ISymbol symbol, int declarationIndex, DiagnosticAnalyzer analyzer);
    public void MarkDeclarationComplete(ISymbol symbol, int declarationIndex, IEnumerable`1<DiagnosticAnalyzer> analyzers);
    public void MarkDeclarationsComplete(ISymbol symbol, IEnumerable`1<DiagnosticAnalyzer> analyzers);
    public bool TryStartSyntaxAnalysis(SyntaxTree tree, DiagnosticAnalyzer analyzer, AnalyzerStateData& state);
    public void MarkSyntaxAnalysisComplete(SyntaxTree tree, DiagnosticAnalyzer analyzer);
    public void MarkSyntaxAnalysisComplete(SyntaxTree tree, IEnumerable`1<DiagnosticAnalyzer> analyzers);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalysisValueProvider`2 : object {
    private Func`2<TKey, TValue> _computeValue;
    private ConditionalWeakTable`2<TKey, WrappedValue<TKey, TValue>> _valueCache;
    private CreateValueCallback<TKey, WrappedValue<TKey, TValue>> _valueCacheCallback;
    [CompilerGeneratedAttribute]
private IEqualityComparer`1<TKey> <KeyComparer>k__BackingField;
    internal IEqualityComparer`1<TKey> KeyComparer { get; private set; }
    public AnalysisValueProvider`2(Func`2<TKey, TValue> computeValue, IEqualityComparer`1<TKey> keyComparer);
    [CompilerGeneratedAttribute]
internal IEqualityComparer`1<TKey> get_KeyComparer();
    [CompilerGeneratedAttribute]
private void set_KeyComparer(IEqualityComparer`1<TKey> value);
    private WrappedValue<TKey, TValue> ComputeValue(TKey key);
    internal bool TryGetValue(TKey key, TValue& value);
}
internal abstract class Microsoft.CodeAnalysis.Diagnostics.AnalyzerAction : object {
    private DiagnosticAnalyzer _analyzer;
    internal DiagnosticAnalyzer Analyzer { get; }
    internal AnalyzerAction(DiagnosticAnalyzer analyzer);
    internal DiagnosticAnalyzer get_Analyzer();
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerActions : object {
    private ImmutableArray`1<CompilationStartAnalyzerAction> _compilationStartActions;
    private ImmutableArray`1<CompilationAnalyzerAction> _compilationEndActions;
    private ImmutableArray`1<CompilationAnalyzerAction> _compilationActions;
    private ImmutableArray`1<SyntaxTreeAnalyzerAction> _syntaxTreeActions;
    private ImmutableArray`1<SemanticModelAnalyzerAction> _semanticModelActions;
    private ImmutableArray`1<SymbolAnalyzerAction> _symbolActions;
    private ImmutableArray`1<AnalyzerAction> _codeBlockStartActions;
    private ImmutableArray`1<CodeBlockAnalyzerAction> _codeBlockEndActions;
    private ImmutableArray`1<CodeBlockAnalyzerAction> _codeBlockActions;
    private ImmutableArray`1<OperationBlockStartAnalyzerAction> _operationBlockStartActions;
    private ImmutableArray`1<OperationBlockAnalyzerAction> _operationBlockEndActions;
    private ImmutableArray`1<OperationBlockAnalyzerAction> _operationBlockActions;
    private ImmutableArray`1<AnalyzerAction> _syntaxNodeActions;
    private ImmutableArray`1<OperationAnalyzerAction> _operationActions;
    private bool _concurrent;
    public int CompilationStartActionsCount { get; }
    public int CompilationEndActionsCount { get; }
    public int CompilationActionsCount { get; }
    public int SyntaxTreeActionsCount { get; }
    public int SemanticModelActionsCount { get; }
    public int SymbolActionsCount { get; }
    public int SyntaxNodeActionsCount { get; }
    public int OperationActionsCount { get; }
    public int OperationBlockStartActionsCount { get; }
    public int OperationBlockEndActionsCount { get; }
    public int OperationBlockActionsCount { get; }
    public int CodeBlockStartActionsCount { get; }
    public int CodeBlockEndActionsCount { get; }
    public int CodeBlockActionsCount { get; }
    public bool Concurrent { get; }
    internal ImmutableArray`1<CompilationStartAnalyzerAction> CompilationStartActions { get; }
    internal ImmutableArray`1<CompilationAnalyzerAction> CompilationEndActions { get; }
    internal ImmutableArray`1<CompilationAnalyzerAction> CompilationActions { get; }
    internal ImmutableArray`1<SyntaxTreeAnalyzerAction> SyntaxTreeActions { get; }
    internal ImmutableArray`1<SemanticModelAnalyzerAction> SemanticModelActions { get; }
    internal ImmutableArray`1<SymbolAnalyzerAction> SymbolActions { get; }
    internal ImmutableArray`1<CodeBlockAnalyzerAction> CodeBlockEndActions { get; }
    internal ImmutableArray`1<CodeBlockAnalyzerAction> CodeBlockActions { get; }
    internal ImmutableArray`1<OperationBlockAnalyzerAction> OperationBlockActions { get; }
    internal ImmutableArray`1<OperationBlockAnalyzerAction> OperationBlockEndActions { get; }
    internal ImmutableArray`1<OperationBlockStartAnalyzerAction> OperationBlockStartActions { get; }
    internal ImmutableArray`1<OperationAnalyzerAction> OperationActions { get; }
    public int get_CompilationStartActionsCount();
    public int get_CompilationEndActionsCount();
    public int get_CompilationActionsCount();
    public int get_SyntaxTreeActionsCount();
    public int get_SemanticModelActionsCount();
    public int get_SymbolActionsCount();
    public int get_SyntaxNodeActionsCount();
    public int get_OperationActionsCount();
    public int get_OperationBlockStartActionsCount();
    public int get_OperationBlockEndActionsCount();
    public int get_OperationBlockActionsCount();
    public int get_CodeBlockStartActionsCount();
    public int get_CodeBlockEndActionsCount();
    public int get_CodeBlockActionsCount();
    public bool get_Concurrent();
    internal ImmutableArray`1<CompilationStartAnalyzerAction> get_CompilationStartActions();
    internal ImmutableArray`1<CompilationAnalyzerAction> get_CompilationEndActions();
    internal ImmutableArray`1<CompilationAnalyzerAction> get_CompilationActions();
    internal ImmutableArray`1<SyntaxTreeAnalyzerAction> get_SyntaxTreeActions();
    internal ImmutableArray`1<SemanticModelAnalyzerAction> get_SemanticModelActions();
    internal ImmutableArray`1<SymbolAnalyzerAction> get_SymbolActions();
    internal ImmutableArray`1<CodeBlockAnalyzerAction> get_CodeBlockEndActions();
    internal ImmutableArray`1<CodeBlockAnalyzerAction> get_CodeBlockActions();
    internal ImmutableArray`1<CodeBlockStartAnalyzerAction`1<TLanguageKindEnum>> GetCodeBlockStartActions();
    internal ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>> GetSyntaxNodeActions();
    internal ImmutableArray`1<OperationBlockAnalyzerAction> get_OperationBlockActions();
    internal ImmutableArray`1<OperationBlockAnalyzerAction> get_OperationBlockEndActions();
    internal ImmutableArray`1<OperationBlockStartAnalyzerAction> get_OperationBlockStartActions();
    internal ImmutableArray`1<OperationAnalyzerAction> get_OperationActions();
    internal void AddCompilationStartAction(CompilationStartAnalyzerAction action);
    internal void AddCompilationEndAction(CompilationAnalyzerAction action);
    internal void AddCompilationAction(CompilationAnalyzerAction action);
    internal void AddSyntaxTreeAction(SyntaxTreeAnalyzerAction action);
    internal void AddSemanticModelAction(SemanticModelAnalyzerAction action);
    internal void AddSymbolAction(SymbolAnalyzerAction action);
    internal void AddCodeBlockStartAction(CodeBlockStartAnalyzerAction`1<TLanguageKindEnum> action);
    internal void AddCodeBlockEndAction(CodeBlockAnalyzerAction action);
    internal void AddCodeBlockAction(CodeBlockAnalyzerAction action);
    internal void AddSyntaxNodeAction(SyntaxNodeAnalyzerAction`1<TLanguageKindEnum> action);
    internal void AddOperationBlockStartAction(OperationBlockStartAnalyzerAction action);
    internal void AddOperationBlockAction(OperationBlockAnalyzerAction action);
    internal void AddOperationBlockEndAction(OperationBlockAnalyzerAction action);
    internal void AddOperationAction(OperationAnalyzerAction action);
    internal void EnableConcurrentExecution();
    public AnalyzerActions Append(AnalyzerActions otherActions);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerAnalysisContext : AnalysisContext {
    private DiagnosticAnalyzer _analyzer;
    private HostSessionStartAnalysisScope _scope;
    public AnalyzerAnalysisContext(DiagnosticAnalyzer analyzer, HostSessionStartAnalysisScope scope);
    public virtual void RegisterCompilationStartAction(Action`1<CompilationStartAnalysisContext> action);
    public virtual void RegisterCompilationAction(Action`1<CompilationAnalysisContext> action);
    public virtual void RegisterSyntaxTreeAction(Action`1<SyntaxTreeAnalysisContext> action);
    public virtual void RegisterSemanticModelAction(Action`1<SemanticModelAnalysisContext> action);
    public virtual void RegisterSymbolAction(Action`1<SymbolAnalysisContext> action, ImmutableArray`1<SymbolKind> symbolKinds);
    public virtual void RegisterCodeBlockStartAction(Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> action);
    public virtual void RegisterCodeBlockAction(Action`1<CodeBlockAnalysisContext> action);
    public virtual void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
    public virtual void RegisterOperationAction(Action`1<OperationAnalysisContext> action, ImmutableArray`1<OperationKind> operationKinds);
    public virtual void RegisterOperationBlockStartAction(Action`1<OperationBlockStartAnalysisContext> action);
    public virtual void RegisterOperationBlockAction(Action`1<OperationBlockAnalysisContext> action);
    public virtual void EnableConcurrentExecution();
    public virtual void ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags mode);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerCodeBlockStartAnalysisContext`1 : CodeBlockStartAnalysisContext`1<TLanguageKindEnum> {
    private DiagnosticAnalyzer _analyzer;
    private HostCodeBlockStartAnalysisScope`1<TLanguageKindEnum> _scope;
    internal AnalyzerCodeBlockStartAnalysisContext`1(DiagnosticAnalyzer analyzer, HostCodeBlockStartAnalysisScope`1<TLanguageKindEnum> scope, SyntaxNode codeBlock, ISymbol owningSymbol, SemanticModel semanticModel, AnalyzerOptions options, CancellationToken cancellationToken);
    public virtual void RegisterCodeBlockEndAction(Action`1<CodeBlockAnalysisContext> action);
    public virtual void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerCompilationStartAnalysisContext : CompilationStartAnalysisContext {
    private DiagnosticAnalyzer _analyzer;
    private HostCompilationStartAnalysisScope _scope;
    private CompilationAnalysisValueProviderFactory _compilationAnalysisValueProviderFactory;
    public AnalyzerCompilationStartAnalysisContext(DiagnosticAnalyzer analyzer, HostCompilationStartAnalysisScope scope, Compilation compilation, AnalyzerOptions options, CompilationAnalysisValueProviderFactory compilationAnalysisValueProviderFactory, CancellationToken cancellationToken);
    public virtual void RegisterCompilationEndAction(Action`1<CompilationAnalysisContext> action);
    public virtual void RegisterSyntaxTreeAction(Action`1<SyntaxTreeAnalysisContext> action);
    public virtual void RegisterSemanticModelAction(Action`1<SemanticModelAnalysisContext> action);
    public virtual void RegisterSymbolAction(Action`1<SymbolAnalysisContext> action, ImmutableArray`1<SymbolKind> symbolKinds);
    public virtual void RegisterCodeBlockStartAction(Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> action);
    public virtual void RegisterCodeBlockAction(Action`1<CodeBlockAnalysisContext> action);
    public virtual void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
    public virtual void RegisterOperationBlockStartAction(Action`1<OperationBlockStartAnalysisContext> action);
    public virtual void RegisterOperationBlockAction(Action`1<OperationBlockAnalysisContext> action);
    public virtual void RegisterOperationAction(Action`1<OperationAnalysisContext> action, ImmutableArray`1<OperationKind> operationKinds);
    internal virtual bool TryGetValueCore(TKey key, AnalysisValueProvider`2<TKey, TValue> valueProvider, TValue& value);
}
internal abstract class Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver : object {
    private static int MaxSymbolKind;
    private static Func`2<DiagnosticAnalyzer, bool> s_IsCompilerAnalyzerFunc;
    protected ImmutableArray`1<DiagnosticAnalyzer> analyzers;
    protected AnalyzerManager analyzerManager;
    private Func`3<SyntaxTree, CancellationToken, bool> _isGeneratedCode;
    private CancellationTokenRegistration _queueRegistration;
    protected AnalyzerExecutor analyzerExecutor;
    protected CompilationData compilationData;
    internal AnalyzerActions analyzerActions;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<ImmutableArray`1<SymbolAnalyzerAction>>> _symbolActionsByKind;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<SemanticModelAnalyzerAction>> _semanticModelActionsMap;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<SyntaxTreeAnalyzerAction>> _syntaxTreeActionsMap;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CompilationAnalyzerAction>> _compilationActionsMap;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CompilationAnalyzerAction>> _compilationEndActionsMap;
    internal static GeneratedCodeAnalysisFlags DefaultGeneratedCodeAnalysisFlags;
    private ImmutableDictionary`2<DiagnosticAnalyzer, SemaphoreSlim> _analyzerGateMap;
    private ImmutableDictionary`2<DiagnosticAnalyzer, GeneratedCodeAnalysisFlags> _generatedCodeAnalysisFlagsMap;
    private bool _treatAllCodeAsNonGeneratedCode;
    private bool _doNotAnalyzeGeneratedCode;
    private ConcurrentDictionary`2<SyntaxTree, bool> _lazyGeneratedCodeFilesMap;
    private Dictionary`2<SyntaxTree, ImmutableHashSet`1<ISymbol>> _lazyGeneratedCodeSymbolsMap;
    private ConcurrentDictionary`2<SyntaxTree, bool> _lazyTreesWithHiddenRegionsMap;
    private INamedTypeSymbol _generatedCodeAttribute;
    private Task _initializeTask;
    private bool _initializeSucceeded;
    private Task _primaryTask;
    private int _workerCount;
    [CompilerGeneratedAttribute]
private AsyncQueue`1<CompilationEvent> <CompilationEventQueue>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticQueue <DiagnosticQueue>k__BackingField;
    public AsyncQueue`1<CompilationEvent> CompilationEventQueue { get; private set; }
    public DiagnosticQueue DiagnosticQueue { get; private set; }
    public Task WhenInitializedTask { get; }
    public Task WhenCompletedTask { get; }
    internal ImmutableDictionary`2<DiagnosticAnalyzer, TimeSpan> AnalyzerExecutionTimes { get; }
    protected bool DoNotAnalyzeGeneratedCode { get; }
    protected AnalyzerDriver(ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerManager analyzerManager, Func`2<SyntaxTrivia, bool> isComment);
    private static AnalyzerDriver();
    [CompilerGeneratedAttribute]
public AsyncQueue`1<CompilationEvent> get_CompilationEventQueue();
    [CompilerGeneratedAttribute]
private void set_CompilationEventQueue(AsyncQueue`1<CompilationEvent> value);
    [CompilerGeneratedAttribute]
public DiagnosticQueue get_DiagnosticQueue();
    [CompilerGeneratedAttribute]
private void set_DiagnosticQueue(DiagnosticQueue value);
    private void Initialize(AnalyzerExecutor analyzerExecutor, DiagnosticQueue diagnosticQueue, CompilationData compilationData, CancellationToken cancellationToken);
    internal void Initialize(Compilation compilation, CompilationWithAnalyzersOptions analysisOptions, CompilationData compilationData, bool categorizeDiagnostics, CancellationToken cancellationToken);
    private SemaphoreSlim GetAnalyzerGate(DiagnosticAnalyzer analyzer);
    private bool ShouldSkipAnalysisOnGeneratedCode(ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    private bool ShouldTreatAllCodeAsNonGeneratedCode(ImmutableArray`1<DiagnosticAnalyzer> analyzers, ImmutableDictionary`2<DiagnosticAnalyzer, GeneratedCodeAnalysisFlags> generatedCodeAnalysisFlagsMap);
    private bool ShouldSkipAnalysisOnGeneratedCode(DiagnosticAnalyzer analyzer);
    private bool ShouldSuppressGeneratedCodeDiagnostic(Diagnostic diagnostic, DiagnosticAnalyzer analyzer, Compilation compilation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver/<AttachQueueAndProcessAllEventsAsync>d__44")]
internal Task AttachQueueAndProcessAllEventsAsync(AsyncQueue`1<CompilationEvent> eventQueue, AnalysisScope analysisScope, AnalysisState analysisStateOpt, CancellationToken cancellationToken);
    internal void AttachQueueAndStartProcessingEvents(AsyncQueue`1<CompilationEvent> eventQueue, AnalysisScope analysisScope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver/<ExecutePrimaryAnalysisTaskAsync>d__46")]
private Task ExecutePrimaryAnalysisTaskAsync(AnalysisScope analysisScope, AnalysisState analysisStateOpt, bool usingPrePopulatedEventQueue, CancellationToken cancellationToken);
    private static void OnDriverException(Task faultedTask, AnalyzerExecutor analyzerExecutor, ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    private void ExecuteSyntaxTreeActions(AnalysisScope analysisScope, AnalysisState analysisStateOpt, CancellationToken cancellationToken);
    public static AnalyzerDriver CreateAndAttachToCompilation(Compilation compilation, ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerOptions options, AnalyzerManager analyzerManager, Action`1<Diagnostic> addExceptionDiagnostic, bool reportAnalyzer, Compilation& newCompilation, CancellationToken cancellationToken);
    internal static AnalyzerDriver CreateAndAttachToCompilation(Compilation compilation, ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerOptions options, AnalyzerManager analyzerManager, Action`3<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, Func`2<Exception, bool> analyzerExceptionFilter, bool reportAnalyzer, Compilation& newCompilation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver/<GetDiagnosticsAsync>d__51")]
public Task`1<ImmutableArray`1<Diagnostic>> GetDiagnosticsAsync(Compilation compilation);
    public ImmutableArray`1<Diagnostic> DequeueLocalDiagnostics(DiagnosticAnalyzer analyzer, bool syntax, Compilation compilation);
    public ImmutableArray`1<Diagnostic> DequeueNonLocalDiagnostics(DiagnosticAnalyzer analyzer, Compilation compilation);
    private ImmutableArray`1<Diagnostic> FilterDiagnosticsSuppressedInSource(ImmutableArray`1<Diagnostic> diagnostics, Compilation compilation, SuppressMessageAttributeState suppressMessageState);
    private bool IsInGeneratedCode(Location location, Compilation compilation, CancellationToken cancellationToken);
    private ImmutableHashSet`1<ISymbol> GetOrComputeGeneratedCodeSymbolsInTree(SyntaxTree tree, Compilation compilation, CancellationToken cancellationToken);
    private ImmutableHashSet`1<ISymbol> ComputeGeneratedCodeSymbolsInTree(SyntaxTree tree, Compilation compilation, CancellationToken cancellationToken);
    public Task get_WhenInitializedTask();
    public Task get_WhenCompletedTask();
    internal ImmutableDictionary`2<DiagnosticAnalyzer, TimeSpan> get_AnalyzerExecutionTimes();
    internal TimeSpan ResetAnalyzerExecutionTime(DiagnosticAnalyzer analyzer);
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<ImmutableArray`1<SymbolAnalyzerAction>>> MakeSymbolActionsByKind();
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<SyntaxTreeAnalyzerAction>> MakeSyntaxTreeActionsByAnalyzer();
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<SemanticModelAnalyzerAction>> MakeSemanticModelActionsByAnalyzer();
    private static ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CompilationAnalyzerAction>> MakeCompilationActionsByAnalyzer(ImmutableArray`1<CompilationAnalyzerAction> compilationActions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver/<ProcessCompilationEventsAsync>d__69")]
private Task ProcessCompilationEventsAsync(AnalysisScope analysisScope, AnalysisState analysisStateOpt, bool prePopulatedEventQueue, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver/<ProcessCompilationEventsCoreAsync>d__70")]
private Task`1<CompilationCompletedEvent> ProcessCompilationEventsCoreAsync(AnalysisScope analysisScope, AnalysisState analysisStateOpt, bool prePopulatedEventQueue, CancellationToken cancellationToken);
    private void ProcessEvent(CompilationEvent e, AnalysisScope analysisScope, AnalysisState analysisStateOpt, CancellationToken cancellationToken);
    private bool TryProcessEventCore(CompilationEvent e, AnalysisScope analysisScope, AnalysisState analysisStateOpt, CancellationToken cancellationToken);
    private bool TryProcessSymbolDeclared(SymbolDeclaredCompilationEvent symbolEvent, AnalysisScope analysisScope, AnalysisState analysisStateOpt, CancellationToken cancellationToken);
    private bool TryExecuteSymbolActions(SymbolDeclaredCompilationEvent symbolEvent, AnalysisScope analysisScope, AnalysisState analysisStateOpt, bool isGeneratedCodeSymbol, CancellationToken cancellationToken);
    private static SyntaxNode GetTopmostNodeForAnalysis(ISymbol symbol, SyntaxReference syntaxReference, Compilation compilation);
    protected abstract virtual bool TryExecuteDeclaringReferenceActions(SymbolDeclaredCompilationEvent symbolEvent, AnalysisScope analysisScope, AnalysisState analysisStateOpt, bool isGeneratedCodeSymbol, CancellationToken cancellationToken);
    private bool TryProcessCompilationUnitCompleted(CompilationUnitCompletedEvent completedEvent, AnalysisScope analysisScope, AnalysisState analysisStateOpt, CancellationToken cancellationToken);
    private bool TryProcessCompilationStarted(CompilationStartedEvent startedEvent, AnalysisScope analysisScope, AnalysisState analysisStateOpt, CancellationToken cancellationToken);
    private bool TryProcessCompilationCompleted(CompilationCompletedEvent endEvent, AnalysisScope analysisScope, AnalysisState analysisStateOpt, CancellationToken cancellationToken);
    private bool TryExecuteCompilationActions(ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CompilationAnalyzerAction>> compilationActionsMap, CompilationEvent compilationEvent, AnalysisScope analysisScope, AnalysisState analysisStateOpt, CancellationToken cancellationToken);
    internal static Action`1<Diagnostic> GetDiagnosticSink(Action`1<Diagnostic> addDiagnosticCore, Compilation compilation);
    internal static Action`3<Diagnostic, DiagnosticAnalyzer, bool> GetDiagnosticSink(Action`3<Diagnostic, DiagnosticAnalyzer, bool> addLocalDiagnosticCore, Compilation compilation);
    internal static Action`2<Diagnostic, DiagnosticAnalyzer> GetDiagnosticSink(Action`2<Diagnostic, DiagnosticAnalyzer> addDiagnosticCore, Compilation compilation);
    private static Diagnostic GetFilteredDiagnostic(Diagnostic diagnostic, Compilation compilation);
    private static ImmutableArray`1<DiagnosticAnalyzer> GetUnsuppressedAnalyzers(ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerManager analyzerManager, AnalyzerExecutor analyzerExecutor);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver/<GetAnalyzerActionsAsync>d__86")]
private static Task`1<AnalyzerActions> GetAnalyzerActionsAsync(ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerManager analyzerManager, AnalyzerExecutor analyzerExecutor);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver/<GetAnalyzerGateMapAsync>d__87")]
private static Task`1<ImmutableDictionary`2<DiagnosticAnalyzer, SemaphoreSlim>> GetAnalyzerGateMapAsync(ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerManager analyzerManager, AnalyzerExecutor analyzerExecutor);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver/<GetGeneratedCodeAnalysisFlagsAsync>d__88")]
private static Task`1<ImmutableDictionary`2<DiagnosticAnalyzer, GeneratedCodeAnalysisFlags>> GetGeneratedCodeAnalysisFlagsAsync(ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerManager analyzerManager, AnalyzerExecutor analyzerExecutor);
    private bool IsGeneratedCodeSymbol(ISymbol symbol);
    protected bool IsGeneratedCode(SyntaxTree tree);
    protected bool get_DoNotAnalyzeGeneratedCode();
    protected bool IsGeneratedOrHiddenCodeLocation(SyntaxTree syntaxTree, TextSpan span);
    protected bool IsHiddenSourceLocation(SyntaxTree syntaxTree, TextSpan span);
    private bool HasHiddenRegions(SyntaxTree tree);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver/<GetAnalyzerActionCountsAsync>d__96")]
internal Task`1<AnalyzerActionCounts> GetAnalyzerActionCountsAsync(DiagnosticAnalyzer analyzer, CompilationOptions compilationOptions, CancellationToken cancellationToken);
    internal static bool IsDiagnosticAnalyzerSuppressed(DiagnosticAnalyzer analyzer, CompilationOptions options, AnalyzerManager analyzerManager, AnalyzerExecutor analyzerExecutor);
    private static bool IsCompilerAnalyzer(DiagnosticAnalyzer analyzer);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <AttachQueueAndStartProcessingEvents>b__45_0();
    [CompilerGeneratedAttribute]
private bool <AttachQueueAndStartProcessingEvents>b__45_1(Task c);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1 : AnalyzerDriver {
    private Func`2<SyntaxNode, TLanguageKindEnum> _getKind;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableDictionary`2<TLanguageKindEnum, ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>>>> _lazyNodeActionsByKind;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableDictionary`2<OperationKind, ImmutableArray`1<OperationAnalyzerAction>>> _lazyOperationActionsByKind;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockStartAnalyzerAction`1<TLanguageKindEnum>>> _lazyCodeBlockStartActionsByAnalyzer;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockAnalyzerAction>> _lazyCodeBlockEndActionsByAnalyzer;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockAnalyzerAction>> _lazyCodeBlockActionsByAnalyzer;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<OperationBlockStartAnalyzerAction>> _lazyOperationBlockStartActionsByAnalyzer;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<OperationBlockAnalyzerAction>> _lazyOperationBlockActionsByAnalyzer;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<OperationBlockAnalyzerAction>> _lazyOperationBlockEndActionsByAnalyzer;
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableDictionary`2<TLanguageKindEnum, ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>>>> NodeActionsByAnalyzerAndKind { get; }
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableDictionary`2<OperationKind, ImmutableArray`1<OperationAnalyzerAction>>> OperationActionsByAnalyzerAndKind { get; }
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockStartAnalyzerAction`1<TLanguageKindEnum>>> CodeBlockStartActionsByAnalyzer { get; }
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockAnalyzerAction>> CodeBlockEndActionsByAnalyzer { get; }
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockAnalyzerAction>> CodeBlockActionsByAnalyzer { get; }
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<OperationBlockStartAnalyzerAction>> OperationBlockStartActionsByAnalyzer { get; }
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<OperationBlockAnalyzerAction>> OperationBlockEndActionsByAnalyzer { get; }
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<OperationBlockAnalyzerAction>> OperationBlockActionsByAnalyzer { get; }
    internal AnalyzerDriver`1(ImmutableArray`1<DiagnosticAnalyzer> analyzers, Func`2<SyntaxNode, TLanguageKindEnum> getKind, AnalyzerManager analyzerManager, Func`2<SyntaxTrivia, bool> isComment);
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableDictionary`2<TLanguageKindEnum, ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>>>> get_NodeActionsByAnalyzerAndKind();
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableDictionary`2<OperationKind, ImmutableArray`1<OperationAnalyzerAction>>> get_OperationActionsByAnalyzerAndKind();
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockStartAnalyzerAction`1<TLanguageKindEnum>>> get_CodeBlockStartActionsByAnalyzer();
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockAnalyzerAction>> get_CodeBlockEndActionsByAnalyzer();
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<CodeBlockAnalyzerAction>> get_CodeBlockActionsByAnalyzer();
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<OperationBlockStartAnalyzerAction>> get_OperationBlockStartActionsByAnalyzer();
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<OperationBlockAnalyzerAction>> get_OperationBlockEndActionsByAnalyzer();
    private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<OperationBlockAnalyzerAction>> get_OperationBlockActionsByAnalyzer();
    private static ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<ActionType>> GetBlockActionsByAnalyzer(ImmutableDictionary`2& lazyCodeBlockActionsByAnalyzer, Func`2<AnalyzerActions, ImmutableArray`1<ActionType>> codeBlockActionsFactory, AnalyzerActions analyzerActions);
    private bool ShouldExecuteSyntaxNodeActions(AnalysisScope analysisScope);
    private bool ShouldExecuteOperationActions(AnalysisScope analysisScope);
    private bool ShouldExecuteBlockActions(ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<T0>> blockStartActions, ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<T1>> blockActions, AnalysisScope analysisScope, ISymbol symbol);
    private bool ShouldExecuteCodeBlockActions(AnalysisScope analysisScope, ISymbol symbol);
    private bool ShouldExecuteOperationBlockActions(AnalysisScope analysisScope, ISymbol symbol);
    protected virtual bool TryExecuteDeclaringReferenceActions(SymbolDeclaredCompilationEvent symbolEvent, AnalysisScope analysisScope, AnalysisState analysisStateOpt, bool isGeneratedCodeSymbol, CancellationToken cancellationToken);
    private void ClearCachedAnalysisDataIfAnalyzed(SyntaxReference declaration, ISymbol symbol, int declarationIndex, AnalysisState analysisState);
    private DeclarationAnalysisData ComputeDeclarationAnalysisData(ISymbol symbol, SyntaxReference declaration, SemanticModel semanticModel, AnalysisScope analysisScope, CancellationToken cancellationToken);
    private static void ComputeDeclarationsInNode(SemanticModel semanticModel, ISymbol declaredSymbol, SyntaxNode declaringReferenceSyntax, SyntaxNode topmostNodeForAnalysis, ArrayBuilder`1<DeclarationInfo> builder, CancellationToken cancellationToken);
    private bool TryExecuteDeclaringReferenceActions(SyntaxReference decl, int declarationIndex, SymbolDeclaredCompilationEvent symbolEvent, AnalysisScope analysisScope, AnalysisState analysisStateOpt, bool shouldExecuteSyntaxNodeActions, bool shouldExecuteOperationActions, bool shouldExecuteCodeBlockActions, bool shouldExecuteOperationBlockActions, bool isInGeneratedCode, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerDriver`1/<GetCodeBlockActions>d__38")]
private IEnumerable`1<CodeBlockAnalyzerActions<TLanguageKindEnum>> GetCodeBlockActions(AnalysisScope analysisScope);
    private static ImmutableArray`1<SyntaxNode> GetSyntaxNodesToAnalyze(SyntaxNode declaredNode, ISymbol declaredSymbol, ImmutableArray`1<DeclarationInfo> declarationsInNode, AnalysisScope analysisScope, bool isPartialDeclAnalysis, SemanticModel semanticModel, AnalyzerExecutor analyzerExecutor);
    private static bool IsEquivalentSymbol(ISymbol declaredSymbol, ISymbol otherSymbol);
    private static ImmutableArray`1<IOperation> GetOperationBlocksToAnalyze(ImmutableArray`1<SyntaxNode> executableBlocks, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ImmutableArray`1<IOperation> GetOperationsToAnalyze(ImmutableArray`1<IOperation> operationBlocks);
    [CompilerGeneratedAttribute]
private bool <ShouldExecuteOperationActions>b__28_0(DiagnosticAnalyzer analyzer);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.AnalyzerExceptionDescriptionBuilder : object {
    private static string s_separator;
    private static AnalyzerExceptionDescriptionBuilder();
    [ExtensionAttribute]
public static string CreateDiagnosticDescription(Exception exception);
    private static string GetExceptionMessage(Exception exception);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerExecutor : object {
    private static string DiagnosticCategory;
    internal static string AnalyzerExceptionDiagnosticId;
    internal static string AnalyzerDriverExceptionDiagnosticId;
    private Compilation _compilation;
    private AnalyzerOptions _analyzerOptions;
    private Action`1<Diagnostic> _addNonCategorizedDiagnosticOpt;
    private Action`3<Diagnostic, DiagnosticAnalyzer, bool> _addCategorizedLocalDiagnosticOpt;
    private Action`2<Diagnostic, DiagnosticAnalyzer> _addCategorizedNonLocalDiagnosticOpt;
    private Action`3<Exception, DiagnosticAnalyzer, Diagnostic> _onAnalyzerException;
    private Func`2<Exception, bool> _analyzerExceptionFilter;
    private AnalyzerManager _analyzerManager;
    private Func`2<DiagnosticAnalyzer, bool> _isCompilerAnalyzer;
    private Func`2<DiagnosticAnalyzer, object> _getAnalyzerGateOpt;
    private Func`2<DiagnosticAnalyzer, bool> _shouldSkipAnalysisOnGeneratedCode;
    private Func`5<Diagnostic, DiagnosticAnalyzer, Compilation, CancellationToken, bool> _shouldSuppressGeneratedCodeDiagnostic;
    private Func`3<SyntaxTree, TextSpan, bool> _isGeneratedCodeLocation;
    private ConcurrentDictionary`2<DiagnosticAnalyzer, StrongBox`1<long>> _analyzerExecutionTimeMapOpt;
    private CompilationAnalysisValueProviderFactory _compilationAnalysisValueProviderFactory;
    private CancellationToken _cancellationToken;
    private ConcurrentDictionary`2<IOperation, ControlFlowGraph> _lazyControlFlowGraphMap;
    internal Compilation Compilation { get; }
    internal AnalyzerOptions AnalyzerOptions { get; }
    internal CancellationToken CancellationToken { get; }
    internal Action`3<Exception, DiagnosticAnalyzer, Diagnostic> OnAnalyzerException { get; }
    internal ImmutableDictionary`2<DiagnosticAnalyzer, TimeSpan> AnalyzerExecutionTimes { get; }
    private AnalyzerExecutor(Compilation compilation, AnalyzerOptions analyzerOptions, Action`1<Diagnostic> addNonCategorizedDiagnosticOpt, Action`3<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, Func`2<Exception, bool> analyzerExceptionFilter, Func`2<DiagnosticAnalyzer, bool> isCompilerAnalyzer, AnalyzerManager analyzerManager, Func`2<DiagnosticAnalyzer, bool> shouldSkipAnalysisOnGeneratedCode, Func`5<Diagnostic, DiagnosticAnalyzer, Compilation, CancellationToken, bool> shouldSuppressGeneratedCodeDiagnostic, Func`3<SyntaxTree, TextSpan, bool> isGeneratedCodeLocation, Func`2<DiagnosticAnalyzer, object> getAnalyzerGateOpt, ConcurrentDictionary`2<DiagnosticAnalyzer, StrongBox`1<long>> analyzerExecutionTimeMapOpt, Action`3<Diagnostic, DiagnosticAnalyzer, bool> addCategorizedLocalDiagnosticOpt, Action`2<Diagnostic, DiagnosticAnalyzer> addCategorizedNonLocalDiagnosticOpt, CancellationToken cancellationToken);
    public static AnalyzerExecutor Create(Compilation compilation, AnalyzerOptions analyzerOptions, Action`1<Diagnostic> addNonCategorizedDiagnosticOpt, Action`3<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, Func`2<Exception, bool> analyzerExceptionFilter, Func`2<DiagnosticAnalyzer, bool> isCompilerAnalyzer, AnalyzerManager analyzerManager, Func`2<DiagnosticAnalyzer, bool> shouldSkipAnalysisOnGeneratedCode, Func`5<Diagnostic, DiagnosticAnalyzer, Compilation, CancellationToken, bool> shouldSuppressGeneratedCodeDiagnostic, Func`3<SyntaxTree, TextSpan, bool> isGeneratedCodeLocation, Func`2<DiagnosticAnalyzer, object> getAnalyzerGate, bool logExecutionTime, Action`3<Diagnostic, DiagnosticAnalyzer, bool> addCategorizedLocalDiagnosticOpt, Action`2<Diagnostic, DiagnosticAnalyzer> addCategorizedNonLocalDiagnosticOpt, CancellationToken cancellationToken);
    public static AnalyzerExecutor CreateForSupportedDiagnostics(Action`3<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, AnalyzerManager analyzerManager, CancellationToken cancellationToken);
    public AnalyzerExecutor WithCancellationToken(CancellationToken cancellationToken);
    internal Compilation get_Compilation();
    internal AnalyzerOptions get_AnalyzerOptions();
    internal CancellationToken get_CancellationToken();
    internal Action`3<Exception, DiagnosticAnalyzer, Diagnostic> get_OnAnalyzerException();
    internal ImmutableDictionary`2<DiagnosticAnalyzer, TimeSpan> get_AnalyzerExecutionTimes();
    public void ExecuteInitializeMethod(DiagnosticAnalyzer analyzer, HostSessionStartAnalysisScope sessionScope);
    public void ExecuteCompilationStartActions(ImmutableArray`1<CompilationStartAnalyzerAction> actions, HostCompilationStartAnalysisScope compilationScope);
    public bool TryExecuteCompilationActions(ImmutableArray`1<CompilationAnalyzerAction> compilationActions, DiagnosticAnalyzer analyzer, CompilationEvent compilationEvent, AnalysisScope analysisScope, AnalysisState analysisStateOpt);
    private void ExecuteCompilationActionsCore(ImmutableArray`1<CompilationAnalyzerAction> compilationActions, DiagnosticAnalyzer analyzer, AnalyzerStateData analyzerStateOpt);
    public bool TryExecuteSymbolActions(ImmutableArray`1<SymbolAnalyzerAction> symbolActions, DiagnosticAnalyzer analyzer, SymbolDeclaredCompilationEvent symbolDeclaredEvent, Func`4<ISymbol, SyntaxReference, Compilation, SyntaxNode> getTopMostNodeForAnalysis, AnalysisScope analysisScope, AnalysisState analysisStateOpt, bool isGeneratedCodeSymbol);
    private void ExecuteSymbolActionsCore(ImmutableArray`1<SymbolAnalyzerAction> symbolActions, DiagnosticAnalyzer analyzer, SymbolDeclaredCompilationEvent symbolDeclaredEvent, Func`4<ISymbol, SyntaxReference, Compilation, SyntaxNode> getTopMostNodeForAnalysis, AnalyzerStateData analyzerStateOpt, bool isGeneratedCodeSymbol);
    public bool TryExecuteSemanticModelActions(ImmutableArray`1<SemanticModelAnalyzerAction> semanticModelActions, DiagnosticAnalyzer analyzer, SemanticModel semanticModel, CompilationEvent compilationUnitCompletedEvent, AnalysisScope analysisScope, AnalysisState analysisStateOpt, bool isGeneratedCode);
    private void ExecuteSemanticModelActionsCore(ImmutableArray`1<SemanticModelAnalyzerAction> semanticModelActions, DiagnosticAnalyzer analyzer, SemanticModel semanticModel, AnalyzerStateData analyzerStateOpt, bool isGeneratedCode);
    public bool TryExecuteSyntaxTreeActions(ImmutableArray`1<SyntaxTreeAnalyzerAction> syntaxTreeActions, DiagnosticAnalyzer analyzer, SyntaxTree tree, AnalysisScope analysisScope, AnalysisState analysisStateOpt, bool isGeneratedCode);
    private void ExecuteSyntaxTreeActionsCore(ImmutableArray`1<SyntaxTreeAnalyzerAction> syntaxTreeActions, DiagnosticAnalyzer analyzer, SyntaxTree tree, AnalyzerStateData analyzerStateOpt, bool isGeneratedCode);
    private void ExecuteSyntaxNodeAction(SyntaxNodeAnalyzerAction`1<TLanguageKindEnum> syntaxNodeAction, SyntaxNode node, ISymbol containingSymbol, SemanticModel semanticModel, Action`1<Diagnostic> addDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, SyntaxNodeAnalyzerStateData analyzerStateOpt);
    private void ExecuteOperationAction(OperationAnalyzerAction operationAction, IOperation operation, ISymbol containingSymbol, SemanticModel semanticModel, Action`1<Diagnostic> addDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, OperationAnalyzerStateData analyzerStateOpt);
    public bool TryExecuteCodeBlockActions(IEnumerable`1<CodeBlockStartAnalyzerAction`1<TLanguageKindEnum>> codeBlockStartActions, IEnumerable`1<CodeBlockAnalyzerAction> codeBlockActions, IEnumerable`1<CodeBlockAnalyzerAction> codeBlockEndActions, DiagnosticAnalyzer analyzer, SyntaxNode declaredNode, ISymbol declaredSymbol, ImmutableArray`1<SyntaxNode> executableCodeBlocks, SemanticModel semanticModel, Func`2<SyntaxNode, TLanguageKindEnum> getKind, SyntaxReference declaration, int declarationIndex, AnalysisScope analysisScope, AnalysisState analysisStateOpt, bool isGeneratedCode);
    public bool TryExecuteOperationBlockActions(IEnumerable`1<OperationBlockStartAnalyzerAction> operationBlockStartActions, IEnumerable`1<OperationBlockAnalyzerAction> operationBlockActions, IEnumerable`1<OperationBlockAnalyzerAction> operationBlockEndActions, DiagnosticAnalyzer analyzer, SyntaxNode declaredNode, ISymbol declaredSymbol, ImmutableArray`1<IOperation> operationBlocks, ImmutableArray`1<IOperation> operations, SemanticModel semanticModel, SyntaxReference declaration, int declarationIndex, AnalysisScope analysisScope, AnalysisState analysisStateOpt, bool isGeneratedCode);
    private void ExecuteBlockActionsCore(IEnumerable`1<TBlockStartAction> startActions, IEnumerable`1<TBlockAction> actions, IEnumerable`1<TBlockAction> endActions, DiagnosticAnalyzer analyzer, SyntaxNode declaredNode, ISymbol declaredSymbol, ImmutableArray`1<TNode> executableBlocks, Func`2<ImmutableArray`1<TNode>, IEnumerable`1<TNode>> getNodesToAnalyze, SemanticModel semanticModel, Func`2<SyntaxNode, TLanguageKindEnum> getKind, BlockAnalyzerStateData`2<TBlockAction, TNodeStateData> analyzerStateOpt, bool isGeneratedCode);
    private void ExecuteBlockActions(PooledHashSet`1<TBlockAction> blockActions, SyntaxNode declaredNode, ISymbol declaredSymbol, SemanticModel semanticModel, ImmutableArray`1<IOperation> operationBlocks, Action`1<Diagnostic> addDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, BlockAnalyzerStateData`2<TBlockAction, TNodeStateData> analyzerStateOpt);
    internal static ImmutableDictionary`2<TLanguageKindEnum, ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>>> GetNodeActionsByKind(IEnumerable`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>> nodeActions);
    public bool TryExecuteSyntaxNodeActions(IEnumerable`1<SyntaxNode> nodesToAnalyze, IDictionary`2<TLanguageKindEnum, ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>>> nodeActionsByKind, DiagnosticAnalyzer analyzer, SemanticModel model, Func`2<SyntaxNode, TLanguageKindEnum> getKind, TextSpan filterSpan, SyntaxReference declaration, int declarationIndex, ISymbol declaredSymbol, AnalysisScope analysisScope, AnalysisState analysisStateOpt, bool isGeneratedCode);
    private void ExecuteSyntaxNodeActionsCore(IEnumerable`1<SyntaxNode> nodesToAnalyze, IDictionary`2<TLanguageKindEnum, ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>>> nodeActionsByKind, DiagnosticAnalyzer analyzer, ISymbol containingSymbol, SemanticModel model, Func`2<SyntaxNode, TLanguageKindEnum> getKind, TextSpan filterSpan, SyntaxNodeAnalyzerStateData analyzerStateOpt, bool isGeneratedCode);
    private void ExecuteSyntaxNodeActions(IEnumerable`1<SyntaxNode> nodesToAnalyze, IDictionary`2<TLanguageKindEnum, ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>>> nodeActionsByKind, DiagnosticAnalyzer analyzer, ISymbol containingSymbol, SemanticModel model, Func`2<SyntaxNode, TLanguageKindEnum> getKind, Action`1<Diagnostic> addDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, SyntaxNodeAnalyzerStateData analyzerStateOpt);
    private void ExecuteSyntaxNodeActions(SyntaxNode node, IDictionary`2<TLanguageKindEnum, ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>>> nodeActionsByKind, ISymbol containingSymbol, SemanticModel model, Func`2<SyntaxNode, TLanguageKindEnum> getKind, Action`1<Diagnostic> addDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, SyntaxNodeAnalyzerStateData analyzerStateOpt);
    internal static ImmutableDictionary`2<OperationKind, ImmutableArray`1<OperationAnalyzerAction>> GetOperationActionsByKind(IEnumerable`1<OperationAnalyzerAction> operationActions);
    public bool TryExecuteOperationActions(IEnumerable`1<IOperation> operationsToAnalyze, IDictionary`2<OperationKind, ImmutableArray`1<OperationAnalyzerAction>> operationActionsByKind, DiagnosticAnalyzer analyzer, SemanticModel model, TextSpan filterSpan, SyntaxReference declaration, int declarationIndex, ISymbol declaredSymbol, AnalysisScope analysisScope, AnalysisState analysisStateOpt, bool isGeneratedCode);
    private void ExecuteOperationActionsCore(IEnumerable`1<IOperation> operationsToAnalyze, IDictionary`2<OperationKind, ImmutableArray`1<OperationAnalyzerAction>> operationActionsByKind, DiagnosticAnalyzer analyzer, ISymbol containingSymbol, SemanticModel model, TextSpan filterSpan, OperationAnalyzerStateData analyzerStateOpt, bool isGeneratedCode);
    private void ExecuteOperationActions(IEnumerable`1<IOperation> operationsToAnalyze, IDictionary`2<OperationKind, ImmutableArray`1<OperationAnalyzerAction>> operationActionsByKind, DiagnosticAnalyzer analyzer, ISymbol containingSymbol, SemanticModel model, Action`1<Diagnostic> addDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, OperationAnalyzerStateData analyzerStateOpt);
    private void ExecuteOperationActions(IOperation operation, IDictionary`2<OperationKind, ImmutableArray`1<OperationAnalyzerAction>> operationActionsByKind, ISymbol containingSymbol, SemanticModel model, Action`1<Diagnostic> addDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, OperationAnalyzerStateData analyzerStateOpt);
    internal static bool CanHaveExecutableCodeBlock(ISymbol symbol);
    internal void ExecuteAndCatchIfThrows(DiagnosticAnalyzer analyzer, Action`1<TArg> analyze, TArg argument, Nullable`1<AnalysisContextInfo> info);
    private void ExecuteAndCatchIfThrows_NoLock(DiagnosticAnalyzer analyzer, Action`1<TArg> analyze, TArg argument, Nullable`1<AnalysisContextInfo> info);
    internal bool ExceptionFilter(Exception ex);
    internal static Diagnostic CreateAnalyzerExceptionDiagnostic(DiagnosticAnalyzer analyzer, Exception e, Nullable`1<AnalysisContextInfo> info);
    private static string CreateDiagnosticDescription(Nullable`1<AnalysisContextInfo> info, Exception e);
    internal static Diagnostic CreateDriverExceptionDiagnostic(Exception e);
    internal static DiagnosticDescriptor GetAnalyzerExceptionDiagnosticDescriptor(string id, string title, string description, string messageFormat);
    internal static bool IsAnalyzerExceptionDiagnostic(Diagnostic diagnostic);
    internal static bool AreEquivalentAnalyzerExceptionDiagnostics(Diagnostic exceptionDiagnostic, Diagnostic other);
    private bool IsSupportedDiagnostic(DiagnosticAnalyzer analyzer, Diagnostic diagnostic);
    private Action`1<Diagnostic> GetAddDiagnostic(ISymbol contextSymbol, ImmutableArray`1<SyntaxReference> cachedDeclaringReferences, DiagnosticAnalyzer analyzer, Func`4<ISymbol, SyntaxReference, Compilation, SyntaxNode> getTopMostNodeForAnalysis);
    private static Action`1<Diagnostic> GetAddDiagnostic(ISymbol contextSymbol, ImmutableArray`1<SyntaxReference> cachedDeclaringReferences, Compilation compilation, DiagnosticAnalyzer analyzer, Action`1<Diagnostic> addNonCategorizedDiagnosticOpt, Action`3<Diagnostic, DiagnosticAnalyzer, bool> addCategorizedLocalDiagnosticOpt, Action`2<Diagnostic, DiagnosticAnalyzer> addCategorizedNonLocalDiagnosticOpt, Func`4<ISymbol, SyntaxReference, Compilation, SyntaxNode> getTopMostNodeForAnalysis, Func`5<Diagnostic, DiagnosticAnalyzer, Compilation, CancellationToken, bool> shouldSuppressGeneratedCodeDiagnostic, CancellationToken cancellationToken);
    private Action`1<Diagnostic> GetAddCompilationDiagnostic(DiagnosticAnalyzer analyzer);
    private Action`1<Diagnostic> GetAddDiagnostic(SyntaxTree tree, DiagnosticAnalyzer analyzer, bool isSyntaxDiagnostic);
    private Action`1<Diagnostic> GetAddDiagnostic(SyntaxTree tree, Nullable`1<TextSpan> span, DiagnosticAnalyzer analyzer, bool isSyntaxDiagnostic);
    private static Action`1<Diagnostic> GetAddDiagnostic(SyntaxTree contextTree, Nullable`1<TextSpan> span, Compilation compilation, DiagnosticAnalyzer analyzer, bool isSyntaxDiagnostic, Action`1<Diagnostic> addNonCategorizedDiagnosticOpt, Action`3<Diagnostic, DiagnosticAnalyzer, bool> addCategorizedLocalDiagnosticOpt, Action`2<Diagnostic, DiagnosticAnalyzer> addCategorizedNonLocalDiagnosticOpt, Func`5<Diagnostic, DiagnosticAnalyzer, Compilation, CancellationToken, bool> shouldSuppressGeneratedCodeDiagnostic, CancellationToken cancellationToken);
    private static bool ShouldExecuteAction(AnalyzerStateData analyzerStateOpt, AnalyzerAction action);
    private bool ShouldExecuteNode(SyntaxNodeAnalyzerStateData analyzerStateOpt, SyntaxNode node, DiagnosticAnalyzer analyzer);
    private bool ShouldExecuteOperation(OperationAnalyzerStateData analyzerStateOpt, IOperation operation, DiagnosticAnalyzer analyzer);
    private static void SetCurrentNode(SyntaxNodeAnalyzerStateData analyzerStateOpt, SyntaxNode node);
    private static void SetCurrentOperation(OperationAnalyzerStateData analyzerStateOpt, IOperation operation);
    private static bool TryStartProcessingEvent(CompilationEvent nonSymbolCompilationEvent, DiagnosticAnalyzer analyzer, AnalysisScope analysisScope, AnalysisState analysisStateOpt, AnalyzerStateData& analyzerStateOpt);
    private static bool TryStartSyntaxAnalysis(SyntaxTree tree, DiagnosticAnalyzer analyzer, AnalysisScope analysisScope, AnalysisState analysisStateOpt, AnalyzerStateData& analyzerStateOpt);
    private static bool TryStartAnalyzingSymbol(ISymbol symbol, DiagnosticAnalyzer analyzer, AnalysisScope analysisScope, AnalysisState analysisStateOpt, AnalyzerStateData& analyzerStateOpt);
    private static bool TryStartAnalyzingDeclaration(ISymbol symbol, int declarationIndex, DiagnosticAnalyzer analyzer, AnalysisScope analysisScope, AnalysisState analysisStateOpt, DeclarationAnalyzerStateData& analyzerStateOpt);
    private static bool TryStartAnalyzingOperationReference(ISymbol symbol, int declarationIndex, DiagnosticAnalyzer analyzer, AnalysisScope analysisScope, AnalysisState analysisStateOpt, OperationAnalyzerStateData& analyzerStateOpt);
    private static bool IsEventComplete(CompilationEvent compilationEvent, DiagnosticAnalyzer analyzer, AnalysisState analysisStateOpt);
    private static bool IsDeclarationComplete(ISymbol symbol, int declarationIndex, DiagnosticAnalyzer analyzer, AnalysisState analysisStateOpt);
    internal TimeSpan ResetAnalyzerExecutionTime(DiagnosticAnalyzer analyzer);
    private ControlFlowGraph GetControlFlowGraph(IOperation operation);
}
public class Microsoft.CodeAnalysis.Diagnostics.AnalyzerFileReference : AnalyzerReference {
    private static string s_diagnosticAnalyzerAttributeNamespace;
    private string _fullPath;
    private IAnalyzerAssemblyLoader _assemblyLoader;
    private Extensions`1<DiagnosticAnalyzer> _diagnosticAnalyzers;
    private string _lazyDisplay;
    private object _lazyIdentity;
    private Assembly _lazyAssembly;
    [CompilerGeneratedAttribute]
private EventHandler`1<AnalyzerLoadFailureEventArgs> AnalyzerLoadFailed;
    public string FullPath { get; }
    public string Display { get; }
    public object Id { get; }
    public AnalyzerFileReference(string fullPath, IAnalyzerAssemblyLoader assemblyLoader);
    private static AnalyzerFileReference();
    [CompilerGeneratedAttribute]
public void add_AnalyzerLoadFailed(EventHandler`1<AnalyzerLoadFailureEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AnalyzerLoadFailed(EventHandler`1<AnalyzerLoadFailureEventArgs> value);
    public virtual ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzersForAllLanguages();
    public virtual ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzers(string language);
    public virtual string get_FullPath();
    public virtual string get_Display();
    public virtual object get_Id();
    private void InitializeDisplayAndId();
    internal void AddAnalyzers(Builder<DiagnosticAnalyzer> builder, string language);
    private static AnalyzerLoadFailureEventArgs CreateAnalyzerFailedArgs(Exception e, string typeNameOpt);
    internal ImmutableDictionary`2<string, ImmutableHashSet`1<string>> GetAnalyzerTypeNameMap();
    private static ImmutableDictionary`2<string, ImmutableHashSet`1<string>> GetAnalyzerTypeNameMap(string fullPath, AttributePredicate attributePredicate);
    private static IEnumerable`1<string> GetSupportedLanguages(TypeDefinition typeDef, PEModule peModule, AttributePredicate attributePredicate);
    private static IEnumerable`1<string> GetSupportedLanguages(PEModule peModule, CustomAttributeHandle customAttrHandle);
    private static bool IsDiagnosticAnalyzerAttribute(PEModule peModule, CustomAttributeHandle customAttrHandle);
    private static string GetFullyQualifiedTypeName(TypeDefinition typeDef, PEModule peModule);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AnalyzerReference other);
    public virtual int GetHashCode();
    public Assembly GetAssembly();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.Diagnostics.AnalyzerImageReference : AnalyzerReference {
    private ImmutableArray`1<DiagnosticAnalyzer> _analyzers;
    private string _fullPath;
    private string _display;
    private string _id;
    public string FullPath { get; }
    public string Display { get; }
    public object Id { get; }
    public AnalyzerImageReference(ImmutableArray`1<DiagnosticAnalyzer> analyzers, string fullPath, string display);
    public virtual ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzersForAllLanguages();
    public virtual ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzers(string language);
    public virtual string get_FullPath();
    public virtual string get_Display();
    public virtual object get_Id();
    private string GetDebuggerDisplay();
}
public class Microsoft.CodeAnalysis.Diagnostics.AnalyzerLoadFailureEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private FailureErrorCode <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public string TypeName { get; }
    public string Message { get; }
    public FailureErrorCode ErrorCode { get; }
    public Exception Exception { get; }
    public AnalyzerLoadFailureEventArgs(FailureErrorCode errorCode, string message, Exception exceptionOpt, string typeNameOpt);
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public FailureErrorCode get_ErrorCode();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager : object {
    private ImmutableDictionary`2<DiagnosticAnalyzer, AnalyzerExecutionContext> _analyzerExecutionContextMap;
    public AnalyzerManager(ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    public AnalyzerManager(DiagnosticAnalyzer analyzer);
    private ImmutableDictionary`2<DiagnosticAnalyzer, AnalyzerExecutionContext> CreateAnalyzerExecutionContextMap(IEnumerable`1<DiagnosticAnalyzer> analyzers);
    private AnalyzerExecutionContext GetAnalyzerExecutionContext(DiagnosticAnalyzer analyzer);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager/<GetCompilationAnalysisScopeAsync>d__6")]
private Task`1<HostCompilationStartAnalysisScope> GetCompilationAnalysisScopeAsync(DiagnosticAnalyzer analyzer, HostSessionStartAnalysisScope sessionScope, AnalyzerExecutor analyzerExecutor);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager/<GetCompilationAnalysisScopeCoreAsync>d__7")]
private Task`1<HostCompilationStartAnalysisScope> GetCompilationAnalysisScopeCoreAsync(HostSessionStartAnalysisScope sessionScope, AnalyzerExecutor analyzerExecutor, AnalyzerExecutionContext analyzerExecutionContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager/<GetSessionAnalysisScopeAsync>d__8")]
private ValueTask`1<HostSessionStartAnalysisScope> GetSessionAnalysisScopeAsync(DiagnosticAnalyzer analyzer, AnalyzerExecutor analyzerExecutor);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager/<GetSessionAnalysisScopeCoreAsync>d__9")]
private ValueTask`1<HostSessionStartAnalysisScope> GetSessionAnalysisScopeCoreAsync(DiagnosticAnalyzer analyzer, AnalyzerExecutor analyzerExecutor, AnalyzerExecutionContext analyzerExecutionContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager/<GetAnalyzerActionsAsync>d__10")]
public ValueTask`1<AnalyzerActions> GetAnalyzerActionsAsync(DiagnosticAnalyzer analyzer, AnalyzerExecutor analyzerExecutor);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager/<IsConcurrentAnalyzerAsync>d__11")]
public Task`1<bool> IsConcurrentAnalyzerAsync(DiagnosticAnalyzer analyzer, AnalyzerExecutor analyzerExecutor);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.AnalyzerManager/<GetGeneratedCodeAnalysisFlagsAsync>d__12")]
public Task`1<GeneratedCodeAnalysisFlags> GetGeneratedCodeAnalysisFlagsAsync(DiagnosticAnalyzer analyzer, AnalyzerExecutor analyzerExecutor);
    private static void ForceLocalizableStringExceptions(LocalizableString localizableString, EventHandler`1<Exception> handler);
    public ImmutableArray`1<DiagnosticDescriptor> GetSupportedDiagnosticDescriptors(DiagnosticAnalyzer analyzer, AnalyzerExecutor analyzerExecutor);
    internal bool IsSupportedDiagnostic(DiagnosticAnalyzer analyzer, Diagnostic diagnostic, Func`2<DiagnosticAnalyzer, bool> isCompilerAnalyzer, AnalyzerExecutor analyzerExecutor);
    internal bool IsDiagnosticAnalyzerSuppressed(DiagnosticAnalyzer analyzer, CompilationOptions options, Func`2<DiagnosticAnalyzer, bool> isCompilerAnalyzer, AnalyzerExecutor analyzerExecutor);
    internal static bool HasNotConfigurableTag(IEnumerable`1<string> customTags);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AnalyzerOperationBlockStartAnalysisContext : OperationBlockStartAnalysisContext {
    private DiagnosticAnalyzer _analyzer;
    private HostOperationBlockStartAnalysisScope _scope;
    internal AnalyzerOperationBlockStartAnalysisContext(DiagnosticAnalyzer analyzer, HostOperationBlockStartAnalysisScope scope, ImmutableArray`1<IOperation> operationBlocks, ISymbol owningSymbol, Compilation compilation, AnalyzerOptions options, Func`2<IOperation, ControlFlowGraph> getControlFlowGraph, CancellationToken cancellationToken);
    public virtual void RegisterOperationBlockEndAction(Action`1<OperationBlockAnalysisContext> action);
    public virtual void RegisterOperationAction(Action`1<OperationAnalysisContext> action, ImmutableArray`1<OperationKind> operationKinds);
}
public class Microsoft.CodeAnalysis.Diagnostics.AnalyzerOptions : object {
    internal static AnalyzerOptions Empty;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<AdditionalText> <AdditionalFiles>k__BackingField;
    public ImmutableArray`1<AdditionalText> AdditionalFiles { get; }
    public AnalyzerOptions(ImmutableArray`1<AdditionalText> additionalFiles);
    private static AnalyzerOptions();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<AdditionalText> get_AdditionalFiles();
    public AnalyzerOptions WithAdditionalFiles(ImmutableArray`1<AdditionalText> additionalFiles);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Microsoft.CodeAnalysis.Diagnostics.AnalyzerReference : object {
    public string FullPath { get; }
    public string Display { get; }
    public object Id { get; }
    public abstract virtual string get_FullPath();
    public virtual string get_Display();
    public abstract virtual object get_Id();
    public abstract virtual ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzersForAllLanguages();
    public abstract virtual ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzers(string language);
}
internal class Microsoft.CodeAnalysis.Diagnostics.AsyncQueue`1 : object {
    private TaskCompletionSource`1<bool> _whenCompleted;
    private Queue`1<TElement> _data;
    private Queue`1<TaskCompletionSource`1<TElement>> _waiters;
    private bool _completed;
    private bool _disallowEnqueue;
    private object SyncObject { get; }
    public int Count { get; }
    public bool IsCompleted { get; }
    public Task WhenCompletedTask { get; }
    private object get_SyncObject();
    public int get_Count();
    public void Enqueue(TElement value);
    public bool TryEnqueue(TElement value);
    private bool EnqueueCore(TElement value);
    public bool TryDequeue(TElement& d);
    public bool get_IsCompleted();
    public void Complete();
    public void PromiseNotToEnqueue();
    public bool TryComplete();
    private bool CompleteCore();
    public Task get_WhenCompletedTask();
    public Task`1<TElement> DequeueAsync(CancellationToken cancellationToken);
    private static Task`1<T> WithCancellation(Task`1<T> task, CancellationToken cancellationToken);
    private Task`1<TElement> DequeueAsyncCore();
}
public class Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalysisContext : ValueType {
    private SyntaxNode _codeBlock;
    private ISymbol _owningSymbol;
    private SemanticModel _semanticModel;
    private AnalyzerOptions _options;
    private Action`1<Diagnostic> _reportDiagnostic;
    private Func`2<Diagnostic, bool> _isSupportedDiagnostic;
    private CancellationToken _cancellationToken;
    public SyntaxNode CodeBlock { get; }
    public ISymbol OwningSymbol { get; }
    public SemanticModel SemanticModel { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    public CodeBlockAnalysisContext(SyntaxNode codeBlock, ISymbol owningSymbol, SemanticModel semanticModel, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);
    public SyntaxNode get_CodeBlock();
    public ISymbol get_OwningSymbol();
    public SemanticModel get_SemanticModel();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public void ReportDiagnostic(Diagnostic diagnostic);
}
internal class Microsoft.CodeAnalysis.Diagnostics.CodeBlockAnalyzerAction : AnalyzerAction {
    private Action`1<CodeBlockAnalysisContext> _action;
    public Action`1<CodeBlockAnalysisContext> Action { get; }
    public CodeBlockAnalyzerAction(Action`1<CodeBlockAnalysisContext> action, DiagnosticAnalyzer analyzer);
    public Action`1<CodeBlockAnalysisContext> get_Action();
}
public abstract class Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalysisContext`1 : object {
    private SyntaxNode _codeBlock;
    private ISymbol _owningSymbol;
    private SemanticModel _semanticModel;
    private AnalyzerOptions _options;
    private CancellationToken _cancellationToken;
    public SyntaxNode CodeBlock { get; }
    public ISymbol OwningSymbol { get; }
    public SemanticModel SemanticModel { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    protected CodeBlockStartAnalysisContext`1(SyntaxNode codeBlock, ISymbol owningSymbol, SemanticModel semanticModel, AnalyzerOptions options, CancellationToken cancellationToken);
    public SyntaxNode get_CodeBlock();
    public ISymbol get_OwningSymbol();
    public SemanticModel get_SemanticModel();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public abstract virtual void RegisterCodeBlockEndAction(Action`1<CodeBlockAnalysisContext> action);
    public void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, TLanguageKindEnum[] syntaxKinds);
    public abstract virtual void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
}
internal class Microsoft.CodeAnalysis.Diagnostics.CodeBlockStartAnalyzerAction`1 : AnalyzerAction {
    private Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> _action;
    public Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> Action { get; }
    public CodeBlockStartAnalyzerAction`1(Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> action, DiagnosticAnalyzer analyzer);
    public Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> get_Action();
}
public class Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisContext : ValueType {
    private Compilation _compilation;
    private AnalyzerOptions _options;
    private Action`1<Diagnostic> _reportDiagnostic;
    private Func`2<Diagnostic, bool> _isSupportedDiagnostic;
    private CompilationAnalysisValueProviderFactory _compilationAnalysisValueProviderFactoryOpt;
    private CancellationToken _cancellationToken;
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    public CompilationAnalysisContext(Compilation compilation, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);
    internal CompilationAnalysisContext(Compilation compilation, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, CompilationAnalysisValueProviderFactory compilationAnalysisValueProviderFactoryOpt, CancellationToken cancellationToken);
    public Compilation get_Compilation();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public void ReportDiagnostic(Diagnostic diagnostic);
    public bool TryGetValue(SourceText text, SourceTextValueProvider`1<TValue> valueProvider, TValue& value);
    public bool TryGetValue(SyntaxTree tree, SyntaxTreeValueProvider`1<TValue> valueProvider, TValue& value);
    private bool TryGetValue(TKey key, AnalysisValueProvider`2<TKey, TValue> valueProvider, TValue& value);
}
internal class Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisValueProvider`2 : object {
    private AnalysisValueProvider`2<TKey, TValue> _analysisValueProvider;
    private Dictionary`2<TKey, TValue> _valueMap;
    public CompilationAnalysisValueProvider`2(AnalysisValueProvider`2<TKey, TValue> analysisValueProvider);
    internal bool TryGetValue(TKey key, TValue& value);
}
internal class Microsoft.CodeAnalysis.Diagnostics.CompilationAnalysisValueProviderFactory : object {
    private Dictionary`2<object, object> _lazySharedStateProviderMap;
    public CompilationAnalysisValueProvider`2<TKey, TValue> GetValueProvider(AnalysisValueProvider`2<TKey, TValue> analysisSharedStateProvider);
}
internal class Microsoft.CodeAnalysis.Diagnostics.CompilationAnalyzerAction : AnalyzerAction {
    private Action`1<CompilationAnalysisContext> _action;
    public Action`1<CompilationAnalysisContext> Action { get; }
    public CompilationAnalyzerAction(Action`1<CompilationAnalysisContext> action, DiagnosticAnalyzer analyzer);
    public Action`1<CompilationAnalysisContext> get_Action();
}
internal class Microsoft.CodeAnalysis.Diagnostics.CompilationCompletedEvent : CompilationEvent {
    public CompilationCompletedEvent(Compilation compilation);
    public virtual string ToString();
}
internal abstract class Microsoft.CodeAnalysis.Diagnostics.CompilationEvent : object {
    [CompilerGeneratedAttribute]
private Compilation <Compilation>k__BackingField;
    public Compilation Compilation { get; }
    internal CompilationEvent(Compilation compilation);
    [CompilerGeneratedAttribute]
public Compilation get_Compilation();
    public virtual void FlushCache();
}
public abstract class Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalysisContext : object {
    private Compilation _compilation;
    private AnalyzerOptions _options;
    private CancellationToken _cancellationToken;
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    protected CompilationStartAnalysisContext(Compilation compilation, AnalyzerOptions options, CancellationToken cancellationToken);
    public Compilation get_Compilation();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public abstract virtual void RegisterCompilationEndAction(Action`1<CompilationAnalysisContext> action);
    public abstract virtual void RegisterSemanticModelAction(Action`1<SemanticModelAnalysisContext> action);
    public void RegisterSymbolAction(Action`1<SymbolAnalysisContext> action, SymbolKind[] symbolKinds);
    public abstract virtual void RegisterSymbolAction(Action`1<SymbolAnalysisContext> action, ImmutableArray`1<SymbolKind> symbolKinds);
    public abstract virtual void RegisterCodeBlockStartAction(Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> action);
    public abstract virtual void RegisterCodeBlockAction(Action`1<CodeBlockAnalysisContext> action);
    public virtual void RegisterOperationBlockStartAction(Action`1<OperationBlockStartAnalysisContext> action);
    public virtual void RegisterOperationBlockAction(Action`1<OperationBlockAnalysisContext> action);
    public abstract virtual void RegisterSyntaxTreeAction(Action`1<SyntaxTreeAnalysisContext> action);
    public void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, TLanguageKindEnum[] syntaxKinds);
    public abstract virtual void RegisterSyntaxNodeAction(Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
    public void RegisterOperationAction(Action`1<OperationAnalysisContext> action, OperationKind[] operationKinds);
    public virtual void RegisterOperationAction(Action`1<OperationAnalysisContext> action, ImmutableArray`1<OperationKind> operationKinds);
    public bool TryGetValue(SourceText text, SourceTextValueProvider`1<TValue> valueProvider, TValue& value);
    public bool TryGetValue(SyntaxTree tree, SyntaxTreeValueProvider`1<TValue> valueProvider, TValue& value);
    private bool TryGetValue(TKey key, AnalysisValueProvider`2<TKey, TValue> valueProvider, TValue& value);
    internal virtual bool TryGetValueCore(TKey key, AnalysisValueProvider`2<TKey, TValue> valueProvider, TValue& value);
}
internal class Microsoft.CodeAnalysis.Diagnostics.CompilationStartAnalyzerAction : AnalyzerAction {
    private Action`1<CompilationStartAnalysisContext> _action;
    public Action`1<CompilationStartAnalysisContext> Action { get; }
    public CompilationStartAnalyzerAction(Action`1<CompilationStartAnalysisContext> action, DiagnosticAnalyzer analyzer);
    public Action`1<CompilationStartAnalysisContext> get_Action();
}
internal class Microsoft.CodeAnalysis.Diagnostics.CompilationStartedEvent : CompilationEvent {
    public CompilationStartedEvent(Compilation compilation);
    public virtual string ToString();
}
internal class Microsoft.CodeAnalysis.Diagnostics.CompilationUnitCompletedEvent : CompilationEvent {
    private WeakReference`1<SemanticModel> _weakModel;
    [CompilerGeneratedAttribute]
private SyntaxTree <CompilationUnit>k__BackingField;
    public SemanticModel SemanticModel { get; private set; }
    public SyntaxTree CompilationUnit { get; }
    public CompilationUnitCompletedEvent(Compilation compilation, SyntaxTree compilationUnit);
    public CompilationUnitCompletedEvent(CompilationUnitCompletedEvent original, SemanticModel newSemanticModel);
    public SemanticModel get_SemanticModel();
    private void set_SemanticModel(SemanticModel value);
    public virtual void FlushCache();
    [CompilerGeneratedAttribute]
public SyntaxTree get_CompilationUnit();
    public CompilationUnitCompletedEvent WithSemanticModel(SemanticModel model);
    public virtual string ToString();
}
public class Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers : object {
    private Compilation _compilation;
    private CompilationData _compilationData;
    private ImmutableArray`1<DiagnosticAnalyzer> _analyzers;
    private CompilationWithAnalyzersOptions _analysisOptions;
    private CancellationToken _cancellationToken;
    private AnalyzerManager _analyzerManager;
    private ObjectPool`1<AnalyzerDriver> _driverPool;
    private AnalysisState _analysisState;
    private AnalysisResultBuilder _analysisResultBuilder;
    private ConcurrentSet`1<Diagnostic> _exceptionDiagnostics;
    private object _executingTasksLock;
    private Dictionary`2<SyntaxTree, Tuple`2<Task, CancellationTokenSource>> _executingConcurrentTreeTasksOpt;
    private Tuple`2<Task, CancellationTokenSource> _executingCompilationOrNonConcurrentTreeTask;
    private int _currentToken;
    private Dictionary`2<Task, int> _concurrentTreeTaskTokensOpt;
    private ObjectPool`1<AsyncQueue`1<CompilationEvent>> _eventQueuePool;
    private static AsyncQueue`1<CompilationEvent> s_EmptyEventQueue;
    public Compilation Compilation { get; }
    public ImmutableArray`1<DiagnosticAnalyzer> Analyzers { get; }
    public CompilationWithAnalyzersOptions AnalysisOptions { get; }
    public CancellationToken CancellationToken { get; }
    public CompilationWithAnalyzers(Compilation compilation, ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerOptions options, CancellationToken cancellationToken);
    public CompilationWithAnalyzers(Compilation compilation, ImmutableArray`1<DiagnosticAnalyzer> analyzers, CompilationWithAnalyzersOptions analysisOptions);
    private CompilationWithAnalyzers(Compilation compilation, ImmutableArray`1<DiagnosticAnalyzer> analyzers, CompilationWithAnalyzersOptions analysisOptions, CancellationToken cancellationToken);
    private static CompilationWithAnalyzers();
    public Compilation get_Compilation();
    public ImmutableArray`1<DiagnosticAnalyzer> get_Analyzers();
    public CompilationWithAnalyzersOptions get_AnalysisOptions();
    public CancellationToken get_CancellationToken();
    private void AddExceptionDiagnostic(Exception exception, DiagnosticAnalyzer analyzer, Diagnostic diagnostic);
    private static void VerifyArguments(Compilation compilation, ImmutableArray`1<DiagnosticAnalyzer> analyzers, CompilationWithAnalyzersOptions analysisOptions);
    private static void VerifyAnalyzersArgumentForStaticApis(ImmutableArray`1<DiagnosticAnalyzer> analyzers, bool allowDefaultOrEmpty);
    private void VerifyAnalyzersArgument(ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    private void VerifyAnalyzerArgument(DiagnosticAnalyzer analyzer);
    private static void VerifyAnalyzerArgumentForStaticApis(DiagnosticAnalyzer analyzer);
    private void VerifyExistingAnalyzersArgument(ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    private void VerifyModel(SemanticModel model);
    private void VerifyTree(SyntaxTree tree);
    public Task`1<ImmutableArray`1<Diagnostic>> GetAnalyzerDiagnosticsAsync();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalyzerDiagnosticsAsync>d__38")]
public Task`1<ImmutableArray`1<Diagnostic>> GetAnalyzerDiagnosticsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalyzerDiagnosticsAsync>d__39")]
public Task`1<ImmutableArray`1<Diagnostic>> GetAnalyzerDiagnosticsAsync(ImmutableArray`1<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalysisResultAsync>d__40")]
public Task`1<AnalysisResult> GetAnalysisResultAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalysisResultAsync>d__41")]
public Task`1<AnalysisResult> GetAnalysisResultAsync(ImmutableArray`1<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    public Task`1<ImmutableArray`1<Diagnostic>> GetAllDiagnosticsAsync();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAllDiagnosticsAsync>d__43")]
public Task`1<ImmutableArray`1<Diagnostic>> GetAllDiagnosticsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalyzerCompilationDiagnosticsAsync>d__44")]
[ObsoleteAttribute("This API was found to have performance issues and hence has been deprecated. Instead, invoke the API 'GetAnalysisResultAsync' and access the property 'CompilationDiagnostics' on the returned 'AnalysisResult' to fetch the compilation diagnostics.")]
public Task`1<ImmutableArray`1<Diagnostic>> GetAnalyzerCompilationDiagnosticsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalyzerCompilationDiagnosticsAsync>d__45")]
[ObsoleteAttribute("This API was found to have performance issues and hence has been deprecated. Instead, invoke the API 'GetAnalysisResultAsync' and access the property 'CompilationDiagnostics' on the returned 'AnalysisResult' to fetch the compilation diagnostics.")]
public Task`1<ImmutableArray`1<Diagnostic>> GetAnalyzerCompilationDiagnosticsAsync(ImmutableArray`1<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalyzerCompilationDiagnosticsCoreAsync>d__46")]
private Task`1<ImmutableArray`1<Diagnostic>> GetAnalyzerCompilationDiagnosticsCoreAsync(ImmutableArray`1<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalysisResultWithoutStateTrackingAsync>d__47")]
private Task`1<AnalysisResult> GetAnalysisResultWithoutStateTrackingAsync(ImmutableArray`1<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalyzerDiagnosticsWithoutStateTrackingAsync>d__48")]
private Task`1<ImmutableArray`1<Diagnostic>> GetAnalyzerDiagnosticsWithoutStateTrackingAsync(ImmutableArray`1<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<ComputeAnalyzerDiagnosticsWithoutStateTrackingAsync>d__49")]
private Task ComputeAnalyzerDiagnosticsWithoutStateTrackingAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAllDiagnosticsWithoutStateTrackingAsync>d__50")]
private Task`1<ImmutableArray`1<Diagnostic>> GetAllDiagnosticsWithoutStateTrackingAsync(ImmutableArray`1<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalyzerSyntaxDiagnosticsAsync>d__51")]
public Task`1<ImmutableArray`1<Diagnostic>> GetAnalyzerSyntaxDiagnosticsAsync(SyntaxTree tree, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalyzerSyntaxDiagnosticsAsync>d__52")]
public Task`1<ImmutableArray`1<Diagnostic>> GetAnalyzerSyntaxDiagnosticsAsync(SyntaxTree tree, ImmutableArray`1<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalyzerSyntaxDiagnosticsCoreAsync>d__53")]
private Task`1<ImmutableArray`1<Diagnostic>> GetAnalyzerSyntaxDiagnosticsCoreAsync(SyntaxTree tree, ImmutableArray`1<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalyzerSemanticDiagnosticsAsync>d__54")]
public Task`1<ImmutableArray`1<Diagnostic>> GetAnalyzerSemanticDiagnosticsAsync(SemanticModel model, Nullable`1<TextSpan> filterSpan, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalyzerSemanticDiagnosticsAsync>d__55")]
public Task`1<ImmutableArray`1<Diagnostic>> GetAnalyzerSemanticDiagnosticsAsync(SemanticModel model, Nullable`1<TextSpan> filterSpan, ImmutableArray`1<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalyzerSemanticDiagnosticsCoreAsync>d__56")]
private Task`1<ImmutableArray`1<Diagnostic>> GetAnalyzerSemanticDiagnosticsCoreAsync(SemanticModel model, Nullable`1<TextSpan> filterSpan, ImmutableArray`1<DiagnosticAnalyzer> analyzers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<ComputeAnalyzerDiagnosticsAsync>d__57")]
private Task ComputeAnalyzerDiagnosticsAsync(AnalysisScope analysisScope, Func`1<AsyncQueue`1<CompilationEvent>> getEventQueue, int newTaskToken, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GenerateCompilationEventsAndPopulateEventsCacheAsync>d__58")]
private Task GenerateCompilationEventsAndPopulateEventsCacheAsync(AnalysisScope analysisScope, AnalyzerDriver driver, CancellationToken cancellationToken);
    private void GenerateCompilationEvents(AnalysisScope analysisScope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<PopulateEventsCacheAsync>d__60")]
private Task PopulateEventsCacheAsync(CancellationToken cancellationToken);
    private ImmutableArray`1<CompilationEvent> DequeueGeneratedCompilationEvents();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalyzerDriverAsync>d__62")]
private Task`1<AnalyzerDriver> GetAnalyzerDriverAsync(CancellationToken cancellationToken);
    private void FreeDriver(AnalyzerDriver driver);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<ComputeAnalyzerDiagnosticsCoreAsync>d__64")]
private Task ComputeAnalyzerDiagnosticsCoreAsync(AnalyzerDriver driver, AsyncQueue`1<CompilationEvent> eventQueue, AnalysisScope analysisScope, CancellationToken cancellationToken);
    private Task`1<Task> SetActiveAnalysisTaskAsync(Func`1<Tuple`2<Task, CancellationTokenSource>> getNewAnalysisTask, SyntaxTree treeOpt, int newTaskToken, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<SetActiveCompilationAnalysisTaskAsync>d__66")]
private Task`1<Task> SetActiveCompilationAnalysisTaskAsync(Func`1<Tuple`2<Task, CancellationTokenSource>> getNewCompilationTask, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<WaitForActiveAnalysisTasksAsync>d__67")]
private Task WaitForActiveAnalysisTasksAsync(bool waitForTreeTasks, bool waitForCompilationOrNonConcurrentTask, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<SetActiveTreeAnalysisTaskAsync>d__68")]
private Task`1<Task> SetActiveTreeAnalysisTaskAsync(Func`1<Tuple`2<Task, CancellationTokenSource>> getNewTreeAnalysisTask, SyntaxTree tree, int newTaskToken, CancellationToken cancellationToken);
    private void SuspendAnalysis_NoLock(Task computeTask, CancellationTokenSource cts);
    private void ClearExecutingTask(Task computeTask, SyntaxTree treeOpt);
    private AsyncQueue`1<CompilationEvent> GetPendingEvents(ImmutableArray`1<DiagnosticAnalyzer> analyzers, SyntaxTree tree);
    private AsyncQueue`1<CompilationEvent> GetPendingEvents(ImmutableArray`1<DiagnosticAnalyzer> analyzers, bool includeSourceEvents, bool includeNonSourceEvents);
    private static void FreeEventQueue(AsyncQueue`1<CompilationEvent> eventQueue, ObjectPool`1<AsyncQueue`1<CompilationEvent>> eventQueuePool);
    public static IEnumerable`1<Diagnostic> GetEffectiveDiagnostics(IEnumerable`1<Diagnostic> diagnostics, Compilation compilation);
    public static IEnumerable`1<Diagnostic> GetEffectiveDiagnostics(ImmutableArray`1<Diagnostic> diagnostics, Compilation compilation);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetEffectiveDiagnosticsImpl>d__76")]
private static IEnumerable`1<Diagnostic> GetEffectiveDiagnosticsImpl(ImmutableArray`1<Diagnostic> diagnostics, Compilation compilation);
    public static bool IsDiagnosticAnalyzerSuppressed(DiagnosticAnalyzer analyzer, CompilationOptions options, Action`3<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException);
    [ObsoleteAttribute("This API is no longer required to be invoked. Analyzer state is automatically cleaned up when CompilationWithAnalyzers instance is released.")]
public static void ClearAnalyzerState(ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalyzerTelemetryInfoAsync>d__79")]
public Task`1<AnalyzerTelemetryInfo> GetAnalyzerTelemetryInfoAsync(DiagnosticAnalyzer analyzer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzers/<GetAnalyzerActionCountsAsync>d__80")]
private Task`1<AnalyzerActionCounts> GetAnalyzerActionCountsAsync(DiagnosticAnalyzer analyzer, CancellationToken cancellationToken);
    private TimeSpan GetAnalyzerExecutionTime(DiagnosticAnalyzer analyzer);
    [CompilerGeneratedAttribute]
private bool <VerifyAnalyzersArgument>b__31_0(DiagnosticAnalyzer a);
    [CompilerGeneratedAttribute]
private bool <VerifyExistingAnalyzersArgument>b__34_0(DiagnosticAnalyzer a);
}
public class Microsoft.CodeAnalysis.Diagnostics.CompilationWithAnalyzersOptions : object {
    private AnalyzerOptions _options;
    private Action`3<Exception, DiagnosticAnalyzer, Diagnostic> _onAnalyzerException;
    private Func`2<Exception, bool> _analyzerExceptionFilter;
    private bool _concurrentAnalysis;
    private bool _logAnalyzerExecutionTime;
    private bool _reportSuppressedDiagnostics;
    public AnalyzerOptions Options { get; }
    public Action`3<Exception, DiagnosticAnalyzer, Diagnostic> OnAnalyzerException { get; }
    public Func`2<Exception, bool> AnalyzerExceptionFilter { get; }
    public bool ConcurrentAnalysis { get; }
    public bool LogAnalyzerExecutionTime { get; }
    public bool ReportSuppressedDiagnostics { get; }
    public CompilationWithAnalyzersOptions(AnalyzerOptions options, Action`3<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime);
    public CompilationWithAnalyzersOptions(AnalyzerOptions options, Action`3<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime, bool reportSuppressedDiagnostics);
    public CompilationWithAnalyzersOptions(AnalyzerOptions options, Action`3<Exception, DiagnosticAnalyzer, Diagnostic> onAnalyzerException, bool concurrentAnalysis, bool logAnalyzerExecutionTime, bool reportSuppressedDiagnostics, Func`2<Exception, bool> analyzerExceptionFilter);
    public AnalyzerOptions get_Options();
    public Action`3<Exception, DiagnosticAnalyzer, Diagnostic> get_OnAnalyzerException();
    public Func`2<Exception, bool> get_AnalyzerExceptionFilter();
    public bool get_ConcurrentAnalysis();
    public bool get_LogAnalyzerExecutionTime();
    public bool get_ReportSuppressedDiagnostics();
}
internal abstract class Microsoft.CodeAnalysis.Diagnostics.CompilerDiagnosticAnalyzer : DiagnosticAnalyzer {
    private static string Origin;
    private static string Syntactic;
    private static string Declaration;
    private static ImmutableDictionary`2<string, string> s_syntactic;
    private static ImmutableDictionary`2<string, string> s_declaration;
    internal CommonMessageProvider MessageProvider { get; }
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static CompilerDiagnosticAnalyzer();
    internal abstract virtual CommonMessageProvider get_MessageProvider();
    internal abstract virtual ImmutableArray`1<int> GetSupportedErrorCodes();
    public sealed virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
}
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalysisContextHelpers : object {
    internal static void VerifyArguments(Action`1<TContext> action);
    internal static void VerifyArguments(Action`1<TContext> action, ImmutableArray`1<SymbolKind> symbolKinds);
    internal static void VerifyArguments(Action`1<TContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
    internal static void VerifyArguments(Diagnostic diagnostic, Compilation compilationOpt, Func`2<Diagnostic, bool> isSupportedDiagnostic);
    internal static void VerifyDiagnosticLocationsInCompilation(Diagnostic diagnostic, Compilation compilation);
    private static void VerifyDiagnosticLocationInCompilation(string id, Location location, Compilation compilation);
    private static void VerifyAction(Action`1<TContext> action);
    private static void VerifySymbolKinds(ImmutableArray`1<SymbolKind> symbolKinds);
    private static void VerifySyntaxKinds(ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
    internal static void VerifyArguments(TKey key, AnalysisValueProvider`2<TKey, TValue> valueProvider);
    internal static ControlFlowGraph GetControlFlowGraph(IOperation operation, Func`2<IOperation, ControlFlowGraph> getControlFlowGraphOpt, CancellationToken cancellationToken);
}
public abstract class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzer : object {
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    public abstract virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public abstract virtual void Initialize(AnalysisContext context);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual string ToString();
}
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Languages>k__BackingField;
    public String[] Languages { get; }
    public DiagnosticAnalyzerAttribute(string firstLanguage, String[] additionalLanguages);
    [CompilerGeneratedAttribute]
public String[] get_Languages();
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions : object {
    [ExtensionAttribute]
public static CompilationWithAnalyzers WithAnalyzers(Compilation compilation, ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalyzerOptions options, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static CompilationWithAnalyzers WithAnalyzers(Compilation compilation, ImmutableArray`1<DiagnosticAnalyzer> analyzers, CompilationWithAnalyzersOptions analysisOptions);
}
internal abstract class Microsoft.CodeAnalysis.Diagnostics.DiagnosticQueue : object {
    public abstract virtual bool TryComplete();
    public abstract virtual bool TryDequeue(Diagnostic& d);
    public abstract virtual void Enqueue(Diagnostic diagnostic);
    public abstract virtual void EnqueueLocal(Diagnostic diagnostic, DiagnosticAnalyzer analyzer, bool isSyntaxDiagnostic);
    public abstract virtual void EnqueueNonLocal(Diagnostic diagnostic, DiagnosticAnalyzer analyzer);
    public abstract virtual ImmutableArray`1<Diagnostic> DequeueLocalSyntaxDiagnostics(DiagnosticAnalyzer analyzer);
    public abstract virtual ImmutableArray`1<Diagnostic> DequeueLocalSemanticDiagnostics(DiagnosticAnalyzer analyzer);
    public abstract virtual ImmutableArray`1<Diagnostic> DequeueNonLocalDiagnostics(DiagnosticAnalyzer analyzer);
    public static DiagnosticQueue Create(bool categorized);
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.Diagnostics.GeneratedCodeAnalysisFlags : Enum {
    public int value__;
    public static GeneratedCodeAnalysisFlags None;
    public static GeneratedCodeAnalysisFlags Analyze;
    public static GeneratedCodeAnalysisFlags ReportDiagnostics;
}
internal abstract class Microsoft.CodeAnalysis.Diagnostics.HostAnalysisScope : object {
    private ImmutableArray`1<CompilationAnalyzerAction> _compilationActions;
    private ImmutableArray`1<CompilationAnalyzerAction> _compilationEndActions;
    private ImmutableArray`1<SemanticModelAnalyzerAction> _semanticModelActions;
    private ImmutableArray`1<SyntaxTreeAnalyzerAction> _syntaxTreeActions;
    private ImmutableArray`1<SymbolAnalyzerAction> _symbolActions;
    private ImmutableArray`1<AnalyzerAction> _codeBlockStartActions;
    private ImmutableArray`1<CodeBlockAnalyzerAction> _codeBlockEndActions;
    private ImmutableArray`1<CodeBlockAnalyzerAction> _codeBlockActions;
    private ImmutableArray`1<AnalyzerAction> _syntaxNodeActions;
    private ImmutableArray`1<OperationBlockStartAnalyzerAction> _operationBlockStartActions;
    private ImmutableArray`1<OperationBlockAnalyzerAction> _operationBlockEndActions;
    private ImmutableArray`1<OperationBlockAnalyzerAction> _operationBlockActions;
    private ImmutableArray`1<OperationAnalyzerAction> _operationActions;
    private Dictionary`2<DiagnosticAnalyzer, AnalyzerActions> _analyzerActions;
    public ImmutableArray`1<CompilationAnalyzerAction> CompilationActions { get; }
    public ImmutableArray`1<CompilationAnalyzerAction> CompilationEndActions { get; }
    public ImmutableArray`1<SemanticModelAnalyzerAction> SemanticModelActions { get; }
    public ImmutableArray`1<SyntaxTreeAnalyzerAction> SyntaxTreeActions { get; }
    public ImmutableArray`1<SymbolAnalyzerAction> SymbolActions { get; }
    public ImmutableArray`1<CodeBlockAnalyzerAction> CodeBlockEndActions { get; }
    public ImmutableArray`1<CodeBlockAnalyzerAction> CodeBlockActions { get; }
    public bool HasCodeBlockEndActions { get; }
    public bool HasCodeBlockActions { get; }
    public ImmutableArray`1<OperationAnalyzerAction> OperationActions { get; }
    public ImmutableArray`1<CompilationAnalyzerAction> get_CompilationActions();
    public virtual ImmutableArray`1<CompilationAnalyzerAction> get_CompilationEndActions();
    public virtual ImmutableArray`1<SemanticModelAnalyzerAction> get_SemanticModelActions();
    public virtual ImmutableArray`1<SyntaxTreeAnalyzerAction> get_SyntaxTreeActions();
    public virtual ImmutableArray`1<SymbolAnalyzerAction> get_SymbolActions();
    public virtual ImmutableArray`1<CodeBlockAnalyzerAction> get_CodeBlockEndActions();
    public virtual ImmutableArray`1<CodeBlockAnalyzerAction> get_CodeBlockActions();
    public virtual bool get_HasCodeBlockEndActions();
    public virtual bool get_HasCodeBlockActions();
    public virtual bool HasCodeBlockStartActions();
    public virtual ImmutableArray`1<CodeBlockStartAnalyzerAction`1<TLanguageKindEnum>> GetCodeBlockStartActions();
    public virtual ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>> GetSyntaxNodeActions();
    public virtual ImmutableArray`1<OperationAnalyzerAction> get_OperationActions();
    public virtual AnalyzerActions GetAnalyzerActions(DiagnosticAnalyzer analyzer);
    public void RegisterCompilationAction(DiagnosticAnalyzer analyzer, Action`1<CompilationAnalysisContext> action);
    public void RegisterCompilationEndAction(DiagnosticAnalyzer analyzer, Action`1<CompilationAnalysisContext> action);
    public void RegisterSemanticModelAction(DiagnosticAnalyzer analyzer, Action`1<SemanticModelAnalysisContext> action);
    public void RegisterSyntaxTreeAction(DiagnosticAnalyzer analyzer, Action`1<SyntaxTreeAnalysisContext> action);
    public void RegisterSymbolAction(DiagnosticAnalyzer analyzer, Action`1<SymbolAnalysisContext> action, ImmutableArray`1<SymbolKind> symbolKinds);
    public void RegisterCodeBlockStartAction(DiagnosticAnalyzer analyzer, Action`1<CodeBlockStartAnalysisContext`1<TLanguageKindEnum>> action);
    public void RegisterCodeBlockEndAction(DiagnosticAnalyzer analyzer, Action`1<CodeBlockAnalysisContext> action);
    public void RegisterCodeBlockAction(DiagnosticAnalyzer analyzer, Action`1<CodeBlockAnalysisContext> action);
    public void RegisterSyntaxNodeAction(DiagnosticAnalyzer analyzer, Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
    public void RegisterOperationBlockStartAction(DiagnosticAnalyzer analyzer, Action`1<OperationBlockStartAnalysisContext> action);
    public void RegisterOperationBlockEndAction(DiagnosticAnalyzer analyzer, Action`1<OperationBlockAnalysisContext> action);
    public void RegisterOperationBlockAction(DiagnosticAnalyzer analyzer, Action`1<OperationBlockAnalysisContext> action);
    public void RegisterOperationAction(DiagnosticAnalyzer analyzer, Action`1<OperationAnalysisContext> action, ImmutableArray`1<OperationKind> operationKinds);
    protected AnalyzerActions GetOrCreateAnalyzerActions(DiagnosticAnalyzer analyzer);
}
internal class Microsoft.CodeAnalysis.Diagnostics.HostCodeBlockStartAnalysisScope`1 : object {
    private ImmutableArray`1<CodeBlockAnalyzerAction> _codeBlockEndActions;
    private ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>> _syntaxNodeActions;
    public ImmutableArray`1<CodeBlockAnalyzerAction> CodeBlockEndActions { get; }
    public ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>> SyntaxNodeActions { get; }
    public ImmutableArray`1<CodeBlockAnalyzerAction> get_CodeBlockEndActions();
    public ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>> get_SyntaxNodeActions();
    public void RegisterCodeBlockEndAction(DiagnosticAnalyzer analyzer, Action`1<CodeBlockAnalysisContext> action);
    public void RegisterSyntaxNodeAction(DiagnosticAnalyzer analyzer, Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> syntaxKinds);
}
internal class Microsoft.CodeAnalysis.Diagnostics.HostCompilationStartAnalysisScope : HostAnalysisScope {
    private HostSessionStartAnalysisScope _sessionScope;
    public ImmutableArray`1<CompilationAnalyzerAction> CompilationEndActions { get; }
    public ImmutableArray`1<SemanticModelAnalyzerAction> SemanticModelActions { get; }
    public ImmutableArray`1<SyntaxTreeAnalyzerAction> SyntaxTreeActions { get; }
    public ImmutableArray`1<SymbolAnalyzerAction> SymbolActions { get; }
    public ImmutableArray`1<CodeBlockAnalyzerAction> CodeBlockEndActions { get; }
    public ImmutableArray`1<CodeBlockAnalyzerAction> CodeBlockActions { get; }
    public bool HasCodeBlockEndActions { get; }
    public bool HasCodeBlockActions { get; }
    public ImmutableArray`1<OperationAnalyzerAction> OperationActions { get; }
    public HostCompilationStartAnalysisScope(HostSessionStartAnalysisScope sessionScope);
    public virtual ImmutableArray`1<CompilationAnalyzerAction> get_CompilationEndActions();
    public virtual ImmutableArray`1<SemanticModelAnalyzerAction> get_SemanticModelActions();
    public virtual ImmutableArray`1<SyntaxTreeAnalyzerAction> get_SyntaxTreeActions();
    public virtual ImmutableArray`1<SymbolAnalyzerAction> get_SymbolActions();
    public virtual ImmutableArray`1<CodeBlockAnalyzerAction> get_CodeBlockEndActions();
    public virtual ImmutableArray`1<CodeBlockAnalyzerAction> get_CodeBlockActions();
    public virtual bool get_HasCodeBlockEndActions();
    public virtual bool get_HasCodeBlockActions();
    public virtual bool HasCodeBlockStartActions();
    public virtual ImmutableArray`1<CodeBlockStartAnalyzerAction`1<TLanguageKindEnum>> GetCodeBlockStartActions();
    public virtual ImmutableArray`1<SyntaxNodeAnalyzerAction`1<TLanguageKindEnum>> GetSyntaxNodeActions();
    public virtual ImmutableArray`1<OperationAnalyzerAction> get_OperationActions();
    public virtual AnalyzerActions GetAnalyzerActions(DiagnosticAnalyzer analyzer);
    public AnalyzerActions GetCompilationOnlyAnalyzerActions(DiagnosticAnalyzer analyzer);
}
internal class Microsoft.CodeAnalysis.Diagnostics.HostOperationBlockStartAnalysisScope : object {
    private ImmutableArray`1<OperationBlockAnalyzerAction> _operationBlockEndActions;
    private ImmutableArray`1<OperationAnalyzerAction> _operationActions;
    public ImmutableArray`1<OperationBlockAnalyzerAction> OperationBlockEndActions { get; }
    public ImmutableArray`1<OperationAnalyzerAction> OperationActions { get; }
    public ImmutableArray`1<OperationBlockAnalyzerAction> get_OperationBlockEndActions();
    public ImmutableArray`1<OperationAnalyzerAction> get_OperationActions();
    public void RegisterOperationBlockEndAction(DiagnosticAnalyzer analyzer, Action`1<OperationBlockAnalysisContext> action);
    public void RegisterOperationAction(DiagnosticAnalyzer analyzer, Action`1<OperationAnalysisContext> action, ImmutableArray`1<OperationKind> operationKinds);
}
internal class Microsoft.CodeAnalysis.Diagnostics.HostSessionStartAnalysisScope : HostAnalysisScope {
    private ImmutableArray`1<CompilationStartAnalyzerAction> _compilationStartActions;
    private ImmutableHashSet`1<DiagnosticAnalyzer> _concurrentAnalyzers;
    private ConcurrentDictionary`2<DiagnosticAnalyzer, GeneratedCodeAnalysisFlags> _generatedCodeConfigurationMap;
    public ImmutableArray`1<CompilationStartAnalyzerAction> CompilationStartActions { get; }
    public ImmutableArray`1<CompilationStartAnalyzerAction> get_CompilationStartActions();
    public bool IsConcurrentAnalyzer(DiagnosticAnalyzer analyzer);
    public GeneratedCodeAnalysisFlags GetGeneratedCodeAnalysisFlags(DiagnosticAnalyzer analyzer);
    public void RegisterCompilationStartAction(DiagnosticAnalyzer analyzer, Action`1<CompilationStartAnalysisContext> action);
    public void EnableConcurrentExecution(DiagnosticAnalyzer analyzer);
    public void ConfigureGeneratedCodeAnalysis(DiagnosticAnalyzer analyzer, GeneratedCodeAnalysisFlags mode);
}
public class Microsoft.CodeAnalysis.Diagnostics.OperationAnalysisContext : ValueType {
    private IOperation _operation;
    private ISymbol _containingSymbol;
    private Compilation _compilation;
    private AnalyzerOptions _options;
    private Action`1<Diagnostic> _reportDiagnostic;
    private Func`2<Diagnostic, bool> _isSupportedDiagnostic;
    private Func`2<IOperation, ControlFlowGraph> _getControlFlowGraphOpt;
    private CancellationToken _cancellationToken;
    public IOperation Operation { get; }
    public ISymbol ContainingSymbol { get; }
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    public OperationAnalysisContext(IOperation operation, ISymbol containingSymbol, Compilation compilation, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);
    internal OperationAnalysisContext(IOperation operation, ISymbol containingSymbol, Compilation compilation, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, Func`2<IOperation, ControlFlowGraph> getControlFlowGraph, CancellationToken cancellationToken);
    public IOperation get_Operation();
    public ISymbol get_ContainingSymbol();
    public Compilation get_Compilation();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public void ReportDiagnostic(Diagnostic diagnostic);
    public ControlFlowGraph GetControlFlowGraph();
}
internal class Microsoft.CodeAnalysis.Diagnostics.OperationAnalyzerAction : AnalyzerAction {
    private Action`1<OperationAnalysisContext> _action;
    private ImmutableArray`1<OperationKind> _kinds;
    public Action`1<OperationAnalysisContext> Action { get; }
    public ImmutableArray`1<OperationKind> Kinds { get; }
    public OperationAnalyzerAction(Action`1<OperationAnalysisContext> action, ImmutableArray`1<OperationKind> kinds, DiagnosticAnalyzer analyzer);
    public Action`1<OperationAnalysisContext> get_Action();
    public ImmutableArray`1<OperationKind> get_Kinds();
}
public class Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalysisContext : ValueType {
    private ImmutableArray`1<IOperation> _operationBlocks;
    private ISymbol _owningSymbol;
    private Compilation _compilation;
    private AnalyzerOptions _options;
    private Action`1<Diagnostic> _reportDiagnostic;
    private Func`2<Diagnostic, bool> _isSupportedDiagnostic;
    private Func`2<IOperation, ControlFlowGraph> _getControlFlowGraphOpt;
    private CancellationToken _cancellationToken;
    public ImmutableArray`1<IOperation> OperationBlocks { get; }
    public ISymbol OwningSymbol { get; }
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    public OperationBlockAnalysisContext(ImmutableArray`1<IOperation> operationBlocks, ISymbol owningSymbol, Compilation compilation, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);
    internal OperationBlockAnalysisContext(ImmutableArray`1<IOperation> operationBlocks, ISymbol owningSymbol, Compilation compilation, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, Func`2<IOperation, ControlFlowGraph> getControlFlowGraph, CancellationToken cancellationToken);
    public ImmutableArray`1<IOperation> get_OperationBlocks();
    public ISymbol get_OwningSymbol();
    public Compilation get_Compilation();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public void ReportDiagnostic(Diagnostic diagnostic);
    public ControlFlowGraph GetControlFlowGraph(IOperation operationBlock);
}
internal class Microsoft.CodeAnalysis.Diagnostics.OperationBlockAnalyzerAction : AnalyzerAction {
    private Action`1<OperationBlockAnalysisContext> _action;
    public Action`1<OperationBlockAnalysisContext> Action { get; }
    public OperationBlockAnalyzerAction(Action`1<OperationBlockAnalysisContext> action, DiagnosticAnalyzer analyzer);
    public Action`1<OperationBlockAnalysisContext> get_Action();
}
public abstract class Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalysisContext : object {
    private ImmutableArray`1<IOperation> _operationBlocks;
    private ISymbol _owningSymbol;
    private Compilation _compilation;
    private AnalyzerOptions _options;
    private Func`2<IOperation, ControlFlowGraph> _getControlFlowGraphOpt;
    private CancellationToken _cancellationToken;
    public ImmutableArray`1<IOperation> OperationBlocks { get; }
    public ISymbol OwningSymbol { get; }
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    protected OperationBlockStartAnalysisContext(ImmutableArray`1<IOperation> operationBlocks, ISymbol owningSymbol, Compilation compilation, AnalyzerOptions options, CancellationToken cancellationToken);
    internal OperationBlockStartAnalysisContext(ImmutableArray`1<IOperation> operationBlocks, ISymbol owningSymbol, Compilation compilation, AnalyzerOptions options, Func`2<IOperation, ControlFlowGraph> getControlFlowGraph, CancellationToken cancellationToken);
    public ImmutableArray`1<IOperation> get_OperationBlocks();
    public ISymbol get_OwningSymbol();
    public Compilation get_Compilation();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public abstract virtual void RegisterOperationBlockEndAction(Action`1<OperationBlockAnalysisContext> action);
    public void RegisterOperationAction(Action`1<OperationAnalysisContext> action, OperationKind[] operationKinds);
    public abstract virtual void RegisterOperationAction(Action`1<OperationAnalysisContext> action, ImmutableArray`1<OperationKind> operationKinds);
    public ControlFlowGraph GetControlFlowGraph(IOperation operationBlock);
}
internal class Microsoft.CodeAnalysis.Diagnostics.OperationBlockStartAnalyzerAction : AnalyzerAction {
    private Action`1<OperationBlockStartAnalysisContext> _action;
    public Action`1<OperationBlockStartAnalysisContext> Action { get; }
    public OperationBlockStartAnalyzerAction(Action`1<OperationBlockStartAnalysisContext> action, DiagnosticAnalyzer analyzer);
    public Action`1<OperationBlockStartAnalysisContext> get_Action();
}
public class Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalysisContext : ValueType {
    private SemanticModel _semanticModel;
    private AnalyzerOptions _options;
    private Action`1<Diagnostic> _reportDiagnostic;
    private Func`2<Diagnostic, bool> _isSupportedDiagnostic;
    private CancellationToken _cancellationToken;
    public SemanticModel SemanticModel { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    public SemanticModelAnalysisContext(SemanticModel semanticModel, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);
    public SemanticModel get_SemanticModel();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public void ReportDiagnostic(Diagnostic diagnostic);
}
internal class Microsoft.CodeAnalysis.Diagnostics.SemanticModelAnalyzerAction : AnalyzerAction {
    private Action`1<SemanticModelAnalysisContext> _action;
    public Action`1<SemanticModelAnalysisContext> Action { get; }
    public SemanticModelAnalyzerAction(Action`1<SemanticModelAnalysisContext> action, DiagnosticAnalyzer analyzer);
    public Action`1<SemanticModelAnalysisContext> get_Action();
}
public class Microsoft.CodeAnalysis.Diagnostics.SourceTextValueProvider`1 : object {
    [CompilerGeneratedAttribute]
private AnalysisValueProvider`2<SourceText, TValue> <CoreValueProvider>k__BackingField;
    internal AnalysisValueProvider`2<SourceText, TValue> CoreValueProvider { get; private set; }
    public SourceTextValueProvider`1(Func`2<SourceText, TValue> computeValue, IEqualityComparer`1<SourceText> sourceTextComparer);
    [CompilerGeneratedAttribute]
internal AnalysisValueProvider`2<SourceText, TValue> get_CoreValueProvider();
    [CompilerGeneratedAttribute]
private void set_CoreValueProvider(AnalysisValueProvider`2<SourceText, TValue> value);
}
public class Microsoft.CodeAnalysis.Diagnostics.SuppressionInfo : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private AttributeData <Attribute>k__BackingField;
    public string Id { get; }
    public AttributeData Attribute { get; }
    internal SuppressionInfo(string id, AttributeData attribute);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public AttributeData get_Attribute();
}
internal class Microsoft.CodeAnalysis.Diagnostics.SuppressMessageAttributeState : object {
    private static SmallDictionary`2<string, TargetScope> s_suppressMessageScopeTypes;
    private Compilation _compilation;
    private GlobalSuppressions _lazyGlobalSuppressions;
    private ConcurrentDictionary`2<ISymbol, ImmutableDictionary`2<string, SuppressMessageInfo>> _localSuppressionsBySymbol;
    private ISymbol _lazySuppressMessageAttribute;
    private static string s_suppressionPrefix;
    private ISymbol SuppressMessageAttribute { get; }
    internal SuppressMessageAttributeState(Compilation compilation);
    private static SuppressMessageAttributeState();
    public Diagnostic ApplySourceSuppressions(Diagnostic diagnostic, ISymbol symbolOpt);
    public bool IsDiagnosticSuppressed(Diagnostic diagnostic, AttributeData& suppressingAttribute);
    private bool IsDiagnosticSuppressed(Diagnostic diagnostic, SuppressMessageInfo& info, ISymbol symbolOpt);
    private bool IsDiagnosticSuppressed(string id, ISymbol symbol, SuppressMessageInfo& info);
    private bool IsDiagnosticSuppressed(string id, Location location, SuppressMessageInfo& info);
    private bool IsDiagnosticGloballySuppressed(string id, ISymbol symbolOpt, SuppressMessageInfo& info);
    private bool IsDiagnosticLocallySuppressed(string id, ISymbol symbol, SuppressMessageInfo& info);
    private ISymbol get_SuppressMessageAttribute();
    private void DecodeGlobalSuppressMessageAttributes();
    private ImmutableDictionary`2<string, SuppressMessageInfo> DecodeLocalSuppressMessageAttributes(ISymbol symbol);
    private static ImmutableDictionary`2<string, SuppressMessageInfo> DecodeLocalSuppressMessageAttributes(ISymbol symbol, IEnumerable`1<AttributeData> attributes);
    private static void AddOrUpdate(SuppressMessageInfo info, IDictionary`2<string, SuppressMessageInfo> builder);
    private void DecodeGlobalSuppressMessageAttributes(Compilation compilation, ISymbol symbol, GlobalSuppressions globalSuppressions);
    private static void DecodeGlobalSuppressMessageAttributes(Compilation compilation, ISymbol symbol, GlobalSuppressions globalSuppressions, IEnumerable`1<AttributeData> attributes);
    internal static IEnumerable`1<ISymbol> ResolveTargetSymbols(Compilation compilation, string target, TargetScope scope);
    private static bool TryDecodeSuppressMessageAttributeData(AttributeData attribute, SuppressMessageInfo& info);
    [CompilerGeneratedAttribute]
private bool <DecodeLocalSuppressMessageAttributes>b__17_0(AttributeData a);
    [CompilerGeneratedAttribute]
private bool <DecodeGlobalSuppressMessageAttributes>b__20_0(AttributeData a);
}
internal class Microsoft.CodeAnalysis.Diagnostics.SuppressMessageInfo : ValueType {
    public string Id;
    public string Scope;
    public string Target;
    public string MessageId;
    public AttributeData Attribute;
}
public class Microsoft.CodeAnalysis.Diagnostics.SymbolAnalysisContext : ValueType {
    private ISymbol _symbol;
    private Compilation _compilation;
    private AnalyzerOptions _options;
    private Action`1<Diagnostic> _reportDiagnostic;
    private Func`2<Diagnostic, bool> _isSupportedDiagnostic;
    private CancellationToken _cancellationToken;
    public ISymbol Symbol { get; }
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    internal Func`2<Diagnostic, bool> IsSupportedDiagnostic { get; }
    public SymbolAnalysisContext(ISymbol symbol, Compilation compilation, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);
    public ISymbol get_Symbol();
    public Compilation get_Compilation();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    internal Func`2<Diagnostic, bool> get_IsSupportedDiagnostic();
    public void ReportDiagnostic(Diagnostic diagnostic);
}
internal class Microsoft.CodeAnalysis.Diagnostics.SymbolAnalyzerAction : AnalyzerAction {
    private Action`1<SymbolAnalysisContext> _action;
    private ImmutableArray`1<SymbolKind> _kinds;
    public Action`1<SymbolAnalysisContext> Action { get; }
    public ImmutableArray`1<SymbolKind> Kinds { get; }
    public SymbolAnalyzerAction(Action`1<SymbolAnalysisContext> action, ImmutableArray`1<SymbolKind> kinds, DiagnosticAnalyzer analyzer);
    public Action`1<SymbolAnalysisContext> get_Action();
    public ImmutableArray`1<SymbolKind> get_Kinds();
}
internal class Microsoft.CodeAnalysis.Diagnostics.SymbolDeclaredCompilationEvent : CompilationEvent {
    private Lazy`1<ImmutableArray`1<SyntaxReference>> _lazyCachedDeclaringReferences;
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    private Lazy`1<SemanticModel> _lazySemanticModel;
    private SemanticModel _semanticModel;
    private WeakReference`1<SemanticModel> _weakModel;
    private object _gate;
    public ISymbol Symbol { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public SymbolDeclaredCompilationEvent(Compilation compilation, ISymbol symbol);
    public SymbolDeclaredCompilationEvent(Compilation compilation, ISymbol symbol, Lazy`1<SemanticModel> lazySemanticModel);
    private SymbolDeclaredCompilationEvent(SymbolDeclaredCompilationEvent original, SemanticModel newSemanticModel);
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    public ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public SemanticModel SemanticModel(SyntaxReference reference);
    public virtual void FlushCache();
    public SymbolDeclaredCompilationEvent WithSemanticModel(SemanticModel model);
    public virtual string ToString();
}
public class Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalysisContext : ValueType {
    private SyntaxNode _node;
    private ISymbol _containingSymbol;
    private SemanticModel _semanticModel;
    private AnalyzerOptions _options;
    private Action`1<Diagnostic> _reportDiagnostic;
    private Func`2<Diagnostic, bool> _isSupportedDiagnostic;
    private CancellationToken _cancellationToken;
    public SyntaxNode Node { get; }
    public ISymbol ContainingSymbol { get; }
    public SemanticModel SemanticModel { get; }
    public Compilation Compilation { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    public SyntaxNodeAnalysisContext(SyntaxNode node, ISymbol containingSymbol, SemanticModel semanticModel, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);
    public SyntaxNodeAnalysisContext(SyntaxNode node, SemanticModel semanticModel, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);
    public SyntaxNode get_Node();
    public ISymbol get_ContainingSymbol();
    public SemanticModel get_SemanticModel();
    public Compilation get_Compilation();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    public void ReportDiagnostic(Diagnostic diagnostic);
}
internal class Microsoft.CodeAnalysis.Diagnostics.SyntaxNodeAnalyzerAction`1 : AnalyzerAction {
    private Action`1<SyntaxNodeAnalysisContext> _action;
    private ImmutableArray`1<TLanguageKindEnum> _kinds;
    public Action`1<SyntaxNodeAnalysisContext> Action { get; }
    public ImmutableArray`1<TLanguageKindEnum> Kinds { get; }
    public SyntaxNodeAnalyzerAction`1(Action`1<SyntaxNodeAnalysisContext> action, ImmutableArray`1<TLanguageKindEnum> kinds, DiagnosticAnalyzer analyzer);
    public Action`1<SyntaxNodeAnalysisContext> get_Action();
    public ImmutableArray`1<TLanguageKindEnum> get_Kinds();
}
public class Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalysisContext : ValueType {
    private SyntaxTree _tree;
    private Compilation _compilationOpt;
    private AnalyzerOptions _options;
    private Action`1<Diagnostic> _reportDiagnostic;
    private Func`2<Diagnostic, bool> _isSupportedDiagnostic;
    private CancellationToken _cancellationToken;
    public SyntaxTree Tree { get; }
    public AnalyzerOptions Options { get; }
    public CancellationToken CancellationToken { get; }
    internal Compilation Compilation { get; }
    public SyntaxTreeAnalysisContext(SyntaxTree tree, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, CancellationToken cancellationToken);
    internal SyntaxTreeAnalysisContext(SyntaxTree tree, AnalyzerOptions options, Action`1<Diagnostic> reportDiagnostic, Func`2<Diagnostic, bool> isSupportedDiagnostic, Compilation compilation, CancellationToken cancellationToken);
    public SyntaxTree get_Tree();
    public AnalyzerOptions get_Options();
    public CancellationToken get_CancellationToken();
    internal Compilation get_Compilation();
    public void ReportDiagnostic(Diagnostic diagnostic);
}
internal class Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeAnalyzerAction : AnalyzerAction {
    private Action`1<SyntaxTreeAnalysisContext> _action;
    public Action`1<SyntaxTreeAnalysisContext> Action { get; }
    public SyntaxTreeAnalyzerAction(Action`1<SyntaxTreeAnalysisContext> action, DiagnosticAnalyzer analyzer);
    public Action`1<SyntaxTreeAnalysisContext> get_Action();
}
public class Microsoft.CodeAnalysis.Diagnostics.SyntaxTreeValueProvider`1 : object {
    [CompilerGeneratedAttribute]
private AnalysisValueProvider`2<SyntaxTree, TValue> <CoreValueProvider>k__BackingField;
    internal AnalysisValueProvider`2<SyntaxTree, TValue> CoreValueProvider { get; private set; }
    public SyntaxTreeValueProvider`1(Func`2<SyntaxTree, TValue> computeValue, IEqualityComparer`1<SyntaxTree> syntaxTreeComparer);
    [CompilerGeneratedAttribute]
internal AnalysisValueProvider`2<SyntaxTree, TValue> get_CoreValueProvider();
    [CompilerGeneratedAttribute]
private void set_CoreValueProvider(AnalysisValueProvider`2<SyntaxTree, TValue> value);
}
internal class Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerActionCounts : object {
    internal static AnalyzerActionCounts Empty;
    [CompilerGeneratedAttribute]
private int <CompilationStartActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CompilationEndActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CompilationActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SyntaxTreeActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SemanticModelActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SymbolActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SyntaxNodeActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodeBlockStartActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodeBlockEndActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodeBlockActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OperationActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OperationBlockStartActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OperationBlockEndActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OperationBlockActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasAnyExecutableCodeActions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Concurrent>k__BackingField;
    public int CompilationStartActionsCount { get; }
    public int CompilationEndActionsCount { get; }
    public int CompilationActionsCount { get; }
    public int SyntaxTreeActionsCount { get; }
    public int SemanticModelActionsCount { get; }
    public int SymbolActionsCount { get; }
    public int SyntaxNodeActionsCount { get; }
    public int CodeBlockStartActionsCount { get; }
    public int CodeBlockEndActionsCount { get; }
    public int CodeBlockActionsCount { get; }
    public int OperationActionsCount { get; }
    public int OperationBlockStartActionsCount { get; }
    public int OperationBlockEndActionsCount { get; }
    public int OperationBlockActionsCount { get; }
    public bool HasAnyExecutableCodeActions { get; }
    public bool Concurrent { get; }
    internal AnalyzerActionCounts(AnalyzerActions analyzerActions);
    internal AnalyzerActionCounts(int compilationStartActionsCount, int compilationEndActionsCount, int compilationActionsCount, int syntaxTreeActionsCount, int semanticModelActionsCount, int symbolActionsCount, int syntaxNodeActionsCount, int codeBlockStartActionsCount, int codeBlockEndActionsCount, int codeBlockActionsCount, int operationActionsCount, int operationBlockStartActionsCount, int operationBlockEndActionsCount, int operationBlockActionsCount, bool concurrent);
    private static AnalyzerActionCounts();
    [CompilerGeneratedAttribute]
public int get_CompilationStartActionsCount();
    [CompilerGeneratedAttribute]
public int get_CompilationEndActionsCount();
    [CompilerGeneratedAttribute]
public int get_CompilationActionsCount();
    [CompilerGeneratedAttribute]
public int get_SyntaxTreeActionsCount();
    [CompilerGeneratedAttribute]
public int get_SemanticModelActionsCount();
    [CompilerGeneratedAttribute]
public int get_SymbolActionsCount();
    [CompilerGeneratedAttribute]
public int get_SyntaxNodeActionsCount();
    [CompilerGeneratedAttribute]
public int get_CodeBlockStartActionsCount();
    [CompilerGeneratedAttribute]
public int get_CodeBlockEndActionsCount();
    [CompilerGeneratedAttribute]
public int get_CodeBlockActionsCount();
    [CompilerGeneratedAttribute]
public int get_OperationActionsCount();
    [CompilerGeneratedAttribute]
public int get_OperationBlockStartActionsCount();
    [CompilerGeneratedAttribute]
public int get_OperationBlockEndActionsCount();
    [CompilerGeneratedAttribute]
public int get_OperationBlockActionsCount();
    [CompilerGeneratedAttribute]
public bool get_HasAnyExecutableCodeActions();
    [CompilerGeneratedAttribute]
public bool get_Concurrent();
}
public class Microsoft.CodeAnalysis.Diagnostics.Telemetry.AnalyzerTelemetryInfo : object {
    [CompilerGeneratedAttribute]
private int <CompilationStartActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CompilationEndActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CompilationActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SyntaxTreeActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SemanticModelActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SymbolActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SyntaxNodeActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodeBlockStartActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodeBlockEndActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodeBlockActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OperationActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OperationBlockStartActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OperationBlockEndActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OperationBlockActionsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <ExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Concurrent>k__BackingField;
    public int CompilationStartActionsCount { get; public set; }
    public int CompilationEndActionsCount { get; public set; }
    public int CompilationActionsCount { get; public set; }
    public int SyntaxTreeActionsCount { get; public set; }
    public int SemanticModelActionsCount { get; public set; }
    public int SymbolActionsCount { get; public set; }
    public int SyntaxNodeActionsCount { get; public set; }
    public int CodeBlockStartActionsCount { get; public set; }
    public int CodeBlockEndActionsCount { get; public set; }
    public int CodeBlockActionsCount { get; public set; }
    public int OperationActionsCount { get; public set; }
    public int OperationBlockStartActionsCount { get; public set; }
    public int OperationBlockEndActionsCount { get; public set; }
    public int OperationBlockActionsCount { get; public set; }
    public TimeSpan ExecutionTime { get; public set; }
    public bool Concurrent { get; public set; }
    internal AnalyzerTelemetryInfo(AnalyzerActionCounts actionCounts, TimeSpan executionTime);
    [CompilerGeneratedAttribute]
public int get_CompilationStartActionsCount();
    [CompilerGeneratedAttribute]
public void set_CompilationStartActionsCount(int value);
    [CompilerGeneratedAttribute]
public int get_CompilationEndActionsCount();
    [CompilerGeneratedAttribute]
public void set_CompilationEndActionsCount(int value);
    [CompilerGeneratedAttribute]
public int get_CompilationActionsCount();
    [CompilerGeneratedAttribute]
public void set_CompilationActionsCount(int value);
    [CompilerGeneratedAttribute]
public int get_SyntaxTreeActionsCount();
    [CompilerGeneratedAttribute]
public void set_SyntaxTreeActionsCount(int value);
    [CompilerGeneratedAttribute]
public int get_SemanticModelActionsCount();
    [CompilerGeneratedAttribute]
public void set_SemanticModelActionsCount(int value);
    [CompilerGeneratedAttribute]
public int get_SymbolActionsCount();
    [CompilerGeneratedAttribute]
public void set_SymbolActionsCount(int value);
    [CompilerGeneratedAttribute]
public int get_SyntaxNodeActionsCount();
    [CompilerGeneratedAttribute]
public void set_SyntaxNodeActionsCount(int value);
    [CompilerGeneratedAttribute]
public int get_CodeBlockStartActionsCount();
    [CompilerGeneratedAttribute]
public void set_CodeBlockStartActionsCount(int value);
    [CompilerGeneratedAttribute]
public int get_CodeBlockEndActionsCount();
    [CompilerGeneratedAttribute]
public void set_CodeBlockEndActionsCount(int value);
    [CompilerGeneratedAttribute]
public int get_CodeBlockActionsCount();
    [CompilerGeneratedAttribute]
public void set_CodeBlockActionsCount(int value);
    [CompilerGeneratedAttribute]
public int get_OperationActionsCount();
    [CompilerGeneratedAttribute]
public void set_OperationActionsCount(int value);
    [CompilerGeneratedAttribute]
public int get_OperationBlockStartActionsCount();
    [CompilerGeneratedAttribute]
public void set_OperationBlockStartActionsCount(int value);
    [CompilerGeneratedAttribute]
public int get_OperationBlockEndActionsCount();
    [CompilerGeneratedAttribute]
public void set_OperationBlockEndActionsCount(int value);
    [CompilerGeneratedAttribute]
public int get_OperationBlockActionsCount();
    [CompilerGeneratedAttribute]
public void set_OperationBlockActionsCount(int value);
    [CompilerGeneratedAttribute]
public TimeSpan get_ExecutionTime();
    [CompilerGeneratedAttribute]
public void set_ExecutionTime(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_Concurrent();
    [CompilerGeneratedAttribute]
public void set_Concurrent(bool value);
}
public class Microsoft.CodeAnalysis.Diagnostics.UnresolvedAnalyzerReference : AnalyzerReference {
    private string _unresolvedPath;
    public string Display { get; }
    public string FullPath { get; }
    public object Id { get; }
    public UnresolvedAnalyzerReference(string unresolvedPath);
    public virtual string get_Display();
    public virtual string get_FullPath();
    public virtual object get_Id();
    public virtual ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzersForAllLanguages();
    public virtual ImmutableArray`1<DiagnosticAnalyzer> GetAnalyzers(string language);
}
public enum Microsoft.CodeAnalysis.DiagnosticSeverity : Enum {
    public int value__;
    public static DiagnosticSeverity Hidden;
    public static DiagnosticSeverity Info;
    public static DiagnosticSeverity Warning;
    public static DiagnosticSeverity Error;
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.DiagnosticWithInfo : Diagnostic {
    private DiagnosticInfo _info;
    private Location _location;
    private bool _isSuppressed;
    public Location Location { get; }
    public IReadOnlyList`1<Location> AdditionalLocations { get; }
    internal IReadOnlyList`1<string> CustomTags { get; }
    public DiagnosticDescriptor Descriptor { get; }
    public string Id { get; }
    internal string Category { get; }
    internal int Code { get; }
    public DiagnosticSeverity Severity { get; }
    public DiagnosticSeverity DefaultSeverity { get; }
    internal bool IsEnabledByDefault { get; }
    public bool IsSuppressed { get; }
    public int WarningLevel { get; }
    internal IReadOnlyList`1<object> Arguments { get; }
    public DiagnosticInfo Info { get; }
    internal bool HasLazyInfo { get; }
    internal DiagnosticWithInfo(DiagnosticInfo info, Location location, bool isSuppressed);
    public virtual Location get_Location();
    public virtual IReadOnlyList`1<Location> get_AdditionalLocations();
    internal virtual IReadOnlyList`1<string> get_CustomTags();
    public virtual DiagnosticDescriptor get_Descriptor();
    public virtual string get_Id();
    internal virtual string get_Category();
    internal sealed virtual int get_Code();
    public sealed virtual DiagnosticSeverity get_Severity();
    public sealed virtual DiagnosticSeverity get_DefaultSeverity();
    internal sealed virtual bool get_IsEnabledByDefault();
    public virtual bool get_IsSuppressed();
    public sealed virtual int get_WarningLevel();
    public virtual string GetMessage(IFormatProvider formatProvider);
    internal virtual IReadOnlyList`1<object> get_Arguments();
    public DiagnosticInfo get_Info();
    internal bool get_HasLazyInfo();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual bool Equals(Diagnostic obj);
    private string GetDebuggerDisplay();
    internal virtual Diagnostic WithLocation(Location location);
    internal virtual Diagnostic WithSeverity(DiagnosticSeverity severity);
    internal virtual Diagnostic WithIsSuppressed(bool isSuppressed);
    internal sealed virtual bool IsNotConfigurable();
}
public class Microsoft.CodeAnalysis.DllImportData : object {
    private string _moduleName;
    private string _entryPointName;
    private MethodImportAttributes _flags;
    public string ModuleName { get; }
    public string EntryPointName { get; }
    private MethodImportAttributes Microsoft.Cci.IPlatformInvokeInformation.Flags { get; }
    public bool ExactSpelling { get; }
    public CharSet CharacterSet { get; }
    public bool SetLastError { get; }
    public CallingConvention CallingConvention { get; }
    public Nullable`1<bool> BestFitMapping { get; }
    public Nullable`1<bool> ThrowOnUnmappableCharacter { get; }
    internal DllImportData(string moduleName, string entryPointName, MethodImportAttributes flags);
    public sealed virtual string get_ModuleName();
    public sealed virtual string get_EntryPointName();
    private sealed virtual override MethodImportAttributes Microsoft.Cci.IPlatformInvokeInformation.get_Flags();
    public bool get_ExactSpelling();
    public CharSet get_CharacterSet();
    public bool get_SetLastError();
    public CallingConvention get_CallingConvention();
    public Nullable`1<bool> get_BestFitMapping();
    public Nullable`1<bool> get_ThrowOnUnmappableCharacter();
    internal static MethodImportAttributes MakeFlags(bool exactSpelling, CharSet charSet, bool setLastError, CallingConvention callingConvention, Nullable`1<bool> useBestFit, Nullable`1<bool> throwOnUnmappable);
}
public static class Microsoft.CodeAnalysis.DocumentationCommentId : object {
    private static ListPool`1<ISymbol> s_symbolListPool;
    private static ListPool`1<INamespaceOrTypeSymbol> s_namespaceOrTypeListPool;
    private static DocumentationCommentId();
    public static string CreateDeclarationId(ISymbol symbol);
    public static string CreateReferenceId(ISymbol symbol);
    public static ImmutableArray`1<ISymbol> GetSymbolsForDeclarationId(string id, Compilation compilation);
    private static bool TryGetSymbolsForDeclarationId(string id, Compilation compilation, List`1<ISymbol> results);
    public static ISymbol GetFirstSymbolForDeclarationId(string id, Compilation compilation);
    public static ImmutableArray`1<ISymbol> GetSymbolsForReferenceId(string id, Compilation compilation);
    private static bool TryGetSymbolsForReferenceId(string id, Compilation compilation, List`1<ISymbol> results);
    public static ISymbol GetFirstSymbolForReferenceId(string id, Compilation compilation);
    private static int GetTotalTypeParameterCount(INamedTypeSymbol symbol);
    private static string EncodeName(string name);
    private static string EncodePropertyName(string name);
    private static string DecodePropertyName(string name, string language);
}
internal class Microsoft.CodeAnalysis.DocumentationCommentIncludeCache : CachingFactory`2<string, KeyValuePair`2<string, XDocument>> {
    private static int Size;
    [CompilerGeneratedAttribute]
private static int <CacheMissCount>k__BackingField;
    private static XmlReaderSettings s_xmlSettings;
    internal static int CacheMissCount { get; private set; }
    public DocumentationCommentIncludeCache(XmlReferenceResolver resolver);
    private static DocumentationCommentIncludeCache();
    [CompilerGeneratedAttribute]
internal static int get_CacheMissCount();
    [CompilerGeneratedAttribute]
private static void set_CacheMissCount(int value);
    public XDocument GetOrMakeDocument(string resolvedPath);
    private static KeyValuePair`2<string, XDocument> MakeValue(XmlReferenceResolver resolver, string resolvedPath);
    private static int KeyHashCode(string resolvedPath);
    private static bool KeyValueEquality(string resolvedPath, KeyValuePair`2<string, XDocument> pathAndDocument);
}
public enum Microsoft.CodeAnalysis.DocumentationMode : Enum {
    public byte value__;
    public static DocumentationMode None;
    public static DocumentationMode Parse;
    public static DocumentationMode Diagnose;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.DocumentationModeEnumBounds : object {
    [ExtensionAttribute]
internal static bool IsValid(DocumentationMode value);
}
public abstract class Microsoft.CodeAnalysis.DocumentationProvider : object {
    [CompilerGeneratedAttribute]
private static DocumentationProvider <Default>k__BackingField;
    public static DocumentationProvider Default { get; }
    private static DocumentationProvider();
    [CompilerGeneratedAttribute]
public static DocumentationProvider get_Default();
    protected internal abstract virtual string GetDocumentationForSymbol(string documentationMemberID, CultureInfo preferredCulture, CancellationToken cancellationToken);
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments`4 : ValueType {
    private EarlyWellKnownAttributeData _lazyDecodeData;
    [CompilerGeneratedAttribute]
private TEarlyBinder <Binder>k__BackingField;
    [CompilerGeneratedAttribute]
private TNamedTypeSymbol <AttributeType>k__BackingField;
    [CompilerGeneratedAttribute]
private TAttributeSyntax <AttributeSyntax>k__BackingField;
    [CompilerGeneratedAttribute]
private TAttributeLocation <SymbolPart>k__BackingField;
    public bool HasDecodedData { get; }
    public EarlyWellKnownAttributeData DecodedData { get; }
    public TEarlyBinder Binder { get; public set; }
    public TNamedTypeSymbol AttributeType { get; public set; }
    public TAttributeSyntax AttributeSyntax { get; public set; }
    public TAttributeLocation SymbolPart { get; public set; }
    public T GetOrCreateData();
    public bool get_HasDecodedData();
    public EarlyWellKnownAttributeData get_DecodedData();
    [CompilerGeneratedAttribute]
public TEarlyBinder get_Binder();
    [CompilerGeneratedAttribute]
public void set_Binder(TEarlyBinder value);
    [CompilerGeneratedAttribute]
public TNamedTypeSymbol get_AttributeType();
    [CompilerGeneratedAttribute]
public void set_AttributeType(TNamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public TAttributeSyntax get_AttributeSyntax();
    [CompilerGeneratedAttribute]
public void set_AttributeSyntax(TAttributeSyntax value);
    [CompilerGeneratedAttribute]
public TAttributeLocation get_SymbolPart();
    [CompilerGeneratedAttribute]
public void set_SymbolPart(TAttributeLocation value);
}
internal abstract class Microsoft.CodeAnalysis.EarlyWellKnownAttributeData : WellKnownAttributeData {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.CodeAnalysis.EmbeddedResource : ValueType {
    public UInt32 Offset;
    public ManifestResourceAttributes Attributes;
    public string Name;
    internal EmbeddedResource(UInt32 offset, ManifestResourceAttributes attributes, string name);
}
public class Microsoft.CodeAnalysis.EmbeddedText : object {
    internal static int CompressionThreshold;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceHashAlgorithm <ChecksumAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<byte> <Checksum>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<byte> <Blob>k__BackingField;
    public string FilePath { get; }
    public SourceHashAlgorithm ChecksumAlgorithm { get; }
    public ImmutableArray`1<byte> Checksum { get; }
    internal ImmutableArray`1<byte> Blob { get; }
    private EmbeddedText(string filePath, ImmutableArray`1<byte> checksum, SourceHashAlgorithm checksumAlgorithm, ImmutableArray`1<byte> blob);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public SourceHashAlgorithm get_ChecksumAlgorithm();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<byte> get_Checksum();
    [CompilerGeneratedAttribute]
internal ImmutableArray`1<byte> get_Blob();
    public static EmbeddedText FromSource(string filePath, SourceText text);
    public static EmbeddedText FromStream(string filePath, Stream stream, SourceHashAlgorithm checksumAlgorithm);
    public static EmbeddedText FromBytes(string filePath, ArraySegment`1<byte> bytes, SourceHashAlgorithm checksumAlgorithm);
    private static void ValidateFilePath(string filePath);
    internal static ImmutableArray`1<byte> CreateBlob(Stream stream);
    internal static ImmutableArray`1<byte> CreateBlob(ArraySegment`1<byte> bytes);
    private static ImmutableArray`1<byte> CreateBlob(SourceText text);
    internal DebugSourceInfo GetDebugSourceInfo();
}
internal class Microsoft.CodeAnalysis.Emit.AddedOrChangedMethodInfo : ValueType {
    public DebugId MethodId;
    public ImmutableArray`1<EncLocalInfo> Locals;
    public ImmutableArray`1<LambdaDebugInfo> LambdaDebugInfo;
    public ImmutableArray`1<ClosureDebugInfo> ClosureDebugInfo;
    public string StateMachineTypeNameOpt;
    public ImmutableArray`1<EncHoistedLocalInfo> StateMachineHoistedLocalSlotsOpt;
    public ImmutableArray`1<ITypeReference> StateMachineAwaiterSlotsOpt;
    public AddedOrChangedMethodInfo(DebugId methodId, ImmutableArray`1<EncLocalInfo> locals, ImmutableArray`1<LambdaDebugInfo> lambdaDebugInfo, ImmutableArray`1<ClosureDebugInfo> closureDebugInfo, string stateMachineTypeNameOpt, ImmutableArray`1<EncHoistedLocalInfo> stateMachineHoistedLocalSlotsOpt, ImmutableArray`1<ITypeReference> stateMachineAwaiterSlotsOpt);
    public AddedOrChangedMethodInfo MapTypes(SymbolMatcher map);
    private static EncLocalInfo MapLocalInfo(EncLocalInfo info, SymbolMatcher map);
    private static EncHoistedLocalInfo MapHoistedLocalSlot(EncHoistedLocalInfo info, SymbolMatcher map);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.Emit.AnonymousTypeKey : ValueType {
    internal bool IsDelegate;
    internal ImmutableArray`1<AnonymousTypeKeyField> Fields;
    internal AnonymousTypeKey(ImmutableArray`1<AnonymousTypeKeyField> fields, bool isDelegate);
    public sealed virtual bool Equals(AnonymousTypeKey other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.Emit.AnonymousTypeKeyField : ValueType {
    internal string Name;
    internal bool IsKey;
    internal bool IgnoreCase;
    public AnonymousTypeKeyField(string name, bool isKey, bool ignoreCase);
    public sealed virtual bool Equals(AnonymousTypeKeyField other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DebuggerDisplayAttribute("{Name, nq}")]
internal class Microsoft.CodeAnalysis.Emit.AnonymousTypeValue : ValueType {
    public string Name;
    public int UniqueIndex;
    public ITypeDefinition Type;
    public AnonymousTypeValue(string name, int uniqueIndex, ITypeDefinition type);
}
internal class Microsoft.CodeAnalysis.Emit.AsyncMoveNextBodyDebugInfo : StateMachineMoveNextBodyDebugInfo {
    public int CatchHandlerOffset;
    public ImmutableArray`1<int> YieldOffsets;
    public ImmutableArray`1<int> ResumeOffsets;
    public AsyncMoveNextBodyDebugInfo(IMethodDefinition kickoffMethod, int catchHandlerOffset, ImmutableArray`1<int> yieldOffsets, ImmutableArray`1<int> resumeOffsets);
}
internal abstract class Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder : object {
    internal DebugDocumentsBuilder DebugDocumentsBuilder;
    internal IEnumerable`1<ResourceDescription> ManifestResources;
    internal ModulePropertiesForSerialization SerializationProperties;
    internal OutputKind OutputKind;
    internal IEnumerable`1<IWin32Resource> Win32Resources;
    internal ResourceSection Win32ResourceSection;
    internal Stream SourceLinkStreamOpt;
    internal IMethodReference PEEntryPoint;
    internal IMethodReference DebugEntryPoint;
    private ConcurrentDictionary`2<IMethodSymbol, IMethodBody> _methodBodyMap;
    private TokenMap`1<IReference> _referencesInILMap;
    private ItemTokenMap`1<string> _stringsInILMap;
    private ItemTokenMap`1<DebugSourceDocument> _sourceDocumentsInILMap;
    private ImmutableArray`1<AssemblyReferenceAlias> _lazyAssemblyReferenceAliases;
    private ImmutableArray`1<ManagedResource> _lazyManagedResources;
    private IEnumerable`1<EmbeddedText> _embeddedTexts;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<IMethodSymbol, MethodData> <TestData>k__BackingField;
    internal DebugInformationFormat DebugInformationFormat;
    internal HashAlgorithmName PdbChecksumAlgorithm;
    internal ConcurrentDictionary`2<IMethodSymbol, MethodData> TestData { get; private set; }
    public int CurrentGenerationOrdinal { get; }
    public string Name { get; }
    internal string ModuleName { get; }
    internal bool SupportsPrivateImplClass { get; }
    internal Compilation CommonCompilation { get; }
    internal IModuleSymbol CommonSourceModule { get; }
    internal IAssemblySymbol CommonCorLibrary { get; }
    internal CommonModuleCompilationState CommonModuleCompilationState { get; }
    internal CommonEmbeddedTypesManager CommonEmbeddedTypesManagerOpt { get; }
    public bool GenerateVisualBasicStylePdb { get; }
    public IEnumerable`1<string> LinkedAssembliesDebugInfo { get; }
    public string DefaultNamespace { get; }
    public int DebugDocumentCount { get; }
    public ISourceAssemblySymbolInternal SourceAssemblyOpt { get; }
    public int HintNumberOfMethodDefinitions { get; }
    public IEnumerable`1<EmbeddedText> EmbeddedTexts { get; public set; }
    internal bool SaveTestData { get; }
    public CommonPEModuleBuilder(IEnumerable`1<ResourceDescription> manifestResources, EmitOptions emitOptions, OutputKind outputKind, ModulePropertiesForSerialization serializationProperties, Compilation compilation);
    [CompilerGeneratedAttribute]
internal ConcurrentDictionary`2<IMethodSymbol, MethodData> get_TestData();
    [CompilerGeneratedAttribute]
private void set_TestData(ConcurrentDictionary`2<IMethodSymbol, MethodData> value);
    public abstract virtual int get_CurrentGenerationOrdinal();
    public abstract virtual string get_Name();
    internal abstract virtual string get_ModuleName();
    internal abstract virtual IAssemblyReference Translate(IAssemblySymbol symbol, DiagnosticBag diagnostics);
    internal abstract virtual ITypeReference Translate(ITypeSymbol symbol, SyntaxNode syntaxOpt, DiagnosticBag diagnostics);
    internal abstract virtual IMethodReference Translate(IMethodSymbol symbol, DiagnosticBag diagnostics, bool needDeclaration);
    internal abstract virtual bool get_SupportsPrivateImplClass();
    internal abstract virtual ImmutableArray`1<INamespaceTypeDefinition> GetAnonymousTypes(EmitContext context);
    internal abstract virtual Compilation get_CommonCompilation();
    internal abstract virtual IModuleSymbol get_CommonSourceModule();
    internal abstract virtual IAssemblySymbol get_CommonCorLibrary();
    internal abstract virtual CommonModuleCompilationState get_CommonModuleCompilationState();
    internal abstract virtual void CompilationFinished();
    internal abstract virtual ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> GetSynthesizedMembers();
    internal abstract virtual CommonEmbeddedTypesManager get_CommonEmbeddedTypesManagerOpt();
    internal abstract virtual ITypeReference EncTranslateType(ITypeSymbol type, DiagnosticBag diagnostics);
    public abstract virtual IEnumerable`1<ICustomAttribute> GetSourceAssemblyAttributes(bool isRefAssembly);
    public abstract virtual IEnumerable`1<SecurityAttribute> GetSourceAssemblySecurityAttributes();
    public abstract virtual IEnumerable`1<ICustomAttribute> GetSourceModuleAttributes();
    internal abstract virtual ICustomAttribute SynthesizeAttribute(WellKnownMember attributeConstructor);
    public abstract virtual ImmutableArray`1<ExportedType> GetExportedTypes(DiagnosticBag diagnostics);
    public abstract virtual bool get_GenerateVisualBasicStylePdb();
    public abstract virtual IEnumerable`1<string> get_LinkedAssembliesDebugInfo();
    public abstract virtual ImmutableArray`1<UsedNamespaceOrType> GetImports();
    public abstract virtual string get_DefaultNamespace();
    protected abstract virtual IAssemblyReference GetCorLibraryReferenceToEmit(EmitContext context);
    protected abstract virtual IEnumerable`1<IAssemblyReference> GetAssemblyReferencesFromAddedModules(DiagnosticBag diagnostics);
    protected abstract virtual void AddEmbeddedResourcesFromAddedModules(ArrayBuilder`1<ManagedResource> builder, DiagnosticBag diagnostics);
    public abstract virtual ITypeReference GetPlatformType(PlatformType platformType, EmitContext context);
    public abstract virtual bool IsPlatformType(ITypeReference typeRef, PlatformType platformType);
    public abstract virtual IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypes(EmitContext context);
    public abstract virtual IEnumerable`1<IFileReference> GetFiles(EmitContext context);
    public abstract virtual MultiDictionary`2<DebugSourceDocument, DefinitionWithLocation> GetSymbolToLocationMap();
    public int get_DebugDocumentCount();
    public sealed virtual void Dispatch(MetadataVisitor visitor);
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.GetAttributes(EmitContext context);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    public abstract virtual ISourceAssemblySymbolInternal get_SourceAssemblyOpt();
    public int get_HintNumberOfMethodDefinitions();
    internal IMethodBody GetMethodBody(IMethodSymbol methodSymbol);
    public void SetMethodBody(IMethodSymbol methodSymbol, IMethodBody body);
    internal void SetPEEntryPoint(IMethodSymbol method, DiagnosticBag diagnostics);
    internal void SetDebugEntryPoint(IMethodSymbol method, DiagnosticBag diagnostics);
    private bool IsSourceDefinition(IMethodSymbol method);
    public IAssemblyReference GetCorLibrary(EmitContext context);
    public sealed virtual IAssemblyReference GetContainingAssembly(EmitContext context);
    public IEnumerable`1<string> GetStrings();
    public sealed virtual UInt32 GetFakeSymbolTokenForIL(IReference symbol, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    public sealed virtual UInt32 GetSourceDocumentIndexForIL(DebugSourceDocument document);
    internal DebugSourceDocument GetSourceDocumentFromIndex(UInt32 token);
    public sealed virtual IReference GetReferenceFromToken(UInt32 token);
    public sealed virtual UInt32 GetFakeStringTokenForIL(string str);
    public sealed virtual string GetStringFromToken(UInt32 token);
    public IEnumerable`1<IReference> ReferencesInIL(Int32& count);
    public ImmutableArray`1<AssemblyReferenceAlias> GetAssemblyReferenceAliases(EmitContext context);
    private ImmutableArray`1<AssemblyReferenceAlias> CalculateAssemblyReferenceAliases(EmitContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Emit.CommonPEModuleBuilder/<GetAssemblyReferences>d__94")]
public IEnumerable`1<IAssemblyReference> GetAssemblyReferences(EmitContext context);
    public ImmutableArray`1<ManagedResource> GetResources(EmitContext context);
    public IEnumerable`1<EmbeddedText> get_EmbeddedTexts();
    public void set_EmbeddedTexts(IEnumerable`1<EmbeddedText> value);
    internal bool get_SaveTestData();
    internal void SetMethodTestData(IMethodSymbol method, ILBuilder builder);
    internal void SetMethodTestData(ConcurrentDictionary`2<IMethodSymbol, MethodData> methods);
}
internal class Microsoft.CodeAnalysis.Emit.DebugDocumentsBuilder : object {
    private ConcurrentDictionary`2<string, DebugSourceDocument> _debugDocuments;
    private ConcurrentCache`2<ValueTuple`2<string, string>, string> _normalizedPathsCache;
    private SourceReferenceResolver _resolverOpt;
    private ImmutableArray`1<DebugSourceDocument> _embeddedDocuments;
    internal ImmutableArray`1<DebugSourceDocument> EmbeddedDocuments { get; internal set; }
    internal int DebugDocumentCount { get; }
    public DebugDocumentsBuilder(SourceReferenceResolver resolverOpt, bool isDocumentNameCaseSensitive);
    internal ImmutableArray`1<DebugSourceDocument> get_EmbeddedDocuments();
    internal void set_EmbeddedDocuments(ImmutableArray`1<DebugSourceDocument> value);
    internal int get_DebugDocumentCount();
    internal void AddDebugDocument(DebugSourceDocument document);
    internal DebugSourceDocument TryGetDebugDocument(string path, string basePath);
    internal DebugSourceDocument TryGetDebugDocumentForNormalizedPath(string normalizedPath);
    internal DebugSourceDocument GetOrAddDebugDocument(string path, string basePath, Func`2<string, DebugSourceDocument> factory);
    internal string NormalizeDebugDocumentPath(string path, string basePath);
}
public enum Microsoft.CodeAnalysis.Emit.DebugInformationFormat : Enum {
    public int value__;
    public static DebugInformationFormat Pdb;
    public static DebugInformationFormat PortablePdb;
    public static DebugInformationFormat Embedded;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Emit.DebugInformationFormatExtensions : object {
    [ExtensionAttribute]
internal static bool IsValid(DebugInformationFormat value);
    [ExtensionAttribute]
internal static bool IsPortable(DebugInformationFormat value);
}
internal abstract class Microsoft.CodeAnalysis.Emit.DefinitionMap : object {
    protected PEModule module;
    protected IReadOnlyDictionary`2<IMethodSymbol, MappedMethod> mappedMethods;
    internal CommonMessageProvider MessageProvider { get; }
    protected DefinitionMap(PEModule module, IEnumerable`1<SemanticEdit> edits);
    private static IReadOnlyDictionary`2<IMethodSymbol, MappedMethod> GetMappedMethods(IEnumerable`1<SemanticEdit> edits);
    internal abstract virtual IDefinition MapDefinition(IDefinition definition);
    internal bool DefinitionExists(IDefinition definition);
    internal abstract virtual bool TryGetTypeHandle(ITypeDefinition def, TypeDefinitionHandle& handle);
    internal abstract virtual bool TryGetEventHandle(IEventDefinition def, EventDefinitionHandle& handle);
    internal abstract virtual bool TryGetFieldHandle(IFieldDefinition def, FieldDefinitionHandle& handle);
    internal abstract virtual bool TryGetMethodHandle(IMethodDefinition def, MethodDefinitionHandle& handle);
    internal abstract virtual bool TryGetPropertyHandle(IPropertyDefinition def, PropertyDefinitionHandle& handle);
    internal abstract virtual CommonMessageProvider get_MessageProvider();
}
internal abstract class Microsoft.CodeAnalysis.Emit.DefinitionMap`1 : DefinitionMap {
    protected TSymbolMatcher mapToMetadata;
    protected TSymbolMatcher mapToPrevious;
    protected DefinitionMap`1(PEModule module, IEnumerable`1<SemanticEdit> edits, TSymbolMatcher mapToMetadata, TSymbolMatcher mapToPrevious);
    internal sealed virtual IDefinition MapDefinition(IDefinition definition);
    private bool TryGetMethodHandle(EmitBaseline baseline, IMethodDefinition def, MethodDefinitionHandle& handle);
    protected static IReadOnlyDictionary`2<SyntaxNode, int> CreateDeclaratorToSyntaxOrdinalMap(ImmutableArray`1<SyntaxNode> declarators);
    protected abstract virtual void GetStateMachineFieldMapFromMetadata(ITypeSymbol stateMachineType, ImmutableArray`1<LocalSlotDebugInfo> localSlotDebugInfo, IReadOnlyDictionary`2& hoistedLocalMap, IReadOnlyDictionary`2& awaiterMap, Int32& awaiterSlotCount);
    protected abstract virtual ImmutableArray`1<EncLocalInfo> GetLocalSlotMapFromMetadata(StandaloneSignatureHandle handle, EditAndContinueMethodDebugInformation debugInfo);
    protected abstract virtual ITypeSymbol TryGetStateMachineType(EntityHandle methodHandle);
    internal VariableSlotAllocator TryCreateVariableSlotAllocator(EmitBaseline baseline, Compilation compilation, IMethodSymbolInternal method, IMethodSymbol topLevelMethod, DiagnosticBag diagnostics);
    protected abstract virtual LambdaSyntaxFacts GetLambdaSyntaxFacts();
    private void ReportMissingStateMachineAttribute(DiagnosticBag diagnostics, IMethodSymbolInternal method, string stateMachineAttributeFullName);
    private static void MakeLambdaAndClosureMaps(ImmutableArray`1<LambdaDebugInfo> lambdaDebugInfo, ImmutableArray`1<ClosureDebugInfo> closureDebugInfo, IReadOnlyDictionary`2& lambdaMap, IReadOnlyDictionary`2& closureMap);
    private static void GetStateMachineFieldMapFromPreviousCompilation(ImmutableArray`1<EncHoistedLocalInfo> hoistedLocalSlots, ImmutableArray`1<ITypeReference> hoistedAwaiters, IReadOnlyDictionary`2& hoistedLocalMap, IReadOnlyDictionary`2& awaiterMap);
}
internal class Microsoft.CodeAnalysis.Emit.DeltaMetadataWriter : MetadataWriter {
    private EmitBaseline _previousGeneration;
    private Guid _encId;
    private DefinitionMap _definitionMap;
    private SymbolChanges _changes;
    private DefinitionIndex`1<ITypeDefinition> _typeDefs;
    private DefinitionIndex`1<IEventDefinition> _eventDefs;
    private DefinitionIndex`1<IFieldDefinition> _fieldDefs;
    private DefinitionIndex`1<IMethodDefinition> _methodDefs;
    private DefinitionIndex`1<IPropertyDefinition> _propertyDefs;
    private ParameterDefinitionIndex _parameterDefs;
    private List`1<KeyValuePair`2<IMethodDefinition, IParameterDefinition>> _parameterDefList;
    private GenericParameterIndex _genericParameters;
    private EventOrPropertyMapIndex _eventMap;
    private EventOrPropertyMapIndex _propertyMap;
    private MethodImplIndex _methodImpls;
    private HeapOrReferenceIndex`1<AssemblyIdentity> _assemblyRefIndex;
    private HeapOrReferenceIndex`1<string> _moduleRefIndex;
    private InstanceAndStructuralReferenceIndex`1<ITypeMemberReference> _memberRefIndex;
    private InstanceAndStructuralReferenceIndex`1<IGenericMethodInstanceReference> _methodSpecIndex;
    private HeapOrReferenceIndex`1<ITypeReference> _typeRefIndex;
    private InstanceAndStructuralReferenceIndex`1<ITypeReference> _typeSpecIndex;
    private HeapOrReferenceIndex`1<BlobHandle> _standAloneSignatureIndex;
    private Dictionary`2<IMethodDefinition, AddedOrChangedMethodInfo> _addedOrChangedMethods;
    protected ushort Generation { get; }
    protected Guid EncId { get; }
    protected Guid EncBaseId { get; }
    protected int GreatestMethodDefIndex { get; }
    public DeltaMetadataWriter(EmitContext context, CommonMessageProvider messageProvider, EmitBaseline previousGeneration, Guid encId, DefinitionMap definitionMap, SymbolChanges changes, CancellationToken cancellationToken);
    private static MetadataBuilder MakeTablesBuilder(EmitBaseline previousGeneration);
    private ImmutableArray`1<int> GetDeltaTableSizes(ImmutableArray`1<int> rowCounts);
    internal EmitBaseline GetDelta(EmitBaseline baseline, Compilation compilation, Guid encId, MetadataSizes metadataSizes);
    private static IReadOnlyDictionary`2<K, V> AddRange(IReadOnlyDictionary`2<K, V> previous, IReadOnlyDictionary`2<K, V> current, bool replace);
    public void GetMethodTokens(ICollection`1<MethodDefinitionHandle> methods);
    protected virtual ushort get_Generation();
    protected virtual Guid get_EncId();
    protected virtual Guid get_EncBaseId();
    protected virtual EventDefinitionHandle GetEventDefinitionHandle(IEventDefinition def);
    protected virtual IReadOnlyList`1<IEventDefinition> GetEventDefs();
    protected virtual FieldDefinitionHandle GetFieldDefinitionHandle(IFieldDefinition def);
    protected virtual IReadOnlyList`1<IFieldDefinition> GetFieldDefs();
    protected virtual bool TryGetTypeDefinitionHandle(ITypeDefinition def, TypeDefinitionHandle& handle);
    protected virtual TypeDefinitionHandle GetTypeDefinitionHandle(ITypeDefinition def);
    protected virtual ITypeDefinition GetTypeDef(TypeDefinitionHandle handle);
    protected virtual IReadOnlyList`1<ITypeDefinition> GetTypeDefs();
    protected virtual bool TryGetMethodDefinitionHandle(IMethodDefinition def, MethodDefinitionHandle& handle);
    protected virtual MethodDefinitionHandle GetMethodDefinitionHandle(IMethodDefinition def);
    protected virtual IMethodDefinition GetMethodDef(MethodDefinitionHandle index);
    protected virtual IReadOnlyList`1<IMethodDefinition> GetMethodDefs();
    protected virtual PropertyDefinitionHandle GetPropertyDefIndex(IPropertyDefinition def);
    protected virtual IReadOnlyList`1<IPropertyDefinition> GetPropertyDefs();
    protected virtual ParameterHandle GetParameterHandle(IParameterDefinition def);
    protected virtual IReadOnlyList`1<IParameterDefinition> GetParameterDefs();
    protected virtual IReadOnlyList`1<IGenericParameter> GetGenericParameters();
    protected virtual FieldDefinitionHandle GetFirstFieldDefinitionHandle(INamedTypeDefinition typeDef);
    protected virtual MethodDefinitionHandle GetFirstMethodDefinitionHandle(INamedTypeDefinition typeDef);
    protected virtual ParameterHandle GetFirstParameterHandle(IMethodDefinition methodDef);
    protected virtual AssemblyReferenceHandle GetOrAddAssemblyReferenceHandle(IAssemblyReference reference);
    protected virtual IReadOnlyList`1<AssemblyIdentity> GetAssemblyRefs();
    protected virtual ModuleReferenceHandle GetOrAddModuleReferenceHandle(string reference);
    protected virtual IReadOnlyList`1<string> GetModuleRefs();
    protected virtual MemberReferenceHandle GetOrAddMemberReferenceHandle(ITypeMemberReference reference);
    protected virtual IReadOnlyList`1<ITypeMemberReference> GetMemberRefs();
    protected virtual MethodSpecificationHandle GetOrAddMethodSpecificationHandle(IGenericMethodInstanceReference reference);
    protected virtual IReadOnlyList`1<IGenericMethodInstanceReference> GetMethodSpecs();
    protected virtual int get_GreatestMethodDefIndex();
    protected virtual bool TryGetTypeReferenceHandle(ITypeReference reference, TypeReferenceHandle& handle);
    protected virtual TypeReferenceHandle GetOrAddTypeReferenceHandle(ITypeReference reference);
    protected virtual IReadOnlyList`1<ITypeReference> GetTypeRefs();
    protected virtual TypeSpecificationHandle GetOrAddTypeSpecificationHandle(ITypeReference reference);
    protected virtual IReadOnlyList`1<ITypeReference> GetTypeSpecs();
    protected virtual StandaloneSignatureHandle GetOrAddStandaloneSignatureHandle(BlobHandle blobIndex);
    protected virtual IReadOnlyList`1<BlobHandle> GetStandaloneSignatureBlobHandles();
    protected virtual IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypes(CommonPEModuleBuilder module);
    protected virtual void OnIndicesCreated();
    protected virtual void CreateIndicesForNonTypeMembers(ITypeDefinition typeDef);
    private bool AddDefIfNecessary(DefinitionIndex`1<T> defIndex, T def);
    protected virtual ReferenceIndexer CreateReferenceVisitor();
    protected virtual void ReportReferencesToAddedSymbols();
    private void ReportReferencesToAddedSymbol(ISymbol symbolOpt);
    protected virtual StandaloneSignatureHandle SerializeLocalVariablesSignature(IMethodBody body);
    private EncLocalInfo CreateEncLocalInfo(ILocalDefinition localDef, Byte[] signature);
    protected virtual void PopulateEncLogTableRows(ImmutableArray`1<int> rowCounts);
    private void PopulateEncLogTableEventsOrProperties(DefinitionIndex`1<T> index, TableIndex table, EditAndContinueOperation addCode, EventOrPropertyMapIndex map, TableIndex mapTable);
    private void PopulateEncLogTableFieldsOrMethods(DefinitionIndex`1<T> index, TableIndex tableIndex, EditAndContinueOperation addCode);
    private void PopulateEncLogTableParameters();
    private void PopulateEncLogTableRows(DefinitionIndex`1<T> index, TableIndex tableIndex);
    private void PopulateEncLogTableRows(TableIndex tableIndex, ImmutableArray`1<int> previousSizes, ImmutableArray`1<int> deltaSizes);
    private void PopulateEncLogTableRows(TableIndex tableIndex, int firstRowId, int tokenCount);
    protected virtual void PopulateEncMapTableRows(ImmutableArray`1<int> rowCounts);
    private static void AddReferencedTokens(ArrayBuilder`1<EntityHandle> builder, TableIndex tableIndex, ImmutableArray`1<int> previousSizes, ImmutableArray`1<int> deltaSizes);
    private static void AddReferencedTokens(ArrayBuilder`1<EntityHandle> builder, TableIndex tableIndex, int firstRowId, int nTokens);
    private static void AddDefinitionTokens(ArrayBuilder`1<EntityHandle> tokens, DefinitionIndex`1<T> index, TableIndex tableIndex);
    protected virtual void PopulateEventMapTableRows();
    protected virtual void PopulatePropertyMapTableRows();
    private bool TryGetExistingTypeDefIndex(ITypeDefinition item, Int32& index);
    private bool TryGetExistingEventDefIndex(IEventDefinition item, Int32& index);
    private bool TryGetExistingFieldDefIndex(IFieldDefinition item, Int32& index);
    private bool TryGetExistingMethodDefIndex(IMethodDefinition item, Int32& index);
    private bool TryGetExistingPropertyDefIndex(IPropertyDefinition item, Int32& index);
    private bool TryGetExistingEventMapIndex(int item, Int32& index);
    private bool TryGetExistingPropertyMapIndex(int item, Int32& index);
    private bool TryGetExistingMethodImplIndex(MethodImplKey item, Int32& index);
}
public class Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation : ValueType {
    internal int MethodOrdinal;
    internal ImmutableArray`1<LocalSlotDebugInfo> LocalSlots;
    internal ImmutableArray`1<LambdaDebugInfo> Lambdas;
    internal ImmutableArray`1<ClosureDebugInfo> Closures;
    private static byte SyntaxOffsetBaseline;
    internal EditAndContinueMethodDebugInformation(int methodOrdinal, ImmutableArray`1<LocalSlotDebugInfo> localSlots, ImmutableArray`1<ClosureDebugInfo> closures, ImmutableArray`1<LambdaDebugInfo> lambdas);
    public static EditAndContinueMethodDebugInformation Create(ImmutableArray`1<byte> compressedSlotMap, ImmutableArray`1<byte> compressedLambdaMap);
    private static InvalidDataException CreateInvalidDataException(ImmutableArray`1<byte> data, int offset);
    private static ImmutableArray`1<LocalSlotDebugInfo> UncompressSlotMap(ImmutableArray`1<byte> compressedSlotMap);
    internal void SerializeLocalSlots(BlobBuilder writer);
    private static void UncompressLambdaMap(ImmutableArray`1<byte> compressedLambdaMap, Int32& methodOrdinal, ImmutableArray`1& closures, ImmutableArray`1& lambdas);
    internal void SerializeLambdaMap(BlobBuilder writer);
}
public class Microsoft.CodeAnalysis.Emit.EmitBaseline : object {
    private static ImmutableArray`1<int> s_emptyTableSizes;
    [CompilerGeneratedAttribute]
private EmitBaseline <InitialBaseline>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleMetadata <OriginalMetadata>k__BackingField;
    internal MetadataSymbols LazyMetadataSymbols;
    internal Compilation Compilation;
    internal CommonPEModuleBuilder PEModuleBuilder;
    internal Guid ModuleVersionId;
    internal bool HasPortablePdb;
    internal int Ordinal;
    internal Guid EncId;
    internal IReadOnlyDictionary`2<ITypeDefinition, int> TypesAdded;
    internal IReadOnlyDictionary`2<IEventDefinition, int> EventsAdded;
    internal IReadOnlyDictionary`2<IFieldDefinition, int> FieldsAdded;
    internal IReadOnlyDictionary`2<IMethodDefinition, int> MethodsAdded;
    internal IReadOnlyDictionary`2<IPropertyDefinition, int> PropertiesAdded;
    internal IReadOnlyDictionary`2<int, int> EventMapAdded;
    internal IReadOnlyDictionary`2<int, int> PropertyMapAdded;
    internal IReadOnlyDictionary`2<MethodImplKey, int> MethodImplsAdded;
    internal ImmutableArray`1<int> TableEntriesAdded;
    internal int BlobStreamLengthAdded;
    internal int StringStreamLengthAdded;
    internal int UserStringStreamLengthAdded;
    internal int GuidStreamLengthAdded;
    internal IReadOnlyDictionary`2<int, AddedOrChangedMethodInfo> AddedOrChangedMethods;
    internal Func`2<MethodDefinitionHandle, EditAndContinueMethodDebugInformation> DebugInformationProvider;
    internal Func`2<MethodDefinitionHandle, StandaloneSignatureHandle> LocalSignatureProvider;
    internal ImmutableArray`1<int> TableSizes;
    internal IReadOnlyDictionary`2<int, int> TypeToEventMap;
    internal IReadOnlyDictionary`2<int, int> TypeToPropertyMap;
    internal IReadOnlyDictionary`2<MethodImplKey, int> MethodImpls;
    private IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> _anonymousTypeMap;
    internal ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> SynthesizedMembers;
    internal EmitBaseline InitialBaseline { get; }
    public ModuleMetadata OriginalMetadata { get; }
    internal IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> AnonymousTypeMap { get; }
    internal MetadataReader MetadataReader { get; }
    internal int BlobStreamLength { get; }
    internal int StringStreamLength { get; }
    internal int UserStringStreamLength { get; }
    internal int GuidStreamLength { get; }
    private EmitBaseline(EmitBaseline initialBaseline, ModuleMetadata module, Compilation compilation, CommonPEModuleBuilder moduleBuilder, Guid moduleVersionId, int ordinal, Guid encId, bool hasPortablePdb, IReadOnlyDictionary`2<ITypeDefinition, int> typesAdded, IReadOnlyDictionary`2<IEventDefinition, int> eventsAdded, IReadOnlyDictionary`2<IFieldDefinition, int> fieldsAdded, IReadOnlyDictionary`2<IMethodDefinition, int> methodsAdded, IReadOnlyDictionary`2<IPropertyDefinition, int> propertiesAdded, IReadOnlyDictionary`2<int, int> eventMapAdded, IReadOnlyDictionary`2<int, int> propertyMapAdded, IReadOnlyDictionary`2<MethodImplKey, int> methodImplsAdded, ImmutableArray`1<int> tableEntriesAdded, int blobStreamLengthAdded, int stringStreamLengthAdded, int userStringStreamLengthAdded, int guidStreamLengthAdded, IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> anonymousTypeMap, ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> synthesizedMembers, IReadOnlyDictionary`2<int, AddedOrChangedMethodInfo> methodsAddedOrChanged, Func`2<MethodDefinitionHandle, EditAndContinueMethodDebugInformation> debugInformationProvider, Func`2<MethodDefinitionHandle, StandaloneSignatureHandle> localSignatureProvider, IReadOnlyDictionary`2<int, int> typeToEventMap, IReadOnlyDictionary`2<int, int> typeToPropertyMap, IReadOnlyDictionary`2<MethodImplKey, int> methodImpls);
    private static EmitBaseline();
    public static EmitBaseline CreateInitialBaseline(ModuleMetadata module, Func`2<MethodDefinitionHandle, EditAndContinueMethodDebugInformation> debugInformationProvider);
    public static EmitBaseline CreateInitialBaseline(ModuleMetadata module, Func`2<MethodDefinitionHandle, EditAndContinueMethodDebugInformation> debugInformationProvider, Func`2<MethodDefinitionHandle, StandaloneSignatureHandle> localSignatureProvider, bool hasPortableDebugInformation);
    [CompilerGeneratedAttribute]
internal EmitBaseline get_InitialBaseline();
    [CompilerGeneratedAttribute]
public ModuleMetadata get_OriginalMetadata();
    internal EmitBaseline With(Compilation compilation, CommonPEModuleBuilder moduleBuilder, int ordinal, Guid encId, IReadOnlyDictionary`2<ITypeDefinition, int> typesAdded, IReadOnlyDictionary`2<IEventDefinition, int> eventsAdded, IReadOnlyDictionary`2<IFieldDefinition, int> fieldsAdded, IReadOnlyDictionary`2<IMethodDefinition, int> methodsAdded, IReadOnlyDictionary`2<IPropertyDefinition, int> propertiesAdded, IReadOnlyDictionary`2<int, int> eventMapAdded, IReadOnlyDictionary`2<int, int> propertyMapAdded, IReadOnlyDictionary`2<MethodImplKey, int> methodImplsAdded, ImmutableArray`1<int> tableEntriesAdded, int blobStreamLengthAdded, int stringStreamLengthAdded, int userStringStreamLengthAdded, int guidStreamLengthAdded, IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> anonymousTypeMap, ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> synthesizedMembers, IReadOnlyDictionary`2<int, AddedOrChangedMethodInfo> addedOrChangedMethods, Func`2<MethodDefinitionHandle, EditAndContinueMethodDebugInformation> debugInformationProvider, Func`2<MethodDefinitionHandle, StandaloneSignatureHandle> localSignatureProvider);
    internal IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> get_AnonymousTypeMap();
    internal MetadataReader get_MetadataReader();
    internal int get_BlobStreamLength();
    internal int get_StringStreamLength();
    internal int get_UserStringStreamLength();
    internal int get_GuidStreamLength();
    private static ImmutableArray`1<int> CalculateTableSizes(MetadataReader reader, ImmutableArray`1<int> delta);
    private static Dictionary`2<int, int> CalculateTypePropertyMap(MetadataReader reader);
    private static Dictionary`2<int, int> CalculateTypeEventMap(MetadataReader reader);
    private static Dictionary`2<MethodImplKey, int> CalculateMethodImpls(MetadataReader reader);
    internal int GetNextAnonymousTypeIndex(bool fromDelegates);
}
internal class Microsoft.CodeAnalysis.Emit.EmitContext : ValueType {
    public CommonPEModuleBuilder Module;
    public SyntaxNode SyntaxNodeOpt;
    public DiagnosticBag Diagnostics;
    private Flags _flags;
    public bool IncludePrivateMembers { get; }
    public bool MetadataOnly { get; }
    public bool IsRefAssembly { get; }
    public EmitContext(CommonPEModuleBuilder module, SyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, bool metadataOnly, bool includePrivateMembers);
    public bool get_IncludePrivateMembers();
    public bool get_MetadataOnly();
    public bool get_IsRefAssembly();
}
public class Microsoft.CodeAnalysis.Emit.EmitDifferenceResult : EmitResult {
    [CompilerGeneratedAttribute]
private EmitBaseline <Baseline>k__BackingField;
    public EmitBaseline Baseline { get; }
    internal EmitDifferenceResult(bool success, ImmutableArray`1<Diagnostic> diagnostics, EmitBaseline baseline);
    [CompilerGeneratedAttribute]
public EmitBaseline get_Baseline();
}
public class Microsoft.CodeAnalysis.Emit.EmitOptions : object {
    internal static EmitOptions Default;
    [CompilerGeneratedAttribute]
private bool <EmitMetadataOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TolerateErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePrivateMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<InstrumentationKind> <InstrumentationKinds>k__BackingField;
    [CompilerGeneratedAttribute]
private SubsystemVersion <SubsystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HighEntropyVirtualAddressSpace>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <BaseAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private DebugInformationFormat <DebugInformationFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputNameOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PdbFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <PdbChecksumAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeMetadataVersion>k__BackingField;
    public bool EmitMetadataOnly { get; private set; }
    public bool TolerateErrors { get; private set; }
    public bool IncludePrivateMembers { get; private set; }
    public ImmutableArray`1<InstrumentationKind> InstrumentationKinds { get; private set; }
    public SubsystemVersion SubsystemVersion { get; private set; }
    public int FileAlignment { get; private set; }
    public bool HighEntropyVirtualAddressSpace { get; private set; }
    public ulong BaseAddress { get; private set; }
    public DebugInformationFormat DebugInformationFormat { get; private set; }
    public string OutputNameOverride { get; private set; }
    public string PdbFilePath { get; private set; }
    public HashAlgorithmName PdbChecksumAlgorithm { get; private set; }
    public string RuntimeMetadataVersion { get; private set; }
    internal bool EmitTestCoverageData { get; }
    public EmitOptions(bool metadataOnly, DebugInformationFormat debugInformationFormat, string pdbFilePath, string outputNameOverride, int fileAlignment, ulong baseAddress, bool highEntropyVirtualAddressSpace, SubsystemVersion subsystemVersion, string runtimeMetadataVersion, bool tolerateErrors, bool includePrivateMembers);
    public EmitOptions(bool metadataOnly, DebugInformationFormat debugInformationFormat, string pdbFilePath, string outputNameOverride, int fileAlignment, ulong baseAddress, bool highEntropyVirtualAddressSpace, SubsystemVersion subsystemVersion, string runtimeMetadataVersion, bool tolerateErrors, bool includePrivateMembers, ImmutableArray`1<InstrumentationKind> instrumentationKinds);
    public EmitOptions(bool metadataOnly, DebugInformationFormat debugInformationFormat, string pdbFilePath, string outputNameOverride, int fileAlignment, ulong baseAddress, bool highEntropyVirtualAddressSpace, SubsystemVersion subsystemVersion, string runtimeMetadataVersion, bool tolerateErrors, bool includePrivateMembers, ImmutableArray`1<InstrumentationKind> instrumentationKinds, Nullable`1<HashAlgorithmName> pdbChecksumAlgorithm);
    private EmitOptions(EmitOptions other);
    private static EmitOptions();
    [CompilerGeneratedAttribute]
public bool get_EmitMetadataOnly();
    [CompilerGeneratedAttribute]
private void set_EmitMetadataOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_TolerateErrors();
    [CompilerGeneratedAttribute]
private void set_TolerateErrors(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludePrivateMembers();
    [CompilerGeneratedAttribute]
private void set_IncludePrivateMembers(bool value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<InstrumentationKind> get_InstrumentationKinds();
    [CompilerGeneratedAttribute]
private void set_InstrumentationKinds(ImmutableArray`1<InstrumentationKind> value);
    [CompilerGeneratedAttribute]
public SubsystemVersion get_SubsystemVersion();
    [CompilerGeneratedAttribute]
private void set_SubsystemVersion(SubsystemVersion value);
    [CompilerGeneratedAttribute]
public int get_FileAlignment();
    [CompilerGeneratedAttribute]
private void set_FileAlignment(int value);
    [CompilerGeneratedAttribute]
public bool get_HighEntropyVirtualAddressSpace();
    [CompilerGeneratedAttribute]
private void set_HighEntropyVirtualAddressSpace(bool value);
    [CompilerGeneratedAttribute]
public ulong get_BaseAddress();
    [CompilerGeneratedAttribute]
private void set_BaseAddress(ulong value);
    [CompilerGeneratedAttribute]
public DebugInformationFormat get_DebugInformationFormat();
    [CompilerGeneratedAttribute]
private void set_DebugInformationFormat(DebugInformationFormat value);
    [CompilerGeneratedAttribute]
public string get_OutputNameOverride();
    [CompilerGeneratedAttribute]
private void set_OutputNameOverride(string value);
    [CompilerGeneratedAttribute]
public string get_PdbFilePath();
    [CompilerGeneratedAttribute]
private void set_PdbFilePath(string value);
    [CompilerGeneratedAttribute]
public HashAlgorithmName get_PdbChecksumAlgorithm();
    [CompilerGeneratedAttribute]
private void set_PdbChecksumAlgorithm(HashAlgorithmName value);
    [CompilerGeneratedAttribute]
public string get_RuntimeMetadataVersion();
    [CompilerGeneratedAttribute]
private void set_RuntimeMetadataVersion(string value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EmitOptions other);
    public virtual int GetHashCode();
    public static bool op_Equality(EmitOptions left, EmitOptions right);
    public static bool op_Inequality(EmitOptions left, EmitOptions right);
    internal void ValidateOptions(DiagnosticBag diagnostics, CommonMessageProvider messageProvider, bool isDeterministic);
    internal bool get_EmitTestCoverageData();
    internal static bool IsValidFileAlignment(int value);
    public EmitOptions WithEmitMetadataOnly(bool value);
    public EmitOptions WithPdbFilePath(string path);
    public EmitOptions WithPdbChecksumAlgorithm(HashAlgorithmName name);
    public EmitOptions WithOutputNameOverride(string outputName);
    public EmitOptions WithDebugInformationFormat(DebugInformationFormat format);
    public EmitOptions WithFileAlignment(int value);
    public EmitOptions WithBaseAddress(ulong value);
    public EmitOptions WithHighEntropyVirtualAddressSpace(bool value);
    public EmitOptions WithSubsystemVersion(SubsystemVersion subsystemVersion);
    public EmitOptions WithRuntimeMetadataVersion(string version);
    public EmitOptions WithTolerateErrors(bool value);
    public EmitOptions WithIncludePrivateMembers(bool value);
    public EmitOptions WithInstrumentationKinds(ImmutableArray`1<InstrumentationKind> instrumentationKinds);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.Emit.EmitResult : object {
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Diagnostic> <Diagnostics>k__BackingField;
    public bool Success { get; }
    public ImmutableArray`1<Diagnostic> Diagnostics { get; }
    internal EmitResult(bool success, ImmutableArray`1<Diagnostic> diagnostics);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<Diagnostic> get_Diagnostics();
    protected virtual string GetDebuggerDisplay();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.Emit.EncHoistedLocalInfo : ValueType {
    public LocalSlotDebugInfo SlotInfo;
    public ITypeReference Type;
    public bool IsUnused { get; }
    public EncHoistedLocalInfo(bool ignored);
    public EncHoistedLocalInfo(LocalSlotDebugInfo slotInfo, ITypeReference type);
    public bool get_IsUnused();
    public sealed virtual bool Equals(EncHoistedLocalInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.Emit.EncHoistedLocalMetadata : ValueType {
    public string Name;
    public ITypeReference Type;
    public SynthesizedLocalKind SynthesizedKind;
    public EncHoistedLocalMetadata(string name, ITypeReference type, SynthesizedLocalKind synthesizedKind);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.Emit.EncLocalInfo : ValueType {
    public LocalSlotDebugInfo SlotInfo;
    public ITypeReference Type;
    public LocalSlotConstraints Constraints;
    public Byte[] Signature;
    public bool isUnused;
    public bool IsDefault { get; }
    public bool IsUnused { get; }
    public EncLocalInfo(Byte[] signature);
    public EncLocalInfo(LocalSlotDebugInfo slotInfo, ITypeReference type, LocalSlotConstraints constraints, Byte[] signature);
    public bool get_IsDefault();
    public bool get_IsUnused();
    public sealed virtual bool Equals(EncLocalInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private string GetDebuggerDisplay();
}
internal class Microsoft.CodeAnalysis.Emit.EncVariableSlotAllocator : VariableSlotAllocator {
    private SymbolMatcher _symbolMap;
    private Func`2<SyntaxNode, SyntaxNode> _syntaxMapOpt;
    private IMethodSymbolInternal _previousTopLevelMethod;
    private DebugId _methodId;
    private IReadOnlyDictionary`2<EncLocalInfo, int> _previousLocalSlots;
    private ImmutableArray`1<EncLocalInfo> _previousLocals;
    private string _stateMachineTypeNameOpt;
    private int _hoistedLocalSlotCount;
    private IReadOnlyDictionary`2<EncHoistedLocalInfo, int> _hoistedLocalSlotsOpt;
    private int _awaiterCount;
    private IReadOnlyDictionary`2<ITypeReference, int> _awaiterMapOpt;
    private IReadOnlyDictionary`2<int, KeyValuePair`2<DebugId, int>> _lambdaMapOpt;
    private IReadOnlyDictionary`2<int, DebugId> _closureMapOpt;
    private LambdaSyntaxFacts _lambdaSyntaxFacts;
    public Nullable`1<DebugId> MethodId { get; }
    public string PreviousStateMachineTypeName { get; }
    public int PreviousHoistedLocalSlotCount { get; }
    public int PreviousAwaiterSlotCount { get; }
    public EncVariableSlotAllocator(SymbolMatcher symbolMap, Func`2<SyntaxNode, SyntaxNode> syntaxMapOpt, IMethodSymbolInternal previousTopLevelMethod, DebugId methodId, ImmutableArray`1<EncLocalInfo> previousLocals, IReadOnlyDictionary`2<int, KeyValuePair`2<DebugId, int>> lambdaMapOpt, IReadOnlyDictionary`2<int, DebugId> closureMapOpt, string stateMachineTypeNameOpt, int hoistedLocalSlotCount, IReadOnlyDictionary`2<EncHoistedLocalInfo, int> hoistedLocalSlotsOpt, int awaiterCount, IReadOnlyDictionary`2<ITypeReference, int> awaiterMapOpt, LambdaSyntaxFacts lambdaSyntaxFacts);
    public virtual Nullable`1<DebugId> get_MethodId();
    private int CalculateSyntaxOffsetInPreviousMethod(int position, SyntaxTree tree);
    public virtual void AddPreviousLocals(ArrayBuilder`1<ILocalDefinition> builder);
    private bool TryGetPreviousLocalId(SyntaxNode currentDeclarator, LocalDebugId currentId, LocalDebugId& previousId);
    public virtual LocalDefinition GetPreviousLocal(ITypeReference currentType, ILocalSymbolInternal currentLocalSymbol, string nameOpt, SynthesizedLocalKind kind, LocalDebugId id, LocalVariableAttributes pdbAttributes, LocalSlotConstraints constraints, ImmutableArray`1<bool> dynamicTransformFlags, ImmutableArray`1<string> tupleElementNames);
    public virtual string get_PreviousStateMachineTypeName();
    public virtual bool TryGetPreviousHoistedLocalSlotIndex(SyntaxNode currentDeclarator, ITypeReference currentType, SynthesizedLocalKind synthesizedKind, LocalDebugId currentId, DiagnosticBag diagnostics, Int32& slotIndex);
    public virtual int get_PreviousHoistedLocalSlotCount();
    public virtual int get_PreviousAwaiterSlotCount();
    public virtual bool TryGetPreviousAwaiterSlotIndex(ITypeReference currentType, DiagnosticBag diagnostics, Int32& slotIndex);
    private bool TryGetPreviousSyntaxOffset(SyntaxNode currentSyntax, Int32& previousSyntaxOffset);
    private bool TryGetPreviousLambdaSyntaxOffset(SyntaxNode lambdaOrLambdaBodySyntax, bool isLambdaBody, Int32& previousSyntaxOffset);
    public virtual bool TryGetPreviousClosure(SyntaxNode scopeSyntax, DebugId& closureId);
    public virtual bool TryGetPreviousLambda(SyntaxNode lambdaOrLambdaBodySyntax, bool isLambdaBody, DebugId& lambdaId);
}
internal class Microsoft.CodeAnalysis.Emit.ErrorType : object {
    public static ErrorType Singleton;
    private static string s_name;
    private string Microsoft.Cci.INamespaceTypeReference.NamespaceName { get; }
    private ushort Microsoft.Cci.INamedTypeReference.GenericParameterCount { get; }
    private bool Microsoft.Cci.INamedTypeReference.MangleName { get; }
    private bool Microsoft.Cci.ITypeReference.IsEnum { get; }
    private bool Microsoft.Cci.ITypeReference.IsValueType { get; }
    private PrimitiveTypeCode Microsoft.Cci.ITypeReference.TypeCode { get; }
    private TypeDefinitionHandle Microsoft.Cci.ITypeReference.TypeDef { get; }
    private IGenericMethodParameterReference Microsoft.Cci.ITypeReference.AsGenericMethodParameterReference { get; }
    private IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.AsGenericTypeInstanceReference { get; }
    private IGenericTypeParameterReference Microsoft.Cci.ITypeReference.AsGenericTypeParameterReference { get; }
    private INamespaceTypeReference Microsoft.Cci.ITypeReference.AsNamespaceTypeReference { get; }
    private INestedTypeReference Microsoft.Cci.ITypeReference.AsNestedTypeReference { get; }
    private ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.AsSpecializedNestedTypeReference { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    private static ErrorType();
    private sealed virtual override IUnitReference Microsoft.Cci.INamespaceTypeReference.GetUnit(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamespaceTypeReference.get_NamespaceName();
    private sealed virtual override ushort Microsoft.Cci.INamedTypeReference.get_GenericParameterCount();
    private sealed virtual override bool Microsoft.Cci.INamedTypeReference.get_MangleName();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsEnum();
    private sealed virtual override bool Microsoft.Cci.ITypeReference.get_IsValueType();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.GetResolvedType(EmitContext context);
    private sealed virtual override PrimitiveTypeCode Microsoft.Cci.ITypeReference.get_TypeCode();
    private sealed virtual override TypeDefinitionHandle Microsoft.Cci.ITypeReference.get_TypeDef();
    private sealed virtual override IGenericMethodParameterReference Microsoft.Cci.ITypeReference.get_AsGenericMethodParameterReference();
    private sealed virtual override IGenericTypeInstanceReference Microsoft.Cci.ITypeReference.get_AsGenericTypeInstanceReference();
    private sealed virtual override IGenericTypeParameterReference Microsoft.Cci.ITypeReference.get_AsGenericTypeParameterReference();
    private sealed virtual override INamespaceTypeDefinition Microsoft.Cci.ITypeReference.AsNamespaceTypeDefinition(EmitContext context);
    private sealed virtual override INamespaceTypeReference Microsoft.Cci.ITypeReference.get_AsNamespaceTypeReference();
    private sealed virtual override INestedTypeDefinition Microsoft.Cci.ITypeReference.AsNestedTypeDefinition(EmitContext context);
    private sealed virtual override INestedTypeReference Microsoft.Cci.ITypeReference.get_AsNestedTypeReference();
    private sealed virtual override ISpecializedNestedTypeReference Microsoft.Cci.ITypeReference.get_AsSpecializedNestedTypeReference();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeReference.AsTypeDefinition(EmitContext context);
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.GetAttributes(EmitContext context);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
}
public enum Microsoft.CodeAnalysis.Emit.InstrumentationKind : Enum {
    public int value__;
    public static InstrumentationKind None;
    public static InstrumentationKind TestCoverage;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Emit.InstrumentationKindExtensions : object {
    [ExtensionAttribute]
internal static bool IsValid(InstrumentationKind value);
}
internal interface Microsoft.CodeAnalysis.Emit.IPEDeltaAssemblyBuilder {
    public abstract virtual void OnCreatedIndices(DiagnosticBag diagnostics);
    public abstract virtual IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> GetAnonymousTypeMap();
}
internal class Microsoft.CodeAnalysis.Emit.IteratorMoveNextBodyDebugInfo : StateMachineMoveNextBodyDebugInfo {
    public IteratorMoveNextBodyDebugInfo(IMethodDefinition kickoffMethod);
}
internal abstract class Microsoft.CodeAnalysis.Emit.LambdaSyntaxFacts : object {
    public abstract virtual SyntaxNode GetLambda(SyntaxNode lambdaOrLambdaBodySyntax);
    public abstract virtual SyntaxNode TryGetCorrespondingLambdaBody(SyntaxNode previousLambdaSyntax, SyntaxNode lambdaOrLambdaBodySyntax);
}
internal class Microsoft.CodeAnalysis.Emit.MethodImplKey : ValueType {
    internal int ImplementingMethod;
    internal int Index;
    internal MethodImplKey(int implementingMethod, int index);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MethodImplKey other);
    public virtual int GetHashCode();
}
internal abstract class Microsoft.CodeAnalysis.Emit.NoPia.CommonEmbeddedTypesManager : object {
    public bool IsFrozen { get; }
    public abstract virtual bool get_IsFrozen();
    public abstract virtual ImmutableArray`1<INamespaceTypeDefinition> GetTypes(DiagnosticBag diagnostics, HashSet`1<string> namesOfTopLevelTypes);
}
internal abstract class Microsoft.CodeAnalysis.Emit.NoPia.EmbeddedTypesManager`21 : CommonEmbeddedTypesManager {
    public TPEModuleBuilder ModuleBeingBuilt;
    public ConcurrentDictionary`2<TNamedTypeSymbol, TEmbeddedType> EmbeddedTypesMap;
    public ConcurrentDictionary`2<TFieldSymbol, TEmbeddedField> EmbeddedFieldsMap;
    public ConcurrentDictionary`2<TMethodSymbol, TEmbeddedMethod> EmbeddedMethodsMap;
    public ConcurrentDictionary`2<TPropertySymbol, TEmbeddedProperty> EmbeddedPropertiesMap;
    public ConcurrentDictionary`2<TEventSymbol, TEmbeddedEvent> EmbeddedEventsMap;
    private ImmutableArray`1<TEmbeddedType> _frozen;
    public bool IsFrozen { get; }
    protected EmbeddedTypesManager`21(TPEModuleBuilder moduleBeingBuilt);
    public virtual bool get_IsFrozen();
    public virtual ImmutableArray`1<INamespaceTypeDefinition> GetTypes(DiagnosticBag diagnostics, HashSet`1<string> namesOfTopLevelTypes);
    private bool HasNameConflict(HashSet`1<string> namesOfTopLevelTypes, TEmbeddedType type, DiagnosticBag diagnostics);
    internal abstract virtual int GetTargetAttributeSignatureIndex(TSymbol underlyingSymbol, TAttributeData attrData, AttributeDescription description);
    internal bool IsTargetAttribute(TSymbol underlyingSymbol, TAttributeData attrData, AttributeDescription description);
    internal abstract virtual TAttributeData CreateSynthesizedAttribute(WellKnownMember constructor, TAttributeData attrData, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal abstract virtual void ReportIndirectReferencesToLinkedAssemblies(TAssemblySymbol assembly, DiagnosticBag diagnostics);
    protected abstract virtual void OnGetTypesCompleted(ImmutableArray`1<TEmbeddedType> types, DiagnosticBag diagnostics);
    protected abstract virtual void ReportNameCollisionBetweenEmbeddedTypes(TEmbeddedType typeA, TEmbeddedType typeB, DiagnosticBag diagnostics);
    protected abstract virtual void ReportNameCollisionWithAlreadyDeclaredType(TEmbeddedType type, DiagnosticBag diagnostics);
    protected abstract virtual TAttributeData CreateCompilerGeneratedAttribute();
    protected void EmbedReferences(ITypeDefinitionMember embeddedMember, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    protected abstract virtual TEmbeddedType GetEmbeddedTypeForMember(TSymbol member, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal abstract virtual TEmbeddedField EmbedField(TEmbeddedType type, TFieldSymbol field, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal abstract virtual TEmbeddedMethod EmbedMethod(TEmbeddedType type, TMethodSymbol method, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal abstract virtual TEmbeddedProperty EmbedProperty(TEmbeddedType type, TPropertySymbol property, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal abstract virtual TEmbeddedEvent EmbedEvent(TEmbeddedType type, TEventSymbol event, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, bool isUsedForComAwareEventBinding);
    internal IFieldReference EmbedFieldIfNeedTo(TFieldSymbol fieldSymbol, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal IMethodReference EmbedMethodIfNeedTo(TMethodSymbol methodSymbol, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal void EmbedEventIfNeedTo(TEventSymbol eventSymbol, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics, bool isUsedForComAwareEventBinding);
    internal void EmbedPropertyIfNeedTo(TPropertySymbol propertySymbol, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
}
internal class Microsoft.CodeAnalysis.Emit.NoPia.VtblGap : object {
    public ITypeDefinition ContainingType;
    private string _name;
    private IEnumerable`1<IGenericMethodParameter> Microsoft.Cci.IMethodDefinition.GenericParameters { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsImplicitlyDeclared { get; }
    private bool Microsoft.Cci.IMethodDefinition.HasDeclarativeSecurity { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsAbstract { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsAccessCheckedOnOverride { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsConstructor { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsExternal { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsHiddenBySignature { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsNewSlot { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsPlatformInvoke { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsRuntimeSpecial { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsSealed { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsSpecialName { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsStatic { get; }
    private bool Microsoft.Cci.IMethodDefinition.IsVirtual { get; }
    private ImmutableArray`1<IParameterDefinition> Microsoft.Cci.IMethodDefinition.Parameters { get; }
    private IPlatformInvokeInformation Microsoft.Cci.IMethodDefinition.PlatformInvokeData { get; }
    private bool Microsoft.Cci.IMethodDefinition.RequiresSecurityObject { get; }
    private bool Microsoft.Cci.IMethodDefinition.ReturnValueIsMarshalledExplicitly { get; }
    private IMarshallingInformation Microsoft.Cci.IMethodDefinition.ReturnValueMarshallingInformation { get; }
    private ImmutableArray`1<byte> Microsoft.Cci.IMethodDefinition.ReturnValueMarshallingDescriptor { get; }
    private IEnumerable`1<SecurityAttribute> Microsoft.Cci.IMethodDefinition.SecurityAttributes { get; }
    private ITypeDefinition Microsoft.Cci.ITypeDefinitionMember.ContainingTypeDefinition { get; }
    private INamespace Microsoft.Cci.IMethodDefinition.ContainingNamespace { get; }
    private TypeMemberVisibility Microsoft.Cci.ITypeDefinitionMember.Visibility { get; }
    private string Microsoft.Cci.INamedEntity.Name { get; }
    private bool Microsoft.Cci.IMethodReference.AcceptsExtraArguments { get; }
    private ushort Microsoft.Cci.IMethodReference.GenericParameterCount { get; }
    private bool Microsoft.Cci.IMethodReference.IsGeneric { get; }
    private ImmutableArray`1<IParameterTypeInformation> Microsoft.Cci.IMethodReference.ExtraParameters { get; }
    private IGenericMethodInstanceReference Microsoft.Cci.IMethodReference.AsGenericMethodInstanceReference { get; }
    private ISpecializedMethodReference Microsoft.Cci.IMethodReference.AsSpecializedMethodReference { get; }
    private CallingConvention Microsoft.Cci.ISignature.CallingConvention { get; }
    private ushort Microsoft.Cci.ISignature.ParameterCount { get; }
    private ImmutableArray`1<ICustomModifier> Microsoft.Cci.ISignature.ReturnValueCustomModifiers { get; }
    private ImmutableArray`1<ICustomModifier> Microsoft.Cci.ISignature.RefCustomModifiers { get; }
    private bool Microsoft.Cci.ISignature.ReturnValueIsByRef { get; }
    public VtblGap(ITypeDefinition containingType, string name);
    private sealed virtual override IMethodBody Microsoft.Cci.IMethodDefinition.GetBody(EmitContext context);
    private sealed virtual override IEnumerable`1<IGenericMethodParameter> Microsoft.Cci.IMethodDefinition.get_GenericParameters();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsImplicitlyDeclared();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_HasDeclarativeSecurity();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsAbstract();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsAccessCheckedOnOverride();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsConstructor();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsExternal();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsHiddenBySignature();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsNewSlot();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsPlatformInvoke();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsRuntimeSpecial();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsSealed();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsSpecialName();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsStatic();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_IsVirtual();
    private sealed virtual override MethodImplAttributes Microsoft.Cci.IMethodDefinition.GetImplementationAttributes(EmitContext context);
    private sealed virtual override ImmutableArray`1<IParameterDefinition> Microsoft.Cci.IMethodDefinition.get_Parameters();
    private sealed virtual override IPlatformInvokeInformation Microsoft.Cci.IMethodDefinition.get_PlatformInvokeData();
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_RequiresSecurityObject();
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IMethodDefinition.GetReturnValueAttributes(EmitContext context);
    private sealed virtual override bool Microsoft.Cci.IMethodDefinition.get_ReturnValueIsMarshalledExplicitly();
    private sealed virtual override IMarshallingInformation Microsoft.Cci.IMethodDefinition.get_ReturnValueMarshallingInformation();
    private sealed virtual override ImmutableArray`1<byte> Microsoft.Cci.IMethodDefinition.get_ReturnValueMarshallingDescriptor();
    private sealed virtual override IEnumerable`1<SecurityAttribute> Microsoft.Cci.IMethodDefinition.get_SecurityAttributes();
    private sealed virtual override ITypeDefinition Microsoft.Cci.ITypeDefinitionMember.get_ContainingTypeDefinition();
    private sealed virtual override INamespace Microsoft.Cci.IMethodDefinition.get_ContainingNamespace();
    private sealed virtual override TypeMemberVisibility Microsoft.Cci.ITypeDefinitionMember.get_Visibility();
    private sealed virtual override ITypeReference Microsoft.Cci.ITypeMemberReference.GetContainingType(EmitContext context);
    private sealed virtual override IEnumerable`1<ICustomAttribute> Microsoft.Cci.IReference.GetAttributes(EmitContext context);
    private sealed virtual override void Microsoft.Cci.IReference.Dispatch(MetadataVisitor visitor);
    private sealed virtual override IDefinition Microsoft.Cci.IReference.AsDefinition(EmitContext context);
    private sealed virtual override string Microsoft.Cci.INamedEntity.get_Name();
    private sealed virtual override bool Microsoft.Cci.IMethodReference.get_AcceptsExtraArguments();
    private sealed virtual override ushort Microsoft.Cci.IMethodReference.get_GenericParameterCount();
    private sealed virtual override bool Microsoft.Cci.IMethodReference.get_IsGeneric();
    private sealed virtual override IMethodDefinition Microsoft.Cci.IMethodReference.GetResolvedMethod(EmitContext context);
    private sealed virtual override ImmutableArray`1<IParameterTypeInformation> Microsoft.Cci.IMethodReference.get_ExtraParameters();
    private sealed virtual override IGenericMethodInstanceReference Microsoft.Cci.IMethodReference.get_AsGenericMethodInstanceReference();
    private sealed virtual override ISpecializedMethodReference Microsoft.Cci.IMethodReference.get_AsSpecializedMethodReference();
    private sealed virtual override CallingConvention Microsoft.Cci.ISignature.get_CallingConvention();
    private sealed virtual override ushort Microsoft.Cci.ISignature.get_ParameterCount();
    private sealed virtual override ImmutableArray`1<IParameterTypeInformation> Microsoft.Cci.ISignature.GetParameters(EmitContext context);
    private sealed virtual override ImmutableArray`1<ICustomModifier> Microsoft.Cci.ISignature.get_ReturnValueCustomModifiers();
    private sealed virtual override ImmutableArray`1<ICustomModifier> Microsoft.Cci.ISignature.get_RefCustomModifiers();
    private sealed virtual override bool Microsoft.Cci.ISignature.get_ReturnValueIsByRef();
    private sealed virtual override ITypeReference Microsoft.Cci.ISignature.GetType(EmitContext context);
}
internal abstract class Microsoft.CodeAnalysis.Emit.PEModuleBuilder`9 : CommonPEModuleBuilder {
    private RootModuleType _rootModuleType;
    internal TSourceModuleSymbol SourceModule;
    internal TCompilation Compilation;
    private PrivateImplementationDetails _privateImplementationDetails;
    private ArrayMethods _lazyArrayMethods;
    private HashSet`1<string> _namesOfTopLevelTypes;
    internal TModuleCompilationState CompilationState;
    private ConcurrentDictionary`2<TNamedTypeSymbol, SynthesizedDefinitions<TCompilation, TSourceModuleSymbol, TAssemblySymbol, TTypeSymbol, TNamedTypeSymbol, TMethodSymbol, TSyntaxNode, TEmbeddedTypesManager, TModuleCompilationState>> _synthesizedDefs;
    public TEmbeddedTypesManager EmbeddedTypesManagerOpt { get; }
    internal IAssemblySymbol CommonCorLibrary { get; }
    internal TAssemblySymbol CorLibrary { get; }
    protected bool HaveDeterminedTopLevelTypes { get; }
    internal IModuleSymbol CommonSourceModule { get; }
    internal Compilation CommonCompilation { get; }
    internal CommonModuleCompilationState CommonModuleCompilationState { get; }
    internal CommonEmbeddedTypesManager CommonEmbeddedTypesManagerOpt { get; }
    public ArrayMethods ArrayMethods { get; }
    internal PrivateImplementationDetails PrivateImplClass { get; }
    internal bool SupportsPrivateImplClass { get; }
    protected PEModuleBuilder`9(TCompilation compilation, TSourceModuleSymbol sourceModule, ModulePropertiesForSerialization serializationProperties, IEnumerable`1<ResourceDescription> manifestResources, OutputKind outputKind, EmitOptions emitOptions, TModuleCompilationState compilationState);
    public abstract virtual TEmbeddedTypesManager get_EmbeddedTypesManagerOpt();
    internal sealed virtual void CompilationFinished();
    internal virtual IAssemblySymbol get_CommonCorLibrary();
    internal abstract virtual TAssemblySymbol get_CorLibrary();
    internal abstract virtual INamedTypeReference GetSystemType(TSyntaxNode syntaxOpt, DiagnosticBag diagnostics);
    internal abstract virtual INamedTypeReference GetSpecialType(SpecialType specialType, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal sealed virtual ITypeReference EncTranslateType(ITypeSymbol type, DiagnosticBag diagnostics);
    internal virtual ITypeReference EncTranslateLocalVariableType(TTypeSymbol type, DiagnosticBag diagnostics);
    protected bool get_HaveDeterminedTopLevelTypes();
    protected bool ContainsTopLevelType(string fullEmittedName);
    internal abstract virtual IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypesCore(EmitContext context);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Emit.PEModuleBuilder`9/<GetTopLevelTypes>d__23")]
public virtual IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypes(EmitContext context);
    internal abstract virtual IAssemblyReference Translate(TAssemblySymbol symbol, DiagnosticBag diagnostics);
    internal abstract virtual ITypeReference Translate(TTypeSymbol symbol, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal abstract virtual IMethodReference Translate(TMethodSymbol symbol, DiagnosticBag diagnostics, bool needDeclaration);
    internal sealed virtual IAssemblyReference Translate(IAssemblySymbol symbol, DiagnosticBag diagnostics);
    internal sealed virtual ITypeReference Translate(ITypeSymbol symbol, SyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal sealed virtual IMethodReference Translate(IMethodSymbol symbol, DiagnosticBag diagnostics, bool needDeclaration);
    internal sealed virtual IModuleSymbol get_CommonSourceModule();
    internal sealed virtual Compilation get_CommonCompilation();
    internal sealed virtual CommonModuleCompilationState get_CommonModuleCompilationState();
    internal sealed virtual CommonEmbeddedTypesManager get_CommonEmbeddedTypesManagerOpt();
    internal MetadataConstant CreateConstant(TTypeSymbol type, object value, TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    private static void AddTopLevelType(HashSet`1<string> names, INamespaceTypeDefinition type);
    private static void VisitTopLevelType(NoPiaReferenceIndexer noPiaIndexer, INamespaceTypeDefinition type);
    internal IFieldReference GetModuleVersionId(ITypeReference mvidType, TSyntaxNode syntaxOpt, DiagnosticBag diagnostics);
    internal IFieldReference GetInstrumentationPayloadRoot(int analysisKind, ITypeReference payloadType, TSyntaxNode syntaxOpt, DiagnosticBag diagnostics);
    private void EnsurePrivateImplementationDetailsStaticConstructor(PrivateImplementationDetails details, TSyntaxNode syntaxOpt, DiagnosticBag diagnostics);
    protected abstract virtual IMethodDefinition CreatePrivateImplementationDetailsStaticConstructor(PrivateImplementationDetails details, TSyntaxNode syntaxOpt, DiagnosticBag diagnostics);
    public void AddSynthesizedDefinition(TNamedTypeSymbol container, INestedTypeDefinition nestedType);
    internal abstract virtual IEnumerable`1<INestedTypeDefinition> GetSynthesizedNestedTypes(TNamedTypeSymbol container);
    public IEnumerable`1<INestedTypeDefinition> GetSynthesizedTypes(TNamedTypeSymbol container);
    private SynthesizedDefinitions<TCompilation, TSourceModuleSymbol, TAssemblySymbol, TTypeSymbol, TNamedTypeSymbol, TMethodSymbol, TSyntaxNode, TEmbeddedTypesManager, TModuleCompilationState> GetCacheOfSynthesizedDefinitions(TNamedTypeSymbol container, bool addIfNotFound);
    public void AddSynthesizedDefinition(TNamedTypeSymbol container, IMethodDefinition method);
    public IEnumerable`1<IMethodDefinition> GetSynthesizedMethods(TNamedTypeSymbol container);
    public void AddSynthesizedDefinition(TNamedTypeSymbol container, IPropertyDefinition property);
    public IEnumerable`1<IPropertyDefinition> GetSynthesizedProperties(TNamedTypeSymbol container);
    public void AddSynthesizedDefinition(TNamedTypeSymbol container, IFieldDefinition field);
    public IEnumerable`1<IFieldDefinition> GetSynthesizedFields(TNamedTypeSymbol container);
    internal virtual ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> GetSynthesizedMembers();
    public ImmutableArray`1<ITypeDefinitionMember> GetSynthesizedMembers(ITypeDefinition container);
    private sealed virtual override IFieldReference Microsoft.CodeAnalysis.CodeGen.ITokenDeferral.GetFieldForData(ImmutableArray`1<byte> data, SyntaxNode syntaxNode, DiagnosticBag diagnostics);
    public abstract virtual IMethodReference GetInitArrayHelper();
    public sealed virtual ArrayMethods get_ArrayMethods();
    internal PrivateImplementationDetails GetPrivateImplClass(TSyntaxNode syntaxNodeOpt, DiagnosticBag diagnostics);
    internal PrivateImplementationDetails get_PrivateImplClass();
    internal virtual bool get_SupportsPrivateImplClass();
    public sealed virtual ITypeReference GetPlatformType(PlatformType platformType, EmitContext context);
}
public class Microsoft.CodeAnalysis.Emit.SemanticEdit : ValueType {
    [CompilerGeneratedAttribute]
private SemanticEditKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <OldSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <NewSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<SyntaxNode, SyntaxNode> <SyntaxMap>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreserveLocalVariables>k__BackingField;
    public SemanticEditKind Kind { get; }
    public ISymbol OldSymbol { get; }
    public ISymbol NewSymbol { get; }
    public Func`2<SyntaxNode, SyntaxNode> SyntaxMap { get; }
    public bool PreserveLocalVariables { get; }
    public SemanticEdit(SemanticEditKind kind, ISymbol oldSymbol, ISymbol newSymbol, Func`2<SyntaxNode, SyntaxNode> syntaxMap, bool preserveLocalVariables);
    [CompilerGeneratedAttribute]
public SemanticEditKind get_Kind();
    [CompilerGeneratedAttribute]
public ISymbol get_OldSymbol();
    [CompilerGeneratedAttribute]
public ISymbol get_NewSymbol();
    [CompilerGeneratedAttribute]
public Func`2<SyntaxNode, SyntaxNode> get_SyntaxMap();
    [CompilerGeneratedAttribute]
public bool get_PreserveLocalVariables();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SemanticEdit other);
}
public enum Microsoft.CodeAnalysis.Emit.SemanticEditKind : Enum {
    public int value__;
    public static SemanticEditKind None;
    public static SemanticEditKind Update;
    public static SemanticEditKind Insert;
    public static SemanticEditKind Delete;
}
internal abstract class Microsoft.CodeAnalysis.Emit.StateMachineMoveNextBodyDebugInfo : object {
    public IMethodDefinition KickoffMethod;
    public StateMachineMoveNextBodyDebugInfo(IMethodDefinition kickoffMethod);
}
internal enum Microsoft.CodeAnalysis.Emit.SymbolChange : Enum {
    public int value__;
    public static SymbolChange None;
    public static SymbolChange ContainsChanges;
    public static SymbolChange Updated;
    public static SymbolChange Added;
}
internal class Microsoft.CodeAnalysis.Emit.SymbolChanges : object {
    private DefinitionMap _definitionMap;
    private IReadOnlyDictionary`2<ISymbol, SymbolChange> _changes;
    private Func`2<ISymbol, bool> _isAddedSymbol;
    public SymbolChanges(DefinitionMap definitionMap, IEnumerable`1<SemanticEdit> edits, Func`2<ISymbol, bool> isAddedSymbol);
    public bool IsAdded(ISymbol symbol);
    public bool RequiresCompilation(ISymbol symbol);
    public SymbolChange GetChange(IDefinition def);
    private SymbolChange GetChange(ISymbol symbol);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Emit.SymbolChanges/<GetTopLevelTypes>d__8")]
public IEnumerable`1<INamespaceTypeDefinition> GetTopLevelTypes(EmitContext context);
    private static IReadOnlyDictionary`2<ISymbol, SymbolChange> CalculateChanges(IEnumerable`1<SemanticEdit> edits);
    private static void AddContainingTypes(Dictionary`2<ISymbol, SymbolChange> changes, ISymbol symbol);
    private static ISymbol GetContainingSymbol(ISymbol symbol);
}
internal abstract class Microsoft.CodeAnalysis.Emit.SymbolMatcher : object {
    public abstract virtual ITypeReference MapReference(ITypeReference reference);
    public abstract virtual IDefinition MapDefinition(IDefinition reference);
    public EmitBaseline MapBaselineToCompilation(EmitBaseline baseline, Compilation targetCompilation, CommonPEModuleBuilder targetModuleBuilder, ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> mappedSynthesizedMembers);
    private IReadOnlyDictionary`2<K, V> MapDefinitions(IReadOnlyDictionary`2<K, V> items);
    private IReadOnlyDictionary`2<int, AddedOrChangedMethodInfo> MapAddedOrChangedMethods(IReadOnlyDictionary`2<int, AddedOrChangedMethodInfo> addedOrChangedMethods);
    private IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> MapAnonymousTypes(IReadOnlyDictionary`2<AnonymousTypeKey, AnonymousTypeValue> anonymousTypeMap);
    internal ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> MapSynthesizedMembers(ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> previousMembers, ImmutableDictionary`2<ITypeDefinition, ImmutableArray`1<ITypeDefinitionMember>> newMembers);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EnumBounds : object {
    [ExtensionAttribute]
internal static bool IsValid(OptimizationLevel value);
    [ExtensionAttribute]
internal static bool IsValid(Platform value);
    [ExtensionAttribute]
internal static bool Requires64Bit(Platform value);
    [ExtensionAttribute]
internal static bool Requires32Bit(Platform value);
    [ExtensionAttribute]
internal static bool IsValid(MetadataImportOptions value);
    [ExtensionAttribute]
internal static bool IsValid(MetadataImageKind kind);
    [ExtensionAttribute]
internal static bool IsValid(OutputKind value);
    [ExtensionAttribute]
internal static string GetDefaultExtension(OutputKind kind);
    [ExtensionAttribute]
internal static bool IsApplication(OutputKind kind);
    [ExtensionAttribute]
internal static bool IsNetModule(OutputKind kind);
    [ExtensionAttribute]
internal static bool IsWindowsRuntime(OutputKind kind);
    [ExtensionAttribute]
internal static bool IsValid(SymbolDisplayPartKind value);
}
internal static class Microsoft.CodeAnalysis.EnumConstantHelper : object {
    internal static EnumOverflowKind OffsetValue(ConstantValue constantValue, UInt32 offset, ConstantValue& offsetValue);
    private static EnumOverflowKind CheckOverflow(long maxOffset, long previous, UInt32 offset);
    private static EnumOverflowKind CheckOverflow(ulong maxOffset, ulong previous, UInt32 offset);
    private static EnumOverflowKind CheckOverflow(ulong maxOffset, UInt32 offset);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EnumerableExtensions : object {
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, V> ToImmutableDictionaryOrEmpty(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, V> ToImmutableDictionaryOrEmpty(IEnumerable`1<KeyValuePair`2<K, V>> items, IEqualityComparer`1<K> keyComparer);
    [ExtensionAttribute]
internal static IList`1<IList`1<T>> Transpose(IEnumerable`1<IEnumerable`1<T>> data);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.EnumerableExtensions/<TransposeInternal>d__3`1")]
[ExtensionAttribute]
private static IEnumerable`1<IList`1<T>> TransposeInternal(IEnumerable`1<IEnumerable`1<T>> data);
    [ExtensionAttribute]
internal static void AddAllValues(IDictionary`2<K, ImmutableArray`1<T>> data, ArrayBuilder`1<T> builder);
    [ExtensionAttribute]
internal static Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(IEnumerable`1<T> data, Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    [ExtensionAttribute]
internal static TSource AsSingleton(IEnumerable`1<TSource> source);
}
internal enum Microsoft.CodeAnalysis.EnumOverflowKind : Enum {
    public int value__;
    public static EnumOverflowKind NoOverflow;
    public static EnumOverflowKind OverflowReport;
    public static EnumOverflowKind OverflowIgnore;
}
internal abstract class Microsoft.CodeAnalysis.ErrorLogger : object {
    public abstract virtual void LogDiagnostic(Diagnostic diagnostic);
}
internal class Microsoft.CodeAnalysis.ExternalFileLocation : Location {
    private TextSpan _sourceSpan;
    private FileLinePositionSpan _lineSpan;
    public TextSpan SourceSpan { get; }
    public LocationKind Kind { get; }
    internal ExternalFileLocation(string filePath, TextSpan sourceSpan, LinePositionSpan lineSpan);
    public virtual TextSpan get_SourceSpan();
    public virtual FileLinePositionSpan GetLineSpan();
    public virtual FileLinePositionSpan GetMappedLineSpan();
    public virtual LocationKind get_Kind();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ExternalFileLocation obj);
    public virtual int GetHashCode();
}
internal static class Microsoft.CodeAnalysis.FailFast : object {
    [DebuggerHiddenAttribute]
internal static void OnFatalException(Exception exception);
    [ConditionalAttribute("DEBUG")]
[DebuggerHiddenAttribute]
internal static void Assert(bool condition, string message);
}
internal static class Microsoft.CodeAnalysis.FatalError : object {
    private static Action`1<Exception> s_fatalHandler;
    private static Action`1<Exception> s_nonFatalHandler;
    private static Exception s_reportedException;
    private static string s_reportedExceptionMessage;
    private static object s_reportedMarker;
    public static Action`1<Exception> Handler { get; public set; }
    public static Action`1<Exception> NonFatalHandler { get; public set; }
    private static FatalError();
    public static Action`1<Exception> get_Handler();
    public static void set_Handler(Action`1<Exception> value);
    public static Action`1<Exception> get_NonFatalHandler();
    public static void set_NonFatalHandler(Action`1<Exception> value);
    public static void OverwriteHandler(Action`1<Exception> value);
    [DebuggerHiddenAttribute]
public static bool ReportUnlessCanceled(Exception exception);
    [DebuggerHiddenAttribute]
public static bool ReportWithoutCrashUnlessCanceled(Exception exception);
    [DebuggerHiddenAttribute]
public static bool ReportUnlessNotImplemented(Exception exception);
    [DebuggerHiddenAttribute]
public static bool Report(Exception exception);
    [DebuggerHiddenAttribute]
public static bool ReportWithoutCrash(Exception exception);
    [DebuggerHiddenAttribute]
public static bool ReportWithoutCrashAndPropagate(Exception exception);
    [DebuggerHiddenAttribute]
public static bool ReportWithoutCrashUnlessCanceledAndPropagate(Exception exception);
    private static void Report(Exception exception, Action`1<Exception> handler);
}
public class Microsoft.CodeAnalysis.FileLinePositionSpan : ValueType {
    private string _path;
    private LinePositionSpan _span;
    private bool _hasMappedPath;
    public string Path { get; }
    public bool HasMappedPath { get; }
    public LinePosition StartLinePosition { get; }
    public LinePosition EndLinePosition { get; }
    public LinePositionSpan Span { get; }
    public bool IsValid { get; }
    public FileLinePositionSpan(string path, LinePosition start, LinePosition end);
    public FileLinePositionSpan(string path, LinePositionSpan span);
    internal FileLinePositionSpan(string path, LinePositionSpan span, bool hasMappedPath);
    public string get_Path();
    public bool get_HasMappedPath();
    public LinePosition get_StartLinePosition();
    public LinePosition get_EndLinePosition();
    public LinePositionSpan get_Span();
    public bool get_IsValid();
    public sealed virtual bool Equals(FileLinePositionSpan other);
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.FileSystemExtensions : object {
    [ExtensionAttribute]
public static EmitResult Emit(Compilation compilation, string outputPath, string pdbPath, string xmlDocPath, string win32ResourcesPath, IEnumerable`1<ResourceDescription> manifestResources, CancellationToken cancellationToken);
}
public class Microsoft.CodeAnalysis.FlowAnalysis.BasicBlock : object {
    private ControlFlowBranch _lazySuccessor;
    private ControlFlowBranch _lazyConditionalSuccessor;
    private ImmutableArray`1<ControlFlowBranch> _lazyPredecessors;
    [CompilerGeneratedAttribute]
private BasicBlockKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <Operations>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <BranchValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowConditionKind <ConditionKind>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Ordinal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReachable>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowRegion <EnclosingRegion>k__BackingField;
    public BasicBlockKind Kind { get; }
    public ImmutableArray`1<IOperation> Operations { get; }
    public IOperation BranchValue { get; }
    public ControlFlowConditionKind ConditionKind { get; }
    public ControlFlowBranch FallThroughSuccessor { get; }
    public ControlFlowBranch ConditionalSuccessor { get; }
    public ImmutableArray`1<ControlFlowBranch> Predecessors { get; }
    public int Ordinal { get; }
    public bool IsReachable { get; }
    public ControlFlowRegion EnclosingRegion { get; }
    internal BasicBlock(BasicBlockKind kind, ImmutableArray`1<IOperation> operations, IOperation branchValue, ControlFlowConditionKind conditionKind, int ordinal, bool isReachable, ControlFlowRegion region);
    [CompilerGeneratedAttribute]
public BasicBlockKind get_Kind();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IOperation> get_Operations();
    [CompilerGeneratedAttribute]
public IOperation get_BranchValue();
    [CompilerGeneratedAttribute]
public ControlFlowConditionKind get_ConditionKind();
    public ControlFlowBranch get_FallThroughSuccessor();
    public ControlFlowBranch get_ConditionalSuccessor();
    public ImmutableArray`1<ControlFlowBranch> get_Predecessors();
    [CompilerGeneratedAttribute]
public int get_Ordinal();
    [CompilerGeneratedAttribute]
public bool get_IsReachable();
    [CompilerGeneratedAttribute]
public ControlFlowRegion get_EnclosingRegion();
    internal void SetSuccessors(ControlFlowBranch successor, ControlFlowBranch conditionalSuccessor);
    internal void SetPredecessors(ImmutableArray`1<ControlFlowBranch> predecessors);
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockKind : Enum {
    public int value__;
    public static BasicBlockKind Entry;
    public static BasicBlockKind Exit;
    public static BasicBlockKind Block;
}
public class Microsoft.CodeAnalysis.FlowAnalysis.CaptureId : ValueType {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    internal int Value { get; }
    internal CaptureId(int value);
    [CompilerGeneratedAttribute]
internal int get_Value();
    public sealed virtual bool Equals(CaptureId other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranch : object {
    private ImmutableArray`1<ControlFlowRegion> _lazyLeavingRegions;
    private ImmutableArray`1<ControlFlowRegion> _lazyFinallyRegions;
    private ImmutableArray`1<ControlFlowRegion> _lazyEnteringRegions;
    [CompilerGeneratedAttribute]
private BasicBlock <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private BasicBlock <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowBranchSemantics <Semantics>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConditionalSuccessor>k__BackingField;
    public BasicBlock Source { get; }
    public BasicBlock Destination { get; }
    public ControlFlowBranchSemantics Semantics { get; }
    public bool IsConditionalSuccessor { get; }
    public ImmutableArray`1<ControlFlowRegion> LeavingRegions { get; }
    public ImmutableArray`1<ControlFlowRegion> EnteringRegions { get; }
    public ImmutableArray`1<ControlFlowRegion> FinallyRegions { get; }
    internal ControlFlowBranch(BasicBlock source, BasicBlock destination, ControlFlowBranchSemantics semantics, bool isConditionalSuccessor);
    [CompilerGeneratedAttribute]
public BasicBlock get_Source();
    [CompilerGeneratedAttribute]
public BasicBlock get_Destination();
    [CompilerGeneratedAttribute]
public ControlFlowBranchSemantics get_Semantics();
    [CompilerGeneratedAttribute]
public bool get_IsConditionalSuccessor();
    public ImmutableArray`1<ControlFlowRegion> get_LeavingRegions();
    private static ArrayBuilder`1<ControlFlowRegion> CollectRegions(int destinationOrdinal, ControlFlowRegion source);
    public ImmutableArray`1<ControlFlowRegion> get_EnteringRegions();
    public ImmutableArray`1<ControlFlowRegion> get_FinallyRegions();
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowBranchSemantics : Enum {
    public int value__;
    public static ControlFlowBranchSemantics None;
    public static ControlFlowBranchSemantics Regular;
    public static ControlFlowBranchSemantics Return;
    public static ControlFlowBranchSemantics StructuredExceptionHandling;
    public static ControlFlowBranchSemantics ProgramTermination;
    public static ControlFlowBranchSemantics Throw;
    public static ControlFlowBranchSemantics Rethrow;
    public static ControlFlowBranchSemantics Error;
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowConditionKind : Enum {
    public int value__;
    public static ControlFlowConditionKind None;
    public static ControlFlowConditionKind WhenFalse;
    public static ControlFlowConditionKind WhenTrue;
}
public class Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraph : object {
    private CaptureIdDispenser _captureIdDispenser;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<IMethodSymbol, ValueTuple`3<ControlFlowRegion, ILocalFunctionOperation, int>> _localFunctionsMap;
    private ControlFlowGraph[] _lazyLocalFunctionsGraphs;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<IFlowAnonymousFunctionOperation, ValueTuple`2<ControlFlowRegion, int>> _anonymousFunctionsMap;
    private ControlFlowGraph[] _lazyAnonymousFunctionsGraphs;
    [CompilerGeneratedAttribute]
private IOperation <OriginalOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<BasicBlock> <Blocks>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowRegion <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMethodSymbol> <LocalFunctions>k__BackingField;
    public IOperation OriginalOperation { get; }
    public ImmutableArray`1<BasicBlock> Blocks { get; }
    public ControlFlowRegion Root { get; }
    public ImmutableArray`1<IMethodSymbol> LocalFunctions { get; }
    internal ControlFlowGraph(IOperation originalOperation, CaptureIdDispenser captureIdDispenser, ImmutableArray`1<BasicBlock> blocks, ControlFlowRegion root, ImmutableArray`1<IMethodSymbol> localFunctions, ImmutableDictionary`2<IMethodSymbol, ValueTuple`3<ControlFlowRegion, ILocalFunctionOperation, int>> localFunctionsMap, ImmutableDictionary`2<IFlowAnonymousFunctionOperation, ValueTuple`2<ControlFlowRegion, int>> anonymousFunctionsMap);
    public static ControlFlowGraph Create(SyntaxNode node, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static ControlFlowGraph Create(IBlockOperation body, CancellationToken cancellationToken);
    public static ControlFlowGraph Create(IFieldInitializerOperation initializer, CancellationToken cancellationToken);
    public static ControlFlowGraph Create(IPropertyInitializerOperation initializer, CancellationToken cancellationToken);
    public static ControlFlowGraph Create(IParameterInitializerOperation initializer, CancellationToken cancellationToken);
    public static ControlFlowGraph Create(IConstructorBodyOperation constructorBody, CancellationToken cancellationToken);
    public static ControlFlowGraph Create(IMethodBodyOperation methodBody, CancellationToken cancellationToken);
    internal static ControlFlowGraph CreateCore(IOperation operation, string argumentNameForException, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public IOperation get_OriginalOperation();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<BasicBlock> get_Blocks();
    [CompilerGeneratedAttribute]
public ControlFlowRegion get_Root();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMethodSymbol> get_LocalFunctions();
    public ControlFlowGraph GetLocalFunctionControlFlowGraph(IMethodSymbol localFunction, CancellationToken cancellationToken);
    public ControlFlowGraph GetAnonymousFunctionControlFlowGraph(IFlowAnonymousFunctionOperation anonymousFunction, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphBuilder : OperationVisitor`2<Nullable`1<int>, IOperation> {
    private Compilation _compilation;
    private BasicBlockBuilder _entry;
    private BasicBlockBuilder _exit;
    private ArrayBuilder`1<BasicBlockBuilder> _blocks;
    private PooledDictionary`2<BasicBlockBuilder, RegionBuilder> _regionMap;
    private BasicBlockBuilder _currentBasicBlock;
    private RegionBuilder _currentRegion;
    private PooledDictionary`2<ILabelSymbol, BasicBlockBuilder> _labeledBlocks;
    private bool _haveAnonymousFunction;
    private IOperation _currentStatement;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ArrayBuilder`1<ValueTuple`2<EvalStackFrame, IOperation>> _evalStack;
    private int _startSpillingAt;
    private IOperation _currentConditionalAccessInstance;
    private IOperation _currentSwitchOperationExpression;
    private IOperation _forToLoopBinaryOperatorLeftOperand;
    private IOperation _forToLoopBinaryOperatorRightOperand;
    private IOperation _currentAggregationGroup;
    private bool _forceImplicit;
    private CaptureIdDispenser _captureIdDispenser;
    private ImplicitInstanceInfo _currentImplicitInstance;
    private BasicBlockBuilder CurrentBasicBlock { get; }
    private ControlFlowGraphBuilder(Compilation compilation, CaptureIdDispenser captureIdDispenser);
    private Context GetCurrentContext();
    private void SetCurrentContext(Context& context);
    private bool IsImplicit(IOperation operation);
    public static ControlFlowGraph Create(IOperation body, ControlFlowRegion enclosing, CaptureIdDispenser captureIdDispenser, Context& context);
    private static ImmutableArray`1<BasicBlock> ToImmutableBlocks(ArrayBuilder`1<BasicBlockBuilder> blockBuilders);
    private static void MarkReachableBlocks(ArrayBuilder`1<BasicBlockBuilder> blocks);
    private static BitVector MarkReachableBlocks(ArrayBuilder`1<BasicBlockBuilder> blocks, int firstBlockOrdinal, int lastBlockOrdinal, ArrayBuilder`1<BasicBlockBuilder> outOfRangeBlocksToVisit, PooledDictionary`2<ControlFlowRegion, bool> continueDispatchAfterFinally, PooledHashSet`1<ControlFlowRegion> dispatchedExceptionsFromRegions, Boolean& fellThrough);
    private static void Pack(ArrayBuilder`1<BasicBlockBuilder> blocks, RegionBuilder root, PooledDictionary`2<BasicBlockBuilder, RegionBuilder> regionMap);
    private static bool PackRegions(RegionBuilder root, ArrayBuilder`1<BasicBlockBuilder> blocks, PooledDictionary`2<BasicBlockBuilder, RegionBuilder> regionMap);
    private static void MergeSubRegionAndFree(RegionBuilder subRegion, ArrayBuilder`1<BasicBlockBuilder> blocks, PooledDictionary`2<BasicBlockBuilder, RegionBuilder> regionMap);
    private static bool PackBlocks(ArrayBuilder`1<BasicBlockBuilder> blocks, PooledDictionary`2<BasicBlockBuilder, RegionBuilder> regionMap);
    private static void CheckUnresolvedBranches(ArrayBuilder`1<BasicBlockBuilder> blocks, PooledDictionary`2<ILabelSymbol, BasicBlockBuilder> labeledBlocks);
    private void VisitStatement(IOperation operation);
    private BasicBlockBuilder get_CurrentBasicBlock();
    private void AddStatement(IOperation statement);
    private void AppendNewBlock(BasicBlockBuilder block, bool linkToPrevious);
    private void EnterRegion(RegionBuilder region, bool spillingStack);
    private void LeaveRegion();
    private static void LinkBlocks(BasicBlockBuilder prevBlock, BasicBlockBuilder nextBlock, ControlFlowBranchSemantics branchKind);
    public virtual IOperation VisitBlock(IBlockOperation operation, Nullable`1<int> captureIdForResult);
    private void StartVisitingStatement(IOperation operation);
    private IOperation FinishVisitingStatement(IOperation originalOperation, IOperation result);
    private void VisitStatements(ArrayBuilder`1<IOperation> statements);
    private void VisitStatements(ImmutableArray`1<IOperation> statements);
    private void VisitStatements(IEnumerable`1<IOperation> statements);
    internal virtual IOperation VisitWith(IWithOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitConstructorBodyOperation(IConstructorBodyOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitMethodBodyOperation(IMethodBodyOperation operation, Nullable`1<int> captureIdForResult);
    private void VisitMethodBodyBaseOperation(IMethodBodyBaseOperation operation);
    private void VisitMethodBodies(IBlockOperation blockBody, IBlockOperation expressionBody);
    public virtual IOperation VisitConditional(IConditionalOperation operation, Nullable`1<int> captureIdForResult);
    private void VisitAndCapture(IOperation operation, int captureId);
    private IOperation VisitAndCapture(IOperation operation);
    private void CaptureResultIfNotAlready(SyntaxNode syntax, int captureId, IOperation result);
    private EvalStackFrame PushStackFrame();
    private void PopStackFrame(EvalStackFrame frame, bool mergeNestedRegions);
    private void PopStackFrameAndLeaveRegion(EvalStackFrame frame);
    private void LeaveRegionIfAny(EvalStackFrame frame);
    private T PopStackFrame(EvalStackFrame frame, T value);
    private T PopStackFrameAndLeaveRegion(EvalStackFrame frame, T value);
    private void LeaveRegionsUpTo(RegionBuilder resultCaptureRegion);
    private int GetNextCaptureId(RegionBuilder owner);
    private void SpillEvalStack();
    private void PushOperand(IOperation operation);
    private IOperation PopOperand();
    private IOperation PeekOperand();
    private void VisitAndPushArray(ImmutableArray`1<T> array, Func`2<T, IOperation> unwrapper);
    private ImmutableArray`1<T> PopArray(ImmutableArray`1<T> originalArray, Func`4<IOperation, int, ImmutableArray`1<T>, T> wrapper);
    private ImmutableArray`1<T> VisitArray(ImmutableArray`1<T> originalArray, Func`2<T, IOperation> unwrapper, Func`4<IOperation, int, ImmutableArray`1<T>, T> wrapper);
    private ImmutableArray`1<IArgumentOperation> VisitArguments(ImmutableArray`1<IArgumentOperation> arguments);
    private static IOperation UnwrapArgument(IArgumentOperation argument);
    private IArgumentOperation RewriteArgumentFromArray(IOperation visitedArgument, int index, ImmutableArray`1<IArgumentOperation> args);
    public virtual IOperation VisitSimpleAssignment(ISimpleAssignmentOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitCompoundAssignment(ICompoundAssignmentOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitArrayElementReference(IArrayElementReferenceOperation operation, Nullable`1<int> captureIdForResult);
    private static bool IsConditional(IBinaryOperation operation);
    public virtual IOperation VisitBinaryOperator(IBinaryOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitTupleBinaryOperator(ITupleBinaryOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitUnaryOperator(IUnaryOperation operation, Nullable`1<int> captureIdForResult);
    private static bool IsBooleanLogicalNot(IUnaryOperation operation);
    private static bool CalculateAndOrSense(IBinaryOperation binOp, bool sense);
    private IOperation VisitBinaryConditionalOperator(IBinaryOperation binOp, bool sense, Nullable`1<int> captureIdForResult, BasicBlockBuilder fallToTrueOpt, BasicBlockBuilder fallToFalseOpt);
    private IOperation VisitNullableBinaryConditionalOperator(IBinaryOperation binOp, Nullable`1<int> captureIdForResult);
    private IOperation VisitObjectBinaryConditionalOperator(IBinaryOperation binOp, Nullable`1<int> captureIdForResult);
    private IOperation CreateConversion(IOperation operand, ITypeSymbol type);
    private IOperation VisitDynamicBinaryConditionalOperator(IBinaryOperation binOp, Nullable`1<int> captureIdForResult);
    private IOperation VisitUserDefinedBinaryConditionalOperator(IBinaryOperation binOp, Nullable`1<int> captureIdForResult);
    private IOperation VisitShortCircuitingOperator(IBinaryOperation condition, bool sense, bool stopSense, bool stopValue, Nullable`1<int> captureIdForResult, BasicBlockBuilder fallToTrueOpt, BasicBlockBuilder fallToFalseOpt);
    private IOperation VisitConditionalExpression(IOperation condition, bool sense, Nullable`1<int> captureIdForResult, BasicBlockBuilder fallToTrueOpt, BasicBlockBuilder fallToFalseOpt);
    private static bool IsBooleanConditionalOperator(IBinaryOperation binOp);
    private void VisitConditionalBranch(IOperation condition, BasicBlockBuilder& dest, bool sense);
    private void VisitConditionalBranchCore(IOperation condition, BasicBlockBuilder& dest, bool sense);
    private static void LinkBlocks(BasicBlockBuilder previous, IOperation condition, bool jumpIfTrue, Branch branch);
    private IOperation NullCheckAndConvertCoalesceValue(ICoalesceOperation operation, BasicBlockBuilder whenNull);
    public virtual IOperation VisitCoalesce(ICoalesceOperation operation, Nullable`1<int> captureIdForResult);
    private static Branch RegularBranch(BasicBlockBuilder destination);
    private static IOperation MakeInvalidOperation(ITypeSymbol type, IOperation child);
    private static IOperation MakeInvalidOperation(SyntaxNode syntax, ITypeSymbol type, IOperation child1, IOperation child2);
    private static IOperation MakeInvalidOperation(SyntaxNode syntax, ITypeSymbol type, ImmutableArray`1<IOperation> children);
    private IsNullOperation MakeIsNullOperation(IOperation operand);
    private static IsNullOperation MakeIsNullOperation(IOperation operand, ITypeSymbol booleanType);
    private IOperation TryUnwrapNullableValue(IOperation value);
    private IOperation UnwrapNullableValue(IOperation value);
    public virtual IOperation VisitConditionalAccess(IConditionalAccessOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitConditionalAccessInstance(IConditionalAccessInstanceOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitExpressionStatement(IExpressionStatementOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitWhileLoop(IWhileLoopOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitTry(ITryOperation operation, Nullable`1<int> captureIdForResult);
    private void AddExceptionStore(ITypeSymbol exceptionType, IOperation exceptionDeclarationOrExpression);
    public virtual IOperation VisitCatchClause(ICatchClauseOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitReturn(IReturnOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitLabeled(ILabeledOperation operation, Nullable`1<int> captureIdForResult);
    private BasicBlockBuilder GetLabeledOrNewBlock(ILabelSymbol labelOpt);
    public virtual IOperation VisitBranch(IBranchOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitEmpty(IEmptyOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitThrow(IThrowOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitUsing(IUsingOperation operation, Nullable`1<int> captureIdForResult);
    private void AddDisposingFinally(IOperation resource, bool knownToImplementIDisposable, ITypeSymbol iDisposable);
    private IOperation ConvertToIDisposable(IOperation operand, ITypeSymbol iDisposable, bool isTryCast);
    public virtual IOperation VisitLock(ILockOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitForEachLoop(IForEachLoopOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitForToLoop(IForToLoopOperation operation, Nullable`1<int> captureIdForResult);
    private static FlowCaptureReference GetCaptureReference(int id, IOperation underlying);
    internal virtual IOperation VisitAggregateQuery(IAggregateQueryOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitSwitch(ISwitchOperation operation, Nullable`1<int> captureIdForResult);
    private IOperation MakeNullable(IOperation operand, ITypeSymbol type);
    public virtual IOperation VisitSwitchCase(ISwitchCaseOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitSingleValueCaseClause(ISingleValueCaseClauseOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitDefaultCaseClause(IDefaultCaseClauseOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitRelationalCaseClause(IRelationalCaseClauseOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitRangeCaseClause(IRangeCaseClauseOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitPatternCaseClause(IPatternCaseClauseOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitEnd(IEndOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitForLoop(IForLoopOperation operation, Nullable`1<int> captureIdForResult);
    internal virtual IOperation VisitFixed(IFixedOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitVariableDeclarationGroup(IVariableDeclarationGroupOperation operation, Nullable`1<int> captureIdForResult);
    private void HandleVariableDeclarations(IVariableDeclarationGroupOperation operation);
    private void HandleVariableDeclaration(IVariableDeclarationOperation operation);
    private void HandleVariableDeclarator(IVariableDeclarationOperation declaration, IVariableDeclaratorOperation declarator);
    public virtual IOperation VisitVariableDeclaration(IVariableDeclarationOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitVariableDeclarator(IVariableDeclaratorOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitVariableInitializer(IVariableInitializerOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitFlowCapture(IFlowCaptureOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitFlowCaptureReference(IFlowCaptureReferenceOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitIsNull(IIsNullOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitCaughtException(ICaughtExceptionOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitInvocation(IInvocationOperation operation, Nullable`1<int> captureIdForResult);
    private ValueTuple`2<IOperation, ImmutableArray`1<IArgumentOperation>> VisitInstanceWithArguments(IOperation instance, ImmutableArray`1<IArgumentOperation> arguments);
    internal virtual IOperation VisitNoPiaObjectCreation(INoPiaObjectCreationOperation operation, Nullable`1<int> argument);
    public virtual IOperation VisitObjectCreation(IObjectCreationOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitTypeParameterObjectCreation(ITypeParameterObjectCreationOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitDynamicObjectCreation(IDynamicObjectCreationOperation operation, Nullable`1<int> captureIdForResult);
    private IOperation HandleObjectOrCollectionInitializer(IObjectOrCollectionInitializerOperation initializer, IOperation objectCreation);
    public virtual IOperation VisitObjectOrCollectionInitializer(IObjectOrCollectionInitializerOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitMemberInitializer(IMemberInitializerOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitAnonymousObjectCreation(IAnonymousObjectCreationOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitLocalFunction(ILocalFunctionOperation operation, Nullable`1<int> captureIdForResult);
    private IOperation VisitLocalFunctionAsRoot(ILocalFunctionOperation operation);
    public virtual IOperation VisitAnonymousFunction(IAnonymousFunctionOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitFlowAnonymousFunction(IFlowAnonymousFunctionOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitArrayCreation(IArrayCreationOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitArrayInitializer(IArrayInitializerOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitInstanceReference(IInstanceReferenceOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitDynamicInvocation(IDynamicInvocationOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitDynamicIndexerAccess(IDynamicIndexerAccessOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitDynamicMemberReference(IDynamicMemberReferenceOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitDeconstructionAssignment(IDeconstructionAssignmentOperation operation, Nullable`1<int> captureIdForResult);
    private void PushTargetAndUnwrapTupleIfNecessary(IOperation value);
    private IOperation PopTargetAndWrapTupleIfNecessary(IOperation value);
    public virtual IOperation VisitDeclarationExpression(IDeclarationExpressionOperation operation, Nullable`1<int> captureIdForResult);
    private IOperation VisitPreservingTupleOperations(IOperation operation);
    private ValueTuple`2<IOperation, IOperation> VisitPreservingTupleOperations(IOperation left, IOperation right);
    public virtual IOperation VisitTuple(ITupleOperation operation, Nullable`1<int> captureIdForResult);
    internal virtual IOperation VisitNoneOperation(IOperation operation, Nullable`1<int> captureIdForResult);
    private IOperation VisitNoneOperationStatement(IOperation operation);
    private IOperation VisitNoneOperationExpression(IOperation operation);
    public virtual IOperation VisitInterpolatedString(IInterpolatedStringOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitInterpolatedStringText(IInterpolatedStringTextOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitInterpolation(IInterpolationOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitNameOf(INameOfOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitLiteral(ILiteralOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitLocalReference(ILocalReferenceOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitParameterReference(IParameterReferenceOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitFieldReference(IFieldReferenceOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitMethodReference(IMethodReferenceOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitPropertyReference(IPropertyReferenceOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitEventReference(IEventReferenceOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitTypeOf(ITypeOfOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitParenthesized(IParenthesizedOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitAwait(IAwaitOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitSizeOf(ISizeOfOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitStop(IStopOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitIsType(IIsTypeOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitParameterInitializer(IParameterInitializerOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitFieldInitializer(IFieldInitializerOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitPropertyInitializer(IPropertyInitializerOperation operation, Nullable`1<int> captureIdForResult);
    private void VisitInitializer(IOperation rewrittenTarget, ISymbolInitializerOperation initializer);
    public virtual IOperation VisitEventAssignment(IEventAssignmentOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitRaiseEvent(IRaiseEventOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitAddressOf(IAddressOfOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitIncrementOrDecrement(IIncrementOrDecrementOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitDiscardOperation(IDiscardOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitOmittedArgument(IOmittedArgumentOperation operation, Nullable`1<int> captureIdForResult);
    internal virtual IOperation VisitPlaceholder(IPlaceholderOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitConversion(IConversionOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitDefaultValue(IDefaultValueOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitIsPattern(IIsPatternOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitInvalid(IInvalidOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitTranslatedQuery(ITranslatedQueryOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitConstantPattern(IConstantPatternOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitDeclarationPattern(IDeclarationPatternOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitDelegateCreation(IDelegateCreationOperation operation, Nullable`1<int> captureIdForResult);
    public IOperation Visit(IOperation operation);
    public virtual IOperation Visit(IOperation operation, Nullable`1<int> argument);
    public virtual IOperation DefaultVisit(IOperation operation, Nullable`1<int> captureIdForResult);
    public virtual IOperation VisitArgument(IArgumentOperation operation, Nullable`1<int> captureIdForResult);
    [CompilerGeneratedAttribute]
internal static ControlFlowBranch <ToImmutableBlocks>g__getFallThroughSuccessor|28_0(BasicBlockBuilder blockBuilder, <>c__DisplayClass28_0& );
    [CompilerGeneratedAttribute]
internal static ControlFlowBranch <ToImmutableBlocks>g__getConditionalSuccessor|28_1(BasicBlockBuilder blockBuilder, <>c__DisplayClass28_0& );
    [CompilerGeneratedAttribute]
internal static ControlFlowBranch <ToImmutableBlocks>g__getBranch|28_2(Branch& branch, BasicBlockBuilder source, bool isConditionalSuccessor, <>c__DisplayClass28_0& );
    [CompilerGeneratedAttribute]
internal static void <MarkReachableBlocks>g__followBranch|30_0(BasicBlockBuilder current, Branch& branch, <>c__DisplayClass30_0& );
    [CompilerGeneratedAttribute]
internal static bool <MarkReachableBlocks>g__stepThroughFinally|30_1(ControlFlowRegion region, BasicBlockBuilder destination, <>c__DisplayClass30_0& );
    [CompilerGeneratedAttribute]
internal static bool <MarkReachableBlocks>g__stepThroughSingleFinally|30_2(ControlFlowRegion finally, <>c__DisplayClass30_0& );
    [CompilerGeneratedAttribute]
internal static void <MarkReachableBlocks>g__dispatchException|30_3(ControlFlowRegion fromRegion, <>c__DisplayClass30_0& );
    [CompilerGeneratedAttribute]
internal static void <MarkReachableBlocks>g__dispatchExceptionThroughCatches|30_4(ControlFlowRegion tryAndCatch, int startAt, <>c__DisplayClass30_0& );
    [CompilerGeneratedAttribute]
internal static bool <PackRegions>g__PackRegion|32_0(RegionBuilder region, <>c__DisplayClass32_0& );
    [CompilerGeneratedAttribute]
internal static RegionBuilder <PackBlocks>g__tryGetImplicitEntryRegion|34_0(BasicBlockBuilder block, RegionBuilder currentRegion);
    [CompilerGeneratedAttribute]
internal static void <PackBlocks>g__removeBlock|34_1(BasicBlockBuilder block, RegionBuilder region, <>c__DisplayClass34_0& );
    [CompilerGeneratedAttribute]
internal static bool <PackBlocks>g__tryMergeBranch|34_2(BasicBlockBuilder predecessor, Branch& predecessorBranch, BasicBlockBuilder successor);
    [CompilerGeneratedAttribute]
internal static void <PackBlocks>g__mergeBranch|34_3(BasicBlockBuilder predecessor, Branch& predecessorBranch, Branch& successorBranch);
    [CompilerGeneratedAttribute]
internal static bool <PackBlocks>g__checkBranchesFromPredecessors|34_4(ArrayBuilder`1<BasicBlockBuilder> predecessors, RegionBuilder currentRegion, RegionBuilder destinationRegionOpt, <>c__DisplayClass34_0& );
    [CompilerGeneratedAttribute]
internal static void <PackBlocks>g__collectAncestorsAndSelf|34_5(RegionBuilder from, ArrayBuilder`1& builder);
    [CompilerGeneratedAttribute]
internal static int <PackBlocks>g__getIndexOfLastLeftRegion|34_6(ArrayBuilder`1<RegionBuilder> from, ArrayBuilder`1<RegionBuilder> to);
    [CompilerGeneratedAttribute]
internal static void <CheckUnresolvedBranches>g__fixupBranch|35_0(Branch& branch, <>c__DisplayClass35_0& );
    [CompilerGeneratedAttribute]
internal static IOperation <VisitNullableBinaryConditionalOperator>g__negateNullable|88_0(IOperation operand);
    [CompilerGeneratedAttribute]
private void <VisitUsing>g__processQueue|122_0(ArrayBuilder`1<ValueTuple`2<IVariableDeclarationOperation, IVariableDeclaratorOperation>> resourceQueueOpt, <>c__DisplayClass122_0& );
    [CompilerGeneratedAttribute]
internal static bool <VisitUsing>g__shouldConvertToIDisposableBeforeTry|122_1(IOperation resource);
    [CompilerGeneratedAttribute]
private void <VisitUsing>g__processResource|122_2(IOperation resource, ArrayBuilder`1<ValueTuple`2<IVariableDeclarationOperation, IVariableDeclaratorOperation>> resourceQueueOpt, <>c__DisplayClass122_0& );
    [CompilerGeneratedAttribute]
private IOperation <AddDisposingFinally>g__tryDispose|123_0(IOperation value);
    [CompilerGeneratedAttribute]
internal static bool <AddDisposingFinally>g__isNotNullableValueType|123_1(ITypeSymbol type);
    [CompilerGeneratedAttribute]
internal static IOperation <VisitForEachLoop>g__applyConversion|126_0(IConvertibleConversion conversionOpt, IOperation operand, ITypeSymbol targetType);
    [CompilerGeneratedAttribute]
private IOperation <VisitForEachLoop>g__getEnumerator|126_1(<>c__DisplayClass126_0& );
    [CompilerGeneratedAttribute]
private IOperation <VisitForEachLoop>g__getCondition|126_2(IOperation enumeratorRef, <>c__DisplayClass126_0& );
    [CompilerGeneratedAttribute]
private IOperation <VisitForEachLoop>g__getCurrent|126_3(IOperation enumeratorRef, <>c__DisplayClass126_0& );
    [CompilerGeneratedAttribute]
private IOperation <VisitForEachLoop>g__getLoopControlVariableAssignment|126_4(IOperation current, <>c__DisplayClass126_0& );
    [CompilerGeneratedAttribute]
private InvocationExpression <VisitForEachLoop>g__makeInvocationDroppingInstanceForStaticMethods|126_5(IMethodSymbol method, IOperation instance, Lazy`1<ImmutableArray`1<IArgumentOperation>> arguments, <>c__DisplayClass126_0& );
    [CompilerGeneratedAttribute]
private InvocationExpression <VisitForEachLoop>g__makeInvocation|126_6(SyntaxNode syntax, IMethodSymbol method, IOperation instanceOpt, Lazy`1<ImmutableArray`1<IArgumentOperation>> arguments, <>c__DisplayClass126_0& );
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IArgumentOperation> <VisitForEachLoop>g__makeArguments|126_7(Lazy`1<ImmutableArray`1<IArgumentOperation>> arguments, <>c__DisplayClass126_0& );
    [CompilerGeneratedAttribute]
private IOperation <VisitForToLoop>g__tryCallObjectForLoopControlHelper|127_0(SyntaxNode syntax, WellKnownMember helper, <>c__DisplayClass127_0& );
    [CompilerGeneratedAttribute]
private void <VisitForToLoop>g__initializeLoop|127_1(<>c__DisplayClass127_0& );
    [CompilerGeneratedAttribute]
private void <VisitForToLoop>g__checkLoopCondition|127_2(<>c__DisplayClass127_0& );
    [CompilerGeneratedAttribute]
private IOperation <VisitForToLoop>g__negateIfStepNegative|127_3(IOperation operand, <>c__DisplayClass127_0& );
    [CompilerGeneratedAttribute]
private void <VisitForToLoop>g__incrementLoopControlVariable|127_4(<>c__DisplayClass127_0& );
    [CompilerGeneratedAttribute]
private IOperation <VisitForToLoop>g__visitLoopControlVariableReference|127_5(bool forceImplicit, <>c__DisplayClass127_0& );
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ILocalSymbol> <VisitSwitch>g__getLocals|130_0(<>c__DisplayClass130_0& );
    [CompilerGeneratedAttribute]
private void <VisitSwitch>g__handleSection|130_1(ISwitchCaseOperation section, <>c__DisplayClass130_0& );
    [CompilerGeneratedAttribute]
private void <VisitSwitch>g__handleCase|130_2(ICaseClauseOperation caseClause, BasicBlockBuilder body, BasicBlockBuilder nextCase, <>c__DisplayClass130_0& );
    [CompilerGeneratedAttribute]
private void <VisitSwitch>g__handleEqualityCheck|130_3(IOperation compareWith, <>c__DisplayClass130_0& , <>c__DisplayClass130_1& );
    [CompilerGeneratedAttribute]
private void <HandleObjectOrCollectionInitializer>g__visitInitializer|158_0(IObjectOrCollectionInitializerOperation initializerOperation, IOperation initializedInstance);
    [CompilerGeneratedAttribute]
private void <HandleObjectOrCollectionInitializer>g__handleInitializer|158_1(IOperation innerInitializer);
    [CompilerGeneratedAttribute]
private void <HandleObjectOrCollectionInitializer>g__handleSimpleAssignment|158_2(ISimpleAssignmentOperation assignmentOperation);
    [CompilerGeneratedAttribute]
private void <HandleObjectOrCollectionInitializer>g__handleMemberInitializer|158_3(IMemberInitializerOperation memberInitializer);
    [CompilerGeneratedAttribute]
private bool <HandleObjectOrCollectionInitializer>g__tryPushTarget|158_4(IOperation instance);
    [CompilerGeneratedAttribute]
private IOperation <HandleObjectOrCollectionInitializer>g__popTarget|158_5(IOperation originalTarget);
    [CompilerGeneratedAttribute]
private IOperation <VisitAnonymousObjectCreation>g__visitAndCaptureInitializer|161_0(IPropertySymbol initializedProperty, IOperation initializer);
    [CompilerGeneratedAttribute]
private void <VisitArrayInitializer>g__visitAndPushArrayInitializerValues|167_0(IArrayInitializerOperation initializer);
    [CompilerGeneratedAttribute]
private IArrayInitializerOperation <VisitArrayInitializer>g__popAndAssembleArrayInitializerValues|167_1(IArrayInitializerOperation initializer);
    [CompilerGeneratedAttribute]
internal static IEventReferenceOperation <VisitEventAssignment>g__getEventReference|203_0(<>c__DisplayClass203_0& );
    [CompilerGeneratedAttribute]
private IOperation <VisitInvalid>g__visitInvalidOperationStatement|213_0(IInvalidOperation invalidOperation, <>c__DisplayClass213_0& );
    [CompilerGeneratedAttribute]
private IOperation <VisitInvalid>g__visitInvalidOperationExpression|213_1(IInvalidOperation invalidOperation, <>c__DisplayClass213_0& );
}
public class Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegion : object {
    [CompilerGeneratedAttribute]
private ControlFlowRegionKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ControlFlowRegion <EnclosingRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <ExceptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FirstBlockOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LastBlockOrdinal>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ControlFlowRegion> <NestedRegions>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ILocalSymbol> <Locals>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMethodSymbol> <LocalFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<CaptureId> <CaptureIds>k__BackingField;
    public ControlFlowRegionKind Kind { get; }
    public ControlFlowRegion EnclosingRegion { get; private set; }
    public ITypeSymbol ExceptionType { get; }
    public int FirstBlockOrdinal { get; }
    public int LastBlockOrdinal { get; }
    public ImmutableArray`1<ControlFlowRegion> NestedRegions { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ImmutableArray`1<IMethodSymbol> LocalFunctions { get; }
    public ImmutableArray`1<CaptureId> CaptureIds { get; }
    internal ControlFlowRegion(ControlFlowRegionKind kind, int firstBlockOrdinal, int lastBlockOrdinal, ImmutableArray`1<ControlFlowRegion> nestedRegions, ImmutableArray`1<ILocalSymbol> locals, ImmutableArray`1<IMethodSymbol> methods, ImmutableArray`1<CaptureId> captureIds, ITypeSymbol exceptionType, ControlFlowRegion enclosingRegion);
    [CompilerGeneratedAttribute]
public ControlFlowRegionKind get_Kind();
    [CompilerGeneratedAttribute]
public ControlFlowRegion get_EnclosingRegion();
    [CompilerGeneratedAttribute]
private void set_EnclosingRegion(ControlFlowRegion value);
    [CompilerGeneratedAttribute]
public ITypeSymbol get_ExceptionType();
    [CompilerGeneratedAttribute]
public int get_FirstBlockOrdinal();
    [CompilerGeneratedAttribute]
public int get_LastBlockOrdinal();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ControlFlowRegion> get_NestedRegions();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ILocalSymbol> get_Locals();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<IMethodSymbol> get_LocalFunctions();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<CaptureId> get_CaptureIds();
    internal bool ContainsBlock(int destinationOrdinal);
}
public enum Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionKind : Enum {
    public int value__;
    public static ControlFlowRegionKind Root;
    public static ControlFlowRegionKind LocalLifetime;
    public static ControlFlowRegionKind Try;
    public static ControlFlowRegionKind Filter;
    public static ControlFlowRegionKind Catch;
    public static ControlFlowRegionKind FilterAndHandler;
    public static ControlFlowRegionKind TryAndCatch;
    public static ControlFlowRegionKind Finally;
    public static ControlFlowRegionKind TryAndFinally;
    public static ControlFlowRegionKind StaticLocalInitializer;
    public static ControlFlowRegionKind ErroneousBody;
}
public interface Microsoft.CodeAnalysis.FlowAnalysis.ICaughtExceptionOperation {
}
public interface Microsoft.CodeAnalysis.FlowAnalysis.IFlowAnonymousFunctionOperation {
    public IMethodSymbol Symbol { get; }
    public abstract virtual IMethodSymbol get_Symbol();
}
public interface Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureOperation {
    public CaptureId Id { get; }
    public IOperation Value { get; }
    public abstract virtual CaptureId get_Id();
    public abstract virtual IOperation get_Value();
}
public interface Microsoft.CodeAnalysis.FlowAnalysis.IFlowCaptureReferenceOperation {
    public CaptureId Id { get; }
    public abstract virtual CaptureId get_Id();
}
public interface Microsoft.CodeAnalysis.FlowAnalysis.IIsNullOperation {
    public IOperation Operand { get; }
    public abstract virtual IOperation get_Operand();
}
public interface Microsoft.CodeAnalysis.FlowAnalysis.IStaticLocalInitializationSemaphoreOperation {
    public ILocalSymbol Local { get; }
    public abstract virtual ILocalSymbol get_Local();
}
internal class Microsoft.CodeAnalysis.FormattedSymbol : object {
    private ISymbol _symbol;
    private SymbolDisplayFormat _symbolDisplayFormat;
    internal FormattedSymbol(ISymbol symbol, SymbolDisplayFormat symbolDisplayFormat);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
}
internal class Microsoft.CodeAnalysis.FormattedSymbolList : object {
    private IEnumerable`1<ISymbol> _symbols;
    private SymbolDisplayFormat _symbolDisplayFormat;
    internal FormattedSymbolList(IEnumerable`1<ISymbol> symbols, SymbolDisplayFormat symbolDisplayFormat);
    public virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal abstract class Microsoft.CodeAnalysis.GreenNode : object {
    internal static int ListKind;
    private ushort _kind;
    protected NodeFlags flags;
    private byte _slotCount;
    private int _fullWidth;
    private static ConditionalWeakTable`2<GreenNode, DiagnosticInfo[]> s_diagnosticsTable;
    private static ConditionalWeakTable`2<GreenNode, SyntaxAnnotation[]> s_annotationsTable;
    private static DiagnosticInfo[] s_noDiagnostics;
    private static SyntaxAnnotation[] s_noAnnotations;
    private static IEnumerable`1<SyntaxAnnotation> s_noAnnotationsEnumerable;
    private static ushort ExtendedSerializationInfoMask;
    internal static int MaxCachedChildNum;
    public string Language { get; }
    public int RawKind { get; }
    public bool IsList { get; }
    public string KindText { get; }
    public bool IsStructuredTrivia { get; }
    public bool IsDirective { get; }
    public bool IsToken { get; }
    public bool IsTrivia { get; }
    public bool IsSkippedTokensTrivia { get; }
    public bool IsDocumentationCommentTrivia { get; }
    public int SlotCount { get; protected set; }
    internal NodeFlags Flags { get; }
    internal bool IsMissing { get; }
    internal bool ParsedInAsync { get; }
    internal bool ParsedInQuery { get; }
    internal bool ParsedInIterator { get; }
    public bool ContainsSkippedText { get; }
    public bool ContainsStructuredTrivia { get; }
    public bool ContainsDirectives { get; }
    public bool ContainsDiagnostics { get; }
    public bool ContainsAnnotations { get; }
    public int FullWidth { get; protected set; }
    public int Width { get; }
    public bool HasLeadingTrivia { get; }
    public bool HasTrailingTrivia { get; }
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    internal bool ShouldReuseInSerialization { get; }
    public int RawContextualKind { get; }
    internal bool IsCacheable { get; }
    protected GreenNode(ushort kind);
    protected GreenNode(ushort kind, int fullWidth);
    protected GreenNode(ushort kind, DiagnosticInfo[] diagnostics, int fullWidth);
    protected GreenNode(ushort kind, DiagnosticInfo[] diagnostics);
    protected GreenNode(ushort kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    protected GreenNode(ushort kind, DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations, int fullWidth);
    internal GreenNode(ObjectReader reader);
    private static GreenNode();
    private string GetDebuggerDisplay();
    protected void AdjustFlagsAndWidth(GreenNode node);
    public abstract virtual string get_Language();
    public int get_RawKind();
    public bool get_IsList();
    public abstract virtual string get_KindText();
    public virtual bool get_IsStructuredTrivia();
    public virtual bool get_IsDirective();
    public virtual bool get_IsToken();
    public virtual bool get_IsTrivia();
    public virtual bool get_IsSkippedTokensTrivia();
    public virtual bool get_IsDocumentationCommentTrivia();
    public int get_SlotCount();
    protected void set_SlotCount(int value);
    internal abstract virtual GreenNode GetSlot(int index);
    protected virtual int GetSlotCount();
    public virtual int GetSlotOffset(int index);
    internal ChildSyntaxList ChildNodesAndTokens();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.GreenNode/<EnumerateNodes>d__45")]
internal IEnumerable`1<GreenNode> EnumerateNodes();
    public virtual int FindSlotIndexContainingOffset(int offset);
    internal NodeFlags get_Flags();
    internal void SetFlags(NodeFlags flags);
    internal void ClearFlags(NodeFlags flags);
    internal bool get_IsMissing();
    internal bool get_ParsedInAsync();
    internal bool get_ParsedInQuery();
    internal bool get_ParsedInIterator();
    public bool get_ContainsSkippedText();
    public bool get_ContainsStructuredTrivia();
    public bool get_ContainsDirectives();
    public bool get_ContainsDiagnostics();
    public bool get_ContainsAnnotations();
    public int get_FullWidth();
    protected void set_FullWidth(int value);
    public virtual int get_Width();
    public virtual int GetLeadingTriviaWidth();
    public virtual int GetTrailingTriviaWidth();
    public bool get_HasLeadingTrivia();
    public bool get_HasTrailingTrivia();
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    internal virtual bool get_ShouldReuseInSerialization();
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    internal virtual void WriteTo(ObjectWriter writer);
    public bool HasAnnotations(string annotationKind);
    public bool HasAnnotations(IEnumerable`1<string> annotationKinds);
    public bool HasAnnotation(SyntaxAnnotation annotation);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(string annotationKind);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.GreenNode/<GetAnnotationsSlow>d__93")]
private static IEnumerable`1<SyntaxAnnotation> GetAnnotationsSlow(SyntaxAnnotation[] annotations, string annotationKind);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(IEnumerable`1<string> annotationKinds);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.GreenNode/<GetAnnotationsSlow>d__95")]
private static IEnumerable`1<SyntaxAnnotation> GetAnnotationsSlow(SyntaxAnnotation[] annotations, IEnumerable`1<string> annotationKinds);
    public SyntaxAnnotation[] GetAnnotations();
    internal abstract virtual GreenNode SetAnnotations(SyntaxAnnotation[] annotations);
    internal DiagnosticInfo[] GetDiagnostics();
    internal abstract virtual GreenNode SetDiagnostics(DiagnosticInfo[] diagnostics);
    public virtual string ToFullString();
    public virtual string ToString();
    public void WriteTo(TextWriter writer);
    protected internal void WriteTo(TextWriter writer, bool leading, bool trailing);
    private static void ProcessStack(TextWriter writer, Stack`1<ValueTuple`3<GreenNode, bool, bool>> stack);
    private static int GetFirstNonNullChildIndex(GreenNode node);
    private static int GetLastNonNullChildIndex(GreenNode node);
    protected virtual void WriteTriviaTo(TextWriter writer);
    protected virtual void WriteTokenTo(TextWriter writer, bool leading, bool trailing);
    public virtual int get_RawContextualKind();
    public virtual object GetValue();
    public virtual string GetValueText();
    public virtual GreenNode GetLeadingTriviaCore();
    public virtual GreenNode GetTrailingTriviaCore();
    public virtual GreenNode WithLeadingTrivia(GreenNode trivia);
    public virtual GreenNode WithTrailingTrivia(GreenNode trivia);
    internal GreenNode GetFirstTerminal();
    internal GreenNode GetLastTerminal();
    internal GreenNode GetLastNonmissingTerminal();
    public virtual bool IsEquivalentTo(GreenNode other);
    private static bool EquivalentToInternal(GreenNode node1, GreenNode node2);
    public abstract virtual SyntaxNode GetStructure(SyntaxTrivia parentTrivia);
    public abstract virtual SyntaxToken CreateSeparator(SyntaxNode element);
    public abstract virtual bool IsTriviaWithEndOfLine();
    public virtual GreenNode CreateList(IEnumerable`1<GreenNode> nodes, bool alwaysCreateListNode);
    public SyntaxNode CreateRed();
    internal abstract virtual SyntaxNode CreateRed(SyntaxNode parent, int position);
    internal bool get_IsCacheable();
    internal int GetCacheHash();
    internal bool IsCacheEquivalent(int kind, NodeFlags flags, GreenNode child1);
    internal bool IsCacheEquivalent(int kind, NodeFlags flags, GreenNode child1, GreenNode child2);
    internal bool IsCacheEquivalent(int kind, NodeFlags flags, GreenNode child1, GreenNode child2, GreenNode child3);
    internal GreenNode AddError(DiagnosticInfo err);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.GreenNodeExtensions : object {
    [ExtensionAttribute]
public static TNode WithAnnotationsGreen(TNode node, IEnumerable`1<SyntaxAnnotation> annotations);
    [ExtensionAttribute]
public static TNode WithAdditionalAnnotationsGreen(TNode node, IEnumerable`1<SyntaxAnnotation> annotations);
    [ExtensionAttribute]
public static TNode WithoutAnnotationsGreen(TNode node, IEnumerable`1<SyntaxAnnotation> annotations);
    [ExtensionAttribute]
public static TNode WithDiagnosticsGreen(TNode node, DiagnosticInfo[] diagnostics);
    [ExtensionAttribute]
public static TNode WithoutDiagnosticsGreen(TNode node);
}
internal class Microsoft.CodeAnalysis.Grouping`2 : object {
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    private IEnumerable`1<TElement> _elements;
    public TKey Key { get; }
    public Grouping`2(TKey key, IEnumerable`1<TElement> elements);
    public Grouping`2(KeyValuePair`2<TKey, IEnumerable`1<TElement>> pair);
    [CompilerGeneratedAttribute]
public sealed virtual TKey get_Key();
    public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.HashSetExtensions : object {
    [ExtensionAttribute]
internal static bool IsNullOrEmpty(HashSet`1<T> hashSet);
    internal static bool InitializeAndAdd(HashSet`1& hashSet, T item);
}
public interface Microsoft.CodeAnalysis.IAliasSymbol {
    public INamespaceOrTypeSymbol Target { get; }
    public abstract virtual INamespaceOrTypeSymbol get_Target();
}
public interface Microsoft.CodeAnalysis.IAnalyzerAssemblyLoader {
    public abstract virtual Assembly LoadFromPath(string fullPath);
    public abstract virtual void AddDependencyLocation(string fullPath);
}
public interface Microsoft.CodeAnalysis.IArrayTypeSymbol {
    public int Rank { get; }
    public bool IsSZArray { get; }
    public ImmutableArray`1<int> LowerBounds { get; }
    public ImmutableArray`1<int> Sizes { get; }
    public ITypeSymbol ElementType { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public abstract virtual int get_Rank();
    public abstract virtual bool get_IsSZArray();
    public abstract virtual ImmutableArray`1<int> get_LowerBounds();
    public abstract virtual ImmutableArray`1<int> get_Sizes();
    public abstract virtual ITypeSymbol get_ElementType();
    public abstract virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public abstract virtual bool Equals(IArrayTypeSymbol other);
}
public interface Microsoft.CodeAnalysis.IAssemblySymbol {
    public bool IsInteractive { get; }
    public AssemblyIdentity Identity { get; }
    public INamespaceSymbol GlobalNamespace { get; }
    public IEnumerable`1<IModuleSymbol> Modules { get; }
    public ICollection`1<string> TypeNames { get; }
    public ICollection`1<string> NamespaceNames { get; }
    public bool MightContainExtensionMethods { get; }
    public abstract virtual bool get_IsInteractive();
    public abstract virtual AssemblyIdentity get_Identity();
    public abstract virtual INamespaceSymbol get_GlobalNamespace();
    public abstract virtual IEnumerable`1<IModuleSymbol> get_Modules();
    public abstract virtual ICollection`1<string> get_TypeNames();
    public abstract virtual ICollection`1<string> get_NamespaceNames();
    public abstract virtual bool GivesAccessTo(IAssemblySymbol toAssembly);
    public abstract virtual INamedTypeSymbol GetTypeByMetadataName(string fullyQualifiedMetadataName);
    public abstract virtual bool get_MightContainExtensionMethods();
    public abstract virtual INamedTypeSymbol ResolveForwardedType(string fullyQualifiedMetadataName);
    public abstract virtual AssemblyMetadata GetMetadata();
}
internal interface Microsoft.CodeAnalysis.IAssemblySymbolInternal {
    public Version AssemblyVersionPattern { get; }
    public abstract virtual Version get_AssemblyVersionPattern();
}
public interface Microsoft.CodeAnalysis.ICompilationUnitSyntax {
    public SyntaxToken EndOfFileToken { get; }
    public abstract virtual SyntaxToken get_EndOfFileToken();
}
internal class Microsoft.CodeAnalysis.IdentifierCollection : object {
    private Dictionary`2<string, object> _map;
    public IdentifierCollection(IEnumerable`1<string> identifiers);
    public void AddIdentifiers(IEnumerable`1<string> identifiers);
    public void AddIdentifier(string identifier);
    private void AddAdditionalSpelling(string identifier, object value);
    private void AddInitialSpelling(string identifier);
    public bool ContainsIdentifier(string identifier, bool caseSensitive);
    private bool CaseInsensitiveContains(string identifier);
    private bool CaseSensitiveContains(string identifier);
    public ICollection`1<string> AsCaseSensitiveCollection();
    public ICollection`1<string> AsCaseInsensitiveCollection();
}
public interface Microsoft.CodeAnalysis.IDiscardSymbol {
    public ITypeSymbol Type { get; }
    public abstract virtual ITypeSymbol get_Type();
}
public interface Microsoft.CodeAnalysis.IDynamicTypeSymbol {
}
public interface Microsoft.CodeAnalysis.IErrorTypeSymbol {
    public ImmutableArray`1<ISymbol> CandidateSymbols { get; }
    public CandidateReason CandidateReason { get; }
    public abstract virtual ImmutableArray`1<ISymbol> get_CandidateSymbols();
    public abstract virtual CandidateReason get_CandidateReason();
}
public interface Microsoft.CodeAnalysis.IEventSymbol {
    public ITypeSymbol Type { get; }
    public bool IsWindowsRuntimeEvent { get; }
    public IMethodSymbol AddMethod { get; }
    public IMethodSymbol RemoveMethod { get; }
    public IMethodSymbol RaiseMethod { get; }
    public IEventSymbol OriginalDefinition { get; }
    public IEventSymbol OverriddenEvent { get; }
    public ImmutableArray`1<IEventSymbol> ExplicitInterfaceImplementations { get; }
    public abstract virtual ITypeSymbol get_Type();
    public abstract virtual bool get_IsWindowsRuntimeEvent();
    public abstract virtual IMethodSymbol get_AddMethod();
    public abstract virtual IMethodSymbol get_RemoveMethod();
    public abstract virtual IMethodSymbol get_RaiseMethod();
    public abstract virtual IEventSymbol get_OriginalDefinition();
    public abstract virtual IEventSymbol get_OverriddenEvent();
    public abstract virtual ImmutableArray`1<IEventSymbol> get_ExplicitInterfaceImplementations();
}
public interface Microsoft.CodeAnalysis.IFieldSymbol {
    public ISymbol AssociatedSymbol { get; }
    public bool IsConst { get; }
    public bool IsReadOnly { get; }
    public bool IsVolatile { get; }
    public ITypeSymbol Type { get; }
    public bool HasConstantValue { get; }
    public object ConstantValue { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public IFieldSymbol OriginalDefinition { get; }
    public IFieldSymbol CorrespondingTupleField { get; }
    public abstract virtual ISymbol get_AssociatedSymbol();
    public abstract virtual bool get_IsConst();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsVolatile();
    public abstract virtual ITypeSymbol get_Type();
    public abstract virtual bool get_HasConstantValue();
    public abstract virtual object get_ConstantValue();
    public abstract virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public abstract virtual IFieldSymbol get_OriginalDefinition();
    public abstract virtual IFieldSymbol get_CorrespondingTupleField();
}
public interface Microsoft.CodeAnalysis.ILabelSymbol {
    public IMethodSymbol ContainingMethod { get; }
    public abstract virtual IMethodSymbol get_ContainingMethod();
}
public interface Microsoft.CodeAnalysis.ILocalSymbol {
    public ITypeSymbol Type { get; }
    public bool IsConst { get; }
    public bool IsRef { get; }
    public RefKind RefKind { get; }
    public bool HasConstantValue { get; }
    public object ConstantValue { get; }
    public bool IsFunctionValue { get; }
    public bool IsFixed { get; }
    public abstract virtual ITypeSymbol get_Type();
    public abstract virtual bool get_IsConst();
    public abstract virtual bool get_IsRef();
    public abstract virtual RefKind get_RefKind();
    public abstract virtual bool get_HasConstantValue();
    public abstract virtual object get_ConstantValue();
    public abstract virtual bool get_IsFunctionValue();
    public abstract virtual bool get_IsFixed();
}
internal interface Microsoft.CodeAnalysis.ILocalSymbolInternal {
    public bool IsImportedFromMetadata { get; }
    public SynthesizedLocalKind SynthesizedKind { get; }
    public abstract virtual bool get_IsImportedFromMetadata();
    public abstract virtual SynthesizedLocalKind get_SynthesizedKind();
    public abstract virtual SyntaxNode GetDeclaratorSyntax();
}
internal interface Microsoft.CodeAnalysis.IMarshalAsAttributeTarget {
    public abstract virtual MarshalPseudoCustomAttributeData GetOrCreateData();
}
public interface Microsoft.CodeAnalysis.IMethodSymbol {
    public MethodKind MethodKind { get; }
    public int Arity { get; }
    public bool IsGenericMethod { get; }
    public bool IsExtensionMethod { get; }
    public bool IsAsync { get; }
    public bool IsVararg { get; }
    public bool IsCheckedBuiltin { get; }
    public bool HidesBaseMethodsByName { get; }
    public bool ReturnsVoid { get; }
    public bool ReturnsByRef { get; }
    public bool ReturnsByRefReadonly { get; }
    public RefKind RefKind { get; }
    public ITypeSymbol ReturnType { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public IMethodSymbol ConstructedFrom { get; }
    public IMethodSymbol OriginalDefinition { get; }
    public IMethodSymbol OverriddenMethod { get; }
    public ITypeSymbol ReceiverType { get; }
    public IMethodSymbol ReducedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> ExplicitInterfaceImplementations { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ImmutableArray`1<CustomModifier> RefCustomModifiers { get; }
    public ISymbol AssociatedSymbol { get; }
    public IMethodSymbol PartialDefinitionPart { get; }
    public IMethodSymbol PartialImplementationPart { get; }
    public INamedTypeSymbol AssociatedAnonymousDelegate { get; }
    public abstract virtual MethodKind get_MethodKind();
    public abstract virtual int get_Arity();
    public abstract virtual bool get_IsGenericMethod();
    public abstract virtual bool get_IsExtensionMethod();
    public abstract virtual bool get_IsAsync();
    public abstract virtual bool get_IsVararg();
    public abstract virtual bool get_IsCheckedBuiltin();
    public abstract virtual bool get_HidesBaseMethodsByName();
    public abstract virtual bool get_ReturnsVoid();
    public abstract virtual bool get_ReturnsByRef();
    public abstract virtual bool get_ReturnsByRefReadonly();
    public abstract virtual RefKind get_RefKind();
    public abstract virtual ITypeSymbol get_ReturnType();
    public abstract virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public abstract virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public abstract virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    public abstract virtual IMethodSymbol get_ConstructedFrom();
    public abstract virtual IMethodSymbol get_OriginalDefinition();
    public abstract virtual IMethodSymbol get_OverriddenMethod();
    public abstract virtual ITypeSymbol get_ReceiverType();
    public abstract virtual IMethodSymbol get_ReducedFrom();
    public abstract virtual ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    public abstract virtual IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType);
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_ExplicitInterfaceImplementations();
    public abstract virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public abstract virtual ImmutableArray`1<CustomModifier> get_RefCustomModifiers();
    public abstract virtual ImmutableArray`1<AttributeData> GetReturnTypeAttributes();
    public abstract virtual ISymbol get_AssociatedSymbol();
    public abstract virtual IMethodSymbol Construct(ITypeSymbol[] typeArguments);
    public abstract virtual IMethodSymbol get_PartialDefinitionPart();
    public abstract virtual IMethodSymbol get_PartialImplementationPart();
    public abstract virtual DllImportData GetDllImportData();
    public abstract virtual INamedTypeSymbol get_AssociatedAnonymousDelegate();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutable(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrEmpty(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrNull(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutable(T[] items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrNull(T[] items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrEmpty(T[] items);
    [ExtensionAttribute]
public static ImmutableArray`1<byte> ToImmutable(MemoryStream stream);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`2<TItem, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`3<TItem, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`4<TItem, int, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> ZipAsArray(ImmutableArray`1<T1> self, ImmutableArray`1<T2> other, Func`3<T1, T2, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<T> WhereAsArray(ImmutableArray`1<T> array, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static ImmutableArray`1<TBase> Cast(ImmutableArray`1<TDerived> items);
    [ExtensionAttribute]
public static bool SetEquals(ImmutableArray`1<T> array1, ImmutableArray`1<T> array2, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static ImmutableArray`1<T> NullToEmpty(ImmutableArray`1<T> array);
    [ExtensionAttribute]
public static ImmutableArray`1<T> Distinct(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool HasAnyErrors(ImmutableArray`1<T> diagnostics);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> DeOrder(ImmutableArray`1<T> array);
    [ExtensionAttribute]
internal static ImmutableArray`1<TValue> Flatten(Dictionary`2<TKey, ImmutableArray`1<TValue>> dictionary, IComparer`1<TValue> comparer);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, T second);
    [ExtensionAttribute]
internal static bool HasDuplicates(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int Count(ImmutableArray`1<T> items, Func`2<T, bool> predicate);
    [ExtensionAttribute]
internal static Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(ImmutableArray`1<T> items, Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
}
public interface Microsoft.CodeAnalysis.IModuleSymbol {
    public INamespaceSymbol GlobalNamespace { get; }
    public ImmutableArray`1<AssemblyIdentity> ReferencedAssemblies { get; }
    public ImmutableArray`1<IAssemblySymbol> ReferencedAssemblySymbols { get; }
    public abstract virtual INamespaceSymbol get_GlobalNamespace();
    public abstract virtual INamespaceSymbol GetModuleNamespace(INamespaceSymbol namespaceSymbol);
    public abstract virtual ImmutableArray`1<AssemblyIdentity> get_ReferencedAssemblies();
    public abstract virtual ImmutableArray`1<IAssemblySymbol> get_ReferencedAssemblySymbols();
    public abstract virtual ModuleMetadata GetMetadata();
}
public interface Microsoft.CodeAnalysis.INamedTypeSymbol {
    public int Arity { get; }
    public bool IsGenericType { get; }
    public bool IsUnboundGenericType { get; }
    public bool IsScriptClass { get; }
    public bool IsImplicitClass { get; }
    public bool IsComImport { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public INamedTypeSymbol OriginalDefinition { get; }
    public IMethodSymbol DelegateInvokeMethod { get; }
    public INamedTypeSymbol EnumUnderlyingType { get; }
    public INamedTypeSymbol ConstructedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> InstanceConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> StaticConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> Constructors { get; }
    public ISymbol AssociatedSymbol { get; }
    public bool MightContainExtensionMethods { get; }
    public INamedTypeSymbol TupleUnderlyingType { get; }
    public ImmutableArray`1<IFieldSymbol> TupleElements { get; }
    public bool IsSerializable { get; }
    public abstract virtual int get_Arity();
    public abstract virtual bool get_IsGenericType();
    public abstract virtual bool get_IsUnboundGenericType();
    public abstract virtual bool get_IsScriptClass();
    public abstract virtual bool get_IsImplicitClass();
    public abstract virtual bool get_IsComImport();
    public abstract virtual IEnumerable`1<string> get_MemberNames();
    public abstract virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public abstract virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public abstract virtual ImmutableArray`1<CustomModifier> GetTypeArgumentCustomModifiers(int ordinal);
    public abstract virtual INamedTypeSymbol get_OriginalDefinition();
    public abstract virtual IMethodSymbol get_DelegateInvokeMethod();
    public abstract virtual INamedTypeSymbol get_EnumUnderlyingType();
    public abstract virtual INamedTypeSymbol get_ConstructedFrom();
    public abstract virtual INamedTypeSymbol Construct(ITypeSymbol[] typeArguments);
    public abstract virtual INamedTypeSymbol ConstructUnboundGenericType();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_InstanceConstructors();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_StaticConstructors();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_Constructors();
    public abstract virtual ISymbol get_AssociatedSymbol();
    public abstract virtual bool get_MightContainExtensionMethods();
    public abstract virtual INamedTypeSymbol get_TupleUnderlyingType();
    public abstract virtual ImmutableArray`1<IFieldSymbol> get_TupleElements();
    public abstract virtual bool get_IsSerializable();
}
public interface Microsoft.CodeAnalysis.INamespaceOrTypeSymbol {
    public bool IsNamespace { get; }
    public bool IsType { get; }
    public abstract virtual ImmutableArray`1<ISymbol> GetMembers();
    public abstract virtual ImmutableArray`1<ISymbol> GetMembers(string name);
    public abstract virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers();
    public abstract virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers(string name);
    public abstract virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers(string name, int arity);
    public abstract virtual bool get_IsNamespace();
    public abstract virtual bool get_IsType();
}
public interface Microsoft.CodeAnalysis.INamespaceSymbol {
    public bool IsGlobalNamespace { get; }
    public NamespaceKind NamespaceKind { get; }
    public Compilation ContainingCompilation { get; }
    public ImmutableArray`1<INamespaceSymbol> ConstituentNamespaces { get; }
    public abstract virtual IEnumerable`1<INamespaceOrTypeSymbol> GetMembers();
    public abstract virtual IEnumerable`1<INamespaceOrTypeSymbol> GetMembers(string name);
    public abstract virtual IEnumerable`1<INamespaceSymbol> GetNamespaceMembers();
    public abstract virtual bool get_IsGlobalNamespace();
    public abstract virtual NamespaceKind get_NamespaceKind();
    public abstract virtual Compilation get_ContainingCompilation();
    public abstract virtual ImmutableArray`1<INamespaceSymbol> get_ConstituentNamespaces();
}
internal static class Microsoft.CodeAnalysis.InternalDiagnosticSeverity : object {
    public static DiagnosticSeverity Unknown;
    public static DiagnosticSeverity Void;
}
internal static class Microsoft.CodeAnalysis.InternalErrorCode : object {
    public static int Unknown;
    public static int Void;
}
internal static class Microsoft.CodeAnalysis.InternalSymbolDisplayPartKind : object {
    private static SymbolDisplayPartKind base;
    public static SymbolDisplayPartKind Arity;
    public static SymbolDisplayPartKind Other;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.InternalUtilities.ConcurrentLruCache`2 : object {
    private int _capacity;
    private Dictionary`2<K, CacheValue<K, V>> _cache;
    private LinkedList`1<K> _nodeList;
    private object _lockObject;
    internal IEnumerable`1<KeyValuePair`2<K, V>> TestingEnumerable { get; }
    public V Item { get; public set; }
    public ConcurrentLruCache`2(int capacity);
    public ConcurrentLruCache`2(KeyValuePair`2[] array);
    internal IEnumerable`1<KeyValuePair`2<K, V>> get_TestingEnumerable();
    public void Add(K key, V value);
    private void MoveNodeToTop(LinkedListNode`1<K> node);
    private void UnsafeEvictLastNode();
    private void UnsafeAddNodeToTop(K key, V value);
    private void UnsafeAdd(K key, V value, bool throwExceptionIfKeyExists);
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public bool TryGetValue(K key, V& value);
    public bool UnsafeTryGetValue(K key, V& value);
    public V GetOrAdd(K key, V value);
    public V GetOrAdd(K key, Func`1<V> creator);
    public V GetOrAdd(K key, T arg, Func`2<T, V> creator);
}
internal static class Microsoft.CodeAnalysis.Interop.ClrStrongName : object {
    private static object nCreateInterface(Guid clsid, Guid riid);
    internal static IClrStrongName GetInstance();
    internal static string GetRuntimeVersion();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("D332DB9E-B9B3-4125-8207-A14884F53216")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.CodeAnalysis.Interop.IClrMetaHost {
    public abstract virtual object GetRuntime(string version, Guid interfaceId);
    public abstract virtual int GetVersionFromFile(string filePath, StringBuilder buffer, Int32& bufferLength);
    public abstract virtual object EnumerateInstalledRuntimes();
    public abstract virtual object EnumerateLoadedRuntimes(IntPtr processHandle);
    public abstract virtual int Reserved01(IntPtr reserved1);
    public abstract virtual object QueryLegacyV2RuntimeBinding(Guid interfaceId);
    public abstract virtual void ExitProcess(int exitCode);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("BD39D1D2-BA2F-486A-89B0-B4B0CB466891")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.CodeAnalysis.Interop.IClrRuntimeInfo {
    public abstract virtual int GetVersionString(StringBuilder buffer, Int32& bufferLength);
    public abstract virtual int GetRuntimeDirectory(StringBuilder buffer, Int32& bufferLength);
    public abstract virtual bool IsLoaded(IntPtr processHandle);
    public abstract virtual int LoadErrorString(int resourceId, StringBuilder buffer, Int32& bufferLength);
    public abstract virtual IntPtr LoadLibrary(string dllName);
    public abstract virtual IntPtr GetProcAddress(string procName);
    public abstract virtual object GetInterface(Guid coClassId, Guid interfaceId);
    public abstract virtual bool IsLoadable();
    public abstract virtual void SetDefaultStartupFlags(int startupFlags, string hostConfigFile);
    public abstract virtual int GetDefaultStartupFlags(Int32& startupFlags, StringBuilder hostConfigFile, Int32& hostConfigFileLength);
    public abstract virtual void BindAsLegacyV2Runtime();
    public abstract virtual void IsStarted(Boolean& started, Int32& startupFlags);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("9FD93CCF-3280-4391-B3A9-96E1CDE77C8D")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.CodeAnalysis.Interop.IClrStrongName {
    public abstract virtual void GetHashFromAssemblyFile(string pszFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual void GetHashFromAssemblyFileW(string pwzFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual void GetHashFromBlob(IntPtr pbBlob, int cchBlob, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual void GetHashFromFile(string pszFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual void GetHashFromFileW(string pwzFilePath, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual void GetHashFromHandle(IntPtr hFile, Int32& piHashAlg, Byte[] pbHash, int cchHash, Int32& pchHash);
    public abstract virtual int StrongNameCompareAssemblies(string pwzAssembly1, string pwzAssembly2);
    public abstract virtual void StrongNameFreeBuffer(IntPtr pbMemory);
    public abstract virtual void StrongNameGetBlob(string pwzFilePath, Byte[] pbBlob, Int32& pcbBlob);
    public abstract virtual void StrongNameGetBlobFromImage(IntPtr pbBase, int dwLength, Byte[] pbBlob, Int32& pcbBlob);
    public abstract virtual void StrongNameGetPublicKey(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    public abstract virtual int StrongNameHashSize(int ulHashAlg);
    public abstract virtual void StrongNameKeyDelete(string pwzKeyContainer);
    public abstract virtual void StrongNameKeyGen(string pwzKeyContainer, int dwFlags, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    public abstract virtual void StrongNameKeyGenEx(string pwzKeyContainer, int dwFlags, int dwKeySize, IntPtr& ppbKeyBlob, Int32& pcbKeyBlob);
    public abstract virtual void StrongNameKeyInstall(string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob);
    public abstract virtual void StrongNameSignatureGeneration(string pwzFilePath, string pwzKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, Byte[] ppbSignatureBlob, Int32& pcbSignatureBlob);
    public abstract virtual void StrongNameSignatureGenerationEx(string wszFilePath, string wszKeyContainer, IntPtr pbKeyBlob, int cbKeyBlob, IntPtr& ppbSignatureBlob, Int32& pcbSignatureBlob, int dwFlags);
    public abstract virtual void StrongNameSignatureSize(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, Int32& pcbSize);
    public abstract virtual int StrongNameSignatureVerification(string pwzFilePath, int dwInFlags);
    public abstract virtual bool StrongNameSignatureVerificationEx(string pwzFilePath, bool fForceVerification, IntPtr& ptr);
    public abstract virtual int StrongNameSignatureVerificationFromImage(IntPtr pbBase, int dwLength, int dwInFlags);
    public abstract virtual void StrongNameTokenFromAssembly(string pwzFilePath, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
    public abstract virtual void StrongNameTokenFromAssemblyEx(string pwzFilePath, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken, IntPtr& ppbPublicKeyBlob, Int32& pcbPublicKeyBlob);
    public abstract virtual void StrongNameTokenFromPublicKey(IntPtr pbPublicKeyBlob, int cbPublicKeyBlob, IntPtr& ppbStrongNameToken, Int32& pcbStrongNameToken);
}
internal class Microsoft.CodeAnalysis.InvalidRuleSetException : Exception {
    public InvalidRuleSetException(string message);
    public InvalidRuleSetException(string message, Exception inner);
}
[InternalImplementationOnlyAttribute]
public interface Microsoft.CodeAnalysis.IOperation {
    public IOperation Parent { get; }
    public OperationKind Kind { get; }
    public SyntaxNode Syntax { get; }
    public ITypeSymbol Type { get; }
    public Optional`1<object> ConstantValue { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public string Language { get; }
    public bool IsImplicit { get; }
    public SemanticModel SemanticModel { get; }
    public abstract virtual IOperation get_Parent();
    public abstract virtual OperationKind get_Kind();
    public abstract virtual SyntaxNode get_Syntax();
    public abstract virtual ITypeSymbol get_Type();
    public abstract virtual Optional`1<object> get_ConstantValue();
    public abstract virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual string get_Language();
    public abstract virtual void Accept(OperationVisitor visitor);
    public abstract virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public abstract virtual bool get_IsImplicit();
    public abstract virtual SemanticModel get_SemanticModel();
}
public interface Microsoft.CodeAnalysis.IParameterSymbol {
    public RefKind RefKind { get; }
    public bool IsParams { get; }
    public bool IsOptional { get; }
    public bool IsThis { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public ImmutableArray`1<CustomModifier> RefCustomModifiers { get; }
    public int Ordinal { get; }
    public bool HasExplicitDefaultValue { get; }
    public object ExplicitDefaultValue { get; }
    public IParameterSymbol OriginalDefinition { get; }
    public abstract virtual RefKind get_RefKind();
    public abstract virtual bool get_IsParams();
    public abstract virtual bool get_IsOptional();
    public abstract virtual bool get_IsThis();
    public abstract virtual ITypeSymbol get_Type();
    public abstract virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public abstract virtual ImmutableArray`1<CustomModifier> get_RefCustomModifiers();
    public abstract virtual int get_Ordinal();
    public abstract virtual bool get_HasExplicitDefaultValue();
    public abstract virtual object get_ExplicitDefaultValue();
    public abstract virtual IParameterSymbol get_OriginalDefinition();
}
public interface Microsoft.CodeAnalysis.IPointerTypeSymbol {
    public ITypeSymbol PointedAtType { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public abstract virtual ITypeSymbol get_PointedAtType();
    public abstract virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
}
public interface Microsoft.CodeAnalysis.IPreprocessingSymbol {
}
public interface Microsoft.CodeAnalysis.IPropertySymbol {
    public bool IsIndexer { get; }
    public bool IsReadOnly { get; }
    public bool IsWriteOnly { get; }
    public bool IsWithEvents { get; }
    public bool ReturnsByRef { get; }
    public bool ReturnsByRefReadonly { get; }
    public RefKind RefKind { get; }
    public ITypeSymbol Type { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public IMethodSymbol GetMethod { get; }
    public IMethodSymbol SetMethod { get; }
    public IPropertySymbol OriginalDefinition { get; }
    public IPropertySymbol OverriddenProperty { get; }
    public ImmutableArray`1<IPropertySymbol> ExplicitInterfaceImplementations { get; }
    public ImmutableArray`1<CustomModifier> RefCustomModifiers { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public abstract virtual bool get_IsIndexer();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsWriteOnly();
    public abstract virtual bool get_IsWithEvents();
    public abstract virtual bool get_ReturnsByRef();
    public abstract virtual bool get_ReturnsByRefReadonly();
    public abstract virtual RefKind get_RefKind();
    public abstract virtual ITypeSymbol get_Type();
    public abstract virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    public abstract virtual IMethodSymbol get_GetMethod();
    public abstract virtual IMethodSymbol get_SetMethod();
    public abstract virtual IPropertySymbol get_OriginalDefinition();
    public abstract virtual IPropertySymbol get_OverriddenProperty();
    public abstract virtual ImmutableArray`1<IPropertySymbol> get_ExplicitInterfaceImplementations();
    public abstract virtual ImmutableArray`1<CustomModifier> get_RefCustomModifiers();
    public abstract virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
}
public interface Microsoft.CodeAnalysis.IRangeVariableSymbol {
}
internal interface Microsoft.CodeAnalysis.ISecurityAttributeTarget {
    public abstract virtual SecurityWellKnownAttributeData GetOrCreateData();
}
public interface Microsoft.CodeAnalysis.ISkippedTokensTriviaSyntax {
    public SyntaxTokenList Tokens { get; }
    public abstract virtual SyntaxTokenList get_Tokens();
}
public interface Microsoft.CodeAnalysis.ISourceAssemblySymbol {
    public Compilation Compilation { get; }
    public abstract virtual Compilation get_Compilation();
}
internal interface Microsoft.CodeAnalysis.ISourceAssemblySymbolInternal {
    public AssemblyFlags AssemblyFlags { get; }
    public string SignatureKey { get; }
    public AssemblyHashAlgorithm HashAlgorithm { get; }
    public Version AssemblyVersionPattern { get; }
    public bool InternalsAreVisible { get; }
    public abstract virtual AssemblyFlags get_AssemblyFlags();
    public abstract virtual string get_SignatureKey();
    public abstract virtual AssemblyHashAlgorithm get_HashAlgorithm();
    public abstract virtual Version get_AssemblyVersionPattern();
    public abstract virtual bool get_InternalsAreVisible();
}
public interface Microsoft.CodeAnalysis.IStructuredTriviaSyntax {
    public SyntaxTrivia ParentTrivia { get; }
    public abstract virtual SyntaxTrivia get_ParentTrivia();
}
[InternalImplementationOnlyAttribute]
public interface Microsoft.CodeAnalysis.ISymbol {
    public SymbolKind Kind { get; }
    public string Language { get; }
    public string Name { get; }
    public string MetadataName { get; }
    public ISymbol ContainingSymbol { get; }
    public IAssemblySymbol ContainingAssembly { get; }
    public IModuleSymbol ContainingModule { get; }
    public INamedTypeSymbol ContainingType { get; }
    public INamespaceSymbol ContainingNamespace { get; }
    public bool IsDefinition { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    public bool IsImplicitlyDeclared { get; }
    public bool CanBeReferencedByName { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public Accessibility DeclaredAccessibility { get; }
    public ISymbol OriginalDefinition { get; }
    public bool HasUnsupportedMetadata { get; }
    public abstract virtual SymbolKind get_Kind();
    public abstract virtual string get_Language();
    public abstract virtual string get_Name();
    public abstract virtual string get_MetadataName();
    public abstract virtual ISymbol get_ContainingSymbol();
    public abstract virtual IAssemblySymbol get_ContainingAssembly();
    public abstract virtual IModuleSymbol get_ContainingModule();
    public abstract virtual INamedTypeSymbol get_ContainingType();
    public abstract virtual INamespaceSymbol get_ContainingNamespace();
    public abstract virtual bool get_IsDefinition();
    public abstract virtual bool get_IsStatic();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual bool get_IsOverride();
    public abstract virtual bool get_IsAbstract();
    public abstract virtual bool get_IsSealed();
    public abstract virtual bool get_IsExtern();
    public abstract virtual bool get_IsImplicitlyDeclared();
    public abstract virtual bool get_CanBeReferencedByName();
    public abstract virtual ImmutableArray`1<Location> get_Locations();
    public abstract virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public abstract virtual ImmutableArray`1<AttributeData> GetAttributes();
    public abstract virtual Accessibility get_DeclaredAccessibility();
    public abstract virtual ISymbol get_OriginalDefinition();
    public abstract virtual void Accept(SymbolVisitor visitor);
    public abstract virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public abstract virtual string GetDocumentationCommentId();
    public abstract virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public abstract virtual string ToDisplayString(SymbolDisplayFormat format);
    public abstract virtual ImmutableArray`1<SymbolDisplayPart> ToDisplayParts(SymbolDisplayFormat format);
    public abstract virtual string ToMinimalDisplayString(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    public abstract virtual ImmutableArray`1<SymbolDisplayPart> ToMinimalDisplayParts(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    public abstract virtual bool get_HasUnsupportedMetadata();
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.ISymbolExtensions : object {
    [ExtensionAttribute]
public static IMethodSymbol GetConstructedReducedFrom(IMethodSymbol method);
    [ExtensionAttribute]
internal static bool IsDefaultTupleElement(IFieldSymbol field);
    [ExtensionAttribute]
internal static bool IsTupleElement(IFieldSymbol field);
    [ExtensionAttribute]
internal static string ProvidedTupleElementNameOrNull(IFieldSymbol field);
    [ExtensionAttribute]
internal static INamespaceSymbol GetNestedNamespace(INamespaceSymbol container, string name);
    [ExtensionAttribute]
internal static bool IsNetModule(IAssemblySymbol assembly);
    [ExtensionAttribute]
internal static IVTConclusion PerformIVTCheck(AssemblyIdentity assemblyGrantingAccessIdentity, ImmutableArray`1<byte> assemblyWantingAccessKey, ImmutableArray`1<byte> grantedToPublicKey);
}
internal interface Microsoft.CodeAnalysis.ISynthesizedMethodBodyImplementationSymbol {
    public IMethodSymbol Method { get; }
    public bool HasMethodBodyDependency { get; }
    public abstract virtual IMethodSymbol get_Method();
    public abstract virtual bool get_HasMethodBodyDependency();
}
public interface Microsoft.CodeAnalysis.ITypeParameterSymbol {
    public int Ordinal { get; }
    public VarianceKind Variance { get; }
    public TypeParameterKind TypeParameterKind { get; }
    public IMethodSymbol DeclaringMethod { get; }
    public INamedTypeSymbol DeclaringType { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public bool HasUnmanagedTypeConstraint { get; }
    public bool HasConstructorConstraint { get; }
    public ImmutableArray`1<ITypeSymbol> ConstraintTypes { get; }
    public ITypeParameterSymbol OriginalDefinition { get; }
    public ITypeParameterSymbol ReducedFrom { get; }
    public abstract virtual int get_Ordinal();
    public abstract virtual VarianceKind get_Variance();
    public abstract virtual TypeParameterKind get_TypeParameterKind();
    public abstract virtual IMethodSymbol get_DeclaringMethod();
    public abstract virtual INamedTypeSymbol get_DeclaringType();
    public abstract virtual bool get_HasReferenceTypeConstraint();
    public abstract virtual bool get_HasValueTypeConstraint();
    public abstract virtual bool get_HasUnmanagedTypeConstraint();
    public abstract virtual bool get_HasConstructorConstraint();
    public abstract virtual ImmutableArray`1<ITypeSymbol> get_ConstraintTypes();
    public abstract virtual ITypeParameterSymbol get_OriginalDefinition();
    public abstract virtual ITypeParameterSymbol get_ReducedFrom();
}
public interface Microsoft.CodeAnalysis.ITypeSymbol {
    public TypeKind TypeKind { get; }
    public INamedTypeSymbol BaseType { get; }
    public ImmutableArray`1<INamedTypeSymbol> Interfaces { get; }
    public ImmutableArray`1<INamedTypeSymbol> AllInterfaces { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    public bool IsAnonymousType { get; }
    public bool IsTupleType { get; }
    public ITypeSymbol OriginalDefinition { get; }
    public SpecialType SpecialType { get; }
    public abstract virtual TypeKind get_TypeKind();
    public abstract virtual INamedTypeSymbol get_BaseType();
    public abstract virtual ImmutableArray`1<INamedTypeSymbol> get_Interfaces();
    public abstract virtual ImmutableArray`1<INamedTypeSymbol> get_AllInterfaces();
    public abstract virtual bool get_IsReferenceType();
    public abstract virtual bool get_IsValueType();
    public abstract virtual bool get_IsAnonymousType();
    public abstract virtual bool get_IsTupleType();
    public abstract virtual ITypeSymbol get_OriginalDefinition();
    public abstract virtual SpecialType get_SpecialType();
    public abstract virtual ISymbol FindImplementationForInterfaceMember(ISymbol interfaceMember);
}
internal static class Microsoft.CodeAnalysis.ITypeSymbolHelpers : object {
    internal static bool IsNullableType(ITypeSymbol typeOpt);
    internal static bool IsNullableOfBoolean(ITypeSymbol type);
    internal static ITypeSymbol GetNullableUnderlyingType(ITypeSymbol type);
    internal static bool IsBooleanType(ITypeSymbol type);
    internal static bool IsObjectType(ITypeSymbol type);
    internal static bool IsSignedIntegralType(ITypeSymbol type);
    internal static bool IsUnsignedIntegralType(ITypeSymbol type);
    internal static bool IsNumericType(ITypeSymbol type);
    internal static ITypeSymbol GetEnumUnderlyingType(ITypeSymbol type);
    internal static ITypeSymbol GetEnumUnderlyingTypeOrSelf(ITypeSymbol type);
    internal static bool IsDynamicType(ITypeSymbol type);
}
internal enum Microsoft.CodeAnalysis.IVTConclusion : Enum {
    public int value__;
    public static IVTConclusion Match;
    public static IVTConclusion OneSignedOneNot;
    public static IVTConclusion PublicKeyDoesntMatch;
    public static IVTConclusion NoRelationshipClaimed;
}
public static class Microsoft.CodeAnalysis.LanguageNames : object {
    public static string CSharp;
    public static string VisualBasic;
    public static string FSharp;
}
internal abstract class Microsoft.CodeAnalysis.LineDirectiveMap`1 : object {
    protected LineMappingEntry[] Entries;
    protected LineDirectiveMap`1(SyntaxTree syntaxTree);
    protected abstract virtual bool ShouldAddDirective(TDirective directive);
    protected abstract virtual LineMappingEntry<TDirective> GetEntry(TDirective directive, SourceText sourceText, LineMappingEntry<TDirective> previous);
    protected abstract virtual LineMappingEntry<TDirective> InitializeFirstEntry();
    public FileLinePositionSpan TranslateSpan(SourceText sourceText, string treeFilePath, TextSpan span);
    protected FileLinePositionSpan TranslateSpan(LineMappingEntry<TDirective> entry, string treeFilePath, LinePosition unmappedStartPos, LinePosition unmappedEndPos);
    public abstract virtual LineVisibility GetLineVisibility(SourceText sourceText, int position);
    internal abstract virtual FileLinePositionSpan TranslateSpanAndVisibility(SourceText sourceText, string treeFilePath, TextSpan span, Boolean& isHiddenPosition);
    public bool HasAnyHiddenRegions();
    protected LineMappingEntry<TDirective> FindEntry(int lineNumber);
    protected int FindEntryIndex(int lineNumber);
    private LineMappingEntry[] CreateEntryMap(SyntaxTree tree, IList`1<TDirective> directives);
}
public enum Microsoft.CodeAnalysis.LineVisibility : Enum {
    public int value__;
    public static LineVisibility BeforeFirstLineDirective;
    public static LineVisibility Hidden;
    public static LineVisibility Visible;
}
internal class Microsoft.CodeAnalysis.LoadDirective : ValueType {
    public string ResolvedPath;
    public ImmutableArray`1<Diagnostic> Diagnostics;
    public LoadDirective(string resolvedPath, ImmutableArray`1<Diagnostic> diagnostics);
    public sealed virtual bool Equals(LoadDirective other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.LocalInfo`1 : ValueType {
    internal Byte[] SignatureOpt;
    internal TypeSymbol Type;
    internal ImmutableArray`1<ModifierInfo`1<TypeSymbol>> CustomModifiers;
    internal LocalSlotConstraints Constraints;
    public bool IsByRef { get; }
    public bool IsPinned { get; }
    internal LocalInfo`1(TypeSymbol type, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers, LocalSlotConstraints constraints, Byte[] signatureOpt);
    internal LocalInfo`1<TypeSymbol> WithSignature(Byte[] signature);
    public bool get_IsByRef();
    public bool get_IsPinned();
}
public class Microsoft.CodeAnalysis.LocalizableResourceString : LocalizableString {
    private string _nameOfLocalizableResource;
    private ResourceManager _resourceManager;
    private Type _resourceSource;
    private String[] _formatArguments;
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    private static LocalizableResourceString();
    public LocalizableResourceString(string nameOfLocalizableResource, ResourceManager resourceManager, Type resourceSource);
    public LocalizableResourceString(string nameOfLocalizableResource, ResourceManager resourceManager, Type resourceSource, String[] formatArguments);
    private LocalizableResourceString(ObjectReader reader);
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    protected virtual string GetText(IFormatProvider formatProvider);
    protected virtual bool AreEqual(object other);
    protected virtual int GetHash();
}
public abstract class Microsoft.CodeAnalysis.LocalizableString : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<Exception> OnException;
    internal bool CanThrowExceptions { get; }
    [CompilerGeneratedAttribute]
public void add_OnException(EventHandler`1<Exception> value);
    [CompilerGeneratedAttribute]
public void remove_OnException(EventHandler`1<Exception> value);
    public string ToString(IFormatProvider formatProvider);
    public static string op_Explicit(LocalizableString localizableResource);
    public static LocalizableString op_Implicit(string fixedResource);
    public sealed virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string ignored, IFormatProvider formatProvider);
    public sealed virtual int GetHashCode();
    public sealed virtual bool Equals(object other);
    public sealed virtual bool Equals(LocalizableString other);
    protected abstract virtual string GetText(IFormatProvider formatProvider);
    protected abstract virtual int GetHash();
    protected abstract virtual bool AreEqual(object other);
    private void RaiseOnException(Exception ex);
    internal virtual bool get_CanThrowExceptions();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.LocalSlotConstraints : Enum {
    public byte value__;
    public static LocalSlotConstraints None;
    public static LocalSlotConstraints ByRef;
    public static LocalSlotConstraints Pinned;
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public abstract class Microsoft.CodeAnalysis.Location : object {
    public LocationKind Kind { get; }
    public bool IsInSource { get; }
    public bool IsInMetadata { get; }
    public SyntaxTree SourceTree { get; }
    public IModuleSymbol MetadataModule { get; }
    public TextSpan SourceSpan { get; }
    public static Location None { get; }
    public abstract virtual LocationKind get_Kind();
    public bool get_IsInSource();
    public bool get_IsInMetadata();
    public virtual SyntaxTree get_SourceTree();
    public virtual IModuleSymbol get_MetadataModule();
    public virtual TextSpan get_SourceSpan();
    public virtual FileLinePositionSpan GetLineSpan();
    public virtual FileLinePositionSpan GetMappedLineSpan();
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(Location left, Location right);
    public static bool op_Inequality(Location left, Location right);
    protected virtual string GetDebuggerDisplay();
    public static Location get_None();
    public static Location Create(SyntaxTree syntaxTree, TextSpan textSpan);
    public static Location Create(string filePath, TextSpan textSpan, LinePositionSpan lineSpan);
}
public enum Microsoft.CodeAnalysis.LocationKind : Enum {
    public byte value__;
    public static LocationKind None;
    public static LocationKind SourceFile;
    public static LocationKind MetadataFile;
    public static LocationKind XmlFile;
    public static LocationKind ExternalFile;
}
internal static class Microsoft.CodeAnalysis.MarshalAsAttributeDecoder`4 : object {
    internal static void Decode(DecodeWellKnownAttributeArguments`3& arguments, AttributeTargets target, CommonMessageProvider messageProvider);
    private static UnmanagedType DecodeMarshalAsType(AttributeData attribute);
    private static void DecodeMarshalAsCustom(DecodeWellKnownAttributeArguments`3& arguments, CommonMessageProvider messageProvider);
    private static void DecodeMarshalAsComInterface(DecodeWellKnownAttributeArguments`3& arguments, UnmanagedType unmanagedType, CommonMessageProvider messageProvider);
    private static void DecodeMarshalAsArray(DecodeWellKnownAttributeArguments`3& arguments, CommonMessageProvider messageProvider, bool isFixed);
    private static void DecodeMarshalAsSafeArray(DecodeWellKnownAttributeArguments`3& arguments, CommonMessageProvider messageProvider);
    private static void DecodeMarshalAsFixedString(DecodeWellKnownAttributeArguments`3& arguments, CommonMessageProvider messageProvider);
}
internal class Microsoft.CodeAnalysis.MarshalPseudoCustomAttributeData : object {
    private UnmanagedType _marshalType;
    private int _marshalArrayElementType;
    private int _marshalArrayElementCount;
    private int _marshalParameterIndex;
    private object _marshalTypeNameOrSymbol;
    private string _marshalCookie;
    internal static int Invalid;
    private static UnmanagedType InvalidUnmanagedType;
    private static VarEnum InvalidVariantType;
    internal static int MaxMarshalInteger;
    public UnmanagedType UnmanagedType { get; }
    private int Microsoft.Cci.IMarshallingInformation.IidParameterIndex { get; }
    private string Microsoft.Cci.IMarshallingInformation.CustomMarshallerRuntimeArgument { get; }
    private int Microsoft.Cci.IMarshallingInformation.NumberOfElements { get; }
    private short Microsoft.Cci.IMarshallingInformation.ParamIndex { get; }
    private UnmanagedType Microsoft.Cci.IMarshallingInformation.ElementType { get; }
    private VarEnum Microsoft.Cci.IMarshallingInformation.SafeArrayElementSubtype { get; }
    internal void SetMarshalAsCustom(object typeSymbolOrName, string cookie);
    internal void SetMarshalAsComInterface(UnmanagedType unmanagedType, Nullable`1<int> parameterIndex);
    internal void SetMarshalAsArray(Nullable`1<UnmanagedType> elementType, Nullable`1<int> elementCount, Nullable`1<short> parameterIndex);
    internal void SetMarshalAsFixedArray(Nullable`1<UnmanagedType> elementType, Nullable`1<int> elementCount);
    internal void SetMarshalAsSafeArray(Nullable`1<VarEnum> elementType, ITypeSymbol elementTypeSymbol);
    internal void SetMarshalAsFixedString(int elementCount);
    internal void SetMarshalAsSimpleType(UnmanagedType type);
    public sealed virtual UnmanagedType get_UnmanagedType();
    private sealed virtual override int Microsoft.Cci.IMarshallingInformation.get_IidParameterIndex();
    private sealed virtual override object Microsoft.Cci.IMarshallingInformation.GetCustomMarshaller(EmitContext context);
    private sealed virtual override string Microsoft.Cci.IMarshallingInformation.get_CustomMarshallerRuntimeArgument();
    private sealed virtual override int Microsoft.Cci.IMarshallingInformation.get_NumberOfElements();
    private sealed virtual override short Microsoft.Cci.IMarshallingInformation.get_ParamIndex();
    private sealed virtual override UnmanagedType Microsoft.Cci.IMarshallingInformation.get_ElementType();
    private sealed virtual override VarEnum Microsoft.Cci.IMarshallingInformation.get_SafeArrayElementSubtype();
    private sealed virtual override ITypeReference Microsoft.Cci.IMarshallingInformation.GetSafeArrayElementUserDefinedSubtype(EmitContext context);
    internal MarshalPseudoCustomAttributeData WithTranslatedTypes(Func`3<TTypeSymbol, TArg, TTypeSymbol> translator, TArg arg);
    internal ITypeSymbol TryGetSafeArrayElementUserDefinedSubtype();
}
internal class Microsoft.CodeAnalysis.MergedAliases : object {
    public ArrayBuilder`1<string> AliasesOpt;
    public ArrayBuilder`1<string> RecursiveAliasesOpt;
    internal void Merge(MetadataReference reference);
    internal static void Merge(ArrayBuilder`1<string> aliases, ImmutableArray`1<string> newAliases);
    internal static ImmutableArray`1<string> Merge(ImmutableArray`1<string> aliasesOpt, ImmutableArray`1<string> newAliases);
    private static void AddNonIncluded(ArrayBuilder`1<string> builder, string item);
    private static void AddNonIncluded(ArrayBuilder`1<string> builder, ImmutableArray`1<string> items);
}
public abstract class Microsoft.CodeAnalysis.Metadata : object {
    internal bool IsImageOwner;
    [CompilerGeneratedAttribute]
private MetadataId <Id>k__BackingField;
    public MetadataId Id { get; }
    public MetadataImageKind Kind { get; }
    internal Metadata(bool isImageOwner, MetadataId id);
    [CompilerGeneratedAttribute]
public MetadataId get_Id();
    public abstract virtual MetadataImageKind get_Kind();
    public abstract virtual void Dispose();
    protected abstract virtual Metadata CommonCopy();
    public Metadata Copy();
}
internal abstract class Microsoft.CodeAnalysis.MetadataDecoder`5 : TypeNameDecoder`2<ModuleSymbol, TypeSymbol> {
    public PEModule Module;
    private AssemblyIdentity _containingAssemblyIdentity;
    internal MetadataDecoder`5(PEModule module, AssemblyIdentity containingAssemblyIdentity, SymbolFactory`2<ModuleSymbol, TypeSymbol> factory, ModuleSymbol moduleSymbol);
    internal TypeSymbol GetTypeOfToken(EntityHandle token);
    internal TypeSymbol GetTypeOfToken(EntityHandle token, Boolean& isNoPiaLocalType);
    private TypeSymbol GetTypeOfTypeSpec(TypeSpecificationHandle typeSpec);
    private TypeSymbol DecodeTypeOrThrow(BlobReader& ppSig, Boolean& refersToNoPiaLocalType);
    private TypeSymbol DecodeTypeOrThrow(BlobReader& ppSig, SignatureTypeCode typeCode, Boolean& refersToNoPiaLocalType);
    private TypeSymbol DecodeGenericTypeInstanceOrThrow(BlobReader& ppSig, Boolean& refersToNoPiaLocalType);
    internal TypeSymbol GetSymbolForTypeHandleOrThrow(EntityHandle handle, Boolean& isNoPiaLocalType, bool allowTypeSpec, bool requireShortForm);
    private TypeSymbol GetTypeOfTypeRef(TypeReferenceHandle typeRef, Boolean& isNoPiaLocalType);
    private TypeSymbol GetTypeByNameOrThrow(MetadataTypeName& fullName, EntityHandle tokenResolutionScope, Boolean& isNoPiaLocalType);
    private TypeSymbol GetTypeOfTypeDef(TypeDefinitionHandle typeDef);
    private TypeSymbol GetTypeOfTypeDef(TypeDefinitionHandle typeDef, Boolean& isNoPiaLocalType, bool isContainingType);
    private ImmutableArray`1<ModifierInfo`1<TypeSymbol>> DecodeModifiersOrThrow(BlobReader& signatureReader, AllowedRequiredModifierType<ModuleSymbol, TypeSymbol, MethodSymbol, FieldSymbol, Symbol> allowedRequiredModifierType, SignatureTypeCode& typeCode, Boolean& requiredModifierFound);
    private TypeSymbol DecodeModifierTypeOrThrow(BlobReader& signatureReader);
    internal ImmutableArray`1<LocalInfo`1<TypeSymbol>> DecodeLocalSignatureOrThrow(BlobReader& signatureReader);
    internal TypeSymbol DecodeGenericParameterConstraint(EntityHandle token, Boolean& isUnmanagedConstraint);
    internal LocalInfo`1<TypeSymbol> DecodeLocalVariableOrThrow(BlobReader& signatureReader);
    internal void DecodeLocalConstantBlobOrThrow(BlobReader& sigReader, TypeSymbol& type, ConstantValue& value);
    private static ConstantValue DecodePrimitiveConstantValue(BlobReader& sigReader, SignatureTypeCode typeCode, Boolean& isEnumTypeCode);
    internal ImmutableArray`1<LocalInfo`1<TypeSymbol>> GetLocalsOrThrow(StandaloneSignatureHandle handle);
    internal TypeSymbol DecodeLocalVariableTypeOrThrow(ImmutableArray`1<byte> signature);
    internal ImmutableArray`1<LocalInfo`1<TypeSymbol>> GetLocalInfo(StandaloneSignatureHandle localSignatureHandle);
    private void DecodeParameterOrThrow(BlobReader& signatureReader, ParamInfo`1& info);
    internal ParamInfo`1[] GetSignatureForMethod(MethodDefinitionHandle methodDef, SignatureHeader& signatureHeader, BadImageFormatException& metadataException, bool setParamHandles);
    internal static void GetSignatureCountsOrThrow(PEModule module, MethodDefinitionHandle methodDef, Int32& parameterCount, Int32& typeParameterCount);
    internal ParamInfo`1[] GetSignatureForProperty(PropertyDefinitionHandle handle, SignatureHeader& signatureHeader, BadImageFormatException& BadImageFormatException);
    internal SignatureHeader GetSignatureHeaderForProperty(PropertyDefinitionHandle handle);
    private void DecodeCustomAttributeParameterTypeOrThrow(BlobReader& sigReader, SerializationTypeCode& typeCode, TypeSymbol& type, SerializationTypeCode& elementTypeCode, TypeSymbol& elementType, bool isElementType);
    private void DecodeCustomAttributeFieldOrPropTypeOrThrow(BlobReader& argReader, SerializationTypeCode& typeCode, TypeSymbol& type, SerializationTypeCode& elementTypeCode, TypeSymbol& elementType, bool isElementType);
    private TypedConstant DecodeCustomAttributeFixedArgumentOrThrow(BlobReader& sigReader, BlobReader& argReader);
    private TypedConstant DecodeCustomAttributeElementOrThrow(BlobReader& argReader, SerializationTypeCode typeCode, TypeSymbol type);
    private TypedConstant DecodeCustomAttributeElementArrayOrThrow(BlobReader& argReader, SerializationTypeCode elementTypeCode, TypeSymbol elementType, TypeSymbol arrayType);
    private TypedConstant DecodeCustomAttributePrimitiveElementOrThrow(BlobReader& argReader, SerializationTypeCode typeCode, TypeSymbol type);
    private static TypedConstantKind GetPrimitiveOrEnumTypedConstantKind(TypeSymbol type);
    private KeyValuePair`2<string, TypedConstant> DecodeCustomAttributeNamedArgumentOrThrow(BlobReader& argReader);
    internal bool IsTargetAttribute(CustomAttributeHandle customAttribute, string namespaceName, string typeName, bool ignoreCase);
    internal int GetTargetAttributeSignatureIndex(CustomAttributeHandle customAttribute, AttributeDescription description);
    internal bool GetCustomAttribute(CustomAttributeHandle handle, TypedConstant[]& positionalArgs, KeyValuePair`2[]& namedArgs);
    internal bool GetCustomAttribute(CustomAttributeHandle handle, TypeSymbol& attributeClass, MethodSymbol& attributeCtor);
    internal bool GetCustomAttributeWellKnownType(CustomAttributeHandle handle, WellKnownType& wellKnownAttribute);
    private TypeSymbol[] DecodeMethodSpecTypeArgumentsOrThrow(BlobHandle signature);
    internal BlobReader DecodeSignatureHeaderOrThrow(BlobHandle signature, SignatureHeader& signatureHeader);
    internal static BlobReader DecodeSignatureHeaderOrThrow(PEModule module, BlobHandle signature, SignatureHeader& signatureHeader);
    protected ParamInfo`1[] DecodeSignatureParametersOrThrow(BlobReader& signatureReader, SignatureHeader signatureHeader, Int32& typeParameterCount);
    private static void GetSignatureCountsOrThrow(BlobReader& signatureReader, SignatureHeader signatureHeader, Int32& parameterCount, Int32& typeParameterCount);
    internal TypeSymbol DecodeFieldSignature(FieldDefinitionHandle fieldHandle, Boolean& isVolatile, ImmutableArray`1& customModifiers);
    protected TypeSymbol DecodeFieldSignature(BlobReader& signatureReader, Boolean& isVolatile, ImmutableArray`1& customModifiers);
    internal ImmutableArray`1<MethodSymbol> GetExplicitlyOverriddenMethods(TypeDefinitionHandle implementingTypeDef, MethodDefinitionHandle implementingMethodDef, TypeSymbol implementingTypeSymbol);
    private MethodSymbol FindMethodSymbolInSuperType(TypeDefinitionHandle searchTypeDef, MethodDefinitionHandle targetMethodDef);
    private void EnqueueTypeDefInterfacesAndBaseTypeOrThrow(Queue`1<TypeDefinitionHandle> typeDefsToSearch, Queue`1<TypeSymbol> typeSymbolsToSearch, TypeDefinitionHandle searchTypeDef);
    private void EnqueueTypeToken(Queue`1<TypeDefinitionHandle> typeDefsToSearch, Queue`1<TypeSymbol> typeSymbolsToSearch, EntityHandle typeToken);
    protected abstract virtual void EnqueueTypeSymbolInterfacesAndBaseTypes(Queue`1<TypeDefinitionHandle> typeDefsToSearch, Queue`1<TypeSymbol> typeSymbolsToSearch, TypeSymbol typeSymbol);
    protected abstract virtual void EnqueueTypeSymbol(Queue`1<TypeDefinitionHandle> typeDefsToSearch, Queue`1<TypeSymbol> typeSymbolsToSearch, TypeSymbol typeSymbol);
    protected abstract virtual MethodSymbol FindMethodSymbolInType(TypeSymbol type, MethodDefinitionHandle methodDef);
    protected abstract virtual FieldSymbol FindFieldSymbolInType(TypeSymbol type, FieldDefinitionHandle fieldDef);
    internal abstract virtual Symbol GetSymbolForMemberRef(MemberReferenceHandle memberRef, TypeSymbol implementingTypeSymbol, bool methodsOnly);
    internal MethodSymbol GetMethodSymbolForMemberRef(MemberReferenceHandle methodRef, TypeSymbol implementingTypeSymbol);
    internal FieldSymbol GetFieldSymbolForMemberRef(MemberReferenceHandle methodRef, TypeSymbol implementingTypeSymbol);
    protected virtual bool IsContainingAssembly(AssemblyIdentity identity);
    protected abstract virtual MethodDefinitionHandle GetMethodHandle(MethodSymbol method);
    protected abstract virtual ConcurrentDictionary`2<TypeDefinitionHandle, TypeSymbol> GetTypeHandleToTypeMap();
    protected abstract virtual ConcurrentDictionary`2<TypeReferenceHandle, TypeSymbol> GetTypeRefHandleToTypeMap();
    protected abstract virtual TypeSymbol SubstituteNoPiaLocalType(TypeDefinitionHandle typeDef, MetadataTypeName& name, string interfaceGuid, string scope, string identifier);
    protected abstract virtual TypeSymbol LookupTopLevelTypeDefSymbol(string moduleName, MetadataTypeName& emittedName, Boolean& isNoPiaLocalType);
    protected abstract virtual TypeSymbol GetGenericTypeParamSymbol(int position);
    protected abstract virtual TypeSymbol GetGenericMethodTypeParamSymbol(int position);
    private static TypedConstant CreateArrayTypedConstant(TypeSymbol type, ImmutableArray`1<TypedConstant> array);
    private static TypedConstant CreateTypedConstant(TypeSymbol type, TypedConstantKind kind, object value);
    private static TypedConstant CreateTypedConstant(TypeSymbol type, TypedConstantKind kind, bool value);
    internal Symbol GetSymbolForILToken(EntityHandle token);
    internal TypeSymbol GetMemberRefTypeSymbol(MemberReferenceHandle memberRef);
    internal MethodSymbol GetMethodSymbolForMethodDefOrMemberRef(EntityHandle memberToken, TypeSymbol container);
    internal FieldSymbol GetFieldSymbolForFieldDefOrMemberRef(EntityHandle memberToken, TypeSymbol container);
    internal bool DoPropertySignaturesMatch(ParamInfo`1[] signature1, ParamInfo`1[] signature2, bool comparingToSetter, bool compareParamByRef, bool compareReturnType);
    internal bool DoesSignatureMatchEvent(TypeSymbol eventType, ParamInfo`1[] methodParams);
}
internal static class Microsoft.CodeAnalysis.MetadataHelpers : object {
    public static char DotDelimiter;
    public static string DotDelimiterString;
    public static char GenericTypeNameManglingChar;
    private static string GenericTypeNameManglingString;
    public static int MaxStringLengthForParamSize;
    public static int MaxStringLengthForIntToStringConversion;
    public static string SystemString;
    public static char MangledNameRegionStartChar;
    public static char MangledNameRegionEndChar;
    private static String[] s_aritySuffixesOneToNine;
    private static ImmutableArray`1<string> s_splitQualifiedNameSystem;
    private static MetadataHelpers();
    internal static AssemblyQualifiedTypeName DecodeTypeName(string s);
    internal static string GetAritySuffix(int arity);
    internal static string ComposeAritySuffixedMetadataName(string name, int arity);
    internal static int InferTypeArityFromMetadataName(string emittedTypeName);
    private static short InferTypeArityFromMetadataName(string emittedTypeName, Int32& suffixStartsAt);
    internal static string InferTypeArityAndUnmangleMetadataName(string emittedTypeName, Int16& arity);
    internal static string UnmangleMetadataNameForArity(string emittedTypeName, int arity);
    internal static ImmutableArray`1<string> SplitQualifiedName(string name);
    internal static string SplitQualifiedName(string pstrName, String& qualifier);
    internal static string BuildQualifiedName(string qualifier, string name);
    public static void GetInfoForImmediateNamespaceMembers(bool isGlobalNamespace, int namespaceNameLength, IEnumerable`1<IGrouping`2<string, TypeDefinitionHandle>> typesByNS, StringComparer nameComparer, IEnumerable`1& types, IEnumerable`1& namespaces);
    private static string ExtractSimpleNameOfChildNamespace(int parentNamespaceNameLength, string fullName);
    internal static bool IsValidMetadataIdentifier(string str);
    internal static bool IsValidUnicodeString(string str);
    internal static bool IsValidAssemblyOrModuleName(string name);
    internal static void CheckAssemblyOrModuleName(string name, CommonMessageProvider messageProvider, int code, DiagnosticBag diagnostics);
    internal static void CheckAssemblyOrModuleName(string name, CommonMessageProvider messageProvider, int code, ArrayBuilder`1<Diagnostic> builder);
    private static string GetAssemblyOrModuleNameErrorArgumentResourceName(string name);
    internal static bool IsValidMetadataFileName(string name);
    internal static bool SplitNameEqualsFullyQualifiedName(string namespaceName, string typeName, string fullyQualified);
    internal static bool IsValidPublicKey(ImmutableArray`1<byte> bytes);
    internal static string MangleForTypeNameIfNeeded(string moduleName);
}
public class Microsoft.CodeAnalysis.MetadataId : object {
    internal static MetadataId CreateNewId();
}
public enum Microsoft.CodeAnalysis.MetadataImageKind : Enum {
    public byte value__;
    public static MetadataImageKind Assembly;
    public static MetadataImageKind Module;
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.MetadataImageReference : PortableExecutableReference {
    private string _display;
    private Metadata _metadata;
    public string Display { get; }
    internal MetadataImageReference(Metadata metadata, MetadataReferenceProperties properties, DocumentationProvider documentation, string filePath, string display);
    protected virtual Metadata GetMetadataImpl();
    protected virtual DocumentationProvider CreateDocumentationProvider();
    protected virtual PortableExecutableReference WithPropertiesImpl(MetadataReferenceProperties properties);
    public virtual string get_Display();
    private string GetDebuggerDisplay();
}
public enum Microsoft.CodeAnalysis.MetadataImportOptions : Enum {
    public byte value__;
    public static MetadataImportOptions Public;
    public static MetadataImportOptions Internal;
    public static MetadataImportOptions All;
}
internal class Microsoft.CodeAnalysis.MetadataLocation : Location {
    private IModuleSymbol _module;
    public LocationKind Kind { get; }
    public IModuleSymbol MetadataModule { get; }
    internal MetadataLocation(IModuleSymbol module);
    public virtual LocationKind get_Kind();
    public virtual IModuleSymbol get_MetadataModule();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MetadataLocation other);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.MetadataReaderExtensions : object {
    [ExtensionAttribute]
internal static bool GetWinMdVersion(MetadataReader reader, Int32& majorVersion, Int32& minorVersion);
    [ExtensionAttribute]
internal static AssemblyIdentity ReadAssemblyIdentityOrThrow(MetadataReader reader);
    [ExtensionAttribute]
internal static ImmutableArray`1<AssemblyIdentity> GetReferencedAssembliesOrThrow(MetadataReader reader);
    [ExtensionAttribute]
internal static Guid GetModuleVersionIdOrThrow(MetadataReader reader);
    [ExtensionAttribute]
private static AssemblyIdentity CreateAssemblyIdentityOrThrow(MetadataReader reader, Version version, AssemblyFlags flags, BlobHandle publicKey, StringHandle name, StringHandle culture, bool isReference);
    [ExtensionAttribute]
internal static bool DeclaresTheObjectClass(MetadataReader reader);
    [ExtensionAttribute]
private static bool IsTheObjectClass(MetadataReader reader, TypeDefinition typeDef);
    [ExtensionAttribute]
internal static bool DeclaresType(MetadataReader reader, Func`3<MetadataReader, TypeDefinition, bool> predicate);
    [ExtensionAttribute]
internal static bool IsPublicNonInterfaceType(MetadataReader reader, TypeDefinition typeDef, string namespaceName, string typeName);
}
public abstract class Microsoft.CodeAnalysis.MetadataReference : object {
    [CompilerGeneratedAttribute]
private MetadataReferenceProperties <Properties>k__BackingField;
    public MetadataReferenceProperties Properties { get; }
    public string Display { get; }
    internal bool IsUnresolved { get; }
    protected MetadataReference(MetadataReferenceProperties properties);
    [CompilerGeneratedAttribute]
public MetadataReferenceProperties get_Properties();
    public virtual string get_Display();
    internal virtual bool get_IsUnresolved();
    public MetadataReference WithAliases(IEnumerable`1<string> aliases);
    public MetadataReference WithEmbedInteropTypes(bool value);
    public MetadataReference WithAliases(ImmutableArray`1<string> aliases);
    public MetadataReference WithProperties(MetadataReferenceProperties properties);
    internal abstract virtual MetadataReference WithPropertiesImplReturningMetadataReference(MetadataReferenceProperties properties);
    public static PortableExecutableReference CreateFromImage(ImmutableArray`1<byte> peImage, MetadataReferenceProperties properties, DocumentationProvider documentation, string filePath);
    public static PortableExecutableReference CreateFromImage(IEnumerable`1<byte> peImage, MetadataReferenceProperties properties, DocumentationProvider documentation, string filePath);
    public static PortableExecutableReference CreateFromStream(Stream peStream, MetadataReferenceProperties properties, DocumentationProvider documentation, string filePath);
    public static PortableExecutableReference CreateFromFile(string path, MetadataReferenceProperties properties, DocumentationProvider documentation);
    [ObsoleteAttribute("Use CreateFromFile(assembly.Location) instead", "True")]
[EditorBrowsableAttribute("1")]
public static MetadataReference CreateFromAssembly(Assembly assembly);
    internal static MetadataReference CreateFromAssemblyInternal(Assembly assembly);
    [ObsoleteAttribute("Use CreateFromFile(assembly.Location) instead", "True")]
[EditorBrowsableAttribute("1")]
public static MetadataReference CreateFromAssembly(Assembly assembly, MetadataReferenceProperties properties, DocumentationProvider documentation);
    internal static PortableExecutableReference CreateFromAssemblyInternal(Assembly assembly, MetadataReferenceProperties properties, DocumentationProvider documentation);
    internal static bool HasMetadata(Assembly assembly);
}
public class Microsoft.CodeAnalysis.MetadataReferenceProperties : ValueType {
    private MetadataImageKind _kind;
    private ImmutableArray`1<string> _aliases;
    private bool _embedInteropTypes;
    [CompilerGeneratedAttribute]
private bool <HasRecursiveAliases>k__BackingField;
    public static MetadataReferenceProperties Module { get; }
    public static MetadataReferenceProperties Assembly { get; }
    public MetadataImageKind Kind { get; }
    public static string GlobalAlias { get; }
    public ImmutableArray`1<string> Aliases { get; }
    public bool EmbedInteropTypes { get; }
    internal bool HasRecursiveAliases { get; private set; }
    public MetadataReferenceProperties(MetadataImageKind kind, ImmutableArray`1<string> aliases, bool embedInteropTypes);
    internal MetadataReferenceProperties(MetadataImageKind kind, ImmutableArray`1<string> aliases, bool embedInteropTypes, bool hasRecursiveAliases);
    public static MetadataReferenceProperties get_Module();
    public static MetadataReferenceProperties get_Assembly();
    public MetadataReferenceProperties WithAliases(IEnumerable`1<string> aliases);
    public MetadataReferenceProperties WithAliases(ImmutableArray`1<string> aliases);
    public MetadataReferenceProperties WithEmbedInteropTypes(bool embedInteropTypes);
    internal MetadataReferenceProperties WithRecursiveAliases(bool value);
    public MetadataImageKind get_Kind();
    public static string get_GlobalAlias();
    public ImmutableArray`1<string> get_Aliases();
    public bool get_EmbedInteropTypes();
    [CompilerGeneratedAttribute]
internal bool get_HasRecursiveAliases();
    [CompilerGeneratedAttribute]
private void set_HasRecursiveAliases(bool value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MetadataReferenceProperties other);
    public virtual int GetHashCode();
    public static bool op_Equality(MetadataReferenceProperties left, MetadataReferenceProperties right);
    public static bool op_Inequality(MetadataReferenceProperties left, MetadataReferenceProperties right);
}
public abstract class Microsoft.CodeAnalysis.MetadataReferenceResolver : object {
    public bool ResolveMissingAssemblies { get; }
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual ImmutableArray`1<PortableExecutableReference> ResolveReference(string reference, string baseFilePath, MetadataReferenceProperties properties);
    public virtual bool get_ResolveMissingAssemblies();
    public virtual PortableExecutableReference ResolveMissingAssembly(MetadataReference definition, AssemblyIdentity referenceIdentity);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.MetadataTypeCodeExtensions : object {
    [ExtensionAttribute]
internal static SpecialType ToSpecialType(SignatureTypeCode typeCode);
    [ExtensionAttribute]
internal static bool HasShortFormSignatureEncoding(SpecialType type);
    [ExtensionAttribute]
internal static SerializationTypeCode ToSerializationType(SpecialType specialType);
}
internal class Microsoft.CodeAnalysis.MetadataTypeName : ValueType {
    private string _fullName;
    private string _namespaceName;
    private string _typeName;
    private string _unmangledTypeName;
    private short _inferredArity;
    private short _forcedArity;
    private bool _useCLSCompliantNameArityEncoding;
    private ImmutableArray`1<string> _namespaceSegments;
    public string FullName { get; }
    public string NamespaceName { get; }
    public string TypeName { get; }
    public string UnmangledTypeName { get; }
    public int InferredArity { get; }
    public bool IsMangled { get; }
    public bool UseCLSCompliantNameArityEncoding { get; }
    public int ForcedArity { get; }
    public ImmutableArray`1<string> NamespaceSegments { get; }
    public bool IsNull { get; }
    public static MetadataTypeName FromFullName(string fullName, bool useCLSCompliantNameArityEncoding, int forcedArity);
    public static MetadataTypeName FromNamespaceAndTypeName(string namespaceName, string typeName, bool useCLSCompliantNameArityEncoding, int forcedArity);
    public static MetadataTypeName FromTypeName(string typeName, bool useCLSCompliantNameArityEncoding, int forcedArity);
    public string get_FullName();
    public string get_NamespaceName();
    public string get_TypeName();
    public string get_UnmangledTypeName();
    public int get_InferredArity();
    public bool get_IsMangled();
    public bool get_UseCLSCompliantNameArityEncoding();
    public int get_ForcedArity();
    public ImmutableArray`1<string> get_NamespaceSegments();
    public bool get_IsNull();
    public virtual string ToString();
    public Key ToKey();
}
public enum Microsoft.CodeAnalysis.MethodKind : Enum {
    public int value__;
    public static MethodKind AnonymousFunction;
    public static MethodKind LambdaMethod;
    public static MethodKind Constructor;
    public static MethodKind Conversion;
    public static MethodKind DelegateInvoke;
    public static MethodKind Destructor;
    public static MethodKind EventAdd;
    public static MethodKind EventRaise;
    public static MethodKind EventRemove;
    public static MethodKind ExplicitInterfaceImplementation;
    public static MethodKind UserDefinedOperator;
    public static MethodKind Ordinary;
    public static MethodKind PropertyGet;
    public static MethodKind PropertySet;
    public static MethodKind ReducedExtension;
    public static MethodKind StaticConstructor;
    public static MethodKind SharedConstructor;
    public static MethodKind BuiltinOperator;
    public static MethodKind DeclareMethod;
    public static MethodKind LocalFunction;
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.ModelExtensions : object {
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSpeculativeSymbolInfo(SemanticModel semanticModel, int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    [ExtensionAttribute]
public static TypeInfo GetTypeInfo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IAliasSymbol GetAliasInfo(SemanticModel semanticModel, SyntaxNode nameSyntax, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IAliasSymbol GetSpeculativeAliasInfo(SemanticModel semanticModel, int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption);
    [ExtensionAttribute]
public static TypeInfo GetSpeculativeTypeInfo(SemanticModel semanticModel, int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    [ExtensionAttribute]
public static ISymbol GetDeclaredSymbol(SemanticModel semanticModel, SyntaxNode declaration, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetMemberGroup(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ControlFlowAnalysis AnalyzeControlFlow(SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement);
    [ExtensionAttribute]
public static ControlFlowAnalysis AnalyzeControlFlow(SemanticModel semanticModel, SyntaxNode statement);
    [ExtensionAttribute]
public static DataFlowAnalysis AnalyzeDataFlow(SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement);
    [ExtensionAttribute]
public static DataFlowAnalysis AnalyzeDataFlow(SemanticModel semanticModel, SyntaxNode statementOrExpression);
}
internal class Microsoft.CodeAnalysis.ModifierInfo`1 : ValueType {
    internal bool IsOptional;
    internal TypeSymbol Modifier;
    public ModifierInfo`1(bool isOptional, TypeSymbol modifier);
}
internal class Microsoft.CodeAnalysis.ModuleCompilationState`2 : CommonModuleCompilationState {
    private Dictionary`2<TMethodSymbol, TNamedTypeSymbol> _lazyStateMachineTypes;
    internal void SetStateMachineType(TMethodSymbol method, TNamedTypeSymbol stateMachineClass);
    internal bool TryGetStateMachineType(TMethodSymbol method, TNamedTypeSymbol& stateMachineType);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ModuleExtensions : object {
    private static string VTableGapMethodNamePrefix;
    [ExtensionAttribute]
public static bool ShouldImportNestedType(PEModule module, TypeDefinitionHandle typeDef);
    [ExtensionAttribute]
public static bool ShouldImportField(PEModule module, FieldDefinitionHandle field, MetadataImportOptions importOptions);
    public static bool ShouldImportField(FieldAttributes flags, MetadataImportOptions importOptions);
    [ExtensionAttribute]
public static bool ShouldImportMethod(PEModule module, MethodDefinitionHandle methodDef, MetadataImportOptions importOptions);
    public static int GetVTableGapSize(string emittedMethodName);
    public static string GetVTableGapName(int sequenceNumber, int countOfSlots);
}
public class Microsoft.CodeAnalysis.ModuleMetadata : Metadata {
    private bool _isDisposed;
    private PEModule _module;
    public bool IsDisposed { get; }
    internal PEModule Module { get; }
    public string Name { get; }
    public MetadataImageKind Kind { get; }
    internal MetadataReader MetadataReader { get; }
    private ModuleMetadata(PEReader peReader);
    private ModuleMetadata(IntPtr metadata, int size, bool includeEmbeddedInteropTypes, bool ignoreAssemblyRefs);
    private ModuleMetadata(ModuleMetadata metadata);
    public static ModuleMetadata CreateFromMetadata(IntPtr metadata, int size);
    internal static ModuleMetadata CreateFromMetadata(IntPtr metadata, int size, bool includeEmbeddedInteropTypes, bool ignoreAssemblyRefs);
    public static ModuleMetadata CreateFromImage(IntPtr peImage, int size);
    public static ModuleMetadata CreateFromImage(IEnumerable`1<byte> peImage);
    public static ModuleMetadata CreateFromImage(ImmutableArray`1<byte> peImage);
    public static ModuleMetadata CreateFromStream(Stream peStream, bool leaveOpen);
    public static ModuleMetadata CreateFromStream(Stream peStream, PEStreamOptions options);
    public static ModuleMetadata CreateFromFile(string path);
    internal ModuleMetadata Copy();
    protected virtual Metadata CommonCopy();
    public virtual void Dispose();
    public bool get_IsDisposed();
    internal PEModule get_Module();
    public string get_Name();
    public Guid GetModuleVersionId();
    public virtual MetadataImageKind get_Kind();
    public ImmutableArray`1<string> GetModuleNames();
    public MetadataReader GetMetadataReader();
    internal MetadataReader get_MetadataReader();
    public PortableExecutableReference GetReference(DocumentationProvider documentation, string filePath, string display);
}
internal class Microsoft.CodeAnalysis.ModuleReferences`1 : object {
    public ImmutableArray`1<AssemblyIdentity> Identities;
    public ImmutableArray`1<TAssemblySymbol> Symbols;
    public ImmutableArray`1<UnifiedAssembly`1<TAssemblySymbol>> UnifiedAssemblies;
    public ModuleReferences`1(ImmutableArray`1<AssemblyIdentity> identities, ImmutableArray`1<TAssemblySymbol> symbols, ImmutableArray`1<UnifiedAssembly`1<TAssemblySymbol>> unifiedAssemblies);
}
public enum Microsoft.CodeAnalysis.NamespaceKind : Enum {
    public int value__;
    public static NamespaceKind Module;
    public static NamespaceKind Assembly;
    public static NamespaceKind Compilation;
}
internal class Microsoft.CodeAnalysis.NoLocation : Location {
    public static Location Singleton;
    public LocationKind Kind { get; }
    private static NoLocation();
    public virtual LocationKind get_Kind();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ObjectDisplayExtensions : object {
    [ExtensionAttribute]
internal static bool IncludesOption(ObjectDisplayOptions options, ObjectDisplayOptions flag);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.ObjectDisplayOptions : Enum {
    public int value__;
    public static ObjectDisplayOptions None;
    public static ObjectDisplayOptions IncludeCodePoints;
    public static ObjectDisplayOptions IncludeTypeSuffix;
    public static ObjectDisplayOptions UseHexadecimalNumbers;
    public static ObjectDisplayOptions UseQuotes;
    public static ObjectDisplayOptions EscapeNonPrintableCharacters;
}
internal class Microsoft.CodeAnalysis.ObsoleteAttributeData : object {
    public static ObsoleteAttributeData Uninitialized;
    public static ObsoleteAttributeData Experimental;
    public ObsoleteAttributeKind Kind;
    public bool IsError;
    public string Message;
    internal bool IsUninitialized { get; }
    public ObsoleteAttributeData(ObsoleteAttributeKind kind, string message, bool isError);
    private static ObsoleteAttributeData();
    internal bool get_IsUninitialized();
}
internal enum Microsoft.CodeAnalysis.ObsoleteAttributeKind : Enum {
    public int value__;
    public static ObsoleteAttributeKind None;
    public static ObsoleteAttributeKind Uninitialized;
    public static ObsoleteAttributeKind Obsolete;
    public static ObsoleteAttributeKind Deprecated;
    public static ObsoleteAttributeKind Experimental;
}
internal abstract class Microsoft.CodeAnalysis.Operation : object {
    private static IOperation s_unset;
    private SemanticModel _owningSemanticModelOpt;
    private IOperation _parentDoNotAccessDirectly;
    [CompilerGeneratedAttribute]
private bool <IsImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <Syntax>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Optional`1<object> <ConstantValue>k__BackingField;
    private static ObjectPool`1<Queue`1<IOperation>> s_queuePool;
    public IOperation Parent { get; }
    public bool IsImplicit { get; }
    public OperationKind Kind { get; }
    public SyntaxNode Syntax { get; }
    public ITypeSymbol Type { get; }
    public string Language { get; }
    public Optional`1<object> ConstantValue { get; }
    public IEnumerable`1<IOperation> Children { get; }
    private SemanticModel Microsoft.CodeAnalysis.IOperation.SemanticModel { get; }
    internal SemanticModel OwningSemanticModel { get; }
    protected Operation(OperationKind kind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    private static Operation();
    public sealed virtual IOperation get_Parent();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsImplicit();
    [CompilerGeneratedAttribute]
public sealed virtual OperationKind get_Kind();
    [CompilerGeneratedAttribute]
public sealed virtual SyntaxNode get_Syntax();
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    public sealed virtual string get_Language();
    [CompilerGeneratedAttribute]
public sealed virtual Optional`1<object> get_ConstantValue();
    public abstract virtual IEnumerable`1<IOperation> get_Children();
    private sealed virtual override SemanticModel Microsoft.CodeAnalysis.IOperation.get_SemanticModel();
    internal SemanticModel get_OwningSemanticModel();
    public abstract virtual void Accept(OperationVisitor visitor);
    public abstract virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    protected void SetParentOperation(IOperation parent);
    public static IOperation CreateOperationNone(SemanticModel semanticModel, SyntaxNode node, Optional`1<object> constantValue, Func`1<ImmutableArray`1<IOperation>> getChildren, bool isImplicit);
    public static IOperation CreateOperationNone(SemanticModel semanticModel, SyntaxNode node, Optional`1<object> constantValue, ImmutableArray`1<IOperation> children, bool isImplicit);
    public static T SetParentOperation(T operation, IOperation parent);
    public static ImmutableArray`1<T> SetParentOperation(ImmutableArray`1<T> operations, IOperation parent);
    private IOperation WalkDownOperationToFindParent(HashSet`1<IOperation> operationAlreadyProcessed, IOperation root);
    internal IOperation SearchParentOperation();
    [CompilerGeneratedAttribute]
internal static void <WalkDownOperationToFindParent>g__EnqueueChildOperations|40_0(Queue`1<IOperation> queue, IOperation parent);
}
public enum Microsoft.CodeAnalysis.OperationKind : Enum {
    public int value__;
    public static OperationKind None;
    public static OperationKind Invalid;
    public static OperationKind Block;
    public static OperationKind VariableDeclarationGroup;
    public static OperationKind Switch;
    public static OperationKind Loop;
    public static OperationKind Labeled;
    public static OperationKind Branch;
    public static OperationKind Empty;
    public static OperationKind Return;
    public static OperationKind YieldBreak;
    public static OperationKind Lock;
    public static OperationKind Try;
    public static OperationKind Using;
    public static OperationKind YieldReturn;
    public static OperationKind ExpressionStatement;
    public static OperationKind LocalFunction;
    public static OperationKind Stop;
    public static OperationKind End;
    public static OperationKind RaiseEvent;
    public static OperationKind Literal;
    public static OperationKind Conversion;
    public static OperationKind Invocation;
    public static OperationKind ArrayElementReference;
    public static OperationKind LocalReference;
    public static OperationKind ParameterReference;
    public static OperationKind FieldReference;
    public static OperationKind MethodReference;
    public static OperationKind PropertyReference;
    public static OperationKind EventReference;
    public static OperationKind UnaryOperator;
    public static OperationKind BinaryOperator;
    public static OperationKind Conditional;
    public static OperationKind Coalesce;
    public static OperationKind AnonymousFunction;
    public static OperationKind ObjectCreation;
    public static OperationKind TypeParameterObjectCreation;
    public static OperationKind ArrayCreation;
    public static OperationKind InstanceReference;
    public static OperationKind IsType;
    public static OperationKind Await;
    public static OperationKind SimpleAssignment;
    public static OperationKind CompoundAssignment;
    public static OperationKind Parenthesized;
    public static OperationKind EventAssignment;
    public static OperationKind ConditionalAccess;
    public static OperationKind ConditionalAccessInstance;
    public static OperationKind InterpolatedString;
    public static OperationKind AnonymousObjectCreation;
    public static OperationKind ObjectOrCollectionInitializer;
    public static OperationKind MemberInitializer;
    [ObsoleteAttribute("ICollectionElementInitializerOperation has been replaced with IInvocationOperation and IDynamicInvocationOperation", "True")]
public static OperationKind CollectionElementInitializer;
    public static OperationKind NameOf;
    public static OperationKind Tuple;
    public static OperationKind DynamicObjectCreation;
    public static OperationKind DynamicMemberReference;
    public static OperationKind DynamicInvocation;
    public static OperationKind DynamicIndexerAccess;
    public static OperationKind TranslatedQuery;
    public static OperationKind DelegateCreation;
    public static OperationKind DefaultValue;
    public static OperationKind TypeOf;
    public static OperationKind SizeOf;
    public static OperationKind AddressOf;
    public static OperationKind IsPattern;
    public static OperationKind Increment;
    public static OperationKind Throw;
    public static OperationKind Decrement;
    public static OperationKind DeconstructionAssignment;
    public static OperationKind DeclarationExpression;
    public static OperationKind OmittedArgument;
    public static OperationKind FieldInitializer;
    public static OperationKind VariableInitializer;
    public static OperationKind PropertyInitializer;
    public static OperationKind ParameterInitializer;
    public static OperationKind ArrayInitializer;
    public static OperationKind VariableDeclarator;
    public static OperationKind VariableDeclaration;
    public static OperationKind Argument;
    public static OperationKind CatchClause;
    public static OperationKind SwitchCase;
    public static OperationKind CaseClause;
    public static OperationKind InterpolatedStringText;
    public static OperationKind Interpolation;
    public static OperationKind ConstantPattern;
    public static OperationKind DeclarationPattern;
    public static OperationKind TupleBinaryOperator;
    public static OperationKind MethodBodyOperation;
    public static OperationKind ConstructorBodyOperation;
    public static OperationKind Discard;
    public static OperationKind FlowCapture;
    public static OperationKind FlowCaptureReference;
    public static OperationKind IsNull;
    public static OperationKind CaughtException;
    public static OperationKind StaticLocalInitializationSemaphore;
    public static OperationKind FlowAnonymousFunction;
}
internal class Microsoft.CodeAnalysis.Operations.AddressOfExpression : BaseAddressOfExpression {
    [CompilerGeneratedAttribute]
private IOperation <Reference>k__BackingField;
    public IOperation Reference { get; }
    public AddressOfExpression(IOperation reference, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Reference();
}
internal class Microsoft.CodeAnalysis.Operations.AggregateQueryOperation : BaseAggregateQueryOperation {
    [CompilerGeneratedAttribute]
private IOperation <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Aggregation>k__BackingField;
    public IOperation Group { get; }
    public IOperation Aggregation { get; }
    public AggregateQueryOperation(IOperation group, IOperation aggregation, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Group();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Aggregation();
}
internal class Microsoft.CodeAnalysis.Operations.AnonymousFunctionExpression : BaseAnonymousFunctionExpression {
    [CompilerGeneratedAttribute]
private IBlockOperation <Body>k__BackingField;
    public IBlockOperation Body { get; }
    public AnonymousFunctionExpression(IMethodSymbol symbol, IBlockOperation body, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IBlockOperation get_Body();
}
internal class Microsoft.CodeAnalysis.Operations.AnonymousObjectCreationExpression : BaseAnonymousObjectCreationExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <Initializers>k__BackingField;
    public ImmutableArray`1<IOperation> Initializers { get; }
    public AnonymousObjectCreationExpression(ImmutableArray`1<IOperation> initializers, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IOperation> get_Initializers();
}
public enum Microsoft.CodeAnalysis.Operations.ArgumentKind : Enum {
    public int value__;
    public static ArgumentKind None;
    public static ArgumentKind Explicit;
    public static ArgumentKind ParamArray;
    public static ArgumentKind DefaultValue;
}
internal class Microsoft.CodeAnalysis.Operations.ArgumentOperation : BaseArgument {
    [CompilerGeneratedAttribute]
private IOperation <Value>k__BackingField;
    public IOperation Value { get; }
    public ArgumentOperation(IOperation value, ArgumentKind argumentKind, IParameterSymbol parameter, IConvertibleConversion inConversionOpt, IConvertibleConversion outConversionOpt, SemanticModel semanticModel, SyntaxNode syntax, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.ArrayCreationExpression : BaseArrayCreationExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <DimensionSizes>k__BackingField;
    [CompilerGeneratedAttribute]
private IArrayInitializerOperation <Initializer>k__BackingField;
    public ImmutableArray`1<IOperation> DimensionSizes { get; }
    public IArrayInitializerOperation Initializer { get; }
    public ArrayCreationExpression(ImmutableArray`1<IOperation> dimensionSizes, IArrayInitializerOperation initializer, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IOperation> get_DimensionSizes();
    [CompilerGeneratedAttribute]
public virtual IArrayInitializerOperation get_Initializer();
}
internal class Microsoft.CodeAnalysis.Operations.ArrayElementReferenceExpression : BaseArrayElementReferenceExpression {
    [CompilerGeneratedAttribute]
private IOperation <ArrayReference>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <Indices>k__BackingField;
    public IOperation ArrayReference { get; }
    public ImmutableArray`1<IOperation> Indices { get; }
    public ArrayElementReferenceExpression(IOperation arrayReference, ImmutableArray`1<IOperation> indices, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_ArrayReference();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IOperation> get_Indices();
}
internal class Microsoft.CodeAnalysis.Operations.ArrayInitializer : BaseArrayInitializer {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <ElementValues>k__BackingField;
    public ImmutableArray`1<IOperation> ElementValues { get; }
    public ArrayInitializer(ImmutableArray`1<IOperation> elementValues, SemanticModel semanticModel, SyntaxNode syntax, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IOperation> get_ElementValues();
}
internal abstract class Microsoft.CodeAnalysis.Operations.AssignmentExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Target { get; }
    public IOperation Value { get; }
    protected AssignmentExpression(OperationKind kind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.AssignmentExpression/<get_Children>d__2")]
public sealed virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Target();
    public abstract virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.AwaitExpression : BaseAwaitExpression {
    [CompilerGeneratedAttribute]
private IOperation <Operation>k__BackingField;
    public IOperation Operation { get; }
    public AwaitExpression(IOperation operation, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Operation();
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseAddressOfExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Reference { get; }
    protected BaseAddressOfExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseAddressOfExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Reference();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseAggregateQueryOperation : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Group { get; }
    public IOperation Aggregation { get; }
    protected BaseAggregateQueryOperation(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseAggregateQueryOperation/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Group();
    public abstract virtual IOperation get_Aggregation();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseAnonymousFunctionExpression : Operation {
    [CompilerGeneratedAttribute]
private IMethodSymbol <Symbol>k__BackingField;
    public IMethodSymbol Symbol { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IBlockOperation Body { get; }
    protected BaseAnonymousFunctionExpression(IMethodSymbol symbol, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_Symbol();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseAnonymousFunctionExpression/<get_Children>d__5")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IBlockOperation get_Body();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseAnonymousObjectCreationExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public ImmutableArray`1<IOperation> Initializers { get; }
    protected BaseAnonymousObjectCreationExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseAnonymousObjectCreationExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual ImmutableArray`1<IOperation> get_Initializers();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseArgument : Operation {
    [CompilerGeneratedAttribute]
private ArgumentKind <ArgumentKind>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameterSymbol <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private IConvertibleConversion <InConversionConvertibleOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private IConvertibleConversion <OutConversionConvertibleOpt>k__BackingField;
    public ArgumentKind ArgumentKind { get; }
    public IParameterSymbol Parameter { get; }
    internal IConvertibleConversion InConversionConvertibleOpt { get; }
    internal IConvertibleConversion OutConversionConvertibleOpt { get; }
    public CommonConversion InConversion { get; }
    public CommonConversion OutConversion { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Value { get; }
    protected BaseArgument(ArgumentKind argumentKind, IParameterSymbol parameter, IConvertibleConversion inConversionOpt, IConvertibleConversion outConversionOpt, SemanticModel semanticModel, SyntaxNode syntax, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ArgumentKind get_ArgumentKind();
    [CompilerGeneratedAttribute]
public sealed virtual IParameterSymbol get_Parameter();
    [CompilerGeneratedAttribute]
internal IConvertibleConversion get_InConversionConvertibleOpt();
    [CompilerGeneratedAttribute]
internal IConvertibleConversion get_OutConversionConvertibleOpt();
    public sealed virtual CommonConversion get_InConversion();
    public sealed virtual CommonConversion get_OutConversion();
    private static CommonConversion Identity();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseArgument/<get_Children>d__19")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Value();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseArrayCreationExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public ImmutableArray`1<IOperation> DimensionSizes { get; }
    public IArrayInitializerOperation Initializer { get; }
    protected BaseArrayCreationExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseArrayCreationExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual ImmutableArray`1<IOperation> get_DimensionSizes();
    public abstract virtual IArrayInitializerOperation get_Initializer();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseArrayElementReferenceExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation ArrayReference { get; }
    public ImmutableArray`1<IOperation> Indices { get; }
    protected BaseArrayElementReferenceExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseArrayElementReferenceExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_ArrayReference();
    public abstract virtual ImmutableArray`1<IOperation> get_Indices();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseArrayInitializer : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public ImmutableArray`1<IOperation> ElementValues { get; }
    protected BaseArrayInitializer(SemanticModel semanticModel, SyntaxNode syntax, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseArrayInitializer/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual ImmutableArray`1<IOperation> get_ElementValues();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseAwaitExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Operation { get; }
    protected BaseAwaitExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseAwaitExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Operation();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseBinaryOperatorExpression : Operation {
    [CompilerGeneratedAttribute]
private BinaryOperatorKind <OperatorKind>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <OperatorMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <UnaryOperatorMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLifted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsChecked>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompareText>k__BackingField;
    public BinaryOperatorKind OperatorKind { get; }
    public IMethodSymbol OperatorMethod { get; }
    public IMethodSymbol UnaryOperatorMethod { get; }
    public bool IsLifted { get; }
    public bool IsChecked { get; }
    public bool IsCompareText { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation LeftOperand { get; }
    public IOperation RightOperand { get; }
    protected BaseBinaryOperatorExpression(BinaryOperatorKind operatorKind, bool isLifted, bool isChecked, bool isCompareText, IMethodSymbol operatorMethod, IMethodSymbol unaryOperatorMethod, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual BinaryOperatorKind get_OperatorKind();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_OperatorMethod();
    [CompilerGeneratedAttribute]
public IMethodSymbol get_UnaryOperatorMethod();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLifted();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsChecked();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCompareText();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseBinaryOperatorExpression/<get_Children>d__20")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_LeftOperand();
    public abstract virtual IOperation get_RightOperand();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseBlockStatement : Operation {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ILocalSymbol> <Locals>k__BackingField;
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public ImmutableArray`1<IOperation> Operations { get; }
    protected BaseBlockStatement(ImmutableArray`1<ILocalSymbol> locals, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ILocalSymbol> get_Locals();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseBlockStatement/<get_Children>d__5")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual ImmutableArray`1<IOperation> get_Operations();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseCatchClause : Operation {
    [CompilerGeneratedAttribute]
private ITypeSymbol <ExceptionType>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ILocalSymbol> <Locals>k__BackingField;
    public ITypeSymbol ExceptionType { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation ExceptionDeclarationOrExpression { get; }
    public IOperation Filter { get; }
    public IBlockOperation Handler { get; }
    protected BaseCatchClause(ITypeSymbol exceptionType, ImmutableArray`1<ILocalSymbol> locals, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_ExceptionType();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ILocalSymbol> get_Locals();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseCatchClause/<get_Children>d__8")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_ExceptionDeclarationOrExpression();
    public abstract virtual IOperation get_Filter();
    public abstract virtual IBlockOperation get_Handler();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseCoalesceExpression : Operation {
    [CompilerGeneratedAttribute]
private IConvertibleConversion <ConvertibleValueConversion>k__BackingField;
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Value { get; }
    public IOperation WhenNull { get; }
    internal IConvertibleConversion ConvertibleValueConversion { get; }
    public CommonConversion ValueConversion { get; }
    protected BaseCoalesceExpression(IConvertibleConversion convertibleValueConversion, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseCoalesceExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Value();
    public abstract virtual IOperation get_WhenNull();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
internal IConvertibleConversion get_ConvertibleValueConversion();
    public sealed virtual CommonConversion get_ValueConversion();
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseCompoundAssignmentExpression : AssignmentExpression {
    [CompilerGeneratedAttribute]
private BinaryOperatorKind <OperatorKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLifted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsChecked>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <OperatorMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IConvertibleConversion <InConversionConvertible>k__BackingField;
    [CompilerGeneratedAttribute]
private IConvertibleConversion <OutConversionConvertible>k__BackingField;
    public BinaryOperatorKind OperatorKind { get; }
    public bool IsLifted { get; }
    public bool IsChecked { get; }
    public IMethodSymbol OperatorMethod { get; }
    internal IConvertibleConversion InConversionConvertible { get; }
    internal IConvertibleConversion OutConversionConvertible { get; }
    public CommonConversion InConversion { get; }
    public CommonConversion OutConversion { get; }
    protected BaseCompoundAssignmentExpression(IConvertibleConversion inConversionConvertible, IConvertibleConversion outConversionConvertible, BinaryOperatorKind operatorKind, bool isLifted, bool isChecked, IMethodSymbol operatorMethod, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual BinaryOperatorKind get_OperatorKind();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLifted();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsChecked();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_OperatorMethod();
    [CompilerGeneratedAttribute]
internal IConvertibleConversion get_InConversionConvertible();
    [CompilerGeneratedAttribute]
internal IConvertibleConversion get_OutConversionConvertible();
    public sealed virtual CommonConversion get_InConversion();
    public sealed virtual CommonConversion get_OutConversion();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseConditionalAccessExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Operation { get; }
    public IOperation WhenNotNull { get; }
    protected BaseConditionalAccessExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseConditionalAccessExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Operation();
    public abstract virtual IOperation get_WhenNotNull();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseConditionalOperation : Operation {
    [CompilerGeneratedAttribute]
private bool <IsRef>k__BackingField;
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Condition { get; }
    public IOperation WhenTrue { get; }
    public IOperation WhenFalse { get; }
    public bool IsRef { get; }
    protected BaseConditionalOperation(bool isRef, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseConditionalOperation/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Condition();
    public abstract virtual IOperation get_WhenTrue();
    public abstract virtual IOperation get_WhenFalse();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRef();
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseConstantPattern : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Value { get; }
    protected BaseConstantPattern(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseConstantPattern/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Value();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseConstructorBodyOperation : BaseMethodBodyBaseOperation {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ILocalSymbol> <Locals>k__BackingField;
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Initializer { get; }
    public IEnumerable`1<IOperation> Children { get; }
    protected BaseConstructorBodyOperation(ImmutableArray`1<ILocalSymbol> locals, SemanticModel semanticModel, SyntaxNode syntax);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ILocalSymbol> get_Locals();
    public abstract virtual IOperation get_Initializer();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseConstructorBodyOperation/<get_Children>d__7")]
public sealed virtual IEnumerable`1<IOperation> get_Children();
    public sealed virtual void Accept(OperationVisitor visitor);
    public sealed virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseConversionExpression : Operation {
    [CompilerGeneratedAttribute]
private IConvertibleConversion <ConvertibleConversion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTryCast>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsChecked>k__BackingField;
    internal IConvertibleConversion ConvertibleConversion { get; }
    public CommonConversion Conversion { get; }
    public bool IsTryCast { get; }
    public bool IsChecked { get; }
    public IMethodSymbol OperatorMethod { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Operand { get; }
    protected BaseConversionExpression(IConvertibleConversion convertibleConversion, bool isTryCast, bool isChecked, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
internal IConvertibleConversion get_ConvertibleConversion();
    public sealed virtual CommonConversion get_Conversion();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsTryCast();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsChecked();
    public sealed virtual IMethodSymbol get_OperatorMethod();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseConversionExpression/<get_Children>d__15")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Operand();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseDeclarationExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Expression { get; }
    public BaseDeclarationExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseDeclarationExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Expression();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseDeconstructionAssignmentExpression : AssignmentExpression {
    public BaseDeconstructionAssignmentExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseDelegateCreationExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Target { get; }
    public BaseDelegateCreationExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseDelegateCreationExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Target();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseDynamicIndexerAccessExpression : HasDynamicArgumentsExpression {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Operation { get; }
    public BaseDynamicIndexerAccessExpression(ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> argumentRefKinds, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseDynamicIndexerAccessExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Operation();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseDynamicInvocationExpression : HasDynamicArgumentsExpression {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Operation { get; }
    public BaseDynamicInvocationExpression(ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> argumentRefKinds, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseDynamicInvocationExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Operation();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseDynamicMemberReferenceExpression : Operation {
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ITypeSymbol> <TypeArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <ContainingType>k__BackingField;
    public string MemberName { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ITypeSymbol ContainingType { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Instance { get; }
    protected BaseDynamicMemberReferenceExpression(string memberName, ImmutableArray`1<ITypeSymbol> typeArguments, ITypeSymbol containingType, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual string get_MemberName();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_ContainingType();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseDynamicMemberReferenceExpression/<get_Children>d__11")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Instance();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseDynamicObjectCreationExpression : HasDynamicArgumentsExpression {
    public IEnumerable`1<IOperation> Children { get; }
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public BaseDynamicObjectCreationExpression(ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> argumentRefKinds, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseDynamicObjectCreationExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IObjectOrCollectionInitializerOperation get_Initializer();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseEventAssignmentOperation : Operation {
    [CompilerGeneratedAttribute]
private bool <Adds>k__BackingField;
    public bool Adds { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation EventReference { get; }
    public IOperation HandlerValue { get; }
    protected BaseEventAssignmentOperation(bool adds, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_Adds();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseEventAssignmentOperation/<get_Children>d__5")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_EventReference();
    public abstract virtual IOperation get_HandlerValue();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseEventReferenceExpression : MemberReferenceExpression {
    public IEventSymbol Event { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public BaseEventReferenceExpression(IEventSymbol event, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public sealed virtual IEventSymbol get_Event();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseEventReferenceExpression/<get_Children>d__4")]
public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseExpressionStatement : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Operation { get; }
    protected BaseExpressionStatement(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseExpressionStatement/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Operation();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseFieldInitializer : SymbolInitializer {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ILocalSymbol> <Locals>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IFieldSymbol> <InitializedFields>k__BackingField;
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ImmutableArray`1<IFieldSymbol> InitializedFields { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public BaseFieldInitializer(ImmutableArray`1<ILocalSymbol> locals, ImmutableArray`1<IFieldSymbol> initializedFields, OperationKind kind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ILocalSymbol> get_Locals();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IFieldSymbol> get_InitializedFields();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseFieldInitializer/<get_Children>d__8")]
public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseFieldReferenceExpression : MemberReferenceExpression {
    [CompilerGeneratedAttribute]
private bool <IsDeclaration>k__BackingField;
    public IFieldSymbol Field { get; }
    public bool IsDeclaration { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public BaseFieldReferenceExpression(IFieldSymbol field, bool isDeclaration, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public sealed virtual IFieldSymbol get_Field();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDeclaration();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseFieldReferenceExpression/<get_Children>d__7")]
public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseFixedStatement : Operation {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ILocalSymbol> <Locals>k__BackingField;
    public IEnumerable`1<IOperation> Children { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IVariableDeclarationGroupOperation Variables { get; }
    public IOperation Body { get; }
    protected BaseFixedStatement(ImmutableArray`1<ILocalSymbol> locals, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseFixedStatement/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ILocalSymbol> get_Locals();
    public abstract virtual IVariableDeclarationGroupOperation get_Variables();
    public abstract virtual IOperation get_Body();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseForEachLoopStatement : LoopStatement {
    [CompilerGeneratedAttribute]
private ForEachLoopOperationInfo <Info>k__BackingField;
    public IEnumerable`1<IOperation> Children { get; }
    public ForEachLoopOperationInfo Info { get; }
    public IOperation LoopControlVariable { get; }
    public IOperation Collection { get; }
    public ImmutableArray`1<IOperation> NextVariables { get; }
    public BaseForEachLoopStatement(ImmutableArray`1<ILocalSymbol> locals, ILabelSymbol continueLabel, ILabelSymbol exitLabel, ForEachLoopOperationInfo info, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseForEachLoopStatement/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    [CompilerGeneratedAttribute]
public ForEachLoopOperationInfo get_Info();
    public abstract virtual IOperation get_LoopControlVariable();
    public abstract virtual IOperation get_Collection();
    public abstract virtual ImmutableArray`1<IOperation> get_NextVariables();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseForLoopStatement : LoopStatement {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ILocalSymbol> <ConditionLocals>k__BackingField;
    public ImmutableArray`1<ILocalSymbol> ConditionLocals { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public ImmutableArray`1<IOperation> Before { get; }
    public IOperation Condition { get; }
    public ImmutableArray`1<IOperation> AtLoopBottom { get; }
    public BaseForLoopStatement(ImmutableArray`1<ILocalSymbol> locals, ImmutableArray`1<ILocalSymbol> conditionLocals, ILabelSymbol continueLabel, ILabelSymbol exitLabel, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ILocalSymbol> get_ConditionLocals();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseForLoopStatement/<get_Children>d__5")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual ImmutableArray`1<IOperation> get_Before();
    public abstract virtual IOperation get_Condition();
    public abstract virtual ImmutableArray`1<IOperation> get_AtLoopBottom();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseForToLoopStatement : LoopStatement {
    [CompilerGeneratedAttribute]
private bool <IsChecked>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`2<ILocalSymbol, ForToLoopOperationUserDefinedInfo> <Info>k__BackingField;
    public bool IsChecked { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<ILocalSymbol, ForToLoopOperationUserDefinedInfo> Info { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation LoopControlVariable { get; }
    public IOperation InitialValue { get; }
    public IOperation LimitValue { get; }
    public IOperation StepValue { get; }
    public ImmutableArray`1<IOperation> NextVariables { get; }
    public BaseForToLoopStatement(ImmutableArray`1<ILocalSymbol> locals, bool isChecked, ValueTuple`2<ILocalSymbol, ForToLoopOperationUserDefinedInfo> info, ILabelSymbol continueLabel, ILabelSymbol exitLabel, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsChecked();
    [CompilerGeneratedAttribute]
public ValueTuple`2<ILocalSymbol, ForToLoopOperationUserDefinedInfo> get_Info();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseForToLoopStatement/<get_Children>d__8")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_LoopControlVariable();
    public abstract virtual IOperation get_InitialValue();
    public abstract virtual IOperation get_LimitValue();
    public abstract virtual IOperation get_StepValue();
    public abstract virtual ImmutableArray`1<IOperation> get_NextVariables();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseIncrementExpression : Operation {
    [CompilerGeneratedAttribute]
private bool <IsPostfix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLifted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsChecked>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <OperatorMethod>k__BackingField;
    public bool IsPostfix { get; }
    public bool IsLifted { get; }
    public bool IsChecked { get; }
    public IMethodSymbol OperatorMethod { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Target { get; }
    public BaseIncrementExpression(bool isDecrement, bool isPostfix, bool isLifted, bool isChecked, IMethodSymbol operatorMethod, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsPostfix();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLifted();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsChecked();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_OperatorMethod();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseIncrementExpression/<get_Children>d__14")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Target();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseInterpolatedStringExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public ImmutableArray`1<IInterpolatedStringContentOperation> Parts { get; }
    protected BaseInterpolatedStringExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseInterpolatedStringExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual ImmutableArray`1<IInterpolatedStringContentOperation> get_Parts();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseInterpolatedStringText : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Text { get; }
    protected BaseInterpolatedStringText(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseInterpolatedStringText/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Text();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseInterpolation : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Expression { get; }
    public IOperation Alignment { get; }
    public IOperation FormatString { get; }
    protected BaseInterpolation(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseInterpolation/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Expression();
    public abstract virtual IOperation get_Alignment();
    public abstract virtual IOperation get_FormatString();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseInvalidOperation : Operation {
    protected BaseInvalidOperation(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseInvocationExpression : Operation {
    [CompilerGeneratedAttribute]
private IMethodSymbol <TargetMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsVirtual>k__BackingField;
    public IMethodSymbol TargetMethod { get; }
    public bool IsVirtual { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Instance { get; }
    public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    protected BaseInvocationExpression(IMethodSymbol targetMethod, bool isVirtual, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_TargetMethod();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsVirtual();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseInvocationExpression/<get_Children>d__8")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Instance();
    public abstract virtual ImmutableArray`1<IArgumentOperation> get_Arguments();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseIsPatternExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Value { get; }
    public IPatternOperation Pattern { get; }
    protected BaseIsPatternExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseIsPatternExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Value();
    public abstract virtual IPatternOperation get_Pattern();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseIsTypeExpression : Operation {
    [CompilerGeneratedAttribute]
private ITypeSymbol <TypeOperand>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNegated>k__BackingField;
    public ITypeSymbol TypeOperand { get; }
    public bool IsNegated { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation ValueOperand { get; }
    protected BaseIsTypeExpression(ITypeSymbol typeOperand, bool isNegated, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_TypeOperand();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsNegated();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseIsTypeExpression/<get_Children>d__8")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_ValueOperand();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseLabeledStatement : Operation {
    [CompilerGeneratedAttribute]
private ILabelSymbol <Label>k__BackingField;
    public ILabelSymbol Label { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Operation { get; }
    protected BaseLabeledStatement(ILabelSymbol label, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ILabelSymbol get_Label();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseLabeledStatement/<get_Children>d__5")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Operation();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseLocalFunctionStatement : Operation {
    [CompilerGeneratedAttribute]
private IMethodSymbol <Symbol>k__BackingField;
    public IMethodSymbol Symbol { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IBlockOperation Body { get; }
    public IBlockOperation IgnoredBody { get; }
    protected BaseLocalFunctionStatement(IMethodSymbol symbol, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_Symbol();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseLocalFunctionStatement/<get_Children>d__5")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IBlockOperation get_Body();
    public abstract virtual IBlockOperation get_IgnoredBody();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseLockStatement : Operation {
    [CompilerGeneratedAttribute]
private ILocalSymbol <LockTakenSymbol>k__BackingField;
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation LockedValue { get; }
    public IOperation Body { get; }
    public ILocalSymbol LockTakenSymbol { get; }
    protected BaseLockStatement(ILocalSymbol lockTakenSymbol, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseLockStatement/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_LockedValue();
    public abstract virtual IOperation get_Body();
    [CompilerGeneratedAttribute]
public ILocalSymbol get_LockTakenSymbol();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseMemberInitializerExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation InitializedMember { get; }
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    protected BaseMemberInitializerExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseMemberInitializerExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_InitializedMember();
    public abstract virtual IObjectOrCollectionInitializerOperation get_Initializer();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseMethodBodyBaseOperation : Operation {
    public IBlockOperation BlockBody { get; }
    public IBlockOperation ExpressionBody { get; }
    public IEnumerable`1<IOperation> Children { get; }
    protected BaseMethodBodyBaseOperation(OperationKind kind, SemanticModel semanticModel, SyntaxNode syntax);
    public abstract virtual IBlockOperation get_BlockBody();
    public abstract virtual IBlockOperation get_ExpressionBody();
    public abstract virtual IEnumerable`1<IOperation> get_Children();
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseMethodBodyOperation : BaseMethodBodyBaseOperation {
    public IEnumerable`1<IOperation> Children { get; }
    protected BaseMethodBodyOperation(SemanticModel semanticModel, SyntaxNode syntax);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseMethodBodyOperation/<get_Children>d__2")]
public sealed virtual IEnumerable`1<IOperation> get_Children();
    public sealed virtual void Accept(OperationVisitor visitor);
    public sealed virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseMethodReferenceExpression : MemberReferenceExpression {
    [CompilerGeneratedAttribute]
private bool <IsVirtual>k__BackingField;
    public IMethodSymbol Method { get; }
    public bool IsVirtual { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public BaseMethodReferenceExpression(IMethodSymbol method, bool isVirtual, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public sealed virtual IMethodSymbol get_Method();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsVirtual();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseMethodReferenceExpression/<get_Children>d__7")]
public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseNameOfExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Argument { get; }
    protected BaseNameOfExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseNameOfExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Argument();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseNoPiaObjectCreationOperation : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public BaseNoPiaObjectCreationOperation(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseNoPiaObjectCreationOperation/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IObjectOrCollectionInitializerOperation get_Initializer();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseObjectCreationExpression : Operation {
    [CompilerGeneratedAttribute]
private IMethodSymbol <Constructor>k__BackingField;
    public IMethodSymbol Constructor { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    protected BaseObjectCreationExpression(IMethodSymbol constructor, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_Constructor();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseObjectCreationExpression/<get_Children>d__5")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IObjectOrCollectionInitializerOperation get_Initializer();
    public abstract virtual ImmutableArray`1<IArgumentOperation> get_Arguments();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseObjectOrCollectionInitializerExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public ImmutableArray`1<IOperation> Initializers { get; }
    protected BaseObjectOrCollectionInitializerExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseObjectOrCollectionInitializerExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual ImmutableArray`1<IOperation> get_Initializers();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseParameterInitializer : SymbolInitializer {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ILocalSymbol> <Locals>k__BackingField;
    [CompilerGeneratedAttribute]
private IParameterSymbol <Parameter>k__BackingField;
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IParameterSymbol Parameter { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public BaseParameterInitializer(ImmutableArray`1<ILocalSymbol> locals, IParameterSymbol parameter, OperationKind kind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ILocalSymbol> get_Locals();
    [CompilerGeneratedAttribute]
public sealed virtual IParameterSymbol get_Parameter();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseParameterInitializer/<get_Children>d__8")]
public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseParenthesizedExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Operand { get; }
    protected BaseParenthesizedExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseParenthesizedExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Operand();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BasePatternCaseClause : CaseClauseWithLabel {
    public IEnumerable`1<IOperation> Children { get; }
    public IPatternOperation Pattern { get; }
    public IOperation Guard { get; }
    protected BasePatternCaseClause(ILabelSymbol label, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BasePatternCaseClause/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IPatternOperation get_Pattern();
    public abstract virtual IOperation get_Guard();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BasePropertyInitializer : SymbolInitializer {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ILocalSymbol> <Locals>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IPropertySymbol> <InitializedProperties>k__BackingField;
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ImmutableArray`1<IPropertySymbol> InitializedProperties { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public BasePropertyInitializer(ImmutableArray`1<ILocalSymbol> locals, ImmutableArray`1<IPropertySymbol> initializedProperties, OperationKind kind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ILocalSymbol> get_Locals();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IPropertySymbol> get_InitializedProperties();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BasePropertyInitializer/<get_Children>d__8")]
public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BasePropertyReferenceExpression : MemberReferenceExpression {
    public IPropertySymbol Property { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    protected BasePropertyReferenceExpression(IPropertySymbol property, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public sealed virtual IPropertySymbol get_Property();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BasePropertyReferenceExpression/<get_Children>d__4")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual ImmutableArray`1<IArgumentOperation> get_Arguments();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseRaiseEventStatement : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IEventReferenceOperation EventReference { get; }
    public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    protected BaseRaiseEventStatement(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseRaiseEventStatement/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IEventReferenceOperation get_EventReference();
    public abstract virtual ImmutableArray`1<IArgumentOperation> get_Arguments();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseRangeCaseClause : CaseClause {
    public ILabelSymbol Label { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation MinimumValue { get; }
    public IOperation MaximumValue { get; }
    public BaseRangeCaseClause(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public sealed virtual ILabelSymbol get_Label();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseRangeCaseClause/<get_Children>d__4")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_MinimumValue();
    public abstract virtual IOperation get_MaximumValue();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseRelationalCaseClause : CaseClause {
    [CompilerGeneratedAttribute]
private BinaryOperatorKind <Relation>k__BackingField;
    public ILabelSymbol Label { get; }
    public BinaryOperatorKind Relation { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Value { get; }
    public BaseRelationalCaseClause(BinaryOperatorKind relation, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public sealed virtual ILabelSymbol get_Label();
    [CompilerGeneratedAttribute]
public sealed virtual BinaryOperatorKind get_Relation();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseRelationalCaseClause/<get_Children>d__7")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Value();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseReturnStatement : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation ReturnedValue { get; }
    protected BaseReturnStatement(OperationKind kind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseReturnStatement/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_ReturnedValue();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseSimpleAssignmentExpression : AssignmentExpression {
    [CompilerGeneratedAttribute]
private bool <IsRef>k__BackingField;
    public bool IsRef { get; }
    public BaseSimpleAssignmentExpression(bool isRef, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsRef();
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseSingleValueCaseClause : CaseClauseWithLabel {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Value { get; }
    public BaseSingleValueCaseClause(ILabelSymbol label, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseSingleValueCaseClause/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Value();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseSwitchCase : Operation {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ILocalSymbol> <Locals>k__BackingField;
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public ImmutableArray`1<ICaseClauseOperation> Clauses { get; }
    public ImmutableArray`1<IOperation> Body { get; }
    public IOperation Condition { get; }
    protected BaseSwitchCase(ImmutableArray`1<ILocalSymbol> locals, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ILocalSymbol> get_Locals();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseSwitchCase/<get_Children>d__5")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual ImmutableArray`1<ICaseClauseOperation> get_Clauses();
    public abstract virtual ImmutableArray`1<IOperation> get_Body();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public abstract virtual IOperation get_Condition();
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseSwitchStatement : Operation {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ILocalSymbol> <Locals>k__BackingField;
    [CompilerGeneratedAttribute]
private ILabelSymbol <ExitLabel>k__BackingField;
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public ILabelSymbol ExitLabel { get; }
    public IOperation Value { get; }
    public ImmutableArray`1<ISwitchCaseOperation> Cases { get; }
    protected BaseSwitchStatement(ImmutableArray`1<ILocalSymbol> locals, ILabelSymbol exitLabel, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ILocalSymbol> get_Locals();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseSwitchStatement/<get_Children>d__5")]
public virtual IEnumerable`1<IOperation> get_Children();
    [CompilerGeneratedAttribute]
public sealed virtual ILabelSymbol get_ExitLabel();
    public abstract virtual IOperation get_Value();
    public abstract virtual ImmutableArray`1<ISwitchCaseOperation> get_Cases();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseThrowExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Exception { get; }
    protected BaseThrowExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseThrowExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Exception();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseTranslatedQueryExpression : Operation {
    public IOperation Operation { get; }
    public IEnumerable`1<IOperation> Children { get; }
    protected BaseTranslatedQueryExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public abstract virtual IOperation get_Operation();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseTranslatedQueryExpression/<get_Children>d__4")]
public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseTryStatement : Operation {
    [CompilerGeneratedAttribute]
private ILabelSymbol <ExitLabel>k__BackingField;
    public IEnumerable`1<IOperation> Children { get; }
    public ILabelSymbol ExitLabel { get; }
    public IBlockOperation Body { get; }
    public ImmutableArray`1<ICatchClauseOperation> Catches { get; }
    public IBlockOperation Finally { get; }
    protected BaseTryStatement(ILabelSymbol exitLabel, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseTryStatement/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    [CompilerGeneratedAttribute]
public sealed virtual ILabelSymbol get_ExitLabel();
    public abstract virtual IBlockOperation get_Body();
    public abstract virtual ImmutableArray`1<ICatchClauseOperation> get_Catches();
    public abstract virtual IBlockOperation get_Finally();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseTupleBinaryOperatorExpression : Operation {
    [CompilerGeneratedAttribute]
private BinaryOperatorKind <OperatorKind>k__BackingField;
    public BinaryOperatorKind OperatorKind { get; }
    public IOperation LeftOperand { get; }
    public IOperation RightOperand { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public BaseTupleBinaryOperatorExpression(BinaryOperatorKind operatorKind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual BinaryOperatorKind get_OperatorKind();
    public abstract virtual IOperation get_LeftOperand();
    public abstract virtual IOperation get_RightOperand();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseTupleBinaryOperatorExpression/<get_Children>d__9")]
public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseTupleExpression : Operation {
    [CompilerGeneratedAttribute]
private ITypeSymbol <NaturalType>k__BackingField;
    public ITypeSymbol NaturalType { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public ImmutableArray`1<IOperation> Elements { get; }
    protected BaseTupleExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, ITypeSymbol naturalType, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_NaturalType();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseTupleExpression/<get_Children>d__5")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual ImmutableArray`1<IOperation> get_Elements();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseTypeParameterObjectCreationExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public BaseTypeParameterObjectCreationExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseTypeParameterObjectCreationExpression/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IObjectOrCollectionInitializerOperation get_Initializer();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseUnaryOperatorExpression : Operation {
    [CompilerGeneratedAttribute]
private UnaryOperatorKind <OperatorKind>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <OperatorMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLifted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsChecked>k__BackingField;
    public UnaryOperatorKind OperatorKind { get; }
    public IMethodSymbol OperatorMethod { get; }
    public bool IsLifted { get; }
    public bool IsChecked { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Operand { get; }
    protected BaseUnaryOperatorExpression(UnaryOperatorKind unaryOperationKind, bool isLifted, bool isChecked, IMethodSymbol operatorMethod, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual UnaryOperatorKind get_OperatorKind();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_OperatorMethod();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsLifted();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsChecked();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseUnaryOperatorExpression/<get_Children>d__14")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Operand();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseUsingStatement : Operation {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ILocalSymbol> <Locals>k__BackingField;
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Resources { get; }
    public IOperation Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    protected BaseUsingStatement(ImmutableArray`1<ILocalSymbol> locals, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseUsingStatement/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Resources();
    public abstract virtual IOperation get_Body();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ILocalSymbol> get_Locals();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseVariableDeclaration : Operation {
    public ImmutableArray`1<IVariableDeclaratorOperation> Declarators { get; }
    public IVariableInitializerOperation Initializer { get; }
    public IEnumerable`1<IOperation> Children { get; }
    protected BaseVariableDeclaration(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public abstract virtual ImmutableArray`1<IVariableDeclaratorOperation> get_Declarators();
    public abstract virtual IVariableInitializerOperation get_Initializer();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseVariableDeclaration/<get_Children>d__6")]
public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseVariableDeclarationGroupOperation : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public ImmutableArray`1<IVariableDeclarationOperation> Declarations { get; }
    protected BaseVariableDeclarationGroupOperation(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseVariableDeclarationGroupOperation/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual ImmutableArray`1<IVariableDeclarationOperation> get_Declarations();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseVariableDeclarator : Operation {
    [CompilerGeneratedAttribute]
private ILocalSymbol <Symbol>k__BackingField;
    public ILocalSymbol Symbol { get; }
    public IVariableInitializerOperation Initializer { get; }
    public ImmutableArray`1<IOperation> IgnoredArguments { get; }
    public IEnumerable`1<IOperation> Children { get; }
    protected BaseVariableDeclarator(ILocalSymbol symbol, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ILocalSymbol get_Symbol();
    public abstract virtual IVariableInitializerOperation get_Initializer();
    public abstract virtual ImmutableArray`1<IOperation> get_IgnoredArguments();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseVariableDeclarator/<get_Children>d__9")]
public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseVariableInitializer : SymbolInitializer {
    public IEnumerable`1<IOperation> Children { get; }
    private ImmutableArray`1<ILocalSymbol> Microsoft.CodeAnalysis.Operations.ISymbolInitializerOperation.Locals { get; }
    public BaseVariableInitializer(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseVariableInitializer/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
    private sealed virtual override ImmutableArray`1<ILocalSymbol> Microsoft.CodeAnalysis.Operations.ISymbolInitializerOperation.get_Locals();
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseWhileLoopStatement : LoopStatement {
    [CompilerGeneratedAttribute]
private bool <ConditionIsTop>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ConditionIsUntil>k__BackingField;
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Condition { get; }
    public bool ConditionIsTop { get; }
    public bool ConditionIsUntil { get; }
    public IOperation IgnoredCondition { get; }
    public BaseWhileLoopStatement(ImmutableArray`1<ILocalSymbol> locals, ILabelSymbol continueLabel, ILabelSymbol exitLabel, bool conditionIsTop, bool conditionIsUntil, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseWhileLoopStatement/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Condition();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ConditionIsTop();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ConditionIsUntil();
    public abstract virtual IOperation get_IgnoredCondition();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.BaseWithStatement : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public IOperation Body { get; }
    public IOperation Value { get; }
    protected BaseWithStatement(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.BaseWithStatement/<get_Children>d__2")]
public virtual IEnumerable`1<IOperation> get_Children();
    public abstract virtual IOperation get_Body();
    public abstract virtual IOperation get_Value();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.BinaryOperatorExpression : BaseBinaryOperatorExpression {
    [CompilerGeneratedAttribute]
private IOperation <LeftOperand>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <RightOperand>k__BackingField;
    public IOperation LeftOperand { get; }
    public IOperation RightOperand { get; }
    public BinaryOperatorExpression(BinaryOperatorKind operatorKind, IOperation leftOperand, IOperation rightOperand, bool isLifted, bool isChecked, bool isCompareText, IMethodSymbol operatorMethod, IMethodSymbol unaryOperatorMethod, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_LeftOperand();
    [CompilerGeneratedAttribute]
public virtual IOperation get_RightOperand();
}
public enum Microsoft.CodeAnalysis.Operations.BinaryOperatorKind : Enum {
    public int value__;
    public static BinaryOperatorKind None;
    public static BinaryOperatorKind Add;
    public static BinaryOperatorKind Subtract;
    public static BinaryOperatorKind Multiply;
    public static BinaryOperatorKind Divide;
    public static BinaryOperatorKind IntegerDivide;
    public static BinaryOperatorKind Remainder;
    public static BinaryOperatorKind Power;
    public static BinaryOperatorKind LeftShift;
    public static BinaryOperatorKind RightShift;
    public static BinaryOperatorKind And;
    public static BinaryOperatorKind Or;
    public static BinaryOperatorKind ExclusiveOr;
    public static BinaryOperatorKind ConditionalAnd;
    public static BinaryOperatorKind ConditionalOr;
    public static BinaryOperatorKind Concatenate;
    public static BinaryOperatorKind Equals;
    public static BinaryOperatorKind ObjectValueEquals;
    public static BinaryOperatorKind NotEquals;
    public static BinaryOperatorKind ObjectValueNotEquals;
    public static BinaryOperatorKind LessThan;
    public static BinaryOperatorKind LessThanOrEqual;
    public static BinaryOperatorKind GreaterThanOrEqual;
    public static BinaryOperatorKind GreaterThan;
    public static BinaryOperatorKind Like;
}
internal class Microsoft.CodeAnalysis.Operations.BlockStatement : BaseBlockStatement {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <Operations>k__BackingField;
    public ImmutableArray`1<IOperation> Operations { get; }
    public BlockStatement(ImmutableArray`1<IOperation> operations, ImmutableArray`1<ILocalSymbol> locals, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IOperation> get_Operations();
}
public enum Microsoft.CodeAnalysis.Operations.BranchKind : Enum {
    public int value__;
    public static BranchKind None;
    public static BranchKind Continue;
    public static BranchKind Break;
    public static BranchKind GoTo;
}
internal class Microsoft.CodeAnalysis.Operations.BranchStatement : Operation {
    [CompilerGeneratedAttribute]
private ILabelSymbol <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private BranchKind <BranchKind>k__BackingField;
    public ILabelSymbol Target { get; }
    public BranchKind BranchKind { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public BranchStatement(ILabelSymbol target, BranchKind branchKind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ILabelSymbol get_Target();
    [CompilerGeneratedAttribute]
public sealed virtual BranchKind get_BranchKind();
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal abstract class Microsoft.CodeAnalysis.Operations.CaseClause : Operation {
    [CompilerGeneratedAttribute]
private CaseKind <CaseKind>k__BackingField;
    public CaseKind CaseKind { get; }
    public ILabelSymbol Label { get; }
    protected CaseClause(CaseKind caseKind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual CaseKind get_CaseKind();
    public abstract virtual ILabelSymbol get_Label();
}
internal abstract class Microsoft.CodeAnalysis.Operations.CaseClauseWithLabel : CaseClause {
    [CompilerGeneratedAttribute]
private ILabelSymbol <Label>k__BackingField;
    public ILabelSymbol Label { get; }
    protected CaseClauseWithLabel(ILabelSymbol label, CaseKind caseKind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ILabelSymbol get_Label();
}
public enum Microsoft.CodeAnalysis.Operations.CaseKind : Enum {
    public int value__;
    public static CaseKind None;
    public static CaseKind SingleValue;
    public static CaseKind Relational;
    public static CaseKind Range;
    public static CaseKind Default;
    public static CaseKind Pattern;
}
internal class Microsoft.CodeAnalysis.Operations.CatchClause : BaseCatchClause {
    [CompilerGeneratedAttribute]
private IBlockOperation <Handler>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <ExceptionDeclarationOrExpression>k__BackingField;
    public IBlockOperation Handler { get; }
    public IOperation Filter { get; }
    public IOperation ExceptionDeclarationOrExpression { get; }
    public CatchClause(IOperation exceptionDeclarationOrExpression, ITypeSymbol exceptionType, ImmutableArray`1<ILocalSymbol> locals, IOperation filter, IBlockOperation handler, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IBlockOperation get_Handler();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Filter();
    [CompilerGeneratedAttribute]
public virtual IOperation get_ExceptionDeclarationOrExpression();
}
internal class Microsoft.CodeAnalysis.Operations.CaughtExceptionOperation : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public CaughtExceptionOperation(SyntaxNode syntax, ITypeSymbol type);
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.CoalesceExpression : BaseCoalesceExpression {
    [CompilerGeneratedAttribute]
private IOperation <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <WhenNull>k__BackingField;
    public IOperation Value { get; }
    public IOperation WhenNull { get; }
    public CoalesceExpression(IOperation value, IOperation whenNull, IConvertibleConversion convertibleValueConversion, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Value();
    [CompilerGeneratedAttribute]
public virtual IOperation get_WhenNull();
}
public class Microsoft.CodeAnalysis.Operations.CommonConversion : ValueType {
    private ConversionKind _conversionKind;
    [CompilerGeneratedAttribute]
private IMethodSymbol <MethodSymbol>k__BackingField;
    public bool Exists { get; }
    public bool IsIdentity { get; }
    public bool IsNumeric { get; }
    public bool IsReference { get; }
    public bool IsImplicit { get; }
    public bool IsUserDefined { get; }
    public IMethodSymbol MethodSymbol { get; }
    internal CommonConversion(bool exists, bool isIdentity, bool isNumeric, bool isReference, bool isImplicit, IMethodSymbol methodSymbol);
    public bool get_Exists();
    public bool get_IsIdentity();
    public bool get_IsNumeric();
    public bool get_IsReference();
    public bool get_IsImplicit();
    public bool get_IsUserDefined();
    [CompilerGeneratedAttribute]
public IMethodSymbol get_MethodSymbol();
}
internal class Microsoft.CodeAnalysis.Operations.CompoundAssignmentOperation : BaseCompoundAssignmentExpression {
    [CompilerGeneratedAttribute]
private IOperation <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Value>k__BackingField;
    public IOperation Target { get; }
    public IOperation Value { get; }
    public CompoundAssignmentOperation(IOperation target, IOperation value, IConvertibleConversion inConversionConvertible, IConvertibleConversion outConversionConvertible, BinaryOperatorKind operatorKind, bool isLifted, bool isChecked, IMethodSymbol operatorMethod, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Target();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.ConditionalAccessExpression : BaseConditionalAccessExpression {
    [CompilerGeneratedAttribute]
private IOperation <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <WhenNotNull>k__BackingField;
    public IOperation Operation { get; }
    public IOperation WhenNotNull { get; }
    public ConditionalAccessExpression(IOperation whenNotNull, IOperation operation, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Operation();
    [CompilerGeneratedAttribute]
public virtual IOperation get_WhenNotNull();
}
internal class Microsoft.CodeAnalysis.Operations.ConditionalAccessInstanceExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public ConditionalAccessInstanceExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.ConditionalOperation : BaseConditionalOperation {
    [CompilerGeneratedAttribute]
private IOperation <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <WhenTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <WhenFalse>k__BackingField;
    public IOperation Condition { get; }
    public IOperation WhenTrue { get; }
    public IOperation WhenFalse { get; }
    public ConditionalOperation(IOperation condition, IOperation whenTrue, IOperation whenFalse, bool isRef, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Condition();
    [CompilerGeneratedAttribute]
public virtual IOperation get_WhenTrue();
    [CompilerGeneratedAttribute]
public virtual IOperation get_WhenFalse();
}
internal class Microsoft.CodeAnalysis.Operations.ConstantPattern : BaseConstantPattern {
    [CompilerGeneratedAttribute]
private IOperation <Value>k__BackingField;
    public IOperation Value { get; }
    public ConstantPattern(IOperation value, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.ConstructorBodyOperation : BaseConstructorBodyOperation {
    [CompilerGeneratedAttribute]
private IOperation <Initializer>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlockOperation <BlockBody>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlockOperation <ExpressionBody>k__BackingField;
    public IOperation Initializer { get; }
    public IBlockOperation BlockBody { get; }
    public IBlockOperation ExpressionBody { get; }
    public ConstructorBodyOperation(ImmutableArray`1<ILocalSymbol> locals, SemanticModel semanticModel, SyntaxNode syntax, IOperation initializer, IBlockOperation blockBody, IBlockOperation expressionBody);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Initializer();
    [CompilerGeneratedAttribute]
public virtual IBlockOperation get_BlockBody();
    [CompilerGeneratedAttribute]
public virtual IBlockOperation get_ExpressionBody();
}
internal class Microsoft.CodeAnalysis.Operations.ConversionOperation : BaseConversionExpression {
    [CompilerGeneratedAttribute]
private IOperation <Operand>k__BackingField;
    public IOperation Operand { get; }
    public ConversionOperation(IOperation operand, IConvertibleConversion convertibleConversion, bool isTryCast, bool isChecked, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Operand();
}
internal class Microsoft.CodeAnalysis.Operations.DeclarationExpression : BaseDeclarationExpression {
    [CompilerGeneratedAttribute]
private IOperation <Expression>k__BackingField;
    public IOperation Expression { get; }
    public DeclarationExpression(IOperation expression, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Expression();
}
internal class Microsoft.CodeAnalysis.Operations.DeclarationPattern : Operation {
    [CompilerGeneratedAttribute]
private ISymbol <DeclaredSymbol>k__BackingField;
    public ISymbol DeclaredSymbol { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public DeclarationPattern(ISymbol declaredSymbol, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ISymbol get_DeclaredSymbol();
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.DeconstructionAssignmentExpression : BaseDeconstructionAssignmentExpression {
    [CompilerGeneratedAttribute]
private IOperation <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Value>k__BackingField;
    public IOperation Target { get; }
    public IOperation Value { get; }
    public DeconstructionAssignmentExpression(IOperation target, IOperation value, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Target();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.DefaultCaseClause : CaseClauseWithLabel {
    public IEnumerable`1<IOperation> Children { get; }
    public DefaultCaseClause(ILabelSymbol label, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.DefaultValueExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public DefaultValueExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.DelegateCreationExpression : BaseDelegateCreationExpression {
    [CompilerGeneratedAttribute]
private IOperation <Target>k__BackingField;
    public IOperation Target { get; }
    public DelegateCreationExpression(IOperation target, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Target();
}
internal class Microsoft.CodeAnalysis.Operations.DiscardOperation : Operation {
    [CompilerGeneratedAttribute]
private IDiscardSymbol <DiscardSymbol>k__BackingField;
    public IDiscardSymbol DiscardSymbol { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public DiscardOperation(IDiscardSymbol discardSymbol, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual IDiscardSymbol get_DiscardSymbol();
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.DynamicIndexerAccessExpression : BaseDynamicIndexerAccessExpression {
    [CompilerGeneratedAttribute]
private IOperation <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <Arguments>k__BackingField;
    public IOperation Operation { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    public DynamicIndexerAccessExpression(IOperation operation, ImmutableArray`1<IOperation> arguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> argumentRefKinds, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Operation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IOperation> get_Arguments();
}
internal class Microsoft.CodeAnalysis.Operations.DynamicInvocationExpression : BaseDynamicInvocationExpression {
    [CompilerGeneratedAttribute]
private IOperation <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <Arguments>k__BackingField;
    public IOperation Operation { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    public DynamicInvocationExpression(IOperation operation, ImmutableArray`1<IOperation> arguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> argumentRefKinds, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Operation();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IOperation> get_Arguments();
}
internal class Microsoft.CodeAnalysis.Operations.DynamicMemberReferenceExpression : BaseDynamicMemberReferenceExpression {
    [CompilerGeneratedAttribute]
private IOperation <Instance>k__BackingField;
    public IOperation Instance { get; }
    public DynamicMemberReferenceExpression(IOperation instance, string memberName, ImmutableArray`1<ITypeSymbol> typeArguments, ITypeSymbol containingType, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Instance();
}
internal class Microsoft.CodeAnalysis.Operations.DynamicObjectCreationExpression : BaseDynamicObjectCreationExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <Arguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IObjectOrCollectionInitializerOperation <Initializer>k__BackingField;
    public ImmutableArray`1<IOperation> Arguments { get; }
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public DynamicObjectCreationExpression(ImmutableArray`1<IOperation> arguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> argumentRefKinds, IObjectOrCollectionInitializerOperation initializer, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IOperation> get_Arguments();
    [CompilerGeneratedAttribute]
public virtual IObjectOrCollectionInitializerOperation get_Initializer();
}
internal class Microsoft.CodeAnalysis.Operations.EmptyStatement : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public EmptyStatement(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.EndStatement : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public EndStatement(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.EventAssignmentOperation : BaseEventAssignmentOperation {
    [CompilerGeneratedAttribute]
private IOperation <EventReference>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <HandlerValue>k__BackingField;
    public IOperation EventReference { get; }
    public IOperation HandlerValue { get; }
    public EventAssignmentOperation(IOperation eventReference, IOperation handlerValue, bool adds, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_EventReference();
    [CompilerGeneratedAttribute]
public virtual IOperation get_HandlerValue();
}
internal class Microsoft.CodeAnalysis.Operations.EventReferenceExpression : BaseEventReferenceExpression {
    [CompilerGeneratedAttribute]
private IOperation <Instance>k__BackingField;
    public IOperation Instance { get; }
    public EventReferenceExpression(IEventSymbol event, IOperation instance, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Instance();
}
internal class Microsoft.CodeAnalysis.Operations.Expression : object {
    public static ConstantValue SynthesizeNumeric(ITypeSymbol type, int value);
}
internal class Microsoft.CodeAnalysis.Operations.ExpressionStatement : BaseExpressionStatement {
    [CompilerGeneratedAttribute]
private IOperation <Operation>k__BackingField;
    public IOperation Operation { get; }
    public ExpressionStatement(IOperation operation, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Operation();
}
internal class Microsoft.CodeAnalysis.Operations.FieldInitializer : BaseFieldInitializer {
    [CompilerGeneratedAttribute]
private IOperation <Value>k__BackingField;
    public IOperation Value { get; }
    public FieldInitializer(ImmutableArray`1<ILocalSymbol> locals, ImmutableArray`1<IFieldSymbol> initializedFields, IOperation value, OperationKind kind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.FieldReferenceExpression : BaseFieldReferenceExpression {
    [CompilerGeneratedAttribute]
private IOperation <Instance>k__BackingField;
    public IOperation Instance { get; }
    public FieldReferenceExpression(IFieldSymbol field, bool isDeclaration, IOperation instance, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Instance();
}
internal class Microsoft.CodeAnalysis.Operations.FixedStatement : BaseFixedStatement {
    [CompilerGeneratedAttribute]
private IVariableDeclarationGroupOperation <Variables>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Body>k__BackingField;
    public IVariableDeclarationGroupOperation Variables { get; }
    public IOperation Body { get; }
    public FixedStatement(ImmutableArray`1<ILocalSymbol> locals, IVariableDeclarationGroupOperation variables, IOperation body, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IVariableDeclarationGroupOperation get_Variables();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Body();
}
internal class Microsoft.CodeAnalysis.Operations.FlowAnonymousFunctionOperation : Operation {
    public Context Context;
    public IAnonymousFunctionOperation Original;
    public IMethodSymbol Symbol { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public FlowAnonymousFunctionOperation(Context& context, IAnonymousFunctionOperation original, bool isImplicit);
    public sealed virtual IMethodSymbol get_Symbol();
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.FlowCapture : Operation {
    [CompilerGeneratedAttribute]
private CaptureId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Value>k__BackingField;
    public CaptureId Id { get; }
    public IOperation Value { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public FlowCapture(int id, SyntaxNode syntax, IOperation value);
    [CompilerGeneratedAttribute]
public sealed virtual CaptureId get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual IOperation get_Value();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.FlowCapture/<get_Children>d__8")]
public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.FlowCaptureReference : Operation {
    [CompilerGeneratedAttribute]
private CaptureId <Id>k__BackingField;
    public CaptureId Id { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public FlowCaptureReference(int id, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue);
    public FlowCaptureReference(CaptureId id, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue);
    [CompilerGeneratedAttribute]
public sealed virtual CaptureId get_Id();
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.ForEachLoopOperationInfo : ValueType {
    public ITypeSymbol ElementType;
    public IMethodSymbol GetEnumeratorMethod;
    public IPropertySymbol CurrentProperty;
    public IMethodSymbol MoveNextMethod;
    public bool NeedsDispose;
    public bool KnownToImplementIDisposable;
    public IConvertibleConversion CurrentConversion;
    public IConvertibleConversion ElementConversion;
    public Lazy`1<ImmutableArray`1<IArgumentOperation>> GetEnumeratorArguments;
    public Lazy`1<ImmutableArray`1<IArgumentOperation>> MoveNextArguments;
    public Lazy`1<ImmutableArray`1<IArgumentOperation>> CurrentArguments;
    public ForEachLoopOperationInfo(ITypeSymbol elementType, IMethodSymbol getEnumeratorMethod, IPropertySymbol currentProperty, IMethodSymbol moveNextMethod, bool needsDispose, bool knownToImplementIDisposable, IConvertibleConversion currentConversion, IConvertibleConversion elementConversion, Lazy`1<ImmutableArray`1<IArgumentOperation>> getEnumeratorArguments, Lazy`1<ImmutableArray`1<IArgumentOperation>> moveNextArguments, Lazy`1<ImmutableArray`1<IArgumentOperation>> currentArguments);
}
internal class Microsoft.CodeAnalysis.Operations.ForEachLoopStatement : BaseForEachLoopStatement {
    [CompilerGeneratedAttribute]
private IOperation <LoopControlVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Collection>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <NextVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Body>k__BackingField;
    public IOperation LoopControlVariable { get; }
    public IOperation Collection { get; }
    public ImmutableArray`1<IOperation> NextVariables { get; }
    public IOperation Body { get; }
    public ForEachLoopStatement(ImmutableArray`1<ILocalSymbol> locals, ILabelSymbol continueLabel, ILabelSymbol exitLabel, IOperation loopControlVariable, IOperation collection, ImmutableArray`1<IOperation> nextVariables, IOperation body, ForEachLoopOperationInfo info, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_LoopControlVariable();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Collection();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IOperation> get_NextVariables();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Body();
}
internal class Microsoft.CodeAnalysis.Operations.ForLoopStatement : BaseForLoopStatement {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <Before>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <AtLoopBottom>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Body>k__BackingField;
    public ImmutableArray`1<IOperation> Before { get; }
    public IOperation Condition { get; }
    public ImmutableArray`1<IOperation> AtLoopBottom { get; }
    public IOperation Body { get; }
    public ForLoopStatement(ImmutableArray`1<IOperation> before, IOperation condition, ImmutableArray`1<IOperation> atLoopBottom, ImmutableArray`1<ILocalSymbol> locals, ImmutableArray`1<ILocalSymbol> conditionLocals, ILabelSymbol continueLabel, ILabelSymbol exitLabel, IOperation body, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IOperation> get_Before();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Condition();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IOperation> get_AtLoopBottom();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Body();
}
internal class Microsoft.CodeAnalysis.Operations.ForToLoopOperationUserDefinedInfo : object {
    public Lazy`1<IBinaryOperation> Addition;
    public Lazy`1<IBinaryOperation> Subtraction;
    public Lazy`1<IOperation> LessThanOrEqual;
    public Lazy`1<IOperation> GreaterThanOrEqual;
    public ForToLoopOperationUserDefinedInfo(Lazy`1<IBinaryOperation> addition, Lazy`1<IBinaryOperation> subtraction, Lazy`1<IOperation> lessThanOrEqual, Lazy`1<IOperation> greaterThanOrEqual);
}
internal class Microsoft.CodeAnalysis.Operations.ForToLoopStatement : BaseForToLoopStatement {
    [CompilerGeneratedAttribute]
private IOperation <LoopControlVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <InitialValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <LimitValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <StepValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <NextVariables>k__BackingField;
    public IOperation LoopControlVariable { get; }
    public IOperation InitialValue { get; }
    public IOperation LimitValue { get; }
    public IOperation StepValue { get; }
    public IOperation Body { get; }
    public ImmutableArray`1<IOperation> NextVariables { get; }
    public ForToLoopStatement(ImmutableArray`1<ILocalSymbol> locals, bool isChecked, ValueTuple`2<ILocalSymbol, ForToLoopOperationUserDefinedInfo> info, ILabelSymbol continueLabel, ILabelSymbol exitLabel, IOperation loopControlVariable, IOperation initialValue, IOperation limitValue, IOperation stepValue, IOperation body, ImmutableArray`1<IOperation> nextVariables, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_LoopControlVariable();
    [CompilerGeneratedAttribute]
public virtual IOperation get_InitialValue();
    [CompilerGeneratedAttribute]
public virtual IOperation get_LimitValue();
    [CompilerGeneratedAttribute]
public virtual IOperation get_StepValue();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Body();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IOperation> get_NextVariables();
}
internal abstract class Microsoft.CodeAnalysis.Operations.HasDynamicArgumentsExpression : Operation {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ArgumentNames>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RefKind> <ArgumentRefKinds>k__BackingField;
    public ImmutableArray`1<string> ArgumentNames { get; }
    public ImmutableArray`1<RefKind> ArgumentRefKinds { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    protected HasDynamicArgumentsExpression(OperationKind operationKind, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> argumentRefKinds, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ArgumentNames();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RefKind> get_ArgumentRefKinds();
    public abstract virtual ImmutableArray`1<IOperation> get_Arguments();
}
public interface Microsoft.CodeAnalysis.Operations.IAddressOfOperation {
    public IOperation Reference { get; }
    public abstract virtual IOperation get_Reference();
}
internal interface Microsoft.CodeAnalysis.Operations.IAggregateQueryOperation {
    public IOperation Group { get; }
    public IOperation Aggregation { get; }
    public abstract virtual IOperation get_Group();
    public abstract virtual IOperation get_Aggregation();
}
public interface Microsoft.CodeAnalysis.Operations.IAnonymousFunctionOperation {
    public IMethodSymbol Symbol { get; }
    public IBlockOperation Body { get; }
    public abstract virtual IMethodSymbol get_Symbol();
    public abstract virtual IBlockOperation get_Body();
}
public interface Microsoft.CodeAnalysis.Operations.IAnonymousObjectCreationOperation {
    public ImmutableArray`1<IOperation> Initializers { get; }
    public abstract virtual ImmutableArray`1<IOperation> get_Initializers();
}
public interface Microsoft.CodeAnalysis.Operations.IArgumentOperation {
    public ArgumentKind ArgumentKind { get; }
    public IParameterSymbol Parameter { get; }
    public IOperation Value { get; }
    public CommonConversion InConversion { get; }
    public CommonConversion OutConversion { get; }
    public abstract virtual ArgumentKind get_ArgumentKind();
    public abstract virtual IParameterSymbol get_Parameter();
    public abstract virtual IOperation get_Value();
    public abstract virtual CommonConversion get_InConversion();
    public abstract virtual CommonConversion get_OutConversion();
}
public interface Microsoft.CodeAnalysis.Operations.IArrayCreationOperation {
    public ImmutableArray`1<IOperation> DimensionSizes { get; }
    public IArrayInitializerOperation Initializer { get; }
    public abstract virtual ImmutableArray`1<IOperation> get_DimensionSizes();
    public abstract virtual IArrayInitializerOperation get_Initializer();
}
public interface Microsoft.CodeAnalysis.Operations.IArrayElementReferenceOperation {
    public IOperation ArrayReference { get; }
    public ImmutableArray`1<IOperation> Indices { get; }
    public abstract virtual IOperation get_ArrayReference();
    public abstract virtual ImmutableArray`1<IOperation> get_Indices();
}
public interface Microsoft.CodeAnalysis.Operations.IArrayInitializerOperation {
    public ImmutableArray`1<IOperation> ElementValues { get; }
    public abstract virtual ImmutableArray`1<IOperation> get_ElementValues();
}
public interface Microsoft.CodeAnalysis.Operations.IAssignmentOperation {
    public IOperation Target { get; }
    public IOperation Value { get; }
    public abstract virtual IOperation get_Target();
    public abstract virtual IOperation get_Value();
}
public interface Microsoft.CodeAnalysis.Operations.IAwaitOperation {
    public IOperation Operation { get; }
    public abstract virtual IOperation get_Operation();
}
public interface Microsoft.CodeAnalysis.Operations.IBinaryOperation {
    public BinaryOperatorKind OperatorKind { get; }
    public IOperation LeftOperand { get; }
    public IOperation RightOperand { get; }
    public IMethodSymbol OperatorMethod { get; }
    public bool IsLifted { get; }
    public bool IsChecked { get; }
    public bool IsCompareText { get; }
    public abstract virtual BinaryOperatorKind get_OperatorKind();
    public abstract virtual IOperation get_LeftOperand();
    public abstract virtual IOperation get_RightOperand();
    public abstract virtual IMethodSymbol get_OperatorMethod();
    public abstract virtual bool get_IsLifted();
    public abstract virtual bool get_IsChecked();
    public abstract virtual bool get_IsCompareText();
}
public interface Microsoft.CodeAnalysis.Operations.IBlockOperation {
    public ImmutableArray`1<IOperation> Operations { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public abstract virtual ImmutableArray`1<IOperation> get_Operations();
    public abstract virtual ImmutableArray`1<ILocalSymbol> get_Locals();
}
public interface Microsoft.CodeAnalysis.Operations.IBranchOperation {
    public ILabelSymbol Target { get; }
    public BranchKind BranchKind { get; }
    public abstract virtual ILabelSymbol get_Target();
    public abstract virtual BranchKind get_BranchKind();
}
public interface Microsoft.CodeAnalysis.Operations.ICaseClauseOperation {
    public CaseKind CaseKind { get; }
    public ILabelSymbol Label { get; }
    public abstract virtual CaseKind get_CaseKind();
    public abstract virtual ILabelSymbol get_Label();
}
public interface Microsoft.CodeAnalysis.Operations.ICatchClauseOperation {
    public IBlockOperation Handler { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ITypeSymbol ExceptionType { get; }
    public IOperation ExceptionDeclarationOrExpression { get; }
    public IOperation Filter { get; }
    public abstract virtual IBlockOperation get_Handler();
    public abstract virtual ImmutableArray`1<ILocalSymbol> get_Locals();
    public abstract virtual ITypeSymbol get_ExceptionType();
    public abstract virtual IOperation get_ExceptionDeclarationOrExpression();
    public abstract virtual IOperation get_Filter();
}
public interface Microsoft.CodeAnalysis.Operations.ICoalesceOperation {
    public IOperation Value { get; }
    public IOperation WhenNull { get; }
    public CommonConversion ValueConversion { get; }
    public abstract virtual IOperation get_Value();
    public abstract virtual IOperation get_WhenNull();
    public abstract virtual CommonConversion get_ValueConversion();
}
[ObsoleteAttribute("ICollectionElementInitializerOperation has been replaced with IInvocationOperation and IDynamicInvocationOperation", "True")]
public interface Microsoft.CodeAnalysis.Operations.ICollectionElementInitializerOperation {
    public IMethodSymbol AddMethod { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    public bool IsDynamic { get; }
    public abstract virtual IMethodSymbol get_AddMethod();
    public abstract virtual ImmutableArray`1<IOperation> get_Arguments();
    public abstract virtual bool get_IsDynamic();
}
public interface Microsoft.CodeAnalysis.Operations.ICompoundAssignmentOperation {
    public BinaryOperatorKind OperatorKind { get; }
    public IMethodSymbol OperatorMethod { get; }
    public bool IsLifted { get; }
    public bool IsChecked { get; }
    public CommonConversion InConversion { get; }
    public CommonConversion OutConversion { get; }
    public abstract virtual BinaryOperatorKind get_OperatorKind();
    public abstract virtual IMethodSymbol get_OperatorMethod();
    public abstract virtual bool get_IsLifted();
    public abstract virtual bool get_IsChecked();
    public abstract virtual CommonConversion get_InConversion();
    public abstract virtual CommonConversion get_OutConversion();
}
public interface Microsoft.CodeAnalysis.Operations.IConditionalAccessInstanceOperation {
}
public interface Microsoft.CodeAnalysis.Operations.IConditionalAccessOperation {
    public IOperation Operation { get; }
    public IOperation WhenNotNull { get; }
    public abstract virtual IOperation get_Operation();
    public abstract virtual IOperation get_WhenNotNull();
}
public interface Microsoft.CodeAnalysis.Operations.IConditionalOperation {
    public IOperation Condition { get; }
    public IOperation WhenTrue { get; }
    public IOperation WhenFalse { get; }
    public bool IsRef { get; }
    public abstract virtual IOperation get_Condition();
    public abstract virtual IOperation get_WhenTrue();
    public abstract virtual IOperation get_WhenFalse();
    public abstract virtual bool get_IsRef();
}
public interface Microsoft.CodeAnalysis.Operations.IConstantPatternOperation {
    public IOperation Value { get; }
    public abstract virtual IOperation get_Value();
}
public interface Microsoft.CodeAnalysis.Operations.IConstructorBodyOperation {
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Initializer { get; }
    public abstract virtual ImmutableArray`1<ILocalSymbol> get_Locals();
    public abstract virtual IOperation get_Initializer();
}
public interface Microsoft.CodeAnalysis.Operations.IConversionOperation {
    public IOperation Operand { get; }
    public IMethodSymbol OperatorMethod { get; }
    public CommonConversion Conversion { get; }
    public bool IsTryCast { get; }
    public bool IsChecked { get; }
    public abstract virtual IOperation get_Operand();
    public abstract virtual IMethodSymbol get_OperatorMethod();
    public abstract virtual CommonConversion get_Conversion();
    public abstract virtual bool get_IsTryCast();
    public abstract virtual bool get_IsChecked();
}
internal interface Microsoft.CodeAnalysis.Operations.IConvertibleConversion {
    public abstract virtual CommonConversion ToCommonConversion();
}
public interface Microsoft.CodeAnalysis.Operations.IDeclarationExpressionOperation {
    public IOperation Expression { get; }
    public abstract virtual IOperation get_Expression();
}
public interface Microsoft.CodeAnalysis.Operations.IDeclarationPatternOperation {
    public ISymbol DeclaredSymbol { get; }
    public abstract virtual ISymbol get_DeclaredSymbol();
}
public interface Microsoft.CodeAnalysis.Operations.IDeconstructionAssignmentOperation {
}
public interface Microsoft.CodeAnalysis.Operations.IDefaultCaseClauseOperation {
}
public interface Microsoft.CodeAnalysis.Operations.IDefaultValueOperation {
}
public interface Microsoft.CodeAnalysis.Operations.IDelegateCreationOperation {
    public IOperation Target { get; }
    public abstract virtual IOperation get_Target();
}
public interface Microsoft.CodeAnalysis.Operations.IDiscardOperation {
    public IDiscardSymbol DiscardSymbol { get; }
    public abstract virtual IDiscardSymbol get_DiscardSymbol();
}
public interface Microsoft.CodeAnalysis.Operations.IDynamicIndexerAccessOperation {
    public IOperation Operation { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    public abstract virtual IOperation get_Operation();
    public abstract virtual ImmutableArray`1<IOperation> get_Arguments();
}
public interface Microsoft.CodeAnalysis.Operations.IDynamicInvocationOperation {
    public IOperation Operation { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    public abstract virtual IOperation get_Operation();
    public abstract virtual ImmutableArray`1<IOperation> get_Arguments();
}
public interface Microsoft.CodeAnalysis.Operations.IDynamicMemberReferenceOperation {
    public IOperation Instance { get; }
    public string MemberName { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ITypeSymbol ContainingType { get; }
    public abstract virtual IOperation get_Instance();
    public abstract virtual string get_MemberName();
    public abstract virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public abstract virtual ITypeSymbol get_ContainingType();
}
public interface Microsoft.CodeAnalysis.Operations.IDynamicObjectCreationOperation {
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    public abstract virtual IObjectOrCollectionInitializerOperation get_Initializer();
    public abstract virtual ImmutableArray`1<IOperation> get_Arguments();
}
public interface Microsoft.CodeAnalysis.Operations.IEmptyOperation {
}
public interface Microsoft.CodeAnalysis.Operations.IEndOperation {
}
public interface Microsoft.CodeAnalysis.Operations.IEventAssignmentOperation {
    public IOperation EventReference { get; }
    public IOperation HandlerValue { get; }
    public bool Adds { get; }
    public abstract virtual IOperation get_EventReference();
    public abstract virtual IOperation get_HandlerValue();
    public abstract virtual bool get_Adds();
}
public interface Microsoft.CodeAnalysis.Operations.IEventReferenceOperation {
    public IEventSymbol Event { get; }
    public abstract virtual IEventSymbol get_Event();
}
public interface Microsoft.CodeAnalysis.Operations.IExpressionStatementOperation {
    public IOperation Operation { get; }
    public abstract virtual IOperation get_Operation();
}
public interface Microsoft.CodeAnalysis.Operations.IFieldInitializerOperation {
    public ImmutableArray`1<IFieldSymbol> InitializedFields { get; }
    public abstract virtual ImmutableArray`1<IFieldSymbol> get_InitializedFields();
}
public interface Microsoft.CodeAnalysis.Operations.IFieldReferenceOperation {
    public IFieldSymbol Field { get; }
    public bool IsDeclaration { get; }
    public abstract virtual IFieldSymbol get_Field();
    public abstract virtual bool get_IsDeclaration();
}
internal interface Microsoft.CodeAnalysis.Operations.IFixedOperation {
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IVariableDeclarationGroupOperation Variables { get; }
    public IOperation Body { get; }
    public abstract virtual ImmutableArray`1<ILocalSymbol> get_Locals();
    public abstract virtual IVariableDeclarationGroupOperation get_Variables();
    public abstract virtual IOperation get_Body();
}
public interface Microsoft.CodeAnalysis.Operations.IForEachLoopOperation {
    public IOperation LoopControlVariable { get; }
    public IOperation Collection { get; }
    public ImmutableArray`1<IOperation> NextVariables { get; }
    public abstract virtual IOperation get_LoopControlVariable();
    public abstract virtual IOperation get_Collection();
    public abstract virtual ImmutableArray`1<IOperation> get_NextVariables();
}
public interface Microsoft.CodeAnalysis.Operations.IForLoopOperation {
    public ImmutableArray`1<IOperation> Before { get; }
    public ImmutableArray`1<ILocalSymbol> ConditionLocals { get; }
    public IOperation Condition { get; }
    public ImmutableArray`1<IOperation> AtLoopBottom { get; }
    public abstract virtual ImmutableArray`1<IOperation> get_Before();
    public abstract virtual ImmutableArray`1<ILocalSymbol> get_ConditionLocals();
    public abstract virtual IOperation get_Condition();
    public abstract virtual ImmutableArray`1<IOperation> get_AtLoopBottom();
}
public interface Microsoft.CodeAnalysis.Operations.IForToLoopOperation {
    public IOperation LoopControlVariable { get; }
    public IOperation InitialValue { get; }
    public IOperation LimitValue { get; }
    public IOperation StepValue { get; }
    public bool IsChecked { get; }
    public ImmutableArray`1<IOperation> NextVariables { get; }
    public abstract virtual IOperation get_LoopControlVariable();
    public abstract virtual IOperation get_InitialValue();
    public abstract virtual IOperation get_LimitValue();
    public abstract virtual IOperation get_StepValue();
    public abstract virtual bool get_IsChecked();
    public abstract virtual ImmutableArray`1<IOperation> get_NextVariables();
}
public interface Microsoft.CodeAnalysis.Operations.IIncrementOrDecrementOperation {
    public IOperation Target { get; }
    public IMethodSymbol OperatorMethod { get; }
    public bool IsPostfix { get; }
    public bool IsLifted { get; }
    public bool IsChecked { get; }
    public abstract virtual IOperation get_Target();
    public abstract virtual IMethodSymbol get_OperatorMethod();
    public abstract virtual bool get_IsPostfix();
    public abstract virtual bool get_IsLifted();
    public abstract virtual bool get_IsChecked();
}
public interface Microsoft.CodeAnalysis.Operations.IInstanceReferenceOperation {
    public InstanceReferenceKind ReferenceKind { get; }
    public abstract virtual InstanceReferenceKind get_ReferenceKind();
}
public interface Microsoft.CodeAnalysis.Operations.IInterpolatedStringContentOperation {
}
public interface Microsoft.CodeAnalysis.Operations.IInterpolatedStringOperation {
    public ImmutableArray`1<IInterpolatedStringContentOperation> Parts { get; }
    public abstract virtual ImmutableArray`1<IInterpolatedStringContentOperation> get_Parts();
}
public interface Microsoft.CodeAnalysis.Operations.IInterpolatedStringTextOperation {
    public IOperation Text { get; }
    public abstract virtual IOperation get_Text();
}
public interface Microsoft.CodeAnalysis.Operations.IInterpolationOperation {
    public IOperation Expression { get; }
    public IOperation Alignment { get; }
    public IOperation FormatString { get; }
    public abstract virtual IOperation get_Expression();
    public abstract virtual IOperation get_Alignment();
    public abstract virtual IOperation get_FormatString();
}
public interface Microsoft.CodeAnalysis.Operations.IInvalidOperation {
}
public interface Microsoft.CodeAnalysis.Operations.IInvocationOperation {
    public IMethodSymbol TargetMethod { get; }
    public IOperation Instance { get; }
    public bool IsVirtual { get; }
    public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    public abstract virtual IMethodSymbol get_TargetMethod();
    public abstract virtual IOperation get_Instance();
    public abstract virtual bool get_IsVirtual();
    public abstract virtual ImmutableArray`1<IArgumentOperation> get_Arguments();
}
public interface Microsoft.CodeAnalysis.Operations.IIsPatternOperation {
    public IOperation Value { get; }
    public IPatternOperation Pattern { get; }
    public abstract virtual IOperation get_Value();
    public abstract virtual IPatternOperation get_Pattern();
}
public interface Microsoft.CodeAnalysis.Operations.IIsTypeOperation {
    public IOperation ValueOperand { get; }
    public ITypeSymbol TypeOperand { get; }
    public bool IsNegated { get; }
    public abstract virtual IOperation get_ValueOperand();
    public abstract virtual ITypeSymbol get_TypeOperand();
    public abstract virtual bool get_IsNegated();
}
public interface Microsoft.CodeAnalysis.Operations.ILabeledOperation {
    public ILabelSymbol Label { get; }
    public IOperation Operation { get; }
    public abstract virtual ILabelSymbol get_Label();
    public abstract virtual IOperation get_Operation();
}
public interface Microsoft.CodeAnalysis.Operations.ILiteralOperation {
}
public interface Microsoft.CodeAnalysis.Operations.ILocalFunctionOperation {
    public IMethodSymbol Symbol { get; }
    public IBlockOperation Body { get; }
    public IBlockOperation IgnoredBody { get; }
    public abstract virtual IMethodSymbol get_Symbol();
    public abstract virtual IBlockOperation get_Body();
    public abstract virtual IBlockOperation get_IgnoredBody();
}
public interface Microsoft.CodeAnalysis.Operations.ILocalReferenceOperation {
    public ILocalSymbol Local { get; }
    public bool IsDeclaration { get; }
    public abstract virtual ILocalSymbol get_Local();
    public abstract virtual bool get_IsDeclaration();
}
public interface Microsoft.CodeAnalysis.Operations.ILockOperation {
    public IOperation LockedValue { get; }
    public IOperation Body { get; }
    public abstract virtual IOperation get_LockedValue();
    public abstract virtual IOperation get_Body();
}
public interface Microsoft.CodeAnalysis.Operations.ILoopOperation {
    public LoopKind LoopKind { get; }
    public IOperation Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ILabelSymbol ContinueLabel { get; }
    public ILabelSymbol ExitLabel { get; }
    public abstract virtual LoopKind get_LoopKind();
    public abstract virtual IOperation get_Body();
    public abstract virtual ImmutableArray`1<ILocalSymbol> get_Locals();
    public abstract virtual ILabelSymbol get_ContinueLabel();
    public abstract virtual ILabelSymbol get_ExitLabel();
}
public interface Microsoft.CodeAnalysis.Operations.IMemberInitializerOperation {
    public IOperation InitializedMember { get; }
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public abstract virtual IOperation get_InitializedMember();
    public abstract virtual IObjectOrCollectionInitializerOperation get_Initializer();
}
public interface Microsoft.CodeAnalysis.Operations.IMemberReferenceOperation {
    public IOperation Instance { get; }
    public ISymbol Member { get; }
    public abstract virtual IOperation get_Instance();
    public abstract virtual ISymbol get_Member();
}
public interface Microsoft.CodeAnalysis.Operations.IMethodBodyBaseOperation {
    public IBlockOperation BlockBody { get; }
    public IBlockOperation ExpressionBody { get; }
    public abstract virtual IBlockOperation get_BlockBody();
    public abstract virtual IBlockOperation get_ExpressionBody();
}
public interface Microsoft.CodeAnalysis.Operations.IMethodBodyOperation {
}
public interface Microsoft.CodeAnalysis.Operations.IMethodReferenceOperation {
    public IMethodSymbol Method { get; }
    public bool IsVirtual { get; }
    public abstract virtual IMethodSymbol get_Method();
    public abstract virtual bool get_IsVirtual();
}
public interface Microsoft.CodeAnalysis.Operations.INameOfOperation {
    public IOperation Argument { get; }
    public abstract virtual IOperation get_Argument();
}
internal class Microsoft.CodeAnalysis.Operations.IncrementExpression : BaseIncrementExpression {
    [CompilerGeneratedAttribute]
private IOperation <Target>k__BackingField;
    public IOperation Target { get; }
    public IncrementExpression(bool isDecrement, bool isPostfix, bool isLifted, bool isChecked, IOperation target, IMethodSymbol operatorMethod, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Target();
}
internal interface Microsoft.CodeAnalysis.Operations.INoPiaObjectCreationOperation {
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public abstract virtual IObjectOrCollectionInitializerOperation get_Initializer();
}
internal class Microsoft.CodeAnalysis.Operations.InstanceReferenceExpression : Operation {
    [CompilerGeneratedAttribute]
private InstanceReferenceKind <ReferenceKind>k__BackingField;
    public InstanceReferenceKind ReferenceKind { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public InstanceReferenceExpression(InstanceReferenceKind referenceKind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual InstanceReferenceKind get_ReferenceKind();
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
public enum Microsoft.CodeAnalysis.Operations.InstanceReferenceKind : Enum {
    public int value__;
    public static InstanceReferenceKind ContainingTypeInstance;
    public static InstanceReferenceKind ImplicitReceiver;
}
internal class Microsoft.CodeAnalysis.Operations.InterpolatedStringExpression : BaseInterpolatedStringExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IInterpolatedStringContentOperation> <Parts>k__BackingField;
    public ImmutableArray`1<IInterpolatedStringContentOperation> Parts { get; }
    public InterpolatedStringExpression(ImmutableArray`1<IInterpolatedStringContentOperation> parts, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IInterpolatedStringContentOperation> get_Parts();
}
internal class Microsoft.CodeAnalysis.Operations.InterpolatedStringText : BaseInterpolatedStringText {
    [CompilerGeneratedAttribute]
private IOperation <Text>k__BackingField;
    public IOperation Text { get; }
    public InterpolatedStringText(IOperation text, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Text();
}
internal class Microsoft.CodeAnalysis.Operations.Interpolation : BaseInterpolation {
    [CompilerGeneratedAttribute]
private IOperation <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Alignment>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <FormatString>k__BackingField;
    public IOperation Expression { get; }
    public IOperation Alignment { get; }
    public IOperation FormatString { get; }
    public Interpolation(IOperation expression, IOperation alignment, IOperation formatString, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Expression();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Alignment();
    [CompilerGeneratedAttribute]
public virtual IOperation get_FormatString();
}
internal class Microsoft.CodeAnalysis.Operations.InvalidOperation : BaseInvalidOperation {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IOperation> <Children>k__BackingField;
    public IEnumerable`1<IOperation> Children { get; }
    public InvalidOperation(ImmutableArray`1<IOperation> children, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IEnumerable`1<IOperation> get_Children();
}
internal class Microsoft.CodeAnalysis.Operations.InvocationExpression : BaseInvocationExpression {
    [CompilerGeneratedAttribute]
private IOperation <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IArgumentOperation> <Arguments>k__BackingField;
    public IOperation Instance { get; }
    public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    public InvocationExpression(IMethodSymbol targetMethod, IOperation instance, bool isVirtual, ImmutableArray`1<IArgumentOperation> arguments, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Instance();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IArgumentOperation> get_Arguments();
}
public interface Microsoft.CodeAnalysis.Operations.IObjectCreationOperation {
    public IMethodSymbol Constructor { get; }
    public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public abstract virtual IMethodSymbol get_Constructor();
    public abstract virtual ImmutableArray`1<IArgumentOperation> get_Arguments();
    public abstract virtual IObjectOrCollectionInitializerOperation get_Initializer();
}
public interface Microsoft.CodeAnalysis.Operations.IObjectOrCollectionInitializerOperation {
    public ImmutableArray`1<IOperation> Initializers { get; }
    public abstract virtual ImmutableArray`1<IOperation> get_Initializers();
}
public interface Microsoft.CodeAnalysis.Operations.IOmittedArgumentOperation {
}
public interface Microsoft.CodeAnalysis.Operations.IParameterInitializerOperation {
    public IParameterSymbol Parameter { get; }
    public abstract virtual IParameterSymbol get_Parameter();
}
public interface Microsoft.CodeAnalysis.Operations.IParameterReferenceOperation {
    public IParameterSymbol Parameter { get; }
    public abstract virtual IParameterSymbol get_Parameter();
}
public interface Microsoft.CodeAnalysis.Operations.IParenthesizedOperation {
    public IOperation Operand { get; }
    public abstract virtual IOperation get_Operand();
}
public interface Microsoft.CodeAnalysis.Operations.IPatternCaseClauseOperation {
    public ILabelSymbol Label { get; }
    public IPatternOperation Pattern { get; }
    public IOperation Guard { get; }
    public abstract virtual ILabelSymbol get_Label();
    public abstract virtual IPatternOperation get_Pattern();
    public abstract virtual IOperation get_Guard();
}
public interface Microsoft.CodeAnalysis.Operations.IPatternOperation {
}
internal interface Microsoft.CodeAnalysis.Operations.IPlaceholderOperation {
    public PlaceholderKind PlaceholderKind { get; }
    public abstract virtual PlaceholderKind get_PlaceholderKind();
}
internal interface Microsoft.CodeAnalysis.Operations.IPointerIndirectionReferenceOperation {
    public IOperation Pointer { get; }
    public abstract virtual IOperation get_Pointer();
}
public interface Microsoft.CodeAnalysis.Operations.IPropertyInitializerOperation {
    public ImmutableArray`1<IPropertySymbol> InitializedProperties { get; }
    public abstract virtual ImmutableArray`1<IPropertySymbol> get_InitializedProperties();
}
public interface Microsoft.CodeAnalysis.Operations.IPropertyReferenceOperation {
    public IPropertySymbol Property { get; }
    public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    public abstract virtual IPropertySymbol get_Property();
    public abstract virtual ImmutableArray`1<IArgumentOperation> get_Arguments();
}
public interface Microsoft.CodeAnalysis.Operations.IRaiseEventOperation {
    public IEventReferenceOperation EventReference { get; }
    public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    public abstract virtual IEventReferenceOperation get_EventReference();
    public abstract virtual ImmutableArray`1<IArgumentOperation> get_Arguments();
}
public interface Microsoft.CodeAnalysis.Operations.IRangeCaseClauseOperation {
    public IOperation MinimumValue { get; }
    public IOperation MaximumValue { get; }
    public abstract virtual IOperation get_MinimumValue();
    public abstract virtual IOperation get_MaximumValue();
}
public interface Microsoft.CodeAnalysis.Operations.IRelationalCaseClauseOperation {
    public IOperation Value { get; }
    public BinaryOperatorKind Relation { get; }
    public abstract virtual IOperation get_Value();
    public abstract virtual BinaryOperatorKind get_Relation();
}
public interface Microsoft.CodeAnalysis.Operations.IReturnOperation {
    public IOperation ReturnedValue { get; }
    public abstract virtual IOperation get_ReturnedValue();
}
public interface Microsoft.CodeAnalysis.Operations.ISimpleAssignmentOperation {
    public bool IsRef { get; }
    public abstract virtual bool get_IsRef();
}
public interface Microsoft.CodeAnalysis.Operations.ISingleValueCaseClauseOperation {
    public IOperation Value { get; }
    public abstract virtual IOperation get_Value();
}
public interface Microsoft.CodeAnalysis.Operations.ISizeOfOperation {
    public ITypeSymbol TypeOperand { get; }
    public abstract virtual ITypeSymbol get_TypeOperand();
}
internal class Microsoft.CodeAnalysis.Operations.IsNullOperation : Operation {
    [CompilerGeneratedAttribute]
private IOperation <Operand>k__BackingField;
    public IOperation Operand { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public IsNullOperation(SyntaxNode syntax, IOperation operand, ITypeSymbol type, Optional`1<object> constantValue);
    [CompilerGeneratedAttribute]
public sealed virtual IOperation get_Operand();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.IsNullOperation/<get_Children>d__5")]
public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.IsPatternExpression : BaseIsPatternExpression {
    [CompilerGeneratedAttribute]
private IOperation <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IPatternOperation <Pattern>k__BackingField;
    public IOperation Value { get; }
    public IPatternOperation Pattern { get; }
    public IsPatternExpression(IOperation value, IPatternOperation pattern, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Value();
    [CompilerGeneratedAttribute]
public virtual IPatternOperation get_Pattern();
}
public interface Microsoft.CodeAnalysis.Operations.IStopOperation {
}
internal class Microsoft.CodeAnalysis.Operations.IsTypeExpression : BaseIsTypeExpression {
    [CompilerGeneratedAttribute]
private IOperation <ValueOperand>k__BackingField;
    public IOperation ValueOperand { get; }
    public IsTypeExpression(IOperation valueOperand, ITypeSymbol typeOperand, bool isNegated, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_ValueOperand();
}
public interface Microsoft.CodeAnalysis.Operations.ISwitchCaseOperation {
    public ImmutableArray`1<ICaseClauseOperation> Clauses { get; }
    public ImmutableArray`1<IOperation> Body { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public abstract virtual ImmutableArray`1<ICaseClauseOperation> get_Clauses();
    public abstract virtual ImmutableArray`1<IOperation> get_Body();
    public abstract virtual ImmutableArray`1<ILocalSymbol> get_Locals();
}
public interface Microsoft.CodeAnalysis.Operations.ISwitchOperation {
    public IOperation Value { get; }
    public ImmutableArray`1<ISwitchCaseOperation> Cases { get; }
    public ILabelSymbol ExitLabel { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public abstract virtual IOperation get_Value();
    public abstract virtual ImmutableArray`1<ISwitchCaseOperation> get_Cases();
    public abstract virtual ILabelSymbol get_ExitLabel();
    public abstract virtual ImmutableArray`1<ILocalSymbol> get_Locals();
}
public interface Microsoft.CodeAnalysis.Operations.ISymbolInitializerOperation {
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public IOperation Value { get; }
    public abstract virtual ImmutableArray`1<ILocalSymbol> get_Locals();
    public abstract virtual IOperation get_Value();
}
public interface Microsoft.CodeAnalysis.Operations.IThrowOperation {
    public IOperation Exception { get; }
    public abstract virtual IOperation get_Exception();
}
public interface Microsoft.CodeAnalysis.Operations.ITranslatedQueryOperation {
    public IOperation Operation { get; }
    public abstract virtual IOperation get_Operation();
}
public interface Microsoft.CodeAnalysis.Operations.ITryOperation {
    public IBlockOperation Body { get; }
    public ImmutableArray`1<ICatchClauseOperation> Catches { get; }
    public IBlockOperation Finally { get; }
    public ILabelSymbol ExitLabel { get; }
    public abstract virtual IBlockOperation get_Body();
    public abstract virtual ImmutableArray`1<ICatchClauseOperation> get_Catches();
    public abstract virtual IBlockOperation get_Finally();
    public abstract virtual ILabelSymbol get_ExitLabel();
}
public interface Microsoft.CodeAnalysis.Operations.ITupleBinaryOperation {
    public BinaryOperatorKind OperatorKind { get; }
    public IOperation LeftOperand { get; }
    public IOperation RightOperand { get; }
    public abstract virtual BinaryOperatorKind get_OperatorKind();
    public abstract virtual IOperation get_LeftOperand();
    public abstract virtual IOperation get_RightOperand();
}
public interface Microsoft.CodeAnalysis.Operations.ITupleOperation {
    public ImmutableArray`1<IOperation> Elements { get; }
    public ITypeSymbol NaturalType { get; }
    public abstract virtual ImmutableArray`1<IOperation> get_Elements();
    public abstract virtual ITypeSymbol get_NaturalType();
}
public interface Microsoft.CodeAnalysis.Operations.ITypeOfOperation {
    public ITypeSymbol TypeOperand { get; }
    public abstract virtual ITypeSymbol get_TypeOperand();
}
public interface Microsoft.CodeAnalysis.Operations.ITypeParameterObjectCreationOperation {
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public abstract virtual IObjectOrCollectionInitializerOperation get_Initializer();
}
public interface Microsoft.CodeAnalysis.Operations.IUnaryOperation {
    public UnaryOperatorKind OperatorKind { get; }
    public IOperation Operand { get; }
    public IMethodSymbol OperatorMethod { get; }
    public bool IsLifted { get; }
    public bool IsChecked { get; }
    public abstract virtual UnaryOperatorKind get_OperatorKind();
    public abstract virtual IOperation get_Operand();
    public abstract virtual IMethodSymbol get_OperatorMethod();
    public abstract virtual bool get_IsLifted();
    public abstract virtual bool get_IsChecked();
}
public interface Microsoft.CodeAnalysis.Operations.IUsingOperation {
    public IOperation Body { get; }
    public IOperation Resources { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public abstract virtual IOperation get_Body();
    public abstract virtual IOperation get_Resources();
    public abstract virtual ImmutableArray`1<ILocalSymbol> get_Locals();
}
public interface Microsoft.CodeAnalysis.Operations.IVariableDeclarationGroupOperation {
    public ImmutableArray`1<IVariableDeclarationOperation> Declarations { get; }
    public abstract virtual ImmutableArray`1<IVariableDeclarationOperation> get_Declarations();
}
public interface Microsoft.CodeAnalysis.Operations.IVariableDeclarationOperation {
    public ImmutableArray`1<IVariableDeclaratorOperation> Declarators { get; }
    public IVariableInitializerOperation Initializer { get; }
    public abstract virtual ImmutableArray`1<IVariableDeclaratorOperation> get_Declarators();
    public abstract virtual IVariableInitializerOperation get_Initializer();
}
public interface Microsoft.CodeAnalysis.Operations.IVariableDeclaratorOperation {
    public ILocalSymbol Symbol { get; }
    public IVariableInitializerOperation Initializer { get; }
    public ImmutableArray`1<IOperation> IgnoredArguments { get; }
    public abstract virtual ILocalSymbol get_Symbol();
    public abstract virtual IVariableInitializerOperation get_Initializer();
    public abstract virtual ImmutableArray`1<IOperation> get_IgnoredArguments();
}
public interface Microsoft.CodeAnalysis.Operations.IVariableInitializerOperation {
}
public interface Microsoft.CodeAnalysis.Operations.IWhileLoopOperation {
    public IOperation Condition { get; }
    public bool ConditionIsTop { get; }
    public bool ConditionIsUntil { get; }
    public IOperation IgnoredCondition { get; }
    public abstract virtual IOperation get_Condition();
    public abstract virtual bool get_ConditionIsTop();
    public abstract virtual bool get_ConditionIsUntil();
    public abstract virtual IOperation get_IgnoredCondition();
}
internal interface Microsoft.CodeAnalysis.Operations.IWithOperation {
    public IOperation Body { get; }
    public IOperation Value { get; }
    public abstract virtual IOperation get_Body();
    public abstract virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.LabeledStatement : BaseLabeledStatement {
    [CompilerGeneratedAttribute]
private IOperation <Operation>k__BackingField;
    public IOperation Operation { get; }
    public LabeledStatement(ILabelSymbol label, IOperation operation, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Operation();
}
internal class Microsoft.CodeAnalysis.Operations.LazyAddressOfExpression : BaseAddressOfExpression {
    private Lazy`1<IOperation> _lazyReference;
    public IOperation Reference { get; }
    public LazyAddressOfExpression(Lazy`1<IOperation> reference, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Reference();
}
internal class Microsoft.CodeAnalysis.Operations.LazyAggregateQueryOperation : BaseAggregateQueryOperation {
    private Lazy`1<IOperation> _lazyGroup;
    private Lazy`1<IOperation> _lazyAggregation;
    public IOperation Group { get; }
    public IOperation Aggregation { get; }
    public LazyAggregateQueryOperation(Lazy`1<IOperation> group, Lazy`1<IOperation> aggregation, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Group();
    public virtual IOperation get_Aggregation();
}
internal class Microsoft.CodeAnalysis.Operations.LazyAnonymousFunctionExpression : BaseAnonymousFunctionExpression {
    private Lazy`1<IBlockOperation> _lazyBody;
    public IBlockOperation Body { get; }
    public LazyAnonymousFunctionExpression(IMethodSymbol symbol, Lazy`1<IBlockOperation> body, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IBlockOperation get_Body();
}
internal class Microsoft.CodeAnalysis.Operations.LazyAnonymousObjectCreationExpression : BaseAnonymousObjectCreationExpression {
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyInitializers;
    public ImmutableArray`1<IOperation> Initializers { get; }
    public LazyAnonymousObjectCreationExpression(Lazy`1<ImmutableArray`1<IOperation>> initializers, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual ImmutableArray`1<IOperation> get_Initializers();
}
internal class Microsoft.CodeAnalysis.Operations.LazyArgumentOperation : BaseArgument {
    private Lazy`1<IOperation> _lazyValue;
    public IOperation Value { get; }
    public LazyArgumentOperation(Lazy`1<IOperation> value, ArgumentKind argumentKind, IConvertibleConversion inConversionOpt, IConvertibleConversion outConversionOpt, IParameterSymbol parameter, SemanticModel semanticModel, SyntaxNode syntax, bool isImplicit);
    public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.LazyArrayCreationExpression : BaseArrayCreationExpression {
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyDimensionSizes;
    private Lazy`1<IArrayInitializerOperation> _lazyInitializer;
    public ImmutableArray`1<IOperation> DimensionSizes { get; }
    public IArrayInitializerOperation Initializer { get; }
    public LazyArrayCreationExpression(Lazy`1<ImmutableArray`1<IOperation>> dimensionSizes, Lazy`1<IArrayInitializerOperation> initializer, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual ImmutableArray`1<IOperation> get_DimensionSizes();
    public virtual IArrayInitializerOperation get_Initializer();
}
internal class Microsoft.CodeAnalysis.Operations.LazyArrayElementReferenceExpression : BaseArrayElementReferenceExpression {
    private Lazy`1<IOperation> _lazyArrayReference;
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyIndices;
    public IOperation ArrayReference { get; }
    public ImmutableArray`1<IOperation> Indices { get; }
    public LazyArrayElementReferenceExpression(Lazy`1<IOperation> arrayReference, Lazy`1<ImmutableArray`1<IOperation>> indices, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_ArrayReference();
    public virtual ImmutableArray`1<IOperation> get_Indices();
}
internal class Microsoft.CodeAnalysis.Operations.LazyArrayInitializer : BaseArrayInitializer {
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyElementValues;
    public ImmutableArray`1<IOperation> ElementValues { get; }
    public LazyArrayInitializer(Lazy`1<ImmutableArray`1<IOperation>> elementValues, SemanticModel semanticModel, SyntaxNode syntax, Optional`1<object> constantValue, bool isImplicit);
    public virtual ImmutableArray`1<IOperation> get_ElementValues();
}
internal class Microsoft.CodeAnalysis.Operations.LazyAwaitExpression : BaseAwaitExpression {
    private Lazy`1<IOperation> _lazyOperation;
    public IOperation Operation { get; }
    public LazyAwaitExpression(Lazy`1<IOperation> operation, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Operation();
}
internal class Microsoft.CodeAnalysis.Operations.LazyBinaryOperatorExpression : BaseBinaryOperatorExpression {
    private Lazy`1<IOperation> _lazyLeftOperand;
    private Lazy`1<IOperation> _lazyRightOperand;
    public IOperation LeftOperand { get; }
    public IOperation RightOperand { get; }
    public LazyBinaryOperatorExpression(BinaryOperatorKind operatorKind, Lazy`1<IOperation> leftOperand, Lazy`1<IOperation> rightOperand, bool isLifted, bool isChecked, bool isCompareText, IMethodSymbol operatorMethod, IMethodSymbol unaryOperatorMethod, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_LeftOperand();
    public virtual IOperation get_RightOperand();
}
internal class Microsoft.CodeAnalysis.Operations.LazyBlockStatement : BaseBlockStatement {
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyOperations;
    public ImmutableArray`1<IOperation> Operations { get; }
    public LazyBlockStatement(Lazy`1<ImmutableArray`1<IOperation>> operations, ImmutableArray`1<ILocalSymbol> locals, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual ImmutableArray`1<IOperation> get_Operations();
}
internal class Microsoft.CodeAnalysis.Operations.LazyCatchClause : BaseCatchClause {
    private Lazy`1<IOperation> _lazyExceptionDeclarationOrExpression;
    private Lazy`1<IOperation> _lazyFilter;
    private Lazy`1<IBlockOperation> _lazyHandler;
    public IOperation ExceptionDeclarationOrExpression { get; }
    public IOperation Filter { get; }
    public IBlockOperation Handler { get; }
    public LazyCatchClause(Lazy`1<IOperation> exceptionDeclarationOrExpression, ITypeSymbol exceptionType, ImmutableArray`1<ILocalSymbol> locals, Lazy`1<IOperation> filter, Lazy`1<IBlockOperation> handler, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_ExceptionDeclarationOrExpression();
    public virtual IOperation get_Filter();
    public virtual IBlockOperation get_Handler();
}
internal class Microsoft.CodeAnalysis.Operations.LazyCoalesceExpression : BaseCoalesceExpression {
    private Lazy`1<IOperation> _lazyValue;
    private Lazy`1<IOperation> _lazyWhenNull;
    public IOperation Value { get; }
    public IOperation WhenNull { get; }
    public LazyCoalesceExpression(Lazy`1<IOperation> value, Lazy`1<IOperation> whenNull, IConvertibleConversion convertibleValueConversion, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Value();
    public virtual IOperation get_WhenNull();
}
internal class Microsoft.CodeAnalysis.Operations.LazyCompoundAssignmentOperation : BaseCompoundAssignmentExpression {
    private Lazy`1<IOperation> _lazyTarget;
    private Lazy`1<IOperation> _lazyValue;
    public IOperation Target { get; }
    public IOperation Value { get; }
    public LazyCompoundAssignmentOperation(Lazy`1<IOperation> target, Lazy`1<IOperation> value, IConvertibleConversion inConversionConvertible, IConvertibleConversion outConversionConvertible, BinaryOperatorKind operatorKind, bool isLifted, bool isChecked, IMethodSymbol operatorMethod, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Target();
    public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.LazyConditionalAccessExpression : BaseConditionalAccessExpression {
    private Lazy`1<IOperation> _lazyWhenNotNull;
    private Lazy`1<IOperation> _lazyOperation;
    public IOperation Operation { get; }
    public IOperation WhenNotNull { get; }
    public LazyConditionalAccessExpression(Lazy`1<IOperation> whenNotNull, Lazy`1<IOperation> operation, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Operation();
    public virtual IOperation get_WhenNotNull();
}
internal class Microsoft.CodeAnalysis.Operations.LazyConditionalOperation : BaseConditionalOperation {
    private Lazy`1<IOperation> _lazyCondition;
    private Lazy`1<IOperation> _lazyWhenTrue;
    private Lazy`1<IOperation> _lazyWhenFalse;
    public IOperation Condition { get; }
    public IOperation WhenTrue { get; }
    public IOperation WhenFalse { get; }
    public LazyConditionalOperation(Lazy`1<IOperation> condition, Lazy`1<IOperation> whenTrue, Lazy`1<IOperation> whenFalse, bool isRef, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Condition();
    public virtual IOperation get_WhenTrue();
    public virtual IOperation get_WhenFalse();
}
internal class Microsoft.CodeAnalysis.Operations.LazyConstantPattern : BaseConstantPattern {
    private Lazy`1<IOperation> _lazyValue;
    public IOperation Value { get; }
    public LazyConstantPattern(Lazy`1<IOperation> value, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.LazyConstructorBodyOperation : BaseConstructorBodyOperation {
    private Lazy`1<IOperation> _lazyInitializer;
    private Lazy`1<IBlockOperation> _lazyBlockBody;
    private Lazy`1<IBlockOperation> _lazyExpressionBody;
    public IOperation Initializer { get; }
    public IBlockOperation BlockBody { get; }
    public IBlockOperation ExpressionBody { get; }
    public LazyConstructorBodyOperation(ImmutableArray`1<ILocalSymbol> locals, SemanticModel semanticModel, SyntaxNode syntax, Lazy`1<IOperation> initializer, Lazy`1<IBlockOperation> blockBody, Lazy`1<IBlockOperation> expressionBody);
    public virtual IOperation get_Initializer();
    public virtual IBlockOperation get_BlockBody();
    public virtual IBlockOperation get_ExpressionBody();
}
internal class Microsoft.CodeAnalysis.Operations.LazyConversionOperation : BaseConversionExpression {
    private Lazy`1<IOperation> _lazyOperand;
    public IOperation Operand { get; }
    public LazyConversionOperation(Lazy`1<IOperation> lazyOperand, IConvertibleConversion convertibleConversion, bool isTryCast, bool isChecked, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Operand();
}
internal class Microsoft.CodeAnalysis.Operations.LazyDeclarationExpression : BaseDeclarationExpression {
    private Lazy`1<IOperation> _lazyExpression;
    public IOperation Expression { get; }
    public LazyDeclarationExpression(Lazy`1<IOperation> expression, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Expression();
}
internal class Microsoft.CodeAnalysis.Operations.LazyDeconstructionAssignmentExpression : BaseDeconstructionAssignmentExpression {
    private Lazy`1<IOperation> _lazyTarget;
    private Lazy`1<IOperation> _lazyValue;
    public IOperation Target { get; }
    public IOperation Value { get; }
    public LazyDeconstructionAssignmentExpression(Lazy`1<IOperation> target, Lazy`1<IOperation> value, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Target();
    public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.LazyDelegateCreationExpression : BaseDelegateCreationExpression {
    private Lazy`1<IOperation> _lazyTarget;
    public IOperation Target { get; }
    public LazyDelegateCreationExpression(Lazy`1<IOperation> lazyTarget, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Target();
}
internal class Microsoft.CodeAnalysis.Operations.LazyDynamicIndexerAccessExpression : BaseDynamicIndexerAccessExpression {
    private Lazy`1<IOperation> _lazyOperation;
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyArguments;
    public IOperation Operation { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    public LazyDynamicIndexerAccessExpression(Lazy`1<IOperation> operation, Lazy`1<ImmutableArray`1<IOperation>> arguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> argumentRefKinds, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Operation();
    public virtual ImmutableArray`1<IOperation> get_Arguments();
}
internal class Microsoft.CodeAnalysis.Operations.LazyDynamicInvocationExpression : BaseDynamicInvocationExpression {
    private Lazy`1<IOperation> _lazyOperation;
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyArguments;
    public IOperation Operation { get; }
    public ImmutableArray`1<IOperation> Arguments { get; }
    public LazyDynamicInvocationExpression(Lazy`1<IOperation> operation, Lazy`1<ImmutableArray`1<IOperation>> arguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> argumentRefKinds, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Operation();
    public virtual ImmutableArray`1<IOperation> get_Arguments();
}
internal class Microsoft.CodeAnalysis.Operations.LazyDynamicMemberReferenceExpression : BaseDynamicMemberReferenceExpression {
    private Lazy`1<IOperation> _lazyInstance;
    public IOperation Instance { get; }
    public LazyDynamicMemberReferenceExpression(Lazy`1<IOperation> lazyInstance, string memberName, ImmutableArray`1<ITypeSymbol> typeArguments, ITypeSymbol containingType, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Instance();
}
internal class Microsoft.CodeAnalysis.Operations.LazyDynamicObjectCreationExpression : BaseDynamicObjectCreationExpression {
    private Lazy`1<IObjectOrCollectionInitializerOperation> _lazyInitializer;
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyArguments;
    public ImmutableArray`1<IOperation> Arguments { get; }
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public LazyDynamicObjectCreationExpression(Lazy`1<ImmutableArray`1<IOperation>> arguments, ImmutableArray`1<string> argumentNames, ImmutableArray`1<RefKind> argumentRefKinds, Lazy`1<IObjectOrCollectionInitializerOperation> initializer, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual ImmutableArray`1<IOperation> get_Arguments();
    public virtual IObjectOrCollectionInitializerOperation get_Initializer();
}
internal class Microsoft.CodeAnalysis.Operations.LazyEventAssignmentOperation : BaseEventAssignmentOperation {
    private Lazy`1<IOperation> _lazyEventReference;
    private Lazy`1<IOperation> _lazyHandlerValue;
    public IOperation EventReference { get; }
    public IOperation HandlerValue { get; }
    public LazyEventAssignmentOperation(Lazy`1<IOperation> eventReference, Lazy`1<IOperation> handlerValue, bool adds, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_EventReference();
    public virtual IOperation get_HandlerValue();
}
internal class Microsoft.CodeAnalysis.Operations.LazyEventReferenceExpression : BaseEventReferenceExpression {
    private Lazy`1<IOperation> _lazyInstance;
    public IOperation Instance { get; }
    public LazyEventReferenceExpression(IEventSymbol event, Lazy`1<IOperation> instance, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Instance();
}
internal class Microsoft.CodeAnalysis.Operations.LazyExpressionStatement : BaseExpressionStatement {
    private Lazy`1<IOperation> _lazyOperation;
    public IOperation Operation { get; }
    public LazyExpressionStatement(Lazy`1<IOperation> operation, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Operation();
}
internal class Microsoft.CodeAnalysis.Operations.LazyFieldInitializer : BaseFieldInitializer {
    private Lazy`1<IOperation> _lazyValue;
    public IOperation Value { get; }
    public LazyFieldInitializer(ImmutableArray`1<ILocalSymbol> locals, ImmutableArray`1<IFieldSymbol> initializedFields, Lazy`1<IOperation> value, OperationKind kind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.LazyFieldReferenceExpression : BaseFieldReferenceExpression {
    private Lazy`1<IOperation> _lazyInstance;
    public IOperation Instance { get; }
    public LazyFieldReferenceExpression(IFieldSymbol field, bool isDeclaration, Lazy`1<IOperation> instance, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Instance();
}
internal class Microsoft.CodeAnalysis.Operations.LazyFixedStatement : BaseFixedStatement {
    private Lazy`1<IVariableDeclarationGroupOperation> _lazyVariables;
    private Lazy`1<IOperation> _lazyBody;
    public IVariableDeclarationGroupOperation Variables { get; }
    public IOperation Body { get; }
    public LazyFixedStatement(ImmutableArray`1<ILocalSymbol> locals, Lazy`1<IVariableDeclarationGroupOperation> variables, Lazy`1<IOperation> body, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IVariableDeclarationGroupOperation get_Variables();
    public virtual IOperation get_Body();
}
internal class Microsoft.CodeAnalysis.Operations.LazyForEachLoopStatement : BaseForEachLoopStatement {
    private Lazy`1<IOperation> _lazyLoopControlVariable;
    private Lazy`1<IOperation> _lazyCollection;
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyNextVariables;
    private Lazy`1<IOperation> _lazyBody;
    public IOperation LoopControlVariable { get; }
    public IOperation Collection { get; }
    public ImmutableArray`1<IOperation> NextVariables { get; }
    public IOperation Body { get; }
    public LazyForEachLoopStatement(ImmutableArray`1<ILocalSymbol> locals, ILabelSymbol continueLabel, ILabelSymbol exitLabel, Lazy`1<IOperation> loopControlVariable, Lazy`1<IOperation> collection, Lazy`1<ImmutableArray`1<IOperation>> nextVariables, Lazy`1<IOperation> body, ForEachLoopOperationInfo info, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_LoopControlVariable();
    public virtual IOperation get_Collection();
    public virtual ImmutableArray`1<IOperation> get_NextVariables();
    public virtual IOperation get_Body();
}
internal class Microsoft.CodeAnalysis.Operations.LazyForLoopStatement : BaseForLoopStatement {
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyBefore;
    private Lazy`1<IOperation> _lazyCondition;
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyAtLoopBottom;
    private Lazy`1<IOperation> _lazyBody;
    public ImmutableArray`1<IOperation> Before { get; }
    public IOperation Condition { get; }
    public ImmutableArray`1<IOperation> AtLoopBottom { get; }
    public IOperation Body { get; }
    public LazyForLoopStatement(Lazy`1<ImmutableArray`1<IOperation>> before, Lazy`1<IOperation> condition, Lazy`1<ImmutableArray`1<IOperation>> atLoopBottom, ImmutableArray`1<ILocalSymbol> locals, ImmutableArray`1<ILocalSymbol> conditionLocals, ILabelSymbol continueLabel, ILabelSymbol exitLabel, Lazy`1<IOperation> body, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual ImmutableArray`1<IOperation> get_Before();
    public virtual IOperation get_Condition();
    public virtual ImmutableArray`1<IOperation> get_AtLoopBottom();
    public virtual IOperation get_Body();
}
internal class Microsoft.CodeAnalysis.Operations.LazyForToLoopStatement : BaseForToLoopStatement {
    private Lazy`1<IOperation> _lazyLoopControlVariable;
    private Lazy`1<IOperation> _lazyInitialValue;
    private Lazy`1<IOperation> _lazyLimitValue;
    private Lazy`1<IOperation> _lazyStepValue;
    private Lazy`1<IOperation> _lazyBody;
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyNextVariables;
    public IOperation LoopControlVariable { get; }
    public IOperation InitialValue { get; }
    public IOperation LimitValue { get; }
    public IOperation StepValue { get; }
    public IOperation Body { get; }
    public ImmutableArray`1<IOperation> NextVariables { get; }
    public LazyForToLoopStatement(ImmutableArray`1<ILocalSymbol> locals, bool isChecked, ValueTuple`2<ILocalSymbol, ForToLoopOperationUserDefinedInfo> info, ILabelSymbol continueLabel, ILabelSymbol exitLabel, Lazy`1<IOperation> loopControlVariable, Lazy`1<IOperation> initialValue, Lazy`1<IOperation> limitValue, Lazy`1<IOperation> stepValue, Lazy`1<IOperation> body, Lazy`1<ImmutableArray`1<IOperation>> nextVariables, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_LoopControlVariable();
    public virtual IOperation get_InitialValue();
    public virtual IOperation get_LimitValue();
    public virtual IOperation get_StepValue();
    public virtual IOperation get_Body();
    public virtual ImmutableArray`1<IOperation> get_NextVariables();
}
internal class Microsoft.CodeAnalysis.Operations.LazyIncrementExpression : BaseIncrementExpression {
    private Lazy`1<IOperation> _lazyTarget;
    public IOperation Target { get; }
    public LazyIncrementExpression(bool isDecrement, bool isPostfix, bool isLifted, bool isChecked, Lazy`1<IOperation> target, IMethodSymbol operatorMethod, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Target();
}
internal class Microsoft.CodeAnalysis.Operations.LazyInterpolatedStringExpression : BaseInterpolatedStringExpression {
    private Lazy`1<ImmutableArray`1<IInterpolatedStringContentOperation>> _lazyParts;
    public ImmutableArray`1<IInterpolatedStringContentOperation> Parts { get; }
    public LazyInterpolatedStringExpression(Lazy`1<ImmutableArray`1<IInterpolatedStringContentOperation>> parts, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual ImmutableArray`1<IInterpolatedStringContentOperation> get_Parts();
}
internal class Microsoft.CodeAnalysis.Operations.LazyInterpolatedStringText : BaseInterpolatedStringText {
    private Lazy`1<IOperation> _lazyText;
    public IOperation Text { get; }
    public LazyInterpolatedStringText(Lazy`1<IOperation> text, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Text();
}
internal class Microsoft.CodeAnalysis.Operations.LazyInterpolation : BaseInterpolation {
    private Lazy`1<IOperation> _lazyExpression;
    private Lazy`1<IOperation> _lazyAlignment;
    private Lazy`1<IOperation> _lazyFormatString;
    public IOperation Expression { get; }
    public IOperation Alignment { get; }
    public IOperation FormatString { get; }
    public LazyInterpolation(Lazy`1<IOperation> expression, Lazy`1<IOperation> alignment, Lazy`1<IOperation> formatString, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Expression();
    public virtual IOperation get_Alignment();
    public virtual IOperation get_FormatString();
}
internal class Microsoft.CodeAnalysis.Operations.LazyInvalidOperation : BaseInvalidOperation {
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyChildren;
    public IEnumerable`1<IOperation> Children { get; }
    public LazyInvalidOperation(Lazy`1<ImmutableArray`1<IOperation>> children, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IEnumerable`1<IOperation> get_Children();
}
internal class Microsoft.CodeAnalysis.Operations.LazyInvocationExpression : BaseInvocationExpression {
    private Lazy`1<IOperation> _lazyInstance;
    private Lazy`1<ImmutableArray`1<IArgumentOperation>> _lazyArguments;
    public IOperation Instance { get; }
    public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    public LazyInvocationExpression(IMethodSymbol targetMethod, Lazy`1<IOperation> instance, bool isVirtual, Lazy`1<ImmutableArray`1<IArgumentOperation>> arguments, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Instance();
    public virtual ImmutableArray`1<IArgumentOperation> get_Arguments();
}
internal class Microsoft.CodeAnalysis.Operations.LazyIsPatternExpression : BaseIsPatternExpression {
    private Lazy`1<IOperation> _lazyValue;
    private Lazy`1<IPatternOperation> _lazyPattern;
    public IOperation Value { get; }
    public IPatternOperation Pattern { get; }
    public LazyIsPatternExpression(Lazy`1<IOperation> value, Lazy`1<IPatternOperation> lazyPattern, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Value();
    public virtual IPatternOperation get_Pattern();
}
internal class Microsoft.CodeAnalysis.Operations.LazyIsTypeExpression : BaseIsTypeExpression {
    private Lazy`1<IOperation> _lazyOperand;
    public IOperation ValueOperand { get; }
    public LazyIsTypeExpression(Lazy`1<IOperation> operand, ITypeSymbol isType, bool isNotTypeExpression, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_ValueOperand();
}
internal class Microsoft.CodeAnalysis.Operations.LazyLabeledStatement : BaseLabeledStatement {
    private Lazy`1<IOperation> _lazyOperation;
    public IOperation Operation { get; }
    public LazyLabeledStatement(ILabelSymbol label, Lazy`1<IOperation> operation, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Operation();
}
internal class Microsoft.CodeAnalysis.Operations.LazyLocalFunctionStatement : BaseLocalFunctionStatement {
    private Lazy`1<IBlockOperation> _lazyBody;
    private Lazy`1<IBlockOperation> _lazyIgnoredBody;
    public IBlockOperation Body { get; }
    public IBlockOperation IgnoredBody { get; }
    public LazyLocalFunctionStatement(IMethodSymbol symbol, Lazy`1<IBlockOperation> body, Lazy`1<IBlockOperation> ignoredBody, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IBlockOperation get_Body();
    public virtual IBlockOperation get_IgnoredBody();
}
internal class Microsoft.CodeAnalysis.Operations.LazyLockStatement : BaseLockStatement {
    private Lazy`1<IOperation> _lazyLockedValue;
    private Lazy`1<IOperation> _lazyBody;
    public IOperation LockedValue { get; }
    public IOperation Body { get; }
    public LazyLockStatement(Lazy`1<IOperation> lockedValue, Lazy`1<IOperation> body, ILocalSymbol lockTakenSymbol, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_LockedValue();
    public virtual IOperation get_Body();
}
internal class Microsoft.CodeAnalysis.Operations.LazyMemberInitializerExpression : BaseMemberInitializerExpression {
    private Lazy`1<IOperation> _lazyInitializedMember;
    private Lazy`1<IObjectOrCollectionInitializerOperation> _lazyInitializer;
    public IOperation InitializedMember { get; }
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public LazyMemberInitializerExpression(Lazy`1<IOperation> initializedMember, Lazy`1<IObjectOrCollectionInitializerOperation> initializer, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_InitializedMember();
    public virtual IObjectOrCollectionInitializerOperation get_Initializer();
}
internal class Microsoft.CodeAnalysis.Operations.LazyMethodBodyOperation : BaseMethodBodyOperation {
    private Lazy`1<IBlockOperation> _lazyBlockBody;
    private Lazy`1<IBlockOperation> _lazyExpressionBody;
    public IBlockOperation BlockBody { get; }
    public IBlockOperation ExpressionBody { get; }
    public LazyMethodBodyOperation(SemanticModel semanticModel, SyntaxNode syntax, Lazy`1<IBlockOperation> blockBody, Lazy`1<IBlockOperation> expressionBody);
    public virtual IBlockOperation get_BlockBody();
    public virtual IBlockOperation get_ExpressionBody();
}
internal class Microsoft.CodeAnalysis.Operations.LazyMethodReferenceExpression : BaseMethodReferenceExpression {
    private Lazy`1<IOperation> _lazyInstance;
    public IOperation Instance { get; }
    public LazyMethodReferenceExpression(IMethodSymbol method, bool isVirtual, Lazy`1<IOperation> instance, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Instance();
}
internal class Microsoft.CodeAnalysis.Operations.LazyNameOfExpression : BaseNameOfExpression {
    private Lazy`1<IOperation> _lazyArgument;
    public IOperation Argument { get; }
    public LazyNameOfExpression(Lazy`1<IOperation> argument, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Argument();
}
internal class Microsoft.CodeAnalysis.Operations.LazyNoPiaObjectCreationOperation : BaseNoPiaObjectCreationOperation {
    private Lazy`1<IObjectOrCollectionInitializerOperation> _lazyInitializer;
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public LazyNoPiaObjectCreationOperation(Lazy`1<IObjectOrCollectionInitializerOperation> initializer, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IObjectOrCollectionInitializerOperation get_Initializer();
}
internal class Microsoft.CodeAnalysis.Operations.LazyObjectCreationExpression : BaseObjectCreationExpression {
    private Lazy`1<IObjectOrCollectionInitializerOperation> _lazyInitializer;
    private Lazy`1<ImmutableArray`1<IArgumentOperation>> _lazyArguments;
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    public LazyObjectCreationExpression(IMethodSymbol constructor, Lazy`1<IObjectOrCollectionInitializerOperation> initializer, Lazy`1<ImmutableArray`1<IArgumentOperation>> arguments, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IObjectOrCollectionInitializerOperation get_Initializer();
    public virtual ImmutableArray`1<IArgumentOperation> get_Arguments();
}
internal class Microsoft.CodeAnalysis.Operations.LazyObjectOrCollectionInitializerExpression : BaseObjectOrCollectionInitializerExpression {
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyInitializers;
    public ImmutableArray`1<IOperation> Initializers { get; }
    public LazyObjectOrCollectionInitializerExpression(Lazy`1<ImmutableArray`1<IOperation>> initializers, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual ImmutableArray`1<IOperation> get_Initializers();
}
internal class Microsoft.CodeAnalysis.Operations.LazyParameterInitializer : BaseParameterInitializer {
    private Lazy`1<IOperation> _lazyValue;
    public IOperation Value { get; }
    public LazyParameterInitializer(ImmutableArray`1<ILocalSymbol> locals, IParameterSymbol parameter, Lazy`1<IOperation> value, OperationKind kind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.LazyParenthesizedExpression : BaseParenthesizedExpression {
    private Lazy`1<IOperation> _lazyOperand;
    public IOperation Operand { get; }
    public LazyParenthesizedExpression(Lazy`1<IOperation> operand, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Operand();
}
internal class Microsoft.CodeAnalysis.Operations.LazyPatternCaseClause : BasePatternCaseClause {
    private Lazy`1<IPatternOperation> _lazyPattern;
    private Lazy`1<IOperation> _lazyGuardExpression;
    public IPatternOperation Pattern { get; }
    public IOperation Guard { get; }
    public LazyPatternCaseClause(ILabelSymbol label, Lazy`1<IPatternOperation> lazyPattern, Lazy`1<IOperation> lazyGuardExpression, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IPatternOperation get_Pattern();
    public virtual IOperation get_Guard();
}
internal class Microsoft.CodeAnalysis.Operations.LazyPropertyInitializer : BasePropertyInitializer {
    private Lazy`1<IOperation> _lazyValue;
    public IOperation Value { get; }
    public LazyPropertyInitializer(ImmutableArray`1<ILocalSymbol> locals, ImmutableArray`1<IPropertySymbol> initializedProperties, Lazy`1<IOperation> value, OperationKind kind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.LazyPropertyReferenceExpression : BasePropertyReferenceExpression {
    private Lazy`1<IOperation> _lazyInstance;
    private Lazy`1<ImmutableArray`1<IArgumentOperation>> _lazyArguments;
    public IOperation Instance { get; }
    public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    public LazyPropertyReferenceExpression(IPropertySymbol property, Lazy`1<IOperation> instance, Lazy`1<ImmutableArray`1<IArgumentOperation>> arguments, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Instance();
    public virtual ImmutableArray`1<IArgumentOperation> get_Arguments();
}
internal class Microsoft.CodeAnalysis.Operations.LazyRaiseEventStatement : BaseRaiseEventStatement {
    private Lazy`1<IEventReferenceOperation> _lazyEventReference;
    private Lazy`1<ImmutableArray`1<IArgumentOperation>> _lazyArguments;
    public IEventReferenceOperation EventReference { get; }
    public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    public LazyRaiseEventStatement(Lazy`1<IEventReferenceOperation> eventReference, Lazy`1<ImmutableArray`1<IArgumentOperation>> arguments, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IEventReferenceOperation get_EventReference();
    public virtual ImmutableArray`1<IArgumentOperation> get_Arguments();
}
internal class Microsoft.CodeAnalysis.Operations.LazyRangeCaseClause : BaseRangeCaseClause {
    private Lazy`1<IOperation> _lazyMinimumValue;
    private Lazy`1<IOperation> _lazyMaximumValue;
    public IOperation MinimumValue { get; }
    public IOperation MaximumValue { get; }
    public LazyRangeCaseClause(Lazy`1<IOperation> minimumValue, Lazy`1<IOperation> maximumValue, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_MinimumValue();
    public virtual IOperation get_MaximumValue();
}
internal class Microsoft.CodeAnalysis.Operations.LazyRelationalCaseClause : BaseRelationalCaseClause {
    private Lazy`1<IOperation> _lazyValue;
    public IOperation Value { get; }
    public LazyRelationalCaseClause(Lazy`1<IOperation> value, BinaryOperatorKind relation, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.LazyReturnStatement : BaseReturnStatement {
    private Lazy`1<IOperation> _lazyReturnedValue;
    public IOperation ReturnedValue { get; }
    public LazyReturnStatement(OperationKind kind, Lazy`1<IOperation> returnedValue, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_ReturnedValue();
}
internal class Microsoft.CodeAnalysis.Operations.LazySimpleAssignmentExpression : BaseSimpleAssignmentExpression {
    private Lazy`1<IOperation> _lazyTarget;
    private Lazy`1<IOperation> _lazyValue;
    public IOperation Target { get; }
    public IOperation Value { get; }
    public LazySimpleAssignmentExpression(Lazy`1<IOperation> target, bool isRef, Lazy`1<IOperation> value, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Target();
    public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.LazySingleValueCaseClause : BaseSingleValueCaseClause {
    private Lazy`1<IOperation> _lazyValue;
    public IOperation Value { get; }
    public LazySingleValueCaseClause(ILabelSymbol label, Lazy`1<IOperation> value, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.LazySwitchCase : BaseSwitchCase {
    private Lazy`1<ImmutableArray`1<ICaseClauseOperation>> _lazyClauses;
    private Lazy`1<IOperation> _lazyCondition;
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyBody;
    public ImmutableArray`1<ICaseClauseOperation> Clauses { get; }
    public IOperation Condition { get; }
    public ImmutableArray`1<IOperation> Body { get; }
    public LazySwitchCase(ImmutableArray`1<ILocalSymbol> locals, Lazy`1<IOperation> condition, Lazy`1<ImmutableArray`1<ICaseClauseOperation>> clauses, Lazy`1<ImmutableArray`1<IOperation>> body, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual ImmutableArray`1<ICaseClauseOperation> get_Clauses();
    public virtual IOperation get_Condition();
    public virtual ImmutableArray`1<IOperation> get_Body();
}
internal class Microsoft.CodeAnalysis.Operations.LazySwitchStatement : BaseSwitchStatement {
    private Lazy`1<IOperation> _lazyValue;
    private Lazy`1<ImmutableArray`1<ISwitchCaseOperation>> _lazyCases;
    public IOperation Value { get; }
    public ImmutableArray`1<ISwitchCaseOperation> Cases { get; }
    public LazySwitchStatement(ImmutableArray`1<ILocalSymbol> locals, Lazy`1<IOperation> value, Lazy`1<ImmutableArray`1<ISwitchCaseOperation>> cases, ILabelSymbol exitLabel, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Value();
    public virtual ImmutableArray`1<ISwitchCaseOperation> get_Cases();
}
internal class Microsoft.CodeAnalysis.Operations.LazyThrowExpression : BaseThrowExpression {
    private Lazy`1<IOperation> _lazyException;
    public IOperation Exception { get; }
    public LazyThrowExpression(Lazy`1<IOperation> exception, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Exception();
}
internal class Microsoft.CodeAnalysis.Operations.LazyTranslatedQueryExpression : BaseTranslatedQueryExpression {
    private Lazy`1<IOperation> _lazyOperation;
    public IOperation Operation { get; }
    public LazyTranslatedQueryExpression(Lazy`1<IOperation> operation, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Operation();
}
internal class Microsoft.CodeAnalysis.Operations.LazyTryStatement : BaseTryStatement {
    private Lazy`1<IBlockOperation> _lazyBody;
    private Lazy`1<ImmutableArray`1<ICatchClauseOperation>> _lazyCatches;
    private Lazy`1<IBlockOperation> _lazyFinallyHandler;
    public IBlockOperation Body { get; }
    public ImmutableArray`1<ICatchClauseOperation> Catches { get; }
    public IBlockOperation Finally { get; }
    public LazyTryStatement(Lazy`1<IBlockOperation> body, Lazy`1<ImmutableArray`1<ICatchClauseOperation>> catches, Lazy`1<IBlockOperation> finallyHandler, ILabelSymbol exitLabel, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IBlockOperation get_Body();
    public virtual ImmutableArray`1<ICatchClauseOperation> get_Catches();
    public virtual IBlockOperation get_Finally();
}
internal class Microsoft.CodeAnalysis.Operations.LazyTupleBinaryOperatorExpression : BaseTupleBinaryOperatorExpression {
    private Lazy`1<IOperation> _lazyLeftOperand;
    private Lazy`1<IOperation> _lazyRightOperand;
    public IOperation LeftOperand { get; }
    public IOperation RightOperand { get; }
    public LazyTupleBinaryOperatorExpression(BinaryOperatorKind operatorKind, Lazy`1<IOperation> leftOperand, Lazy`1<IOperation> rightOperand, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_LeftOperand();
    public virtual IOperation get_RightOperand();
}
internal class Microsoft.CodeAnalysis.Operations.LazyTupleExpression : BaseTupleExpression {
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyElements;
    public ImmutableArray`1<IOperation> Elements { get; }
    public LazyTupleExpression(Lazy`1<ImmutableArray`1<IOperation>> elements, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, ITypeSymbol naturalType, Optional`1<object> constantValue, bool isImplicit);
    public virtual ImmutableArray`1<IOperation> get_Elements();
}
internal class Microsoft.CodeAnalysis.Operations.LazyTypeParameterObjectCreationExpression : BaseTypeParameterObjectCreationExpression {
    private Lazy`1<IObjectOrCollectionInitializerOperation> _lazyInitializer;
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public LazyTypeParameterObjectCreationExpression(Lazy`1<IObjectOrCollectionInitializerOperation> initializer, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IObjectOrCollectionInitializerOperation get_Initializer();
}
internal class Microsoft.CodeAnalysis.Operations.LazyUnaryOperatorExpression : BaseUnaryOperatorExpression {
    private Lazy`1<IOperation> _lazyOperand;
    public IOperation Operand { get; }
    public LazyUnaryOperatorExpression(UnaryOperatorKind unaryOperationKind, Lazy`1<IOperation> operand, bool isLifted, bool isChecked, IMethodSymbol operatorMethod, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Operand();
}
internal class Microsoft.CodeAnalysis.Operations.LazyUsingStatement : BaseUsingStatement {
    private Lazy`1<IOperation> _lazyResources;
    private Lazy`1<IOperation> _lazyBody;
    public IOperation Resources { get; }
    public IOperation Body { get; }
    public LazyUsingStatement(Lazy`1<IOperation> resources, Lazy`1<IOperation> body, ImmutableArray`1<ILocalSymbol> locals, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Resources();
    public virtual IOperation get_Body();
}
internal class Microsoft.CodeAnalysis.Operations.LazyVariableDeclaration : BaseVariableDeclaration {
    private Lazy`1<ImmutableArray`1<IVariableDeclaratorOperation>> _lazyDeclarators;
    private Lazy`1<IVariableInitializerOperation> _lazyInitializer;
    public ImmutableArray`1<IVariableDeclaratorOperation> Declarators { get; }
    public IVariableInitializerOperation Initializer { get; }
    public LazyVariableDeclaration(Lazy`1<ImmutableArray`1<IVariableDeclaratorOperation>> declarators, Lazy`1<IVariableInitializerOperation> initializer, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual ImmutableArray`1<IVariableDeclaratorOperation> get_Declarators();
    public virtual IVariableInitializerOperation get_Initializer();
}
internal class Microsoft.CodeAnalysis.Operations.LazyVariableDeclarationGroupOperation : BaseVariableDeclarationGroupOperation {
    private Lazy`1<ImmutableArray`1<IVariableDeclarationOperation>> _lazyDeclarations;
    public ImmutableArray`1<IVariableDeclarationOperation> Declarations { get; }
    public LazyVariableDeclarationGroupOperation(Lazy`1<ImmutableArray`1<IVariableDeclarationOperation>> declarations, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual ImmutableArray`1<IVariableDeclarationOperation> get_Declarations();
}
internal class Microsoft.CodeAnalysis.Operations.LazyVariableDeclarator : BaseVariableDeclarator {
    private Lazy`1<IVariableInitializerOperation> _lazyInitializer;
    private Lazy`1<ImmutableArray`1<IOperation>> _lazyIgnoredArguments;
    public IVariableInitializerOperation Initializer { get; }
    public ImmutableArray`1<IOperation> IgnoredArguments { get; }
    public LazyVariableDeclarator(ILocalSymbol symbol, Lazy`1<IVariableInitializerOperation> initializer, Lazy`1<ImmutableArray`1<IOperation>> ignoredArguments, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IVariableInitializerOperation get_Initializer();
    public virtual ImmutableArray`1<IOperation> get_IgnoredArguments();
}
internal class Microsoft.CodeAnalysis.Operations.LazyVariableInitializer : BaseVariableInitializer {
    private Lazy`1<IOperation> _lazyValue;
    public IOperation Value { get; }
    public LazyVariableInitializer(Lazy`1<IOperation> value, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.LazyWhileLoopStatement : BaseWhileLoopStatement {
    private Lazy`1<IOperation> _lazyCondition;
    private Lazy`1<IOperation> _lazyBody;
    private Lazy`1<IOperation> _lazyIgnoredCondition;
    public IOperation Condition { get; }
    public IOperation Body { get; }
    public IOperation IgnoredCondition { get; }
    public LazyWhileLoopStatement(Lazy`1<IOperation> condition, Lazy`1<IOperation> body, Lazy`1<IOperation> ignoredCondition, ImmutableArray`1<ILocalSymbol> locals, ILabelSymbol continueLabel, ILabelSymbol exitLabel, bool conditionIsTop, bool conditionIsUntil, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Condition();
    public virtual IOperation get_Body();
    public virtual IOperation get_IgnoredCondition();
}
internal class Microsoft.CodeAnalysis.Operations.LazyWithStatement : BaseWithStatement {
    private Lazy`1<IOperation> _lazyBody;
    private Lazy`1<IOperation> _lazyValue;
    public IOperation Body { get; }
    public IOperation Value { get; }
    public LazyWithStatement(Lazy`1<IOperation> body, Lazy`1<IOperation> value, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IOperation get_Body();
    public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.LiteralExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public LiteralExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.LocalFunctionStatement : BaseLocalFunctionStatement {
    [CompilerGeneratedAttribute]
private IBlockOperation <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlockOperation <IgnoredBody>k__BackingField;
    public IBlockOperation Body { get; }
    public IBlockOperation IgnoredBody { get; }
    public LocalFunctionStatement(IMethodSymbol symbol, IBlockOperation body, IBlockOperation ignoredBody, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IBlockOperation get_Body();
    [CompilerGeneratedAttribute]
public virtual IBlockOperation get_IgnoredBody();
}
internal class Microsoft.CodeAnalysis.Operations.LocalReferenceExpression : Operation {
    [CompilerGeneratedAttribute]
private ILocalSymbol <Local>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeclaration>k__BackingField;
    public ILocalSymbol Local { get; }
    public bool IsDeclaration { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public LocalReferenceExpression(ILocalSymbol local, bool isDeclaration, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ILocalSymbol get_Local();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDeclaration();
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.LockStatement : BaseLockStatement {
    [CompilerGeneratedAttribute]
private IOperation <LockedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Body>k__BackingField;
    public IOperation LockedValue { get; }
    public IOperation Body { get; }
    public LockStatement(IOperation lockedValue, IOperation body, ILocalSymbol lockTakenSymbol, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_LockedValue();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Body();
}
public enum Microsoft.CodeAnalysis.Operations.LoopKind : Enum {
    public int value__;
    public static LoopKind None;
    public static LoopKind While;
    public static LoopKind For;
    public static LoopKind ForTo;
    public static LoopKind ForEach;
}
internal abstract class Microsoft.CodeAnalysis.Operations.LoopStatement : Operation {
    [CompilerGeneratedAttribute]
private LoopKind <LoopKind>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ILocalSymbol> <Locals>k__BackingField;
    [CompilerGeneratedAttribute]
private ILabelSymbol <ContinueLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private ILabelSymbol <ExitLabel>k__BackingField;
    public LoopKind LoopKind { get; }
    public ImmutableArray`1<ILocalSymbol> Locals { get; }
    public ILabelSymbol ContinueLabel { get; }
    public ILabelSymbol ExitLabel { get; }
    public IOperation Body { get; }
    protected LoopStatement(LoopKind loopKind, ImmutableArray`1<ILocalSymbol> locals, ILabelSymbol continueLabel, ILabelSymbol exitLabel, OperationKind kind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual LoopKind get_LoopKind();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ILocalSymbol> get_Locals();
    [CompilerGeneratedAttribute]
public sealed virtual ILabelSymbol get_ContinueLabel();
    [CompilerGeneratedAttribute]
public sealed virtual ILabelSymbol get_ExitLabel();
    public abstract virtual IOperation get_Body();
}
internal class Microsoft.CodeAnalysis.Operations.MemberInitializerExpression : BaseMemberInitializerExpression {
    [CompilerGeneratedAttribute]
private IOperation <InitializedMember>k__BackingField;
    [CompilerGeneratedAttribute]
private IObjectOrCollectionInitializerOperation <Initializer>k__BackingField;
    public IOperation InitializedMember { get; }
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public MemberInitializerExpression(IOperation initializedMember, IObjectOrCollectionInitializerOperation initializer, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_InitializedMember();
    [CompilerGeneratedAttribute]
public virtual IObjectOrCollectionInitializerOperation get_Initializer();
}
internal abstract class Microsoft.CodeAnalysis.Operations.MemberReferenceExpression : Operation {
    [CompilerGeneratedAttribute]
private ISymbol <Member>k__BackingField;
    public IOperation Instance { get; }
    public ISymbol Member { get; }
    protected MemberReferenceExpression(ISymbol member, OperationKind kind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public abstract virtual IOperation get_Instance();
    [CompilerGeneratedAttribute]
public sealed virtual ISymbol get_Member();
}
internal class Microsoft.CodeAnalysis.Operations.MethodBodyOperation : BaseMethodBodyOperation {
    [CompilerGeneratedAttribute]
private IBlockOperation <BlockBody>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlockOperation <ExpressionBody>k__BackingField;
    public IBlockOperation BlockBody { get; }
    public IBlockOperation ExpressionBody { get; }
    public MethodBodyOperation(SemanticModel semanticModel, SyntaxNode syntax, IBlockOperation blockBody, IBlockOperation expressionBody);
    [CompilerGeneratedAttribute]
public virtual IBlockOperation get_BlockBody();
    [CompilerGeneratedAttribute]
public virtual IBlockOperation get_ExpressionBody();
}
internal class Microsoft.CodeAnalysis.Operations.MethodReferenceExpression : BaseMethodReferenceExpression {
    [CompilerGeneratedAttribute]
private IOperation <Instance>k__BackingField;
    public IOperation Instance { get; }
    public MethodReferenceExpression(IMethodSymbol method, bool isVirtual, IOperation instance, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Instance();
}
internal class Microsoft.CodeAnalysis.Operations.NameOfExpression : BaseNameOfExpression {
    [CompilerGeneratedAttribute]
private IOperation <Argument>k__BackingField;
    public IOperation Argument { get; }
    public NameOfExpression(IOperation argument, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Argument();
}
internal class Microsoft.CodeAnalysis.Operations.NoPiaObjectCreationOperation : BaseNoPiaObjectCreationOperation {
    [CompilerGeneratedAttribute]
private IObjectOrCollectionInitializerOperation <Initializer>k__BackingField;
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public NoPiaObjectCreationOperation(IObjectOrCollectionInitializerOperation initializer, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IObjectOrCollectionInitializerOperation get_Initializer();
}
internal class Microsoft.CodeAnalysis.Operations.ObjectCreationExpression : BaseObjectCreationExpression {
    [CompilerGeneratedAttribute]
private IObjectOrCollectionInitializerOperation <Initializer>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IArgumentOperation> <Arguments>k__BackingField;
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    public ObjectCreationExpression(IMethodSymbol constructor, IObjectOrCollectionInitializerOperation initializer, ImmutableArray`1<IArgumentOperation> arguments, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IObjectOrCollectionInitializerOperation get_Initializer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IArgumentOperation> get_Arguments();
}
internal class Microsoft.CodeAnalysis.Operations.ObjectOrCollectionInitializerExpression : BaseObjectOrCollectionInitializerExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <Initializers>k__BackingField;
    public ImmutableArray`1<IOperation> Initializers { get; }
    public ObjectOrCollectionInitializerExpression(ImmutableArray`1<IOperation> initializers, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IOperation> get_Initializers();
}
internal class Microsoft.CodeAnalysis.Operations.OmittedArgumentExpression : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public OmittedArgumentExpression(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.OperationCloner : OperationVisitor`2<object, IOperation> {
    private static OperationCloner s_instance;
    private static OperationCloner();
    public static T CloneOperation(T operation);
    private T Visit(T node);
    public IOperation Visit(IOperation operation);
    public virtual IOperation DefaultVisit(IOperation operation, object argument);
    internal virtual IOperation VisitNoneOperation(IOperation operation, object argument);
    private ImmutableArray`1<T> VisitArray(ImmutableArray`1<T> nodes);
    public virtual IOperation VisitBlock(IBlockOperation operation, object argument);
    public virtual IOperation VisitVariableDeclarationGroup(IVariableDeclarationGroupOperation operation, object argument);
    public virtual IOperation VisitVariableDeclarator(IVariableDeclaratorOperation operation, object argument);
    public virtual IOperation VisitVariableDeclaration(IVariableDeclarationOperation operation, object argument);
    public virtual IOperation VisitConversion(IConversionOperation operation, object argument);
    public virtual IOperation VisitSwitch(ISwitchOperation operation, object argument);
    public virtual IOperation VisitSwitchCase(ISwitchCaseOperation operation, object argument);
    public virtual IOperation VisitSingleValueCaseClause(ISingleValueCaseClauseOperation operation, object argument);
    public virtual IOperation VisitRelationalCaseClause(IRelationalCaseClauseOperation operation, object argument);
    public virtual IOperation VisitRangeCaseClause(IRangeCaseClauseOperation operation, object argument);
    public virtual IOperation VisitDefaultCaseClause(IDefaultCaseClauseOperation operation, object argument);
    public virtual IOperation VisitWhileLoop(IWhileLoopOperation operation, object argument);
    public virtual IOperation VisitForLoop(IForLoopOperation operation, object argument);
    public virtual IOperation VisitForToLoop(IForToLoopOperation operation, object argument);
    public virtual IOperation VisitForEachLoop(IForEachLoopOperation operation, object argument);
    public virtual IOperation VisitLabeled(ILabeledOperation operation, object argument);
    public virtual IOperation VisitBranch(IBranchOperation operation, object argument);
    public virtual IOperation VisitEmpty(IEmptyOperation operation, object argument);
    public virtual IOperation VisitReturn(IReturnOperation operation, object argument);
    public virtual IOperation VisitLock(ILockOperation operation, object argument);
    public virtual IOperation VisitTry(ITryOperation operation, object argument);
    public virtual IOperation VisitCatchClause(ICatchClauseOperation operation, object argument);
    public virtual IOperation VisitUsing(IUsingOperation operation, object argument);
    internal virtual IOperation VisitFixed(IFixedOperation operation, object argument);
    internal virtual IOperation VisitAggregateQuery(IAggregateQueryOperation operation, object argument);
    public virtual IOperation VisitExpressionStatement(IExpressionStatementOperation operation, object argument);
    internal virtual IOperation VisitWith(IWithOperation operation, object argument);
    public virtual IOperation VisitStop(IStopOperation operation, object argument);
    public virtual IOperation VisitEnd(IEndOperation operation, object argument);
    public virtual IOperation VisitInvocation(IInvocationOperation operation, object argument);
    public virtual IOperation VisitArgument(IArgumentOperation operation, object argument);
    public virtual IOperation VisitOmittedArgument(IOmittedArgumentOperation operation, object argument);
    public virtual IOperation VisitArrayElementReference(IArrayElementReferenceOperation operation, object argument);
    public virtual IOperation VisitLocalReference(ILocalReferenceOperation operation, object argument);
    public virtual IOperation VisitParameterReference(IParameterReferenceOperation operation, object argument);
    public virtual IOperation VisitInstanceReference(IInstanceReferenceOperation operation, object argument);
    public virtual IOperation VisitFieldReference(IFieldReferenceOperation operation, object argument);
    public virtual IOperation VisitMethodReference(IMethodReferenceOperation operation, object argument);
    public virtual IOperation VisitPropertyReference(IPropertyReferenceOperation operation, object argument);
    public virtual IOperation VisitEventReference(IEventReferenceOperation operation, object argument);
    public virtual IOperation VisitEventAssignment(IEventAssignmentOperation operation, object argument);
    public virtual IOperation VisitConditionalAccess(IConditionalAccessOperation operation, object argument);
    public virtual IOperation VisitConditionalAccessInstance(IConditionalAccessInstanceOperation operation, object argument);
    internal virtual IOperation VisitPlaceholder(IPlaceholderOperation operation, object argument);
    public virtual IOperation VisitUnaryOperator(IUnaryOperation operation, object argument);
    public virtual IOperation VisitBinaryOperator(IBinaryOperation operation, object argument);
    public virtual IOperation VisitTupleBinaryOperator(ITupleBinaryOperation operation, object argument);
    public virtual IOperation VisitCompoundAssignment(ICompoundAssignmentOperation operation, object argument);
    public virtual IOperation VisitConditional(IConditionalOperation operation, object argument);
    public virtual IOperation VisitCoalesce(ICoalesceOperation operation, object argument);
    public virtual IOperation VisitIsType(IIsTypeOperation operation, object argument);
    public virtual IOperation VisitSizeOf(ISizeOfOperation operation, object argument);
    public virtual IOperation VisitTypeOf(ITypeOfOperation operation, object argument);
    public virtual IOperation VisitAnonymousFunction(IAnonymousFunctionOperation operation, object argument);
    public virtual IOperation VisitFlowAnonymousFunction(IFlowAnonymousFunctionOperation operation, object argument);
    public virtual IOperation VisitDelegateCreation(IDelegateCreationOperation operation, object argument);
    public virtual IOperation VisitLiteral(ILiteralOperation operation, object argument);
    public virtual IOperation VisitAwait(IAwaitOperation operation, object argument);
    public virtual IOperation VisitNameOf(INameOfOperation operation, object argument);
    public virtual IOperation VisitThrow(IThrowOperation operation, object argument);
    public virtual IOperation VisitAddressOf(IAddressOfOperation operation, object argument);
    public virtual IOperation VisitObjectCreation(IObjectCreationOperation operation, object argument);
    public virtual IOperation VisitAnonymousObjectCreation(IAnonymousObjectCreationOperation operation, object argument);
    public virtual IOperation VisitObjectOrCollectionInitializer(IObjectOrCollectionInitializerOperation operation, object argument);
    public virtual IOperation VisitMemberInitializer(IMemberInitializerOperation operation, object argument);
    public virtual IOperation VisitFieldInitializer(IFieldInitializerOperation operation, object argument);
    public virtual IOperation VisitVariableInitializer(IVariableInitializerOperation operation, object argument);
    public virtual IOperation VisitPropertyInitializer(IPropertyInitializerOperation operation, object argument);
    public virtual IOperation VisitParameterInitializer(IParameterInitializerOperation operation, object argument);
    public virtual IOperation VisitArrayCreation(IArrayCreationOperation operation, object argument);
    public virtual IOperation VisitArrayInitializer(IArrayInitializerOperation operation, object argument);
    public virtual IOperation VisitSimpleAssignment(ISimpleAssignmentOperation operation, object argument);
    public virtual IOperation VisitDeconstructionAssignment(IDeconstructionAssignmentOperation operation, object argument);
    public virtual IOperation VisitDeclarationExpression(IDeclarationExpressionOperation operation, object argument);
    public virtual IOperation VisitIncrementOrDecrement(IIncrementOrDecrementOperation operation, object argument);
    public virtual IOperation VisitParenthesized(IParenthesizedOperation operation, object argument);
    public virtual IOperation VisitDynamicMemberReference(IDynamicMemberReferenceOperation operation, object argument);
    public virtual IOperation VisitDynamicObjectCreation(IDynamicObjectCreationOperation operation, object argument);
    public virtual IOperation VisitDynamicInvocation(IDynamicInvocationOperation operation, object argument);
    public virtual IOperation VisitDynamicIndexerAccess(IDynamicIndexerAccessOperation operation, object argument);
    public virtual IOperation VisitDefaultValue(IDefaultValueOperation operation, object argument);
    public virtual IOperation VisitTypeParameterObjectCreation(ITypeParameterObjectCreationOperation operation, object argument);
    internal virtual IOperation VisitNoPiaObjectCreation(INoPiaObjectCreationOperation operation, object argument);
    public virtual IOperation VisitInvalid(IInvalidOperation operation, object argument);
    public virtual IOperation VisitLocalFunction(ILocalFunctionOperation operation, object argument);
    public virtual IOperation VisitInterpolatedString(IInterpolatedStringOperation operation, object argument);
    public virtual IOperation VisitInterpolatedStringText(IInterpolatedStringTextOperation operation, object argument);
    public virtual IOperation VisitInterpolation(IInterpolationOperation operation, object argument);
    public virtual IOperation VisitIsPattern(IIsPatternOperation operation, object argument);
    public virtual IOperation VisitConstantPattern(IConstantPatternOperation operation, object argument);
    public virtual IOperation VisitDeclarationPattern(IDeclarationPatternOperation operation, object argument);
    public virtual IOperation VisitPatternCaseClause(IPatternCaseClauseOperation operation, object argument);
    public virtual IOperation VisitTuple(ITupleOperation operation, object argument);
    public virtual IOperation VisitTranslatedQuery(ITranslatedQueryOperation operation, object argument);
    public virtual IOperation VisitRaiseEvent(IRaiseEventOperation operation, object argument);
    public virtual IOperation VisitConstructorBodyOperation(IConstructorBodyOperation operation, object argument);
    public virtual IOperation VisitMethodBodyOperation(IMethodBodyOperation operation, object argument);
    public virtual IOperation VisitDiscardOperation(IDiscardOperation operation, object argument);
    public virtual IOperation VisitFlowCapture(IFlowCaptureOperation operation, object argument);
    public virtual IOperation VisitFlowCaptureReference(IFlowCaptureReferenceOperation operation, object argument);
    public virtual IOperation VisitIsNull(IIsNullOperation operation, object argument);
    public virtual IOperation VisitCaughtException(ICaughtExceptionOperation operation, object argument);
    public virtual IOperation VisitStaticLocalInitializationSemaphore(IStaticLocalInitializationSemaphoreOperation operation, object argument);
    [CompilerGeneratedAttribute]
private T <VisitArray>b__7_0(T n);
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.Operations.OperationExtensions : object {
    [ExtensionAttribute]
internal static bool HasErrors(IOperation operation, Compilation compilation, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<IOperation> Descendants(IOperation operation);
    [ExtensionAttribute]
public static IEnumerable`1<IOperation> DescendantsAndSelf(IOperation operation);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Operations.OperationExtensions/<Descendants>d__3")]
private static IEnumerable`1<IOperation> Descendants(IOperation operation, bool includeSelf);
    [ExtensionAttribute]
public static ImmutableArray`1<ILocalSymbol> GetDeclaredVariables(IVariableDeclarationGroupOperation declarationGroup);
    [ExtensionAttribute]
public static ImmutableArray`1<ILocalSymbol> GetDeclaredVariables(IVariableDeclarationOperation declaration);
    [ExtensionAttribute]
private static void GetDeclaredVariables(IVariableDeclarationOperation declaration, ArrayBuilder`1<ILocalSymbol> arrayBuilder);
    [ExtensionAttribute]
public static IVariableInitializerOperation GetVariableInitializer(IVariableDeclaratorOperation declarationOperation);
    [ExtensionAttribute]
public static string GetArgumentName(IDynamicInvocationOperation dynamicOperation, int index);
    [ExtensionAttribute]
public static string GetArgumentName(IDynamicIndexerAccessOperation dynamicOperation, int index);
    [ExtensionAttribute]
public static string GetArgumentName(IDynamicObjectCreationOperation dynamicOperation, int index);
    [ExtensionAttribute]
internal static string GetArgumentName(HasDynamicArgumentsExpression dynamicOperation, int index);
    [ExtensionAttribute]
public static Nullable`1<RefKind> GetArgumentRefKind(IDynamicInvocationOperation dynamicOperation, int index);
    [ExtensionAttribute]
public static Nullable`1<RefKind> GetArgumentRefKind(IDynamicIndexerAccessOperation dynamicOperation, int index);
    [ExtensionAttribute]
public static Nullable`1<RefKind> GetArgumentRefKind(IDynamicObjectCreationOperation dynamicOperation, int index);
    [ExtensionAttribute]
internal static Nullable`1<RefKind> GetArgumentRefKind(HasDynamicArgumentsExpression dynamicOperation, int index);
    [ExtensionAttribute]
internal static IOperation GetRootOperation(IOperation operation);
}
internal static class Microsoft.CodeAnalysis.Operations.OperationFactory : object {
    [CompilerGeneratedAttribute]
private static Lazy`1<IOperation> <NullOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private static Lazy`1<IVariableInitializerOperation> <NullInitializer>k__BackingField;
    public static Lazy`1<IOperation> NullOperation { get; }
    public static Lazy`1<IVariableInitializerOperation> NullInitializer { get; }
    private static OperationFactory();
    public static IVariableInitializerOperation CreateVariableInitializer(SyntaxNode syntax, IOperation initializerValue, SemanticModel semanticModel, bool isImplicit);
    public static IConditionalOperation CreateConditionalExpression(IOperation condition, IOperation whenTrue, IOperation whenFalse, bool isRef, ITypeSymbol resultType, SemanticModel semanticModel, SyntaxNode syntax, bool isImplicit);
    public static IExpressionStatementOperation CreateSimpleAssignmentExpressionStatement(IOperation target, bool isRef, IOperation value, SemanticModel semanticModel, SyntaxNode syntax, bool isImplicit);
    public static ILiteralOperation CreateLiteralExpression(long value, ITypeSymbol resultType, SemanticModel semanticModel, SyntaxNode syntax, bool isImplicit);
    public static ILiteralOperation CreateLiteralExpression(ConstantValue value, ITypeSymbol resultType, SemanticModel semanticModel, SyntaxNode syntax, bool isImplicit);
    public static IBinaryOperation CreateBinaryOperatorExpression(BinaryOperatorKind operatorKind, IOperation left, IOperation right, ITypeSymbol resultType, SemanticModel semanticModel, SyntaxNode syntax, bool isLifted, bool isChecked, bool isCompareText, bool isImplicit);
    public static IInvalidOperation CreateInvalidExpression(SemanticModel semanticModel, SyntaxNode syntax, bool isImplicit);
    public static IInvalidOperation CreateInvalidExpression(SemanticModel semanticModel, SyntaxNode syntax, ImmutableArray`1<IOperation> children, bool isImplicit);
    [CompilerGeneratedAttribute]
public static Lazy`1<IOperation> get_NullOperation();
    [CompilerGeneratedAttribute]
public static Lazy`1<IVariableInitializerOperation> get_NullInitializer();
}
public abstract class Microsoft.CodeAnalysis.Operations.OperationVisitor : object {
    public virtual void Visit(IOperation operation);
    public virtual void DefaultVisit(IOperation operation);
    internal virtual void VisitNoneOperation(IOperation operation);
    public virtual void VisitBlock(IBlockOperation operation);
    public virtual void VisitVariableDeclarationGroup(IVariableDeclarationGroupOperation operation);
    public virtual void VisitVariableDeclarator(IVariableDeclaratorOperation operation);
    public virtual void VisitVariableDeclaration(IVariableDeclarationOperation operation);
    public virtual void VisitSwitch(ISwitchOperation operation);
    public virtual void VisitSwitchCase(ISwitchCaseOperation operation);
    public virtual void VisitSingleValueCaseClause(ISingleValueCaseClauseOperation operation);
    public virtual void VisitRelationalCaseClause(IRelationalCaseClauseOperation operation);
    public virtual void VisitRangeCaseClause(IRangeCaseClauseOperation operation);
    public virtual void VisitDefaultCaseClause(IDefaultCaseClauseOperation operation);
    public virtual void VisitWhileLoop(IWhileLoopOperation operation);
    public virtual void VisitForLoop(IForLoopOperation operation);
    public virtual void VisitForToLoop(IForToLoopOperation operation);
    public virtual void VisitForEachLoop(IForEachLoopOperation operation);
    public virtual void VisitLabeled(ILabeledOperation operation);
    public virtual void VisitBranch(IBranchOperation operation);
    public virtual void VisitEmpty(IEmptyOperation operation);
    public virtual void VisitReturn(IReturnOperation operation);
    public virtual void VisitLock(ILockOperation operation);
    public virtual void VisitTry(ITryOperation operation);
    public virtual void VisitCatchClause(ICatchClauseOperation operation);
    public virtual void VisitUsing(IUsingOperation operation);
    internal virtual void VisitFixed(IFixedOperation operation);
    internal virtual void VisitAggregateQuery(IAggregateQueryOperation operation);
    public virtual void VisitExpressionStatement(IExpressionStatementOperation operation);
    internal virtual void VisitWith(IWithOperation operation);
    public virtual void VisitStop(IStopOperation operation);
    public virtual void VisitEnd(IEndOperation operation);
    public virtual void VisitInvocation(IInvocationOperation operation);
    public virtual void VisitArgument(IArgumentOperation operation);
    public virtual void VisitOmittedArgument(IOmittedArgumentOperation operation);
    public virtual void VisitArrayElementReference(IArrayElementReferenceOperation operation);
    internal virtual void VisitPointerIndirectionReference(IPointerIndirectionReferenceOperation operation);
    public virtual void VisitLocalReference(ILocalReferenceOperation operation);
    public virtual void VisitParameterReference(IParameterReferenceOperation operation);
    public virtual void VisitInstanceReference(IInstanceReferenceOperation operation);
    public virtual void VisitFieldReference(IFieldReferenceOperation operation);
    public virtual void VisitMethodReference(IMethodReferenceOperation operation);
    public virtual void VisitPropertyReference(IPropertyReferenceOperation operation);
    public virtual void VisitEventReference(IEventReferenceOperation operation);
    public virtual void VisitEventAssignment(IEventAssignmentOperation operation);
    public virtual void VisitConditionalAccess(IConditionalAccessOperation operation);
    public virtual void VisitConditionalAccessInstance(IConditionalAccessInstanceOperation operation);
    internal virtual void VisitPlaceholder(IPlaceholderOperation operation);
    public virtual void VisitUnaryOperator(IUnaryOperation operation);
    public virtual void VisitBinaryOperator(IBinaryOperation operation);
    public virtual void VisitTupleBinaryOperator(ITupleBinaryOperation operation);
    public virtual void VisitConversion(IConversionOperation operation);
    public virtual void VisitConditional(IConditionalOperation operation);
    public virtual void VisitCoalesce(ICoalesceOperation operation);
    public virtual void VisitIsType(IIsTypeOperation operation);
    public virtual void VisitSizeOf(ISizeOfOperation operation);
    public virtual void VisitTypeOf(ITypeOfOperation operation);
    public virtual void VisitAnonymousFunction(IAnonymousFunctionOperation operation);
    public virtual void VisitFlowAnonymousFunction(IFlowAnonymousFunctionOperation operation);
    public virtual void VisitDelegateCreation(IDelegateCreationOperation operation);
    public virtual void VisitLiteral(ILiteralOperation operation);
    public virtual void VisitAwait(IAwaitOperation operation);
    public virtual void VisitNameOf(INameOfOperation operation);
    public virtual void VisitThrow(IThrowOperation operation);
    public virtual void VisitAddressOf(IAddressOfOperation operation);
    public virtual void VisitObjectCreation(IObjectCreationOperation operation);
    public virtual void VisitAnonymousObjectCreation(IAnonymousObjectCreationOperation operation);
    public virtual void VisitDynamicObjectCreation(IDynamicObjectCreationOperation operation);
    public virtual void VisitDynamicInvocation(IDynamicInvocationOperation operation);
    public virtual void VisitDynamicIndexerAccess(IDynamicIndexerAccessOperation operation);
    public virtual void VisitObjectOrCollectionInitializer(IObjectOrCollectionInitializerOperation operation);
    public virtual void VisitMemberInitializer(IMemberInitializerOperation operation);
    [ObsoleteAttribute("ICollectionElementInitializerOperation has been replaced with IInvocationOperation and IDynamicInvocationOperation", "True")]
public virtual void VisitCollectionElementInitializer(ICollectionElementInitializerOperation operation);
    public virtual void VisitFieldInitializer(IFieldInitializerOperation operation);
    public virtual void VisitVariableInitializer(IVariableInitializerOperation operation);
    public virtual void VisitPropertyInitializer(IPropertyInitializerOperation operation);
    public virtual void VisitParameterInitializer(IParameterInitializerOperation operation);
    public virtual void VisitArrayCreation(IArrayCreationOperation operation);
    public virtual void VisitArrayInitializer(IArrayInitializerOperation operation);
    public virtual void VisitSimpleAssignment(ISimpleAssignmentOperation operation);
    public virtual void VisitDeconstructionAssignment(IDeconstructionAssignmentOperation operation);
    public virtual void VisitDeclarationExpression(IDeclarationExpressionOperation operation);
    public virtual void VisitCompoundAssignment(ICompoundAssignmentOperation operation);
    public virtual void VisitIncrementOrDecrement(IIncrementOrDecrementOperation operation);
    public virtual void VisitParenthesized(IParenthesizedOperation operation);
    public virtual void VisitDynamicMemberReference(IDynamicMemberReferenceOperation operation);
    public virtual void VisitDefaultValue(IDefaultValueOperation operation);
    public virtual void VisitTypeParameterObjectCreation(ITypeParameterObjectCreationOperation operation);
    internal virtual void VisitNoPiaObjectCreation(INoPiaObjectCreationOperation operation);
    public virtual void VisitInvalid(IInvalidOperation operation);
    public virtual void VisitLocalFunction(ILocalFunctionOperation operation);
    public virtual void VisitInterpolatedString(IInterpolatedStringOperation operation);
    public virtual void VisitInterpolatedStringText(IInterpolatedStringTextOperation operation);
    public virtual void VisitInterpolation(IInterpolationOperation operation);
    public virtual void VisitIsPattern(IIsPatternOperation operation);
    public virtual void VisitConstantPattern(IConstantPatternOperation operation);
    public virtual void VisitDeclarationPattern(IDeclarationPatternOperation operation);
    public virtual void VisitPatternCaseClause(IPatternCaseClauseOperation operation);
    public virtual void VisitTuple(ITupleOperation operation);
    public virtual void VisitTranslatedQuery(ITranslatedQueryOperation operation);
    public virtual void VisitRaiseEvent(IRaiseEventOperation operation);
    public virtual void VisitMethodBodyOperation(IMethodBodyOperation operation);
    public virtual void VisitConstructorBodyOperation(IConstructorBodyOperation operation);
    public virtual void VisitDiscardOperation(IDiscardOperation operation);
    public virtual void VisitFlowCapture(IFlowCaptureOperation operation);
    public virtual void VisitFlowCaptureReference(IFlowCaptureReferenceOperation operation);
    public virtual void VisitIsNull(IIsNullOperation operation);
    public virtual void VisitCaughtException(ICaughtExceptionOperation operation);
    public virtual void VisitStaticLocalInitializationSemaphore(IStaticLocalInitializationSemaphoreOperation operation);
}
public abstract class Microsoft.CodeAnalysis.Operations.OperationVisitor`2 : object {
    public virtual TResult Visit(IOperation operation, TArgument argument);
    public virtual TResult DefaultVisit(IOperation operation, TArgument argument);
    internal virtual TResult VisitNoneOperation(IOperation operation, TArgument argument);
    public virtual TResult VisitBlock(IBlockOperation operation, TArgument argument);
    public virtual TResult VisitVariableDeclarationGroup(IVariableDeclarationGroupOperation operation, TArgument argument);
    public virtual TResult VisitVariableDeclarator(IVariableDeclaratorOperation operation, TArgument argument);
    public virtual TResult VisitVariableDeclaration(IVariableDeclarationOperation operation, TArgument argument);
    public virtual TResult VisitSwitch(ISwitchOperation operation, TArgument argument);
    public virtual TResult VisitSwitchCase(ISwitchCaseOperation operation, TArgument argument);
    public virtual TResult VisitSingleValueCaseClause(ISingleValueCaseClauseOperation operation, TArgument argument);
    public virtual TResult VisitRelationalCaseClause(IRelationalCaseClauseOperation operation, TArgument argument);
    public virtual TResult VisitRangeCaseClause(IRangeCaseClauseOperation operation, TArgument argument);
    public virtual TResult VisitDefaultCaseClause(IDefaultCaseClauseOperation operation, TArgument argument);
    public virtual TResult VisitWhileLoop(IWhileLoopOperation operation, TArgument argument);
    public virtual TResult VisitForLoop(IForLoopOperation operation, TArgument argument);
    public virtual TResult VisitForToLoop(IForToLoopOperation operation, TArgument argument);
    public virtual TResult VisitForEachLoop(IForEachLoopOperation operation, TArgument argument);
    public virtual TResult VisitLabeled(ILabeledOperation operation, TArgument argument);
    public virtual TResult VisitBranch(IBranchOperation operation, TArgument argument);
    public virtual TResult VisitEmpty(IEmptyOperation operation, TArgument argument);
    public virtual TResult VisitReturn(IReturnOperation operation, TArgument argument);
    public virtual TResult VisitLock(ILockOperation operation, TArgument argument);
    public virtual TResult VisitTry(ITryOperation operation, TArgument argument);
    public virtual TResult VisitCatchClause(ICatchClauseOperation operation, TArgument argument);
    public virtual TResult VisitUsing(IUsingOperation operation, TArgument argument);
    internal virtual TResult VisitFixed(IFixedOperation operation, TArgument argument);
    internal virtual TResult VisitAggregateQuery(IAggregateQueryOperation operation, TArgument argument);
    public virtual TResult VisitExpressionStatement(IExpressionStatementOperation operation, TArgument argument);
    internal virtual TResult VisitWith(IWithOperation operation, TArgument argument);
    public virtual TResult VisitStop(IStopOperation operation, TArgument argument);
    public virtual TResult VisitEnd(IEndOperation operation, TArgument argument);
    public virtual TResult VisitInvocation(IInvocationOperation operation, TArgument argument);
    public virtual TResult VisitArgument(IArgumentOperation operation, TArgument argument);
    public virtual TResult VisitOmittedArgument(IOmittedArgumentOperation operation, TArgument argument);
    public virtual TResult VisitArrayElementReference(IArrayElementReferenceOperation operation, TArgument argument);
    internal virtual TResult VisitPointerIndirectionReference(IPointerIndirectionReferenceOperation operation, TArgument argument);
    public virtual TResult VisitLocalReference(ILocalReferenceOperation operation, TArgument argument);
    public virtual TResult VisitParameterReference(IParameterReferenceOperation operation, TArgument argument);
    public virtual TResult VisitInstanceReference(IInstanceReferenceOperation operation, TArgument argument);
    public virtual TResult VisitFieldReference(IFieldReferenceOperation operation, TArgument argument);
    public virtual TResult VisitMethodReference(IMethodReferenceOperation operation, TArgument argument);
    public virtual TResult VisitPropertyReference(IPropertyReferenceOperation operation, TArgument argument);
    public virtual TResult VisitEventReference(IEventReferenceOperation operation, TArgument argument);
    public virtual TResult VisitEventAssignment(IEventAssignmentOperation operation, TArgument argument);
    public virtual TResult VisitConditionalAccess(IConditionalAccessOperation operation, TArgument argument);
    public virtual TResult VisitConditionalAccessInstance(IConditionalAccessInstanceOperation operation, TArgument argument);
    internal virtual TResult VisitPlaceholder(IPlaceholderOperation operation, TArgument argument);
    public virtual TResult VisitUnaryOperator(IUnaryOperation operation, TArgument argument);
    public virtual TResult VisitBinaryOperator(IBinaryOperation operation, TArgument argument);
    public virtual TResult VisitTupleBinaryOperator(ITupleBinaryOperation operation, TArgument argument);
    public virtual TResult VisitConversion(IConversionOperation operation, TArgument argument);
    public virtual TResult VisitConditional(IConditionalOperation operation, TArgument argument);
    public virtual TResult VisitCoalesce(ICoalesceOperation operation, TArgument argument);
    public virtual TResult VisitIsType(IIsTypeOperation operation, TArgument argument);
    public virtual TResult VisitSizeOf(ISizeOfOperation operation, TArgument argument);
    public virtual TResult VisitTypeOf(ITypeOfOperation operation, TArgument argument);
    public virtual TResult VisitAnonymousFunction(IAnonymousFunctionOperation operation, TArgument argument);
    public virtual TResult VisitFlowAnonymousFunction(IFlowAnonymousFunctionOperation operation, TArgument argument);
    public virtual TResult VisitDelegateCreation(IDelegateCreationOperation operation, TArgument argument);
    public virtual TResult VisitLiteral(ILiteralOperation operation, TArgument argument);
    public virtual TResult VisitAwait(IAwaitOperation operation, TArgument argument);
    public virtual TResult VisitNameOf(INameOfOperation operation, TArgument argument);
    public virtual TResult VisitThrow(IThrowOperation operation, TArgument argument);
    public virtual TResult VisitAddressOf(IAddressOfOperation operation, TArgument argument);
    public virtual TResult VisitObjectCreation(IObjectCreationOperation operation, TArgument argument);
    public virtual TResult VisitAnonymousObjectCreation(IAnonymousObjectCreationOperation operation, TArgument argument);
    public virtual TResult VisitDynamicObjectCreation(IDynamicObjectCreationOperation operation, TArgument argument);
    public virtual TResult VisitDynamicInvocation(IDynamicInvocationOperation operation, TArgument argument);
    public virtual TResult VisitDynamicIndexerAccess(IDynamicIndexerAccessOperation operation, TArgument argument);
    public virtual TResult VisitObjectOrCollectionInitializer(IObjectOrCollectionInitializerOperation operation, TArgument argument);
    public virtual TResult VisitMemberInitializer(IMemberInitializerOperation operation, TArgument argument);
    [ObsoleteAttribute("ICollectionElementInitializerOperation has been replaced with IInvocationOperation and IDynamicInvocationOperation", "True")]
public virtual TResult VisitCollectionElementInitializer(ICollectionElementInitializerOperation operation, TArgument argument);
    public virtual TResult VisitFieldInitializer(IFieldInitializerOperation operation, TArgument argument);
    public virtual TResult VisitVariableInitializer(IVariableInitializerOperation operation, TArgument argument);
    public virtual TResult VisitPropertyInitializer(IPropertyInitializerOperation operation, TArgument argument);
    public virtual TResult VisitParameterInitializer(IParameterInitializerOperation operation, TArgument argument);
    public virtual TResult VisitArrayCreation(IArrayCreationOperation operation, TArgument argument);
    public virtual TResult VisitArrayInitializer(IArrayInitializerOperation operation, TArgument argument);
    public virtual TResult VisitSimpleAssignment(ISimpleAssignmentOperation operation, TArgument argument);
    public virtual TResult VisitDeconstructionAssignment(IDeconstructionAssignmentOperation operation, TArgument argument);
    public virtual TResult VisitDeclarationExpression(IDeclarationExpressionOperation operation, TArgument argument);
    public virtual TResult VisitCompoundAssignment(ICompoundAssignmentOperation operation, TArgument argument);
    public virtual TResult VisitIncrementOrDecrement(IIncrementOrDecrementOperation operation, TArgument argument);
    public virtual TResult VisitParenthesized(IParenthesizedOperation operation, TArgument argument);
    public virtual TResult VisitDynamicMemberReference(IDynamicMemberReferenceOperation operation, TArgument argument);
    public virtual TResult VisitDefaultValue(IDefaultValueOperation operation, TArgument argument);
    public virtual TResult VisitTypeParameterObjectCreation(ITypeParameterObjectCreationOperation operation, TArgument argument);
    internal virtual TResult VisitNoPiaObjectCreation(INoPiaObjectCreationOperation operation, TArgument argument);
    public virtual TResult VisitInvalid(IInvalidOperation operation, TArgument argument);
    public virtual TResult VisitLocalFunction(ILocalFunctionOperation operation, TArgument argument);
    public virtual TResult VisitInterpolatedString(IInterpolatedStringOperation operation, TArgument argument);
    public virtual TResult VisitInterpolatedStringText(IInterpolatedStringTextOperation operation, TArgument argument);
    public virtual TResult VisitInterpolation(IInterpolationOperation operation, TArgument argument);
    public virtual TResult VisitIsPattern(IIsPatternOperation operation, TArgument argument);
    public virtual TResult VisitConstantPattern(IConstantPatternOperation operation, TArgument argument);
    public virtual TResult VisitDeclarationPattern(IDeclarationPatternOperation operation, TArgument argument);
    public virtual TResult VisitPatternCaseClause(IPatternCaseClauseOperation operation, TArgument argument);
    public virtual TResult VisitTuple(ITupleOperation operation, TArgument argument);
    public virtual TResult VisitTranslatedQuery(ITranslatedQueryOperation operation, TArgument argument);
    public virtual TResult VisitRaiseEvent(IRaiseEventOperation operation, TArgument argument);
    public virtual TResult VisitMethodBodyOperation(IMethodBodyOperation operation, TArgument argument);
    public virtual TResult VisitConstructorBodyOperation(IConstructorBodyOperation operation, TArgument argument);
    public virtual TResult VisitDiscardOperation(IDiscardOperation operation, TArgument argument);
    public virtual TResult VisitFlowCapture(IFlowCaptureOperation operation, TArgument argument);
    public virtual TResult VisitFlowCaptureReference(IFlowCaptureReferenceOperation operation, TArgument argument);
    public virtual TResult VisitIsNull(IIsNullOperation operation, TArgument argument);
    public virtual TResult VisitCaughtException(ICaughtExceptionOperation operation, TArgument argument);
    public virtual TResult VisitStaticLocalInitializationSemaphore(IStaticLocalInitializationSemaphoreOperation operation, TArgument argument);
}
public abstract class Microsoft.CodeAnalysis.Operations.OperationWalker : OperationVisitor {
    private int _recursionDepth;
    internal void VisitArray(IEnumerable`1<T> operations);
    internal void VisitOperationArrayElement(T operation);
    public virtual void Visit(IOperation operation);
    public virtual void DefaultVisit(IOperation operation);
    internal virtual void VisitNoneOperation(IOperation operation);
}
internal class Microsoft.CodeAnalysis.Operations.ParameterInitializer : BaseParameterInitializer {
    [CompilerGeneratedAttribute]
private IOperation <Value>k__BackingField;
    public IOperation Value { get; }
    public ParameterInitializer(ImmutableArray`1<ILocalSymbol> locals, IParameterSymbol parameter, IOperation value, OperationKind kind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.ParameterReferenceExpression : Operation {
    [CompilerGeneratedAttribute]
private IParameterSymbol <Parameter>k__BackingField;
    public IParameterSymbol Parameter { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public ParameterReferenceExpression(IParameterSymbol parameter, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual IParameterSymbol get_Parameter();
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.ParenthesizedExpression : BaseParenthesizedExpression {
    [CompilerGeneratedAttribute]
private IOperation <Operand>k__BackingField;
    public IOperation Operand { get; }
    public ParenthesizedExpression(IOperation operand, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Operand();
}
internal class Microsoft.CodeAnalysis.Operations.PatternCaseClause : BasePatternCaseClause {
    [CompilerGeneratedAttribute]
private IPatternOperation <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Guard>k__BackingField;
    public IPatternOperation Pattern { get; }
    public IOperation Guard { get; }
    public PatternCaseClause(ILabelSymbol label, IPatternOperation pattern, IOperation guardExpression, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IPatternOperation get_Pattern();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Guard();
}
internal class Microsoft.CodeAnalysis.Operations.PlaceholderExpression : Operation {
    [CompilerGeneratedAttribute]
private PlaceholderKind <PlaceholderKind>k__BackingField;
    public PlaceholderKind PlaceholderKind { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public PlaceholderExpression(PlaceholderKind placeholderKind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual PlaceholderKind get_PlaceholderKind();
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal enum Microsoft.CodeAnalysis.Operations.PlaceholderKind : Enum {
    public int value__;
    public static PlaceholderKind Unspecified;
    public static PlaceholderKind SwitchOperationExpression;
    public static PlaceholderKind ForToLoopBinaryOperatorLeftOperand;
    public static PlaceholderKind ForToLoopBinaryOperatorRightOperand;
    public static PlaceholderKind AggregationGroup;
}
internal class Microsoft.CodeAnalysis.Operations.PropertyInitializer : BasePropertyInitializer {
    [CompilerGeneratedAttribute]
private IOperation <Value>k__BackingField;
    public IOperation Value { get; }
    public PropertyInitializer(ImmutableArray`1<ILocalSymbol> locals, ImmutableArray`1<IPropertySymbol> initializedProperties, IOperation value, OperationKind kind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.PropertyReferenceExpression : BasePropertyReferenceExpression {
    [CompilerGeneratedAttribute]
private IOperation <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IArgumentOperation> <Arguments>k__BackingField;
    public IOperation Instance { get; }
    public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    public PropertyReferenceExpression(IPropertySymbol property, IOperation instance, ImmutableArray`1<IArgumentOperation> arguments, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Instance();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IArgumentOperation> get_Arguments();
}
internal class Microsoft.CodeAnalysis.Operations.RaiseEventStatement : BaseRaiseEventStatement {
    [CompilerGeneratedAttribute]
private IEventReferenceOperation <EventReference>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IArgumentOperation> <Arguments>k__BackingField;
    public IEventReferenceOperation EventReference { get; }
    public ImmutableArray`1<IArgumentOperation> Arguments { get; }
    public RaiseEventStatement(IEventReferenceOperation eventReference, ImmutableArray`1<IArgumentOperation> arguments, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IEventReferenceOperation get_EventReference();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IArgumentOperation> get_Arguments();
}
internal class Microsoft.CodeAnalysis.Operations.RangeCaseClause : BaseRangeCaseClause {
    [CompilerGeneratedAttribute]
private IOperation <MinimumValue>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <MaximumValue>k__BackingField;
    public IOperation MinimumValue { get; }
    public IOperation MaximumValue { get; }
    public RangeCaseClause(IOperation minimumValue, IOperation maximumValue, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_MinimumValue();
    [CompilerGeneratedAttribute]
public virtual IOperation get_MaximumValue();
}
internal class Microsoft.CodeAnalysis.Operations.RelationalCaseClause : BaseRelationalCaseClause {
    [CompilerGeneratedAttribute]
private IOperation <Value>k__BackingField;
    public IOperation Value { get; }
    public RelationalCaseClause(IOperation value, BinaryOperatorKind relation, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.ReturnStatement : BaseReturnStatement {
    [CompilerGeneratedAttribute]
private IOperation <ReturnedValue>k__BackingField;
    public IOperation ReturnedValue { get; }
    public ReturnStatement(OperationKind kind, IOperation returnedValue, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_ReturnedValue();
}
internal class Microsoft.CodeAnalysis.Operations.SimpleAssignmentExpression : BaseSimpleAssignmentExpression {
    [CompilerGeneratedAttribute]
private IOperation <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Value>k__BackingField;
    public IOperation Target { get; }
    public IOperation Value { get; }
    public SimpleAssignmentExpression(IOperation target, bool isRef, IOperation value, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Target();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.SingleValueCaseClause : BaseSingleValueCaseClause {
    [CompilerGeneratedAttribute]
private IOperation <Value>k__BackingField;
    public IOperation Value { get; }
    public SingleValueCaseClause(ILabelSymbol label, IOperation value, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.SizeOfExpression : Operation {
    [CompilerGeneratedAttribute]
private ITypeSymbol <TypeOperand>k__BackingField;
    public ITypeSymbol TypeOperand { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public SizeOfExpression(ITypeSymbol typeOperand, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_TypeOperand();
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.StaticLocalInitializationSemaphoreOperation : Operation {
    [CompilerGeneratedAttribute]
private ILocalSymbol <Local>k__BackingField;
    public ILocalSymbol Local { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public StaticLocalInitializationSemaphoreOperation(ILocalSymbol local, SyntaxNode syntax, ITypeSymbol type);
    [CompilerGeneratedAttribute]
public sealed virtual ILocalSymbol get_Local();
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.StopStatement : Operation {
    public IEnumerable`1<IOperation> Children { get; }
    public StopStatement(SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.SwitchCase : BaseSwitchCase {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ICaseClauseOperation> <Clauses>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <Body>k__BackingField;
    public ImmutableArray`1<ICaseClauseOperation> Clauses { get; }
    public IOperation Condition { get; }
    public ImmutableArray`1<IOperation> Body { get; }
    public SwitchCase(ImmutableArray`1<ILocalSymbol> locals, IOperation condition, ImmutableArray`1<ICaseClauseOperation> clauses, ImmutableArray`1<IOperation> body, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<ICaseClauseOperation> get_Clauses();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Condition();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IOperation> get_Body();
}
internal class Microsoft.CodeAnalysis.Operations.SwitchStatement : BaseSwitchStatement {
    [CompilerGeneratedAttribute]
private IOperation <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ISwitchCaseOperation> <Cases>k__BackingField;
    public IOperation Value { get; }
    public ImmutableArray`1<ISwitchCaseOperation> Cases { get; }
    public SwitchStatement(ImmutableArray`1<ILocalSymbol> locals, IOperation value, ImmutableArray`1<ISwitchCaseOperation> cases, ILabelSymbol exitLabel, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Value();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<ISwitchCaseOperation> get_Cases();
}
internal abstract class Microsoft.CodeAnalysis.Operations.SymbolInitializer : Operation {
    public IOperation Value { get; }
    protected SymbolInitializer(OperationKind kind, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    public abstract virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.ThrowExpression : BaseThrowExpression {
    [CompilerGeneratedAttribute]
private IOperation <Exception>k__BackingField;
    public IOperation Exception { get; }
    public ThrowExpression(IOperation exception, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Exception();
}
internal class Microsoft.CodeAnalysis.Operations.TranslatedQueryExpression : BaseTranslatedQueryExpression {
    [CompilerGeneratedAttribute]
private IOperation <Operation>k__BackingField;
    public IOperation Operation { get; }
    public TranslatedQueryExpression(IOperation operation, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Operation();
}
internal class Microsoft.CodeAnalysis.Operations.TryStatement : BaseTryStatement {
    [CompilerGeneratedAttribute]
private IBlockOperation <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ICatchClauseOperation> <Catches>k__BackingField;
    [CompilerGeneratedAttribute]
private IBlockOperation <Finally>k__BackingField;
    public IBlockOperation Body { get; }
    public ImmutableArray`1<ICatchClauseOperation> Catches { get; }
    public IBlockOperation Finally { get; }
    public TryStatement(IBlockOperation body, ImmutableArray`1<ICatchClauseOperation> catches, IBlockOperation finallyHandler, ILabelSymbol exitLabel, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IBlockOperation get_Body();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<ICatchClauseOperation> get_Catches();
    [CompilerGeneratedAttribute]
public virtual IBlockOperation get_Finally();
}
internal class Microsoft.CodeAnalysis.Operations.TupleBinaryOperatorExpression : BaseTupleBinaryOperatorExpression {
    [CompilerGeneratedAttribute]
private IOperation <LeftOperand>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <RightOperand>k__BackingField;
    public IOperation LeftOperand { get; }
    public IOperation RightOperand { get; }
    public TupleBinaryOperatorExpression(BinaryOperatorKind operatorKind, IOperation leftOperand, IOperation rightOperand, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_LeftOperand();
    [CompilerGeneratedAttribute]
public virtual IOperation get_RightOperand();
}
internal class Microsoft.CodeAnalysis.Operations.TupleExpression : BaseTupleExpression {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <Elements>k__BackingField;
    public ImmutableArray`1<IOperation> Elements { get; }
    public TupleExpression(ImmutableArray`1<IOperation> elements, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, ITypeSymbol naturalType, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IOperation> get_Elements();
}
internal class Microsoft.CodeAnalysis.Operations.TypeOfExpression : Operation {
    [CompilerGeneratedAttribute]
private ITypeSymbol <TypeOperand>k__BackingField;
    public ITypeSymbol TypeOperand { get; }
    public IEnumerable`1<IOperation> Children { get; }
    public TypeOfExpression(ITypeSymbol typeOperand, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_TypeOperand();
    public virtual IEnumerable`1<IOperation> get_Children();
    public virtual void Accept(OperationVisitor visitor);
    public virtual TResult Accept(OperationVisitor`2<TArgument, TResult> visitor, TArgument argument);
}
internal class Microsoft.CodeAnalysis.Operations.TypeParameterObjectCreationExpression : BaseTypeParameterObjectCreationExpression {
    [CompilerGeneratedAttribute]
private IObjectOrCollectionInitializerOperation <Initializer>k__BackingField;
    public IObjectOrCollectionInitializerOperation Initializer { get; }
    public TypeParameterObjectCreationExpression(IObjectOrCollectionInitializerOperation initializer, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IObjectOrCollectionInitializerOperation get_Initializer();
}
internal class Microsoft.CodeAnalysis.Operations.UnaryOperatorExpression : BaseUnaryOperatorExpression {
    [CompilerGeneratedAttribute]
private IOperation <Operand>k__BackingField;
    public IOperation Operand { get; }
    public UnaryOperatorExpression(UnaryOperatorKind unaryOperationKind, IOperation operand, bool isLifted, bool isChecked, IMethodSymbol operatorMethod, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Operand();
}
public enum Microsoft.CodeAnalysis.Operations.UnaryOperatorKind : Enum {
    public int value__;
    public static UnaryOperatorKind None;
    public static UnaryOperatorKind BitwiseNegation;
    public static UnaryOperatorKind Not;
    public static UnaryOperatorKind Plus;
    public static UnaryOperatorKind Minus;
    public static UnaryOperatorKind True;
    public static UnaryOperatorKind False;
}
internal class Microsoft.CodeAnalysis.Operations.UsingStatement : BaseUsingStatement {
    [CompilerGeneratedAttribute]
private IOperation <Resources>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Body>k__BackingField;
    public IOperation Resources { get; }
    public IOperation Body { get; }
    public UsingStatement(IOperation resources, IOperation body, ImmutableArray`1<ILocalSymbol> locals, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Resources();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Body();
}
internal class Microsoft.CodeAnalysis.Operations.VariableDeclaration : BaseVariableDeclaration {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IVariableDeclaratorOperation> <Declarators>k__BackingField;
    [CompilerGeneratedAttribute]
private IVariableInitializerOperation <Initializer>k__BackingField;
    public ImmutableArray`1<IVariableDeclaratorOperation> Declarators { get; }
    public IVariableInitializerOperation Initializer { get; }
    public VariableDeclaration(ImmutableArray`1<IVariableDeclaratorOperation> declarations, IVariableInitializerOperation initializer, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IVariableDeclaratorOperation> get_Declarators();
    [CompilerGeneratedAttribute]
public virtual IVariableInitializerOperation get_Initializer();
}
internal class Microsoft.CodeAnalysis.Operations.VariableDeclarationGroupOperation : BaseVariableDeclarationGroupOperation {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IVariableDeclarationOperation> <Declarations>k__BackingField;
    public ImmutableArray`1<IVariableDeclarationOperation> Declarations { get; }
    public VariableDeclarationGroupOperation(ImmutableArray`1<IVariableDeclarationOperation> declarations, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IVariableDeclarationOperation> get_Declarations();
}
internal class Microsoft.CodeAnalysis.Operations.VariableDeclarator : BaseVariableDeclarator {
    [CompilerGeneratedAttribute]
private IVariableInitializerOperation <Initializer>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IOperation> <IgnoredArguments>k__BackingField;
    public IVariableInitializerOperation Initializer { get; }
    public ImmutableArray`1<IOperation> IgnoredArguments { get; }
    public VariableDeclarator(ILocalSymbol symbol, IVariableInitializerOperation initializer, ImmutableArray`1<IOperation> ignoredArguments, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IVariableInitializerOperation get_Initializer();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IOperation> get_IgnoredArguments();
}
internal class Microsoft.CodeAnalysis.Operations.VariableInitializer : BaseVariableInitializer {
    [CompilerGeneratedAttribute]
private IOperation <Value>k__BackingField;
    public IOperation Value { get; }
    public VariableInitializer(IOperation value, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Value();
}
internal class Microsoft.CodeAnalysis.Operations.WhileLoopStatement : BaseWhileLoopStatement {
    [CompilerGeneratedAttribute]
private IOperation <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <IgnoredCondition>k__BackingField;
    public IOperation Condition { get; }
    public IOperation Body { get; }
    public IOperation IgnoredCondition { get; }
    public WhileLoopStatement(IOperation condition, IOperation body, IOperation ignoredCondition, ImmutableArray`1<ILocalSymbol> locals, ILabelSymbol continueLabel, ILabelSymbol exitLabel, bool conditionIsTop, bool conditionIsUntil, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Condition();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Body();
    [CompilerGeneratedAttribute]
public virtual IOperation get_IgnoredCondition();
}
internal class Microsoft.CodeAnalysis.Operations.WithStatement : BaseWithStatement {
    [CompilerGeneratedAttribute]
private IOperation <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private IOperation <Value>k__BackingField;
    public IOperation Body { get; }
    public IOperation Value { get; }
    public WithStatement(IOperation body, IOperation value, SemanticModel semanticModel, SyntaxNode syntax, ITypeSymbol type, Optional`1<object> constantValue, bool isImplicit);
    [CompilerGeneratedAttribute]
public virtual IOperation get_Body();
    [CompilerGeneratedAttribute]
public virtual IOperation get_Value();
}
public enum Microsoft.CodeAnalysis.OptimizationLevel : Enum {
    public int value__;
    public static OptimizationLevel Debug;
    public static OptimizationLevel Release;
}
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.Optional`1 : ValueType {
    private bool _hasValue;
    private T _value;
    public bool HasValue { get; }
    public T Value { get; }
    public Optional`1(T value);
    public bool get_HasValue();
    public T get_Value();
    public static Optional`1<T> op_Implicit(T value);
    public virtual string ToString();
}
public enum Microsoft.CodeAnalysis.OutputKind : Enum {
    public int value__;
    public static OutputKind ConsoleApplication;
    public static OutputKind WindowsApplication;
    public static OutputKind DynamicallyLinkedLibrary;
    public static OutputKind NetModule;
    public static OutputKind WindowsRuntimeMetadata;
    public static OutputKind WindowsRuntimeApplication;
}
internal class Microsoft.CodeAnalysis.ParamInfo`1 : ValueType {
    internal bool IsByRef;
    internal TypeSymbol Type;
    internal ParameterHandle Handle;
    internal ImmutableArray`1<ModifierInfo`1<TypeSymbol>> RefCustomModifiers;
    internal ImmutableArray`1<ModifierInfo`1<TypeSymbol>> CustomModifiers;
}
public abstract class Microsoft.CodeAnalysis.ParseOptions : object {
    private Lazy`1<ImmutableArray`1<Diagnostic>> _lazyErrors;
    [CompilerGeneratedAttribute]
private SourceCodeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceCodeKind <SpecifiedKind>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentationMode <DocumentationMode>k__BackingField;
    public SourceCodeKind Kind { get; protected set; }
    public SourceCodeKind SpecifiedKind { get; protected set; }
    public DocumentationMode DocumentationMode { get; protected set; }
    public string Language { get; }
    public ImmutableArray`1<Diagnostic> Errors { get; }
    public IReadOnlyDictionary`2<string, string> Features { get; }
    public IEnumerable`1<string> PreprocessorSymbolNames { get; }
    internal ParseOptions(SourceCodeKind kind, DocumentationMode documentationMode);
    [CompilerGeneratedAttribute]
public SourceCodeKind get_Kind();
    [CompilerGeneratedAttribute]
protected void set_Kind(SourceCodeKind value);
    [CompilerGeneratedAttribute]
public SourceCodeKind get_SpecifiedKind();
    [CompilerGeneratedAttribute]
protected void set_SpecifiedKind(SourceCodeKind value);
    [CompilerGeneratedAttribute]
public DocumentationMode get_DocumentationMode();
    [CompilerGeneratedAttribute]
protected void set_DocumentationMode(DocumentationMode value);
    public abstract virtual string get_Language();
    public ImmutableArray`1<Diagnostic> get_Errors();
    public ParseOptions WithKind(SourceCodeKind kind);
    internal abstract virtual void ValidateOptions(ArrayBuilder`1<Diagnostic> builder);
    internal void ValidateOptions(ArrayBuilder`1<Diagnostic> builder, CommonMessageProvider messageProvider);
    [EditorBrowsableAttribute("1")]
public abstract virtual ParseOptions CommonWithKind(SourceCodeKind kind);
    public ParseOptions WithDocumentationMode(DocumentationMode documentationMode);
    protected abstract virtual ParseOptions CommonWithDocumentationMode(DocumentationMode documentationMode);
    public ParseOptions WithFeatures(IEnumerable`1<KeyValuePair`2<string, string>> features);
    protected abstract virtual ParseOptions CommonWithFeatures(IEnumerable`1<KeyValuePair`2<string, string>> features);
    public abstract virtual IReadOnlyDictionary`2<string, string> get_Features();
    public abstract virtual IEnumerable`1<string> get_PreprocessorSymbolNames();
    public abstract virtual bool Equals(object obj);
    protected bool EqualsHelper(ParseOptions other);
    public abstract virtual int GetHashCode();
    protected int GetHashCodeHelper();
    private static int HashFeatures(IReadOnlyDictionary`2<string, string> features);
    public static bool op_Equality(ParseOptions left, ParseOptions right);
    public static bool op_Inequality(ParseOptions left, ParseOptions right);
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Diagnostic> <.ctor>b__13_0();
}
internal class Microsoft.CodeAnalysis.PEAssembly : object {
    internal ImmutableArray`1<AssemblyIdentity> AssemblyReferences;
    internal ImmutableArray`1<int> ModuleReferenceCounts;
    private ImmutableArray`1<PEModule> _modules;
    private AssemblyIdentity _identity;
    private ThreeState _lazyContainsNoPiaLocalTypes;
    private ThreeState _lazyDeclaresTheObjectClass;
    private AssemblyMetadata _owner;
    private Dictionary`2<string, List`1<ImmutableArray`1<byte>>> _lazyInternalsVisibleToMap;
    internal EntityHandle Handle { get; }
    internal PEModule ManifestModule { get; }
    internal ImmutableArray`1<PEModule> Modules { get; }
    internal AssemblyIdentity Identity { get; }
    internal bool DeclaresTheObjectClass { get; }
    internal PEAssembly(AssemblyMetadata owner, ImmutableArray`1<PEModule> modules);
    internal EntityHandle get_Handle();
    internal PEModule get_ManifestModule();
    internal ImmutableArray`1<PEModule> get_Modules();
    internal AssemblyIdentity get_Identity();
    internal bool ContainsNoPiaLocalTypes();
    private Dictionary`2<string, List`1<ImmutableArray`1<byte>>> BuildInternalsVisibleToMap();
    internal IEnumerable`1<ImmutableArray`1<byte>> GetInternalsVisibleToPublicKeys(string simpleName);
    internal bool get_DeclaresTheObjectClass();
    public AssemblyMetadata GetNonDisposableMetadata();
}
internal class Microsoft.CodeAnalysis.PEModule : object {
    private ModuleMetadata _owner;
    private PEReader _peReaderOpt;
    private IntPtr _metadataPointerOpt;
    private int _metadataSizeOpt;
    private MetadataReader _lazyMetadataReader;
    private ImmutableArray`1<AssemblyIdentity> _lazyAssemblyReferences;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, ValueTuple`2<int, int>> _lazyForwardedTypesToAssemblyIndexMap;
    private Lazy`1<IdentifierCollection> _lazyTypeNameCollection;
    private Lazy`1<IdentifierCollection> _lazyNamespaceNameCollection;
    private string _lazyName;
    private bool _isDisposed;
    private ThreeState _lazyContainsNoPiaLocalTypes;
    private Int32[] _lazyNoPiaLocalTypeCheckBitMap;
    private ConcurrentDictionary`2<TypeDefinitionHandle, AttributeInfo> _lazyTypeDefToTypeIdentifierMap;
    private CryptographicHashProvider _hashesOpt;
    private static AttributeValueExtractor`1<string> s_attributeStringValueExtractor;
    private static AttributeValueExtractor`1<StringAndInt> s_attributeStringAndIntValueExtractor;
    private static AttributeValueExtractor`1<short> s_attributeShortValueExtractor;
    private static AttributeValueExtractor`1<int> s_attributeIntValueExtractor;
    private static AttributeValueExtractor`1<long> s_attributeLongValueExtractor;
    private static AttributeValueExtractor`1<decimal> s_decimalValueInDecimalConstantAttributeExtractor;
    private static AttributeValueExtractor`1<ImmutableArray`1<bool>> s_attributeBoolArrayValueExtractor;
    private static AttributeValueExtractor`1<ImmutableArray`1<string>> s_attributeStringArrayValueExtractor;
    private static AttributeValueExtractor`1<ObsoleteAttributeData> s_attributeObsoleteDataExtractor;
    private static AttributeValueExtractor`1<ObsoleteAttributeData> s_attributeDeprecatedDataExtractor;
    private static ImmutableArray`1<bool> s_simpleDynamicTransforms;
    internal static string ByRefLikeMarker;
    internal bool IsDisposed { get; }
    internal PEReader PEReaderOpt { get; }
    internal MetadataReader MetadataReader { get; }
    internal bool IsManifestModule { get; }
    internal bool IsLinkedModule { get; }
    internal bool IsCOFFOnly { get; }
    internal Machine Machine { get; }
    internal bool Bit32Required { get; }
    internal string Name { get; }
    public ImmutableArray`1<AssemblyIdentity> ReferencedAssemblies { get; }
    internal string MetadataVersion { get; }
    internal IdentifierCollection TypeNames { get; }
    internal IdentifierCollection NamespaceNames { get; }
    internal bool HasIL { get; }
    internal bool IsEntireImageAvailable { get; }
    internal PEModule(ModuleMetadata owner, PEReader peReader, IntPtr metadataOpt, int metadataSizeOpt, bool includeEmbeddedInteropTypes, bool ignoreAssemblyRefs);
    private static PEModule();
    internal bool get_IsDisposed();
    public sealed virtual void Dispose();
    internal PEReader get_PEReaderOpt();
    internal MetadataReader get_MetadataReader();
    private void InitializeMetadataReader();
    private static void ThrowMetadataDisposed();
    internal bool get_IsManifestModule();
    internal bool get_IsLinkedModule();
    internal bool get_IsCOFFOnly();
    internal Machine get_Machine();
    internal bool get_Bit32Required();
    internal ImmutableArray`1<byte> GetHash(AssemblyHashAlgorithm algorithmId);
    internal string get_Name();
    internal Guid GetModuleVersionIdOrThrow();
    internal ImmutableArray`1<string> GetMetadataModuleNamesOrThrow();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.PEModule/<GetReferencedManagedModulesOrThrow>d__52")]
internal IEnumerable`1<string> GetReferencedManagedModulesOrThrow();
    internal ImmutableArray`1<EmbeddedResource> GetEmbeddedResourcesOrThrow();
    public string GetModuleRefNameOrThrow(ModuleReferenceHandle moduleRef);
    public ImmutableArray`1<AssemblyIdentity> get_ReferencedAssemblies();
    internal string get_MetadataVersion();
    internal BlobReader GetMemoryReaderOrThrow(BlobHandle blob);
    internal string GetFullNameOrThrow(StringHandle namespaceHandle, StringHandle nameHandle);
    internal AssemblyIdentity ReadAssemblyIdentityOrThrow();
    public TypeDefinitionHandle GetContainingTypeOrThrow(TypeDefinitionHandle typeDef);
    public string GetTypeDefNameOrThrow(TypeDefinitionHandle typeDef);
    public string GetTypeDefNamespaceOrThrow(TypeDefinitionHandle typeDef);
    public EntityHandle GetTypeDefExtendsOrThrow(TypeDefinitionHandle typeDef);
    public TypeAttributes GetTypeDefFlagsOrThrow(TypeDefinitionHandle typeDef);
    public GenericParameterHandleCollection GetTypeDefGenericParamsOrThrow(TypeDefinitionHandle typeDef);
    public bool HasGenericParametersOrThrow(TypeDefinitionHandle typeDef);
    public void GetTypeDefPropsOrThrow(TypeDefinitionHandle typeDef, String& name, String& namespace, TypeAttributes& flags, EntityHandle& extends);
    internal bool IsNestedTypeDefOrThrow(TypeDefinitionHandle typeDef);
    private static bool IsNestedTypeDefOrThrow(MetadataReader metadataReader, TypeDefinitionHandle typeDef);
    internal bool IsInterfaceOrThrow(TypeDefinitionHandle typeDef);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.PEModule/<GetTypeDefsOrThrow>d__74")]
private IEnumerable`1<TypeDefToNamespace> GetTypeDefsOrThrow(bool topLevelOnly);
    internal IEnumerable`1<IGrouping`2<string, TypeDefinitionHandle>> GroupTypesByNamespaceOrThrow(StringComparer nameComparer);
    private void GetTypeNamespaceNamesOrThrow(Dictionary`2<string, ArrayBuilder`1<TypeDefinitionHandle>> namespaces);
    private void GetForwardedTypeNamespaceNamesOrThrow(Dictionary`2<string, ArrayBuilder`1<TypeDefinitionHandle>> namespaces);
    private IdentifierCollection ComputeTypeNameCollection();
    private IdentifierCollection ComputeNamespaceNameCollection();
    internal ImmutableArray`1<TypeDefinitionHandle> GetNestedTypeDefsOrThrow(TypeDefinitionHandle container);
    internal MethodImplementationHandleCollection GetMethodImplementationsOrThrow(TypeDefinitionHandle typeDef);
    internal InterfaceImplementationHandleCollection GetInterfaceImplementationsOrThrow(TypeDefinitionHandle typeDef);
    internal MethodDefinitionHandleCollection GetMethodsOfTypeOrThrow(TypeDefinitionHandle typeDef);
    internal PropertyDefinitionHandleCollection GetPropertiesOfTypeOrThrow(TypeDefinitionHandle typeDef);
    internal EventDefinitionHandleCollection GetEventsOfTypeOrThrow(TypeDefinitionHandle typeDef);
    internal FieldDefinitionHandleCollection GetFieldsOfTypeOrThrow(TypeDefinitionHandle typeDef);
    internal EntityHandle GetBaseTypeOfTypeOrThrow(TypeDefinitionHandle typeDef);
    internal TypeLayout GetTypeLayout(TypeDefinitionHandle typeDef);
    internal bool IsNoPiaLocalType(TypeDefinitionHandle typeDef);
    internal bool HasParamsAttribute(EntityHandle token);
    internal bool HasIsReadOnlyAttribute(EntityHandle token);
    internal bool HasIsUnmanagedAttribute(EntityHandle token);
    internal bool HasExtensionAttribute(EntityHandle token, bool ignoreCase);
    internal bool HasVisualBasicEmbeddedAttribute(EntityHandle token);
    internal bool HasCodeAnalysisEmbeddedAttribute(EntityHandle token);
    internal bool HasDefaultMemberAttribute(EntityHandle token, String& memberName);
    internal bool HasGuidAttribute(EntityHandle token, String& guidValue);
    internal bool HasFixedBufferAttribute(EntityHandle token, String& elementTypeName, Int32& bufferSize);
    internal bool HasAccessedThroughPropertyAttribute(EntityHandle token, String& propertyName);
    internal bool HasRequiredAttributeAttribute(EntityHandle token);
    internal bool HasAttribute(EntityHandle token, AttributeDescription description);
    internal CustomAttributeHandle GetAttributeHandle(EntityHandle token, AttributeDescription description);
    internal bool HasDynamicAttribute(EntityHandle token, ImmutableArray`1& dynamicTransforms);
    internal bool HasTupleElementNamesAttribute(EntityHandle token, ImmutableArray`1& tupleElementNames);
    internal bool HasIsByRefLikeAttribute(EntityHandle token);
    internal ObsoleteAttributeData TryGetDeprecatedOrExperimentalOrObsoleteAttribute(EntityHandle token, bool ignoreByRefLikeMarker);
    internal CustomAttributeHandle GetAttributeUsageAttributeHandle(EntityHandle token);
    internal bool HasInterfaceTypeAttribute(EntityHandle token, ComInterfaceType& interfaceType);
    internal bool HasTypeLibTypeAttribute(EntityHandle token, TypeLibTypeFlags& flags);
    internal bool HasDateTimeConstantAttribute(EntityHandle token, ConstantValue& defaultValue);
    internal bool HasDecimalConstantAttribute(EntityHandle token, ConstantValue& defaultValue);
    internal ImmutableArray`1<string> GetInternalsVisibleToAttributeValues(EntityHandle token);
    internal ImmutableArray`1<string> GetConditionalAttributeValues(EntityHandle token);
    private ArrayBuilder`1<string> ExtractStringValuesFromAttributes(List`1<AttributeInfo> attrInfos);
    private ObsoleteAttributeData TryExtractObsoleteDataFromAttribute(AttributeInfo attributeInfo);
    private ObsoleteAttributeData TryExtractDeprecatedDataFromAttribute(AttributeInfo attributeInfo);
    private ObsoleteAttributeData TryExtractExperimentalDataFromAttribute(AttributeInfo attributeInfo);
    private bool TryExtractInterfaceTypeFromAttribute(AttributeInfo attributeInfo, ComInterfaceType& interfaceType);
    private static bool IsValidComInterfaceType(int comInterfaceType);
    private bool TryExtractTypeLibTypeFromAttribute(AttributeInfo info, TypeLibTypeFlags& flags);
    internal bool TryExtractStringValueFromAttribute(CustomAttributeHandle handle, String& value);
    internal bool TryExtractLongValueFromAttribute(CustomAttributeHandle handle, Int64& value);
    private bool TryExtractDecimalValueFromDecimalConstantAttribute(CustomAttributeHandle handle, Decimal& value);
    private bool TryExtractStringAndIntValueFromAttribute(CustomAttributeHandle handle, String& stringValue, Int32& intValue);
    private bool TryExtractBoolArrayValueFromAttribute(CustomAttributeHandle handle, ImmutableArray`1& value);
    private bool TryExtractStringArrayValueFromAttribute(CustomAttributeHandle handle, ImmutableArray`1& value);
    private bool TryExtractValueFromAttribute(CustomAttributeHandle handle, T& value, AttributeValueExtractor`1<T> valueExtractor);
    internal bool HasStringValuedAttribute(EntityHandle token, AttributeDescription description, String& value);
    private bool HasStringAndIntValuedAttribute(EntityHandle token, AttributeDescription description, String& stringValue, Int32& intValue);
    internal bool IsNoPiaLocalType(TypeDefinitionHandle typeDef, String& interfaceGuid, String& scope, String& identifier);
    private static bool CrackObsoleteAttributeData(ObsoleteAttributeData& value, BlobReader& sig);
    private static bool CrackDeprecatedAttributeData(ObsoleteAttributeData& value, BlobReader& sig);
    private static bool CrackStringAndIntInAttributeValue(StringAndInt& value, BlobReader& sig);
    internal static bool CrackStringInAttributeValue(String& value, BlobReader& sig);
    internal static bool CrackStringArrayInAttributeValue(ImmutableArray`1& value, BlobReader& sig);
    internal static bool CrackByteInAttributeValue(Byte& value, BlobReader& sig);
    internal static bool CrackShortInAttributeValue(Int16& value, BlobReader& sig);
    internal static bool CrackIntInAttributeValue(Int32& value, BlobReader& sig);
    internal static bool CrackLongInAttributeValue(Int64& value, BlobReader& sig);
    private static bool CrackDecimalInDecimalConstantAttribute(Decimal& value, BlobReader& sig);
    internal static bool CrackBoolArrayInAttributeValue(ImmutableArray`1& value, BlobReader& sig);
    internal List`1<AttributeInfo> FindTargetAttributes(EntityHandle hasAttribute, AttributeDescription description);
    private AttributeInfo FindTargetAttribute(EntityHandle hasAttribute, AttributeDescription description);
    internal static AttributeInfo FindTargetAttribute(MetadataReader metadataReader, EntityHandle hasAttribute, AttributeDescription description);
    internal AttributeInfo FindLastTargetAttribute(EntityHandle hasAttribute, AttributeDescription description);
    internal int GetParamArrayCountOrThrow(EntityHandle hasAttribute);
    private bool IsNoPiaLocalType(TypeDefinitionHandle typeDef, AttributeInfo& attributeInfo);
    private void RegisterNoPiaLocalType(TypeDefinitionHandle typeDef, CustomAttributeHandle customAttribute, int signatureIndex);
    private void RecordNoPiaLocalTypeCheck(TypeDefinitionHandle typeDef);
    private int IsTypeIdentifierAttribute(CustomAttributeHandle customAttribute);
    internal bool IsTargetAttribute(CustomAttributeHandle customAttribute, string namespaceName, string typeName, EntityHandle& ctor, bool ignoreCase);
    private static bool IsTargetAttribute(MetadataReader metadataReader, CustomAttributeHandle customAttribute, string namespaceName, string typeName, EntityHandle& ctor, bool ignoreCase);
    internal AssemblyReferenceHandle GetAssemblyRef(string assemblyName);
    internal EntityHandle GetTypeRef(EntityHandle resolutionScope, string namespaceName, string typeName);
    public void GetTypeRefPropsOrThrow(TypeReferenceHandle handle, String& name, String& namespace, EntityHandle& resolutionScope);
    internal int GetTargetAttributeSignatureIndex(CustomAttributeHandle customAttribute, AttributeDescription description);
    private static int GetTargetAttributeSignatureIndex(MetadataReader metadataReader, CustomAttributeHandle customAttribute, AttributeDescription description);
    internal bool GetTypeAndConstructor(CustomAttributeHandle customAttribute, EntityHandle& ctorType, EntityHandle& attributeCtor);
    private static bool GetTypeAndConstructor(MetadataReader metadataReader, CustomAttributeHandle customAttribute, EntityHandle& ctorType, EntityHandle& attributeCtor);
    internal bool GetAttributeNamespaceAndName(EntityHandle typeDefOrRef, StringHandle& namespaceHandle, StringHandle& nameHandle);
    private static bool GetAttributeNamespaceAndName(MetadataReader metadataReader, EntityHandle typeDefOrRef, StringHandle& namespaceHandle, StringHandle& nameHandle);
    internal void PretendThereArentNoPiaLocalTypes();
    internal bool ContainsNoPiaLocalTypes();
    internal BlobReader GetTypeSpecificationSignatureReaderOrThrow(TypeSpecificationHandle typeSpec);
    internal void GetMethodSpecificationOrThrow(MethodSpecificationHandle handle, EntityHandle& method, BlobHandle& instantiation);
    internal void GetGenericParamPropsOrThrow(GenericParameterHandle handle, String& name, GenericParameterAttributes& flags);
    internal string GetMethodDefNameOrThrow(MethodDefinitionHandle methodDef);
    internal BlobHandle GetMethodSignatureOrThrow(MethodDefinitionHandle methodDef);
    private static BlobHandle GetMethodSignatureOrThrow(MetadataReader metadataReader, MethodDefinitionHandle methodDef);
    internal BlobHandle GetMethodSignatureOrThrow(EntityHandle methodDefOrRef);
    private static BlobHandle GetMethodSignatureOrThrow(MetadataReader metadataReader, EntityHandle methodDefOrRef);
    public MethodAttributes GetMethodDefFlagsOrThrow(MethodDefinitionHandle methodDef);
    internal TypeDefinitionHandle FindContainingTypeOrThrow(MethodDefinitionHandle methodDef);
    internal TypeDefinitionHandle FindContainingTypeOrThrow(FieldDefinitionHandle fieldDef);
    internal EntityHandle GetContainingTypeOrThrow(MemberReferenceHandle memberRef);
    public void GetMethodDefPropsOrThrow(MethodDefinitionHandle methodDef, String& name, MethodImplAttributes& implFlags, MethodAttributes& flags, Int32& rva);
    internal void GetMethodImplPropsOrThrow(MethodImplementationHandle methodImpl, EntityHandle& body, EntityHandle& declaration);
    internal GenericParameterHandleCollection GetGenericParametersForMethodOrThrow(MethodDefinitionHandle methodDef);
    internal ParameterHandleCollection GetParametersOfMethodOrThrow(MethodDefinitionHandle methodDef);
    internal DllImportData GetDllImportData(MethodDefinitionHandle methodDef);
    public string GetMemberRefNameOrThrow(MemberReferenceHandle memberRef);
    private static string GetMemberRefNameOrThrow(MetadataReader metadataReader, MemberReferenceHandle memberRef);
    internal BlobHandle GetSignatureOrThrow(MemberReferenceHandle memberRef);
    private static BlobHandle GetSignatureOrThrow(MetadataReader metadataReader, MemberReferenceHandle memberRef);
    public void GetMemberRefPropsOrThrow(MemberReferenceHandle memberRef, EntityHandle& class, String& name, Byte[]& signature);
    internal void GetParamPropsOrThrow(ParameterHandle parameterDef, String& name, ParameterAttributes& flags);
    internal string GetParamNameOrThrow(ParameterHandle parameterDef);
    internal int GetParameterSequenceNumberOrThrow(ParameterHandle param);
    internal string GetPropertyDefNameOrThrow(PropertyDefinitionHandle propertyDef);
    internal BlobHandle GetPropertySignatureOrThrow(PropertyDefinitionHandle propertyDef);
    internal void GetPropertyDefPropsOrThrow(PropertyDefinitionHandle propertyDef, String& name, PropertyAttributes& flags);
    internal string GetEventDefNameOrThrow(EventDefinitionHandle eventDef);
    internal void GetEventDefPropsOrThrow(EventDefinitionHandle eventDef, String& name, EventAttributes& flags, EntityHandle& type);
    public string GetFieldDefNameOrThrow(FieldDefinitionHandle fieldDef);
    internal BlobHandle GetFieldSignatureOrThrow(FieldDefinitionHandle fieldDef);
    public FieldAttributes GetFieldDefFlagsOrThrow(FieldDefinitionHandle fieldDef);
    public void GetFieldDefPropsOrThrow(FieldDefinitionHandle fieldDef, String& name, FieldAttributes& flags);
    internal ConstantValue GetParamDefaultValue(ParameterHandle param);
    internal ConstantValue GetConstantFieldValue(FieldDefinitionHandle fieldDef);
    public CustomAttributeHandleCollection GetCustomAttributesOrThrow(EntityHandle handle);
    public BlobHandle GetCustomAttributeValueOrThrow(CustomAttributeHandle handle);
    private BlobHandle GetMarshallingDescriptorHandleOrThrow(EntityHandle fieldOrParameterToken);
    internal UnmanagedType GetMarshallingType(EntityHandle fieldOrParameterToken);
    internal ImmutableArray`1<byte> GetMarshallingDescriptor(EntityHandle fieldOrParameterToken);
    internal Nullable`1<int> GetFieldOffset(FieldDefinitionHandle fieldDef);
    private ConstantValue GetConstantValueOrThrow(ConstantHandle handle);
    internal ValueTuple`2<int, int> GetAssemblyRefsForForwardedType(string fullName, bool ignoreCase, String& matchedName);
    internal IEnumerable`1<KeyValuePair`2<string, ValueTuple`2<int, int>>> GetForwardedTypes();
    private void EnsureForwardTypeToAssemblyMap();
    internal IdentifierCollection get_TypeNames();
    internal IdentifierCollection get_NamespaceNames();
    internal PropertyAccessors GetPropertyMethodsOrThrow(PropertyDefinitionHandle propertyDef);
    internal EventAccessors GetEventMethodsOrThrow(EventDefinitionHandle eventDef);
    internal int GetAssemblyReferenceIndexOrThrow(AssemblyReferenceHandle assemblyRef);
    internal static bool IsNested(TypeAttributes flags);
    internal bool get_HasIL();
    internal bool get_IsEntireImageAvailable();
    internal MethodBodyBlock GetMethodBodyOrThrow(MethodDefinitionHandle methodHandle);
    private static bool StringEquals(MetadataReader metadataReader, StringHandle nameHandle, string name, bool ignoreCase);
    public ModuleMetadata GetNonDisposableMetadata();
    [CompilerGeneratedAttribute]
private <>f__AnonymousType6`2<TypeDefToNamespace, string> <ComputeTypeNameCollection>b__80_0(TypeDefToNamespace typeDef);
    [CompilerGeneratedAttribute]
private string <ComputeNamespaceNameCollection>b__81_1(TypeDefToNamespace id);
}
public enum Microsoft.CodeAnalysis.Platform : Enum {
    public int value__;
    public static Platform AnyCpu;
    public static Platform X86;
    public static Platform X64;
    public static Platform Itanium;
    public static Platform AnyCpu32BitPreferred;
    public static Platform Arm;
    public static Platform Arm64;
}
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count,nq}")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1/DebuggerProxy")]
internal class Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1 : object {
    private Builder<T> _builder;
    private ObjectPool`1<ArrayBuilder`1<T>> _pool;
    private static ObjectPool`1<ArrayBuilder`1<T>> s_poolInstance;
    public int Count { get; public set; }
    public T Item { get; public set; }
    public ArrayBuilder`1(int size);
    private ArrayBuilder`1(ObjectPool`1<ArrayBuilder`1<T>> pool);
    private static ArrayBuilder`1();
    public ImmutableArray`1<T> ToImmutable();
    public sealed virtual int get_Count();
    public void set_Count(int value);
    public sealed virtual T get_Item(int index);
    public void set_Item(int index, T value);
    public void SetItem(int index, T value);
    public void Add(T item);
    public void Insert(int index, T item);
    public void EnsureCapacity(int capacity);
    public void Clear();
    public bool Contains(T item);
    public int IndexOf(T item);
    public int IndexOf(T item, IEqualityComparer`1<T> equalityComparer);
    public int IndexOf(T item, int startIndex, int count);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public void RemoveAt(int index);
    public void RemoveLast();
    public void ReverseContents();
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> compare);
    public void Sort(int startIndex, IComparer`1<T> comparer);
    public T[] ToArray();
    public void CopyTo(T[] array, int start);
    public T Last();
    public T First();
    public bool Any();
    public ImmutableArray`1<T> ToImmutableOrNull();
    public ImmutableArray`1<U> ToDowncastedImmutable();
    public ImmutableArray`1<T> ToImmutableAndFree();
    public T[] ToArrayAndFree();
    public void Free();
    public static ArrayBuilder`1<T> GetInstance();
    public static ArrayBuilder`1<T> GetInstance(int capacity);
    public static ArrayBuilder`1<T> GetInstance(int capacity, T fillWithValue);
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool();
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool(int size);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    public void AddRange(ArrayBuilder`1<T> items);
    public void AddRange(ArrayBuilder`1<U> items);
    public void AddRange(ImmutableArray`1<T> items);
    public void AddRange(ImmutableArray`1<T> items, int length);
    public void AddRange(ImmutableArray`1<S> items);
    public void AddRange(T[] items, int start, int length);
    public void AddRange(IEnumerable`1<T> items);
    public void AddRange(T[] items);
    public void AddRange(T[] items, int length);
    public void Clip(int limit);
    public void ZeroInit(int count);
    public void AddMany(T item, int count);
    public void RemoveDuplicates();
    public ImmutableArray`1<S> SelectDistinct(Func`2<T, S> selector);
}
internal class Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1 : object {
    private T _firstItem;
    private Element[] _items;
    private Factory<T> _factory;
    internal ObjectPool`1(Factory<T> factory);
    internal ObjectPool`1(Factory<T> factory, int size);
    private T CreateInstance();
    internal T Allocate();
    private T AllocateSlow();
    internal void Free(T obj);
    private void FreeSlow(T obj);
    [ConditionalAttribute("DEBUG")]
internal void ForgetTrackedObject(T old, T replacement);
    [ConditionalAttribute("DEBUG")]
private void Validate(object obj);
}
internal class Microsoft.CodeAnalysis.PooledObjects.PooledDictionary`2 : Dictionary`2<K, V> {
    private ObjectPool`1<PooledDictionary`2<K, V>> _pool;
    private static ObjectPool`1<PooledDictionary`2<K, V>> s_poolInstance;
    private PooledDictionary`2(ObjectPool`1<PooledDictionary`2<K, V>> pool);
    private static PooledDictionary`2();
    public ImmutableDictionary`2<K, V> ToImmutableDictionaryAndFree();
    public void Free();
    public static ObjectPool`1<PooledDictionary`2<K, V>> CreatePool();
    public static PooledDictionary`2<K, V> GetInstance();
}
internal class Microsoft.CodeAnalysis.PooledObjects.PooledHashSet`1 : HashSet`1<T> {
    private ObjectPool`1<PooledHashSet`1<T>> _pool;
    private static ObjectPool`1<PooledHashSet`1<T>> s_poolInstance;
    private PooledHashSet`1(ObjectPool`1<PooledHashSet`1<T>> pool);
    private static PooledHashSet`1();
    public void Free();
    public static ObjectPool`1<PooledHashSet`1<T>> CreatePool();
    public static PooledHashSet`1<T> GetInstance();
}
internal class Microsoft.CodeAnalysis.PooledObjects.PooledStopwatch : Stopwatch {
    private static ObjectPool`1<PooledStopwatch> s_poolInstance;
    private ObjectPool`1<PooledStopwatch> _pool;
    private PooledStopwatch(ObjectPool`1<PooledStopwatch> pool);
    private static PooledStopwatch();
    public void Free();
    public static ObjectPool`1<PooledStopwatch> CreatePool();
    public static PooledStopwatch StartInstance();
}
internal class Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder : object {
    public StringBuilder Builder;
    private ObjectPool`1<PooledStringBuilder> _pool;
    private static ObjectPool`1<PooledStringBuilder> s_poolInstance;
    public int Length { get; }
    private PooledStringBuilder(ObjectPool`1<PooledStringBuilder> pool);
    private static PooledStringBuilder();
    public int get_Length();
    public void Free();
    [ObsoleteAttribute("Consider calling ToStringAndFree instead.")]
public string ToString();
    public string ToStringAndFree();
    public string ToStringAndFree(int startIndex, int length);
    public static ObjectPool`1<PooledStringBuilder> CreatePool(int size);
    public static PooledStringBuilder GetInstance();
    public static StringBuilder op_Implicit(PooledStringBuilder obj);
}
public abstract class Microsoft.CodeAnalysis.PortableExecutableReference : MetadataReference {
    private string _filePath;
    private DocumentationProvider _lazyDocumentation;
    public string Display { get; }
    public string FilePath { get; }
    internal DocumentationProvider DocumentationProvider { get; }
    protected PortableExecutableReference(MetadataReferenceProperties properties, string fullPath, DocumentationProvider initialDocumentation);
    public virtual string get_Display();
    public string get_FilePath();
    internal DocumentationProvider get_DocumentationProvider();
    protected abstract virtual DocumentationProvider CreateDocumentationProvider();
    public PortableExecutableReference WithAliases(IEnumerable`1<string> aliases);
    public PortableExecutableReference WithAliases(ImmutableArray`1<string> aliases);
    public PortableExecutableReference WithEmbedInteropTypes(bool value);
    public PortableExecutableReference WithProperties(MetadataReferenceProperties properties);
    internal sealed virtual MetadataReference WithPropertiesImplReturningMetadataReference(MetadataReferenceProperties properties);
    protected abstract virtual PortableExecutableReference WithPropertiesImpl(MetadataReferenceProperties properties);
    protected abstract virtual Metadata GetMetadataImpl();
    internal Metadata GetMetadataNoCopy();
    public Metadata GetMetadata();
    public MetadataId GetMetadataId();
    internal static Diagnostic ExceptionToDiagnostic(Exception e, CommonMessageProvider messageProvider, Location location, string display, MetadataImageKind kind);
}
internal class Microsoft.CodeAnalysis.PortableStrongNameProvider : StrongNameProvider {
    private ImmutableArray`1<string> _keyFileSearchPaths;
    [CompilerGeneratedAttribute]
private StrongNameFileSystem <FileSystem>k__BackingField;
    internal StrongNameFileSystem FileSystem { get; }
    internal SigningCapability Capability { get; }
    public PortableStrongNameProvider(ImmutableArray`1<string> keySearchPaths, StrongNameFileSystem strongNameFileSystem);
    [CompilerGeneratedAttribute]
internal StrongNameFileSystem get_FileSystem();
    public virtual int GetHashCode();
    internal virtual SigningCapability get_Capability();
    internal virtual StrongNameKeys CreateKeys(string keyFilePath, string keyContainerName, CommonMessageProvider messageProvider);
    internal virtual void SignPeBuilder(ExtendedPEBuilder peBuilder, BlobBuilder peBlob, RSAParameters privkey);
    internal virtual Stream CreateInputStream();
    public virtual bool Equals(object obj);
}
public class Microsoft.CodeAnalysis.PreprocessingSymbolInfo : ValueType {
    internal static PreprocessingSymbolInfo None;
    [CompilerGeneratedAttribute]
private IPreprocessingSymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefined>k__BackingField;
    public IPreprocessingSymbol Symbol { get; }
    public bool IsDefined { get; }
    internal PreprocessingSymbolInfo(IPreprocessingSymbol symbol, bool isDefined);
    private static PreprocessingSymbolInfo();
    [CompilerGeneratedAttribute]
public IPreprocessingSymbol get_Symbol();
    [CompilerGeneratedAttribute]
public bool get_IsDefined();
    public sealed virtual bool Equals(PreprocessingSymbolInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.PrimitiveTypeCodeExtensions : object {
    [ExtensionAttribute]
public static bool IsNumeric(PrimitiveTypeCode kind);
    [ExtensionAttribute]
public static bool IsIntegral(PrimitiveTypeCode kind);
    [ExtensionAttribute]
public static bool Is64BitIntegral(PrimitiveTypeCode kind);
    [ExtensionAttribute]
public static bool IsSigned(PrimitiveTypeCode kind);
    [ExtensionAttribute]
public static bool IsUnsigned(PrimitiveTypeCode kind);
    [ExtensionAttribute]
public static bool IsFloatingPoint(PrimitiveTypeCode kind);
    [ExtensionAttribute]
public static ConstantValueTypeDiscriminator GetConstantValueTypeDiscriminator(PrimitiveTypeCode type);
}
internal class Microsoft.CodeAnalysis.ReadOnlyUnmanagedMemoryStream : Stream {
    private object _memoryOwner;
    private IntPtr _data;
    private int _length;
    private int _position;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public ReadOnlyUnmanagedMemoryStream(object memoryOwner, IntPtr data, int length);
    public virtual int ReadByte();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Flush();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal static class Microsoft.CodeAnalysis.RealParser : object {
    private static BigInteger s_bigZero;
    private static BigInteger s_bigOne;
    private static BigInteger s_bigTwo;
    private static BigInteger s_bigTen;
    private static RealParser();
    public static bool TryParseDouble(string s, Double& d);
    public static bool TryParseFloat(string s, Single& f);
    private static Status ConvertDecimalToFloatingPointBits(DecimalFloatingPointString data, FloatingPointType type, UInt64& result);
    private static Status ConvertBigIntegerToFloatingPointBits(Byte[] integerValueAsBytes, UInt32 integerBitsOfPrecision, bool hasNonzeroFractionalPart, FloatingPointType type, UInt64& result);
    private static BigInteger AccumulateDecimalDigitsIntoBigInteger(DecimalFloatingPointString data, UInt32 integer_first_index, UInt32 integer_last_index);
    private static UInt32 CountSignificantBits(ulong data);
    private static UInt32 CountSignificantBits(byte data);
    private static UInt32 CountSignificantBits(BigInteger data, Byte[]& dataBytes);
    private static UInt32 CountSignificantBits(BigInteger data);
    private static ulong RightShiftWithRounding(ulong value, int shift, bool hasZeroTail);
    private static bool ShouldRoundUp(bool lsbBit, bool roundBit, bool hasTailBits);
    private static void ShiftLeft(BigInteger& number, UInt32 shift);
    private static void MultiplyByPowerOfTen(BigInteger& number, UInt32 power);
    private static UInt32 FloatToInt32Bits(float f);
    private static float Int32BitsToFloat(UInt32 i);
}
internal class Microsoft.CodeAnalysis.ReferenceDirective : ValueType {
    public string File;
    public Location Location;
    public ReferenceDirective(string file, Location location);
}
public enum Microsoft.CodeAnalysis.RefKind : Enum {
    public byte value__;
    public static RefKind None;
    public static RefKind Ref;
    public static RefKind Out;
    public static RefKind In;
    public static RefKind RefReadOnly;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.RefKindExtensions : object {
    internal static RefKind StrictIn;
    [ExtensionAttribute]
internal static string ToParameterDisplayString(RefKind kind);
    [ExtensionAttribute]
internal static string ToArgumentDisplayString(RefKind kind);
    [ExtensionAttribute]
internal static string ToParameterPrefix(RefKind kind);
}
internal class Microsoft.CodeAnalysis.RelativePathResolver : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <SearchPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseDirectory>k__BackingField;
    public ImmutableArray`1<string> SearchPaths { get; }
    public string BaseDirectory { get; }
    public RelativePathResolver(ImmutableArray`1<string> searchPaths, string baseDirectory);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_SearchPaths();
    [CompilerGeneratedAttribute]
public string get_BaseDirectory();
    public string ResolvePath(string reference, string baseFilePath);
    protected virtual bool FileExists(string fullPath);
    public RelativePathResolver WithSearchPaths(ImmutableArray`1<string> searchPaths);
    public RelativePathResolver WithBaseDirectory(string baseDirectory);
    public sealed virtual bool Equals(RelativePathResolver other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
public enum Microsoft.CodeAnalysis.ReportDiagnostic : Enum {
    public int value__;
    public static ReportDiagnostic Default;
    public static ReportDiagnostic Error;
    public static ReportDiagnostic Warn;
    public static ReportDiagnostic Info;
    public static ReportDiagnostic Hidden;
    public static ReportDiagnostic Suppress;
}
internal abstract class Microsoft.CodeAnalysis.RequiredLanguageVersion : object {
    public abstract virtual string ToString();
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
}
internal class Microsoft.CodeAnalysis.RESOURCE : object {
    internal RESOURCE_STRING pstringType;
    internal RESOURCE_STRING pstringName;
    internal UInt32 DataSize;
    internal UInt32 HeaderSize;
    internal UInt32 DataVersion;
    internal ushort MemoryFlags;
    internal ushort LanguageId;
    internal UInt32 Version;
    internal UInt32 Characteristics;
    internal Byte[] data;
}
internal class Microsoft.CodeAnalysis.RESOURCE_STRING : object {
    internal ushort Ordinal;
    internal string theString;
}
public class Microsoft.CodeAnalysis.ResourceDescription : object {
    internal string ResourceName;
    internal string FileName;
    internal bool IsPublic;
    internal Func`1<Stream> DataProvider;
    private CryptographicHashProvider _hashes;
    internal bool IsEmbedded { get; }
    private string Microsoft.Cci.IFileReference.FileName { get; }
    private bool Microsoft.Cci.IFileReference.HasMetadata { get; }
    public ResourceDescription(string resourceName, Func`1<Stream> dataProvider, bool isPublic);
    public ResourceDescription(string resourceName, string fileName, Func`1<Stream> dataProvider, bool isPublic);
    internal ResourceDescription(string resourceName, string fileName, Func`1<Stream> dataProvider, bool isPublic, bool isEmbedded, bool checkArgs);
    internal bool get_IsEmbedded();
    internal ManagedResource ToManagedResource(CommonPEModuleBuilder moduleBeingBuilt);
    private sealed virtual override ImmutableArray`1<byte> Microsoft.Cci.IFileReference.GetHashValue(AssemblyHashAlgorithm algorithmId);
    private sealed virtual override string Microsoft.Cci.IFileReference.get_FileName();
    private sealed virtual override bool Microsoft.Cci.IFileReference.get_HasMetadata();
}
internal class Microsoft.CodeAnalysis.ResourceException : Exception {
    internal ResourceException(string name, Exception inner);
}
public class Microsoft.CodeAnalysis.RuleSet : object {
    private string _filePath;
    private ReportDiagnostic _generalDiagnosticOption;
    private ImmutableDictionary`2<string, ReportDiagnostic> _specificDiagnosticOptions;
    private ImmutableArray`1<RuleSetInclude> _includes;
    public string FilePath { get; }
    public ReportDiagnostic GeneralDiagnosticOption { get; }
    public ImmutableDictionary`2<string, ReportDiagnostic> SpecificDiagnosticOptions { get; }
    public ImmutableArray`1<RuleSetInclude> Includes { get; }
    public RuleSet(string filePath, ReportDiagnostic generalOption, ImmutableDictionary`2<string, ReportDiagnostic> specificOptions, ImmutableArray`1<RuleSetInclude> includes);
    public string get_FilePath();
    public ReportDiagnostic get_GeneralDiagnosticOption();
    public ImmutableDictionary`2<string, ReportDiagnostic> get_SpecificDiagnosticOptions();
    public ImmutableArray`1<RuleSetInclude> get_Includes();
    public RuleSet WithEffectiveAction(ReportDiagnostic action);
    private RuleSet GetEffectiveRuleSet(HashSet`1<string> includedRulesetPaths);
    private ImmutableArray`1<string> GetEffectiveIncludes();
    private void GetEffectiveIncludesCore(Builder<string> arrayBuilder);
    private static bool IsStricterThan(ReportDiagnostic action1, ReportDiagnostic action2);
    public static RuleSet LoadEffectiveRuleSetFromFile(string filePath);
    public static ImmutableArray`1<string> GetEffectiveIncludesFromFile(string filePath);
    public static ReportDiagnostic GetDiagnosticOptionsFromRulesetFile(string rulesetFileFullPath, Dictionary`2& specificDiagnosticOptions);
    internal static ReportDiagnostic GetDiagnosticOptionsFromRulesetFile(string rulesetFileFullPath, Dictionary`2& diagnosticOptions, IList`1<Diagnostic> diagnosticsOpt, CommonMessageProvider messageProviderOpt);
    private static ReportDiagnostic GetDiagnosticOptionsFromRulesetFile(Dictionary`2<string, ReportDiagnostic> diagnosticOptions, string resolvedPath, IList`1<Diagnostic> diagnosticsOpt, CommonMessageProvider messageProviderOpt);
}
public class Microsoft.CodeAnalysis.RuleSetInclude : object {
    private string _includePath;
    private ReportDiagnostic _action;
    public string IncludePath { get; }
    public ReportDiagnostic Action { get; }
    public RuleSetInclude(string includePath, ReportDiagnostic action);
    public string get_IncludePath();
    public ReportDiagnostic get_Action();
    public RuleSet LoadRuleSet(RuleSet parent);
    private string GetIncludePath(RuleSet parent);
    private static string ResolveIncludePath(string includePath, string parentRulesetPath);
    private static string ResolveIncludePathCore(string includePath, string parentRulesetPath);
}
internal class Microsoft.CodeAnalysis.RuleSetProcessor : object {
    private static string RuleSetNodeName;
    private static string RuleSetNameAttributeName;
    private static string RuleSetDescriptionAttributeName;
    private static string RuleSetToolsVersionAttributeName;
    private static string RulesNodeName;
    private static string RulesAnalyzerIdAttributeName;
    private static string RulesNamespaceAttributeName;
    private static string RuleNodeName;
    private static string RuleIdAttributeName;
    private static string IncludeNodeName;
    private static string IncludePathAttributeName;
    private static string IncludeAllNodeName;
    private static string RuleActionAttributeName;
    private static string RuleActionNoneValue;
    private static string RuleActionHiddenValue;
    private static string RuleActionInfoValue;
    private static string RuleActionWarningValue;
    private static string RuleActionErrorValue;
    private static string RuleActionDefaultValue;
    public static RuleSet LoadFromFile(string filePath);
    private static RuleSet ReadRuleSet(XElement ruleSetNode, string filePath);
    private static List`1<KeyValuePair`2<string, ReportDiagnostic>> ReadRules(XElement rulesNode);
    private static KeyValuePair`2<string, ReportDiagnostic> ReadRule(XElement ruleNode, string analyzer, string space);
    private static RuleSetInclude ReadRuleSetInclude(XElement includeNode);
    private static ReportDiagnostic ReadAction(XElement node, bool allowDefault);
    private static ReportDiagnostic ReadIncludeAll(XElement includeAllNode);
    private static string ReadNonEmptyAttribute(XElement node, string attributeName);
    private static XmlReaderSettings GetDefaultXmlReaderSettings();
    private static void ValidateAttribute(XElement node, string attributeName);
}
internal class Microsoft.CodeAnalysis.RuntimeMembers.MemberDescriptor : ValueType {
    public MemberFlags Flags;
    public short DeclaringTypeId;
    public ushort Arity;
    public string Name;
    public ImmutableArray`1<byte> Signature;
    public string DeclaringTypeMetadataName { get; }
    public int ParametersCount { get; }
    public MemberDescriptor(MemberFlags Flags, short DeclaringTypeId, string Name, ImmutableArray`1<byte> Signature, ushort Arity);
    public string get_DeclaringTypeMetadataName();
    public int get_ParametersCount();
    internal static ImmutableArray`1<MemberDescriptor> InitializeFromStream(Stream stream, String[] nameTable);
    private static short ReadTypeId(Stream stream);
    private static void ParseMethodOrPropertySignature(Builder<byte> builder, Stream stream);
    private static void ParseType(Builder<byte> builder, Stream stream, bool allowByRef);
    private static void ParseTypeHandle(Builder<byte> builder, Stream stream);
    private static void ParseGenericTypeInstance(Builder<byte> builder, Stream stream);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.RuntimeMembers.MemberFlags : Enum {
    public byte value__;
    public static MemberFlags Method;
    public static MemberFlags Field;
    public static MemberFlags Constructor;
    public static MemberFlags PropertyGet;
    public static MemberFlags Property;
    public static MemberFlags KindMask;
    public static MemberFlags Static;
    public static MemberFlags Virtual;
}
internal abstract class Microsoft.CodeAnalysis.RuntimeMembers.SignatureComparer`5 : object {
    public bool MatchFieldSignature(FieldSymbol field, ImmutableArray`1<byte> signature);
    public bool MatchPropertySignature(PropertySymbol property, ImmutableArray`1<byte> signature);
    public bool MatchMethodSignature(MethodSymbol method, ImmutableArray`1<byte> signature);
    private bool MatchParameter(ParameterSymbol parameter, ImmutableArray`1<byte> signature, Int32& position);
    private static bool IsByRef(ImmutableArray`1<byte> signature, Int32& position);
    private bool MatchType(TypeSymbol type, ImmutableArray`1<byte> signature, Int32& position);
    private static short ReadTypeId(ImmutableArray`1<byte> signature, Int32& position);
    protected abstract virtual TypeSymbol GetGenericTypeArgument(TypeSymbol type, int argumentIndex);
    protected abstract virtual TypeSymbol GetGenericTypeDefinition(TypeSymbol type);
    protected abstract virtual bool IsGenericMethodTypeParam(TypeSymbol type, int paramPosition);
    protected abstract virtual bool IsGenericTypeParam(TypeSymbol type, int paramPosition);
    protected abstract virtual TypeSymbol GetPointedToType(TypeSymbol type);
    protected abstract virtual TypeSymbol GetSZArrayElementType(TypeSymbol type);
    protected abstract virtual bool MatchArrayRank(TypeSymbol type, int countOfDimensions);
    protected abstract virtual TypeSymbol GetMDArrayElementType(TypeSymbol type);
    protected abstract virtual bool MatchTypeToTypeId(TypeSymbol type, int typeId);
    protected abstract virtual TypeSymbol GetReturnType(MethodSymbol method);
    protected abstract virtual ImmutableArray`1<ParameterSymbol> GetParameters(MethodSymbol method);
    protected abstract virtual TypeSymbol GetPropertyType(PropertySymbol property);
    protected abstract virtual ImmutableArray`1<ParameterSymbol> GetParameters(PropertySymbol property);
    protected abstract virtual TypeSymbol GetParamType(ParameterSymbol parameter);
    protected abstract virtual bool IsByRefParam(ParameterSymbol parameter);
    protected abstract virtual bool IsByRefMethod(MethodSymbol method);
    protected abstract virtual TypeSymbol GetFieldType(FieldSymbol field);
}
public abstract class Microsoft.CodeAnalysis.ScriptCompilationInfo : object {
    [CompilerGeneratedAttribute]
private Type <ReturnTypeOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <GlobalsType>k__BackingField;
    internal Type ReturnTypeOpt { get; }
    public Type ReturnType { get; }
    public Type GlobalsType { get; }
    public Compilation PreviousScriptCompilation { get; }
    internal Compilation CommonPreviousScriptCompilation { get; }
    internal ScriptCompilationInfo(Type returnType, Type globalsType);
    [CompilerGeneratedAttribute]
internal Type get_ReturnTypeOpt();
    public Type get_ReturnType();
    [CompilerGeneratedAttribute]
public Type get_GlobalsType();
    public Compilation get_PreviousScriptCompilation();
    internal abstract virtual Compilation get_CommonPreviousScriptCompilation();
    public ScriptCompilationInfo WithPreviousScriptCompilation(Compilation compilation);
    internal abstract virtual ScriptCompilationInfo CommonWithPreviousScriptCompilation(Compilation compilation);
}
internal class Microsoft.CodeAnalysis.SecurityWellKnownAttributeData : object {
    private Byte[] _lazySecurityActions;
    private String[] _lazyPathsForPermissionSetFixup;
    public void SetSecurityAttribute(int attributeIndex, DeclarativeSecurityAction action, int totalSourceAttributes);
    public void SetPathForPermissionSetAttributeFixup(int attributeIndex, string resolvedFilePath, int totalSourceAttributes);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SecurityWellKnownAttributeData/<GetSecurityAttributes>d__4`1")]
public IEnumerable`1<SecurityAttribute> GetSecurityAttributes(ImmutableArray`1<T> customAttributes);
}
public abstract class Microsoft.CodeAnalysis.SemanticModel : object {
    public string Language { get; }
    public Compilation Compilation { get; }
    protected Compilation CompilationCore { get; }
    public SyntaxTree SyntaxTree { get; }
    protected SyntaxTree SyntaxTreeCore { get; }
    public bool IgnoresAccessibility { get; }
    public bool IsSpeculativeSemanticModel { get; }
    public int OriginalPositionForSpeculation { get; }
    public SemanticModel ParentModel { get; }
    protected SemanticModel ParentModelCore { get; }
    internal SemanticModel ContainingModelOrSelf { get; }
    internal SyntaxNode Root { get; }
    protected SyntaxNode RootCore { get; }
    public abstract virtual string get_Language();
    public Compilation get_Compilation();
    protected abstract virtual Compilation get_CompilationCore();
    public SyntaxTree get_SyntaxTree();
    protected abstract virtual SyntaxTree get_SyntaxTreeCore();
    public IOperation GetOperation(SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual IOperation GetOperationCore(SyntaxNode node, CancellationToken cancellationToken);
    public virtual bool get_IgnoresAccessibility();
    internal SymbolInfo GetSymbolInfo(SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual SymbolInfo GetSymbolInfoCore(SyntaxNode node, CancellationToken cancellationToken);
    internal SymbolInfo GetSpeculativeSymbolInfo(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    protected abstract virtual SymbolInfo GetSpeculativeSymbolInfoCore(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    internal TypeInfo GetSpeculativeTypeInfo(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    protected abstract virtual TypeInfo GetSpeculativeTypeInfoCore(int position, SyntaxNode expression, SpeculativeBindingOption bindingOption);
    internal TypeInfo GetTypeInfo(SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual TypeInfo GetTypeInfoCore(SyntaxNode node, CancellationToken cancellationToken);
    internal IAliasSymbol GetAliasInfo(SyntaxNode nameSyntax, CancellationToken cancellationToken);
    protected abstract virtual IAliasSymbol GetAliasInfoCore(SyntaxNode nameSyntax, CancellationToken cancellationToken);
    public abstract virtual bool get_IsSpeculativeSemanticModel();
    public abstract virtual int get_OriginalPositionForSpeculation();
    public SemanticModel get_ParentModel();
    protected abstract virtual SemanticModel get_ParentModelCore();
    internal abstract virtual SemanticModel get_ContainingModelOrSelf();
    internal IAliasSymbol GetSpeculativeAliasInfo(int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption);
    protected abstract virtual IAliasSymbol GetSpeculativeAliasInfoCore(int position, SyntaxNode nameSyntax, SpeculativeBindingOption bindingOption);
    public abstract virtual ImmutableArray`1<Diagnostic> GetSyntaxDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<Diagnostic> GetDeclarationDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<Diagnostic> GetMethodBodyDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<Diagnostic> GetDiagnostics(Nullable`1<TextSpan> span, CancellationToken cancellationToken);
    internal ISymbol GetDeclaredSymbolForNode(SyntaxNode declaration, CancellationToken cancellationToken);
    protected abstract virtual ISymbol GetDeclaredSymbolCore(SyntaxNode declaration, CancellationToken cancellationToken);
    internal ImmutableArray`1<ISymbol> GetDeclaredSymbolsForNode(SyntaxNode declaration, CancellationToken cancellationToken);
    protected abstract virtual ImmutableArray`1<ISymbol> GetDeclaredSymbolsCore(SyntaxNode declaration, CancellationToken cancellationToken);
    public ImmutableArray`1<ISymbol> LookupSymbols(int position, INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods);
    protected abstract virtual ImmutableArray`1<ISymbol> LookupSymbolsCore(int position, INamespaceOrTypeSymbol container, string name, bool includeReducedExtensionMethods);
    public ImmutableArray`1<ISymbol> LookupBaseMembers(int position, string name);
    protected abstract virtual ImmutableArray`1<ISymbol> LookupBaseMembersCore(int position, string name);
    public ImmutableArray`1<ISymbol> LookupStaticMembers(int position, INamespaceOrTypeSymbol container, string name);
    protected abstract virtual ImmutableArray`1<ISymbol> LookupStaticMembersCore(int position, INamespaceOrTypeSymbol container, string name);
    public ImmutableArray`1<ISymbol> LookupNamespacesAndTypes(int position, INamespaceOrTypeSymbol container, string name);
    protected abstract virtual ImmutableArray`1<ISymbol> LookupNamespacesAndTypesCore(int position, INamespaceOrTypeSymbol container, string name);
    public ImmutableArray`1<ISymbol> LookupLabels(int position, string name);
    protected abstract virtual ImmutableArray`1<ISymbol> LookupLabelsCore(int position, string name);
    internal ControlFlowAnalysis AnalyzeControlFlow(SyntaxNode firstStatement, SyntaxNode lastStatement);
    protected abstract virtual ControlFlowAnalysis AnalyzeControlFlowCore(SyntaxNode firstStatement, SyntaxNode lastStatement);
    internal ControlFlowAnalysis AnalyzeControlFlow(SyntaxNode statement);
    protected abstract virtual ControlFlowAnalysis AnalyzeControlFlowCore(SyntaxNode statement);
    internal DataFlowAnalysis AnalyzeDataFlow(SyntaxNode firstStatement, SyntaxNode lastStatement);
    protected abstract virtual DataFlowAnalysis AnalyzeDataFlowCore(SyntaxNode firstStatement, SyntaxNode lastStatement);
    internal DataFlowAnalysis AnalyzeDataFlow(SyntaxNode statementOrExpression);
    protected abstract virtual DataFlowAnalysis AnalyzeDataFlowCore(SyntaxNode statementOrExpression);
    public Optional`1<object> GetConstantValue(SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual Optional`1<object> GetConstantValueCore(SyntaxNode node, CancellationToken cancellationToken);
    internal ImmutableArray`1<ISymbol> GetMemberGroup(SyntaxNode node, CancellationToken cancellationToken);
    protected abstract virtual ImmutableArray`1<ISymbol> GetMemberGroupCore(SyntaxNode node, CancellationToken cancellationToken);
    public ISymbol GetEnclosingSymbol(int position, CancellationToken cancellationToken);
    protected abstract virtual ISymbol GetEnclosingSymbolCore(int position, CancellationToken cancellationToken);
    public bool IsAccessible(int position, ISymbol symbol);
    protected abstract virtual bool IsAccessibleCore(int position, ISymbol symbol);
    public bool IsEventUsableAsField(int position, IEventSymbol eventSymbol);
    protected abstract virtual bool IsEventUsableAsFieldCore(int position, IEventSymbol eventSymbol);
    public PreprocessingSymbolInfo GetPreprocessingSymbolInfo(SyntaxNode nameSyntax);
    protected abstract virtual PreprocessingSymbolInfo GetPreprocessingSymbolInfoCore(SyntaxNode nameSyntax);
    internal abstract virtual void ComputeDeclarationsInSpan(TextSpan span, bool getSymbol, ArrayBuilder`1<DeclarationInfo> builder, CancellationToken cancellationToken);
    internal abstract virtual void ComputeDeclarationsInNode(SyntaxNode node, bool getSymbol, ArrayBuilder`1<DeclarationInfo> builder, CancellationToken cancellationToken, Nullable`1<int> levelsToCompute);
    protected internal virtual SyntaxNode GetTopmostNodeForDiagnosticAnalysis(ISymbol symbol, SyntaxNode declaringSyntax);
    internal SyntaxNode get_Root();
    protected abstract virtual SyntaxNode get_RootCore();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.SeparatedSyntaxList`1 : ValueType {
    private SyntaxNodeOrTokenList _list;
    private int _count;
    private int _separatorCount;
    internal SyntaxNode Node { get; }
    public int Count { get; }
    public int SeparatorCount { get; }
    public TNode Item { get; }
    public TextSpan FullSpan { get; }
    public TextSpan Span { get; }
    private TNode[] Nodes { get; }
    private SyntaxNodeOrToken[] NodesWithSeparators { get; }
    internal SeparatedSyntaxList`1(SyntaxNodeOrTokenList list);
    internal SeparatedSyntaxList`1(SyntaxNode node, int index);
    [ConditionalAttribute("DEBUG")]
private static void Validate(SyntaxNodeOrTokenList list);
    internal SyntaxNode get_Node();
    public sealed virtual int get_Count();
    public int get_SeparatorCount();
    public sealed virtual TNode get_Item(int index);
    public SyntaxToken GetSeparator(int index);
    public IEnumerable`1<SyntaxToken> GetSeparators();
    public TextSpan get_FullSpan();
    public TextSpan get_Span();
    public virtual string ToString();
    public string ToFullString();
    public TNode First();
    public TNode FirstOrDefault();
    public TNode Last();
    public TNode LastOrDefault();
    public bool Contains(TNode node);
    public int IndexOf(TNode node);
    public int IndexOf(Func`2<TNode, bool> predicate);
    internal int IndexOf(int rawKind);
    public int LastIndexOf(TNode node);
    public int LastIndexOf(Func`2<TNode, bool> predicate);
    public bool Any();
    internal bool Any(Func`2<TNode, bool> predicate);
    public SyntaxNodeOrTokenList GetWithSeparators();
    public static bool op_Equality(SeparatedSyntaxList`1<TNode> left, SeparatedSyntaxList`1<TNode> right);
    public static bool op_Inequality(SeparatedSyntaxList`1<TNode> left, SeparatedSyntaxList`1<TNode> right);
    public sealed virtual bool Equals(SeparatedSyntaxList`1<TNode> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public SeparatedSyntaxList`1<TNode> Add(TNode node);
    public SeparatedSyntaxList`1<TNode> AddRange(IEnumerable`1<TNode> nodes);
    public SeparatedSyntaxList`1<TNode> Insert(int index, TNode node);
    public SeparatedSyntaxList`1<TNode> InsertRange(int index, IEnumerable`1<TNode> nodes);
    private static bool KeepSeparatorWithPreviousNode(SyntaxToken& separator);
    public SeparatedSyntaxList`1<TNode> RemoveAt(int index);
    public SeparatedSyntaxList`1<TNode> Remove(TNode node);
    public SeparatedSyntaxList`1<TNode> Replace(TNode nodeInList, TNode newNode);
    public SeparatedSyntaxList`1<TNode> ReplaceRange(TNode nodeInList, IEnumerable`1<TNode> newNodes);
    public SeparatedSyntaxList`1<TNode> ReplaceSeparator(SyntaxToken separatorToken, SyntaxToken newSeparator);
    private TNode[] get_Nodes();
    private SyntaxNodeOrToken[] get_NodesWithSeparators();
    public Enumerator<TNode> GetEnumerator();
    private sealed virtual override IEnumerator`1<TNode> System.Collections.Generic.IEnumerable<TNode>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static SeparatedSyntaxList`1<SyntaxNode> op_Implicit(SeparatedSyntaxList`1<TNode> nodes);
    public static SeparatedSyntaxList`1<TNode> op_Implicit(SeparatedSyntaxList`1<SyntaxNode> nodes);
}
internal enum Microsoft.CodeAnalysis.SigningCapability : Enum {
    public int value__;
    public static SigningCapability SignsStream;
    public static SigningCapability SignsPeBuilder;
}
internal static class Microsoft.CodeAnalysis.SigningUtilities : object {
    internal static Byte[] CalculateRsaSignature(IEnumerable`1<Blob> content, RSAParameters privateKey);
    internal static Byte[] CalculateSha1(IEnumerable`1<Blob> content);
    internal static int CalculateStrongNameSignatureSize(CommonPEModuleBuilder module, Nullable`1<RSAParameters> privateKey);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.SmallDictionary`2 : object {
    private AvlNode<K, V> _root;
    private IEqualityComparer`1<K> _comparer;
    public static SmallDictionary`2<K, V> Empty;
    public V Item { get; public set; }
    public KeyCollection<K, V> Keys { get; }
    public ValueCollection<K, V> Values { get; }
    public SmallDictionary`2(IEqualityComparer`1<K> comparer);
    public SmallDictionary`2(SmallDictionary`2<K, V> other, IEqualityComparer`1<K> comparer);
    private static SmallDictionary`2();
    private bool CompareKeys(K k1, K k2);
    private int GetHashCode(K k);
    public bool TryGetValue(K key, V& value);
    public void Add(K key, V value);
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public bool ContainsKey(K key);
    [ConditionalAttribute("DEBUG")]
internal void AssertBalanced();
    private bool TryGetValue(int hashCode, K key, V& value);
    private bool GetFromList(Node<K, V> next, K key, V& value);
    private void Insert(int hashCode, K key, V value, bool add);
    private static AvlNode<K, V> LeftSimple(AvlNode<K, V> unbalanced);
    private static AvlNode<K, V> RightSimple(AvlNode<K, V> unbalanced);
    private static AvlNode<K, V> LeftComplex(AvlNode<K, V> unbalanced);
    private static AvlNode<K, V> RightComplex(AvlNode<K, V> unbalanced);
    private void HandleInsert(AvlNode<K, V> node, AvlNode<K, V> parent, K key, V value, bool add);
    private void AddNode(AvlNode<K, V> node, AvlNode<K, V> parent, K key, V value);
    public KeyCollection<K, V> get_Keys();
    public ValueCollection<K, V> get_Values();
    public Enumerator<K, V> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<K, V>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,V>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private int HeightApprox();
}
public enum Microsoft.CodeAnalysis.SourceCodeKind : Enum {
    public int value__;
    public static SourceCodeKind Regular;
    public static SourceCodeKind Script;
    [ObsoleteAttribute("Use Script instead", "False")]
[EditorBrowsableAttribute("1")]
public static SourceCodeKind Interactive;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SourceCodeKindExtensions : object {
    [ExtensionAttribute]
internal static SourceCodeKind MapSpecifiedToEffectiveKind(SourceCodeKind kind);
    [ExtensionAttribute]
internal static bool IsValid(SourceCodeKind value);
}
public class Microsoft.CodeAnalysis.SourceFileResolver : SourceReferenceResolver {
    [CompilerGeneratedAttribute]
private static SourceFileResolver <Default>k__BackingField;
    private string _baseDirectory;
    private ImmutableArray`1<string> _searchPaths;
    private ImmutableArray`1<KeyValuePair`2<string, string>> _pathMap;
    public static SourceFileResolver Default { get; }
    public string BaseDirectory { get; }
    public ImmutableArray`1<string> SearchPaths { get; }
    public ImmutableArray`1<KeyValuePair`2<string, string>> PathMap { get; }
    public SourceFileResolver(IEnumerable`1<string> searchPaths, string baseDirectory);
    public SourceFileResolver(ImmutableArray`1<string> searchPaths, string baseDirectory);
    public SourceFileResolver(ImmutableArray`1<string> searchPaths, string baseDirectory, ImmutableArray`1<KeyValuePair`2<string, string>> pathMap);
    private static SourceFileResolver();
    [CompilerGeneratedAttribute]
public static SourceFileResolver get_Default();
    public string get_BaseDirectory();
    public ImmutableArray`1<string> get_SearchPaths();
    public ImmutableArray`1<KeyValuePair`2<string, string>> get_PathMap();
    public virtual string NormalizePath(string path, string baseFilePath);
    public virtual string ResolveReference(string path, string baseFilePath);
    public virtual Stream OpenRead(string resolvedPath);
    protected virtual bool FileExists(string resolvedPath);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SourceFileResolver other);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.SourceLocation : Location {
    private SyntaxTree _syntaxTree;
    private TextSpan _span;
    public LocationKind Kind { get; }
    public TextSpan SourceSpan { get; }
    public SyntaxTree SourceTree { get; }
    public SourceLocation(SyntaxTree syntaxTree, TextSpan span);
    public SourceLocation(SyntaxNode node);
    public SourceLocation(SyntaxToken& token);
    public SourceLocation(SyntaxNodeOrToken& nodeOrToken);
    public SourceLocation(SyntaxTrivia& trivia);
    public SourceLocation(SyntaxReference syntaxRef);
    public virtual LocationKind get_Kind();
    public virtual TextSpan get_SourceSpan();
    public virtual SyntaxTree get_SourceTree();
    public virtual FileLinePositionSpan GetLineSpan();
    public virtual FileLinePositionSpan GetMappedLineSpan();
    public sealed virtual bool Equals(SourceLocation other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected virtual string GetDebuggerDisplay();
}
public abstract class Microsoft.CodeAnalysis.SourceReferenceResolver : object {
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual string NormalizePath(string path, string baseFilePath);
    public abstract virtual string ResolveReference(string path, string baseFilePath);
    public abstract virtual Stream OpenRead(string resolvedPath);
    internal Stream OpenReadChecked(string fullPath);
    public virtual SourceText ReadText(string resolvedPath);
}
internal enum Microsoft.CodeAnalysis.SpecialMember : Enum {
    public int value__;
    public static SpecialMember System_String__CtorSZArrayChar;
    public static SpecialMember System_String__ConcatStringString;
    public static SpecialMember System_String__ConcatStringStringString;
    public static SpecialMember System_String__ConcatStringStringStringString;
    public static SpecialMember System_String__ConcatStringArray;
    public static SpecialMember System_String__ConcatObject;
    public static SpecialMember System_String__ConcatObjectObject;
    public static SpecialMember System_String__ConcatObjectObjectObject;
    public static SpecialMember System_String__ConcatObjectArray;
    public static SpecialMember System_String__op_Equality;
    public static SpecialMember System_String__op_Inequality;
    public static SpecialMember System_String__Length;
    public static SpecialMember System_String__Chars;
    public static SpecialMember System_String__Format;
    public static SpecialMember System_Delegate__Combine;
    public static SpecialMember System_Delegate__Remove;
    public static SpecialMember System_Delegate__op_Equality;
    public static SpecialMember System_Delegate__op_Inequality;
    public static SpecialMember System_Decimal__Zero;
    public static SpecialMember System_Decimal__MinusOne;
    public static SpecialMember System_Decimal__One;
    public static SpecialMember System_Decimal__CtorInt32;
    public static SpecialMember System_Decimal__CtorUInt32;
    public static SpecialMember System_Decimal__CtorInt64;
    public static SpecialMember System_Decimal__CtorUInt64;
    public static SpecialMember System_Decimal__CtorSingle;
    public static SpecialMember System_Decimal__CtorDouble;
    public static SpecialMember System_Decimal__CtorInt32Int32Int32BooleanByte;
    public static SpecialMember System_Decimal__op_Addition;
    public static SpecialMember System_Decimal__op_Subtraction;
    public static SpecialMember System_Decimal__op_Multiply;
    public static SpecialMember System_Decimal__op_Division;
    public static SpecialMember System_Decimal__op_Modulus;
    public static SpecialMember System_Decimal__op_UnaryNegation;
    public static SpecialMember System_Decimal__op_Increment;
    public static SpecialMember System_Decimal__op_Decrement;
    public static SpecialMember System_Decimal__NegateDecimal;
    public static SpecialMember System_Decimal__RemainderDecimalDecimal;
    public static SpecialMember System_Decimal__AddDecimalDecimal;
    public static SpecialMember System_Decimal__SubtractDecimalDecimal;
    public static SpecialMember System_Decimal__MultiplyDecimalDecimal;
    public static SpecialMember System_Decimal__DivideDecimalDecimal;
    public static SpecialMember System_Decimal__ModuloDecimalDecimal;
    public static SpecialMember System_Decimal__CompareDecimalDecimal;
    public static SpecialMember System_Decimal__op_Equality;
    public static SpecialMember System_Decimal__op_Inequality;
    public static SpecialMember System_Decimal__op_GreaterThan;
    public static SpecialMember System_Decimal__op_GreaterThanOrEqual;
    public static SpecialMember System_Decimal__op_LessThan;
    public static SpecialMember System_Decimal__op_LessThanOrEqual;
    public static SpecialMember System_Decimal__op_Implicit_FromByte;
    public static SpecialMember System_Decimal__op_Implicit_FromChar;
    public static SpecialMember System_Decimal__op_Implicit_FromInt16;
    public static SpecialMember System_Decimal__op_Implicit_FromInt32;
    public static SpecialMember System_Decimal__op_Implicit_FromInt64;
    public static SpecialMember System_Decimal__op_Implicit_FromSByte;
    public static SpecialMember System_Decimal__op_Implicit_FromUInt16;
    public static SpecialMember System_Decimal__op_Implicit_FromUInt32;
    public static SpecialMember System_Decimal__op_Implicit_FromUInt64;
    public static SpecialMember System_Decimal__op_Explicit_ToByte;
    public static SpecialMember System_Decimal__op_Explicit_ToUInt16;
    public static SpecialMember System_Decimal__op_Explicit_ToSByte;
    public static SpecialMember System_Decimal__op_Explicit_ToInt16;
    public static SpecialMember System_Decimal__op_Explicit_ToSingle;
    public static SpecialMember System_Decimal__op_Explicit_ToDouble;
    public static SpecialMember System_Decimal__op_Explicit_ToChar;
    public static SpecialMember System_Decimal__op_Explicit_ToUInt64;
    public static SpecialMember System_Decimal__op_Explicit_ToInt32;
    public static SpecialMember System_Decimal__op_Explicit_ToUInt32;
    public static SpecialMember System_Decimal__op_Explicit_ToInt64;
    public static SpecialMember System_Decimal__op_Explicit_FromDouble;
    public static SpecialMember System_Decimal__op_Explicit_FromSingle;
    public static SpecialMember System_DateTime__MinValue;
    public static SpecialMember System_DateTime__CtorInt64;
    public static SpecialMember System_DateTime__CompareDateTimeDateTime;
    public static SpecialMember System_DateTime__op_Equality;
    public static SpecialMember System_DateTime__op_Inequality;
    public static SpecialMember System_DateTime__op_GreaterThan;
    public static SpecialMember System_DateTime__op_GreaterThanOrEqual;
    public static SpecialMember System_DateTime__op_LessThan;
    public static SpecialMember System_DateTime__op_LessThanOrEqual;
    public static SpecialMember System_Collections_IEnumerable__GetEnumerator;
    public static SpecialMember System_Collections_IEnumerator__Current;
    public static SpecialMember System_Collections_IEnumerator__get_Current;
    public static SpecialMember System_Collections_IEnumerator__MoveNext;
    public static SpecialMember System_Collections_IEnumerator__Reset;
    public static SpecialMember System_Collections_Generic_IEnumerable_T__GetEnumerator;
    public static SpecialMember System_Collections_Generic_IEnumerator_T__Current;
    public static SpecialMember System_Collections_Generic_IEnumerator_T__get_Current;
    public static SpecialMember System_IDisposable__Dispose;
    public static SpecialMember System_Array__Length;
    public static SpecialMember System_Array__LongLength;
    public static SpecialMember System_Array__GetLowerBound;
    public static SpecialMember System_Array__GetUpperBound;
    public static SpecialMember System_Object__GetHashCode;
    public static SpecialMember System_Object__Equals;
    public static SpecialMember System_Object__ToString;
    public static SpecialMember System_Object__ReferenceEquals;
    public static SpecialMember System_IntPtr__op_Explicit_ToPointer;
    public static SpecialMember System_IntPtr__op_Explicit_ToInt32;
    public static SpecialMember System_IntPtr__op_Explicit_ToInt64;
    public static SpecialMember System_IntPtr__op_Explicit_FromPointer;
    public static SpecialMember System_IntPtr__op_Explicit_FromInt32;
    public static SpecialMember System_IntPtr__op_Explicit_FromInt64;
    public static SpecialMember System_UIntPtr__op_Explicit_ToPointer;
    public static SpecialMember System_UIntPtr__op_Explicit_ToUInt32;
    public static SpecialMember System_UIntPtr__op_Explicit_ToUInt64;
    public static SpecialMember System_UIntPtr__op_Explicit_FromPointer;
    public static SpecialMember System_UIntPtr__op_Explicit_FromUInt32;
    public static SpecialMember System_UIntPtr__op_Explicit_FromUInt64;
    public static SpecialMember System_Nullable_T_GetValueOrDefault;
    public static SpecialMember System_Nullable_T_get_Value;
    public static SpecialMember System_Nullable_T_get_HasValue;
    public static SpecialMember System_Nullable_T__ctor;
    public static SpecialMember System_Nullable_T__op_Implicit_FromT;
    public static SpecialMember System_Nullable_T__op_Explicit_ToT;
    public static SpecialMember Count;
}
internal static class Microsoft.CodeAnalysis.SpecialMembers : object {
    private static ImmutableArray`1<MemberDescriptor> s_descriptors;
    private static SpecialMembers();
    public static MemberDescriptor GetDescriptor(SpecialMember member);
}
public enum Microsoft.CodeAnalysis.SpecialType : Enum {
    public sbyte value__;
    public static SpecialType None;
    public static SpecialType System_Object;
    public static SpecialType System_Enum;
    public static SpecialType System_MulticastDelegate;
    public static SpecialType System_Delegate;
    public static SpecialType System_ValueType;
    public static SpecialType System_Void;
    public static SpecialType System_Boolean;
    public static SpecialType System_Char;
    public static SpecialType System_SByte;
    public static SpecialType System_Byte;
    public static SpecialType System_Int16;
    public static SpecialType System_UInt16;
    public static SpecialType System_Int32;
    public static SpecialType System_UInt32;
    public static SpecialType System_Int64;
    public static SpecialType System_UInt64;
    public static SpecialType System_Decimal;
    public static SpecialType System_Single;
    public static SpecialType System_Double;
    public static SpecialType System_String;
    public static SpecialType System_IntPtr;
    public static SpecialType System_UIntPtr;
    public static SpecialType System_Array;
    public static SpecialType System_Collections_IEnumerable;
    public static SpecialType System_Collections_Generic_IEnumerable_T;
    public static SpecialType System_Collections_Generic_IList_T;
    public static SpecialType System_Collections_Generic_ICollection_T;
    public static SpecialType System_Collections_IEnumerator;
    public static SpecialType System_Collections_Generic_IEnumerator_T;
    public static SpecialType System_Collections_Generic_IReadOnlyList_T;
    public static SpecialType System_Collections_Generic_IReadOnlyCollection_T;
    public static SpecialType System_Nullable_T;
    public static SpecialType System_DateTime;
    public static SpecialType System_Runtime_CompilerServices_IsVolatile;
    public static SpecialType System_IDisposable;
    public static SpecialType System_TypedReference;
    public static SpecialType System_ArgIterator;
    public static SpecialType System_RuntimeArgumentHandle;
    public static SpecialType System_RuntimeFieldHandle;
    public static SpecialType System_RuntimeMethodHandle;
    public static SpecialType System_RuntimeTypeHandle;
    public static SpecialType System_IAsyncResult;
    public static SpecialType System_AsyncCallback;
    public static SpecialType Count;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SpecialTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsClrInteger(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsBlittable(SpecialType specialType);
    [ExtensionAttribute]
public static int SizeInBytes(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsPrimitiveRecursiveStruct(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsValidEnumUnderlyingType(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsNumericType(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsUnsignedIntegralType(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsSignedIntegralType(SpecialType specialType);
    [ExtensionAttribute]
public static int VBForToShiftBits(SpecialType specialType);
    public static SpecialType FromRuntimeTypeOfLiteralValue(object value);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SpecialTypes : object {
    private static String[] s_emittedNames;
    private static Dictionary`2<string, SpecialType> s_nameToTypeIdMap;
    private static PrimitiveTypeCode[] s_typeIdToTypeCodeMap;
    private static SpecialType[] s_typeCodeToTypeIdMap;
    private static SpecialTypes();
    [ExtensionAttribute]
public static string GetMetadataName(SpecialType id);
    public static SpecialType GetTypeFromMetadataName(string metadataName);
    public static SpecialType GetTypeFromMetadataName(PrimitiveTypeCode typeCode);
    public static PrimitiveTypeCode GetTypeCode(SpecialType typeId);
}
public enum Microsoft.CodeAnalysis.SpeculativeBindingOption : Enum {
    public int value__;
    public static SpeculativeBindingOption BindAsExpression;
    public static SpeculativeBindingOption BindAsTypeOrNamespace;
}
internal static class Microsoft.CodeAnalysis.StackGuard : object {
    public static int MaxUncheckedRecursionDepth;
    public static void EnsureSufficientExecutionStack(int recursionDepth);
    public static bool IsInsufficientExecutionStackException(Exception ex);
}
internal static class Microsoft.CodeAnalysis.StaticCast`1 : object {
    internal static ImmutableArray`1<T> From(ImmutableArray`1<TDerived> from);
}
internal class Microsoft.CodeAnalysis.StreamErrorLogger : ErrorLogger {
    private JsonWriter _writer;
    private DiagnosticDescriptorSet _descriptors;
    private CultureInfo _culture;
    private static Uri _fileRoot;
    public StreamErrorLogger(Stream stream, string toolName, string toolFileVersion, Version toolAssemblyVersion, CultureInfo culture);
    private static StreamErrorLogger();
    public virtual void LogDiagnostic(Diagnostic diagnostic);
    private void WriteLocations(Location location, IReadOnlyList`1<Location> additionalLocations);
    private void WritePhysicalLocation(Location location);
    private static bool HasPath(Location location);
    private static string GetUri(string path);
    private void WriteProperties(Diagnostic diagnostic);
    private void WriteRules();
    private static string GetLevel(DiagnosticSeverity severity);
    public sealed virtual void Dispose();
}
internal class Microsoft.CodeAnalysis.StrongNameFileSystem : object {
    internal static StrongNameFileSystem Instance;
    private static StrongNameFileSystem();
    internal virtual Byte[] ReadAllBytes(string fullPath);
    internal string ResolveStrongNameKeyFile(string path, ImmutableArray`1<string> keyFileSearchPaths);
    internal virtual bool FileExists(string fullPath);
}
internal class Microsoft.CodeAnalysis.StrongNameKeys : object {
    internal ImmutableArray`1<byte> KeyPair;
    internal ImmutableArray`1<byte> PublicKey;
    internal Nullable`1<RSAParameters> PrivateKey;
    internal Diagnostic DiagnosticOpt;
    internal string KeyContainer;
    internal string KeyFilePath;
    internal static StrongNameKeys None;
    private static Tuple`3<ImmutableArray`1<byte>, ImmutableArray`1<byte>, Nullable`1<RSAParameters>> s_lastSeenKeyPair;
    internal bool CanSign { get; }
    internal bool CanProvideStrongName { get; }
    internal StrongNameKeys(Diagnostic diagnostic);
    internal StrongNameKeys(ImmutableArray`1<byte> keyPair, ImmutableArray`1<byte> publicKey, Nullable`1<RSAParameters> privateKey, string keyContainerName, string keyFilePath);
    private static StrongNameKeys();
    internal static StrongNameKeys Create(ImmutableArray`1<byte> publicKey, Nullable`1<RSAParameters> privateKey, CommonMessageProvider messageProvider);
    internal static StrongNameKeys Create(string keyFilePath, CommonMessageProvider messageProvider);
    internal static StrongNameKeys CreateHelper(ImmutableArray`1<byte> keyFileContent, string keyFilePath);
    internal static StrongNameKeys Create(StrongNameProvider providerOpt, string keyFilePath, string keyContainerName, CommonMessageProvider messageProvider);
    internal bool get_CanSign();
    internal bool get_CanProvideStrongName();
    internal static Diagnostic GetError(string keyFilePath, string keyContainerName, object message, CommonMessageProvider messageProvider);
    internal static Diagnostic GetContainerError(CommonMessageProvider messageProvider, string name, object message);
    internal static Diagnostic GetKeyFileError(CommonMessageProvider messageProvider, string path, object message);
    internal static bool IsValidPublicKeyString(string publicKey);
}
public abstract class Microsoft.CodeAnalysis.StrongNameProvider : object {
    internal SigningCapability Capability { get; }
    public abstract virtual int GetHashCode();
    public abstract virtual bool Equals(object other);
    internal abstract virtual SigningCapability get_Capability();
    internal abstract virtual Stream CreateInputStream();
    internal abstract virtual StrongNameKeys CreateKeys(string keyFilePath, string keyContainerName, CommonMessageProvider messageProvider);
    internal StrongNameKeys CommonCreateKeys(StrongNameFileSystem fileSystem, string keyFilePath, ImmutableArray`1<string> keyFileSearchPaths, CommonMessageProvider messageProvider);
    internal virtual void SignStream(StrongNameKeys keys, Stream inputStream, Stream outputStream);
    internal virtual void SignPeBuilder(ExtendedPEBuilder peBuilder, BlobBuilder peBlob, RSAParameters privkey);
}
public class Microsoft.CodeAnalysis.SubsystemVersion : ValueType {
    [CompilerGeneratedAttribute]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Minor>k__BackingField;
    public int Major { get; }
    public int Minor { get; }
    public static SubsystemVersion None { get; }
    public static SubsystemVersion Windows2000 { get; }
    public static SubsystemVersion WindowsXP { get; }
    public static SubsystemVersion WindowsVista { get; }
    public static SubsystemVersion Windows7 { get; }
    public static SubsystemVersion Windows8 { get; }
    public bool IsValid { get; }
    private SubsystemVersion(int major, int minor);
    [CompilerGeneratedAttribute]
public int get_Major();
    [CompilerGeneratedAttribute]
public int get_Minor();
    public static SubsystemVersion get_None();
    public static SubsystemVersion get_Windows2000();
    public static SubsystemVersion get_WindowsXP();
    public static SubsystemVersion get_WindowsVista();
    public static SubsystemVersion get_Windows7();
    public static SubsystemVersion get_Windows8();
    public static bool TryParse(string str, SubsystemVersion& version);
    public static SubsystemVersion Create(int major, int minor);
    internal static SubsystemVersion Default(OutputKind outputKind, Platform platform);
    public bool get_IsValid();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(SubsystemVersion other);
    public virtual string ToString();
}
internal static class Microsoft.CodeAnalysis.SwitchConstantValueHelper : object {
    public static bool IsValidSwitchCaseLabelConstant(ConstantValue constant);
    public static int CompareSwitchCaseLabelConstants(ConstantValue first, ConstantValue second);
}
internal abstract class Microsoft.CodeAnalysis.SymbolDisplay.AbstractSymbolDisplayVisitor : SymbolVisitor {
    protected ArrayBuilder`1<SymbolDisplayPart> builder;
    protected SymbolDisplayFormat format;
    protected bool isFirstSymbolVisited;
    protected bool inNamespaceOrType;
    protected SemanticModel semanticModelOpt;
    protected int positionOpt;
    private AbstractSymbolDisplayVisitor _lazyNotFirstVisitor;
    private AbstractSymbolDisplayVisitor _lazyNotFirstVisitorNamespaceOrType;
    protected AbstractSymbolDisplayVisitor NotFirstVisitor { get; }
    protected AbstractSymbolDisplayVisitor NotFirstVisitorNamespaceOrType { get; }
    protected bool IsMinimizing { get; }
    protected AbstractSymbolDisplayVisitor(ArrayBuilder`1<SymbolDisplayPart> builder, SymbolDisplayFormat format, bool isFirstSymbolVisited, SemanticModel semanticModelOpt, int positionOpt, bool inNamespaceOrType);
    protected AbstractSymbolDisplayVisitor get_NotFirstVisitor();
    protected AbstractSymbolDisplayVisitor get_NotFirstVisitorNamespaceOrType();
    protected abstract virtual AbstractSymbolDisplayVisitor MakeNotFirstVisitor(bool inNamespaceOrType);
    protected abstract virtual void AddLiteralValue(SpecialType type, object value);
    protected abstract virtual void AddExplicitlyCastedLiteralValue(INamedTypeSymbol namedType, SpecialType type, object value);
    protected abstract virtual void AddSpace();
    protected abstract virtual void AddBitwiseOr();
    protected void AddNonNullConstantValue(ITypeSymbol type, object constantValue, bool preferNumericValueOrExpandedFlagsForEnum);
    private void AddEnumConstantValue(INamedTypeSymbol enumType, object constantValue, bool preferNumericValueOrExpandedFlags);
    private static bool IsFlagsEnum(ITypeSymbol typeSymbol);
    private void AddFlagsEnumConstantValue(INamedTypeSymbol enumType, object constantValue, bool preferNumericValueOrExpandedFlags);
    private void AddFlagsEnumConstantValue(INamedTypeSymbol enumType, object constantValue, ArrayBuilder`1<EnumField> allFieldsAndValues, ArrayBuilder`1<EnumField> usedFieldsAndValues, bool preferNumericValueOrExpandedFlags);
    private static void GetSortedEnumFields(INamedTypeSymbol enumType, ArrayBuilder`1<EnumField> enumFields);
    private void AddNonFlagsEnumConstantValue(INamedTypeSymbol enumType, object constantValue);
    protected abstract virtual bool ShouldRestrictMinimallyQualifyLookupToNamespacesAndTypes();
    protected bool get_IsMinimizing();
    protected bool NameBoundSuccessfullyToSameSymbol(INamedTypeSymbol symbol);
    private static ISymbol SingleSymbolWithArity(ImmutableArray`1<ISymbol> candidates, int desiredArity);
    protected static ITypeSymbol GetSymbolType(ISymbol symbol);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.SymbolDisplayCompilerInternalOptions : Enum {
    public int value__;
    public static SymbolDisplayCompilerInternalOptions None;
    public static SymbolDisplayCompilerInternalOptions UseMetadataMethodNames;
    public static SymbolDisplayCompilerInternalOptions UseArityForGenericTypes;
    public static SymbolDisplayCompilerInternalOptions FlagMissingMetadataTypes;
    public static SymbolDisplayCompilerInternalOptions IncludeScriptType;
    public static SymbolDisplayCompilerInternalOptions IncludeCustomModifiers;
    public static SymbolDisplayCompilerInternalOptions ReverseArrayRankSpecifiers;
}
public enum Microsoft.CodeAnalysis.SymbolDisplayDelegateStyle : Enum {
    public int value__;
    public static SymbolDisplayDelegateStyle NameOnly;
    public static SymbolDisplayDelegateStyle NameAndParameters;
    public static SymbolDisplayDelegateStyle NameAndSignature;
}
public enum Microsoft.CodeAnalysis.SymbolDisplayExtensionMethodStyle : Enum {
    public int value__;
    public static SymbolDisplayExtensionMethodStyle Default;
    public static SymbolDisplayExtensionMethodStyle InstanceMethod;
    public static SymbolDisplayExtensionMethodStyle StaticMethod;
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.SymbolDisplayExtensions : object {
    [ExtensionAttribute]
public static string ToDisplayString(ImmutableArray`1<SymbolDisplayPart> parts);
    [ExtensionAttribute]
internal static bool IncludesOption(SymbolDisplayCompilerInternalOptions options, SymbolDisplayCompilerInternalOptions flag);
    [ExtensionAttribute]
internal static bool IncludesOption(SymbolDisplayGenericsOptions options, SymbolDisplayGenericsOptions flag);
    [ExtensionAttribute]
internal static bool IncludesOption(SymbolDisplayMemberOptions options, SymbolDisplayMemberOptions flag);
    [ExtensionAttribute]
internal static bool IncludesOption(SymbolDisplayMiscellaneousOptions options, SymbolDisplayMiscellaneousOptions flag);
    [ExtensionAttribute]
internal static bool IncludesOption(SymbolDisplayParameterOptions options, SymbolDisplayParameterOptions flag);
    [ExtensionAttribute]
internal static bool IncludesOption(SymbolDisplayKindOptions options, SymbolDisplayKindOptions flag);
    [ExtensionAttribute]
internal static bool IncludesOption(SymbolDisplayLocalOptions options, SymbolDisplayLocalOptions flag);
}
public class Microsoft.CodeAnalysis.SymbolDisplayFormat : object {
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <CSharpErrorMessageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <CSharpShortErrorMessageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <VisualBasicErrorMessageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <VisualBasicShortErrorMessageFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <FullyQualifiedFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private static SymbolDisplayFormat <MinimallyQualifiedFormat>k__BackingField;
    internal static SymbolDisplayFormat TestFormat;
    internal static SymbolDisplayFormat QualifiedNameOnlyFormat;
    internal static SymbolDisplayFormat QualifiedNameArityFormat;
    internal static SymbolDisplayFormat ShortFormat;
    internal static SymbolDisplayFormat ILVisualizationFormat;
    internal static SymbolDisplayFormat ExplicitInterfaceImplementationFormat;
    [CompilerGeneratedAttribute]
private SymbolDisplayGlobalNamespaceStyle <GlobalNamespaceStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayTypeQualificationStyle <TypeQualificationStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayGenericsOptions <GenericsOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayMemberOptions <MemberOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayParameterOptions <ParameterOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayDelegateStyle <DelegateStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayExtensionMethodStyle <ExtensionMethodStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayPropertyStyle <PropertyStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayLocalOptions <LocalOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayKindOptions <KindOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayMiscellaneousOptions <MiscellaneousOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolDisplayCompilerInternalOptions <CompilerInternalOptions>k__BackingField;
    public static SymbolDisplayFormat CSharpErrorMessageFormat { get; }
    public static SymbolDisplayFormat CSharpShortErrorMessageFormat { get; }
    public static SymbolDisplayFormat VisualBasicErrorMessageFormat { get; }
    public static SymbolDisplayFormat VisualBasicShortErrorMessageFormat { get; }
    public static SymbolDisplayFormat FullyQualifiedFormat { get; }
    public static SymbolDisplayFormat MinimallyQualifiedFormat { get; }
    public SymbolDisplayGlobalNamespaceStyle GlobalNamespaceStyle { get; }
    public SymbolDisplayTypeQualificationStyle TypeQualificationStyle { get; }
    public SymbolDisplayGenericsOptions GenericsOptions { get; }
    public SymbolDisplayMemberOptions MemberOptions { get; }
    public SymbolDisplayParameterOptions ParameterOptions { get; }
    public SymbolDisplayDelegateStyle DelegateStyle { get; }
    public SymbolDisplayExtensionMethodStyle ExtensionMethodStyle { get; }
    public SymbolDisplayPropertyStyle PropertyStyle { get; }
    public SymbolDisplayLocalOptions LocalOptions { get; }
    public SymbolDisplayKindOptions KindOptions { get; }
    public SymbolDisplayMiscellaneousOptions MiscellaneousOptions { get; }
    internal SymbolDisplayCompilerInternalOptions CompilerInternalOptions { get; }
    public SymbolDisplayFormat(SymbolDisplayGlobalNamespaceStyle globalNamespaceStyle, SymbolDisplayTypeQualificationStyle typeQualificationStyle, SymbolDisplayGenericsOptions genericsOptions, SymbolDisplayMemberOptions memberOptions, SymbolDisplayDelegateStyle delegateStyle, SymbolDisplayExtensionMethodStyle extensionMethodStyle, SymbolDisplayParameterOptions parameterOptions, SymbolDisplayPropertyStyle propertyStyle, SymbolDisplayLocalOptions localOptions, SymbolDisplayKindOptions kindOptions, SymbolDisplayMiscellaneousOptions miscellaneousOptions);
    internal SymbolDisplayFormat(SymbolDisplayCompilerInternalOptions compilerInternalOptions, SymbolDisplayGlobalNamespaceStyle globalNamespaceStyle, SymbolDisplayTypeQualificationStyle typeQualificationStyle, SymbolDisplayGenericsOptions genericsOptions, SymbolDisplayMemberOptions memberOptions, SymbolDisplayParameterOptions parameterOptions, SymbolDisplayDelegateStyle delegateStyle, SymbolDisplayExtensionMethodStyle extensionMethodStyle, SymbolDisplayPropertyStyle propertyStyle, SymbolDisplayLocalOptions localOptions, SymbolDisplayKindOptions kindOptions, SymbolDisplayMiscellaneousOptions miscellaneousOptions);
    private static SymbolDisplayFormat();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_CSharpErrorMessageFormat();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_CSharpShortErrorMessageFormat();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_VisualBasicErrorMessageFormat();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_VisualBasicShortErrorMessageFormat();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_FullyQualifiedFormat();
    [CompilerGeneratedAttribute]
public static SymbolDisplayFormat get_MinimallyQualifiedFormat();
    [CompilerGeneratedAttribute]
public SymbolDisplayGlobalNamespaceStyle get_GlobalNamespaceStyle();
    [CompilerGeneratedAttribute]
public SymbolDisplayTypeQualificationStyle get_TypeQualificationStyle();
    [CompilerGeneratedAttribute]
public SymbolDisplayGenericsOptions get_GenericsOptions();
    [CompilerGeneratedAttribute]
public SymbolDisplayMemberOptions get_MemberOptions();
    [CompilerGeneratedAttribute]
public SymbolDisplayParameterOptions get_ParameterOptions();
    [CompilerGeneratedAttribute]
public SymbolDisplayDelegateStyle get_DelegateStyle();
    [CompilerGeneratedAttribute]
public SymbolDisplayExtensionMethodStyle get_ExtensionMethodStyle();
    [CompilerGeneratedAttribute]
public SymbolDisplayPropertyStyle get_PropertyStyle();
    [CompilerGeneratedAttribute]
public SymbolDisplayLocalOptions get_LocalOptions();
    [CompilerGeneratedAttribute]
public SymbolDisplayKindOptions get_KindOptions();
    [CompilerGeneratedAttribute]
public SymbolDisplayMiscellaneousOptions get_MiscellaneousOptions();
    [CompilerGeneratedAttribute]
internal SymbolDisplayCompilerInternalOptions get_CompilerInternalOptions();
    public SymbolDisplayFormat WithMiscellaneousOptions(SymbolDisplayMiscellaneousOptions options);
    public SymbolDisplayFormat AddMiscellaneousOptions(SymbolDisplayMiscellaneousOptions options);
    public SymbolDisplayFormat RemoveMiscellaneousOptions(SymbolDisplayMiscellaneousOptions options);
    public SymbolDisplayFormat WithGenericsOptions(SymbolDisplayGenericsOptions options);
    public SymbolDisplayFormat AddGenericsOptions(SymbolDisplayGenericsOptions options);
    public SymbolDisplayFormat RemoveGenericsOptions(SymbolDisplayGenericsOptions options);
    public SymbolDisplayFormat WithMemberOptions(SymbolDisplayMemberOptions options);
    public SymbolDisplayFormat AddMemberOptions(SymbolDisplayMemberOptions options);
    public SymbolDisplayFormat RemoveMemberOptions(SymbolDisplayMemberOptions options);
    public SymbolDisplayFormat WithKindOptions(SymbolDisplayKindOptions options);
    public SymbolDisplayFormat AddKindOptions(SymbolDisplayKindOptions options);
    public SymbolDisplayFormat RemoveKindOptions(SymbolDisplayKindOptions options);
    public SymbolDisplayFormat WithParameterOptions(SymbolDisplayParameterOptions options);
    public SymbolDisplayFormat AddParameterOptions(SymbolDisplayParameterOptions options);
    public SymbolDisplayFormat RemoveParameterOptions(SymbolDisplayParameterOptions options);
    public SymbolDisplayFormat WithGlobalNamespaceStyle(SymbolDisplayGlobalNamespaceStyle style);
    public SymbolDisplayFormat WithLocalOptions(SymbolDisplayLocalOptions options);
    public SymbolDisplayFormat AddLocalOptions(SymbolDisplayLocalOptions options);
    public SymbolDisplayFormat RemoveLocalOptions(SymbolDisplayLocalOptions options);
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.SymbolDisplayGenericsOptions : Enum {
    public int value__;
    public static SymbolDisplayGenericsOptions None;
    public static SymbolDisplayGenericsOptions IncludeTypeParameters;
    public static SymbolDisplayGenericsOptions IncludeTypeConstraints;
    public static SymbolDisplayGenericsOptions IncludeVariance;
}
public enum Microsoft.CodeAnalysis.SymbolDisplayGlobalNamespaceStyle : Enum {
    public int value__;
    public static SymbolDisplayGlobalNamespaceStyle Omitted;
    public static SymbolDisplayGlobalNamespaceStyle OmittedAsContaining;
    public static SymbolDisplayGlobalNamespaceStyle Included;
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.SymbolDisplayKindOptions : Enum {
    public int value__;
    public static SymbolDisplayKindOptions None;
    public static SymbolDisplayKindOptions IncludeNamespaceKeyword;
    public static SymbolDisplayKindOptions IncludeTypeKeyword;
    public static SymbolDisplayKindOptions IncludeMemberKeyword;
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.SymbolDisplayLocalOptions : Enum {
    public int value__;
    public static SymbolDisplayLocalOptions None;
    public static SymbolDisplayLocalOptions IncludeType;
    public static SymbolDisplayLocalOptions IncludeConstantValue;
    public static SymbolDisplayLocalOptions IncludeRef;
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.SymbolDisplayMemberOptions : Enum {
    public int value__;
    public static SymbolDisplayMemberOptions None;
    public static SymbolDisplayMemberOptions IncludeType;
    public static SymbolDisplayMemberOptions IncludeModifiers;
    public static SymbolDisplayMemberOptions IncludeAccessibility;
    public static SymbolDisplayMemberOptions IncludeExplicitInterface;
    public static SymbolDisplayMemberOptions IncludeParameters;
    public static SymbolDisplayMemberOptions IncludeContainingType;
    public static SymbolDisplayMemberOptions IncludeConstantValue;
    public static SymbolDisplayMemberOptions IncludeRef;
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.SymbolDisplayMiscellaneousOptions : Enum {
    public int value__;
    public static SymbolDisplayMiscellaneousOptions None;
    public static SymbolDisplayMiscellaneousOptions UseSpecialTypes;
    public static SymbolDisplayMiscellaneousOptions EscapeKeywordIdentifiers;
    public static SymbolDisplayMiscellaneousOptions UseAsterisksInMultiDimensionalArrays;
    public static SymbolDisplayMiscellaneousOptions UseErrorTypeSymbolName;
    public static SymbolDisplayMiscellaneousOptions RemoveAttributeSuffix;
    public static SymbolDisplayMiscellaneousOptions ExpandNullable;
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.SymbolDisplayParameterOptions : Enum {
    public int value__;
    public static SymbolDisplayParameterOptions None;
    public static SymbolDisplayParameterOptions IncludeExtensionThis;
    public static SymbolDisplayParameterOptions IncludeParamsRefOut;
    public static SymbolDisplayParameterOptions IncludeType;
    public static SymbolDisplayParameterOptions IncludeName;
    public static SymbolDisplayParameterOptions IncludeDefaultValue;
    public static SymbolDisplayParameterOptions IncludeOptionalBrackets;
}
public class Microsoft.CodeAnalysis.SymbolDisplayPart : ValueType {
    private SymbolDisplayPartKind _kind;
    private string _text;
    private ISymbol _symbol;
    public SymbolDisplayPartKind Kind { get; }
    public ISymbol Symbol { get; }
    public SymbolDisplayPart(SymbolDisplayPartKind kind, ISymbol symbol, string text);
    public SymbolDisplayPartKind get_Kind();
    public ISymbol get_Symbol();
    public virtual string ToString();
}
public enum Microsoft.CodeAnalysis.SymbolDisplayPartKind : Enum {
    public int value__;
    public static SymbolDisplayPartKind AliasName;
    public static SymbolDisplayPartKind AssemblyName;
    public static SymbolDisplayPartKind ClassName;
    public static SymbolDisplayPartKind DelegateName;
    public static SymbolDisplayPartKind EnumName;
    public static SymbolDisplayPartKind ErrorTypeName;
    public static SymbolDisplayPartKind EventName;
    public static SymbolDisplayPartKind FieldName;
    public static SymbolDisplayPartKind InterfaceName;
    public static SymbolDisplayPartKind Keyword;
    public static SymbolDisplayPartKind LabelName;
    public static SymbolDisplayPartKind LineBreak;
    public static SymbolDisplayPartKind NumericLiteral;
    public static SymbolDisplayPartKind StringLiteral;
    public static SymbolDisplayPartKind LocalName;
    public static SymbolDisplayPartKind MethodName;
    public static SymbolDisplayPartKind ModuleName;
    public static SymbolDisplayPartKind NamespaceName;
    public static SymbolDisplayPartKind Operator;
    public static SymbolDisplayPartKind ParameterName;
    public static SymbolDisplayPartKind PropertyName;
    public static SymbolDisplayPartKind Punctuation;
    public static SymbolDisplayPartKind Space;
    public static SymbolDisplayPartKind StructName;
    public static SymbolDisplayPartKind AnonymousTypeIndicator;
    public static SymbolDisplayPartKind Text;
    public static SymbolDisplayPartKind TypeParameterName;
    public static SymbolDisplayPartKind RangeVariableName;
}
public enum Microsoft.CodeAnalysis.SymbolDisplayPropertyStyle : Enum {
    public int value__;
    public static SymbolDisplayPropertyStyle NameOnly;
    public static SymbolDisplayPropertyStyle ShowReadWriteDescriptor;
}
public enum Microsoft.CodeAnalysis.SymbolDisplayTypeQualificationStyle : Enum {
    public int value__;
    public static SymbolDisplayTypeQualificationStyle NameOnly;
    public static SymbolDisplayTypeQualificationStyle NameAndContainingTypes;
    public static SymbolDisplayTypeQualificationStyle NameAndContainingTypesAndNamespaces;
}
internal abstract class Microsoft.CodeAnalysis.SymbolFactory`2 : object {
    internal abstract virtual TypeSymbol GetUnsupportedMetadataTypeSymbol(ModuleSymbol moduleSymbol, BadImageFormatException exception);
    internal abstract virtual TypeSymbol MakeUnboundIfGeneric(ModuleSymbol moduleSymbol, TypeSymbol type);
    internal abstract virtual TypeSymbol GetSZArrayTypeSymbol(ModuleSymbol moduleSymbol, TypeSymbol elementType, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers);
    internal abstract virtual TypeSymbol GetMDArrayTypeSymbol(ModuleSymbol moduleSymbol, int rank, TypeSymbol elementType, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers, ImmutableArray`1<int> sizes, ImmutableArray`1<int> lowerBounds);
    internal abstract virtual TypeSymbol SubstituteTypeParameters(ModuleSymbol moduleSymbol, TypeSymbol generic, ImmutableArray`1<KeyValuePair`2<TypeSymbol, ImmutableArray`1<ModifierInfo`1<TypeSymbol>>>> arguments, ImmutableArray`1<bool> refersToNoPiaLocalType);
    internal abstract virtual TypeSymbol MakePointerTypeSymbol(ModuleSymbol moduleSymbol, TypeSymbol type, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers);
    internal abstract virtual TypeSymbol GetSpecialType(ModuleSymbol moduleSymbol, SpecialType specialType);
    internal abstract virtual TypeSymbol GetSystemTypeSymbol(ModuleSymbol moduleSymbol);
    internal abstract virtual TypeSymbol GetEnumUnderlyingType(ModuleSymbol moduleSymbol, TypeSymbol type);
    internal abstract virtual bool IsAcceptedVolatileModifierType(ModuleSymbol moduleSymbol, TypeSymbol type);
    internal abstract virtual bool IsAcceptedInAttributeModifierType(TypeSymbol type);
    internal abstract virtual bool IsAcceptedUnmanagedTypeModifierType(TypeSymbol type);
    internal abstract virtual PrimitiveTypeCode GetPrimitiveTypeCode(ModuleSymbol moduleSymbol, TypeSymbol type);
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.SymbolFilter : Enum {
    public int value__;
    public static SymbolFilter None;
    public static SymbolFilter Namespace;
    public static SymbolFilter Type;
    public static SymbolFilter Member;
    public static SymbolFilter TypeAndMember;
    public static SymbolFilter All;
}
public class Microsoft.CodeAnalysis.SymbolInfo : ValueType {
    internal static SymbolInfo None;
    private ImmutableArray`1<ISymbol> _candidateSymbols;
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private CandidateReason <CandidateReason>k__BackingField;
    public ISymbol Symbol { get; }
    public ImmutableArray`1<ISymbol> CandidateSymbols { get; }
    public CandidateReason CandidateReason { get; }
    internal bool IsEmpty { get; }
    internal SymbolInfo(ISymbol symbol);
    internal SymbolInfo(ISymbol symbol, CandidateReason reason);
    internal SymbolInfo(ImmutableArray`1<ISymbol> candidateSymbols, CandidateReason candidateReason);
    internal SymbolInfo(ISymbol symbol, ImmutableArray`1<ISymbol> candidateSymbols, CandidateReason candidateReason);
    private static SymbolInfo();
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    public ImmutableArray`1<ISymbol> get_CandidateSymbols();
    internal ImmutableArray`1<ISymbol> GetAllSymbols();
    [CompilerGeneratedAttribute]
public CandidateReason get_CandidateReason();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SymbolInfo other);
    public virtual int GetHashCode();
    internal bool get_IsEmpty();
}
public enum Microsoft.CodeAnalysis.SymbolKind : Enum {
    public int value__;
    public static SymbolKind Alias;
    public static SymbolKind ArrayType;
    public static SymbolKind Assembly;
    public static SymbolKind DynamicType;
    public static SymbolKind ErrorType;
    public static SymbolKind Event;
    public static SymbolKind Field;
    public static SymbolKind Label;
    public static SymbolKind Local;
    public static SymbolKind Method;
    public static SymbolKind NetModule;
    public static SymbolKind NamedType;
    public static SymbolKind Namespace;
    public static SymbolKind Parameter;
    public static SymbolKind PointerType;
    public static SymbolKind Property;
    public static SymbolKind RangeVariable;
    public static SymbolKind TypeParameter;
    public static SymbolKind Preprocessing;
    public static SymbolKind Discard;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SymbolKindExtensions : object {
    [ExtensionAttribute]
public static int ToSortOrder(SymbolKind kind);
}
internal abstract class Microsoft.CodeAnalysis.Symbols.CommonAnonymousTypeManager : object {
    private ThreeState _templatesSealed;
    internal bool AreTemplatesSealed { get; }
    internal bool get_AreTemplatesSealed();
    protected void SealTemplates();
}
internal interface Microsoft.CodeAnalysis.Symbols.IMethodSymbolInternal {
    public bool IsIterator { get; }
    public abstract virtual bool get_IsIterator();
    public abstract virtual int CalculateLocalSyntaxOffset(int declaratorPosition, SyntaxTree declaratorTree);
}
public abstract class Microsoft.CodeAnalysis.SymbolVisitor : object {
    public virtual void Visit(ISymbol symbol);
    public virtual void DefaultVisit(ISymbol symbol);
    public virtual void VisitAlias(IAliasSymbol symbol);
    public virtual void VisitArrayType(IArrayTypeSymbol symbol);
    public virtual void VisitAssembly(IAssemblySymbol symbol);
    public virtual void VisitDiscard(IDiscardSymbol symbol);
    public virtual void VisitDynamicType(IDynamicTypeSymbol symbol);
    public virtual void VisitEvent(IEventSymbol symbol);
    public virtual void VisitField(IFieldSymbol symbol);
    public virtual void VisitLabel(ILabelSymbol symbol);
    public virtual void VisitLocal(ILocalSymbol symbol);
    public virtual void VisitMethod(IMethodSymbol symbol);
    public virtual void VisitModule(IModuleSymbol symbol);
    public virtual void VisitNamedType(INamedTypeSymbol symbol);
    public virtual void VisitNamespace(INamespaceSymbol symbol);
    public virtual void VisitParameter(IParameterSymbol symbol);
    public virtual void VisitPointerType(IPointerTypeSymbol symbol);
    public virtual void VisitProperty(IPropertySymbol symbol);
    public virtual void VisitRangeVariable(IRangeVariableSymbol symbol);
    public virtual void VisitTypeParameter(ITypeParameterSymbol symbol);
}
public abstract class Microsoft.CodeAnalysis.SymbolVisitor`1 : object {
    public virtual TResult Visit(ISymbol symbol);
    public virtual TResult DefaultVisit(ISymbol symbol);
    public virtual TResult VisitAlias(IAliasSymbol symbol);
    public virtual TResult VisitArrayType(IArrayTypeSymbol symbol);
    public virtual TResult VisitAssembly(IAssemblySymbol symbol);
    public virtual TResult VisitDiscard(IDiscardSymbol symbol);
    public virtual TResult VisitDynamicType(IDynamicTypeSymbol symbol);
    public virtual TResult VisitEvent(IEventSymbol symbol);
    public virtual TResult VisitField(IFieldSymbol symbol);
    public virtual TResult VisitLabel(ILabelSymbol symbol);
    public virtual TResult VisitLocal(ILocalSymbol symbol);
    public virtual TResult VisitMethod(IMethodSymbol symbol);
    public virtual TResult VisitModule(IModuleSymbol symbol);
    public virtual TResult VisitNamedType(INamedTypeSymbol symbol);
    public virtual TResult VisitNamespace(INamespaceSymbol symbol);
    public virtual TResult VisitParameter(IParameterSymbol symbol);
    public virtual TResult VisitPointerType(IPointerTypeSymbol symbol);
    public virtual TResult VisitProperty(IPropertySymbol symbol);
    public virtual TResult VisitRangeVariable(IRangeVariableSymbol symbol);
    public virtual TResult VisitTypeParameter(ITypeParameterSymbol symbol);
}
internal abstract class Microsoft.CodeAnalysis.Syntax.AbstractWarningStateMap : object {
    private WarningStateMapEntry[] _warningStateMapEntries;
    protected AbstractWarningStateMap(SyntaxTree syntaxTree);
    protected abstract virtual WarningStateMapEntry[] CreateWarningStateMapEntries(SyntaxTree syntaxTree);
    public ReportDiagnostic GetWarningState(string id, int position);
    private WarningStateMapEntry GetEntryAtOrBeforePosition(int position);
}
internal static class Microsoft.CodeAnalysis.Syntax.CommonSyntaxNodeRemover : object {
    public static void GetSeparatorInfo(SyntaxNodeOrTokenList nodesAndSeparators, int nodeIndex, int endOfLineKind, Boolean& nextTokenIsSeparator, Boolean& nextSeparatorBelongsToNode);
    private static bool ContainsEndOfLine(SyntaxTriviaList triviaList, int endOfLineKind);
}
internal class Microsoft.CodeAnalysis.Syntax.InternalSyntax.ChildSyntaxList : ValueType {
    private GreenNode _node;
    private int _count;
    public int Count { get; }
    private GreenNode[] Nodes { get; }
    internal ChildSyntaxList(GreenNode node);
    public int get_Count();
    private int CountNodes();
    private GreenNode[] get_Nodes();
    public Enumerator GetEnumerator();
    public Reversed Reverse();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Syntax.InternalSyntax.GreenNodeExtensions : object {
    [ExtensionAttribute]
internal static SyntaxList`1<T> ToGreenList(SyntaxNode node);
    [ExtensionAttribute]
internal static SeparatedSyntaxList`1<T> ToGreenSeparatedList(SyntaxNode node);
    [ExtensionAttribute]
internal static SyntaxList`1<T> ToGreenList(GreenNode node);
}
internal class Microsoft.CodeAnalysis.Syntax.InternalSyntax.GreenStats : object {
    internal static void NoteGreen(GreenNode node);
    [ConditionalAttribute("DEBUG")]
internal static void ItemAdded();
    [ConditionalAttribute("DEBUG")]
internal static void ItemCacheable();
    [ConditionalAttribute("DEBUG")]
internal static void CacheHit();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxList`1 : ValueType {
    private SyntaxList`1<GreenNode> _list;
    internal GreenNode Node { get; }
    public int Count { get; }
    public int SeparatorCount { get; }
    public TNode Item { get; }
    internal SeparatedSyntaxList`1(SyntaxList`1<GreenNode> list);
    [ConditionalAttribute("DEBUG")]
private static void Validate(SyntaxList`1<GreenNode> list);
    internal GreenNode get_Node();
    public int get_Count();
    public int get_SeparatorCount();
    public TNode get_Item(int index);
    public GreenNode GetSeparator(int index);
    public SyntaxList`1<GreenNode> GetWithSeparators();
    public static bool op_Equality(SeparatedSyntaxList`1& left, SeparatedSyntaxList`1& right);
    public static bool op_Inequality(SeparatedSyntaxList`1& left, SeparatedSyntaxList`1& right);
    public sealed virtual bool Equals(SeparatedSyntaxList`1<TNode> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static SeparatedSyntaxList`1<GreenNode> op_Implicit(SeparatedSyntaxList`1<TNode> list);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Syntax.InternalSyntax.SeparatedSyntaxListBuilder`1 : ValueType {
    private SyntaxListBuilder _builder;
    public bool IsNull { get; }
    public int Count { get; }
    public GreenNode Item { get; public set; }
    internal SyntaxListBuilder UnderlyingBuilder { get; }
    public SeparatedSyntaxListBuilder`1(int size);
    internal SeparatedSyntaxListBuilder`1(SyntaxListBuilder builder);
    public static SeparatedSyntaxListBuilder`1<TNode> Create();
    public bool get_IsNull();
    public int get_Count();
    public GreenNode get_Item(int index);
    public void set_Item(int index, GreenNode value);
    public void Clear();
    public void RemoveLast();
    public SeparatedSyntaxListBuilder`1<TNode> Add(TNode node);
    public void AddSeparator(GreenNode separatorToken);
    public void AddRange(TNode[] items, int offset, int length);
    public void AddRange(SeparatedSyntaxList`1& nodes);
    public void AddRange(SeparatedSyntaxList`1& nodes, int count);
    public bool Any(int kind);
    public SeparatedSyntaxList`1<TNode> ToList();
    internal SyntaxListBuilder get_UnderlyingBuilder();
    public static SeparatedSyntaxList`1<TNode> op_Implicit(SeparatedSyntaxListBuilder`1& builder);
    public static SyntaxListBuilder op_Implicit(SeparatedSyntaxListBuilder`1& builder);
}
internal class Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxDiagnosticInfoList : ValueType {
    private GreenNode _node;
    internal SyntaxDiagnosticInfoList(GreenNode node);
    public Enumerator GetEnumerator();
    internal bool Any(Func`2<DiagnosticInfo, bool> predicate);
}
internal abstract class Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList : GreenNode {
    public string Language { get; }
    public string KindText { get; }
    internal SyntaxList(DiagnosticInfo[] diagnostics, SyntaxAnnotation[] annotations);
    internal SyntaxList(ObjectReader reader);
    internal static GreenNode List(GreenNode child);
    internal static WithTwoChildren List(GreenNode child0, GreenNode child1);
    internal static WithThreeChildren List(GreenNode child0, GreenNode child1, GreenNode child2);
    internal static GreenNode List(GreenNode[] nodes);
    internal static GreenNode List(GreenNode[] nodes, int count);
    internal static SyntaxList List(ArrayElement`1[] children);
    internal abstract virtual void CopyTo(ArrayElement`1[] array, int offset);
    internal static GreenNode Concat(GreenNode left, GreenNode right);
    public sealed virtual string get_Language();
    public sealed virtual string get_KindText();
    public sealed virtual SyntaxNode GetStructure(SyntaxTrivia parentTrivia);
    public sealed virtual SyntaxToken CreateSeparator(SyntaxNode element);
    public sealed virtual bool IsTriviaWithEndOfLine();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxList`1 : ValueType {
    private GreenNode _node;
    internal GreenNode Node { get; }
    public int Count { get; }
    public TNode Item { get; }
    internal TNode[] Nodes { get; }
    public TNode Last { get; }
    internal SyntaxList`1(GreenNode node);
    internal GreenNode get_Node();
    public int get_Count();
    public TNode get_Item(int index);
    internal GreenNode ItemUntyped(int index);
    public bool Any();
    public bool Any(int kind);
    internal TNode[] get_Nodes();
    public TNode get_Last();
    public Enumerator<TNode> GetEnumerator();
    internal void CopyTo(int offset, ArrayElement`1[] array, int arrayOffset, int count);
    public static bool op_Equality(SyntaxList`1<TNode> left, SyntaxList`1<TNode> right);
    public static bool op_Inequality(SyntaxList`1<TNode> left, SyntaxList`1<TNode> right);
    public sealed virtual bool Equals(SyntaxList`1<TNode> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public SeparatedSyntaxList`1<TOther> AsSeparatedList();
    public static SyntaxList`1<TNode> op_Implicit(TNode node);
    public static SyntaxList`1<TNode> op_Implicit(SyntaxList`1<GreenNode> nodes);
    public static SyntaxList`1<GreenNode> op_Implicit(SyntaxList`1<TNode> nodes);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder : object {
    private ArrayElement`1[] _nodes;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    public GreenNode Item { get; public set; }
    public SyntaxListBuilder(int size);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public static SyntaxListBuilder Create();
    public void Clear();
    public GreenNode get_Item(int index);
    public void set_Item(int index, GreenNode value);
    public void Add(GreenNode item);
    public void AddRange(GreenNode[] items);
    public void AddRange(GreenNode[] items, int offset, int length);
    [ConditionalAttribute("DEBUG")]
private void Validate(int start, int end);
    public void AddRange(SyntaxList`1<GreenNode> list);
    public void AddRange(SyntaxList`1<GreenNode> list, int offset, int length);
    public void AddRange(SyntaxList`1<TNode> list);
    public void AddRange(SyntaxList`1<TNode> list, int offset, int length);
    public void RemoveLast();
    private void EnsureAdditionalCapacity(int additionalCount);
    public bool Any(int kind);
    public GreenNode[] ToArray();
    internal GreenNode ToListNode();
    public SyntaxList`1<GreenNode> ToList();
    public SyntaxList`1<TNode> ToList();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilder`1 : ValueType {
    private SyntaxListBuilder _builder;
    public bool IsNull { get; }
    public int Count { get; }
    public TNode Item { get; public set; }
    public SyntaxListBuilder`1(int size);
    internal SyntaxListBuilder`1(SyntaxListBuilder builder);
    public static SyntaxListBuilder`1<TNode> Create();
    public bool get_IsNull();
    public int get_Count();
    public TNode get_Item(int index);
    public void set_Item(int index, TNode value);
    public void Clear();
    public SyntaxListBuilder`1<TNode> Add(TNode node);
    public void AddRange(TNode[] items, int offset, int length);
    public void AddRange(SyntaxList`1<TNode> nodes);
    public void AddRange(SyntaxList`1<TNode> nodes, int offset, int length);
    public bool Any(int kind);
    public SyntaxList`1<TNode> ToList();
    public GreenNode ToListNode();
    public static SyntaxListBuilder op_Implicit(SyntaxListBuilder`1<TNode> builder);
    public static SyntaxList`1<TNode> op_Implicit(SyntaxListBuilder`1<TNode> builder);
    public SyntaxList`1<TDerived> ToList();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListBuilderExtensions : object {
    [ExtensionAttribute]
public static SyntaxList`1<GreenNode> ToList(SyntaxListBuilder builder);
    [ExtensionAttribute]
public static SyntaxList`1<TNode> ToList(SyntaxListBuilder builder);
}
internal class Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxListPool : object {
    private ArrayElement`1[] _freeList;
    private int _freeIndex;
    internal SyntaxListBuilder Allocate();
    internal SyntaxListBuilder`1<TNode> Allocate();
    internal SeparatedSyntaxListBuilder`1<TNode> AllocateSeparated();
    internal void Free(SeparatedSyntaxListBuilder`1& item);
    internal void Free(SyntaxListBuilder item);
    private void Grow();
    public SyntaxList`1<TNode> ToListAndFree(SyntaxListBuilder`1<TNode> item);
}
internal static class Microsoft.CodeAnalysis.Syntax.InternalSyntax.SyntaxNodeCache : object {
    private static int CacheSizeBits;
    private static int CacheSize;
    private static int CacheMask;
    private static Entry[] s_cache;
    private static SyntaxNodeCache();
    internal static void AddNode(GreenNode node, int hash);
    private static bool CanBeCached(GreenNode child1);
    private static bool CanBeCached(GreenNode child1, GreenNode child2);
    private static bool CanBeCached(GreenNode child1, GreenNode child2, GreenNode child3);
    private static bool ChildInCache(GreenNode child);
    private static bool AllChildrenInCache(GreenNode node);
    internal static GreenNode TryGetNode(int kind, GreenNode child1, Int32& hash);
    internal static GreenNode TryGetNode(int kind, GreenNode child1, NodeFlags flags, Int32& hash);
    internal static GreenNode TryGetNode(int kind, GreenNode child1, GreenNode child2, Int32& hash);
    internal static GreenNode TryGetNode(int kind, GreenNode child1, GreenNode child2, NodeFlags flags, Int32& hash);
    internal static GreenNode TryGetNode(int kind, GreenNode child1, GreenNode child2, GreenNode child3, Int32& hash);
    internal static GreenNode TryGetNode(int kind, GreenNode child1, GreenNode child2, GreenNode child3, NodeFlags flags, Int32& hash);
    public static NodeFlags GetDefaultNodeFlags();
    private static int GetCacheHash(int kind, NodeFlags flags, GreenNode child1);
    private static int GetCacheHash(int kind, NodeFlags flags, GreenNode child1, GreenNode child2);
    private static int GetCacheHash(int kind, NodeFlags flags, GreenNode child1, GreenNode child2, GreenNode child3);
}
internal class Microsoft.CodeAnalysis.Syntax.SeparatedSyntaxListBuilder`1 : ValueType {
    private SyntaxListBuilder _builder;
    private bool _expectedSeparator;
    public bool IsNull { get; }
    public int Count { get; }
    public SeparatedSyntaxListBuilder`1(int size);
    internal SeparatedSyntaxListBuilder`1(SyntaxListBuilder builder);
    public static SeparatedSyntaxListBuilder`1<TNode> Create();
    public bool get_IsNull();
    public int get_Count();
    public void Clear();
    private void CheckExpectedElement();
    private void CheckExpectedSeparator();
    public SeparatedSyntaxListBuilder`1<TNode> Add(TNode node);
    public SeparatedSyntaxListBuilder`1<TNode> AddSeparator(SyntaxToken& separatorToken);
    public SeparatedSyntaxListBuilder`1<TNode> AddRange(SeparatedSyntaxList`1& nodes);
    public SeparatedSyntaxListBuilder`1<TNode> AddRange(SeparatedSyntaxList`1& nodes, int count);
    public SeparatedSyntaxList`1<TNode> ToList();
    public SeparatedSyntaxList`1<TDerived> ToList();
    public static SyntaxListBuilder op_Implicit(SeparatedSyntaxListBuilder`1& builder);
    public static SeparatedSyntaxList`1<TNode> op_Implicit(SeparatedSyntaxListBuilder`1& builder);
}
internal abstract class Microsoft.CodeAnalysis.Syntax.SyntaxList : SyntaxNode {
    public string Language { get; }
    protected SyntaxTree SyntaxTreeCore { get; }
    internal SyntaxList(SyntaxList green, SyntaxNode parent, int position);
    public virtual string get_Language();
    protected virtual SyntaxTree get_SyntaxTreeCore();
    protected internal virtual SyntaxNode ReplaceCore(IEnumerable`1<TNode> nodes, Func`3<TNode, TNode, SyntaxNode> computeReplacementNode, IEnumerable`1<SyntaxToken> tokens, Func`3<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken, IEnumerable`1<SyntaxTrivia> trivia, Func`3<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia);
    protected internal virtual SyntaxNode ReplaceNodeInListCore(SyntaxNode originalNode, IEnumerable`1<SyntaxNode> replacementNodes);
    protected internal virtual SyntaxNode InsertNodesInListCore(SyntaxNode nodeInList, IEnumerable`1<SyntaxNode> nodesToInsert, bool insertBefore);
    protected internal virtual SyntaxNode ReplaceTokenInListCore(SyntaxToken originalToken, IEnumerable`1<SyntaxToken> newTokens);
    protected internal virtual SyntaxNode InsertTokensInListCore(SyntaxToken originalToken, IEnumerable`1<SyntaxToken> newTokens, bool insertBefore);
    protected internal virtual SyntaxNode ReplaceTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable`1<SyntaxTrivia> newTrivia);
    protected internal virtual SyntaxNode InsertTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable`1<SyntaxTrivia> newTrivia, bool insertBefore);
    protected internal virtual SyntaxNode RemoveNodesCore(IEnumerable`1<SyntaxNode> nodes, SyntaxRemoveOptions options);
    protected internal virtual SyntaxNode NormalizeWhitespaceCore(string indentation, string eol, bool elasticTrivia);
    protected virtual bool IsEquivalentToCore(SyntaxNode node, bool topLevel);
}
internal class Microsoft.CodeAnalysis.Syntax.SyntaxListBuilder : object {
    private ArrayElement`1[] _nodes;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; private set; }
    public SyntaxListBuilder(int size);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public void Clear();
    public void Add(SyntaxNode item);
    internal void AddInternal(GreenNode item);
    public void AddRange(SyntaxNode[] items);
    public void AddRange(SyntaxNode[] items, int offset, int length);
    [ConditionalAttribute("DEBUG")]
private void Validate(int start, int end);
    public void AddRange(SyntaxList`1<SyntaxNode> list);
    public void AddRange(SyntaxList`1<SyntaxNode> list, int offset, int count);
    public void AddRange(SyntaxList`1<TNode> list);
    public void AddRange(SyntaxList`1<TNode> list, int offset, int count);
    public void AddRange(SyntaxNodeOrTokenList list);
    public void AddRange(SyntaxNodeOrTokenList list, int offset, int count);
    public void AddRange(SyntaxTokenList list);
    public void AddRange(SyntaxTokenList list, int offset, int length);
    private void Grow(int size);
    public bool Any(int kind);
    internal GreenNode ToListNode();
    public static SyntaxList`1<SyntaxNode> op_Implicit(SyntaxListBuilder builder);
    internal void RemoveLast();
}
internal class Microsoft.CodeAnalysis.Syntax.SyntaxListBuilder`1 : ValueType {
    private SyntaxListBuilder _builder;
    public bool IsNull { get; }
    public int Count { get; }
    public SyntaxListBuilder`1(int size);
    internal SyntaxListBuilder`1(SyntaxListBuilder builder);
    public static SyntaxListBuilder`1<TNode> Create();
    public bool get_IsNull();
    public int get_Count();
    public void Clear();
    public SyntaxListBuilder`1<TNode> Add(TNode node);
    public void AddRange(TNode[] items, int offset, int length);
    public void AddRange(SyntaxList`1<TNode> nodes);
    public void AddRange(SyntaxList`1<TNode> nodes, int offset, int length);
    public bool Any(int kind);
    public SyntaxList`1<TNode> ToList();
    public static SyntaxListBuilder op_Implicit(SyntaxListBuilder`1<TNode> builder);
    public static SyntaxList`1<TNode> op_Implicit(SyntaxListBuilder`1<TNode> builder);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Syntax.SyntaxListBuilderExtensions : object {
    [ExtensionAttribute]
public static SyntaxTokenList ToTokenList(SyntaxListBuilder builder);
    [ExtensionAttribute]
public static SyntaxList`1<SyntaxNode> ToList(SyntaxListBuilder builder);
    [ExtensionAttribute]
public static SyntaxList`1<TNode> ToList(SyntaxListBuilder builder);
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<TNode> ToSeparatedList(SyntaxListBuilder builder);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Syntax.SyntaxNodeOrTokenListBuilder : object {
    private GreenNode[] _nodes;
    private int _count;
    public int Count { get; }
    public SyntaxNodeOrToken Item { get; public set; }
    public SyntaxNodeOrTokenListBuilder(int size);
    public static SyntaxNodeOrTokenListBuilder Create();
    public int get_Count();
    public void Clear();
    public SyntaxNodeOrToken get_Item(int index);
    public void set_Item(int index, SyntaxNodeOrToken value);
    internal void Add(GreenNode item);
    public void Add(SyntaxNode item);
    public void Add(SyntaxToken& item);
    public void Add(SyntaxNodeOrToken& item);
    public void Add(SyntaxNodeOrTokenList list);
    public void Add(SyntaxNodeOrTokenList list, int offset, int length);
    public void Add(IEnumerable`1<SyntaxNodeOrToken> nodeOrTokens);
    internal void RemoveLast();
    private void Grow(int size);
    public SyntaxNodeOrTokenList ToList();
}
internal class Microsoft.CodeAnalysis.Syntax.SyntaxTokenListBuilder : object {
    private GreenNode[] _nodes;
    private int _count;
    public int Count { get; }
    public SyntaxTokenListBuilder(int size);
    public static SyntaxTokenListBuilder Create();
    public int get_Count();
    public void Add(SyntaxToken item);
    internal void Add(GreenNode item);
    public void Add(SyntaxTokenList list);
    public void Add(SyntaxTokenList list, int offset, int length);
    public void Add(SyntaxToken[] list);
    public void Add(SyntaxToken[] list, int offset, int length);
    private void CheckSpace(int delta);
    private void Grow(int newSize);
    public SyntaxTokenList ToList();
    public static SyntaxTokenList op_Implicit(SyntaxTokenListBuilder builder);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Syntax.SyntaxTriviaListBuilder : object {
    private SyntaxTrivia[] _nodes;
    private int _count;
    public int Count { get; }
    public SyntaxTrivia Item { get; }
    public SyntaxTriviaListBuilder(int size);
    public static SyntaxTriviaListBuilder Create();
    public static SyntaxTriviaList Create(IEnumerable`1<SyntaxTrivia> trivia);
    public int get_Count();
    public void Clear();
    public SyntaxTrivia get_Item(int index);
    public void AddRange(IEnumerable`1<SyntaxTrivia> items);
    public SyntaxTriviaListBuilder Add(SyntaxTrivia item);
    public void Add(SyntaxTrivia[] items);
    public void Add(SyntaxTrivia[] items, int offset, int length);
    public void Add(SyntaxTriviaList& list);
    public void Add(SyntaxTriviaList& list, int offset, int length);
    private void Grow(int size);
    public static SyntaxTriviaList op_Implicit(SyntaxTriviaListBuilder builder);
    public SyntaxTriviaList ToList();
}
internal abstract class Microsoft.CodeAnalysis.Syntax.TranslationSyntaxReference : SyntaxReference {
    private SyntaxReference _reference;
    public TextSpan Span { get; }
    public SyntaxTree SyntaxTree { get; }
    protected TranslationSyntaxReference(SyntaxReference reference);
    public sealed virtual TextSpan get_Span();
    public sealed virtual SyntaxTree get_SyntaxTree();
    public sealed virtual SyntaxNode GetSyntax(CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode Translate(SyntaxReference reference, CancellationToken cancellationToken);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.SyntaxAnnotation : object {
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <ElasticAnnotation>k__BackingField;
    private long _id;
    private static long s_nextId;
    [CompilerGeneratedAttribute]
private string <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Data>k__BackingField;
    public static SyntaxAnnotation ElasticAnnotation { get; }
    public string Kind { get; }
    public string Data { get; }
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    private static SyntaxAnnotation();
    public SyntaxAnnotation(string kind);
    public SyntaxAnnotation(string kind, string data);
    private SyntaxAnnotation(ObjectReader reader);
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_ElasticAnnotation();
    [CompilerGeneratedAttribute]
public string get_Kind();
    [CompilerGeneratedAttribute]
public string get_Data();
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    private string GetDebuggerDisplay();
    public sealed virtual bool Equals(SyntaxAnnotation other);
    public static bool op_Equality(SyntaxAnnotation left, SyntaxAnnotation right);
    public static bool op_Inequality(SyntaxAnnotation left, SyntaxAnnotation right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.SyntaxDiffer : object {
    private static int InitialStackSize;
    private static int MaxSearchLength;
    private Stack`1<SyntaxNodeOrToken> _oldNodes;
    private Stack`1<SyntaxNodeOrToken> _newNodes;
    private List`1<ChangeRecord> _changes;
    private TextSpan _oldSpan;
    private bool _computeNewText;
    private HashSet`1<GreenNode> _nodeSimilaritySet;
    private HashSet`1<string> _tokenTextSimilaritySet;
    private SyntaxDiffer(SyntaxNode oldNode, SyntaxNode newNode, bool computeNewText);
    internal static IList`1<TextChange> GetTextChanges(SyntaxTree before, SyntaxTree after);
    internal static IList`1<TextChange> GetTextChanges(SyntaxNode oldNode, SyntaxNode newNode);
    private IList`1<TextChange> ComputeTextChangesFromOld();
    internal static IList`1<TextSpan> GetPossiblyDifferentTextSpans(SyntaxTree before, SyntaxTree after);
    internal static IList`1<TextSpan> GetPossiblyDifferentTextSpans(SyntaxNode oldNode, SyntaxNode newNode);
    private IList`1<TextSpan> ComputeSpansInNew();
    private void ComputeChangeRecords();
    private DiffAction GetNextAction();
    private static void ReplaceFirstWithChildren(Stack`1<SyntaxNodeOrToken> stack);
    private void FindBestMatch(Stack`1<SyntaxNodeOrToken> stack, SyntaxNodeOrToken& node, Int32& index, Int32& similarity, int startIndex);
    private int GetSimilarity(SyntaxNodeOrToken& node1, SyntaxNodeOrToken& node2);
    private static bool AreIdentical(SyntaxNodeOrToken& node1, SyntaxNodeOrToken& node2);
    private static bool AreSimilar(SyntaxNodeOrToken& node1, SyntaxNodeOrToken& node2);
    private void RecordDeleteOld(int oldNodeCount);
    private void RecordReplaceOldWithNew(int oldNodeCount, int newNodeCount);
    private void RecordInsertNew(int newNodeCount);
    private void RecordChange(ChangeRecord change);
    private void RecordChange(TextChangeRange textChangeRange, SyntaxNodeOrToken& removedNode, SyntaxNodeOrToken insertedNode);
    private static TextSpan GetSpan(Stack`1<SyntaxNodeOrToken> stack, int first, int length);
    private static TextSpan GetSpan(Queue`1<SyntaxNodeOrToken> queue, int first, int length);
    private static Queue`1<SyntaxNodeOrToken> Combine(Queue`1<SyntaxNodeOrToken> first, Queue`1<SyntaxNodeOrToken> next);
    private static Queue`1<SyntaxNodeOrToken> CopyFirst(Stack`1<SyntaxNodeOrToken> stack, int n);
    private static SyntaxNodeOrToken[] ToArray(Stack`1<SyntaxNodeOrToken> stack, int n);
    private static void RemoveFirst(Stack`1<SyntaxNodeOrToken> stack, int count);
    private List`1<ChangeRangeWithText> ReduceChanges(List`1<ChangeRecord> changeRecords);
    private static void GetCommonEdgeLengths(StringBuilder oldText, StringBuilder newText, Int32& commonLeadingCount, Int32& commonTrailingCount);
    private static string GetText(Queue`1<SyntaxNodeOrToken> queue);
    private static void CopyText(Queue`1<SyntaxNodeOrToken> queue, StringBuilder builder);
    [CompilerGeneratedAttribute]
internal static Queue`1<SyntaxNodeOrToken> <RecordChange>g__CreateQueue|30_0(SyntaxNodeOrToken nodeOrToken);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.SyntaxList`1 : ValueType {
    private SyntaxNode _node;
    internal SyntaxNode Node { get; }
    public int Count { get; }
    public TNode Item { get; }
    public TextSpan FullSpan { get; }
    public TextSpan Span { get; }
    private TNode[] Nodes { get; }
    internal SyntaxList`1(SyntaxNode node);
    public SyntaxList`1(TNode node);
    public SyntaxList`1(IEnumerable`1<TNode> nodes);
    private static SyntaxNode CreateNode(IEnumerable`1<TNode> nodes);
    internal SyntaxNode get_Node();
    public sealed virtual int get_Count();
    public sealed virtual TNode get_Item(int index);
    internal SyntaxNode ItemInternal(int index);
    public TextSpan get_FullSpan();
    public TextSpan get_Span();
    public virtual string ToString();
    public string ToFullString();
    public SyntaxList`1<TNode> Add(TNode node);
    public SyntaxList`1<TNode> AddRange(IEnumerable`1<TNode> nodes);
    public SyntaxList`1<TNode> Insert(int index, TNode node);
    public SyntaxList`1<TNode> InsertRange(int index, IEnumerable`1<TNode> nodes);
    public SyntaxList`1<TNode> RemoveAt(int index);
    public SyntaxList`1<TNode> Remove(TNode node);
    public SyntaxList`1<TNode> Replace(TNode nodeInList, TNode newNode);
    public SyntaxList`1<TNode> ReplaceRange(TNode nodeInList, IEnumerable`1<TNode> newNodes);
    private static SyntaxList`1<TNode> CreateList(List`1<TNode> items);
    private static SyntaxList`1<TNode> CreateList(GreenNode creator, List`1<TNode> items);
    public TNode First();
    public TNode FirstOrDefault();
    public TNode Last();
    public TNode LastOrDefault();
    public bool Any();
    private TNode[] get_Nodes();
    public Enumerator<TNode> GetEnumerator();
    private sealed virtual override IEnumerator`1<TNode> System.Collections.Generic.IEnumerable<TNode>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static bool op_Equality(SyntaxList`1<TNode> left, SyntaxList`1<TNode> right);
    public static bool op_Inequality(SyntaxList`1<TNode> left, SyntaxList`1<TNode> right);
    public sealed virtual bool Equals(SyntaxList`1<TNode> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static SyntaxList`1<TNode> op_Implicit(SyntaxList`1<SyntaxNode> nodes);
    public static SyntaxList`1<SyntaxNode> op_Implicit(SyntaxList`1<TNode> nodes);
    public int IndexOf(TNode node);
    public int IndexOf(Func`2<TNode, bool> predicate);
    internal int IndexOf(int rawKind);
    public int LastIndexOf(TNode node);
    public int LastIndexOf(Func`2<TNode, bool> predicate);
}
internal class Microsoft.CodeAnalysis.SyntaxNavigator : object {
    private static int None;
    public static SyntaxNavigator Instance;
    private static Func`2[] s_stepIntoFunctions;
    private static ObjectPool`1<Stack`1<Enumerator>> s_childEnumeratorStackPool;
    private static ObjectPool`1<Stack`1<Enumerator>> s_childReversedEnumeratorStackPool;
    private static SyntaxNavigator();
    private static Func`2<SyntaxTrivia, bool> GetStepIntoFunction(bool skipped, bool directives, bool docComments);
    private static Func`2<SyntaxToken, bool> GetPredicateFunction(bool includeZeroWidth);
    private static bool Matches(Func`2<SyntaxToken, bool> predicate, SyntaxToken token);
    internal SyntaxToken GetFirstToken(SyntaxNode& current, bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    internal SyntaxToken GetLastToken(SyntaxNode& current, bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    internal SyntaxToken GetPreviousToken(SyntaxToken& current, bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    internal SyntaxToken GetNextToken(SyntaxToken& current, bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    internal SyntaxToken GetPreviousToken(SyntaxToken& current, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    internal SyntaxToken GetNextToken(SyntaxToken& current, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    internal SyntaxToken GetFirstToken(SyntaxNode current, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    internal SyntaxToken GetLastToken(SyntaxNode current, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    private SyntaxToken GetFirstToken(SyntaxTriviaList triviaList, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    private SyntaxToken GetLastToken(SyntaxTriviaList list, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    private bool TryGetLastTokenForStructuredTrivia(SyntaxTrivia trivia, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto, SyntaxToken& token);
    private SyntaxToken GetFirstToken(SyntaxToken token, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    private SyntaxToken GetLastToken(SyntaxToken token, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    internal SyntaxToken GetNextToken(SyntaxTrivia current, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    internal SyntaxToken GetPreviousToken(SyntaxTrivia current, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    private SyntaxToken GetNextToken(SyntaxTrivia current, SyntaxTriviaList list, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto, Boolean& returnNext);
    private SyntaxToken GetPreviousToken(SyntaxTrivia current, SyntaxTriviaList list, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto, Boolean& returnPrevious);
    internal SyntaxToken GetNextToken(SyntaxNode node, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    internal SyntaxToken GetPreviousToken(SyntaxNode node, Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    internal SyntaxToken GetNextToken(SyntaxToken& current, Func`2<SyntaxToken, bool> predicate, bool searchInsideCurrentTokenTrailingTrivia, Func`2<SyntaxTrivia, bool> stepInto);
    internal SyntaxToken GetPreviousToken(SyntaxToken& current, Func`2<SyntaxToken, bool> predicate, bool searchInsideCurrentTokenLeadingTrivia, Func`2<SyntaxTrivia, bool> stepInto);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public abstract class Microsoft.CodeAnalysis.SyntaxNode : object {
    private SyntaxNode _parent;
    internal SyntaxTree _syntaxTree;
    [CompilerGeneratedAttribute]
private GreenNode <Green>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int RawKind { get; }
    protected string KindText { get; }
    public string Language { get; }
    internal GreenNode Green { get; }
    internal int Position { get; }
    internal int EndPosition { get; }
    public SyntaxTree SyntaxTree { get; }
    internal bool IsList { get; }
    public TextSpan FullSpan { get; }
    internal int SlotCount { get; }
    public TextSpan Span { get; }
    public int SpanStart { get; }
    internal int Width { get; }
    internal int FullWidth { get; }
    public bool IsMissing { get; }
    public bool IsStructuredTrivia { get; }
    public bool HasStructuredTrivia { get; }
    public bool ContainsSkippedText { get; }
    public bool ContainsDirectives { get; }
    public bool ContainsDiagnostics { get; }
    public bool HasLeadingTrivia { get; }
    public bool HasTrailingTrivia { get; }
    internal Location Location { get; }
    public SyntaxNode Parent { get; }
    public SyntaxTrivia ParentTrivia { get; }
    internal SyntaxNode ParentOrStructuredTriviaParent { get; }
    public bool ContainsAnnotations { get; }
    protected SyntaxTree SyntaxTreeCore { get; }
    internal bool HasErrors { get; }
    internal SyntaxNode(GreenNode green, SyntaxNode parent, int position);
    internal SyntaxNode(GreenNode green, int position, SyntaxTree syntaxTree);
    private string GetDebuggerDisplay();
    public int get_RawKind();
    protected string get_KindText();
    public abstract virtual string get_Language();
    [CompilerGeneratedAttribute]
internal GreenNode get_Green();
    [CompilerGeneratedAttribute]
internal int get_Position();
    internal int get_EndPosition();
    public SyntaxTree get_SyntaxTree();
    internal bool get_IsList();
    public TextSpan get_FullSpan();
    internal int get_SlotCount();
    public TextSpan get_Span();
    public int get_SpanStart();
    internal int get_Width();
    internal int get_FullWidth();
    internal SyntaxNode GetRed(SyntaxNode& field, int slot);
    internal SyntaxNode GetRedAtZero(SyntaxNode& field);
    protected T GetRed(T& field, int slot);
    protected T GetRedAtZero(T& field);
    internal SyntaxNode GetRedElement(SyntaxNode& element, int slot);
    internal SyntaxNode GetRedElementIfNotToken(SyntaxNode& element);
    internal SyntaxNode GetWeakRedElement(WeakReference`1& slot, int index);
    private SyntaxNode CreateWeakItem(WeakReference`1& slot, int index);
    public virtual string ToString();
    public virtual string ToFullString();
    public virtual void WriteTo(TextWriter writer);
    public SourceText GetText(Encoding encoding, SourceHashAlgorithm checksumAlgorithm);
    public bool IsEquivalentTo(SyntaxNode other);
    public bool get_IsMissing();
    public bool IsPartOfStructuredTrivia();
    public bool get_IsStructuredTrivia();
    public bool get_HasStructuredTrivia();
    public bool get_ContainsSkippedText();
    public bool get_ContainsDirectives();
    public bool get_ContainsDiagnostics();
    public bool Contains(SyntaxNode node);
    public bool get_HasLeadingTrivia();
    public bool get_HasTrailingTrivia();
    internal abstract virtual SyntaxNode GetCachedSlot(int index);
    internal int GetChildIndex(int slot);
    internal virtual int GetChildPosition(int index);
    public Location GetLocation();
    internal Location get_Location();
    public IEnumerable`1<Diagnostic> GetDiagnostics();
    public SyntaxReference GetReference();
    public SyntaxNode get_Parent();
    public virtual SyntaxTrivia get_ParentTrivia();
    internal SyntaxNode get_ParentOrStructuredTriviaParent();
    public ChildSyntaxList ChildNodesAndTokens();
    public virtual SyntaxNodeOrToken ChildThatContainsPosition(int position);
    internal abstract virtual SyntaxNode GetNodeSlot(int slot);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNode/<ChildNodes>d__83")]
public IEnumerable`1<SyntaxNode> ChildNodes();
    public IEnumerable`1<SyntaxNode> Ancestors(bool ascendOutOfTrivia);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNode/<AncestorsAndSelf>d__85")]
public IEnumerable`1<SyntaxNode> AncestorsAndSelf(bool ascendOutOfTrivia);
    private static SyntaxNode GetParent(SyntaxNode node, bool ascendOutOfTrivia);
    public TNode FirstAncestorOrSelf(Func`2<TNode, bool> predicate, bool ascendOutOfTrivia);
    public IEnumerable`1<SyntaxNode> DescendantNodes(Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxNode> DescendantNodes(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxNode> DescendantNodesAndSelf(Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxNode> DescendantNodesAndSelf(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxNodeOrToken> DescendantNodesAndTokens(Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxNodeOrToken> DescendantNodesAndTokens(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf(Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public SyntaxNode FindNode(TextSpan span, bool findInsideTrivia, bool getInnermostNodeForTie);
    public SyntaxToken FindToken(int position, bool findInsideTrivia);
    public SyntaxToken GetFirstToken(bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    public SyntaxToken GetLastToken(bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNode/<ChildTokens>d__100")]
public IEnumerable`1<SyntaxToken> ChildTokens();
    public IEnumerable`1<SyntaxToken> DescendantTokens(Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxToken> DescendantTokens(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public SyntaxTriviaList GetLeadingTrivia();
    public SyntaxTriviaList GetTrailingTrivia();
    public SyntaxTrivia FindTrivia(int position, bool findInsideTrivia);
    public SyntaxTrivia FindTrivia(int position, Func`2<SyntaxTrivia, bool> stepInto);
    internal static SyntaxTrivia FindTriviaByOffset(SyntaxNode node, int textOffset, Func`2<SyntaxTrivia, bool> stepInto);
    public IEnumerable`1<SyntaxTrivia> DescendantTrivia(Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public IEnumerable`1<SyntaxTrivia> DescendantTrivia(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    public bool get_ContainsAnnotations();
    public bool HasAnnotations(string annotationKind);
    public bool HasAnnotations(IEnumerable`1<string> annotationKinds);
    public bool HasAnnotation(SyntaxAnnotation annotation);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(string annotationKind);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(IEnumerable`1<string> annotationKinds);
    internal SyntaxAnnotation[] GetAnnotations();
    public IEnumerable`1<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(string annotationKind);
    public IEnumerable`1<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(String[] annotationKinds);
    public IEnumerable`1<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(SyntaxAnnotation annotation);
    public IEnumerable`1<SyntaxNode> GetAnnotatedNodes(SyntaxAnnotation syntaxAnnotation);
    public IEnumerable`1<SyntaxNode> GetAnnotatedNodes(string annotationKind);
    public IEnumerable`1<SyntaxToken> GetAnnotatedTokens(SyntaxAnnotation syntaxAnnotation);
    public IEnumerable`1<SyntaxToken> GetAnnotatedTokens(string annotationKind);
    public IEnumerable`1<SyntaxTrivia> GetAnnotatedTrivia(string annotationKind);
    public IEnumerable`1<SyntaxTrivia> GetAnnotatedTrivia(String[] annotationKinds);
    public IEnumerable`1<SyntaxTrivia> GetAnnotatedTrivia(SyntaxAnnotation annotation);
    internal SyntaxNode WithAdditionalAnnotationsInternal(IEnumerable`1<SyntaxAnnotation> annotations);
    internal SyntaxNode GetNodeWithoutAnnotations(IEnumerable`1<SyntaxAnnotation> annotations);
    public T CopyAnnotationsTo(T node);
    public bool IsEquivalentTo(SyntaxNode node, bool topLevel);
    public virtual void SerializeTo(Stream stream, CancellationToken cancellationToken);
    protected virtual bool EquivalentToCore(SyntaxNode other);
    protected abstract virtual SyntaxTree get_SyntaxTreeCore();
    protected virtual SyntaxToken FindTokenCore(int position, bool findInsideTrivia);
    private bool TryGetEofAt(int position, SyntaxToken& Eof);
    internal SyntaxToken FindTokenInternal(int position);
    private SyntaxToken FindToken(int position, Func`2<SyntaxTrivia, bool> findInsideTrivia);
    protected virtual SyntaxToken FindTokenCore(int position, Func`2<SyntaxTrivia, bool> stepInto);
    internal static SyntaxTrivia GetTriviaFromSyntaxToken(int position, SyntaxToken& token);
    internal static SyntaxTrivia GetTriviaThatContainsPosition(SyntaxTriviaList& list, int position);
    protected virtual SyntaxTrivia FindTriviaCore(int position, bool findInsideTrivia);
    protected internal abstract virtual SyntaxNode ReplaceCore(IEnumerable`1<TNode> nodes, Func`3<TNode, TNode, SyntaxNode> computeReplacementNode, IEnumerable`1<SyntaxToken> tokens, Func`3<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken, IEnumerable`1<SyntaxTrivia> trivia, Func`3<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia);
    protected internal abstract virtual SyntaxNode ReplaceNodeInListCore(SyntaxNode originalNode, IEnumerable`1<SyntaxNode> replacementNodes);
    protected internal abstract virtual SyntaxNode InsertNodesInListCore(SyntaxNode nodeInList, IEnumerable`1<SyntaxNode> nodesToInsert, bool insertBefore);
    protected internal abstract virtual SyntaxNode ReplaceTokenInListCore(SyntaxToken originalToken, IEnumerable`1<SyntaxToken> newTokens);
    protected internal abstract virtual SyntaxNode InsertTokensInListCore(SyntaxToken originalToken, IEnumerable`1<SyntaxToken> newTokens, bool insertBefore);
    protected internal abstract virtual SyntaxNode ReplaceTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable`1<SyntaxTrivia> newTrivia);
    protected internal abstract virtual SyntaxNode InsertTriviaInListCore(SyntaxTrivia originalTrivia, IEnumerable`1<SyntaxTrivia> newTrivia, bool insertBefore);
    protected internal abstract virtual SyntaxNode RemoveNodesCore(IEnumerable`1<SyntaxNode> nodes, SyntaxRemoveOptions options);
    protected internal abstract virtual SyntaxNode NormalizeWhitespaceCore(string indentation, string eol, bool elasticTrivia);
    protected abstract virtual bool IsEquivalentToCore(SyntaxNode node, bool topLevel);
    internal virtual bool ShouldCreateWeakList();
    internal bool get_HasErrors();
    private bool HasErrorsSlow();
    internal static T CloneNodeAsRoot(T node, SyntaxTree syntaxTree);
    private IEnumerable`1<SyntaxNode> DescendantNodesImpl(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia, bool includeSelf);
    private IEnumerable`1<SyntaxNodeOrToken> DescendantNodesAndTokensImpl(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia, bool includeSelf);
    private IEnumerable`1<SyntaxTrivia> DescendantTriviaImpl(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool descendIntoTrivia);
    private static bool IsInSpan(TextSpan& span, TextSpan childSpan);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNode/<DescendantNodesOnly>d__167")]
private IEnumerable`1<SyntaxNode> DescendantNodesOnly(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool includeSelf);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNode/<DescendantNodesAndTokensOnly>d__168")]
private IEnumerable`1<SyntaxNodeOrToken> DescendantNodesAndTokensOnly(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool includeSelf);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNode/<DescendantNodesAndTokensIntoTrivia>d__169")]
private IEnumerable`1<SyntaxNodeOrToken> DescendantNodesAndTokensIntoTrivia(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren, bool includeSelf);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNode/<DescendantTriviaOnly>d__170")]
private IEnumerable`1<SyntaxTrivia> DescendantTriviaOnly(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNode/<DescendantTriviaIntoTrivia>d__171")]
private IEnumerable`1<SyntaxTrivia> DescendantTriviaIntoTrivia(TextSpan span, Func`2<SyntaxNode, bool> descendIntoChildren);
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.SyntaxNodeExtensions : object {
    internal static string DefaultIndentation;
    internal static string DefaultEOL;
    private static ConditionalWeakTable`2<SyntaxNode, SyntaxAnnotation> s_nodeToIdMap;
    private static ConditionalWeakTable`2<SyntaxNode, CurrentNodes> s_rootToCurrentNodesMap;
    internal static string IdAnnotationKind;
    private static SyntaxNodeExtensions();
    [ExtensionAttribute]
public static TRoot ReplaceSyntax(TRoot root, IEnumerable`1<SyntaxNode> nodes, Func`3<SyntaxNode, SyntaxNode, SyntaxNode> computeReplacementNode, IEnumerable`1<SyntaxToken> tokens, Func`3<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken, IEnumerable`1<SyntaxTrivia> trivia, Func`3<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia);
    [ExtensionAttribute]
public static TRoot ReplaceNodes(TRoot root, IEnumerable`1<TNode> nodes, Func`3<TNode, TNode, SyntaxNode> computeReplacementNode);
    [ExtensionAttribute]
public static TRoot ReplaceNode(TRoot root, SyntaxNode oldNode, SyntaxNode newNode);
    [ExtensionAttribute]
public static TRoot ReplaceNode(TRoot root, SyntaxNode oldNode, IEnumerable`1<SyntaxNode> newNodes);
    [ExtensionAttribute]
public static TRoot InsertNodesBefore(TRoot root, SyntaxNode nodeInList, IEnumerable`1<SyntaxNode> newNodes);
    [ExtensionAttribute]
public static TRoot InsertNodesAfter(TRoot root, SyntaxNode nodeInList, IEnumerable`1<SyntaxNode> newNodes);
    [ExtensionAttribute]
public static TRoot ReplaceToken(TRoot root, SyntaxToken tokenInList, IEnumerable`1<SyntaxToken> newTokens);
    [ExtensionAttribute]
public static TRoot InsertTokensBefore(TRoot root, SyntaxToken tokenInList, IEnumerable`1<SyntaxToken> newTokens);
    [ExtensionAttribute]
public static TRoot InsertTokensAfter(TRoot root, SyntaxToken tokenInList, IEnumerable`1<SyntaxToken> newTokens);
    [ExtensionAttribute]
public static TRoot ReplaceTrivia(TRoot root, SyntaxTrivia oldTrivia, IEnumerable`1<SyntaxTrivia> newTrivia);
    [ExtensionAttribute]
public static TRoot InsertTriviaBefore(TRoot root, SyntaxTrivia trivia, IEnumerable`1<SyntaxTrivia> newTrivia);
    [ExtensionAttribute]
public static TRoot InsertTriviaAfter(TRoot root, SyntaxTrivia trivia, IEnumerable`1<SyntaxTrivia> newTrivia);
    [ExtensionAttribute]
public static TRoot ReplaceTokens(TRoot root, IEnumerable`1<SyntaxToken> tokens, Func`3<SyntaxToken, SyntaxToken, SyntaxToken> computeReplacementToken);
    [ExtensionAttribute]
public static TRoot ReplaceToken(TRoot root, SyntaxToken oldToken, SyntaxToken newToken);
    [ExtensionAttribute]
public static TRoot ReplaceTrivia(TRoot root, IEnumerable`1<SyntaxTrivia> trivia, Func`3<SyntaxTrivia, SyntaxTrivia, SyntaxTrivia> computeReplacementTrivia);
    [ExtensionAttribute]
public static TRoot ReplaceTrivia(TRoot root, SyntaxTrivia trivia, SyntaxTrivia newTrivia);
    [ExtensionAttribute]
public static TRoot RemoveNode(TRoot root, SyntaxNode node, SyntaxRemoveOptions options);
    [ExtensionAttribute]
public static TRoot RemoveNodes(TRoot root, IEnumerable`1<SyntaxNode> nodes, SyntaxRemoveOptions options);
    [ExtensionAttribute]
public static TNode NormalizeWhitespace(TNode node, string indentation, bool elasticTrivia);
    [ExtensionAttribute]
public static TNode NormalizeWhitespace(TNode node, string indentation, string eol, bool elasticTrivia);
    [ExtensionAttribute]
public static TSyntax WithTriviaFrom(TSyntax syntax, SyntaxNode node);
    [ExtensionAttribute]
public static TSyntax WithoutTrivia(TSyntax syntax);
    [ExtensionAttribute]
public static SyntaxToken WithoutTrivia(SyntaxToken token);
    [ExtensionAttribute]
public static TSyntax WithLeadingTrivia(TSyntax node, SyntaxTriviaList trivia);
    [ExtensionAttribute]
public static TSyntax WithLeadingTrivia(TSyntax node, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static TSyntax WithoutLeadingTrivia(TSyntax node);
    [ExtensionAttribute]
public static TSyntax WithLeadingTrivia(TSyntax node, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
public static TSyntax WithTrailingTrivia(TSyntax node, SyntaxTriviaList trivia);
    [ExtensionAttribute]
public static TSyntax WithTrailingTrivia(TSyntax node, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static TSyntax WithoutTrailingTrivia(TSyntax node);
    [ExtensionAttribute]
public static TSyntax WithTrailingTrivia(TSyntax node, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
internal static SyntaxNode AsRootOfNewTreeWithOptionsFrom(SyntaxNode node, SyntaxTree oldTree);
    [ExtensionAttribute]
public static TRoot TrackNodes(TRoot root, IEnumerable`1<SyntaxNode> nodes);
    [ExtensionAttribute]
public static TRoot TrackNodes(TRoot root, SyntaxNode[] nodes);
    [ExtensionAttribute]
public static IEnumerable`1<TNode> GetCurrentNodes(SyntaxNode root, TNode node);
    [ExtensionAttribute]
public static TNode GetCurrentNode(SyntaxNode root, TNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SyntaxNodeExtensions/<GetCurrentNodes>d__41`1")]
[ExtensionAttribute]
public static IEnumerable`1<TNode> GetCurrentNodes(SyntaxNode root, IEnumerable`1<TNode> nodes);
    private static IReadOnlyList`1<SyntaxNode> GetCurrentNodeFromTrueRoots(SyntaxNode trueRoot, SyntaxNode node);
    private static SyntaxAnnotation GetId(SyntaxNode original);
    private static SyntaxNode GetRoot(SyntaxNode node);
    private static bool IsDescendant(SyntaxNode root, SyntaxNode node);
}
internal class Microsoft.CodeAnalysis.SyntaxNodeLocationComparer : object {
    private Compilation _compilation;
    public SyntaxNodeLocationComparer(Compilation compilation);
    public sealed virtual int Compare(SyntaxNode x, SyntaxNode y);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.SyntaxNodeOrToken : ValueType {
    private SyntaxNode _nodeOrParent;
    private GreenNode _token;
    private int _position;
    private int _tokenIndex;
    private string KindText { get; }
    public int RawKind { get; }
    public string Language { get; }
    public bool IsMissing { get; }
    public SyntaxNode Parent { get; }
    internal GreenNode UnderlyingNode { get; }
    internal int Position { get; }
    public bool IsToken { get; }
    public bool IsNode { get; }
    public TextSpan Span { get; }
    public int SpanStart { get; }
    public TextSpan FullSpan { get; }
    public bool HasLeadingTrivia { get; }
    public bool HasTrailingTrivia { get; }
    public bool ContainsDiagnostics { get; }
    public bool ContainsDirectives { get; }
    public bool ContainsAnnotations { get; }
    public SyntaxTree SyntaxTree { get; }
    internal int Width { get; }
    internal int FullWidth { get; }
    internal int EndPosition { get; }
    internal SyntaxNodeOrToken(SyntaxNode node);
    internal SyntaxNodeOrToken(SyntaxNode parent, GreenNode token, int position, int index);
    internal string GetDebuggerDisplay();
    private string get_KindText();
    public int get_RawKind();
    public string get_Language();
    public bool get_IsMissing();
    public SyntaxNode get_Parent();
    internal GreenNode get_UnderlyingNode();
    internal int get_Position();
    public bool get_IsToken();
    public bool get_IsNode();
    public SyntaxToken AsToken();
    public SyntaxNode AsNode();
    public ChildSyntaxList ChildNodesAndTokens();
    public TextSpan get_Span();
    public int get_SpanStart();
    public TextSpan get_FullSpan();
    public virtual string ToString();
    public string ToFullString();
    public void WriteTo(TextWriter writer);
    public bool get_HasLeadingTrivia();
    public SyntaxTriviaList GetLeadingTrivia();
    public bool get_HasTrailingTrivia();
    public SyntaxTriviaList GetTrailingTrivia();
    public SyntaxNodeOrToken WithLeadingTrivia(IEnumerable`1<SyntaxTrivia> trivia);
    public SyntaxNodeOrToken WithLeadingTrivia(SyntaxTrivia[] trivia);
    public SyntaxNodeOrToken WithTrailingTrivia(IEnumerable`1<SyntaxTrivia> trivia);
    public SyntaxNodeOrToken WithTrailingTrivia(SyntaxTrivia[] trivia);
    public bool get_ContainsDiagnostics();
    public IEnumerable`1<Diagnostic> GetDiagnostics();
    public bool get_ContainsDirectives();
    public bool get_ContainsAnnotations();
    public bool HasAnnotations(string annotationKind);
    public bool HasAnnotations(IEnumerable`1<string> annotationKinds);
    public bool HasAnnotation(SyntaxAnnotation annotation);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(string annotationKind);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(IEnumerable`1<string> annotationKinds);
    public SyntaxNodeOrToken WithAdditionalAnnotations(SyntaxAnnotation[] annotations);
    public SyntaxNodeOrToken WithAdditionalAnnotations(IEnumerable`1<SyntaxAnnotation> annotations);
    public SyntaxNodeOrToken WithoutAnnotations(SyntaxAnnotation[] annotations);
    public SyntaxNodeOrToken WithoutAnnotations(IEnumerable`1<SyntaxAnnotation> annotations);
    public SyntaxNodeOrToken WithoutAnnotations(string annotationKind);
    public sealed virtual bool Equals(SyntaxNodeOrToken other);
    public static bool op_Equality(SyntaxNodeOrToken left, SyntaxNodeOrToken right);
    public static bool op_Inequality(SyntaxNodeOrToken left, SyntaxNodeOrToken right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public bool IsEquivalentTo(SyntaxNodeOrToken other);
    public static SyntaxNodeOrToken op_Implicit(SyntaxToken token);
    public static SyntaxToken op_Explicit(SyntaxNodeOrToken nodeOrToken);
    public static SyntaxNodeOrToken op_Implicit(SyntaxNode node);
    public static SyntaxNode op_Explicit(SyntaxNodeOrToken nodeOrToken);
    public SyntaxTree get_SyntaxTree();
    public Location GetLocation();
    internal IList`1<TDirective> GetDirectives(Func`2<TDirective, bool> filter);
    private static void GetDirectives(SyntaxNodeOrToken& node, Func`2<TDirective, bool> filter, List`1& directives);
    private static void GetDirectives(SyntaxNode node, Func`2<TDirective, bool> filter, List`1& directives);
    private static void GetDirectives(SyntaxToken token, Func`2<TDirective, bool> filter, List`1& directives);
    private static void GetDirectives(SyntaxTriviaList& trivia, Func`2<TDirective, bool> filter, List`1& directives);
    internal int get_Width();
    internal int get_FullWidth();
    internal int get_EndPosition();
    public static int GetFirstChildIndexSpanningPosition(SyntaxNode node, int position);
    internal static int GetFirstChildIndexSpanningPosition(ChildSyntaxList list, int position);
    public SyntaxNodeOrToken GetNextSibling();
    public SyntaxNodeOrToken GetPreviousSibling();
    private SyntaxNodeOrToken GetNextSiblingFromStart(ChildSyntaxList siblings);
    private SyntaxNodeOrToken GetNextSiblingWithSearch(ChildSyntaxList siblings);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.SyntaxNodeOrTokenList : ValueType {
    private SyntaxNode _node;
    internal int index;
    internal SyntaxNode Node { get; }
    internal int Position { get; }
    internal SyntaxNode Parent { get; }
    public int Count { get; }
    public SyntaxNodeOrToken Item { get; }
    public TextSpan FullSpan { get; }
    public TextSpan Span { get; }
    private SyntaxNodeOrToken[] Nodes { get; }
    internal SyntaxNodeOrTokenList(SyntaxNode node, int index);
    public SyntaxNodeOrTokenList(IEnumerable`1<SyntaxNodeOrToken> nodesAndTokens);
    public SyntaxNodeOrTokenList(SyntaxNodeOrToken[] nodesAndTokens);
    private static SyntaxNode CreateNode(IEnumerable`1<SyntaxNodeOrToken> nodesAndTokens);
    internal SyntaxNode get_Node();
    internal int get_Position();
    internal SyntaxNode get_Parent();
    public sealed virtual int get_Count();
    public SyntaxNodeOrToken get_Item(int index);
    public TextSpan get_FullSpan();
    public TextSpan get_Span();
    public virtual string ToString();
    public string ToFullString();
    public SyntaxNodeOrToken First();
    public SyntaxNodeOrToken FirstOrDefault();
    public SyntaxNodeOrToken Last();
    public SyntaxNodeOrToken LastOrDefault();
    public int IndexOf(SyntaxNodeOrToken nodeOrToken);
    public bool Any();
    internal void CopyTo(int offset, GreenNode[] array, int arrayOffset, int count);
    public SyntaxNodeOrTokenList Add(SyntaxNodeOrToken nodeOrToken);
    public SyntaxNodeOrTokenList AddRange(IEnumerable`1<SyntaxNodeOrToken> nodesOrTokens);
    public SyntaxNodeOrTokenList Insert(int index, SyntaxNodeOrToken nodeOrToken);
    public SyntaxNodeOrTokenList InsertRange(int index, IEnumerable`1<SyntaxNodeOrToken> nodesAndTokens);
    private static SyntaxNodeOrTokenList CreateList(GreenNode creator, List`1<SyntaxNodeOrToken> items);
    public SyntaxNodeOrTokenList RemoveAt(int index);
    public SyntaxNodeOrTokenList Remove(SyntaxNodeOrToken nodeOrTokenInList);
    public SyntaxNodeOrTokenList Replace(SyntaxNodeOrToken nodeOrTokenInList, SyntaxNodeOrToken newNodeOrToken);
    public SyntaxNodeOrTokenList ReplaceRange(SyntaxNodeOrToken nodeOrTokenInList, IEnumerable`1<SyntaxNodeOrToken> newNodesAndTokens);
    private SyntaxNodeOrToken[] get_Nodes();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<SyntaxNodeOrToken> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxNodeOrToken>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static bool op_Equality(SyntaxNodeOrTokenList left, SyntaxNodeOrTokenList right);
    public static bool op_Inequality(SyntaxNodeOrTokenList left, SyntaxNodeOrTokenList right);
    public sealed virtual bool Equals(SyntaxNodeOrTokenList other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Microsoft.CodeAnalysis.SyntaxReference : object {
    public SyntaxTree SyntaxTree { get; }
    public TextSpan Span { get; }
    public abstract virtual SyntaxTree get_SyntaxTree();
    public abstract virtual TextSpan get_Span();
    public abstract virtual SyntaxNode GetSyntax(CancellationToken cancellationToken);
    public virtual Task`1<SyntaxNode> GetSyntaxAsync(CancellationToken cancellationToken);
    internal Location GetLocation();
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.SyntaxRemoveOptions : Enum {
    public int value__;
    public static SyntaxRemoveOptions KeepNoTrivia;
    public static SyntaxRemoveOptions KeepLeadingTrivia;
    public static SyntaxRemoveOptions KeepTrailingTrivia;
    public static SyntaxRemoveOptions KeepExteriorTrivia;
    public static SyntaxRemoveOptions KeepUnbalancedDirectives;
    public static SyntaxRemoveOptions KeepDirectives;
    public static SyntaxRemoveOptions KeepEndOfLine;
    public static SyntaxRemoveOptions AddElasticMarker;
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.SyntaxToken : ValueType {
    private static Func`2<DiagnosticInfo, Diagnostic> s_createDiagnosticWithoutLocation;
    internal static Func`2<SyntaxToken, bool> NonZeroWidth;
    internal static Func`2<SyntaxToken, bool> Any;
    [CompilerGeneratedAttribute]
private SyntaxNode <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private GreenNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public int RawKind { get; }
    public string Language { get; }
    internal int RawContextualKind { get; }
    public SyntaxNode Parent { get; }
    internal GreenNode Node { get; }
    internal int Index { get; }
    internal int Position { get; }
    internal int Width { get; }
    internal int FullWidth { get; }
    public TextSpan Span { get; }
    internal int EndPosition { get; }
    public int SpanStart { get; }
    public TextSpan FullSpan { get; }
    public bool IsMissing { get; }
    public object Value { get; }
    public string ValueText { get; }
    public string Text { get; }
    public bool HasLeadingTrivia { get; }
    public bool HasTrailingTrivia { get; }
    internal int LeadingWidth { get; }
    internal int TrailingWidth { get; }
    public bool ContainsDiagnostics { get; }
    public bool ContainsDirectives { get; }
    public bool HasStructuredTrivia { get; }
    public bool ContainsAnnotations { get; }
    public SyntaxTriviaList LeadingTrivia { get; }
    public SyntaxTriviaList TrailingTrivia { get; }
    public SyntaxTree SyntaxTree { get; }
    internal SyntaxToken(SyntaxNode parent, GreenNode token, int position, int index);
    internal SyntaxToken(GreenNode token);
    private static SyntaxToken();
    private string GetDebuggerDisplay();
    public int get_RawKind();
    public string get_Language();
    internal int get_RawContextualKind();
    [CompilerGeneratedAttribute]
public SyntaxNode get_Parent();
    [CompilerGeneratedAttribute]
internal GreenNode get_Node();
    [CompilerGeneratedAttribute]
internal int get_Index();
    [CompilerGeneratedAttribute]
internal int get_Position();
    internal int get_Width();
    internal int get_FullWidth();
    public TextSpan get_Span();
    internal int get_EndPosition();
    public int get_SpanStart();
    public TextSpan get_FullSpan();
    public bool get_IsMissing();
    public object get_Value();
    public string get_ValueText();
    public string get_Text();
    public virtual string ToString();
    public string ToFullString();
    public void WriteTo(TextWriter writer);
    internal void WriteTo(TextWriter writer, bool leading, bool trailing);
    public bool get_HasLeadingTrivia();
    public bool get_HasTrailingTrivia();
    internal int get_LeadingWidth();
    internal int get_TrailingWidth();
    public bool get_ContainsDiagnostics();
    public bool get_ContainsDirectives();
    public bool IsPartOfStructuredTrivia();
    public bool get_HasStructuredTrivia();
    public bool get_ContainsAnnotations();
    public bool HasAnnotations(string annotationKind);
    public bool HasAnnotations(String[] annotationKinds);
    public bool HasAnnotation(SyntaxAnnotation annotation);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(string annotationKind);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(String[] annotationKinds);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(IEnumerable`1<string> annotationKinds);
    public SyntaxToken WithAdditionalAnnotations(SyntaxAnnotation[] annotations);
    public SyntaxToken WithAdditionalAnnotations(IEnumerable`1<SyntaxAnnotation> annotations);
    public SyntaxToken WithoutAnnotations(SyntaxAnnotation[] annotations);
    public SyntaxToken WithoutAnnotations(IEnumerable`1<SyntaxAnnotation> annotations);
    public SyntaxToken WithoutAnnotations(string annotationKind);
    public SyntaxToken CopyAnnotationsTo(SyntaxToken token);
    public SyntaxTriviaList get_LeadingTrivia();
    public SyntaxTriviaList get_TrailingTrivia();
    public SyntaxToken WithTriviaFrom(SyntaxToken token);
    public SyntaxToken WithLeadingTrivia(SyntaxTriviaList trivia);
    public SyntaxToken WithLeadingTrivia(SyntaxTrivia[] trivia);
    public SyntaxToken WithLeadingTrivia(IEnumerable`1<SyntaxTrivia> trivia);
    public SyntaxToken WithTrailingTrivia(SyntaxTriviaList trivia);
    public SyntaxToken WithTrailingTrivia(SyntaxTrivia[] trivia);
    public SyntaxToken WithTrailingTrivia(IEnumerable`1<SyntaxTrivia> trivia);
    public IEnumerable`1<SyntaxTrivia> GetAllTrivia();
    public static bool op_Equality(SyntaxToken left, SyntaxToken right);
    public static bool op_Inequality(SyntaxToken left, SyntaxToken right);
    public sealed virtual bool Equals(SyntaxToken other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public SyntaxToken GetNextToken(bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    internal SyntaxToken GetNextToken(Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    public SyntaxToken GetPreviousToken(bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    internal SyntaxToken GetPreviousToken(Func`2<SyntaxToken, bool> predicate, Func`2<SyntaxTrivia, bool> stepInto);
    public SyntaxTree get_SyntaxTree();
    public Location GetLocation();
    public IEnumerable`1<Diagnostic> GetDiagnostics();
    public bool IsEquivalentTo(SyntaxToken token);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.SyntaxTokenList : ValueType {
    private SyntaxNode _parent;
    private int _index;
    [CompilerGeneratedAttribute]
private GreenNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    internal GreenNode Node { get; }
    internal int Position { get; }
    public int Count { get; }
    public SyntaxToken Item { get; }
    public TextSpan FullSpan { get; }
    public TextSpan Span { get; }
    private SyntaxToken[] Nodes { get; }
    internal SyntaxTokenList(SyntaxNode parent, GreenNode tokenOrList, int position, int index);
    public SyntaxTokenList(SyntaxToken token);
    public SyntaxTokenList(SyntaxToken[] tokens);
    public SyntaxTokenList(IEnumerable`1<SyntaxToken> tokens);
    private static GreenNode CreateNode(SyntaxToken[] tokens);
    private static GreenNode CreateNode(IEnumerable`1<SyntaxToken> tokens);
    [CompilerGeneratedAttribute]
internal GreenNode get_Node();
    [CompilerGeneratedAttribute]
internal int get_Position();
    public sealed virtual int get_Count();
    public sealed virtual SyntaxToken get_Item(int index);
    public TextSpan get_FullSpan();
    public TextSpan get_Span();
    public virtual string ToString();
    public string ToFullString();
    public SyntaxToken First();
    public SyntaxToken Last();
    public bool Any();
    public Reversed Reverse();
    internal void CopyTo(int offset, GreenNode[] array, int arrayOffset, int count);
    private GreenNode GetGreenNodeAt(int i);
    private static GreenNode GetGreenNodeAt(GreenNode node, int i);
    public int IndexOf(SyntaxToken tokenInList);
    internal int IndexOf(int rawKind);
    public SyntaxTokenList Add(SyntaxToken token);
    public SyntaxTokenList AddRange(IEnumerable`1<SyntaxToken> tokens);
    public SyntaxTokenList Insert(int index, SyntaxToken token);
    public SyntaxTokenList InsertRange(int index, IEnumerable`1<SyntaxToken> tokens);
    public SyntaxTokenList RemoveAt(int index);
    public SyntaxTokenList Remove(SyntaxToken tokenInList);
    public SyntaxTokenList Replace(SyntaxToken tokenInList, SyntaxToken newToken);
    public SyntaxTokenList ReplaceRange(SyntaxToken tokenInList, IEnumerable`1<SyntaxToken> newTokens);
    private SyntaxToken[] get_Nodes();
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<SyntaxToken> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxToken>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public static bool op_Equality(SyntaxTokenList left, SyntaxTokenList right);
    public static bool op_Inequality(SyntaxTokenList left, SyntaxTokenList right);
    public sealed virtual bool Equals(SyntaxTokenList other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static SyntaxTokenList Create(SyntaxToken token);
}
public abstract class Microsoft.CodeAnalysis.SyntaxTree : object {
    private ImmutableArray`1<byte> _lazyChecksum;
    private SourceHashAlgorithm _lazyHashAlgorithm;
    public string FilePath { get; }
    public bool HasCompilationUnitRoot { get; }
    public ParseOptions Options { get; }
    protected ParseOptions OptionsCore { get; }
    public int Length { get; }
    public Encoding Encoding { get; }
    internal bool SupportsLocations { get; }
    public abstract virtual string get_FilePath();
    public abstract virtual bool get_HasCompilationUnitRoot();
    public ParseOptions get_Options();
    protected abstract virtual ParseOptions get_OptionsCore();
    public abstract virtual int get_Length();
    public abstract virtual bool TryGetText(SourceText& text);
    public abstract virtual SourceText GetText(CancellationToken cancellationToken);
    public abstract virtual Encoding get_Encoding();
    public virtual Task`1<SourceText> GetTextAsync(CancellationToken cancellationToken);
    public bool TryGetRoot(SyntaxNode& root);
    protected abstract virtual bool TryGetRootCore(SyntaxNode& root);
    public SyntaxNode GetRoot(CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode GetRootCore(CancellationToken cancellationToken);
    public Task`1<SyntaxNode> GetRootAsync(CancellationToken cancellationToken);
    protected abstract virtual Task`1<SyntaxNode> GetRootAsyncCore(CancellationToken cancellationToken);
    public abstract virtual SyntaxTree WithChangedText(SourceText newText);
    public abstract virtual IEnumerable`1<Diagnostic> GetDiagnostics(CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<Diagnostic> GetDiagnostics(SyntaxNode node);
    public abstract virtual IEnumerable`1<Diagnostic> GetDiagnostics(SyntaxToken token);
    public abstract virtual IEnumerable`1<Diagnostic> GetDiagnostics(SyntaxTrivia trivia);
    public abstract virtual IEnumerable`1<Diagnostic> GetDiagnostics(SyntaxNodeOrToken nodeOrToken);
    public abstract virtual FileLinePositionSpan GetLineSpan(TextSpan span, CancellationToken cancellationToken);
    public abstract virtual FileLinePositionSpan GetMappedLineSpan(TextSpan span, CancellationToken cancellationToken);
    public virtual LineVisibility GetLineVisibility(int position, CancellationToken cancellationToken);
    internal virtual FileLinePositionSpan GetMappedLineSpanAndVisibility(TextSpan span, Boolean& isHiddenPosition);
    internal string GetDisplayPath(TextSpan span, SourceReferenceResolver resolver);
    internal int GetDisplayLineNumber(TextSpan span);
    public abstract virtual bool HasHiddenRegions();
    public abstract virtual IList`1<TextSpan> GetChangedSpans(SyntaxTree syntaxTree);
    public abstract virtual Location GetLocation(TextSpan span);
    public abstract virtual bool IsEquivalentTo(SyntaxTree tree, bool topLevel);
    public abstract virtual SyntaxReference GetReference(SyntaxNode node);
    public abstract virtual IList`1<TextChange> GetChanges(SyntaxTree oldTree);
    internal DebugSourceInfo GetDebugSourceInfo();
    public abstract virtual SyntaxTree WithRootAndOptions(SyntaxNode root, ParseOptions options);
    public abstract virtual SyntaxTree WithFilePath(string path);
    public virtual string ToString();
    internal virtual bool get_SupportsLocations();
}
internal class Microsoft.CodeAnalysis.SyntaxTreeComparer : object {
    public static SyntaxTreeComparer Instance;
    private static SyntaxTreeComparer();
    public sealed virtual bool Equals(SyntaxTree x, SyntaxTree y);
    public sealed virtual int GetHashCode(SyntaxTree obj);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SyntaxTreeExtensions : object {
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
internal static void VerifySource(SyntaxTree tree, IEnumerable`1<TextChangeRange> changes);
    private static int FindFirstDifference(string s1, string s2);
    [ExtensionAttribute]
public static bool IsHiddenPosition(SyntaxTree tree, int position, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.SyntaxTrivia : ValueType {
    internal static Func`2<SyntaxTrivia, bool> Any;
    [CompilerGeneratedAttribute]
private SyntaxToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private GreenNode <UnderlyingNode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    public int RawKind { get; }
    public string Language { get; }
    public SyntaxToken Token { get; }
    internal GreenNode UnderlyingNode { get; }
    internal int Position { get; }
    internal int Index { get; }
    internal int Width { get; }
    internal int FullWidth { get; }
    public TextSpan Span { get; }
    public int SpanStart { get; }
    public TextSpan FullSpan { get; }
    public bool ContainsDiagnostics { get; }
    public bool HasStructure { get; }
    internal bool ContainsAnnotations { get; }
    public bool IsDirective { get; }
    internal bool IsSkippedTokensTrivia { get; }
    internal bool IsDocumentationCommentTrivia { get; }
    public SyntaxTree SyntaxTree { get; }
    internal SyntaxTrivia(SyntaxToken& token, GreenNode triviaNode, int position, int index);
    private static SyntaxTrivia();
    public int get_RawKind();
    private string GetDebuggerDisplay();
    public string get_Language();
    [CompilerGeneratedAttribute]
public SyntaxToken get_Token();
    [CompilerGeneratedAttribute]
internal GreenNode get_UnderlyingNode();
    [CompilerGeneratedAttribute]
internal int get_Position();
    [CompilerGeneratedAttribute]
internal int get_Index();
    internal int get_Width();
    internal int get_FullWidth();
    public TextSpan get_Span();
    public int get_SpanStart();
    public TextSpan get_FullSpan();
    public bool get_ContainsDiagnostics();
    public bool get_HasStructure();
    public bool IsPartOfStructuredTrivia();
    internal bool get_ContainsAnnotations();
    public bool HasAnnotations(string annotationKind);
    public bool HasAnnotations(String[] annotationKinds);
    public bool HasAnnotation(SyntaxAnnotation annotation);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(string annotationKind);
    public IEnumerable`1<SyntaxAnnotation> GetAnnotations(String[] annotationKinds);
    public bool get_IsDirective();
    internal bool get_IsSkippedTokensTrivia();
    internal bool get_IsDocumentationCommentTrivia();
    public SyntaxNode GetStructure();
    public virtual string ToString();
    public string ToFullString();
    public void WriteTo(TextWriter writer);
    public static bool op_Equality(SyntaxTrivia left, SyntaxTrivia right);
    public static bool op_Inequality(SyntaxTrivia left, SyntaxTrivia right);
    public sealed virtual bool Equals(SyntaxTrivia other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public SyntaxTrivia WithAdditionalAnnotations(SyntaxAnnotation[] annotations);
    public SyntaxTrivia WithAdditionalAnnotations(IEnumerable`1<SyntaxAnnotation> annotations);
    public SyntaxTrivia WithoutAnnotations(SyntaxAnnotation[] annotations);
    public SyntaxTrivia WithoutAnnotations(IEnumerable`1<SyntaxAnnotation> annotations);
    public SyntaxTrivia WithoutAnnotations(string annotationKind);
    public SyntaxTrivia CopyAnnotationsTo(SyntaxTrivia trivia);
    public SyntaxTree get_SyntaxTree();
    public Location GetLocation();
    public IEnumerable`1<Diagnostic> GetDiagnostics();
    public bool IsEquivalentTo(SyntaxTrivia trivia);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class Microsoft.CodeAnalysis.SyntaxTriviaList : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private GreenNode <Node>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    private static ObjectPool`1<SyntaxTriviaListBuilder> s_builderPool;
    public static SyntaxTriviaList Empty { get; }
    internal SyntaxToken Token { get; }
    internal GreenNode Node { get; }
    internal int Position { get; }
    internal int Index { get; }
    public int Count { get; }
    public SyntaxTrivia Item { get; }
    public TextSpan FullSpan { get; }
    public TextSpan Span { get; }
    private SyntaxTrivia[] Nodes { get; }
    internal SyntaxTriviaList(SyntaxToken& token, GreenNode node, int position, int index);
    internal SyntaxTriviaList(SyntaxToken& token, GreenNode node);
    public SyntaxTriviaList(SyntaxTrivia trivia);
    public SyntaxTriviaList(SyntaxTrivia[] trivias);
    public SyntaxTriviaList(IEnumerable`1<SyntaxTrivia> trivias);
    private static SyntaxTriviaList();
    public static SyntaxTriviaList get_Empty();
    private static GreenNode CreateNode(SyntaxTrivia[] trivias);
    [CompilerGeneratedAttribute]
internal SyntaxToken get_Token();
    [CompilerGeneratedAttribute]
internal GreenNode get_Node();
    [CompilerGeneratedAttribute]
internal int get_Position();
    [CompilerGeneratedAttribute]
internal int get_Index();
    public sealed virtual int get_Count();
    public SyntaxTrivia ElementAt(int index);
    public sealed virtual SyntaxTrivia get_Item(int index);
    public TextSpan get_FullSpan();
    public TextSpan get_Span();
    public SyntaxTrivia First();
    public SyntaxTrivia Last();
    public bool Any();
    public Reversed Reverse();
    public Enumerator GetEnumerator();
    public int IndexOf(SyntaxTrivia triviaInList);
    internal int IndexOf(int rawKind);
    public SyntaxTriviaList Add(SyntaxTrivia trivia);
    public SyntaxTriviaList AddRange(IEnumerable`1<SyntaxTrivia> trivia);
    public SyntaxTriviaList Insert(int index, SyntaxTrivia trivia);
    private static SyntaxTriviaListBuilder GetBuilder();
    private static void ClearAndFreeBuilder(SyntaxTriviaListBuilder builder);
    public SyntaxTriviaList InsertRange(int index, IEnumerable`1<SyntaxTrivia> trivia);
    public SyntaxTriviaList RemoveAt(int index);
    public SyntaxTriviaList Remove(SyntaxTrivia triviaInList);
    public SyntaxTriviaList Replace(SyntaxTrivia triviaInList, SyntaxTrivia newTrivia);
    public SyntaxTriviaList ReplaceRange(SyntaxTrivia triviaInList, IEnumerable`1<SyntaxTrivia> newTrivia);
    private SyntaxTrivia[] get_Nodes();
    private sealed virtual override IEnumerator`1<SyntaxTrivia> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.SyntaxTrivia>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private GreenNode GetGreenNodeAt(int i);
    private static GreenNode GetGreenNodeAt(GreenNode node, int i);
    public sealed virtual bool Equals(SyntaxTriviaList other);
    public static bool op_Equality(SyntaxTriviaList left, SyntaxTriviaList right);
    public static bool op_Inequality(SyntaxTriviaList left, SyntaxTriviaList right);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal void CopyTo(int offset, SyntaxTrivia[] array, int arrayOffset, int count);
    public virtual string ToString();
    public string ToFullString();
    public static SyntaxTriviaList Create(SyntaxTrivia trivia);
}
public abstract class Microsoft.CodeAnalysis.SyntaxWalker : object {
    [CompilerGeneratedAttribute]
private SyntaxWalkerDepth <Depth>k__BackingField;
    protected SyntaxWalkerDepth Depth { get; }
    protected SyntaxWalker(SyntaxWalkerDepth depth);
    [CompilerGeneratedAttribute]
protected SyntaxWalkerDepth get_Depth();
    public virtual void Visit(SyntaxNode node);
    protected virtual void VisitToken(SyntaxToken token);
    private void VisitLeadingTrivia(SyntaxToken& token);
    private void VisitTrailingTrivia(SyntaxToken& token);
    protected virtual void VisitTrivia(SyntaxTrivia trivia);
}
public enum Microsoft.CodeAnalysis.SyntaxWalkerDepth : Enum {
    public int value__;
    public static SyntaxWalkerDepth Node;
    public static SyntaxWalkerDepth Token;
    public static SyntaxWalkerDepth Trivia;
    public static SyntaxWalkerDepth StructuredTrivia;
}
internal enum Microsoft.CodeAnalysis.SynthesizedLocalKind : Enum {
    public int value__;
    public static SynthesizedLocalKind FrameCache;
    public static SynthesizedLocalKind OptimizerTemp;
    public static SynthesizedLocalKind LoweringTemp;
    public static SynthesizedLocalKind EmitterTemp;
    public static SynthesizedLocalKind UserDefined;
    public static SynthesizedLocalKind ConditionalBranchDiscriminator;
    public static SynthesizedLocalKind LockTaken;
    public static SynthesizedLocalKind Lock;
    public static SynthesizedLocalKind Using;
    public static SynthesizedLocalKind ForEachEnumerator;
    public static SynthesizedLocalKind ForEachArray;
    public static SynthesizedLocalKind ForEachArrayLimit;
    public static SynthesizedLocalKind ForEachArrayIndex;
    public static SynthesizedLocalKind FixedReference;
    public static SynthesizedLocalKind With;
    public static SynthesizedLocalKind ForLimit;
    public static SynthesizedLocalKind ForStep;
    public static SynthesizedLocalKind ForInitialValue;
    public static SynthesizedLocalKind ForDirection;
    public static SynthesizedLocalKind SelectCaseValue;
    public static SynthesizedLocalKind OnErrorActiveHandler;
    public static SynthesizedLocalKind OnErrorResumeTarget;
    public static SynthesizedLocalKind OnErrorCurrentStatement;
    public static SynthesizedLocalKind OnErrorCurrentLine;
    public static SynthesizedLocalKind AsyncMethodReturnValue;
    public static SynthesizedLocalKind StateMachineReturnValue;
    public static SynthesizedLocalKind FunctionReturnValue;
    public static SynthesizedLocalKind TryAwaitPendingException;
    public static SynthesizedLocalKind TryAwaitPendingBranch;
    public static SynthesizedLocalKind TryAwaitPendingCatch;
    public static SynthesizedLocalKind TryAwaitPendingCaughtException;
    public static SynthesizedLocalKind ExceptionFilterAwaitHoistedExceptionLocal;
    public static SynthesizedLocalKind StateMachineCachedState;
    public static SynthesizedLocalKind AwaitSpill;
    public static SynthesizedLocalKind AwaitByRefSpill;
    public static SynthesizedLocalKind LambdaDisplayClass;
    public static SynthesizedLocalKind CachedAnonymousMethodDelegate;
    public static SynthesizedLocalKind XmlInExpressionLambda;
    public static SynthesizedLocalKind Awaiter;
    public static SynthesizedLocalKind InstrumentationPayload;
    public static SynthesizedLocalKind SwitchCasePatternMatching;
    public static SynthesizedLocalKind MaxValidValueForLocalVariableSerializedToDebugInformation;
    public static SynthesizedLocalKind AwaiterField;
    public static SynthesizedLocalKind DelegateRelaxationReceiver;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SynthesizedLocalKindExtensions : object {
    [ExtensionAttribute]
public static bool IsLongLived(SynthesizedLocalKind kind);
    [ExtensionAttribute]
public static bool MustSurviveStateMachineSuspension(SynthesizedLocalKind kind);
    [ExtensionAttribute]
public static bool IsSlotReusable(SynthesizedLocalKind kind, OptimizationLevel optimizations);
    [ExtensionAttribute]
public static bool IsSlotReusable(SynthesizedLocalKind kind, bool isDebug);
    [ExtensionAttribute]
public static LocalVariableAttributes PdbAttributes(SynthesizedLocalKind kind);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Text.ChangedText : SourceText {
    private SourceText _newText;
    private ChangeInfo _info;
    public Encoding Encoding { get; }
    public IEnumerable`1<TextChangeRange> Changes { get; }
    public int Length { get; }
    internal int StorageSize { get; }
    internal ImmutableArray`1<SourceText> Segments { get; }
    internal SourceText StorageKey { get; }
    public char Item { get; }
    public ChangedText(SourceText oldText, SourceText newText, ImmutableArray`1<TextChangeRange> changeRanges);
    public virtual Encoding get_Encoding();
    public IEnumerable`1<TextChangeRange> get_Changes();
    public virtual int get_Length();
    internal virtual int get_StorageSize();
    internal virtual ImmutableArray`1<SourceText> get_Segments();
    internal virtual SourceText get_StorageKey();
    public virtual char get_Item(int position);
    public virtual string ToString(TextSpan span);
    public virtual SourceText GetSubText(TextSpan span);
    public virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public virtual SourceText WithChanges(IEnumerable`1<TextChange> changes);
    public virtual IReadOnlyList`1<TextChangeRange> GetChangeRanges(SourceText oldText);
    private bool IsChangedFrom(SourceText oldText);
    private static IReadOnlyList`1<ImmutableArray`1<TextChangeRange>> GetChangesBetween(SourceText oldText, ChangedText newText);
    private static ImmutableArray`1<TextChangeRange> Merge(IReadOnlyList`1<ImmutableArray`1<TextChangeRange>> changeSets);
    private static ImmutableArray`1<TextChangeRange> Merge(ImmutableArray`1<TextChangeRange> oldChanges, ImmutableArray`1<TextChangeRange> newChanges);
    private static void AddRange(List`1<TextChangeRange> list, TextChangeRange range);
    protected virtual TextLineCollection GetLinesCore();
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Text.CompositeText : SourceText {
    private ImmutableArray`1<SourceText> _segments;
    private int _length;
    private int _storageSize;
    private Int32[] _segmentOffsets;
    private Encoding _encoding;
    internal static int TARGET_SEGMENT_COUNT_AFTER_REDUCTION;
    internal static int MAXIMUM_SEGMENT_COUNT_BEFORE_REDUCTION;
    private static int INITIAL_SEGMENT_SIZE_FOR_COMBINING;
    private static int MAXIMUM_SEGMENT_SIZE_FOR_COMBINING;
    private static ObjectPool`1<HashSet`1<SourceText>> s_uniqueSourcesPool;
    public Encoding Encoding { get; }
    public int Length { get; }
    internal int StorageSize { get; }
    internal ImmutableArray`1<SourceText> Segments { get; }
    public char Item { get; }
    private CompositeText(ImmutableArray`1<SourceText> segments, Encoding encoding, SourceHashAlgorithm checksumAlgorithm);
    private static CompositeText();
    public virtual Encoding get_Encoding();
    public virtual int get_Length();
    internal virtual int get_StorageSize();
    internal virtual ImmutableArray`1<SourceText> get_Segments();
    public virtual char get_Item(int position);
    public virtual SourceText GetSubText(TextSpan span);
    private void GetIndexAndOffset(int position, Int32& index, Int32& offset);
    private bool CheckCopyToArguments(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    internal static void AddSegments(ArrayBuilder`1<SourceText> segments, SourceText text);
    internal static SourceText ToSourceTextAndFree(ArrayBuilder`1<SourceText> segments, SourceText original, bool adjustSegments);
    private static void ReduceSegmentCountIfNecessary(ArrayBuilder`1<SourceText> segments);
    private static int GetMinimalSegmentSizeToUseForCombining(ArrayBuilder`1<SourceText> segments);
    private static int GetSegmentCountIfCombined(ArrayBuilder`1<SourceText> segments, int segmentSize);
    private static void CombineSegments(ArrayBuilder`1<SourceText> segments, int segmentSize);
    private static void ComputeLengthAndStorageSize(IReadOnlyList`1<SourceText> segments, Int32& length, Int32& size);
    private static void TrimInaccessibleText(ArrayBuilder`1<SourceText> segments);
}
internal static class Microsoft.CodeAnalysis.Text.EncodedStringText : object {
    private static int LargeObjectHeapLimitInChars;
    private static Encoding s_utf8Encoding;
    private static Lazy`1<Encoding> s_fallbackEncoding;
    private static EncodedStringText();
    private static Encoding GetFallbackEncoding();
    internal static SourceText Create(Stream stream, Encoding defaultEncoding, SourceHashAlgorithm checksumAlgorithm, bool canBeEmbedded);
    internal static SourceText Create(Stream stream, Lazy`1<Encoding> getEncoding, Encoding defaultEncoding, SourceHashAlgorithm checksumAlgorithm, bool canBeEmbedded);
    internal static SourceText Decode(Stream data, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected, bool canBeEmbedded);
    internal static bool TryGetBytesFromStream(Stream data, ArraySegment`1& bytes);
    private static bool TryGetBytesFromFileStream(FileStream stream, ArraySegment`1& bytes);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Text.LargeText : SourceText {
    internal static int ChunkSize;
    private ImmutableArray`1<Char[]> _chunks;
    private Int32[] _chunkStartOffsets;
    private int _length;
    private Encoding _encodingOpt;
    public char Item { get; }
    public Encoding Encoding { get; }
    public int Length { get; }
    internal LargeText(ImmutableArray`1<Char[]> chunks, Encoding encodingOpt, ImmutableArray`1<byte> checksum, SourceHashAlgorithm checksumAlgorithm, ImmutableArray`1<byte> embeddedTextBlob);
    internal LargeText(ImmutableArray`1<Char[]> chunks, Encoding encodingOpt, SourceHashAlgorithm checksumAlgorithm);
    internal static SourceText Decode(Stream stream, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected, bool canBeEmbedded);
    internal static SourceText Decode(TextReader reader, int length, Encoding encodingOpt, SourceHashAlgorithm checksumAlgorithm);
    private static ImmutableArray`1<Char[]> ReadChunksFromTextReader(TextReader reader, int maxCharRemainingGuess, bool throwIfBinaryDetected);
    private static bool IsBinary(Char[] chunk);
    private int GetIndexFromPosition(int position);
    public virtual char get_Item(int position);
    public virtual Encoding get_Encoding();
    public virtual int get_Length();
    public virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public virtual void Write(TextWriter writer, TextSpan span, CancellationToken cancellationToken);
    protected virtual TextLineCollection GetLinesCore();
    private Int32[] ParseLineStarts();
}
internal class Microsoft.CodeAnalysis.Text.LargeTextWriter : SourceTextWriter {
    private Encoding _encoding;
    private SourceHashAlgorithm _checksumAlgorithm;
    private ArrayBuilder`1<Char[]> _chunks;
    private int _bufferSize;
    private Char[] _buffer;
    private int _currentUsed;
    public Encoding Encoding { get; }
    public LargeTextWriter(Encoding encoding, SourceHashAlgorithm checksumAlgorithm, int length);
    public virtual SourceText ToSourceText();
    public virtual Encoding get_Encoding();
    public bool CanFitInAllocatedBuffer(int chars);
    public virtual void Write(char value);
    public virtual void Write(string value);
    public virtual void Write(Char[] chars, int index, int count);
    internal void AppendChunk(Char[] chunk);
    public virtual void Flush();
    private void EnsureBuffer();
}
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.Text.LinePosition : ValueType {
    private int _line;
    private int _character;
    public static LinePosition Zero { get; }
    public int Line { get; }
    public int Character { get; }
    public LinePosition(int line, int character);
    internal LinePosition(int character);
    public static LinePosition get_Zero();
    public int get_Line();
    public int get_Character();
    public static bool op_Equality(LinePosition left, LinePosition right);
    public static bool op_Inequality(LinePosition left, LinePosition right);
    public sealed virtual bool Equals(LinePosition other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(LinePosition other);
    public static bool op_GreaterThan(LinePosition left, LinePosition right);
    public static bool op_GreaterThanOrEqual(LinePosition left, LinePosition right);
    public static bool op_LessThan(LinePosition left, LinePosition right);
    public static bool op_LessThanOrEqual(LinePosition left, LinePosition right);
}
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.Text.LinePositionSpan : ValueType {
    private LinePosition _start;
    private LinePosition _end;
    public LinePosition Start { get; }
    public LinePosition End { get; }
    public LinePositionSpan(LinePosition start, LinePosition end);
    public LinePosition get_Start();
    public LinePosition get_End();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(LinePositionSpan other);
    public virtual int GetHashCode();
    public static bool op_Equality(LinePositionSpan left, LinePositionSpan right);
    public static bool op_Inequality(LinePositionSpan left, LinePositionSpan right);
    public virtual string ToString();
}
public enum Microsoft.CodeAnalysis.Text.SourceHashAlgorithm : Enum {
    public int value__;
    public static SourceHashAlgorithm None;
    public static SourceHashAlgorithm Sha1;
    public static SourceHashAlgorithm Sha256;
}
[DefaultMemberAttribute("Item")]
public abstract class Microsoft.CodeAnalysis.Text.SourceText : object {
    private static int CharBufferSize;
    private static int CharBufferCount;
    internal static int LargeObjectHeapLimitInChars;
    private static ObjectPool`1<Char[]> s_charArrayPool;
    private SourceHashAlgorithm _checksumAlgorithm;
    private SourceTextContainer _lazyContainer;
    private TextLineCollection _lazyLineInfo;
    private ImmutableArray`1<byte> _lazyChecksum;
    private ImmutableArray`1<byte> _precomputedEmbeddedTextBlob;
    private static Encoding s_utf8EncodingWithNoBOM;
    public SourceHashAlgorithm ChecksumAlgorithm { get; }
    public Encoding Encoding { get; }
    public int Length { get; }
    internal int StorageSize { get; }
    internal ImmutableArray`1<SourceText> Segments { get; }
    internal SourceText StorageKey { get; }
    public bool CanBeEmbedded { get; }
    internal ImmutableArray`1<byte> PrecomputedEmbeddedTextBlob { get; }
    public char Item { get; }
    public SourceTextContainer Container { get; }
    public TextLineCollection Lines { get; }
    protected SourceText(ImmutableArray`1<byte> checksum, SourceHashAlgorithm checksumAlgorithm, SourceTextContainer container);
    internal SourceText(ImmutableArray`1<byte> checksum, SourceHashAlgorithm checksumAlgorithm, ImmutableArray`1<byte> embeddedTextBlob);
    private static SourceText();
    internal static void ValidateChecksumAlgorithm(SourceHashAlgorithm checksumAlgorithm);
    public static SourceText From(string text, Encoding encoding, SourceHashAlgorithm checksumAlgorithm);
    public static SourceText From(TextReader reader, int length, Encoding encoding, SourceHashAlgorithm checksumAlgorithm);
    [EditorBrowsableAttribute("1")]
public static SourceText From(Stream stream, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected);
    public static SourceText From(Stream stream, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected, bool canBeEmbedded);
    [EditorBrowsableAttribute("1")]
public static SourceText From(Byte[] buffer, int length, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected);
    public static SourceText From(Byte[] buffer, int length, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected, bool canBeEmbedded);
    private static string Decode(Stream stream, Encoding encoding, Encoding& actualEncoding);
    private static string Decode(Byte[] buffer, int length, Encoding encoding, Encoding& actualEncoding);
    internal static bool IsBinary(string text);
    public SourceHashAlgorithm get_ChecksumAlgorithm();
    public abstract virtual Encoding get_Encoding();
    public abstract virtual int get_Length();
    internal virtual int get_StorageSize();
    internal virtual ImmutableArray`1<SourceText> get_Segments();
    internal virtual SourceText get_StorageKey();
    public bool get_CanBeEmbedded();
    internal ImmutableArray`1<byte> get_PrecomputedEmbeddedTextBlob();
    public abstract virtual char get_Item(int position);
    public abstract virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public virtual SourceTextContainer get_Container();
    internal void CheckSubSpan(TextSpan span);
    public virtual SourceText GetSubText(TextSpan span);
    public SourceText GetSubText(int start);
    public void Write(TextWriter textWriter, CancellationToken cancellationToken);
    public virtual void Write(TextWriter writer, TextSpan span, CancellationToken cancellationToken);
    public ImmutableArray`1<byte> GetChecksum();
    internal static ImmutableArray`1<byte> CalculateChecksum(Byte[] buffer, int offset, int count, SourceHashAlgorithm algorithmId);
    internal static ImmutableArray`1<byte> CalculateChecksum(Stream stream, SourceHashAlgorithm algorithmId);
    public virtual string ToString();
    public virtual string ToString(TextSpan span);
    public virtual SourceText WithChanges(IEnumerable`1<TextChange> changes);
    public SourceText WithChanges(TextChange[] changes);
    public SourceText Replace(TextSpan span, string newText);
    public SourceText Replace(int start, int length, string newText);
    public virtual IReadOnlyList`1<TextChangeRange> GetChangeRanges(SourceText oldText);
    public virtual IReadOnlyList`1<TextChange> GetTextChanges(SourceText oldText);
    public TextLineCollection get_Lines();
    internal bool TryGetLines(TextLineCollection& lines);
    protected virtual TextLineCollection GetLinesCore();
    private void EnumerateChars(Action`3<int, Char[], int> action);
    private Int32[] ParseLineStarts();
    public bool ContentEquals(SourceText other);
    protected virtual bool ContentEqualsImpl(SourceText other);
    internal static Encoding TryReadByteOrderMark(Byte[] source, int length, Int32& preambleLength);
}
internal class Microsoft.CodeAnalysis.Text.SourceTextComparer : object {
    public static SourceTextComparer Instance;
    private static SourceTextComparer();
    public sealed virtual bool Equals(SourceText x, SourceText y);
    public sealed virtual int GetHashCode(SourceText obj);
}
public abstract class Microsoft.CodeAnalysis.Text.SourceTextContainer : object {
    public SourceText CurrentText { get; }
    public abstract virtual SourceText get_CurrentText();
    [CompilerGeneratedAttribute]
public abstract virtual void add_TextChanged(EventHandler`1<TextChangeEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_TextChanged(EventHandler`1<TextChangeEventArgs> value);
}
internal class Microsoft.CodeAnalysis.Text.SourceTextStream : Stream {
    private SourceText _source;
    private Encoding _encoding;
    private Encoder _encoder;
    private int _minimumTargetBufferCount;
    private int _position;
    private int _sourceOffset;
    private Char[] _charBuffer;
    private int _bufferOffset;
    private int _bufferUnreadChars;
    private bool _preambleWritten;
    private static Encoding s_utf8EncodingWithNoBOM;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public SourceTextStream(SourceText source, int bufferSize, bool useDefaultEncodingIfNull);
    private static SourceTextStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    private int WritePreamble(Byte[] buffer, int offset, int count);
    private void FillBuffer();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal abstract class Microsoft.CodeAnalysis.Text.SourceTextWriter : TextWriter {
    public abstract virtual SourceText ToSourceText();
    public static SourceTextWriter Create(Encoding encoding, SourceHashAlgorithm checksumAlgorithm, int length);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Text.StringBuilderText : SourceText {
    private StringBuilder _builder;
    private Encoding _encodingOpt;
    public Encoding Encoding { get; }
    internal StringBuilder Builder { get; }
    public int Length { get; }
    public char Item { get; }
    public StringBuilderText(StringBuilder builder, Encoding encodingOpt, SourceHashAlgorithm checksumAlgorithm);
    public virtual Encoding get_Encoding();
    internal StringBuilder get_Builder();
    public virtual int get_Length();
    public virtual char get_Item(int position);
    public virtual string ToString(TextSpan span);
    public virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Text.StringText : SourceText {
    private string _source;
    private Encoding _encodingOpt;
    public Encoding Encoding { get; }
    public string Source { get; }
    public int Length { get; }
    public char Item { get; }
    internal StringText(string source, Encoding encodingOpt, ImmutableArray`1<byte> checksum, SourceHashAlgorithm checksumAlgorithm, ImmutableArray`1<byte> embeddedTextBlob);
    public virtual Encoding get_Encoding();
    public string get_Source();
    public virtual int get_Length();
    public virtual char get_Item(int position);
    public virtual string ToString(TextSpan span);
    public virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    public virtual void Write(TextWriter textWriter, TextSpan span, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Text.StringTextWriter : SourceTextWriter {
    private StringBuilder _builder;
    private Encoding _encoding;
    private SourceHashAlgorithm _checksumAlgorithm;
    public Encoding Encoding { get; }
    public StringTextWriter(Encoding encoding, SourceHashAlgorithm checksumAlgorithm, int capacity);
    public virtual Encoding get_Encoding();
    public virtual SourceText ToSourceText();
    public virtual void Write(char value);
    public virtual void Write(string value);
    public virtual void Write(Char[] buffer, int index, int count);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Text.SubText : SourceText {
    [CompilerGeneratedAttribute]
private SourceText <UnderlyingText>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <UnderlyingSpan>k__BackingField;
    public Encoding Encoding { get; }
    public SourceText UnderlyingText { get; }
    public TextSpan UnderlyingSpan { get; }
    public int Length { get; }
    internal int StorageSize { get; }
    internal SourceText StorageKey { get; }
    public char Item { get; }
    public SubText(SourceText text, TextSpan span);
    public virtual Encoding get_Encoding();
    [CompilerGeneratedAttribute]
public SourceText get_UnderlyingText();
    [CompilerGeneratedAttribute]
public TextSpan get_UnderlyingSpan();
    public virtual int get_Length();
    internal virtual int get_StorageSize();
    internal virtual SourceText get_StorageKey();
    public virtual char get_Item(int position);
    public virtual string ToString(TextSpan span);
    public virtual SourceText GetSubText(TextSpan span);
    public virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    private TextSpan GetCompositeSpan(int start, int length);
}
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.Text.TextChange : ValueType {
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewText>k__BackingField;
    public TextSpan Span { get; }
    public string NewText { get; }
    public static IReadOnlyList`1<TextChange> NoChanges { get; }
    public TextChange(TextSpan span, string newText);
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public string get_NewText();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TextChange other);
    public virtual int GetHashCode();
    public static bool op_Equality(TextChange left, TextChange right);
    public static bool op_Inequality(TextChange left, TextChange right);
    public static TextChangeRange op_Implicit(TextChange change);
    public static IReadOnlyList`1<TextChange> get_NoChanges();
}
public class Microsoft.CodeAnalysis.Text.TextChangeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private SourceText <OldText>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceText <NewText>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<TextChangeRange> <Changes>k__BackingField;
    public SourceText OldText { get; }
    public SourceText NewText { get; }
    public IReadOnlyList`1<TextChangeRange> Changes { get; }
    public TextChangeEventArgs(SourceText oldText, SourceText newText, IEnumerable`1<TextChangeRange> changes);
    public TextChangeEventArgs(SourceText oldText, SourceText newText, TextChangeRange[] changes);
    [CompilerGeneratedAttribute]
public SourceText get_OldText();
    [CompilerGeneratedAttribute]
public SourceText get_NewText();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<TextChangeRange> get_Changes();
}
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.Text.TextChangeRange : ValueType {
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NewLength>k__BackingField;
    public TextSpan Span { get; }
    public int NewLength { get; }
    public static IReadOnlyList`1<TextChangeRange> NoChanges { get; }
    public TextChangeRange(TextSpan span, int newLength);
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public int get_NewLength();
    public sealed virtual bool Equals(TextChangeRange other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TextChangeRange left, TextChangeRange right);
    public static bool op_Inequality(TextChangeRange left, TextChangeRange right);
    public static IReadOnlyList`1<TextChangeRange> get_NoChanges();
    public static TextChangeRange Collapse(IEnumerable`1<TextChangeRange> changes);
}
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.Text.TextLine : ValueType {
    private SourceText _text;
    private int _start;
    private int _endIncludingBreaks;
    public SourceText Text { get; }
    public int LineNumber { get; }
    public int Start { get; }
    public int End { get; }
    private int LineBreakLength { get; }
    public int EndIncludingLineBreak { get; }
    public TextSpan Span { get; }
    public TextSpan SpanIncludingLineBreak { get; }
    private TextLine(SourceText text, int start, int endIncludingBreaks);
    public static TextLine FromSpan(SourceText text, TextSpan span);
    public SourceText get_Text();
    public int get_LineNumber();
    public int get_Start();
    public int get_End();
    private int get_LineBreakLength();
    public int get_EndIncludingLineBreak();
    public TextSpan get_Span();
    public TextSpan get_SpanIncludingLineBreak();
    public virtual string ToString();
    public static bool op_Equality(TextLine left, TextLine right);
    public static bool op_Inequality(TextLine left, TextLine right);
    public sealed virtual bool Equals(TextLine other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[DefaultMemberAttribute("Item")]
public abstract class Microsoft.CodeAnalysis.Text.TextLineCollection : object {
    public int Count { get; }
    public TextLine Item { get; }
    public abstract virtual int get_Count();
    public abstract virtual TextLine get_Item(int index);
    public abstract virtual int IndexOf(int position);
    public virtual TextLine GetLineFromPosition(int position);
    public virtual LinePosition GetLinePosition(int position);
    public LinePositionSpan GetLinePositionSpan(TextSpan span);
    public int GetPosition(LinePosition position);
    public TextSpan GetTextSpan(LinePositionSpan span);
    public Enumerator GetEnumerator();
    private sealed virtual override IEnumerator`1<TextLine> System.Collections.Generic.IEnumerable<Microsoft.CodeAnalysis.Text.TextLine>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.Text.TextSpan : ValueType {
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Start { get; }
    public int End { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public TextSpan(int start, int length);
    [CompilerGeneratedAttribute]
public int get_Start();
    public int get_End();
    [CompilerGeneratedAttribute]
public int get_Length();
    public bool get_IsEmpty();
    public bool Contains(int position);
    public bool Contains(TextSpan span);
    public bool OverlapsWith(TextSpan span);
    public Nullable`1<TextSpan> Overlap(TextSpan span);
    public bool IntersectsWith(TextSpan span);
    public bool IntersectsWith(int position);
    public Nullable`1<TextSpan> Intersection(TextSpan span);
    public static TextSpan FromBounds(int start, int end);
    public static bool op_Equality(TextSpan left, TextSpan right);
    public static bool op_Inequality(TextSpan left, TextSpan right);
    public sealed virtual bool Equals(TextSpan other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual int CompareTo(TextSpan other);
}
internal static class Microsoft.CodeAnalysis.Text.TextUtilities : object {
    internal static int GetLengthOfLineBreak(SourceText text, int index);
    private static int GetLengthOfLineBreakSlow(SourceText text, int index, char c);
    public static void GetStartAndLengthOfLineBreakEndingAt(SourceText text, int index, Int32& startLinebreak, Int32& lengthLinebreak);
    internal static bool IsAnyLineBreakCharacter(char c);
}
internal enum Microsoft.CodeAnalysis.ThreeState : Enum {
    public byte value__;
    public static ThreeState Unknown;
    public static ThreeState False;
    public static ThreeState True;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ThreeStateHelpers : object {
    [ExtensionAttribute]
public static ThreeState ToThreeState(bool value);
    [ExtensionAttribute]
public static bool HasValue(ThreeState value);
    [ExtensionAttribute]
public static bool Value(ThreeState value);
}
internal class Microsoft.CodeAnalysis.TouchedFileLogger : object {
    private ConcurrentSet`1<string> _readFiles;
    private ConcurrentSet`1<string> _writtenFiles;
    public void AddRead(string path);
    public void AddWritten(string path);
    public void AddReadWritten(string path);
    public void WriteReadPaths(TextWriter s);
    public void WriteWrittenPaths(TextWriter s);
}
internal class Microsoft.CodeAnalysis.TreeDumper : object {
    private StringBuilder _sb;
    public static string DumpCompact(TreeDumperNode root);
    private void DoDumpCompact(TreeDumperNode node, string indent);
    public static string DumpXML(TreeDumperNode root, string indent);
    private void DoDumpXML(TreeDumperNode node, string indent, string relativeIndent);
    private static bool IsDefaultImmutableArray(object o);
    private static string DumperString(object o);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.TreeDumperNode : object {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TreeDumperNode> <Children>k__BackingField;
    public object Value { get; }
    public string Text { get; }
    public IEnumerable`1<TreeDumperNode> Children { get; }
    public TreeDumperNode Item { get; }
    public TreeDumperNode(string text, object value, IEnumerable`1<TreeDumperNode> children);
    public TreeDumperNode(string text);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public IEnumerable`1<TreeDumperNode> get_Children();
    public TreeDumperNode get_Item(string child);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.TreeDumperNode/<PreorderTraversal>d__13")]
public IEnumerable`1<KeyValuePair`2<TreeDumperNode, TreeDumperNode>> PreorderTraversal();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.TypeAttributesExtensions : object {
    [ExtensionAttribute]
public static bool IsInterface(TypeAttributes flags);
    [ExtensionAttribute]
public static bool IsWindowsRuntime(TypeAttributes flags);
    [ExtensionAttribute]
public static bool IsPublic(TypeAttributes flags);
    [ExtensionAttribute]
public static bool IsSpecialName(TypeAttributes flags);
    [ExtensionAttribute]
internal static CharSet ToCharSet(TypeAttributes flags);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.TypeCompareKind : Enum {
    public int value__;
    public static TypeCompareKind ConsiderEverything;
    public static TypeCompareKind IgnoreCustomModifiersAndArraySizesAndLowerBounds;
    public static TypeCompareKind IgnoreDynamic;
    public static TypeCompareKind IgnoreTupleNames;
    public static TypeCompareKind IgnoreDynamicAndTupleNames;
    public static TypeCompareKind AllIgnoreOptions;
    public static TypeCompareKind AllIgnoreOptionsForVB;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.TypeCompareKindExtension : object {
    [ExtensionAttribute]
public static TypeCompareKind AddIgnoreCustomModifiersAndArraySizesAndLowerBounds(TypeCompareKind self, bool condition);
    [ExtensionAttribute]
public static TypeCompareKind AddIgnoreDynamic(TypeCompareKind self, bool condition);
    [ExtensionAttribute]
public static TypeCompareKind AddIgnoreTupleNames(TypeCompareKind self, bool condition);
}
public class Microsoft.CodeAnalysis.TypedConstant : ValueType {
    private TypedConstantKind _kind;
    private ITypeSymbol _type;
    private object _value;
    public TypedConstantKind Kind { get; }
    public ITypeSymbol Type { get; }
    public bool IsNull { get; }
    public object Value { get; }
    public ImmutableArray`1<TypedConstant> Values { get; }
    internal TypedConstant(ITypeSymbol type, TypedConstantKind kind, object value);
    internal TypedConstant(ITypeSymbol type, ImmutableArray`1<TypedConstant> array);
    public TypedConstantKind get_Kind();
    public ITypeSymbol get_Type();
    public bool get_IsNull();
    public object get_Value();
    public ImmutableArray`1<TypedConstant> get_Values();
    internal T DecodeValue(SpecialType specialType);
    internal static TypedConstantKind GetTypedConstantKind(ITypeSymbol type, Compilation compilation);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TypedConstant other);
    public virtual int GetHashCode();
}
public enum Microsoft.CodeAnalysis.TypedConstantKind : Enum {
    public int value__;
    public static TypedConstantKind Error;
    public static TypedConstantKind Primitive;
    public static TypedConstantKind Enum;
    public static TypedConstantKind Type;
    public static TypedConstantKind Array;
}
internal class Microsoft.CodeAnalysis.TypedConstantValue : ValueType {
    private object _value;
    public bool IsNull { get; }
    public ImmutableArray`1<TypedConstant> Array { get; }
    public object Object { get; }
    internal TypedConstantValue(object value);
    internal TypedConstantValue(ImmutableArray`1<TypedConstant> array);
    public bool get_IsNull();
    public ImmutableArray`1<TypedConstant> get_Array();
    public object get_Object();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TypedConstantValue other);
}
public class Microsoft.CodeAnalysis.TypeInfo : ValueType {
    internal static TypeInfo None;
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <ConvertedType>k__BackingField;
    public ITypeSymbol Type { get; }
    public ITypeSymbol ConvertedType { get; }
    internal TypeInfo(ITypeSymbol type, ITypeSymbol convertedType);
    private static TypeInfo();
    [CompilerGeneratedAttribute]
public ITypeSymbol get_Type();
    [CompilerGeneratedAttribute]
public ITypeSymbol get_ConvertedType();
    public sealed virtual bool Equals(TypeInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum Microsoft.CodeAnalysis.TypeKind : Enum {
    public byte value__;
    public static TypeKind Unknown;
    public static TypeKind Array;
    public static TypeKind Class;
    public static TypeKind Delegate;
    public static TypeKind Dynamic;
    public static TypeKind Enum;
    public static TypeKind Error;
    public static TypeKind Interface;
    public static TypeKind Module;
    public static TypeKind Pointer;
    public static TypeKind Struct;
    public static TypeKind Structure;
    public static TypeKind TypeParameter;
    public static TypeKind Submission;
}
internal class Microsoft.CodeAnalysis.TypeLayout : ValueType {
    private byte _kind;
    private short _alignment;
    private int _size;
    public LayoutKind Kind { get; }
    public short Alignment { get; }
    public int Size { get; }
    public TypeLayout(LayoutKind kind, int size, byte alignment);
    public LayoutKind get_Kind();
    public short get_Alignment();
    public int get_Size();
    public sealed virtual bool Equals(TypeLayout other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal abstract class Microsoft.CodeAnalysis.TypeNameDecoder`2 : object {
    private SymbolFactory`2<ModuleSymbol, TypeSymbol> _factory;
    protected ModuleSymbol moduleSymbol;
    protected TypeSymbol SystemTypeSymbol { get; }
    internal TypeNameDecoder`2(SymbolFactory`2<ModuleSymbol, TypeSymbol> factory, ModuleSymbol moduleSymbol);
    protected abstract virtual bool IsContainingAssembly(AssemblyIdentity identity);
    protected abstract virtual TypeSymbol LookupTopLevelTypeDefSymbol(MetadataTypeName& emittedName, Boolean& isNoPiaLocalType);
    protected abstract virtual TypeSymbol LookupTopLevelTypeDefSymbol(int referencedAssemblyIndex, MetadataTypeName& emittedName);
    protected abstract virtual TypeSymbol LookupNestedTypeDefSymbol(TypeSymbol container, MetadataTypeName& emittedName);
    protected abstract virtual int GetIndexOfReferencedAssembly(AssemblyIdentity identity);
    internal TypeSymbol GetTypeSymbolForSerializedType(string s);
    protected TypeSymbol GetUnsupportedMetadataTypeSymbol(BadImageFormatException exception);
    protected TypeSymbol GetSZArrayTypeSymbol(TypeSymbol elementType, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers);
    protected TypeSymbol GetMDArrayTypeSymbol(int rank, TypeSymbol elementType, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers, ImmutableArray`1<int> sizes, ImmutableArray`1<int> lowerBounds);
    protected TypeSymbol MakePointerTypeSymbol(TypeSymbol type, ImmutableArray`1<ModifierInfo`1<TypeSymbol>> customModifiers);
    protected TypeSymbol GetSpecialType(SpecialType specialType);
    protected TypeSymbol get_SystemTypeSymbol();
    protected TypeSymbol GetEnumUnderlyingType(TypeSymbol type);
    protected bool IsAcceptedVolatileModifierType(TypeSymbol type);
    protected bool IsAcceptedInAttributeModifierType(TypeSymbol type);
    protected bool IsAcceptedUnmanagedTypeModifierType(TypeSymbol type);
    protected PrimitiveTypeCode GetPrimitiveTypeCode(TypeSymbol type);
    protected TypeSymbol SubstituteWithUnboundIfGeneric(TypeSymbol type);
    protected TypeSymbol SubstituteTypeParameters(TypeSymbol genericType, ImmutableArray`1<KeyValuePair`2<TypeSymbol, ImmutableArray`1<ModifierInfo`1<TypeSymbol>>>> arguments, ImmutableArray`1<bool> refersToNoPiaLocalType);
    internal TypeSymbol GetTypeSymbol(AssemblyQualifiedTypeName fullName, Boolean& refersToNoPiaLocalType);
    private ImmutableArray`1<KeyValuePair`2<TypeSymbol, ImmutableArray`1<ModifierInfo`1<TypeSymbol>>>> ResolveTypeArguments(AssemblyQualifiedTypeName[] arguments, ImmutableArray`1& refersToNoPiaLocalType);
    private TypeSymbol LookupTopLevelTypeDefSymbol(MetadataTypeName& emittedName, int referencedAssemblyIndex, Boolean& isNoPiaLocalType);
}
public enum Microsoft.CodeAnalysis.TypeParameterKind : Enum {
    public int value__;
    public static TypeParameterKind Type;
    public static TypeParameterKind Method;
    public static TypeParameterKind Cref;
}
internal class Microsoft.CodeAnalysis.UnifiedAssembly`1 : ValueType {
    internal AssemblyIdentity OriginalReference;
    internal TAssemblySymbol TargetAssembly;
    public UnifiedAssembly`1(TAssemblySymbol targetAssembly, AssemblyIdentity originalReference);
}
internal class Microsoft.CodeAnalysis.UnionCollection`1 : object {
    private ImmutableArray`1<ICollection`1<T>> _collections;
    private int _count;
    public int Count { get; }
    public bool IsReadOnly { get; }
    private UnionCollection`1(ImmutableArray`1<ICollection`1<T>> collections);
    public static ICollection`1<T> Create(ICollection`1<T> coll1, ICollection`1<T> coll2);
    public static ICollection`1<T> Create(ImmutableArray`1<TOrig> collections, Func`2<TOrig, ICollection`1<T>> selector);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Microsoft.CodeAnalysis.UnresolvedMetadataReference : MetadataReference {
    [CompilerGeneratedAttribute]
private string <Reference>k__BackingField;
    public string Reference { get; }
    public string Display { get; }
    internal bool IsUnresolved { get; }
    internal UnresolvedMetadataReference(string reference, MetadataReferenceProperties properties);
    [CompilerGeneratedAttribute]
public string get_Reference();
    public virtual string get_Display();
    internal virtual bool get_IsUnresolved();
    internal virtual MetadataReference WithPropertiesImplReturningMetadataReference(MetadataReferenceProperties properties);
}
internal class Microsoft.CodeAnalysis.UnsupportedSignatureContent : Exception {
}
public enum Microsoft.CodeAnalysis.VarianceKind : Enum {
    public short value__;
    public static VarianceKind None;
    public static VarianceKind Out;
    public static VarianceKind In;
}
internal static class Microsoft.CodeAnalysis.VersionHelper : object {
    internal static bool TryParse(string s, Version& version);
    internal static bool TryParseAssemblyVersion(string s, bool allowWildcard, Version& version);
    private static bool TryParse(string s, bool allowWildcard, ushort maxValue, bool allowPartialParse, Version& version);
    private static bool TryGetValue(string s, UInt16& value);
    public static Version GenerateVersionFromPatternAndCurrentTime(DateTime time, Version pattern);
}
internal abstract class Microsoft.CodeAnalysis.WellKnownAttributeData : object {
    public static string StringMissingValue;
    private static WellKnownAttributeData();
    [ConditionalAttribute("DEBUG")]
protected void VerifySealed(bool expected);
    [ConditionalAttribute("DEBUG")]
internal void VerifyDataStored(bool expected);
    [ConditionalAttribute("DEBUG")]
protected void SetDataStored();
    [ConditionalAttribute("DEBUG")]
internal static void Seal(WellKnownAttributeData data);
}
public static class Microsoft.CodeAnalysis.WellKnownDiagnosticTags : object {
    public static string Unnecessary;
    public static string EditAndContinue;
    public static string Build;
    public static string Compiler;
    public static string Telemetry;
    public static string NotConfigurable;
    public static string AnalyzerException;
}
internal enum Microsoft.CodeAnalysis.WellKnownMember : Enum {
    public int value__;
    public static WellKnownMember System_Math__RoundDouble;
    public static WellKnownMember System_Math__PowDoubleDouble;
    public static WellKnownMember System_Array__get_Length;
    public static WellKnownMember System_Array__Empty;
    public static WellKnownMember System_Convert__ToBooleanDecimal;
    public static WellKnownMember System_Convert__ToBooleanInt32;
    public static WellKnownMember System_Convert__ToBooleanUInt32;
    public static WellKnownMember System_Convert__ToBooleanInt64;
    public static WellKnownMember System_Convert__ToBooleanUInt64;
    public static WellKnownMember System_Convert__ToBooleanSingle;
    public static WellKnownMember System_Convert__ToBooleanDouble;
    public static WellKnownMember System_Convert__ToSByteDecimal;
    public static WellKnownMember System_Convert__ToSByteDouble;
    public static WellKnownMember System_Convert__ToSByteSingle;
    public static WellKnownMember System_Convert__ToByteDecimal;
    public static WellKnownMember System_Convert__ToByteDouble;
    public static WellKnownMember System_Convert__ToByteSingle;
    public static WellKnownMember System_Convert__ToInt16Decimal;
    public static WellKnownMember System_Convert__ToInt16Double;
    public static WellKnownMember System_Convert__ToInt16Single;
    public static WellKnownMember System_Convert__ToUInt16Decimal;
    public static WellKnownMember System_Convert__ToUInt16Double;
    public static WellKnownMember System_Convert__ToUInt16Single;
    public static WellKnownMember System_Convert__ToInt32Decimal;
    public static WellKnownMember System_Convert__ToInt32Double;
    public static WellKnownMember System_Convert__ToInt32Single;
    public static WellKnownMember System_Convert__ToUInt32Decimal;
    public static WellKnownMember System_Convert__ToUInt32Double;
    public static WellKnownMember System_Convert__ToUInt32Single;
    public static WellKnownMember System_Convert__ToInt64Decimal;
    public static WellKnownMember System_Convert__ToInt64Double;
    public static WellKnownMember System_Convert__ToInt64Single;
    public static WellKnownMember System_Convert__ToUInt64Decimal;
    public static WellKnownMember System_Convert__ToUInt64Double;
    public static WellKnownMember System_Convert__ToUInt64Single;
    public static WellKnownMember System_Convert__ToSingleDecimal;
    public static WellKnownMember System_Convert__ToDoubleDecimal;
    public static WellKnownMember System_CLSCompliantAttribute__ctor;
    public static WellKnownMember System_FlagsAttribute__ctor;
    public static WellKnownMember System_Guid__ctor;
    public static WellKnownMember System_Type__GetTypeFromCLSID;
    public static WellKnownMember System_Type__GetTypeFromHandle;
    public static WellKnownMember System_Type__Missing;
    public static WellKnownMember System_Reflection_AssemblyKeyFileAttribute__ctor;
    public static WellKnownMember System_Reflection_AssemblyKeyNameAttribute__ctor;
    public static WellKnownMember System_Reflection_MethodBase__GetMethodFromHandle;
    public static WellKnownMember System_Reflection_MethodBase__GetMethodFromHandle2;
    public static WellKnownMember System_Reflection_MethodInfo__CreateDelegate;
    public static WellKnownMember System_Delegate__CreateDelegate;
    public static WellKnownMember System_Delegate__CreateDelegate4;
    public static WellKnownMember System_Reflection_FieldInfo__GetFieldFromHandle;
    public static WellKnownMember System_Reflection_FieldInfo__GetFieldFromHandle2;
    public static WellKnownMember System_Reflection_Missing__Value;
    public static WellKnownMember System_IEquatable_T__Equals;
    public static WellKnownMember System_Collections_Generic_EqualityComparer_T__Equals;
    public static WellKnownMember System_Collections_Generic_EqualityComparer_T__GetHashCode;
    public static WellKnownMember System_Collections_Generic_EqualityComparer_T__get_Default;
    public static WellKnownMember System_AttributeUsageAttribute__ctor;
    public static WellKnownMember System_AttributeUsageAttribute__AllowMultiple;
    public static WellKnownMember System_AttributeUsageAttribute__Inherited;
    public static WellKnownMember System_ParamArrayAttribute__ctor;
    public static WellKnownMember System_STAThreadAttribute__ctor;
    public static WellKnownMember System_Reflection_DefaultMemberAttribute__ctor;
    public static WellKnownMember System_Diagnostics_Debugger__Break;
    public static WellKnownMember System_Diagnostics_DebuggerDisplayAttribute__ctor;
    public static WellKnownMember System_Diagnostics_DebuggerDisplayAttribute__Type;
    public static WellKnownMember System_Diagnostics_DebuggerNonUserCodeAttribute__ctor;
    public static WellKnownMember System_Diagnostics_DebuggerHiddenAttribute__ctor;
    public static WellKnownMember System_Diagnostics_DebuggerBrowsableAttribute__ctor;
    public static WellKnownMember System_Diagnostics_DebuggerStepThroughAttribute__ctor;
    public static WellKnownMember System_Diagnostics_DebuggableAttribute__ctorDebuggingModes;
    public static WellKnownMember System_Diagnostics_DebuggableAttribute_DebuggingModes__Default;
    public static WellKnownMember System_Diagnostics_DebuggableAttribute_DebuggingModes__DisableOptimizations;
    public static WellKnownMember System_Diagnostics_DebuggableAttribute_DebuggingModes__EnableEditAndContinue;
    public static WellKnownMember System_Diagnostics_DebuggableAttribute_DebuggingModes__IgnoreSymbolStoreSequencePoints;
    public static WellKnownMember System_Runtime_InteropServices_UnknownWrapper__ctor;
    public static WellKnownMember System_Runtime_InteropServices_DispatchWrapper__ctor;
    public static WellKnownMember System_Runtime_InteropServices_ClassInterfaceAttribute__ctorClassInterfaceType;
    public static WellKnownMember System_Runtime_InteropServices_CoClassAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_ComAwareEventInfo__ctor;
    public static WellKnownMember System_Runtime_InteropServices_ComAwareEventInfo__AddEventHandler;
    public static WellKnownMember System_Runtime_InteropServices_ComAwareEventInfo__RemoveEventHandler;
    public static WellKnownMember System_Runtime_InteropServices_ComEventInterfaceAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_ComSourceInterfacesAttribute__ctorString;
    public static WellKnownMember System_Runtime_InteropServices_ComVisibleAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_DispIdAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_GuidAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_InterfaceTypeAttribute__ctorComInterfaceType;
    public static WellKnownMember System_Runtime_InteropServices_InterfaceTypeAttribute__ctorInt16;
    public static WellKnownMember System_Runtime_InteropServices_Marshal__GetTypeFromCLSID;
    public static WellKnownMember System_Runtime_InteropServices_TypeIdentifierAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_TypeIdentifierAttribute__ctorStringString;
    public static WellKnownMember System_Runtime_InteropServices_BestFitMappingAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_DefaultParameterValueAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_LCIDConversionAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_UnmanagedFunctionPointerAttribute__ctor;
    public static WellKnownMember System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T__AddEventHandler;
    public static WellKnownMember System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T__GetOrCreateEventRegistrationTokenTable;
    public static WellKnownMember System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T__InvocationList;
    public static WellKnownMember System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T__RemoveEventHandler;
    public static WellKnownMember System_Runtime_InteropServices_WindowsRuntime_WindowsRuntimeMarshal__AddEventHandler_T;
    public static WellKnownMember System_Runtime_InteropServices_WindowsRuntime_WindowsRuntimeMarshal__RemoveAllEventHandlers;
    public static WellKnownMember System_Runtime_InteropServices_WindowsRuntime_WindowsRuntimeMarshal__RemoveEventHandler_T;
    public static WellKnownMember System_Runtime_CompilerServices_DateTimeConstantAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_DecimalConstantAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_DecimalConstantAttribute__ctorByteByteInt32Int32Int32;
    public static WellKnownMember System_Runtime_CompilerServices_ExtensionAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_CompilerGeneratedAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_AccessedThroughPropertyAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_CompilationRelaxationsAttribute__ctorInt32;
    public static WellKnownMember System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_RuntimeCompatibilityAttribute__WrapNonExceptionThrows;
    public static WellKnownMember System_Runtime_CompilerServices_UnsafeValueTypeAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_FixedBufferAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_DynamicAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_DynamicAttribute__ctorTransformFlags;
    public static WellKnownMember System_Runtime_CompilerServices_CallSite_T__Create;
    public static WellKnownMember System_Runtime_CompilerServices_CallSite_T__Target;
    public static WellKnownMember System_Runtime_CompilerServices_RuntimeHelpers__GetObjectValueObject;
    public static WellKnownMember System_Runtime_CompilerServices_RuntimeHelpers__InitializeArrayArrayRuntimeFieldHandle;
    public static WellKnownMember System_Runtime_CompilerServices_RuntimeHelpers__get_OffsetToStringData;
    public static WellKnownMember System_Runtime_ExceptionServices_ExceptionDispatchInfo__Capture;
    public static WellKnownMember System_Runtime_ExceptionServices_ExceptionDispatchInfo__Throw;
    public static WellKnownMember System_Security_UnverifiableCodeAttribute__ctor;
    public static WellKnownMember System_Security_Permissions_SecurityAction__RequestMinimum;
    public static WellKnownMember System_Security_Permissions_SecurityPermissionAttribute__ctor;
    public static WellKnownMember System_Security_Permissions_SecurityPermissionAttribute__SkipVerification;
    public static WellKnownMember System_Activator__CreateInstance;
    public static WellKnownMember System_Activator__CreateInstance_T;
    public static WellKnownMember System_Threading_Interlocked__CompareExchange_T;
    public static WellKnownMember System_Threading_Monitor__Enter;
    public static WellKnownMember System_Threading_Monitor__Enter2;
    public static WellKnownMember System_Threading_Monitor__Exit;
    public static WellKnownMember System_Threading_Thread__CurrentThread;
    public static WellKnownMember System_Threading_Thread__ManagedThreadId;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__BinaryOperation;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__Convert;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__GetIndex;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__GetMember;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__Invoke;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__InvokeConstructor;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__InvokeMember;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__IsEvent;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__SetIndex;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__SetMember;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_Binder__UnaryOperation;
    public static WellKnownMember Microsoft_CSharp_RuntimeBinder_CSharpArgumentInfo__Create;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToDecimalBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToBooleanString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToSByteString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToByteString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToShortString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToUShortString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToIntegerString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToUIntegerString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToLongString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToULongString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToSingleString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToDoubleString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToDecimalString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToDateString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToCharString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToCharArrayRankOneString;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringInt32;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringByte;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringUInt32;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringInt64;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringUInt64;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringSingle;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringDouble;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringDecimal;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringDateTime;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringChar;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToStringObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToBooleanObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToSByteObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToByteObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToShortObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToUShortObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToIntegerObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToUIntegerObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToLongObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToULongObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToSingleObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToDoubleObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToDecimalObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToDateObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToCharObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToCharArrayRankOneObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ToGenericParameter_T_Object;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Conversions__ChangeType;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__PlusObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__NegateObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__NotObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__AndObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__OrObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__XorObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__AddObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__SubtractObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__MultiplyObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__DivideObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ExponentObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ModObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__IntDivideObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__LeftShiftObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__RightShiftObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ConcatenateObjectObjectObject;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__CompareObjectEqualObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__CompareObjectNotEqualObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__CompareObjectLessObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__CompareObjectLessEqualObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__CompareObjectGreaterEqualObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__CompareObjectGreaterObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ConditionalCompareObjectEqualObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ConditionalCompareObjectNotEqualObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ConditionalCompareObjectLessObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ConditionalCompareObjectLessEqualObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ConditionalCompareObjectGreaterEqualObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__ConditionalCompareObjectGreaterObjectObjectBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Operators__CompareStringStringStringBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_EmbeddedOperators__CompareStringStringStringBoolean;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_NewLateBinding__LateCall;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_NewLateBinding__LateGet;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_NewLateBinding__LateSet;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_NewLateBinding__LateSetComplex;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_NewLateBinding__LateIndexGet;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_NewLateBinding__LateIndexSet;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_NewLateBinding__LateIndexSetComplex;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_StandardModuleAttribute__ctor;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_StaticLocalInitFlag__ctor;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_StaticLocalInitFlag__State;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_StringType__MidStmtStr;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_IncompleteInitialization__ctor;
    public static WellKnownMember Microsoft_VisualBasic_Embedded__ctor;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Utils__CopyArray;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_LikeOperator__LikeStringStringStringCompareMethod;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_LikeOperator__LikeObjectObjectObjectCompareMethod;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_ProjectData__CreateProjectError;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_ProjectData__SetProjectError;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_ProjectData__SetProjectError_Int32;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_ProjectData__ClearProjectError;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_ProjectData__EndApp;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_ObjectFlowControl_ForLoopControl__ForLoopInitObj;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_ObjectFlowControl_ForLoopControl__ForNextCheckObj;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_ObjectFlowControl__CheckForSyncLockOnValueType;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Versioned__CallByName;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Versioned__IsNumeric;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Versioned__SystemTypeName;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Versioned__TypeName;
    public static WellKnownMember Microsoft_VisualBasic_CompilerServices_Versioned__VbTypeName;
    public static WellKnownMember Microsoft_VisualBasic_Information__IsNumeric;
    public static WellKnownMember Microsoft_VisualBasic_Information__SystemTypeName;
    public static WellKnownMember Microsoft_VisualBasic_Information__TypeName;
    public static WellKnownMember Microsoft_VisualBasic_Information__VbTypeName;
    public static WellKnownMember Microsoft_VisualBasic_Interaction__CallByName;
    public static WellKnownMember System_Runtime_CompilerServices_IAsyncStateMachine_MoveNext;
    public static WellKnownMember System_Runtime_CompilerServices_IAsyncStateMachine_SetStateMachine;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncVoidMethodBuilder__Create;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncVoidMethodBuilder__SetException;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncVoidMethodBuilder__SetResult;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncVoidMethodBuilder__AwaitOnCompleted;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncVoidMethodBuilder__AwaitUnsafeOnCompleted;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncVoidMethodBuilder__Start_T;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncVoidMethodBuilder__SetStateMachine;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder__Create;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder__SetException;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder__SetResult;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder__AwaitOnCompleted;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder__AwaitUnsafeOnCompleted;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder__Start_T;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder__SetStateMachine;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder__Task;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__Create;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__SetException;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__SetResult;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__AwaitOnCompleted;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__AwaitUnsafeOnCompleted;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__Start_T;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__SetStateMachine;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T__Task;
    public static WellKnownMember System_Runtime_CompilerServices_AsyncStateMachineAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_IteratorStateMachineAttribute__ctor;
    public static WellKnownMember Microsoft_VisualBasic_Strings__AscCharInt32;
    public static WellKnownMember Microsoft_VisualBasic_Strings__AscStringInt32;
    public static WellKnownMember Microsoft_VisualBasic_Strings__AscWCharInt32;
    public static WellKnownMember Microsoft_VisualBasic_Strings__AscWStringInt32;
    public static WellKnownMember Microsoft_VisualBasic_Strings__ChrInt32Char;
    public static WellKnownMember Microsoft_VisualBasic_Strings__ChrWInt32Char;
    public static WellKnownMember System_Xml_Linq_XElement__ctor;
    public static WellKnownMember System_Xml_Linq_XElement__ctor2;
    public static WellKnownMember System_Xml_Linq_XNamespace__Get;
    public static WellKnownMember System_Windows_Forms_Application__RunForm;
    public static WellKnownMember System_Environment__CurrentManagedThreadId;
    public static WellKnownMember System_ComponentModel_EditorBrowsableAttribute__ctor;
    public static WellKnownMember System_Runtime_GCLatencyMode__SustainedLowLatency;
    public static WellKnownMember System_ValueTuple_T1__Item1;
    public static WellKnownMember System_ValueTuple_T2__Item1;
    public static WellKnownMember System_ValueTuple_T2__Item2;
    public static WellKnownMember System_ValueTuple_T3__Item1;
    public static WellKnownMember System_ValueTuple_T3__Item2;
    public static WellKnownMember System_ValueTuple_T3__Item3;
    public static WellKnownMember System_ValueTuple_T4__Item1;
    public static WellKnownMember System_ValueTuple_T4__Item2;
    public static WellKnownMember System_ValueTuple_T4__Item3;
    public static WellKnownMember System_ValueTuple_T4__Item4;
    public static WellKnownMember System_ValueTuple_T5__Item1;
    public static WellKnownMember System_ValueTuple_T5__Item2;
    public static WellKnownMember System_ValueTuple_T5__Item3;
    public static WellKnownMember System_ValueTuple_T5__Item4;
    public static WellKnownMember System_ValueTuple_T5__Item5;
    public static WellKnownMember System_ValueTuple_T6__Item1;
    public static WellKnownMember System_ValueTuple_T6__Item2;
    public static WellKnownMember System_ValueTuple_T6__Item3;
    public static WellKnownMember System_ValueTuple_T6__Item4;
    public static WellKnownMember System_ValueTuple_T6__Item5;
    public static WellKnownMember System_ValueTuple_T6__Item6;
    public static WellKnownMember System_ValueTuple_T7__Item1;
    public static WellKnownMember System_ValueTuple_T7__Item2;
    public static WellKnownMember System_ValueTuple_T7__Item3;
    public static WellKnownMember System_ValueTuple_T7__Item4;
    public static WellKnownMember System_ValueTuple_T7__Item5;
    public static WellKnownMember System_ValueTuple_T7__Item6;
    public static WellKnownMember System_ValueTuple_T7__Item7;
    public static WellKnownMember System_ValueTuple_TRest__Item1;
    public static WellKnownMember System_ValueTuple_TRest__Item2;
    public static WellKnownMember System_ValueTuple_TRest__Item3;
    public static WellKnownMember System_ValueTuple_TRest__Item4;
    public static WellKnownMember System_ValueTuple_TRest__Item5;
    public static WellKnownMember System_ValueTuple_TRest__Item6;
    public static WellKnownMember System_ValueTuple_TRest__Item7;
    public static WellKnownMember System_ValueTuple_TRest__Rest;
    public static WellKnownMember System_ValueTuple_T1__ctor;
    public static WellKnownMember System_ValueTuple_T2__ctor;
    public static WellKnownMember System_ValueTuple_T3__ctor;
    public static WellKnownMember System_ValueTuple_T4__ctor;
    public static WellKnownMember System_ValueTuple_T5__ctor;
    public static WellKnownMember System_ValueTuple_T6__ctor;
    public static WellKnownMember System_ValueTuple_T7__ctor;
    public static WellKnownMember System_ValueTuple_TRest__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_TupleElementNamesAttribute__ctorTransformNames;
    public static WellKnownMember System_String__Format_IFormatProvider;
    public static WellKnownMember Microsoft_CodeAnalysis_Runtime_Instrumentation__CreatePayloadForMethodsSpanningSingleFile;
    public static WellKnownMember Microsoft_CodeAnalysis_Runtime_Instrumentation__CreatePayloadForMethodsSpanningMultipleFiles;
    public static WellKnownMember System_Runtime_CompilerServices_ReferenceAssemblyAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_IsReadOnlyAttribute__ctor;
    public static WellKnownMember System_Runtime_CompilerServices_IsByRefLikeAttribute__ctor;
    public static WellKnownMember System_ObsoleteAttribute__ctor;
    public static WellKnownMember System_Span_T__ctor;
    public static WellKnownMember System_Span_T__get_Item;
    public static WellKnownMember System_Span_T__get_Length;
    public static WellKnownMember System_ReadOnlySpan_T__ctor;
    public static WellKnownMember System_ReadOnlySpan_T__get_Item;
    public static WellKnownMember System_ReadOnlySpan_T__get_Length;
    public static WellKnownMember System_Runtime_CompilerServices_IsUnmanagedAttribute__ctor;
    public static WellKnownMember Microsoft_VisualBasic_Conversion__FixSingle;
    public static WellKnownMember Microsoft_VisualBasic_Conversion__FixDouble;
    public static WellKnownMember Microsoft_VisualBasic_Conversion__IntSingle;
    public static WellKnownMember Microsoft_VisualBasic_Conversion__IntDouble;
    public static WellKnownMember System_Math__CeilingDouble;
    public static WellKnownMember System_Math__FloorDouble;
    public static WellKnownMember System_Math__TruncateDouble;
    public static WellKnownMember Count;
}
public static class Microsoft.CodeAnalysis.WellKnownMemberNames : object {
    public static string EnumBackingFieldName;
    public static string InstanceConstructorName;
    public static string StaticConstructorName;
    public static string Indexer;
    public static string DestructorName;
    public static string DelegateInvokeName;
    public static string DelegateBeginInvokeName;
    public static string DelegateEndInvokeName;
    public static string EntryPointMethodName;
    public static string DefaultScriptClassName;
    public static string ObjectToString;
    public static string ObjectEquals;
    public static string ObjectGetHashCode;
    public static string ImplicitConversionName;
    public static string ExplicitConversionName;
    public static string AdditionOperatorName;
    public static string BitwiseAndOperatorName;
    public static string BitwiseOrOperatorName;
    public static string DecrementOperatorName;
    public static string DivisionOperatorName;
    public static string EqualityOperatorName;
    public static string ExclusiveOrOperatorName;
    public static string FalseOperatorName;
    public static string GreaterThanOperatorName;
    public static string GreaterThanOrEqualOperatorName;
    public static string IncrementOperatorName;
    public static string InequalityOperatorName;
    public static string LeftShiftOperatorName;
    public static string UnsignedLeftShiftOperatorName;
    public static string LessThanOperatorName;
    public static string LessThanOrEqualOperatorName;
    public static string LogicalNotOperatorName;
    public static string LogicalOrOperatorName;
    public static string LogicalAndOperatorName;
    public static string ModulusOperatorName;
    public static string MultiplyOperatorName;
    public static string OnesComplementOperatorName;
    public static string RightShiftOperatorName;
    public static string UnsignedRightShiftOperatorName;
    public static string SubtractionOperatorName;
    public static string TrueOperatorName;
    public static string UnaryNegationOperatorName;
    public static string UnaryPlusOperatorName;
    public static string ConcatenateOperatorName;
    public static string ExponentOperatorName;
    public static string IntegerDivisionOperatorName;
    public static string LikeOperatorName;
    public static string GetEnumeratorMethodName;
    public static string DeconstructMethodName;
    public static string MoveNextMethodName;
    public static string CurrentPropertyName;
    public static string ValuePropertyName;
    public static string CollectionInitializerAddMethodName;
    public static string GetAwaiter;
    public static string IsCompleted;
    public static string GetResult;
    public static string OnCompleted;
}
internal static class Microsoft.CodeAnalysis.WellKnownMembers : object {
    private static ImmutableArray`1<MemberDescriptor> s_descriptors;
    private static WellKnownMembers();
    public static MemberDescriptor GetDescriptor(WellKnownMember member);
    internal static bool IsSynthesizedAttributeOptional(WellKnownMember attributeMember);
}
internal enum Microsoft.CodeAnalysis.WellKnownType : Enum {
    public int value__;
    public static WellKnownType Unknown;
    public static WellKnownType First;
    public static WellKnownType System_Math;
    public static WellKnownType System_Array;
    public static WellKnownType System_Attribute;
    public static WellKnownType System_CLSCompliantAttribute;
    public static WellKnownType System_Convert;
    public static WellKnownType System_Exception;
    public static WellKnownType System_FlagsAttribute;
    public static WellKnownType System_FormattableString;
    public static WellKnownType System_Guid;
    public static WellKnownType System_IFormattable;
    public static WellKnownType System_RuntimeTypeHandle;
    public static WellKnownType System_RuntimeFieldHandle;
    public static WellKnownType System_RuntimeMethodHandle;
    public static WellKnownType System_MarshalByRefObject;
    public static WellKnownType System_Type;
    public static WellKnownType System_Reflection_AssemblyKeyFileAttribute;
    public static WellKnownType System_Reflection_AssemblyKeyNameAttribute;
    public static WellKnownType System_Reflection_MethodInfo;
    public static WellKnownType System_Reflection_ConstructorInfo;
    public static WellKnownType System_Reflection_MethodBase;
    public static WellKnownType System_Reflection_FieldInfo;
    public static WellKnownType System_Reflection_MemberInfo;
    public static WellKnownType System_Reflection_Missing;
    public static WellKnownType System_Runtime_CompilerServices_FormattableStringFactory;
    public static WellKnownType System_Runtime_CompilerServices_RuntimeHelpers;
    public static WellKnownType System_Runtime_ExceptionServices_ExceptionDispatchInfo;
    public static WellKnownType System_Runtime_InteropServices_StructLayoutAttribute;
    public static WellKnownType System_Runtime_InteropServices_UnknownWrapper;
    public static WellKnownType System_Runtime_InteropServices_DispatchWrapper;
    public static WellKnownType System_Runtime_InteropServices_CallingConvention;
    public static WellKnownType System_Runtime_InteropServices_ClassInterfaceAttribute;
    public static WellKnownType System_Runtime_InteropServices_ClassInterfaceType;
    public static WellKnownType System_Runtime_InteropServices_CoClassAttribute;
    public static WellKnownType System_Runtime_InteropServices_ComAwareEventInfo;
    public static WellKnownType System_Runtime_InteropServices_ComEventInterfaceAttribute;
    public static WellKnownType System_Runtime_InteropServices_ComInterfaceType;
    public static WellKnownType System_Runtime_InteropServices_ComSourceInterfacesAttribute;
    public static WellKnownType System_Runtime_InteropServices_ComVisibleAttribute;
    public static WellKnownType System_Runtime_InteropServices_DispIdAttribute;
    public static WellKnownType System_Runtime_InteropServices_GuidAttribute;
    public static WellKnownType System_Runtime_InteropServices_InterfaceTypeAttribute;
    public static WellKnownType System_Runtime_InteropServices_Marshal;
    public static WellKnownType System_Runtime_InteropServices_TypeIdentifierAttribute;
    public static WellKnownType System_Runtime_InteropServices_BestFitMappingAttribute;
    public static WellKnownType System_Runtime_InteropServices_DefaultParameterValueAttribute;
    public static WellKnownType System_Runtime_InteropServices_LCIDConversionAttribute;
    public static WellKnownType System_Runtime_InteropServices_UnmanagedFunctionPointerAttribute;
    public static WellKnownType System_Activator;
    public static WellKnownType System_Threading_Tasks_Task;
    public static WellKnownType System_Threading_Tasks_Task_T;
    public static WellKnownType System_Threading_Interlocked;
    public static WellKnownType System_Threading_Monitor;
    public static WellKnownType System_Threading_Thread;
    public static WellKnownType Microsoft_CSharp_RuntimeBinder_Binder;
    public static WellKnownType Microsoft_CSharp_RuntimeBinder_CSharpArgumentInfo;
    public static WellKnownType Microsoft_CSharp_RuntimeBinder_CSharpArgumentInfoFlags;
    public static WellKnownType Microsoft_CSharp_RuntimeBinder_CSharpBinderFlags;
    public static WellKnownType Microsoft_VisualBasic_CallType;
    public static WellKnownType Microsoft_VisualBasic_Embedded;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_Conversions;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_Operators;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_NewLateBinding;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_EmbeddedOperators;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_StandardModuleAttribute;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_Utils;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_LikeOperator;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_ProjectData;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_ObjectFlowControl;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_ObjectFlowControl_ForLoopControl;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_StaticLocalInitFlag;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_StringType;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_IncompleteInitialization;
    public static WellKnownType Microsoft_VisualBasic_CompilerServices_Versioned;
    public static WellKnownType Microsoft_VisualBasic_CompareMethod;
    public static WellKnownType Microsoft_VisualBasic_Strings;
    public static WellKnownType Microsoft_VisualBasic_ErrObject;
    public static WellKnownType Microsoft_VisualBasic_FileSystem;
    public static WellKnownType Microsoft_VisualBasic_ApplicationServices_ApplicationBase;
    public static WellKnownType Microsoft_VisualBasic_ApplicationServices_WindowsFormsApplicationBase;
    public static WellKnownType Microsoft_VisualBasic_Information;
    public static WellKnownType Microsoft_VisualBasic_Interaction;
    public static WellKnownType System_Func_T;
    public static WellKnownType System_Func_T2;
    public static WellKnownType System_Func_T3;
    public static WellKnownType System_Func_T4;
    public static WellKnownType System_Func_T5;
    public static WellKnownType System_Func_T6;
    public static WellKnownType System_Func_T7;
    public static WellKnownType System_Func_T8;
    public static WellKnownType System_Func_T9;
    public static WellKnownType System_Func_T10;
    public static WellKnownType System_Func_T11;
    public static WellKnownType System_Func_T12;
    public static WellKnownType System_Func_T13;
    public static WellKnownType System_Func_T14;
    public static WellKnownType System_Func_T15;
    public static WellKnownType System_Func_T16;
    public static WellKnownType System_Func_T17;
    public static WellKnownType System_Func_TMax;
    public static WellKnownType System_Action;
    public static WellKnownType System_Action_T;
    public static WellKnownType System_Action_T2;
    public static WellKnownType System_Action_T3;
    public static WellKnownType System_Action_T4;
    public static WellKnownType System_Action_T5;
    public static WellKnownType System_Action_T6;
    public static WellKnownType System_Action_T7;
    public static WellKnownType System_Action_T8;
    public static WellKnownType System_Action_T9;
    public static WellKnownType System_Action_T10;
    public static WellKnownType System_Action_T11;
    public static WellKnownType System_Action_T12;
    public static WellKnownType System_Action_T13;
    public static WellKnownType System_Action_T14;
    public static WellKnownType System_Action_T15;
    public static WellKnownType System_Action_T16;
    public static WellKnownType System_Action_TMax;
    public static WellKnownType System_AttributeUsageAttribute;
    public static WellKnownType System_ParamArrayAttribute;
    public static WellKnownType System_NonSerializedAttribute;
    public static WellKnownType System_STAThreadAttribute;
    public static WellKnownType System_Reflection_DefaultMemberAttribute;
    public static WellKnownType System_Runtime_CompilerServices_DateTimeConstantAttribute;
    public static WellKnownType System_Runtime_CompilerServices_DecimalConstantAttribute;
    public static WellKnownType System_Runtime_CompilerServices_IUnknownConstantAttribute;
    public static WellKnownType System_Runtime_CompilerServices_IDispatchConstantAttribute;
    public static WellKnownType System_Runtime_CompilerServices_ExtensionAttribute;
    public static WellKnownType System_Runtime_CompilerServices_INotifyCompletion;
    public static WellKnownType System_Runtime_CompilerServices_InternalsVisibleToAttribute;
    public static WellKnownType System_Runtime_CompilerServices_CompilerGeneratedAttribute;
    public static WellKnownType System_Runtime_CompilerServices_AccessedThroughPropertyAttribute;
    public static WellKnownType System_Runtime_CompilerServices_CompilationRelaxationsAttribute;
    public static WellKnownType System_Runtime_CompilerServices_RuntimeCompatibilityAttribute;
    public static WellKnownType System_Runtime_CompilerServices_UnsafeValueTypeAttribute;
    public static WellKnownType System_Runtime_CompilerServices_FixedBufferAttribute;
    public static WellKnownType System_Runtime_CompilerServices_DynamicAttribute;
    public static WellKnownType System_Runtime_CompilerServices_CallSiteBinder;
    public static WellKnownType System_Runtime_CompilerServices_CallSite;
    public static WellKnownType System_Runtime_CompilerServices_CallSite_T;
    public static WellKnownType System_Runtime_InteropServices_WindowsRuntime_EventRegistrationToken;
    public static WellKnownType System_Runtime_InteropServices_WindowsRuntime_EventRegistrationTokenTable_T;
    public static WellKnownType System_Runtime_InteropServices_WindowsRuntime_WindowsRuntimeMarshal;
    public static WellKnownType Windows_Foundation_IAsyncAction;
    public static WellKnownType Windows_Foundation_IAsyncActionWithProgress_T;
    public static WellKnownType Windows_Foundation_IAsyncOperation_T;
    public static WellKnownType Windows_Foundation_IAsyncOperationWithProgress_T2;
    public static WellKnownType System_Diagnostics_Debugger;
    public static WellKnownType System_Diagnostics_DebuggerDisplayAttribute;
    public static WellKnownType System_Diagnostics_DebuggerNonUserCodeAttribute;
    public static WellKnownType System_Diagnostics_DebuggerHiddenAttribute;
    public static WellKnownType System_Diagnostics_DebuggerBrowsableAttribute;
    public static WellKnownType System_Diagnostics_DebuggerStepThroughAttribute;
    public static WellKnownType System_Diagnostics_DebuggerBrowsableState;
    public static WellKnownType System_Diagnostics_DebuggableAttribute;
    public static WellKnownType System_Diagnostics_DebuggableAttribute__DebuggingModes;
    public static WellKnownType System_ComponentModel_DesignerSerializationVisibilityAttribute;
    public static WellKnownType System_IEquatable_T;
    public static WellKnownType System_Collections_IList;
    public static WellKnownType System_Collections_ICollection;
    public static WellKnownType System_Collections_Generic_EqualityComparer_T;
    public static WellKnownType System_Collections_Generic_List_T;
    public static WellKnownType System_Collections_Generic_IDictionary_KV;
    public static WellKnownType System_Collections_Generic_IReadOnlyDictionary_KV;
    public static WellKnownType System_Collections_ObjectModel_Collection_T;
    public static WellKnownType System_Collections_ObjectModel_ReadOnlyCollection_T;
    public static WellKnownType System_Collections_Specialized_INotifyCollectionChanged;
    public static WellKnownType System_ComponentModel_INotifyPropertyChanged;
    public static WellKnownType System_ComponentModel_EditorBrowsableAttribute;
    public static WellKnownType System_ComponentModel_EditorBrowsableState;
    public static WellKnownType System_Linq_Enumerable;
    public static WellKnownType System_Linq_Expressions_Expression;
    public static WellKnownType System_Linq_Expressions_Expression_T;
    public static WellKnownType System_Linq_Expressions_ParameterExpression;
    public static WellKnownType System_Linq_Expressions_ElementInit;
    public static WellKnownType System_Linq_Expressions_MemberBinding;
    public static WellKnownType System_Linq_Expressions_ExpressionType;
    public static WellKnownType System_Linq_IQueryable;
    public static WellKnownType System_Linq_IQueryable_T;
    public static WellKnownType System_Xml_Linq_Extensions;
    public static WellKnownType System_Xml_Linq_XAttribute;
    public static WellKnownType System_Xml_Linq_XCData;
    public static WellKnownType System_Xml_Linq_XComment;
    public static WellKnownType System_Xml_Linq_XContainer;
    public static WellKnownType System_Xml_Linq_XDeclaration;
    public static WellKnownType System_Xml_Linq_XDocument;
    public static WellKnownType System_Xml_Linq_XElement;
    public static WellKnownType System_Xml_Linq_XName;
    public static WellKnownType System_Xml_Linq_XNamespace;
    public static WellKnownType System_Xml_Linq_XObject;
    public static WellKnownType System_Xml_Linq_XProcessingInstruction;
    public static WellKnownType System_Security_UnverifiableCodeAttribute;
    public static WellKnownType System_Security_Permissions_SecurityAction;
    public static WellKnownType System_Security_Permissions_SecurityAttribute;
    public static WellKnownType System_Security_Permissions_SecurityPermissionAttribute;
    public static WellKnownType System_NotSupportedException;
    public static WellKnownType System_Runtime_CompilerServices_ICriticalNotifyCompletion;
    public static WellKnownType System_Runtime_CompilerServices_IAsyncStateMachine;
    public static WellKnownType System_Runtime_CompilerServices_AsyncVoidMethodBuilder;
    public static WellKnownType System_Runtime_CompilerServices_AsyncTaskMethodBuilder;
    public static WellKnownType System_Runtime_CompilerServices_AsyncTaskMethodBuilder_T;
    public static WellKnownType System_Runtime_CompilerServices_AsyncStateMachineAttribute;
    public static WellKnownType System_Runtime_CompilerServices_IteratorStateMachineAttribute;
    public static WellKnownType System_Windows_Forms_Form;
    public static WellKnownType System_Windows_Forms_Application;
    public static WellKnownType System_Environment;
    public static WellKnownType System_Runtime_GCLatencyMode;
    public static WellKnownType System_IFormatProvider;
    public static WellKnownType CSharp7Sentinel;
    public static WellKnownType System_ValueTuple_T1;
    public static WellKnownType System_ValueTuple_T2;
    public static WellKnownType System_ValueTuple_T3;
    public static WellKnownType System_ValueTuple_T4;
    public static WellKnownType System_ValueTuple_T5;
    public static WellKnownType System_ValueTuple_T6;
    public static WellKnownType ExtSentinel;
    public static WellKnownType System_ValueTuple_T7;
    public static WellKnownType System_ValueTuple_TRest;
    public static WellKnownType System_Runtime_CompilerServices_TupleElementNamesAttribute;
    public static WellKnownType Microsoft_CodeAnalysis_Runtime_Instrumentation;
    public static WellKnownType System_Runtime_CompilerServices_ReferenceAssemblyAttribute;
    public static WellKnownType System_Runtime_CompilerServices_IsReadOnlyAttribute;
    public static WellKnownType System_Runtime_CompilerServices_IsByRefLikeAttribute;
    public static WellKnownType System_Runtime_InteropServices_InAttribute;
    public static WellKnownType System_ObsoleteAttribute;
    public static WellKnownType System_Span_T;
    public static WellKnownType System_ReadOnlySpan_T;
    public static WellKnownType System_Runtime_InteropServices_UnmanagedType;
    public static WellKnownType System_Runtime_CompilerServices_IsUnmanagedAttribute;
    public static WellKnownType Microsoft_VisualBasic_Conversion;
    public static WellKnownType NextAvailable;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.WellKnownTypes : object {
    internal static int Count;
    private static String[] s_metadataNames;
    private static Dictionary`2<string, WellKnownType> s_nameToTypeIdMap;
    private static WellKnownTypes();
    [ConditionalAttribute("DEBUG")]
private static void AssertEnumAndTableInSync();
    [ExtensionAttribute]
public static bool IsWellKnownType(WellKnownType typeId);
    [ExtensionAttribute]
public static bool IsValueTupleType(WellKnownType typeId);
    [ExtensionAttribute]
public static bool IsValid(WellKnownType typeId);
    [ExtensionAttribute]
public static string GetMetadataName(WellKnownType id);
    public static WellKnownType GetTypeFromMetadataName(string metadataName);
    internal static WellKnownType GetWellKnownFunctionDelegate(int invokeArgumentCount);
    internal static WellKnownType GetWellKnownActionDelegate(int invokeArgumentCount);
}
internal static class Microsoft.CodeAnalysis.Win32ResourceConversions : object {
    internal static void AppendIconToResourceStream(Stream resStream, Stream iconStream);
    internal static void AppendVersionToResourceStream(Stream resStream, bool isDll, string fileVersion, string originalFileName, string internalName, string productVersion, Version assemblyVersion, string fileDescription, string legalCopyright, string legalTrademarks, string productName, string comments, string companyName);
    internal static void AppendManifestToResourceStream(Stream resStream, Stream manifestStream, bool isDll);
}
internal static class Microsoft.CodeAnalysis.XmlCharType : object {
    internal static int SurHighStart;
    internal static int SurHighEnd;
    internal static int SurLowStart;
    internal static int SurLowEnd;
    internal static int SurMask;
    internal static int fWhitespace;
    internal static int fLetter;
    internal static int fNCStartNameSC;
    internal static int fNCNameSC;
    internal static int fCharData;
    internal static int fNCNameXml4e;
    internal static int fText;
    internal static int fAttrValue;
    private static string s_PublicIdBitmap;
    private static UInt32 CharPropertiesSize;
    private static int innerSizeBits;
    private static int innerSize;
    private static int innerSizeMask;
    private static Byte[] s_charPropertiesIndex;
    private static Byte[] s_charProperties;
    private static XmlCharType();
    private static byte charProperties(char i);
    public static bool IsWhiteSpace(char ch);
    public static bool IsExtender(char ch);
    public static bool IsNCNameSingleChar(char ch);
    public static bool IsStartNCNameSingleChar(char ch);
    public static bool IsNameSingleChar(char ch);
    public static bool IsStartNameSingleChar(char ch);
    public static bool IsCharData(char ch);
    public static bool IsPubidChar(char ch);
    internal static bool IsTextChar(char ch);
    internal static bool IsAttributeValueChar(char ch);
    public static bool IsLetter(char ch);
    public static bool IsNCNameCharXml4e(char ch);
    public static bool IsStartNCNameCharXml4e(char ch);
    public static bool IsNameCharXml4e(char ch);
    public static bool IsStartNameCharXml4e(char ch);
    public static bool IsDigit(char ch);
    public static bool IsHexDigit(char ch);
    internal static bool IsHighSurrogate(int ch);
    internal static bool IsLowSurrogate(int ch);
    internal static bool IsSurrogate(int ch);
    internal static int CombineSurrogateChar(int lowChar, int highChar);
    internal static void SplitSurrogateChar(int combinedChar, Char& lowChar, Char& highChar);
    internal static bool IsOnlyWhitespace(string str);
    internal static int IsOnlyWhitespaceWithPos(string str);
    internal static int IsOnlyCharData(string str);
    internal static bool IsOnlyDigits(string str, int startPos, int len);
    internal static bool IsOnlyDigits(Char[] chars, int startPos, int len);
    internal static int IsPublicId(string str);
    private static bool InRange(int value, int start, int end);
    internal static bool InRange(char value, char start, char end);
}
internal class Microsoft.CodeAnalysis.XmlDocumentationCommentTextReader : object {
    private XmlReader _reader;
    private Reader _textReader;
    private static ObjectPool`1<XmlDocumentationCommentTextReader> s_pool;
    private static XmlReaderSettings s_xmlSettings;
    private static XmlDocumentationCommentTextReader();
    public static XmlException ParseAndGetException(string text);
    internal XmlException ParseInternal(string text);
}
public class Microsoft.CodeAnalysis.XmlFileResolver : XmlReferenceResolver {
    [CompilerGeneratedAttribute]
private static XmlFileResolver <Default>k__BackingField;
    private string _baseDirectory;
    public static XmlFileResolver Default { get; }
    public string BaseDirectory { get; }
    public XmlFileResolver(string baseDirectory);
    private static XmlFileResolver();
    [CompilerGeneratedAttribute]
public static XmlFileResolver get_Default();
    public string get_BaseDirectory();
    public virtual string ResolveReference(string path, string baseFilePath);
    public virtual Stream OpenRead(string resolvedPath);
    protected virtual bool FileExists(string resolvedPath);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.XmlLocation : Location {
    private FileLinePositionSpan _positionSpan;
    public LocationKind Kind { get; }
    private XmlLocation(string path, int lineNumber, int columnNumber);
    public static XmlLocation Create(XmlException exception, string path);
    public static XmlLocation Create(XObject obj, string path);
    public virtual LocationKind get_Kind();
    public virtual FileLinePositionSpan GetLineSpan();
    public sealed virtual bool Equals(XmlLocation other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public abstract class Microsoft.CodeAnalysis.XmlReferenceResolver : object {
    public abstract virtual bool Equals(object other);
    public abstract virtual int GetHashCode();
    public abstract virtual string ResolveReference(string path, string baseFilePath);
    public abstract virtual Stream OpenRead(string resolvedPath);
    internal Stream OpenReadChecked(string fullPath);
}
internal class Microsoft.DiaSymReader.ComMemoryStream : object {
    internal static int STREAM_SEEK_SET;
    internal static int STREAM_SEEK_CUR;
    internal static int STREAM_SEEK_END;
    private int _chunkSize;
    private List`1<Byte[]> _chunks;
    private int _position;
    private int _length;
    public ComMemoryStream(int chunkSize);
    public void CopyTo(Stream stream);
    [IteratorStateMachineAttribute("Microsoft.DiaSymReader.ComMemoryStream/<GetChunks>d__9")]
public IEnumerable`1<ArraySegment`1<byte>> GetChunks();
    private static void ZeroMemory(Byte* dest, int count);
    private sealed virtual override void Microsoft.DiaSymReader.IUnsafeComStream.Read(Byte* pv, int cb, Int32* pcbRead);
    private int SetPosition(int newPos);
    private sealed virtual override void Microsoft.DiaSymReader.IUnsafeComStream.Seek(long dlibMove, int origin, Int64* plibNewPosition);
    private sealed virtual override void Microsoft.DiaSymReader.IUnsafeComStream.SetSize(long libNewSize);
    private sealed virtual override void Microsoft.DiaSymReader.IUnsafeComStream.Stat(STATSTG& pstatstg, int grfStatFlag);
    private sealed virtual override void Microsoft.DiaSymReader.IUnsafeComStream.Write(Byte* pv, int cb, Int32* pcbWritten);
    private sealed virtual override void Microsoft.DiaSymReader.IUnsafeComStream.Commit(int grfCommitFlags);
    private sealed virtual override void Microsoft.DiaSymReader.IUnsafeComStream.Clone(IStream& ppstm);
    private sealed virtual override void Microsoft.DiaSymReader.IUnsafeComStream.CopyTo(IStream pstm, long cb, Int32* pcbRead, Int32* pcbWritten);
    private sealed virtual override void Microsoft.DiaSymReader.IUnsafeComStream.LockRegion(long libOffset, long cb, int lockType);
    private sealed virtual override void Microsoft.DiaSymReader.IUnsafeComStream.Revert();
    private sealed virtual override void Microsoft.DiaSymReader.IUnsafeComStream.UnlockRegion(long libOffset, long cb, int lockType);
}
internal static class Microsoft.DiaSymReader.EmptyArray`1 : object {
    public static T[] Instance;
    private static EmptyArray`1();
}
internal static class Microsoft.DiaSymReader.HResult : object {
    internal static int S_OK;
    internal static int S_FALSE;
    internal static int E_NOTIMPL;
    internal static int E_FAIL;
    internal static int E_INVALIDARG;
    internal static int E_UNEXPECTED;
}
internal class Microsoft.DiaSymReader.ImageDebugDirectory : ValueType {
    internal int Characteristics;
    internal int TimeDateStamp;
    internal short MajorVersion;
    internal short MinorVersion;
    internal int Type;
    internal int SizeOfData;
    internal int AddressOfRawData;
    internal int PointerToRawData;
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("BA3FEE4C-ECB9-4e41-83B7-183FA41CD859")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.DiaSymReader.IMetadataEmit {
    public abstract virtual void __SetModuleProps();
    public abstract virtual void __Save();
    public abstract virtual void __SaveToStream();
    public abstract virtual void __GetSaveSize();
    public abstract virtual void __DefineTypeDef();
    public abstract virtual void __DefineNestedType();
    public abstract virtual void __SetHandler();
    public abstract virtual void __DefineMethod();
    public abstract virtual void __DefineMethodImpl();
    public abstract virtual void __DefineTypeRefByName();
    public abstract virtual void __DefineImportType();
    public abstract virtual void __DefineMemberRef();
    public abstract virtual void __DefineImportMember();
    public abstract virtual void __DefineEvent();
    public abstract virtual void __SetClassLayout();
    public abstract virtual void __DeleteClassLayout();
    public abstract virtual void __SetFieldMarshal();
    public abstract virtual void __DeleteFieldMarshal();
    public abstract virtual void __DefinePermissionSet();
    public abstract virtual void __SetRVA();
    public abstract virtual int GetTokenFromSig(Byte* voidPointerSig, int byteCountSig);
    public abstract virtual void __DefineModuleRef();
    public abstract virtual void __SetParent();
    public abstract virtual void __GetTokenFromTypeSpec();
    public abstract virtual void __SaveToMemory();
    public abstract virtual void __DefineUserString();
    public abstract virtual void __DeleteToken();
    public abstract virtual void __SetMethodProps();
    public abstract virtual void __SetTypeDefProps();
    public abstract virtual void __SetEventProps();
    public abstract virtual void __SetPermissionSetProps();
    public abstract virtual void __DefinePinvokeMap();
    public abstract virtual void __SetPinvokeMap();
    public abstract virtual void __DeletePinvokeMap();
    public abstract virtual void __DefineCustomAttribute();
    public abstract virtual void __SetCustomAttributeValue();
    public abstract virtual void __DefineField();
    public abstract virtual void __DefineProperty();
    public abstract virtual void __DefineParam();
    public abstract virtual void __SetFieldProps();
    public abstract virtual void __SetPropertyProps();
    public abstract virtual void __SetParamProps();
    public abstract virtual void __DefineSecurityAttributeSet();
    public abstract virtual void __ApplyEditAndContinue();
    public abstract virtual void __TranslateSigWithScope();
    public abstract virtual void __SetMethodImplFlags();
    public abstract virtual void __SetFieldRVA();
    public abstract virtual void __Merge();
    public abstract virtual void __MergeEnd();
}
[ComVisibleAttribute("False")]
[InterfaceTypeAttribute("1")]
[GuidAttribute("7DAC8207-D3AE-4c75-9B67-92801A497D44")]
internal interface Microsoft.DiaSymReader.IMetadataImport {
    public abstract virtual void CloseEnum(Void* enumHandle);
    public abstract virtual int CountEnum(Void* enumHandle, Int32& count);
    public abstract virtual int ResetEnum(Void* enumHandle, int position);
    public abstract virtual int EnumTypeDefs(Void*& enumHandle, Int32* typeDefs, int bufferLength, Int32* count);
    public abstract virtual int EnumInterfaceImpls(Void*& enumHandle, int typeDef, Int32* interfaceImpls, int bufferLength, Int32* count);
    public abstract virtual int EnumTypeRefs(Void*& enumHandle, Int32* typeRefs, int bufferLength, Int32* count);
    public abstract virtual int FindTypeDefByName(string name, int enclosingClass, Int32& typeDef);
    public abstract virtual int GetScopeProps(Char* name, int bufferLength, Int32* nameLength, Guid* mvid);
    public abstract virtual int GetModuleFromScope(Int32& moduleDef);
    public abstract virtual int GetTypeDefProps(int typeDef, Char* qualifiedName, int qualifiedNameBufferLength, Int32* qualifiedNameLength, TypeAttributes* attributes, Int32* baseType);
    public abstract virtual int GetInterfaceImplProps(int interfaceImpl, Int32* typeDef, Int32* interfaceDefRefSpec);
    public abstract virtual int GetTypeRefProps(int typeRef, Int32* resolutionScope, Char* qualifiedName, int qualifiedNameBufferLength, Int32* qualifiedNameLength);
    public abstract virtual int ResolveTypeRef(int typeRef, Guid& scopeInterfaceId, Object& scope, Int32& typeDef);
    public abstract virtual int EnumMembers(Void*& enumHandle, int typeDef, Int32* memberDefs, int bufferLength, Int32* count);
    public abstract virtual int EnumMembersWithName(Void*& enumHandle, int typeDef, string name, Int32* memberDefs, int bufferLength, Int32* count);
    public abstract virtual int EnumMethods(Void*& enumHandle, int typeDef, Int32* methodDefs, int bufferLength, Int32* count);
    public abstract virtual int EnumMethodsWithName(Void*& enumHandle, int typeDef, string name, Int32* methodDefs, int bufferLength, Int32* count);
    public abstract virtual int EnumFields(Void*& enumHandle, int typeDef, Int32* fieldDefs, int bufferLength, Int32* count);
    public abstract virtual int EnumFieldsWithName(Void*& enumHandle, int typeDef, string name, Int32* fieldDefs, int bufferLength, Int32* count);
    public abstract virtual int EnumParams(Void*& enumHandle, int methodDef, Int32* paramDefs, int bufferLength, Int32* count);
    public abstract virtual int EnumMemberRefs(Void*& enumHandle, int parentToken, Int32* memberRefs, int bufferLength, Int32* count);
    public abstract virtual int EnumMethodImpls(Void*& enumHandle, int typeDef, Int32* implementationTokens, Int32* declarationTokens, int bufferLength, Int32* count);
    public abstract virtual int EnumPermissionSets(Void*& enumHandle, int token, UInt32 action, Int32* declSecurityTokens, int bufferLength, Int32* count);
    public abstract virtual int FindMember(int typeDef, string name, Byte* signature, int signatureLength, Int32& memberDef);
    public abstract virtual int FindMethod(int typeDef, string name, Byte* signature, int signatureLength, Int32& methodDef);
    public abstract virtual int FindField(int typeDef, string name, Byte* signature, int signatureLength, Int32& fieldDef);
    public abstract virtual int FindMemberRef(int typeDef, string name, Byte* signature, int signatureLength, Int32& memberRef);
    public abstract virtual int GetMethodProps(int methodDef, Int32* declaringTypeDef, Char* name, int nameBufferLength, Int32* nameLength, MethodAttributes* attributes, Byte** signature, Int32* signatureLength, Int32* relativeVirtualAddress, MethodImplAttributes* implAttributes);
    public abstract virtual int GetMemberRefProps(int memberRef, Int32* declaringType, Char* name, int nameBufferLength, Int32* nameLength, Byte** signature, Int32* signatureLength);
    public abstract virtual int EnumProperties(Void*& enumHandle, int typeDef, Int32* properties, int bufferLength, Int32* count);
    public abstract virtual UInt32 EnumEvents(Void*& enumHandle, int typeDef, Int32* events, int bufferLength, Int32* count);
    public abstract virtual int GetEventProps(int event, Int32* declaringTypeDef, Char* name, int nameBufferLength, Int32* nameLength, Int32* attributes, Int32* eventType, Int32* adderMethodDef, Int32* removerMethodDef, Int32* raiserMethodDef, Int32* otherMethodDefs, int otherMethodDefBufferLength, Int32* methodMethodDefsLength);
    public abstract virtual int EnumMethodSemantics(Void*& enumHandle, int methodDef, Int32* eventsAndProperties, int bufferLength, Int32* count);
    public abstract virtual int GetMethodSemantics(int methodDef, int eventOrProperty, Int32* semantics);
    public abstract virtual int GetClassLayout(int typeDef, Int32* packSize, MetadataImportFieldOffset* fieldOffsets, int bufferLength, Int32* count, Int32* typeSize);
    public abstract virtual int GetFieldMarshal(int fieldDef, Byte** nativeTypeSignature, Int32* nativeTypeSignatureLengvth);
    public abstract virtual int GetRVA(int methodDef, Int32* relativeVirtualAddress, Int32* implAttributes);
    public abstract virtual int GetPermissionSetProps(int declSecurity, UInt32* action, Byte** permissionBlob, Int32* permissionBlobLength);
    public abstract virtual int GetSigFromToken(int standaloneSignature, Byte** signature, Int32* signatureLength);
    public abstract virtual int GetModuleRefProps(int moduleRef, Char* name, int nameBufferLength, Int32* nameLength);
    public abstract virtual int EnumModuleRefs(Void*& enumHandle, Int32* moduleRefs, int bufferLength, Int32* count);
    public abstract virtual int GetTypeSpecFromToken(int typeSpec, Byte** signature, Int32* signatureLength);
    public abstract virtual int GetNameFromToken(int token, Byte* nameUTF8);
    public abstract virtual int EnumUnresolvedMethods(Void*& enumHandle, Int32* methodDefs, int bufferLength, Int32* count);
    public abstract virtual int GetUserString(int userStringToken, Char* buffer, int bufferLength, Int32* length);
    public abstract virtual int GetPinvokeMap(int memberDef, Int32* attributes, Char* importName, int importNameBufferLength, Int32* importNameLength, Int32* moduleRef);
    public abstract virtual int EnumSignatures(Void*& enumHandle, Int32* signatureTokens, int bufferLength, Int32* count);
    public abstract virtual int EnumTypeSpecs(Void*& enumHandle, Int32* typeSpecs, int bufferLength, Int32* count);
    public abstract virtual int EnumUserStrings(Void*& enumHandle, Int32* userStrings, int bufferLength, Int32* count);
    public abstract virtual int GetParamForMethodIndex(int methodDef, int sequenceNumber, Int32& parameterToken);
    public abstract virtual int EnumCustomAttributes(Void*& enumHandle, int parent, int attributeType, Int32* customAttributes, int bufferLength, Int32* count);
    public abstract virtual int GetCustomAttributeProps(int customAttribute, Int32* parent, Int32* constructor, Byte** value, Int32* valueLength);
    public abstract virtual int FindTypeRef(int resolutionScope, string name, Int32& typeRef);
    public abstract virtual int GetMemberProps(int member, Int32* declaringTypeDef, Char* name, int nameBufferLength, Int32* nameLength, Int32* attributes, Byte** signature, Int32* signatureLength, Int32* relativeVirtualAddress, Int32* implAttributes, Int32* constantType, Byte** constantValue, Int32* constantValueLength);
    public abstract virtual int GetFieldProps(int fieldDef, Int32* declaringTypeDef, Char* name, int nameBufferLength, Int32* nameLength, Int32* attributes, Byte** signature, Int32* signatureLength, Int32* constantType, Byte** constantValue, Int32* constantValueLength);
    public abstract virtual int GetPropertyProps(int propertyDef, Int32* declaringTypeDef, Char* name, int nameBufferLength, Int32* nameLength, Int32* attributes, Byte** signature, Int32* signatureLength, Int32* constantType, Byte** constantValue, Int32* constantValueLength, Int32* setterMethodDef, Int32* getterMethodDef, Int32* outerMethodDefs, int outerMethodDefsBufferLength, Int32* otherMethodDefCount);
    public abstract virtual int GetParamProps(int parameter, Int32* declaringMethodDef, Int32* sequenceNumber, Char* name, int nameBufferLength, Int32* nameLength, Int32* attributes, Int32* constantType, Byte** constantValue, Int32* constantValueLength);
    public abstract virtual int GetCustomAttributeByName(int parent, string name, Byte** value, Int32* valueLength);
    public abstract virtual bool IsValidToken(int token);
    public abstract virtual int GetNestedClassProps(int nestedClass, Int32& enclosingClass);
    public abstract virtual int GetNativeCallConvFromSig(Byte* signature, int signatureLength, Int32* callingConvention);
    public abstract virtual int IsGlobal(int token, bool value);
}
internal class Microsoft.DiaSymReader.InteropUtilities : object {
    private static IntPtr s_ignoreIErrorInfo;
    private static InteropUtilities();
    internal static T[] NullToEmpty(T[] items);
    internal static void ThrowExceptionForHR(int hr);
    internal static void CopyQualifiedTypeName(Char* qualifiedName, int qualifiedNameBufferLength, Int32* qualifiedNameLength, string namespaceStr, string nameStr);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("98ECEE1E-752D-11d3-8D56-00C04F680B2B")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.DiaSymReader.IPdbWriter {
    public abstract virtual int __SetPath();
    public abstract virtual int __OpenMod();
    public abstract virtual int __CloseMod();
    public abstract virtual int __GetPath();
    public abstract virtual void GetSignatureAge(UInt32& sig, Int32& age);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("FC073774-1739-4232-BD56-A027294BEC15")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.DiaSymReader.ISymUnmanagedAsyncMethodPropertiesWriter {
    public abstract virtual void DefineKickoffMethod(int kickoffMethod);
    public abstract virtual void DefineCatchHandlerILOffset(int catchHandlerOffset);
    public abstract virtual void DefineAsyncStepInfo(int count, Int32[] yieldOffsets, Int32[] breakpointOffset, Int32[] breakpointMethod);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B01FAFEB-C450-3A4D-BEEC-B4CEEC01E006")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.DiaSymReader.ISymUnmanagedDocumentWriter {
    public abstract virtual void SetSource(UInt32 sourceSize, Byte[] source);
    public abstract virtual void SetCheckSum(Guid algorithmId, UInt32 checkSumSize, Byte[] checkSum);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("DCF7780D-BDE9-45DF-ACFE-21731A32000C")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.DiaSymReader.ISymUnmanagedWriter5 {
    public abstract virtual ISymUnmanagedDocumentWriter DefineDocument(string url, Guid& language, Guid& languageVendor, Guid& documentType);
    public abstract virtual void SetUserEntryPoint(int entryMethodToken);
    public abstract virtual void OpenMethod(UInt32 methodToken);
    public abstract virtual void CloseMethod();
    public abstract virtual UInt32 OpenScope(int startOffset);
    public abstract virtual void CloseScope(int endOffset);
    public abstract virtual void SetScopeRange(UInt32 scopeID, UInt32 startOffset, UInt32 endOffset);
    public abstract virtual void DefineLocalVariable(string name, UInt32 attributes, UInt32 sig, Byte* signature, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 startOffset, UInt32 endOffset);
    public abstract virtual void DefineParameter(string name, UInt32 attributes, UInt32 sequence, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void DefineField(UInt32 parent, string name, UInt32 attributes, UInt32 sig, Byte* signature, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void DefineGlobalVariable(string name, UInt32 attributes, UInt32 sig, Byte* signature, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void Close();
    public abstract virtual void SetSymAttribute(UInt32 parent, string name, int length, Byte* data);
    public abstract virtual void OpenNamespace(string name);
    public abstract virtual void CloseNamespace();
    public abstract virtual void UsingNamespace(string fullName);
    public abstract virtual void SetMethodSourceRange(ISymUnmanagedDocumentWriter startDoc, UInt32 startLine, UInt32 startColumn, object endDoc, UInt32 endLine, UInt32 endColumn);
    public abstract virtual void Initialize(object emitter, string filename, object ptrIStream, bool fullBuild);
    public abstract virtual void GetDebugInfo(ImageDebugDirectory& debugDirectory, UInt32 dataCount, UInt32& dataCountPtr, Byte* data);
    public abstract virtual void DefineSequencePoints(ISymUnmanagedDocumentWriter document, int count, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public abstract virtual void RemapToken(UInt32 oldToken, UInt32 newToken);
    public abstract virtual void Initialize2(object emitter, string tempfilename, object ptrIStream, bool fullBuild, string finalfilename);
    public abstract virtual void DefineConstant(string name, object value, UInt32 sig, Byte* signature);
    public abstract virtual void Abort();
    public abstract virtual void DefineLocalVariable2(string name, int attributes, int localSignatureToken, UInt32 addrKind, int index, UInt32 addr2, UInt32 addr3, UInt32 startOffset, UInt32 endOffset);
    public abstract virtual void DefineGlobalVariable2(string name, int attributes, int sigToken, UInt32 addrKind, UInt32 addr1, UInt32 addr2, UInt32 addr3);
    public abstract virtual void DefineConstant2(string name, VariantStructure value, int constantSignatureToken);
    public abstract virtual void OpenMethod2(UInt32 methodToken, int sectionIndex, int offsetRelativeOffset);
    public abstract virtual void Commit();
    public abstract virtual void GetDebugInfoWithPadding(ImageDebugDirectory& debugDirectory, UInt32 dataCount, UInt32& dataCountPtr, Byte* data);
    public abstract virtual void OpenMapTokensToSourceSpans();
    public abstract virtual void CloseMapTokensToSourceSpans();
    public abstract virtual void MapTokenToSourceSpan(int token, ISymUnmanagedDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("5ba52f3b-6bf8-40fc-b476-d39c529b331e")]
[SuppressUnmanagedCodeSecurityAttribute]
internal interface Microsoft.DiaSymReader.ISymUnmanagedWriter8 {
    public abstract virtual void _VtblGap1_33();
    public abstract virtual void InitializeDeterministic(object emitter, object stream);
    public abstract virtual void UpdateSignatureByHashingContent(Byte* buffer, int size);
    public abstract virtual void UpdateSignature(Guid pdbId, UInt32 stamp, int age);
    public abstract virtual void SetSourceServerData(Byte* data, int size);
    public abstract virtual void SetSourceLinkData(Byte* data, int size);
}
internal interface Microsoft.DiaSymReader.ISymWriterMetadataProvider {
    public abstract virtual bool TryGetTypeDefinitionInfo(int typeDefinitionToken, String& namespaceName, String& typeName, TypeAttributes& attributes);
    public abstract virtual bool TryGetEnclosingType(int nestedTypeToken, Int32& enclosingTypeToken);
    public abstract virtual bool TryGetMethodInfo(int methodDefinitionToken, String& methodName, Int32& declaringTypeToken);
}
[GuidAttribute("0000000c-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface Microsoft.DiaSymReader.IUnsafeComStream {
    public abstract virtual void Read(Byte* pv, int cb, Int32* pcbRead);
    public abstract virtual void Write(Byte* pv, int cb, Int32* pcbWritten);
    public abstract virtual void Seek(long dlibMove, int dwOrigin, Int64* plibNewPosition);
    public abstract virtual void SetSize(long libNewSize);
    public abstract virtual void CopyTo(IStream pstm, long cb, Int32* pcbRead, Int32* pcbWritten);
    public abstract virtual void Commit(int grfCommitFlags);
    public abstract virtual void Revert();
    public abstract virtual void LockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void UnlockRegion(long libOffset, long cb, int dwLockType);
    public abstract virtual void Stat(STATSTG& pstatstg, int grfStatFlag);
    public abstract virtual void Clone(IStream& ppstm);
}
internal class Microsoft.DiaSymReader.MetadataAdapterBase : object {
    public virtual int GetTokenFromSig(Byte* voidPointerSig, int byteCountSig);
    public virtual int GetSigFromToken(int standaloneSignature, Byte** signature, Int32* signatureLength);
    public virtual int GetTypeDefProps(int typeDef, Char* qualifiedName, int qualifiedNameBufferLength, Int32* qualifiedNameLength, TypeAttributes* attributes, Int32* baseType);
    public virtual int GetTypeRefProps(int typeRef, Int32* resolutionScope, Char* qualifiedName, int qualifiedNameBufferLength, Int32* qualifiedNameLength);
    public virtual int GetNestedClassProps(int nestedClass, Int32& enclosingClass);
    public virtual int GetMethodProps(int methodDef, Int32* declaringTypeDef, Char* name, int nameBufferLength, Int32* nameLength, MethodAttributes* attributes, Byte** signature, Int32* signatureLength, Int32* relativeVirtualAddress, MethodImplAttributes* implAttributes);
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataImport.CloseEnum(Void* enumHandle);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.CountEnum(Void* enumHandle, Int32& count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.ResetEnum(Void* enumHandle, int position);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumTypeDefs(Void*& enumHandle, Int32* typeDefs, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumInterfaceImpls(Void*& enumHandle, int typeDef, Int32* interfaceImpls, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumTypeRefs(Void*& enumHandle, Int32* typeRefs, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.FindTypeDefByName(string name, int enclosingClass, Int32& typeDef);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetScopeProps(Char* name, int bufferLength, Int32* nameLength, Guid* mvid);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetModuleFromScope(Int32& moduleDef);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetInterfaceImplProps(int interfaceImpl, Int32* typeDef, Int32* interfaceDefRefSpec);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.ResolveTypeRef(int typeRef, Guid& scopeInterfaceId, Object& scope, Int32& typeDef);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumMembers(Void*& enumHandle, int typeDef, Int32* memberDefs, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumMembersWithName(Void*& enumHandle, int typeDef, string name, Int32* memberDefs, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumMethods(Void*& enumHandle, int typeDef, Int32* methodDefs, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumMethodsWithName(Void*& enumHandle, int typeDef, string name, Int32* methodDefs, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumFields(Void*& enumHandle, int typeDef, Int32* fieldDefs, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumFieldsWithName(Void*& enumHandle, int typeDef, string name, Int32* fieldDefs, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumParams(Void*& enumHandle, int methodDef, Int32* paramDefs, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumMemberRefs(Void*& enumHandle, int parentToken, Int32* memberRefs, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumMethodImpls(Void*& enumHandle, int typeDef, Int32* implementationTokens, Int32* declarationTokens, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumPermissionSets(Void*& enumHandle, int token, UInt32 action, Int32* declSecurityTokens, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.FindMember(int typeDef, string name, Byte* signature, int signatureLength, Int32& memberDef);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.FindMethod(int typeDef, string name, Byte* signature, int signatureLength, Int32& methodDef);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.FindField(int typeDef, string name, Byte* signature, int signatureLength, Int32& fieldDef);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.FindMemberRef(int typeDef, string name, Byte* signature, int signatureLength, Int32& memberRef);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetMemberRefProps(int memberRef, Int32* declaringType, Char* name, int nameBufferLength, Int32* nameLength, Byte** signature, Int32* signatureLength);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumProperties(Void*& enumHandle, int typeDef, Int32* properties, int bufferLength, Int32* count);
    private sealed virtual override UInt32 Microsoft.DiaSymReader.IMetadataImport.EnumEvents(Void*& enumHandle, int typeDef, Int32* events, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetEventProps(int event, Int32* declaringTypeDef, Char* name, int nameBufferLength, Int32* nameLength, Int32* attributes, Int32* eventType, Int32* adderMethodDef, Int32* removerMethodDef, Int32* raiserMethodDef, Int32* otherMethodDefs, int otherMethodDefBufferLength, Int32* methodMethodDefsLength);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumMethodSemantics(Void*& enumHandle, int methodDef, Int32* eventsAndProperties, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetMethodSemantics(int methodDef, int eventOrProperty, Int32* semantics);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetClassLayout(int typeDef, Int32* packSize, MetadataImportFieldOffset* fieldOffsets, int bufferLength, Int32* count, Int32* typeSize);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetFieldMarshal(int fieldDef, Byte** nativeTypeSignature, Int32* nativeTypeSignatureLengvth);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetRVA(int methodDef, Int32* relativeVirtualAddress, Int32* implAttributes);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetPermissionSetProps(int declSecurity, UInt32* action, Byte** permissionBlob, Int32* permissionBlobLength);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetModuleRefProps(int moduleRef, Char* name, int nameBufferLength, Int32* nameLength);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumModuleRefs(Void*& enumHandle, Int32* moduleRefs, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetTypeSpecFromToken(int typeSpec, Byte** signature, Int32* signatureLength);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetNameFromToken(int token, Byte* nameUTF8);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumUnresolvedMethods(Void*& enumHandle, Int32* methodDefs, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetUserString(int userStringToken, Char* buffer, int bufferLength, Int32* length);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetPinvokeMap(int memberDef, Int32* attributes, Char* importName, int importNameBufferLength, Int32* importNameLength, Int32* moduleRef);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumSignatures(Void*& enumHandle, Int32* signatureTokens, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumTypeSpecs(Void*& enumHandle, Int32* typeSpecs, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumUserStrings(Void*& enumHandle, Int32* userStrings, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetParamForMethodIndex(int methodDef, int sequenceNumber, Int32& parameterToken);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.EnumCustomAttributes(Void*& enumHandle, int parent, int attributeType, Int32* customAttributes, int bufferLength, Int32* count);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetCustomAttributeProps(int customAttribute, Int32* parent, Int32* constructor, Byte** value, Int32* valueLength);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.FindTypeRef(int resolutionScope, string name, Int32& typeRef);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetMemberProps(int member, Int32* declaringTypeDef, Char* name, int nameBufferLength, Int32* nameLength, Int32* attributes, Byte** signature, Int32* signatureLength, Int32* relativeVirtualAddress, Int32* implAttributes, Int32* constantType, Byte** constantValue, Int32* constantValueLength);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetFieldProps(int fieldDef, Int32* declaringTypeDef, Char* name, int nameBufferLength, Int32* nameLength, Int32* attributes, Byte** signature, Int32* signatureLength, Int32* constantType, Byte** constantValue, Int32* constantValueLength);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetPropertyProps(int propertyDef, Int32* declaringTypeDef, Char* name, int nameBufferLength, Int32* nameLength, Int32* attributes, Byte** signature, Int32* signatureLength, Int32* constantType, Byte** constantValue, Int32* constantValueLength, Int32* setterMethodDef, Int32* getterMethodDef, Int32* outerMethodDefs, int outerMethodDefsBufferLength, Int32* otherMethodDefCount);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetParamProps(int parameter, Int32* declaringMethodDef, Int32* sequenceNumber, Char* name, int nameBufferLength, Int32* nameLength, Int32* attributes, Int32* constantType, Byte** constantValue, Int32* constantValueLength);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetCustomAttributeByName(int parent, string name, Byte** value, Int32* valueLength);
    private sealed virtual override bool Microsoft.DiaSymReader.IMetadataImport.IsValidToken(int token);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.GetNativeCallConvFromSig(Byte* signature, int signatureLength, Int32* callingConvention);
    private sealed virtual override int Microsoft.DiaSymReader.IMetadataImport.IsGlobal(int token, bool value);
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetModuleProps();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__Save();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SaveToStream();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__GetSaveSize();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefineTypeDef();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefineNestedType();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetHandler();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefineMethod();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefineMethodImpl();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefineTypeRefByName();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefineImportType();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefineMemberRef();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefineImportMember();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefineEvent();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetClassLayout();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DeleteClassLayout();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetFieldMarshal();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DeleteFieldMarshal();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefinePermissionSet();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetRVA();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefineModuleRef();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetParent();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__GetTokenFromTypeSpec();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SaveToMemory();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefineUserString();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DeleteToken();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetMethodProps();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetTypeDefProps();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetEventProps();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetPermissionSetProps();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefinePinvokeMap();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetPinvokeMap();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DeletePinvokeMap();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefineCustomAttribute();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetCustomAttributeValue();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefineField();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefineProperty();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefineParam();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetFieldProps();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetPropertyProps();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetParamProps();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__DefineSecurityAttributeSet();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__ApplyEditAndContinue();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__TranslateSigWithScope();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetMethodImplFlags();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__SetFieldRVA();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__Merge();
    private sealed virtual override void Microsoft.DiaSymReader.IMetadataEmit.__MergeEnd();
}
internal class Microsoft.DiaSymReader.MetadataImportFieldOffset : ValueType {
    public int FieldDef;
    public UInt32 Offset;
}
internal static class Microsoft.DiaSymReader.SymUnmanagedFactory : object {
    private static string AlternateLoadPathEnvironmentVariableName;
    private static string LegacyDiaSymReaderModuleName;
    private static string DiaSymReaderModuleName32;
    private static string DiaSymReaderModuleName64;
    private static string CreateSymReaderFactoryName;
    private static string CreateSymWriterFactoryName;
    private static string SymWriterClsid;
    private static string SymReaderClsid;
    private static Type s_lazySymReaderComType;
    private static Type s_lazySymWriterComType;
    private static Lazy`1<Func`2<string, string>> s_lazyGetEnvironmentVariable;
    internal static string DiaSymReaderModuleName { get; }
    private static SymUnmanagedFactory();
    internal static string get_DiaSymReaderModuleName();
    [DefaultDllImportSearchPathsAttribute("4098")]
private static void CreateSymReader32(Guid& id, Object& symReader);
    [DefaultDllImportSearchPathsAttribute("4098")]
private static void CreateSymReader64(Guid& id, Object& symReader);
    [DefaultDllImportSearchPathsAttribute("4098")]
private static void CreateSymWriter32(Guid& id, Object& symWriter);
    [DefaultDllImportSearchPathsAttribute("4098")]
private static void CreateSymWriter64(Guid& id, Object& symWriter);
    private static IntPtr LoadLibrary(string path);
    private static bool FreeLibrary(IntPtr hModule);
    private static IntPtr GetProcAddress(IntPtr hModule, string procedureName);
    internal static string GetEnvironmentVariable(string name);
    private static object TryLoadFromAlternativePath(Guid clsid, string factoryName);
    private static Type GetComTypeType(Type& lazyType, Guid clsid);
    internal static object CreateObject(bool createReader, bool useAlternativeLoadPath, bool useComRegistry, String& moduleName, Exception& loadException);
}
internal class Microsoft.DiaSymReader.SymUnmanagedSequencePointsWriter : object {
    private SymUnmanagedWriter _writer;
    private int _currentDocumentIndex;
    private int _count;
    private Int32[] _offsets;
    private Int32[] _startLines;
    private Int32[] _startColumns;
    private Int32[] _endLines;
    private Int32[] _endColumns;
    public SymUnmanagedSequencePointsWriter(SymUnmanagedWriter writer, int capacity);
    private void EnsureCapacity(int length);
    private void Clear();
    public void Add(int documentIndex, int offset, int startLine, int startColumn, int endLine, int endColumn);
    public void Flush();
}
internal abstract class Microsoft.DiaSymReader.SymUnmanagedWriter : object {
    public int DocumentTableCapacity { get; public set; }
    public abstract virtual void Dispose();
    public abstract virtual IEnumerable`1<ArraySegment`1<byte>> GetUnderlyingData();
    public abstract virtual void WriteTo(Stream stream);
    public abstract virtual int get_DocumentTableCapacity();
    public abstract virtual void set_DocumentTableCapacity(int value);
    public abstract virtual int DefineDocument(string name, Guid language, Guid vendor, Guid type, Guid algorithmId, Byte[] checksum, Byte[] source);
    public abstract virtual void DefineSequencePoints(int documentIndex, int count, Int32[] offsets, Int32[] startLines, Int32[] startColumns, Int32[] endLines, Int32[] endColumns);
    public abstract virtual void OpenMethod(int methodToken);
    public abstract virtual void CloseMethod();
    public abstract virtual void OpenScope(int startOffset);
    public abstract virtual void CloseScope(int endOffset);
    public abstract virtual void DefineLocalVariable(int index, string name, int attributes, int localSignatureToken);
    public abstract virtual bool DefineLocalConstant(string name, object value, int constantSignatureToken);
    public abstract virtual void UsingNamespace(string importString);
    public abstract virtual void SetAsyncInfo(int moveNextMethodToken, int kickoffMethodToken, int catchHandlerOffset, Int32[] yieldOffsets, Int32[] resumeOffsets);
    public abstract virtual void DefineCustomMetadata(Byte[] metadata);
    public abstract virtual void SetEntryPoint(int entryMethodToken);
    public abstract virtual void UpdateSignature(Guid guid, UInt32 stamp, int age);
    public abstract virtual void GetSignature(Guid& guid, UInt32& stamp, Int32& age);
    public abstract virtual void SetSourceServerData(Byte[] data);
    public abstract virtual void SetSourceLinkData(Byte[] data);
    public abstract virtual void OpenTokensToSourceSpansMap();
    public abstract virtual void MapTokenToSourceSpan(int token, int documentIndex, int startLine, int startColumn, int endLine, int endColumn);
    public abstract virtual void CloseTokensToSourceSpansMap();
}
[FlagsAttribute]
internal enum Microsoft.DiaSymReader.SymUnmanagedWriterCreationOptions : Enum {
    public int value__;
    public static SymUnmanagedWriterCreationOptions Default;
    public static SymUnmanagedWriterCreationOptions UseAlternativeLoadPath;
    public static SymUnmanagedWriterCreationOptions UseComRegistry;
    public static SymUnmanagedWriterCreationOptions Deterministic;
}
internal class Microsoft.DiaSymReader.SymUnmanagedWriterException : Exception {
    [CompilerGeneratedAttribute]
private string <ImplementationModuleName>k__BackingField;
    public string ImplementationModuleName { get; }
    public SymUnmanagedWriterException(string message);
    public SymUnmanagedWriterException(string message, Exception innerException);
    public SymUnmanagedWriterException(string message, Exception innerException, string implementationModuleName);
    internal SymUnmanagedWriterException(Exception innerException, string implementationModuleName);
    [CompilerGeneratedAttribute]
public string get_ImplementationModuleName();
}
internal static class Microsoft.DiaSymReader.SymUnmanagedWriterFactory : object {
    public static SymUnmanagedWriter CreateWriter(ISymWriterMetadataProvider metadataProvider, SymUnmanagedWriterCreationOptions options);
}
internal class Microsoft.DiaSymReader.SymUnmanagedWriterImpl : SymUnmanagedWriter {
    private static object s_zeroInt32;
    private ISymUnmanagedWriter5 _symWriter;
    private ComMemoryStream _pdbStream;
    private List`1<ISymUnmanagedDocumentWriter> _documentWriters;
    private string _symWriterModuleName;
    private bool _disposed;
    public int DocumentTableCapacity { get; public set; }
    internal SymUnmanagedWriterImpl(ComMemoryStream pdbStream, ISymUnmanagedWriter5 symWriter, string symWriterModuleName);
    private static SymUnmanagedWriterImpl();
    private ISymUnmanagedWriter5 GetSymWriter();
    private ISymUnmanagedWriter8 GetSymWriter8();
    private Exception PdbWritingException(Exception inner);
    public virtual void WriteTo(Stream stream);
    public virtual void Dispose();
    protected virtual override void Finalize();
    private void DisposeImpl();
    private void CloseSymWriter();
    public virtual IEnumerable`1<ArraySegment`1<byte>> GetUnderlyingData();
    public virtual int get_DocumentTableCapacity();
    public virtual void set_DocumentTableCapacity(int value);
    public virtual int DefineDocument(string name, Guid language, Guid vendor, Guid type, Guid algorithmId, Byte[] checksum, Byte[] source);
    public virtual void DefineSequencePoints(int documentIndex, int count, Int32[] offsets, Int32[] startLines, Int32[] startColumns, Int32[] endLines, Int32[] endColumns);
    public virtual void OpenMethod(int methodToken);
    public virtual void CloseMethod();
    public virtual void OpenScope(int startOffset);
    public virtual void CloseScope(int endOffset);
    public virtual void DefineLocalVariable(int index, string name, int attributes, int localSignatureToken);
    public virtual bool DefineLocalConstant(string name, object value, int constantSignatureToken);
    private void DefineLocalConstantImpl(ISymUnmanagedWriter5 symWriter, string name, object value, int constantSignatureToken);
    private bool DefineLocalStringConstant(ISymUnmanagedWriter5 symWriter, string name, string value, int constantSignatureToken);
    private static bool IsValidUnicodeString(string str);
    public virtual void UsingNamespace(string importString);
    public virtual void SetAsyncInfo(int moveNextMethodToken, int kickoffMethodToken, int catchHandlerOffset, Int32[] yieldOffsets, Int32[] resumeOffsets);
    public virtual void DefineCustomMetadata(Byte[] metadata);
    public virtual void SetEntryPoint(int entryMethodToken);
    public virtual void UpdateSignature(Guid guid, UInt32 stamp, int age);
    public virtual void SetSourceServerData(Byte[] data);
    public virtual void SetSourceLinkData(Byte[] data);
    public virtual void OpenTokensToSourceSpansMap();
    public virtual void MapTokenToSourceSpan(int token, int documentIndex, int startLine, int startColumn, int endLine, int endColumn);
    public virtual void CloseTokensToSourceSpansMap();
    public virtual void GetSignature(Guid& guid, UInt32& stamp, Int32& age);
}
internal class Microsoft.DiaSymReader.SymWriterMetadataAdapter : MetadataAdapterBase {
    private ISymWriterMetadataProvider _metadataProvider;
    public SymWriterMetadataAdapter(ISymWriterMetadataProvider metadataProvider);
    public virtual int GetTokenFromSig(Byte* voidPointerSig, int byteCountSig);
    public virtual int GetTypeDefProps(int typeDef, Char* qualifiedName, int qualifiedNameBufferLength, Int32* qualifiedNameLength, TypeAttributes* attributes, Int32* baseType);
    public virtual int GetTypeRefProps(int typeRef, Int32* resolutionScope, Char* qualifiedName, int qualifiedNameBufferLength, Int32* qualifiedNameLength);
    public virtual int GetNestedClassProps(int nestedClass, Int32& enclosingClass);
    public virtual int GetMethodProps(int methodDef, Int32* declaringTypeDef, Char* name, int nameBufferLength, Int32* nameLength, MethodAttributes* attributes, Byte** signature, Int32* signatureLength, Int32* relativeVirtualAddress, MethodImplAttributes* implAttributes);
}
internal class Microsoft.DiaSymReader.VariantPadding : ValueType {
    public Byte* Data2;
    public Byte* Data3;
}
internal class Microsoft.DiaSymReader.VariantStructure : ValueType {
    private short _type;
    private long _longValue;
    private VariantPadding _padding;
    private decimal _decimalValue;
    private bool _boolValue;
    private long _intValue;
    private double _doubleValue;
    public VariantStructure(DateTime date);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ArrayExtensions : object {
    [ExtensionAttribute]
internal static T[] Copy(T[] array, int start, int length);
    [ExtensionAttribute]
internal static bool ValueEquals(UInt32[] array, UInt32[] other);
    [ExtensionAttribute]
internal static T[] InsertAt(T[] array, int position, T item);
    [ExtensionAttribute]
internal static T[] Append(T[] array, T item);
    [ExtensionAttribute]
internal static T[] InsertAt(T[] array, int position, T[] items);
    [ExtensionAttribute]
internal static T[] Append(T[] array, T[] items);
    [ExtensionAttribute]
internal static T[] RemoveAt(T[] array, int position);
    [ExtensionAttribute]
internal static T[] RemoveAt(T[] array, int position, int length);
    [ExtensionAttribute]
internal static T[] ReplaceAt(T[] array, int position, T item);
    [ExtensionAttribute]
internal static T[] ReplaceAt(T[] array, int position, int length, T[] items);
    [ExtensionAttribute]
internal static void ReverseContents(T[] array);
    [ExtensionAttribute]
internal static void ReverseContents(T[] array, int start, int count);
    [ExtensionAttribute]
internal static int BinarySearch(Int32[] array, int value);
    [ExtensionAttribute]
internal static int BinarySearchUpperBound(Int32[] array, int value);
}
internal static class Roslyn.Utilities.AssemblyUtilities : object {
    public static ImmutableArray`1<string> FindAssemblySet(string filePath);
    public static Guid ReadMvid(string filePath);
    public static ImmutableArray`1<string> FindSatelliteAssemblies(string filePath);
    public static ImmutableArray`1<AssemblyIdentity> IdentifyMissingDependencies(string assemblyPath, IEnumerable`1<string> dependencyFilePaths);
    public static AssemblyIdentity GetAssemblyIdentity(string assemblyPath);
}
internal static class Roslyn.Utilities.BitArithmeticUtilities : object {
    public static int CountBits(int v);
    public static int CountBits(UInt32 v);
    public static int CountBits(long v);
    public static int CountBits(ulong v);
    internal static UInt32 Align(UInt32 position, UInt32 alignment);
    internal static int Align(int position, int alignment);
}
internal class Roslyn.Utilities.BlobBuildingStream : Stream {
    private static ObjectPool`1<BlobBuildingStream> s_pool;
    private BlobBuilder _builder;
    public static int ChunkSize;
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public long Length { get; }
    public long Position { get; public set; }
    private static BlobBuildingStream();
    public virtual bool get_CanWrite();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual long get_Length();
    public static BlobBuildingStream GetInstance();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    public void WriteInt32(int value);
    public Blob ReserveBytes(int byteCount);
    public ImmutableArray`1<byte> ToImmutableArray();
    public void Free();
    public virtual void Flush();
    protected virtual void Dispose(bool disposing);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void SetLength(long value);
    public virtual long get_Position();
    public virtual void set_Position(long value);
}
internal static class Roslyn.Utilities.CommandLineUtilities : object {
    public static IEnumerable`1<string> SplitCommandLineIntoArguments(string commandLine, bool removeHashComments);
    public static IEnumerable`1<string> SplitCommandLineIntoArguments(string commandLine, bool removeHashComments, Nullable`1& illegalChar);
}
internal static class Roslyn.Utilities.CompilerOptionParseUtilities : object {
    public static IList`1<string> ParseFeatureFromMSBuild(string features);
    public static void ParseFeatures(IDictionary`2<string, string> builder, List`1<string> values);
    private static void ParseFeatureCore(IDictionary`2<string, string> builder, string feature);
}
internal static class Roslyn.Utilities.CompilerPathUtilities : object {
    internal static void RequireAbsolutePath(string path, string argumentName);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ConcurrentDictionaryExtensions : object {
    [ExtensionAttribute]
public static void Add(ConcurrentDictionary`2<K, V> dict, K key, V value);
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Roslyn.Utilities.ConcurrentSet`1 : object {
    private static int DefaultConcurrencyLevel;
    private static int DefaultCapacity;
    private ConcurrentDictionary`2<T, byte> _dictionary;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsReadOnly { get; }
    public ConcurrentSet`1(IEqualityComparer`1<T> equalityComparer);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Contains(T value);
    public bool Add(T value);
    public void AddRange(IEnumerable`1<T> values);
    public sealed virtual bool Remove(T value);
    public sealed virtual void Clear();
    public KeyEnumerator<T> GetEnumerator();
    [IteratorStateMachineAttribute("Roslyn.Utilities.ConcurrentSet`1/<GetEnumeratorImpl>d__18")]
private IEnumerator`1<T> GetEnumeratorImpl();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
}
internal class Roslyn.Utilities.ConsList`1 : object {
    public static ConsList`1<T> Empty;
    private T _head;
    private ConsList`1<T> _tail;
    [DebuggerBrowsableAttribute("0")]
public T Head { get; }
    [DebuggerBrowsableAttribute("0")]
public ConsList`1<T> Tail { get; }
    public ConsList`1(T head, ConsList`1<T> tail);
    private static ConsList`1();
    public T get_Head();
    public ConsList`1<T> get_Tail();
    public bool Any();
    public ConsList`1<T> Push(T value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    public Enumerator<T> GetEnumerator();
    public virtual string ToString();
}
internal static class Roslyn.Utilities.CorLightup : object {
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.DecimalUtilities : object {
    [ExtensionAttribute]
public static int GetScale(decimal value);
    [ExtensionAttribute]
public static void GetBits(decimal value, Boolean& isNegative, Byte& scale, UInt32& low, UInt32& mid, UInt32& high);
}
internal static class Roslyn.Utilities.DesktopShim : object {
}
internal static class Roslyn.Utilities.DocumentationCommentXmlNames : object {
    public static string CElementName;
    public static string CodeElementName;
    public static string CompletionListElementName;
    public static string DescriptionElementName;
    public static string ExampleElementName;
    public static string ExceptionElementName;
    public static string IncludeElementName;
    public static string ItemElementName;
    public static string ListElementName;
    public static string ListHeaderElementName;
    public static string ParaElementName;
    public static string ParameterElementName;
    public static string ParameterReferenceElementName;
    public static string PermissionElementName;
    public static string PlaceholderElementName;
    public static string PreliminaryElementName;
    public static string RemarksElementName;
    public static string ReturnsElementName;
    public static string SeeElementName;
    public static string SeeAlsoElementName;
    public static string SummaryElementName;
    public static string TermElementName;
    public static string ThreadSafetyElementName;
    public static string TypeParameterElementName;
    public static string TypeParameterReferenceElementName;
    public static string ValueElementName;
    public static string CrefAttributeName;
    public static string FileAttributeName;
    public static string InstanceAttributeName;
    public static string LangwordAttributeName;
    public static string NameAttributeName;
    public static string PathAttributeName;
    public static string StaticAttributeName;
    public static string TypeAttributeName;
    public static bool ElementEquals(string name1, string name2, bool fromVb);
    public static bool AttributeEquals(string name1, string name2);
    public static bool Equals(object left, object right);
}
internal class Roslyn.Utilities.EmptyComparer : object {
    public static EmptyComparer Instance;
    private static EmptyComparer();
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object a, object b);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Object>.GetHashCode(object s);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.EncodingExtensions : object {
    [ExtensionAttribute]
internal static int GetMaxCharCountOrThrowIfHuge(Encoding encoding, Stream stream);
    [ExtensionAttribute]
internal static bool TryGetMaxCharCount(Encoding encoding, long length, Int32& maxCharCount);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.EnumerableExtensions : object {
    private static Func`2<object, bool> s_notNullTest;
    private static EnumerableExtensions();
    [ExtensionAttribute]
public static IEnumerable`1<T> Do(IEnumerable`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnlyCollection(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> source, T value);
    [IteratorStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<ConcatWorker>d__3`1")]
[ExtensionAttribute]
private static IEnumerable`1<T> ConcatWorker(IEnumerable`1<T> source, T value);
    [ExtensionAttribute]
public static bool SetEquals(IEnumerable`1<T> source1, IEnumerable`1<T> source2, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool SetEquals(IEnumerable`1<T> source1, IEnumerable`1<T> source2);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static Nullable`1<T> FirstOrNullable(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static Nullable`1<T> FirstOrNullable(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static Nullable`1<T> LastOrNullable(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsSingle(IEnumerable`1<T> list);
    [ExtensionAttribute]
public static bool IsEmpty(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(IReadOnlyCollection`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(ICollection`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(string source);
    [ExtensionAttribute]
public static bool IsEmpty(T[] source);
    [ExtensionAttribute]
public static bool IsEmpty(List`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static bool All(IEnumerable`1<bool> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Flatten(IEnumerable`1<IEnumerable`1<T>> sequence);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderBy(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderBy(IEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> Order(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> ThenBy(IOrderedEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> ThenBy(IOrderedEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> ThenBy(IOrderedEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsSorted(IEnumerable`1<T> enumerable, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<T> sequence, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<string> sequence, string s);
    [ExtensionAttribute]
public static IComparer`1<T> ToComparer(Comparison`1<T> comparison);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Roslyn.Utilities.EnumField : ValueType {
    public static IComparer`1<EnumField> Comparer;
    public string Name;
    public ulong Value;
    public object IdentityOpt;
    public bool IsDefault { get; }
    public EnumField(string name, ulong value, object identityOpt);
    private static EnumField();
    public bool get_IsDefault();
    private string GetDebuggerDisplay();
    internal static EnumField FindValue(ArrayBuilder`1<EnumField> sortedFields, ulong value);
}
internal static class Roslyn.Utilities.EnumUtilities : object {
    internal static ulong ConvertEnumUnderlyingTypeToUInt64(object value, SpecialType specialType);
    internal static T[] GetValues();
}
internal static class Roslyn.Utilities.ExceptionUtilities : object {
    internal static Exception Unreachable { get; }
    internal static Exception UnexpectedValue(object o);
    internal static Exception get_Unreachable();
}
internal class Roslyn.Utilities.FileKey : ValueType {
    public string FullPath;
    public DateTime Timestamp;
    public FileKey(string fullPath, DateTime timestamp);
    public static FileKey Create(string fullPath);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public sealed virtual bool Equals(FileKey other);
}
internal static class Roslyn.Utilities.FileNameUtilities : object {
    private static string DirectorySeparatorStr;
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static char VolumeSeparatorChar;
    internal static bool IsFileName(string path);
    private static int IndexOfExtension(string path);
    internal static string GetExtension(string path);
    private static string RemoveExtension(string path);
    internal static string ChangeExtension(string path, string extension);
    internal static int IndexOfFileName(string path);
    internal static string GetFileName(string path, bool includeExtension);
}
internal static class Roslyn.Utilities.FileUtilities : object {
    private static Char[] s_invalidPathChars;
    private static FileUtilities();
    internal static string ResolveRelativePath(string path, string basePath, string baseDirectory, IEnumerable`1<string> searchPaths, Func`2<string, bool> fileExists);
    internal static string ResolveRelativePath(string path, string baseDirectory);
    internal static string ResolveRelativePath(string path, string basePath, string baseDirectory);
    private static string ResolveRelativePath(PathKind kind, string path, string basePath, string baseDirectory);
    private static string GetBaseDirectory(string basePath, string baseDirectory);
    internal static string NormalizeRelativePath(string path, string basePath, string baseDirectory);
    internal static string NormalizeAbsolutePath(string path);
    internal static string NormalizeDirectoryPath(string path);
    internal static string TryNormalizeAbsolutePath(string path);
    internal static Stream OpenRead(string fullPath);
    internal static Stream OpenAsyncRead(string fullPath);
    internal static T RethrowExceptionsAsIOException(Func`1<T> operation);
    internal static Stream CreateFileStreamChecked(Func`2<string, Stream> factory, string path, string paramName);
    internal static DateTime GetFileTimeStamp(string fullPath);
    internal static long GetFileLength(string fullPath);
    internal static Stream OpenFileStream(string path);
}
internal static class Roslyn.Utilities.Functions`1 : object {
    public static Func`2<T, T> Identity;
    public static Func`2<T, bool> True;
    private static Functions`1();
}
internal static class Roslyn.Utilities.GeneratedCodeUtilities : object {
    private static String[] s_autoGeneratedStrings;
    private static GeneratedCodeUtilities();
    internal static bool IsGeneratedSymbolWithGeneratedCodeAttribute(ISymbol symbol, INamedTypeSymbol generatedCodeAttribute);
    internal static bool IsGeneratedCode(SyntaxTree tree, Func`2<SyntaxTrivia, bool> isComment, CancellationToken cancellationToken);
    private static bool IsGeneratedCodeFile(string filePath);
    private static bool BeginsWithAutoGeneratedComment(SyntaxTree tree, Func`2<SyntaxTrivia, bool> isComment, CancellationToken cancellationToken);
}
internal static class Roslyn.Utilities.Hash : object {
    internal static int FnvOffsetBias;
    internal static int FnvPrime;
    internal static int Combine(int newKey, int currentKey);
    internal static int Combine(bool newKeyPart, int currentKey);
    internal static int Combine(T newKeyPart, int currentKey);
    internal static int CombineValues(IEnumerable`1<T> values, int maxItemsToHash);
    internal static int CombineValues(T[] values, int maxItemsToHash);
    internal static int CombineValues(ImmutableArray`1<T> values, int maxItemsToHash);
    internal static int CombineValues(IEnumerable`1<string> values, StringComparer stringComparer, int maxItemsToHash);
    internal static int GetFNVHashCode(Byte[] data);
    internal static int GetFNVHashCode(Byte* data, int length, Boolean& isAscii);
    internal static int GetFNVHashCode(ImmutableArray`1<byte> data);
    internal static int GetFNVHashCode(string text, int start, int length);
    internal static int GetCaseInsensitiveFNVHashCode(string text);
    internal static int GetCaseInsensitiveFNVHashCode(string text, int start, int length);
    internal static int GetFNVHashCode(string text, int start);
    internal static int GetFNVHashCode(string text);
    internal static int GetFNVHashCode(StringBuilder text);
    internal static int GetFNVHashCode(Char[] text, int start, int length);
    internal static int GetFNVHashCode(char ch);
    internal static int CombineFNVHash(int hashCode, string text);
    internal static int CombineFNVHash(int hashCode, char ch);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
internal static ImmutableArray`1<T> ToImmutableArrayOrEmpty(IEnumerable`1<T> items);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> ToImmutableArrayOrEmpty(ImmutableArray`1<T> items);
    [ExtensionAttribute]
internal static int BinarySearch(ImmutableArray`1<TElement> array, TValue value, Func`3<TElement, TValue, int> comparer);
    [ExtensionAttribute]
internal static ImmutableArray`1<TDerived> CastDown(ImmutableArray`1<TOriginal> array);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableByteArrayInterop : object {
    [ExtensionAttribute]
internal static Byte[] DangerousGetUnderlyingArray(ImmutableArray`1<byte> array);
    internal static ImmutableArray`1<byte> DangerousCreateFromUnderlyingArray(Byte[]& array);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableInt32ArrayInterop : object {
    [ExtensionAttribute]
internal static Int32[] DangerousGetUnderlyingArray(ImmutableArray`1<int> array);
    internal static ImmutableArray`1<int> DangerousCreateFromUnderlyingArray(Int32[]& array);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableListExtensions : object {
    [ExtensionAttribute]
internal static ImmutableList`1<T> ToImmutableListOrEmpty(T[] items);
    [ExtensionAttribute]
internal static ImmutableList`1<T> ToImmutableListOrEmpty(IEnumerable`1<T> items);
}
internal class Roslyn.Utilities.ImmutableSetWithInsertionOrder`1 : object {
    public static ImmutableSetWithInsertionOrder`1<T> Empty;
    private ImmutableDictionary`2<T, UInt32> _map;
    private UInt32 _nextElementValue;
    public int Count { get; }
    public IEnumerable`1<T> InInsertionOrder { get; }
    private ImmutableSetWithInsertionOrder`1(ImmutableDictionary`2<T, UInt32> map, UInt32 nextElementValue);
    private static ImmutableSetWithInsertionOrder`1();
    public int get_Count();
    public bool Contains(T value);
    public ImmutableSetWithInsertionOrder`1<T> Add(T value);
    public ImmutableSetWithInsertionOrder`1<T> Remove(T value);
    public IEnumerable`1<T> get_InInsertionOrder();
    public virtual string ToString();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.IncrementalHashExtensions : object {
    [ExtensionAttribute]
internal static void AppendData(IncrementalHash hash, IEnumerable`1<Blob> blobs);
    [ExtensionAttribute]
internal static void AppendData(IncrementalHash hash, IEnumerable`1<ArraySegment`1<byte>> blobs);
    [ExtensionAttribute]
internal static void AppendData(IncrementalHash hash, ArraySegment`1<byte> segment);
}
internal static class Roslyn.Utilities.InterlockedOperations : object {
    public static T Initialize(T& target, T value);
    public static T Initialize(T& target, T initializedValue, T uninitializedValue);
    public static ImmutableArray`1<T> Initialize(ImmutableArray`1& target, ImmutableArray`1<T> initializedValue);
}
internal interface Roslyn.Utilities.IObjectWritable {
    public bool ShouldReuseInSerialization { get; }
    public abstract virtual void WriteTo(ObjectWriter writer);
    public abstract virtual bool get_ShouldReuseInSerialization();
}
internal interface Roslyn.Utilities.IReadOnlySet`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool Contains(T item);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ISetExtensions : object {
    [ExtensionAttribute]
public static bool AddAll(ISet`1<T> set, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool RemoveAll(ISet`1<T> set, IEnumerable`1<T> values);
}
internal class Roslyn.Utilities.JsonWriter : object {
    private TextWriter _output;
    private int _indent;
    private Pending _pending;
    private static string Indentation;
    public JsonWriter(TextWriter output);
    public void WriteObjectStart();
    public void WriteObjectStart(string key);
    public void WriteObjectEnd();
    public void WriteArrayStart();
    public void WriteArrayStart(string key);
    public void WriteArrayEnd();
    public void WriteKey(string key);
    public void Write(string key, string value);
    public void Write(string key, int value);
    public void Write(string key, bool value);
    public void Write(string value);
    public void Write(int value);
    public void Write(bool value);
    private void WritePending();
    private void WriteStart(char c);
    private void WriteEnd(char c);
    public sealed virtual void Dispose();
    private static string EscapeString(string value);
    private static void AppendCharAsUnicode(StringBuilder builder, char c);
    private static bool ShouldAppendAsUnicode(char c);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.KeyValuePairUtil : object {
    public static KeyValuePair`2<K, V> Create(K key, V value);
    [ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> keyValuePair, TKey& key, TValue& value);
}
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.MultiDictionary`2 : object {
    private Dictionary`2<K, ValueSet<K, V>> _dictionary;
    public int Count { get; }
    public IEnumerable`1<K> Keys { get; }
    public ValueSet<K, V> Item { get; }
    public MultiDictionary`2(IEqualityComparer`1<K> comparer);
    public MultiDictionary`2(int capacity, IEqualityComparer`1<K> comparer);
    public int get_Count();
    public IEnumerable`1<K> get_Keys();
    public ValueSet<K, V> get_Item(K k);
    public void Add(K k, V v);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<K, ValueSet<K, V>>> GetEnumerator();
    public bool ContainsKey(K k);
    internal void Clear();
    public void Remove(K key);
}
internal class Roslyn.Utilities.NoThrowStreamDisposer : object {
    private Nullable`1<bool> _failed;
    private string _filePath;
    private DiagnosticBag _diagnostics;
    private CommonMessageProvider _messageProvider;
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    public Stream Stream { get; }
    public bool HasFailedToDispose { get; }
    public NoThrowStreamDisposer(Stream stream, string filePath, DiagnosticBag diagnostics, CommonMessageProvider messageProvider);
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    public bool get_HasFailedToDispose();
    public sealed virtual void Dispose();
}
internal static class Roslyn.Utilities.ObjectBinder : object {
    private static object s_gate;
    private static Nullable`1<ObjectBinderSnapshot> s_lastSnapshot;
    private static Dictionary`2<Type, int> s_typeToIndex;
    private static List`1<Type> s_types;
    private static List`1<Func`2<ObjectReader, IObjectWritable>> s_typeReaders;
    private static ObjectBinder();
    public static ObjectBinderSnapshot GetSnapshot();
    public static void RegisterTypeReader(Type type, Func`2<ObjectReader, IObjectWritable> typeReader);
}
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.ObjectBinderSnapshot : ValueType {
    private Dictionary`2<Type, int> _typeToIndex;
    private ImmutableArray`1<Type> _types;
    private ImmutableArray`1<Func`2<ObjectReader, IObjectWritable>> _typeReaders;
    public ObjectBinderSnapshot(Dictionary`2<Type, int> typeToIndex, List`1<Type> types, List`1<Func`2<ObjectReader, IObjectWritable>> typeReaders);
    public int GetTypeId(Type type);
    public Type GetTypeFromId(int typeId);
    public Func`2<ObjectReader, IObjectWritable> GetTypeReaderFromId(int typeId);
}
internal class Roslyn.Utilities.ObjectReader : object {
    internal static byte VersionByte1;
    internal static byte VersionByte2;
    private BinaryReader _reader;
    private CancellationToken _cancellationToken;
    private ReaderReferenceMap`1<object> _objectReferenceMap;
    private ReaderReferenceMap`1<string> _stringReferenceMap;
    private ObjectBinderSnapshot _binderSnapshot;
    private int _recursionDepth;
    private ObjectReader(Stream stream, CancellationToken cancellationToken);
    public static ObjectReader TryGetReader(Stream stream, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    public bool ReadBoolean();
    public byte ReadByte();
    public char ReadChar();
    public decimal ReadDecimal();
    public double ReadDouble();
    public float ReadSingle();
    public int ReadInt32();
    public long ReadInt64();
    public sbyte ReadSByte();
    public short ReadInt16();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public ushort ReadUInt16();
    public string ReadString();
    public Guid ReadGuid();
    public object ReadValue();
    private object ReadValueWorker();
    internal UInt32 ReadCompressedUInt();
    private string ReadStringValue();
    private string ReadStringValue(EncodingKind kind);
    private string ReadStringLiteral(EncodingKind kind);
    private Array ReadArray(EncodingKind kind);
    private Array ReadPrimitiveTypeArrayElements(Type type, EncodingKind kind, int length);
    private Boolean[] ReadBooleanArrayElements(Boolean[] array);
    private static T[] CreateArray(int length);
    private String[] ReadStringArrayElements(String[] array);
    private SByte[] ReadInt8ArrayElements(SByte[] array);
    private Int16[] ReadInt16ArrayElements(Int16[] array);
    private Int32[] ReadInt32ArrayElements(Int32[] array);
    private Int64[] ReadInt64ArrayElements(Int64[] array);
    private UInt16[] ReadUInt16ArrayElements(UInt16[] array);
    private UInt32[] ReadUInt32ArrayElements(UInt32[] array);
    private UInt64[] ReadUInt64ArrayElements(UInt64[] array);
    private Decimal[] ReadDecimalArrayElements(Decimal[] array);
    private Single[] ReadFloat4ArrayElements(Single[] array);
    private Double[] ReadFloat8ArrayElements(Double[] array);
    public Type ReadType();
    private Type ReadTypeAfterTag();
    private object ReadObject();
    private static Exception DeserializationReadIncorrectNumberOfValuesException(string typeName);
    private static Exception NoSerializationTypeException(string typeName);
    private static Exception NoSerializationReaderException(string typeName);
    [CompilerGeneratedAttribute]
private object <ReadValue>b__26_0();
}
internal class Roslyn.Utilities.ObjectWriter : object {
    private BinaryWriter _writer;
    private CancellationToken _cancellationToken;
    private WriterReferenceMap _objectReferenceMap;
    private WriterReferenceMap _stringReferenceMap;
    private ObjectBinderSnapshot _binderSnapshot;
    private int _recursionDepth;
    internal static int MaxRecursionDepth;
    internal static Dictionary`2<Type, EncodingKind> s_typeMap;
    internal static ImmutableArray`1<Type> s_reverseTypeMap;
    internal static byte ByteMarkerMask;
    internal static byte Byte1Marker;
    internal static byte Byte2Marker;
    internal static byte Byte4Marker;
    public ObjectWriter(Stream stream, CancellationToken cancellationToken);
    private static ObjectWriter();
    private void WriteVersion();
    public sealed virtual void Dispose();
    public void WriteBoolean(bool value);
    public void WriteByte(byte value);
    public void WriteChar(char ch);
    public void WriteDecimal(decimal value);
    public void WriteDouble(double value);
    public void WriteSingle(float value);
    public void WriteInt32(int value);
    public void WriteInt64(long value);
    public void WriteSByte(sbyte value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteUInt64(ulong value);
    public void WriteUInt16(ushort value);
    public void WriteString(string value);
    public void WriteGuid(Guid guid);
    public void WriteValue(object value);
    public void WriteValue(IObjectWritable value);
    private void WriteEncodedInt32(int v);
    private void WriteEncodedUInt32(UInt32 v);
    internal void WriteCompressedUInt(UInt32 value);
    private void WriteStringValue(string value);
    private void WriteArray(Array array);
    private void WriteArrayValues(Array array);
    private void WritePrimitiveTypeArrayElements(Type type, EncodingKind kind, Array instance);
    private void WriteBooleanArrayElements(Boolean[] array);
    private void WriteStringArrayElements(String[] array);
    private void WriteInt8ArrayElements(SByte[] array);
    private void WriteInt16ArrayElements(Int16[] array);
    private void WriteInt32ArrayElements(Int32[] array);
    private void WriteInt64ArrayElements(Int64[] array);
    private void WriteUInt16ArrayElements(UInt16[] array);
    private void WriteUInt32ArrayElements(UInt32[] array);
    private void WriteUInt64ArrayElements(UInt64[] array);
    private void WriteDecimalArrayElements(Decimal[] array);
    private void WriteFloat4ArrayElements(Single[] array);
    private void WriteFloat8ArrayElements(Double[] array);
    private void WritePrimitiveType(Type type, EncodingKind kind);
    public void WriteType(Type type);
    private void WriteKnownType(Type type);
    private void WriteObject(object instance, IObjectWritable instanceAsWritableOpt);
    private void WriteObjectWorker(IObjectWritable writable);
    private static Exception NoSerializationTypeException(string typeName);
    private static Exception NoSerializationWriterException(string typeName);
    [CompilerGeneratedAttribute]
private void <WriteArray>b__33_0(object a);
    [CompilerGeneratedAttribute]
private void <WriteObject>b__51_0(object obj);
}
internal static class Roslyn.Utilities.OneOrMany : object {
    public static OneOrMany`1<T> Create(T one);
    public static OneOrMany`1<T> Create(ImmutableArray`1<T> many);
}
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.OneOrMany`1 : ValueType {
    private T _one;
    private ImmutableArray`1<T> _many;
    public T Item { get; }
    public int Count { get; }
    public OneOrMany`1(T one);
    public OneOrMany`1(ImmutableArray`1<T> many);
    public T get_Item(int index);
    public int get_Count();
    public OneOrMany`1<T> Add(T one);
    public bool Contains(T item);
    public OneOrMany`1<T> RemoveAll(T item);
    public Enumerator<T> GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.OrderedMultiDictionary`2 : object {
    private Dictionary`2<K, SetWithInsertionOrder`1<V>> _dictionary;
    private List`1<K> _keys;
    public int Count { get; }
    public IEnumerable`1<K> Keys { get; }
    public SetWithInsertionOrder`1<V> Item { get; }
    public int get_Count();
    public IEnumerable`1<K> get_Keys();
    public SetWithInsertionOrder`1<V> get_Item(K k);
    public void Add(K k, V v);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("Roslyn.Utilities.OrderedMultiDictionary`2/<GetEnumerator>d__11")]
public sealed virtual IEnumerator`1<KeyValuePair`2<K, SetWithInsertionOrder`1<V>>> GetEnumerator();
}
internal enum Roslyn.Utilities.PathKind : Enum {
    public int value__;
    public static PathKind Empty;
    public static PathKind Relative;
    public static PathKind RelativeToCurrentDirectory;
    public static PathKind RelativeToCurrentParent;
    public static PathKind RelativeToCurrentRoot;
    public static PathKind RelativeToDriveDirectory;
    public static PathKind Absolute;
}
internal static class Roslyn.Utilities.PathUtilities : object {
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static string ParentRelativeDirectory;
    internal static string ThisDirectory;
    internal static string DirectorySeparatorStr;
    internal static char VolumeSeparatorChar;
    private static Char[] s_pathChars;
    public static IEqualityComparer`1<string> Comparer;
    internal static bool IsUnixLikePlatform { get; }
    private static PathUtilities();
    internal static bool get_IsUnixLikePlatform();
    public static bool IsDirectorySeparator(char c);
    public static bool IsAnyDirectorySeparator(char c);
    public static string TrimTrailingSeparators(string s);
    public static string EnsureTrailingSeparator(string s);
    public static string GetExtension(string path);
    public static string ChangeExtension(string path, string extension);
    public static string RemoveExtension(string path);
    public static string GetFileName(string path, bool includeExtension);
    public static string GetDirectoryName(string path);
    internal static string GetDirectoryName(string path, bool isUnixLike);
    internal static bool IsSameDirectoryOrChildOf(string child, string parent);
    public static string GetPathRoot(string path);
    private static string GetPathRoot(string path, bool isUnixLike);
    private static string GetWindowsRoot(string path);
    private static int ConsumeDirectorySeparators(string path, int length, int i);
    private static string GetUnixRoot(string path);
    public static PathKind GetPathKind(string path);
    public static bool IsAbsolute(string path);
    private static bool IsDriveRootedAbsolutePath(string path);
    public static string CombineAbsoluteAndRelativePaths(string root, string relativePath);
    public static string CombinePossiblyRelativeAndRelativePaths(string rootOpt, string relativePath);
    public static string CombinePathsUnchecked(string root, string relativePath);
    private static string RemoveTrailingDirectorySeparator(string path);
    public static bool IsFilePath(string assemblyDisplayNameOrPath);
    public static bool ContainsPathComponent(string path, string component, bool ignoreCase);
    public static string GetRelativePath(string directory, string fullPath);
    public static bool IsChildPath(string parentPath, string childPath);
    private static string GetRelativeChildPath(string parentPath, string childPath);
    private static String[] GetPathParts(string path);
    public static bool PathsEqual(string path1, string path2);
    private static bool PathsEqual(string path1, string path2, int length);
    private static bool PathCharEqual(char x, char y);
    private static int PathHashCode(string path);
    public static string NormalizePathPrefix(string filePath, ImmutableArray`1<KeyValuePair`2<string, string>> pathMap);
    public static bool IsValidFilePath(string fullPath);
}
[ConditionalAttribute("EMIT_CODE_ANALYSIS_ATTRIBUTES")]
[AttributeUsageAttribute("480")]
internal class Roslyn.Utilities.PerformanceSensitiveAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Constraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowCaptures>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowGenericEnumeration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowLocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OftenCompletesSynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParallelEntry>k__BackingField;
    public string Uri { get; }
    public string Constraint { get; public set; }
    public bool AllowCaptures { get; public set; }
    public bool AllowGenericEnumeration { get; public set; }
    public bool AllowLocks { get; public set; }
    public bool OftenCompletesSynchronously { get; public set; }
    public bool IsParallelEntry { get; public set; }
    public PerformanceSensitiveAttribute(string uri);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public string get_Constraint();
    [CompilerGeneratedAttribute]
public void set_Constraint(string value);
    [CompilerGeneratedAttribute]
public bool get_AllowCaptures();
    [CompilerGeneratedAttribute]
public void set_AllowCaptures(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowGenericEnumeration();
    [CompilerGeneratedAttribute]
public void set_AllowGenericEnumeration(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowLocks();
    [CompilerGeneratedAttribute]
public void set_AllowLocks(bool value);
    [CompilerGeneratedAttribute]
public bool get_OftenCompletesSynchronously();
    [CompilerGeneratedAttribute]
public void set_OftenCompletesSynchronously(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsParallelEntry();
    [CompilerGeneratedAttribute]
public void set_IsParallelEntry(bool value);
}
internal static class Roslyn.Utilities.PlatformInformation : object {
    public static bool IsWindows { get; }
    public static bool IsUnix { get; }
    public static bool IsRunningOnMono { get; }
    public static bool get_IsWindows();
    public static bool get_IsUnix();
    public static bool get_IsRunningOnMono();
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ReaderWriterLockSlimExtensions : object {
    [ExtensionAttribute]
internal static ReadLockExiter DisposableRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static WriteLockExiter DisposableWrite(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static void AssertCanRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static void AssertCanWrite(ReaderWriterLockSlim lock);
}
internal class Roslyn.Utilities.ReferenceEqualityComparer : object {
    public static ReferenceEqualityComparer Instance;
    private static ReferenceEqualityComparer();
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object a, object b);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Object>.GetHashCode(object a);
    public static int GetHashCode(object a);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ReflectionUtilities : object {
    private static Type Missing;
    private static ReflectionUtilities();
    public static Type TryGetType(string assemblyQualifiedName);
    public static Type TryGetType(Type& lazyType, string assemblyQualifiedName);
    public static Type GetTypeFromEither(string contractName, string desktopName);
    public static Type GetTypeFromEither(Type& lazyType, string contractName, string desktopName);
    public static T FindItem(IEnumerable`1<T> collection, Type[] paramTypes);
    [ExtensionAttribute]
internal static MethodInfo GetDeclaredMethod(TypeInfo typeInfo, string name, Type[] paramTypes);
    [ExtensionAttribute]
internal static ConstructorInfo GetDeclaredConstructor(TypeInfo typeInfo, Type[] paramTypes);
    [ExtensionAttribute]
public static T CreateDelegate(MethodInfo methodInfo);
    [ExtensionAttribute]
public static T InvokeConstructor(ConstructorInfo constructorInfo, Object[] args);
    [ExtensionAttribute]
public static object InvokeConstructor(ConstructorInfo constructorInfo, Object[] args);
    [ExtensionAttribute]
public static T Invoke(MethodInfo methodInfo, object obj, Object[] args);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.SemaphoreExtensions : object {
    [ExtensionAttribute]
public static SemaphoreDisposer DisposableWait(Semaphore semaphore, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<SemaphoreDisposer> DisposableWaitAsync(Semaphore semaphore, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.SemaphoreSlimExtensions : object {
    [ExtensionAttribute]
public static SemaphoreDisposer DisposableWait(SemaphoreSlim semaphore, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslyn.Utilities.SemaphoreSlimExtensions/<DisposableWaitAsync>d__1")]
[ExtensionAttribute]
public static Task`1<SemaphoreDisposer> DisposableWaitAsync(SemaphoreSlim semaphore, CancellationToken cancellationToken);
}
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.SetWithInsertionOrder`1 : object {
    private HashSet`1<T> _set;
    private ArrayBuilder`1<T> _elements;
    public int Count { get; }
    public T Item { get; }
    public bool Add(T value);
    public bool Insert(int index, T value);
    public bool Remove(T value);
    public sealed virtual int get_Count();
    public sealed virtual bool Contains(T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ImmutableArray`1<T> AsImmutable();
    public T get_Item(int i);
}
internal static class Roslyn.Utilities.SpecializedCollections : object {
    public static IEnumerator`1<T> EmptyEnumerator();
    public static IEnumerable`1<T> EmptyEnumerable();
    public static ICollection`1<T> EmptyCollection();
    public static IList`1<T> EmptyList();
    public static IReadOnlyList`1<T> EmptyReadOnlyList();
    public static ISet`1<T> EmptySet();
    public static IReadOnlySet`1<T> EmptyReadOnlySet();
    public static IDictionary`2<TKey, TValue> EmptyDictionary();
    public static IReadOnlyDictionary`2<TKey, TValue> EmptyReadOnlyDictionary();
    public static IEnumerable`1<T> SingletonEnumerable(T value);
    public static ICollection`1<T> SingletonCollection(T value);
    public static IEnumerator`1<T> SingletonEnumerator(T value);
    public static IList`1<T> SingletonList(T value);
    public static IEnumerable`1<T> ReadOnlyEnumerable(IEnumerable`1<T> values);
    public static ICollection`1<T> ReadOnlyCollection(ICollection`1<T> collection);
    public static ISet`1<T> ReadOnlySet(ISet`1<T> set);
    public static IReadOnlySet`1<T> StronglyTypedReadOnlySet(ISet`1<T> set);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.StreamExtensions : object {
    [ExtensionAttribute]
public static int TryReadAll(Stream stream, Byte[] buffer, int offset, int count);
    [ExtensionAttribute]
public static Byte[] ReadAllBytes(Stream stream);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.StringExtensions : object {
    private static ImmutableArray`1<string> s_lazyNumerals;
    private static Func`2<char, char> s_toLower;
    private static Func`2<char, char> s_toUpper;
    private static StringExtensions();
    internal static string GetNumeral(int number);
    [ExtensionAttribute]
public static string Join(IEnumerable`1<string> source, string separator);
    [ExtensionAttribute]
public static bool LooksLikeInterfaceName(string name);
    [ExtensionAttribute]
public static bool LooksLikeTypeParameterName(string name);
    [ExtensionAttribute]
public static string ToPascalCase(string shortName, bool trimLeadingTypePrefix);
    [ExtensionAttribute]
public static string ToCamelCase(string shortName, bool trimLeadingTypePrefix);
    [ExtensionAttribute]
private static string ConvertCase(string shortName, bool trimLeadingTypePrefix, Func`2<char, char> convert);
    [ExtensionAttribute]
internal static bool IsValidClrTypeName(string name);
    [ExtensionAttribute]
internal static bool IsValidClrNamespaceName(string name);
    [ExtensionAttribute]
internal static string GetWithSingleAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool TryGetWithoutAttributeSuffix(string name, String& result);
    [ExtensionAttribute]
internal static string GetWithoutAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool TryGetWithoutAttributeSuffix(string name, bool isCaseSensitive, String& result);
    [ExtensionAttribute]
internal static bool IsValidUnicodeString(string str);
    [ExtensionAttribute]
internal static string Unquote(string arg);
    [ExtensionAttribute]
internal static string Unquote(string arg, Boolean& quoted);
    [ExtensionAttribute]
internal static int IndexOfBalancedParenthesis(string str, int openingOffset, char closing);
    [ExtensionAttribute]
internal static char First(string arg);
    [ExtensionAttribute]
internal static char Last(string arg);
    [ExtensionAttribute]
internal static bool All(string arg, Predicate`1<char> predicate);
    [ExtensionAttribute]
public static int GetCaseInsensitivePrefixLength(string string1, string string2);
}
internal class Roslyn.Utilities.StringOrdinalComparer : object {
    public static StringOrdinalComparer Instance;
    private static StringOrdinalComparer();
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.String>.Equals(string a, string b);
    public static bool Equals(string a, string b);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.String>.GetHashCode(string s);
}
internal class Roslyn.Utilities.StringTable : object {
    private static int LocalSizeBits;
    private static int LocalSize;
    private static int LocalSizeMask;
    private static int SharedSizeBits;
    private static int SharedSize;
    private static int SharedSizeMask;
    private static int SharedBucketBits;
    private static int SharedBucketSize;
    private static int SharedBucketSizeMask;
    private Entry[] _localTable;
    private static Entry[] s_sharedTable;
    private int _localRandom;
    private static int s_sharedRandom;
    private ObjectPool`1<StringTable> _pool;
    private static ObjectPool`1<StringTable> s_staticPool;
    private StringTable(ObjectPool`1<StringTable> pool);
    private static StringTable();
    private static ObjectPool`1<StringTable> CreatePool();
    public static StringTable GetInstance();
    public void Free();
    internal string Add(Char[] chars, int start, int len);
    internal string Add(string chars, int start, int len);
    internal string Add(char chars);
    internal string Add(StringBuilder chars);
    internal string Add(string chars);
    private static string FindSharedEntry(Char[] chars, int start, int len, int hashCode);
    private static string FindSharedEntry(string chars, int start, int len, int hashCode);
    private static string FindSharedEntryASCII(int hashCode, Byte* asciiChars, int length);
    private static string FindSharedEntry(char chars, int hashCode);
    private static string FindSharedEntry(StringBuilder chars, int hashCode);
    private static string FindSharedEntry(string chars, int hashCode);
    private string AddItem(Char[] chars, int start, int len, int hashCode);
    private string AddItem(string chars, int start, int len, int hashCode);
    private string AddItem(char chars, int hashCode);
    private string AddItem(StringBuilder chars, int hashCode);
    private void AddCore(string chars, int hashCode);
    private void AddSharedEntry(int hashCode, string text);
    internal static string AddShared(StringBuilder chars);
    private static string AddSharedSlow(int hashCode, StringBuilder builder);
    internal static string AddSharedUTF8(Byte* bytes, int byteCount);
    private static string AddSharedSlow(int hashCode, Byte* utf8Bytes, int byteCount, bool isAscii);
    private static void AddSharedSlow(int hashCode, string text);
    private static int LocalIdxFromHash(int hash);
    private static int SharedIdxFromHash(int hash);
    private int LocalNextRandom();
    private static int SharedNextRandom();
    internal static bool TextEquals(string array, string text, int start, int length);
    internal static bool TextEquals(string array, StringBuilder text);
    internal static bool TextEqualsASCII(string text, Byte* ascii, int length);
    internal static bool TextEquals(string array, Char[] text, int start, int length);
    private static bool TextEqualsCore(string array, Char[] text, int start);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.TextChangeRangeExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<TextChangeRange> Accumulate(Nullable`1<TextChangeRange> accumulatedTextChangeSoFar, IEnumerable`1<TextChangeRange> changesInNextVersion);
}
internal class Roslyn.Utilities.TextKeyedCache`1 : object {
    private static int LocalSizeBits;
    private static int LocalSize;
    private static int LocalSizeMask;
    private static int SharedSizeBits;
    private static int SharedSize;
    private static int SharedSizeMask;
    private static int SharedBucketBits;
    private static int SharedBucketSize;
    private static int SharedBucketSizeMask;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`3[] _localTable;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2[] s_sharedTable;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _sharedTableInst;
    private StringTable _strings;
    private Random _random;
    private ObjectPool`1<TextKeyedCache`1<T>> _pool;
    private static ObjectPool`1<TextKeyedCache`1<T>> s_staticPool;
    private TextKeyedCache`1(ObjectPool`1<TextKeyedCache`1<T>> pool);
    private static TextKeyedCache`1();
    private static ObjectPool`1<TextKeyedCache`1<T>> CreatePool();
    public static TextKeyedCache`1<T> GetInstance();
    public void Free();
    internal T FindItem(Char[] chars, int start, int len, int hashCode);
    private SharedEntryValue<T> FindSharedEntry(Char[] chars, int start, int len, int hashCode);
    internal void AddItem(Char[] chars, int start, int len, int hashCode, T item);
    private void AddSharedEntry(int hashCode, SharedEntryValue<T> e);
    private static int LocalIdxFromHash(int hash);
    private static int SharedIdxFromHash(int hash);
    private int NextRandom();
}
internal static class Roslyn.Utilities.ThreadSafeFlagOperations : object {
    public static bool Set(Int32& flags, int toSet);
    public static bool Clear(Int32& flags, int toClear);
}
internal static class Roslyn.Utilities.UICultureUtilities : object {
    private static string currentUICultureName;
    private static Action`1<CultureInfo> s_setCurrentUICulture;
    private static UICultureUtilities();
    private static bool TryGetCurrentUICultureSetter(Action`1& setter);
    private static bool TryGetCurrentThreadUICultureSetter(Action`1& setter);
    public static Action WithCurrentUICulture(Action action);
    public static Action`1<T> WithCurrentUICulture(Action`1<T> action);
    public static Func`1<T> WithCurrentUICulture(Func`1<T> func);
}
internal static class Roslyn.Utilities.UnicodeCharacterUtilities : object {
    public static bool IsIdentifierStartCharacter(char ch);
    public static bool IsIdentifierPartCharacter(char ch);
    public static bool IsValidIdentifier(string name);
    private static bool IsLetterChar(UnicodeCategory cat);
    private static bool IsCombiningChar(UnicodeCategory cat);
    private static bool IsDecimalDigitChar(UnicodeCategory cat);
    private static bool IsConnectingChar(UnicodeCategory cat);
    internal static bool IsFormattingChar(char ch);
    private static bool IsFormattingChar(UnicodeCategory cat);
}
internal class Roslyn.Utilities.WeakList`1 : object {
    private WeakReference`1[] _items;
    private int _size;
    private static int MinimalNonEmptySize;
    public int WeakCount { get; }
    internal WeakReference`1[] TestOnly_UnderlyingArray { get; }
    private void Resize();
    private void Shrink(int firstDead, int alive);
    private static int GetExpandedSize(int baseSize);
    private void Compact(int firstDead, WeakReference`1[] result);
    public int get_WeakCount();
    public WeakReference`1<T> GetWeakReference(int index);
    public void Add(T item);
    [IteratorStateMachineAttribute("Roslyn.Utilities.WeakList`1/<GetEnumerator>d__12")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal WeakReference`1[] get_TestOnly_UnderlyingArray();
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.WeakReferenceExtensions : object {
    [ExtensionAttribute]
public static T GetTarget(WeakReference`1<T> reference);
    [ExtensionAttribute]
public static bool IsNull(WeakReference`1<T> reference);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.XmlUtilities : object {
    [ExtensionAttribute]
internal static TNode Copy(TNode node, bool copyAttributeAnnotations);
    private static void CopyAnnotations(XObject source, XObject target);
    internal static XElement[] TrySelectElements(XNode node, string xpath, String& errorMessage, Boolean& invalidXPath);
}
[ExtensionAttribute]
internal static class System.Linq.EnumerableExtensions : object {
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<T> first, IEnumerable`1<T> second, Func`3<T, T, bool> comparer);
}
[AttributeUsageAttribute("1024")]
internal class System.Runtime.CompilerServices.InternalImplementationOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
internal class System.Security.SuppressUnmanagedCodeSecurityAttribute : Attribute {
}
