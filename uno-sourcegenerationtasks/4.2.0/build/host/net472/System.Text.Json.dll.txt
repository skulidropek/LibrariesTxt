internal static class FxResources.System.Text.Json.SR : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class System.Buffers.ArrayBufferWriter`1 : object {
    private T[] _buffer;
    private int _index;
    private static int DefaultInitialBufferSize;
    public ReadOnlyMemory`1<T> WrittenMemory { get; }
    public ReadOnlySpan`1<T> WrittenSpan { get; }
    public int WrittenCount { get; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public ArrayBufferWriter`1(int initialCapacity);
    public ReadOnlyMemory`1<T> get_WrittenMemory();
    public ReadOnlySpan`1<T> get_WrittenSpan();
    public int get_WrittenCount();
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
    private void CheckAndResizeBuffer(int sizeHint);
    private static void ThrowInvalidOperationException_AdvancedTooFar(int capacity);
}
internal enum System.Buffers.Text.SequenceValidity : Enum {
    public int value__;
    public static SequenceValidity Empty;
    public static SequenceValidity WellFormed;
    public static SequenceValidity Incomplete;
    public static SequenceValidity Invalid;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ArrayDepthTooLarge { get; }
    internal static string CallFlushToAvoidDataLoss { get; }
    internal static string CannotReadIncompleteUTF16 { get; }
    internal static string CannotReadInvalidUTF16 { get; }
    internal static string CannotStartObjectArrayAfterPrimitiveOrClose { get; }
    internal static string CannotStartObjectArrayWithoutProperty { get; }
    internal static string CannotTranscodeInvalidUtf8 { get; }
    internal static string CannotDecodeInvalidBase64 { get; }
    internal static string CannotTranscodeInvalidUtf16 { get; }
    internal static string CannotEncodeInvalidUTF16 { get; }
    internal static string CannotEncodeInvalidUTF8 { get; }
    internal static string CannotWritePropertyWithinArray { get; }
    internal static string CannotWritePropertyAfterProperty { get; }
    internal static string CannotWriteValueAfterPrimitiveOrClose { get; }
    internal static string CannotWriteValueWithinObject { get; }
    internal static string DepthTooLarge { get; }
    internal static string EmptyJsonIsInvalid { get; }
    internal static string EndOfCommentNotFound { get; }
    internal static string EndOfStringNotFound { get; }
    internal static string ExpectedEndAfterSingleJson { get; }
    internal static string ExpectedEndOfDigitNotFound { get; }
    internal static string ExpectedFalse { get; }
    internal static string ExpectedJsonTokens { get; }
    internal static string ExpectedOneCompleteToken { get; }
    internal static string ExpectedNextDigitEValueNotFound { get; }
    internal static string ExpectedNull { get; }
    internal static string ExpectedSeparatorAfterPropertyNameNotFound { get; }
    internal static string ExpectedStartOfPropertyNotFound { get; }
    internal static string ExpectedStartOfPropertyOrValueNotFound { get; }
    internal static string ExpectedStartOfValueNotFound { get; }
    internal static string ExpectedTrue { get; }
    internal static string ExpectedValueAfterPropertyNameNotFound { get; }
    internal static string FailedToGetLargerSpan { get; }
    internal static string FoundInvalidCharacter { get; }
    internal static string InvalidCast { get; }
    internal static string InvalidCharacterAfterEscapeWithinString { get; }
    internal static string InvalidCharacterWithinString { get; }
    internal static string InvalidEndOfJsonNonPrimitive { get; }
    internal static string InvalidHexCharacterWithinString { get; }
    internal static string JsonDocumentDoesNotSupportComments { get; }
    internal static string JsonElementHasWrongType { get; }
    internal static string MaxDepthMustBePositive { get; }
    internal static string CommentHandlingMustBeValid { get; }
    internal static string MismatchedObjectArray { get; }
    internal static string CannotWriteEndAfterProperty { get; }
    internal static string ObjectDepthTooLarge { get; }
    internal static string PropertyNameTooLarge { get; }
    internal static string FormatDecimal { get; }
    internal static string FormatDouble { get; }
    internal static string FormatInt32 { get; }
    internal static string FormatInt64 { get; }
    internal static string FormatSingle { get; }
    internal static string FormatUInt32 { get; }
    internal static string FormatUInt64 { get; }
    internal static string RequiredDigitNotFoundAfterDecimal { get; }
    internal static string RequiredDigitNotFoundAfterSign { get; }
    internal static string RequiredDigitNotFoundEndOfData { get; }
    internal static string SpecialNumberValuesNotSupported { get; }
    internal static string ValueTooLarge { get; }
    internal static string ZeroDepthAtEnd { get; }
    internal static string DeserializeUnableToConvertValue { get; }
    internal static string DeserializeWrongType { get; }
    internal static string SerializationInvalidBufferSize { get; }
    internal static string BufferWriterAdvancedTooFar { get; }
    internal static string InvalidComparison { get; }
    internal static string FormatDateTime { get; }
    internal static string FormatDateTimeOffset { get; }
    internal static string FormatGuid { get; }
    internal static string ExpectedStartOfPropertyOrValueAfterComment { get; }
    internal static string TrailingCommaNotAllowedBeforeArrayEnd { get; }
    internal static string TrailingCommaNotAllowedBeforeObjectEnd { get; }
    internal static string SerializerOptionsImmutable { get; }
    internal static string StreamNotWritable { get; }
    internal static string CannotWriteCommentWithEmbeddedDelimiter { get; }
    internal static string SerializerPropertyNameConflict { get; }
    internal static string SerializerPropertyNameNull { get; }
    internal static string DeserializeDuplicateKey { get; }
    internal static string SerializationDataExtensionPropertyInvalid { get; }
    internal static string SerializationDuplicateTypeAttribute { get; }
    internal static string SerializationNotSupportedCollectionType { get; }
    internal static string SerializationNotSupportedCollection { get; }
    internal static string InvalidCharacterAtStartOfComment { get; }
    internal static string UnexpectedEndOfDataWhileReadingComment { get; }
    internal static string CannotSkip { get; }
    internal static string NotEnoughData { get; }
    internal static string UnexpectedEndOfLineSeparator { get; }
    internal static string JsonSerializerDoesNotSupportComments { get; }
    internal static string DeserializeMissingParameterlessConstructor { get; }
    internal static string DeserializePolymorphicInterface { get; }
    internal static string SerializationConverterOnAttributeNotCompatible { get; }
    internal static string SerializationConverterOnAttributeInvalid { get; }
    internal static string SerializationConverterRead { get; }
    internal static string SerializationConverterNotCompatible { get; }
    internal static string SerializationConverterWrite { get; }
    internal static string SerializerDictionaryKeyNull { get; }
    internal static string SerializationDuplicateAttribute { get; }
    internal static string SerializeUnableToSerialize { get; }
    internal static string FormatByte { get; }
    internal static string FormatInt16 { get; }
    internal static string FormatSByte { get; }
    internal static string FormatUInt16 { get; }
    internal static string SerializerCycleDetected { get; }
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ArrayDepthTooLarge();
    internal static string get_CallFlushToAvoidDataLoss();
    internal static string get_CannotReadIncompleteUTF16();
    internal static string get_CannotReadInvalidUTF16();
    internal static string get_CannotStartObjectArrayAfterPrimitiveOrClose();
    internal static string get_CannotStartObjectArrayWithoutProperty();
    internal static string get_CannotTranscodeInvalidUtf8();
    internal static string get_CannotDecodeInvalidBase64();
    internal static string get_CannotTranscodeInvalidUtf16();
    internal static string get_CannotEncodeInvalidUTF16();
    internal static string get_CannotEncodeInvalidUTF8();
    internal static string get_CannotWritePropertyWithinArray();
    internal static string get_CannotWritePropertyAfterProperty();
    internal static string get_CannotWriteValueAfterPrimitiveOrClose();
    internal static string get_CannotWriteValueWithinObject();
    internal static string get_DepthTooLarge();
    internal static string get_EmptyJsonIsInvalid();
    internal static string get_EndOfCommentNotFound();
    internal static string get_EndOfStringNotFound();
    internal static string get_ExpectedEndAfterSingleJson();
    internal static string get_ExpectedEndOfDigitNotFound();
    internal static string get_ExpectedFalse();
    internal static string get_ExpectedJsonTokens();
    internal static string get_ExpectedOneCompleteToken();
    internal static string get_ExpectedNextDigitEValueNotFound();
    internal static string get_ExpectedNull();
    internal static string get_ExpectedSeparatorAfterPropertyNameNotFound();
    internal static string get_ExpectedStartOfPropertyNotFound();
    internal static string get_ExpectedStartOfPropertyOrValueNotFound();
    internal static string get_ExpectedStartOfValueNotFound();
    internal static string get_ExpectedTrue();
    internal static string get_ExpectedValueAfterPropertyNameNotFound();
    internal static string get_FailedToGetLargerSpan();
    internal static string get_FoundInvalidCharacter();
    internal static string get_InvalidCast();
    internal static string get_InvalidCharacterAfterEscapeWithinString();
    internal static string get_InvalidCharacterWithinString();
    internal static string get_InvalidEndOfJsonNonPrimitive();
    internal static string get_InvalidHexCharacterWithinString();
    internal static string get_JsonDocumentDoesNotSupportComments();
    internal static string get_JsonElementHasWrongType();
    internal static string get_MaxDepthMustBePositive();
    internal static string get_CommentHandlingMustBeValid();
    internal static string get_MismatchedObjectArray();
    internal static string get_CannotWriteEndAfterProperty();
    internal static string get_ObjectDepthTooLarge();
    internal static string get_PropertyNameTooLarge();
    internal static string get_FormatDecimal();
    internal static string get_FormatDouble();
    internal static string get_FormatInt32();
    internal static string get_FormatInt64();
    internal static string get_FormatSingle();
    internal static string get_FormatUInt32();
    internal static string get_FormatUInt64();
    internal static string get_RequiredDigitNotFoundAfterDecimal();
    internal static string get_RequiredDigitNotFoundAfterSign();
    internal static string get_RequiredDigitNotFoundEndOfData();
    internal static string get_SpecialNumberValuesNotSupported();
    internal static string get_ValueTooLarge();
    internal static string get_ZeroDepthAtEnd();
    internal static string get_DeserializeUnableToConvertValue();
    internal static string get_DeserializeWrongType();
    internal static string get_SerializationInvalidBufferSize();
    internal static string get_BufferWriterAdvancedTooFar();
    internal static string get_InvalidComparison();
    internal static string get_FormatDateTime();
    internal static string get_FormatDateTimeOffset();
    internal static string get_FormatGuid();
    internal static string get_ExpectedStartOfPropertyOrValueAfterComment();
    internal static string get_TrailingCommaNotAllowedBeforeArrayEnd();
    internal static string get_TrailingCommaNotAllowedBeforeObjectEnd();
    internal static string get_SerializerOptionsImmutable();
    internal static string get_StreamNotWritable();
    internal static string get_CannotWriteCommentWithEmbeddedDelimiter();
    internal static string get_SerializerPropertyNameConflict();
    internal static string get_SerializerPropertyNameNull();
    internal static string get_DeserializeDuplicateKey();
    internal static string get_SerializationDataExtensionPropertyInvalid();
    internal static string get_SerializationDuplicateTypeAttribute();
    internal static string get_SerializationNotSupportedCollectionType();
    internal static string get_SerializationNotSupportedCollection();
    internal static string get_InvalidCharacterAtStartOfComment();
    internal static string get_UnexpectedEndOfDataWhileReadingComment();
    internal static string get_CannotSkip();
    internal static string get_NotEnoughData();
    internal static string get_UnexpectedEndOfLineSeparator();
    internal static string get_JsonSerializerDoesNotSupportComments();
    internal static string get_DeserializeMissingParameterlessConstructor();
    internal static string get_DeserializePolymorphicInterface();
    internal static string get_SerializationConverterOnAttributeNotCompatible();
    internal static string get_SerializationConverterOnAttributeInvalid();
    internal static string get_SerializationConverterRead();
    internal static string get_SerializationConverterNotCompatible();
    internal static string get_SerializationConverterWrite();
    internal static string get_SerializerDictionaryKeyNull();
    internal static string get_SerializationDuplicateAttribute();
    internal static string get_SerializeUnableToSerialize();
    internal static string get_FormatByte();
    internal static string get_FormatInt16();
    internal static string get_FormatSByte();
    internal static string get_FormatUInt16();
    internal static string get_SerializerCycleDetected();
}
internal class System.Text.Json.BitStack : ValueType {
    private static int AllocationFreeMaxDepth;
    private static int DefaultInitialArraySize;
    private Int32[] _array;
    private ulong _allocationFreeContainer;
    private int _currentDepth;
    public int CurrentDepth { get; }
    public int get_CurrentDepth();
    public void PushTrue();
    public void PushFalse();
    private void PushToArray(bool value);
    public bool Pop();
    private bool PopFromArray();
    private void DoubleArray(int minSize);
    public void SetFirstBit();
    public void ResetFirstBit();
    private static int Div32Rem(int number, Int32& remainder);
}
internal enum System.Text.Json.ClassType : Enum {
    public byte value__;
    public static ClassType Unknown;
    public static ClassType Object;
    public static ClassType Value;
    public static ClassType Enumerable;
    public static ClassType Dictionary;
    public static ClassType IDictionaryConstructible;
}
internal enum System.Text.Json.ConsumeNumberResult : Enum {
    public byte value__;
    public static ConsumeNumberResult Success;
    public static ConsumeNumberResult OperationIncomplete;
    public static ConsumeNumberResult NeedMoreData;
}
internal enum System.Text.Json.ConsumeTokenResult : Enum {
    public byte value__;
    public static ConsumeTokenResult Success;
    public static ConsumeTokenResult NotEnoughDataRollBackState;
    public static ConsumeTokenResult IncompleteNoRollBackNecessary;
}
internal enum System.Text.Json.DataType : Enum {
    public int value__;
    public static DataType DateTime;
    public static DataType DateTimeOffset;
    public static DataType Base64String;
    public static DataType Guid;
}
internal enum System.Text.Json.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource ArrayDepthTooLarge;
    public static ExceptionResource EndOfCommentNotFound;
    public static ExceptionResource EndOfStringNotFound;
    public static ExceptionResource RequiredDigitNotFoundAfterDecimal;
    public static ExceptionResource RequiredDigitNotFoundAfterSign;
    public static ExceptionResource RequiredDigitNotFoundEndOfData;
    public static ExceptionResource ExpectedEndAfterSingleJson;
    public static ExceptionResource ExpectedEndOfDigitNotFound;
    public static ExceptionResource ExpectedFalse;
    public static ExceptionResource ExpectedNextDigitEValueNotFound;
    public static ExceptionResource ExpectedNull;
    public static ExceptionResource ExpectedSeparatorAfterPropertyNameNotFound;
    public static ExceptionResource ExpectedStartOfPropertyNotFound;
    public static ExceptionResource ExpectedStartOfPropertyOrValueNotFound;
    public static ExceptionResource ExpectedStartOfPropertyOrValueAfterComment;
    public static ExceptionResource ExpectedStartOfValueNotFound;
    public static ExceptionResource ExpectedTrue;
    public static ExceptionResource ExpectedValueAfterPropertyNameNotFound;
    public static ExceptionResource FoundInvalidCharacter;
    public static ExceptionResource InvalidCharacterWithinString;
    public static ExceptionResource InvalidCharacterAfterEscapeWithinString;
    public static ExceptionResource InvalidHexCharacterWithinString;
    public static ExceptionResource InvalidEndOfJsonNonPrimitive;
    public static ExceptionResource MismatchedObjectArray;
    public static ExceptionResource ObjectDepthTooLarge;
    public static ExceptionResource ZeroDepthAtEnd;
    public static ExceptionResource DepthTooLarge;
    public static ExceptionResource CannotStartObjectArrayWithoutProperty;
    public static ExceptionResource CannotStartObjectArrayAfterPrimitiveOrClose;
    public static ExceptionResource CannotWriteValueWithinObject;
    public static ExceptionResource CannotWriteValueAfterPrimitiveOrClose;
    public static ExceptionResource CannotWritePropertyWithinArray;
    public static ExceptionResource ExpectedJsonTokens;
    public static ExceptionResource TrailingCommaNotAllowedBeforeArrayEnd;
    public static ExceptionResource TrailingCommaNotAllowedBeforeObjectEnd;
    public static ExceptionResource InvalidCharacterAtStartOfComment;
    public static ExceptionResource UnexpectedEndOfDataWhileReadingComment;
    public static ExceptionResource UnexpectedEndOfLineSeparator;
    public static ExceptionResource ExpectedOneCompleteToken;
    public static ExceptionResource NotEnoughData;
}
internal abstract class System.Text.Json.ImmutableCollectionCreator : object {
    public abstract virtual void RegisterCreatorDelegateFromMethod(MethodInfo creator);
    public abstract virtual bool CreateImmutableEnumerable(IList items, IEnumerable& collection);
    public abstract virtual bool CreateImmutableDictionary(IDictionary items, IDictionary& collection);
}
internal class System.Text.Json.ImmutableDictionaryCreator`2 : ImmutableCollectionCreator {
    private Func`2<IEnumerable`1<KeyValuePair`2<string, TElement>>, TCollection> _creatorDelegate;
    public virtual void RegisterCreatorDelegateFromMethod(MethodInfo creator);
    public virtual bool CreateImmutableEnumerable(IList items, IEnumerable& collection);
    public virtual bool CreateImmutableDictionary(IDictionary items, IDictionary& collection);
    [IteratorStateMachineAttribute("System.Text.Json.ImmutableDictionaryCreator`2/<CreateGenericTElementIDictionary>d__4")]
private IEnumerable`1<KeyValuePair`2<string, TElement>> CreateGenericTElementIDictionary(IDictionary sourceDictionary);
}
internal class System.Text.Json.ImmutableEnumerableCreator`2 : ImmutableCollectionCreator {
    private Func`2<IEnumerable`1<TElement>, TCollection> _creatorDelegate;
    public virtual void RegisterCreatorDelegateFromMethod(MethodInfo creator);
    public virtual bool CreateImmutableEnumerable(IList items, IEnumerable& collection);
    public virtual bool CreateImmutableDictionary(IDictionary items, IDictionary& collection);
    [IteratorStateMachineAttribute("System.Text.Json.ImmutableEnumerableCreator`2/<CreateGenericTElementIEnumerable>d__4")]
private IEnumerable`1<TElement> CreateGenericTElementIEnumerable(IList sourceList);
}
internal class System.Text.Json.JsonCamelCaseNamingPolicy : JsonNamingPolicy {
    public virtual string ConvertName(string name);
    private static void FixCasing(Span`1<char> chars);
}
[DebuggerDisplayAttribute("ClassType.{ClassType}, {Type.Name}")]
internal class System.Text.Json.JsonClassInfo : object {
    private static int PropertyNameKeyLength;
    private static int PropertyNameCountCacheThreshold;
    public Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) PropertyCache;
    public ConcurrentDictionary`2<ValueTuple`2<JsonPropertyInfo, Type>, JsonPropertyInfo> RuntimePropertyCache;
    public JsonPropertyInfo[] modreq(System.Runtime.CompilerServices.IsVolatile) PropertyCacheArray;
    private PropertyRef[] modreq(System.Runtime.CompilerServices.IsVolatile) _propertyRefsSorted;
    [CompilerGeneratedAttribute]
private ConstructorDelegate <CreateObject>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorDelegate <CreateConcreteDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private ClassType <ClassType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyInfo <DataExtensionProperty>k__BackingField;
    private JsonClassInfo _elementClassInfo;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonPropertyInfo <PolicyProperty>k__BackingField;
    public static string ImmutableNamespaceName;
    private static string EnumerableGenericInterfaceTypeName;
    private static string EnumerableInterfaceTypeName;
    private static string ListInterfaceTypeName;
    private static string ListGenericInterfaceTypeName;
    private static string ListGenericTypeName;
    private static string CollectionGenericInterfaceTypeName;
    private static string CollectionInterfaceTypeName;
    private static string ReadOnlyListGenericInterfaceTypeName;
    private static string ReadOnlyCollectionGenericInterfaceTypeName;
    public static string HashtableTypeName;
    public static string SortedListTypeName;
    public static string StackTypeName;
    public static string StackGenericTypeName;
    public static string QueueTypeName;
    public static string QueueGenericTypeName;
    public static string SetGenericInterfaceTypeName;
    public static string SortedSetGenericTypeName;
    public static string HashSetGenericTypeName;
    public static string LinkedListGenericTypeName;
    public static string DictionaryInterfaceTypeName;
    public static string DictionaryGenericTypeName;
    public static string DictionaryGenericInterfaceTypeName;
    public static string ReadOnlyDictionaryGenericInterfaceTypeName;
    public static string SortedDictionaryGenericTypeName;
    public static string KeyValuePairGenericTypeName;
    public static string ArrayListTypeName;
    private static Type[] s_genericInterfacesWithAddMethods;
    private static Type[] s_nonGenericInterfacesWithAddMethods;
    private static Type[] s_genericInterfacesWithoutAddMethods;
    private static HashSet`1<string> s_nativelySupportedGenericCollections;
    private static HashSet`1<string> s_nativelySupportedNonGenericCollections;
    public ConstructorDelegate CreateObject { get; private set; }
    public ConstructorDelegate CreateConcreteDictionary { get; private set; }
    public ClassType ClassType { get; private set; }
    public JsonPropertyInfo DataExtensionProperty { get; private set; }
    public JsonClassInfo ElementClassInfo { get; }
    public Type ElementType { get; public set; }
    public JsonSerializerOptions Options { get; private set; }
    public Type Type { get; private set; }
    public JsonPropertyInfo PolicyProperty { get; private set; }
    public JsonClassInfo(Type type, JsonSerializerOptions options);
    private static JsonClassInfo();
    [CompilerGeneratedAttribute]
public ConstructorDelegate get_CreateObject();
    [CompilerGeneratedAttribute]
private void set_CreateObject(ConstructorDelegate value);
    [CompilerGeneratedAttribute]
public ConstructorDelegate get_CreateConcreteDictionary();
    [CompilerGeneratedAttribute]
private void set_CreateConcreteDictionary(ConstructorDelegate value);
    [CompilerGeneratedAttribute]
public ClassType get_ClassType();
    [CompilerGeneratedAttribute]
private void set_ClassType(ClassType value);
    [CompilerGeneratedAttribute]
public JsonPropertyInfo get_DataExtensionProperty();
    [CompilerGeneratedAttribute]
private void set_DataExtensionProperty(JsonPropertyInfo value);
    public JsonClassInfo get_ElementClassInfo();
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
public void set_ElementType(Type value);
    [CompilerGeneratedAttribute]
public JsonSerializerOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(JsonSerializerOptions value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    public void UpdateSortedPropertyCache(ReadStackFrame& frame);
    private bool DetermineExtensionDataProperty(Dictionary`2<string, JsonPropertyInfo> cache);
    private JsonPropertyInfo GetPropertyWithUniqueAttribute(Type attributeType, Dictionary`2<string, JsonPropertyInfo> cache);
    public JsonPropertyInfo GetProperty(ReadOnlySpan`1<byte> propertyName, ReadStackFrame& frame);
    private Dictionary`2<string, JsonPropertyInfo> CreatePropertyCache(int capacity);
    [CompilerGeneratedAttribute]
public JsonPropertyInfo get_PolicyProperty();
    [CompilerGeneratedAttribute]
private void set_PolicyProperty(JsonPropertyInfo value);
    private static bool TryIsPropertyRefEqual(PropertyRef& propertyRef, ReadOnlySpan`1<byte> propertyName, ulong key, JsonPropertyInfo& info);
    public static ulong GetKey(ReadOnlySpan`1<byte> propertyName);
    public static Type GetElementType(Type propertyType, Type parentType, MemberInfo memberInfo, JsonSerializerOptions options);
    public static ClassType GetClassType(Type type, JsonSerializerOptions options);
    public static bool IsDictionaryClassType(Type type);
    private void AddPolicyProperty(Type propertyType, JsonSerializerOptions options);
    private JsonPropertyInfo AddProperty(Type propertyType, PropertyInfo propertyInfo, Type classType, JsonSerializerOptions options);
    internal static JsonPropertyInfo CreateProperty(Type declaredPropertyType, Type runtimePropertyType, Type implementedPropertyType, PropertyInfo propertyInfo, Type parentClassType, JsonConverter converter, JsonSerializerOptions options);
    internal JsonPropertyInfo CreateRootObject(JsonSerializerOptions options);
    internal JsonPropertyInfo GetOrAddPolymorphicProperty(JsonPropertyInfo property, Type runtimePropertyType, JsonSerializerOptions options);
    public static Type GetImplementedCollectionType(Type parentClassType, Type queryType, PropertyInfo propertyInfo, JsonConverter& converter, JsonSerializerOptions options);
    public static bool IsDeserializedByAssigningFromList(Type type);
    public static bool IsSetInterface(Type type);
    public static bool HasConstructorThatTakesGenericIEnumerable(Type type, JsonSerializerOptions options);
    public static bool IsDeserializedByConstructingWithIList(Type type);
    public static bool IsDeserializedByConstructingWithIDictionary(Type type);
    public static bool IsNativelySupportedCollection(Type queryType);
    public static Type ExtractGenericInterface(Type queryType, Type interfaceType);
    private static bool IsGenericInstantiation(Type candidate, Type interfaceType);
    private static Type GetGenericInstantiation(Type queryType, Type interfaceType);
    [CompilerGeneratedAttribute]
internal static JsonPropertyInfo <GetOrAddPolymorphicProperty>g__CreateRuntimeProperty|57_0(ValueTuple`2<JsonPropertyInfo, Type> key, ValueTuple`2<JsonSerializerOptions, Type> arg);
}
public enum System.Text.Json.JsonCommentHandling : Enum {
    public byte value__;
    public static JsonCommentHandling Disallow;
    public static JsonCommentHandling Skip;
    public static JsonCommentHandling Allow;
}
internal static class System.Text.Json.JsonConstants : object {
    public static byte OpenBrace;
    public static byte CloseBrace;
    public static byte OpenBracket;
    public static byte CloseBracket;
    public static byte Space;
    public static byte CarriageReturn;
    public static byte LineFeed;
    public static byte Tab;
    public static byte ListSeparator;
    public static byte KeyValueSeperator;
    public static byte Quote;
    public static byte BackSlash;
    public static byte Slash;
    public static byte BackSpace;
    public static byte FormFeed;
    public static byte Asterisk;
    public static byte Colon;
    public static byte Period;
    public static byte Plus;
    public static byte Hyphen;
    public static byte UtcOffsetToken;
    public static byte TimePrefix;
    public static byte StartingByteOfNonStandardSeparator;
    public static int SpacesPerIndent;
    public static int MaxWriterDepth;
    public static int RemoveFlagsBitMask;
    public static int StackallocThreshold;
    public static int MaxExpansionFactorWhileEscaping;
    public static int MaxExpansionFactorWhileTranscoding;
    public static int MaxEscapedTokenSize;
    public static int MaxUnescapedTokenSize;
    public static int MaxBase64ValueTokenSize;
    public static int MaxCharacterTokenSize;
    public static int MaximumFormatInt64Length;
    public static int MaximumFormatUInt64Length;
    public static int MaximumFormatDoubleLength;
    public static int MaximumFormatSingleLength;
    public static int MaximumFormatDecimalLength;
    public static int MaximumFormatGuidLength;
    public static int MaximumEscapedGuidLength;
    public static int MaximumFormatDateTimeLength;
    public static int MaximumFormatDateTimeOffsetLength;
    public static int MaxDateTimeUtcOffsetHours;
    public static int DateTimeNumFractionDigits;
    public static int MaxDateTimeFraction;
    public static int DateTimeParseNumFractionDigits;
    public static int MaximumDateTimeOffsetParseLength;
    public static int MinimumDateTimeParseLength;
    public static int MaximumEscapedDateTimeOffsetParseLength;
    internal static char ScientificNotationFormat;
    public static char HighSurrogateStart;
    public static char HighSurrogateEnd;
    public static char LowSurrogateStart;
    public static char LowSurrogateEnd;
    public static int UnicodePlane01StartValue;
    public static int HighSurrogateStartValue;
    public static int HighSurrogateEndValue;
    public static int LowSurrogateStartValue;
    public static int LowSurrogateEndValue;
    public static int BitShiftBy10;
    public static ReadOnlySpan`1<byte> Utf8Bom { get; }
    public static ReadOnlySpan`1<byte> TrueValue { get; }
    public static ReadOnlySpan`1<byte> FalseValue { get; }
    public static ReadOnlySpan`1<byte> NullValue { get; }
    public static ReadOnlySpan`1<byte> Delimiters { get; }
    public static ReadOnlySpan`1<byte> EscapableChars { get; }
    public static ReadOnlySpan`1<byte> get_Utf8Bom();
    public static ReadOnlySpan`1<byte> get_TrueValue();
    public static ReadOnlySpan`1<byte> get_FalseValue();
    public static ReadOnlySpan`1<byte> get_NullValue();
    public static ReadOnlySpan`1<byte> get_Delimiters();
    public static ReadOnlySpan`1<byte> get_EscapableChars();
}
internal class System.Text.Json.JsonDefaultNamingPolicy : JsonNamingPolicy {
    public virtual string ConvertName(string name);
}
public class System.Text.Json.JsonDocument : object {
    private ReadOnlyMemory`1<byte> _utf8Json;
    private MetadataDb _parsedData;
    private Byte[] _extraRentedBytes;
    private ValueTuple`2<int, string> _lastIndexAndString;
    [CompilerGeneratedAttribute]
private bool <IsDisposable>k__BackingField;
    private static int UnseekableStreamInitialRentSize;
    internal bool IsDisposable { get; }
    public JsonElement RootElement { get; }
    private JsonDocument(ReadOnlyMemory`1<byte> utf8Json, MetadataDb parsedData, Byte[] extraRentedBytes, bool isDisposable);
    [CompilerGeneratedAttribute]
internal bool get_IsDisposable();
    public JsonElement get_RootElement();
    public sealed virtual void Dispose();
    public void WriteTo(Utf8JsonWriter writer);
    internal JsonTokenType GetJsonTokenType(int index);
    internal int GetArrayLength(int index);
    internal JsonElement GetArrayIndexElement(int currentIndex, int arrayIndex);
    internal int GetEndIndex(int index, bool includeEndElement);
    private ReadOnlyMemory`1<byte> GetRawValue(int index, bool includeQuotes);
    private ReadOnlyMemory`1<byte> GetPropertyRawValue(int valueIndex);
    internal string GetString(int index, JsonTokenType expectedType);
    internal bool TextEquals(int index, ReadOnlySpan`1<char> otherText, bool isPropertyName);
    internal bool TextEquals(int index, ReadOnlySpan`1<byte> otherUtf8Text, bool isPropertyName);
    internal string GetNameOfPropertyValue(int index);
    internal bool TryGetValue(int index, Byte[]& value);
    internal bool TryGetValue(int index, SByte& value);
    internal bool TryGetValue(int index, Byte& value);
    internal bool TryGetValue(int index, Int16& value);
    internal bool TryGetValue(int index, UInt16& value);
    internal bool TryGetValue(int index, Int32& value);
    internal bool TryGetValue(int index, UInt32& value);
    internal bool TryGetValue(int index, Int64& value);
    internal bool TryGetValue(int index, UInt64& value);
    internal bool TryGetValue(int index, Double& value);
    internal bool TryGetValue(int index, Single& value);
    internal bool TryGetValue(int index, Decimal& value);
    internal bool TryGetValue(int index, DateTime& value);
    internal bool TryGetValue(int index, DateTimeOffset& value);
    internal bool TryGetValue(int index, Guid& value);
    internal string GetRawValueAsString(int index);
    internal string GetPropertyRawValueAsString(int valueIndex);
    internal JsonElement CloneElement(int index);
    internal void WriteElementTo(int index, Utf8JsonWriter writer);
    private void WriteComplexElement(int index, Utf8JsonWriter writer);
    private ReadOnlySpan`1<byte> UnescapeString(DbRow& row, ArraySegment`1& rented);
    private static void ClearAndReturn(ArraySegment`1<byte> rented);
    private void WritePropertyName(DbRow& row, Utf8JsonWriter writer);
    private void WriteString(DbRow& row, Utf8JsonWriter writer);
    private static void Parse(ReadOnlySpan`1<byte> utf8JsonSpan, Utf8JsonReader reader, MetadataDb& database, StackRowStack& stack);
    private void CheckNotDisposed();
    private void CheckExpectedType(JsonTokenType expected, JsonTokenType actual);
    private static void CheckSupportedOptions(JsonReaderOptions readerOptions, string paramName);
    public static JsonDocument Parse(ReadOnlyMemory`1<byte> utf8Json, JsonDocumentOptions options);
    public static JsonDocument Parse(ReadOnlySequence`1<byte> utf8Json, JsonDocumentOptions options);
    public static JsonDocument Parse(Stream utf8Json, JsonDocumentOptions options);
    public static Task`1<JsonDocument> ParseAsync(Stream utf8Json, JsonDocumentOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Text.Json.JsonDocument/<ParseAsyncCore>d__57")]
private static Task`1<JsonDocument> ParseAsyncCore(Stream utf8Json, JsonDocumentOptions options, CancellationToken cancellationToken);
    public static JsonDocument Parse(ReadOnlyMemory`1<char> json, JsonDocumentOptions options);
    public static JsonDocument Parse(string json, JsonDocumentOptions options);
    public static bool TryParseValue(Utf8JsonReader& reader, JsonDocument& document);
    public static JsonDocument ParseValue(Utf8JsonReader& reader);
    private static bool TryParseValue(Utf8JsonReader& reader, JsonDocument& document, bool shouldThrow);
    private static JsonDocument Parse(ReadOnlyMemory`1<byte> utf8Json, JsonReaderOptions readerOptions, Byte[] extraRentedBytes);
    private static ArraySegment`1<byte> ReadToEnd(Stream stream);
    [AsyncStateMachineAttribute("System.Text.Json.JsonDocument/<ReadToEndAsync>d__65")]
private static Task`1<ArraySegment`1<byte>> ReadToEndAsync(Stream stream, CancellationToken cancellationToken);
    internal bool TryGetNamedPropertyValue(int index, ReadOnlySpan`1<char> propertyName, JsonElement& value);
    internal bool TryGetNamedPropertyValue(int index, ReadOnlySpan`1<byte> propertyName, JsonElement& value);
    private bool TryGetNamedPropertyValue(int startIndex, int endIndex, ReadOnlySpan`1<byte> propertyName, JsonElement& value);
}
public class System.Text.Json.JsonDocumentOptions : ValueType {
    internal static int DefaultMaxDepth;
    private int _maxDepth;
    private JsonCommentHandling _commentHandling;
    [CompilerGeneratedAttribute]
private bool <AllowTrailingCommas>k__BackingField;
    public JsonCommentHandling CommentHandling { get; public set; }
    public int MaxDepth { get; public set; }
    public bool AllowTrailingCommas { get; public set; }
    [IsReadOnlyAttribute]
public JsonCommentHandling get_CommentHandling();
    public void set_CommentHandling(JsonCommentHandling value);
    [IsReadOnlyAttribute]
public int get_MaxDepth();
    public void set_MaxDepth(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AllowTrailingCommas();
    [CompilerGeneratedAttribute]
public void set_AllowTrailingCommas(bool value);
    internal JsonReaderOptions GetReaderOptions();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.JsonElement : ValueType {
    private JsonDocument _parent;
    private int _idx;
    private JsonTokenType TokenType { get; }
    public JsonValueKind ValueKind { get; }
    public JsonElement Item { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    internal JsonElement(JsonDocument parent, int idx);
    private JsonTokenType get_TokenType();
    public JsonValueKind get_ValueKind();
    public JsonElement get_Item(int index);
    public int GetArrayLength();
    public JsonElement GetProperty(string propertyName);
    public JsonElement GetProperty(ReadOnlySpan`1<char> propertyName);
    public JsonElement GetProperty(ReadOnlySpan`1<byte> utf8PropertyName);
    public bool TryGetProperty(string propertyName, JsonElement& value);
    public bool TryGetProperty(ReadOnlySpan`1<char> propertyName, JsonElement& value);
    public bool TryGetProperty(ReadOnlySpan`1<byte> utf8PropertyName, JsonElement& value);
    public bool GetBoolean();
    public string GetString();
    public bool TryGetBytesFromBase64(Byte[]& value);
    public Byte[] GetBytesFromBase64();
    [CLSCompliantAttribute("False")]
public bool TryGetSByte(SByte& value);
    [CLSCompliantAttribute("False")]
public sbyte GetSByte();
    public bool TryGetByte(Byte& value);
    public byte GetByte();
    public bool TryGetInt16(Int16& value);
    public short GetInt16();
    [CLSCompliantAttribute("False")]
public bool TryGetUInt16(UInt16& value);
    [CLSCompliantAttribute("False")]
public ushort GetUInt16();
    public bool TryGetInt32(Int32& value);
    public int GetInt32();
    [CLSCompliantAttribute("False")]
public bool TryGetUInt32(UInt32& value);
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32();
    public bool TryGetInt64(Int64& value);
    public long GetInt64();
    [CLSCompliantAttribute("False")]
public bool TryGetUInt64(UInt64& value);
    [CLSCompliantAttribute("False")]
public ulong GetUInt64();
    public bool TryGetDouble(Double& value);
    public double GetDouble();
    public bool TryGetSingle(Single& value);
    public float GetSingle();
    public bool TryGetDecimal(Decimal& value);
    public decimal GetDecimal();
    public bool TryGetDateTime(DateTime& value);
    public DateTime GetDateTime();
    public bool TryGetDateTimeOffset(DateTimeOffset& value);
    public DateTimeOffset GetDateTimeOffset();
    public bool TryGetGuid(Guid& value);
    public Guid GetGuid();
    internal string GetPropertyName();
    public string GetRawText();
    internal string GetPropertyRawText();
    public bool ValueEquals(string text);
    public bool ValueEquals(ReadOnlySpan`1<byte> utf8Text);
    public bool ValueEquals(ReadOnlySpan`1<char> text);
    internal bool TextEqualsHelper(ReadOnlySpan`1<byte> utf8Text, bool isPropertyName);
    internal bool TextEqualsHelper(ReadOnlySpan`1<char> text, bool isPropertyName);
    public void WriteTo(Utf8JsonWriter writer);
    public ArrayEnumerator EnumerateArray();
    public ObjectEnumerator EnumerateObject();
    public virtual string ToString();
    public JsonElement Clone();
    private void CheckValidInstance();
    private string get_DebuggerDisplay();
}
[IsReadOnlyAttribute]
public class System.Text.Json.JsonEncodedText : ValueType {
    private Byte[] _utf8Value;
    private string _value;
    public ReadOnlySpan`1<byte> EncodedUtf8Bytes { get; }
    private JsonEncodedText(Byte[] utf8Value);
    public ReadOnlySpan`1<byte> get_EncodedUtf8Bytes();
    public static JsonEncodedText Encode(string value, JavaScriptEncoder encoder);
    public static JsonEncodedText Encode(ReadOnlySpan`1<char> value, JavaScriptEncoder encoder);
    private static JsonEncodedText TranscodeAndEncode(ReadOnlySpan`1<char> value, JavaScriptEncoder encoder);
    public static JsonEncodedText Encode(ReadOnlySpan`1<byte> utf8Value, JavaScriptEncoder encoder);
    private static JsonEncodedText EncodeHelper(ReadOnlySpan`1<byte> utf8Value, JavaScriptEncoder encoder);
    private static Byte[] GetEscapedString(ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexVal, JavaScriptEncoder encoder);
    public sealed virtual bool Equals(JsonEncodedText other);
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public virtual int GetHashCode();
}
public class System.Text.Json.JsonException : Exception {
    private string _message;
    [CompilerGeneratedAttribute]
private bool <AppendPathInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <BytePositionInLine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    internal bool AppendPathInformation { get; internal set; }
    public Nullable`1<long> LineNumber { get; internal set; }
    public Nullable`1<long> BytePositionInLine { get; internal set; }
    public string Path { get; internal set; }
    public string Message { get; }
    public JsonException(string message, string path, Nullable`1<long> lineNumber, Nullable`1<long> bytePositionInLine, Exception innerException);
    public JsonException(string message, string path, Nullable`1<long> lineNumber, Nullable`1<long> bytePositionInLine);
    public JsonException(string message, Exception innerException);
    public JsonException(string message);
    protected JsonException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
internal bool get_AppendPathInformation();
    [CompilerGeneratedAttribute]
internal void set_AppendPathInformation(bool value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_LineNumber();
    [CompilerGeneratedAttribute]
internal void set_LineNumber(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_BytePositionInLine();
    [CompilerGeneratedAttribute]
internal void set_BytePositionInLine(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(string value);
    public virtual string get_Message();
    internal void SetMessage(string message);
}
internal static class System.Text.Json.JsonHelpers : object {
    private static Int32[] s_daysToMonth365;
    private static Int32[] s_daysToMonth366;
    private static JsonHelpers();
    public static bool IsValidUnicodeScalar(UInt32 value);
    public static bool IsInRangeInclusive(UInt32 value, UInt32 lowerBound, UInt32 upperBound);
    public static bool IsInRangeInclusive(int value, int lowerBound, int upperBound);
    public static bool IsInRangeInclusive(long value, long lowerBound, long upperBound);
    public static bool IsInRangeInclusive(JsonTokenType value, JsonTokenType lowerBound, JsonTokenType upperBound);
    public static bool IsDigit(byte value);
    internal static string Utf8GetString(ReadOnlySpan`1<byte> bytes);
    internal static bool TryAdd(Dictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
    public static bool TryParseAsISO(ReadOnlySpan`1<byte> source, DateTime& value);
    public static bool TryParseAsISO(ReadOnlySpan`1<byte> source, DateTimeOffset& value);
    private static bool TryParseDateTimeOffset(ReadOnlySpan`1<byte> source, DateTimeParseData& parseData);
    private static bool TryGetNextTwoDigits(ReadOnlySpan`1<byte> source, Int32& value);
    private static bool TryCreateDateTimeOffset(DateTime dateTime, DateTimeParseData& parseData, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffset(DateTimeParseData& parseData, DateTimeOffset& value);
    private static bool TryCreateDateTimeOffsetInterpretingDataAsLocalTime(DateTimeParseData parseData, DateTimeOffset& value);
    private static bool TryCreateDateTime(DateTimeParseData parseData, DateTimeKind kind, DateTime& value);
    [CompilerGeneratedAttribute]
internal static bool <TryParseDateTimeOffset>g__ParseOffset|11_0(DateTimeParseData& parseData, ReadOnlySpan`1<byte> offsetData);
}
public abstract class System.Text.Json.JsonNamingPolicy : object {
    [CompilerGeneratedAttribute]
private static JsonNamingPolicy <CamelCase>k__BackingField;
    [CompilerGeneratedAttribute]
private static JsonNamingPolicy <Default>k__BackingField;
    public static JsonNamingPolicy CamelCase { get; }
    internal static JsonNamingPolicy Default { get; }
    private static JsonNamingPolicy();
    [CompilerGeneratedAttribute]
public static JsonNamingPolicy get_CamelCase();
    [CompilerGeneratedAttribute]
internal static JsonNamingPolicy get_Default();
    public abstract virtual string ConvertName(string name);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.JsonProperty : ValueType {
    [CompilerGeneratedAttribute]
private JsonElement <Value>k__BackingField;
    public JsonElement Value { get; }
    public string Name { get; }
    private string DebuggerDisplay { get; }
    internal JsonProperty(JsonElement value);
    [CompilerGeneratedAttribute]
public JsonElement get_Value();
    public string get_Name();
    public bool NameEquals(string text);
    public bool NameEquals(ReadOnlySpan`1<byte> utf8Text);
    public bool NameEquals(ReadOnlySpan`1<char> text);
    public void WriteTo(Utf8JsonWriter writer);
    public virtual string ToString();
    private string get_DebuggerDisplay();
}
[DebuggerDisplayAttribute("PropertyInfo={PropertyInfo}, Element={ElementClassInfo}")]
internal abstract class System.Text.Json.JsonPropertyInfo : object {
    private static JsonEnumerableConverter s_jsonDerivedEnumerableConverter;
    private static JsonEnumerableConverter s_jsonArrayConverter;
    private static JsonEnumerableConverter s_jsonICollectionConverter;
    private static JsonEnumerableConverter s_jsonImmutableEnumerableConverter;
    private static JsonDictionaryConverter s_jsonDerivedDictionaryConverter;
    private static JsonDictionaryConverter s_jsonIDictionaryConverter;
    private static JsonDictionaryConverter s_jsonImmutableDictionaryConverter;
    public static JsonPropertyInfo s_missingProperty;
    private JsonClassInfo _elementClassInfo;
    private JsonClassInfo _runtimeClassInfo;
    private JsonClassInfo _declaredTypeClassInfo;
    private JsonPropertyInfo _dictionaryValuePropertyPolicy;
    [CompilerGeneratedAttribute]
private bool <CanBeNull>k__BackingField;
    public ClassType ClassType;
    [CompilerGeneratedAttribute]
private Type <DeclaredPropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ImplementedPropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonEnumerableConverter <EnumerableConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonDictionaryConverter <DictionaryConverter>k__BackingField;
    public Nullable`1<JsonEncodedText> EscapedName;
    [CompilerGeneratedAttribute]
private bool <HasGetter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasSetter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasInternalConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreNullValues>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNullableType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPropertyPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <JsonPropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NameAsString>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <PropertyNameKey>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParentClassType>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo <PropertyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <RuntimePropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldSerialize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldDeserialize>k__BackingField;
    public bool CanBeNull { get; private set; }
    public JsonConverter ConverterBase { get; public set; }
    public Type DeclaredPropertyType { get; private set; }
    public Type ImplementedPropertyType { get; private set; }
    public JsonPropertyInfo DictionaryValuePropertyPolicy { get; }
    public JsonClassInfo ElementClassInfo { get; }
    public Type ElementType { get; public set; }
    public JsonEnumerableConverter EnumerableConverter { get; private set; }
    public JsonDictionaryConverter DictionaryConverter { get; private set; }
    public bool HasGetter { get; public set; }
    public bool HasSetter { get; public set; }
    public bool HasInternalConverter { get; private set; }
    public bool IgnoreNullValues { get; private set; }
    public bool IsNullableType { get; private set; }
    public bool IsPropertyPolicy { get; protected set; }
    public Byte[] JsonPropertyName { get; public set; }
    public Byte[] Name { get; private set; }
    public string NameAsString { get; private set; }
    public ulong PropertyNameKey { get; public set; }
    protected JsonSerializerOptions Options { get; protected set; }
    public Type ParentClassType { get; private set; }
    public PropertyInfo PropertyInfo { get; private set; }
    public JsonClassInfo RuntimeClassInfo { get; }
    public JsonClassInfo DeclaredTypeClassInfo { get; }
    public Type RuntimePropertyType { get; private set; }
    public bool ShouldSerialize { get; private set; }
    public bool ShouldDeserialize { get; private set; }
    private static JsonPropertyInfo();
    [CompilerGeneratedAttribute]
public bool get_CanBeNull();
    [CompilerGeneratedAttribute]
private void set_CanBeNull(bool value);
    public abstract virtual JsonConverter get_ConverterBase();
    public abstract virtual void set_ConverterBase(JsonConverter value);
    private static JsonPropertyInfo GetMissingProperty();
    public void CopyRuntimeSettingsTo(JsonPropertyInfo other);
    public abstract virtual IList CreateConverterList();
    public abstract virtual IEnumerable CreateDerivedEnumerableInstance(ReadStack& state, JsonPropertyInfo collectionPropertyInfo, IList sourceList);
    public abstract virtual object CreateDerivedDictionaryInstance(ReadStack& state, JsonPropertyInfo collectionPropertyInfo, IDictionary sourceDictionary);
    public abstract virtual IEnumerable CreateIEnumerableInstance(ReadStack& state, Type parentType, IList sourceList);
    public abstract virtual IDictionary CreateIDictionaryInstance(ReadStack& state, Type parentType, IDictionary sourceDictionary);
    public abstract virtual IEnumerable CreateImmutableCollectionInstance(ReadStack& state, Type collectionType, string delegateKey, IList sourceList, JsonSerializerOptions options);
    public abstract virtual IDictionary CreateImmutableDictionaryInstance(ReadStack& state, Type collectionType, string delegateKey, IDictionary sourceDictionary, JsonSerializerOptions options);
    public static JsonPropertyInfo CreateIgnoredPropertyPlaceholder(PropertyInfo propertyInfo, JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
public Type get_DeclaredPropertyType();
    [CompilerGeneratedAttribute]
private void set_DeclaredPropertyType(Type value);
    [CompilerGeneratedAttribute]
public Type get_ImplementedPropertyType();
    [CompilerGeneratedAttribute]
private void set_ImplementedPropertyType(Type value);
    private void DeterminePropertyName();
    private void DetermineSerializationCapabilities();
    public JsonPropertyInfo get_DictionaryValuePropertyPolicy();
    public JsonClassInfo get_ElementClassInfo();
    [CompilerGeneratedAttribute]
public Type get_ElementType();
    [CompilerGeneratedAttribute]
public void set_ElementType(Type value);
    [CompilerGeneratedAttribute]
public JsonEnumerableConverter get_EnumerableConverter();
    [CompilerGeneratedAttribute]
private void set_EnumerableConverter(JsonEnumerableConverter value);
    [CompilerGeneratedAttribute]
public JsonDictionaryConverter get_DictionaryConverter();
    [CompilerGeneratedAttribute]
private void set_DictionaryConverter(JsonDictionaryConverter value);
    public static TAttribute GetAttribute(PropertyInfo propertyInfo);
    public abstract virtual Type GetConcreteType(Type type);
    public abstract virtual Type GetDictionaryConcreteType();
    public void GetDictionaryKeyAndValue(WriteStackFrame& writeStackFrame, String& key, Object& value);
    public abstract virtual void GetDictionaryKeyAndValueFromGenericDictionary(WriteStackFrame& writeStackFrame, String& key, Object& value);
    public virtual void GetPolicies();
    public abstract virtual object GetValueAsObject(object obj);
    [CompilerGeneratedAttribute]
public bool get_HasGetter();
    [CompilerGeneratedAttribute]
public void set_HasGetter(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasSetter();
    [CompilerGeneratedAttribute]
public void set_HasSetter(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasInternalConverter();
    [CompilerGeneratedAttribute]
private void set_HasInternalConverter(bool value);
    public virtual void Initialize(Type parentClassType, Type declaredPropertyType, Type runtimePropertyType, Type implementedPropertyType, PropertyInfo propertyInfo, Type elementType, JsonConverter converter, JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
public bool get_IgnoreNullValues();
    [CompilerGeneratedAttribute]
private void set_IgnoreNullValues(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsNullableType();
    [CompilerGeneratedAttribute]
private void set_IsNullableType(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsPropertyPolicy();
    [CompilerGeneratedAttribute]
protected void set_IsPropertyPolicy(bool value);
    [CompilerGeneratedAttribute]
public Byte[] get_JsonPropertyName();
    [CompilerGeneratedAttribute]
public void set_JsonPropertyName(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_NameAsString();
    [CompilerGeneratedAttribute]
private void set_NameAsString(string value);
    [CompilerGeneratedAttribute]
public ulong get_PropertyNameKey();
    [CompilerGeneratedAttribute]
public void set_PropertyNameKey(ulong value);
    [CompilerGeneratedAttribute]
protected JsonSerializerOptions get_Options();
    [CompilerGeneratedAttribute]
protected void set_Options(JsonSerializerOptions value);
    protected abstract virtual void OnRead(ReadStack& state, Utf8JsonReader& reader);
    protected abstract virtual void OnReadEnumerable(ReadStack& state, Utf8JsonReader& reader);
    protected abstract virtual void OnWrite(WriteStackFrame& current, Utf8JsonWriter writer);
    protected virtual void OnWriteDictionary(WriteStackFrame& current, Utf8JsonWriter writer);
    protected abstract virtual void OnWriteEnumerable(WriteStackFrame& current, Utf8JsonWriter writer);
    [CompilerGeneratedAttribute]
public Type get_ParentClassType();
    [CompilerGeneratedAttribute]
private void set_ParentClassType(Type value);
    [CompilerGeneratedAttribute]
public PropertyInfo get_PropertyInfo();
    [CompilerGeneratedAttribute]
private void set_PropertyInfo(PropertyInfo value);
    public void Read(JsonTokenType tokenType, ReadStack& state, Utf8JsonReader& reader);
    public void ReadEnumerable(JsonTokenType tokenType, ReadStack& state, Utf8JsonReader& reader);
    public JsonClassInfo get_RuntimeClassInfo();
    public JsonClassInfo get_DeclaredTypeClassInfo();
    [CompilerGeneratedAttribute]
public Type get_RuntimePropertyType();
    [CompilerGeneratedAttribute]
private void set_RuntimePropertyType(Type value);
    public abstract virtual void SetValueAsObject(object obj, object value);
    [CompilerGeneratedAttribute]
public bool get_ShouldSerialize();
    [CompilerGeneratedAttribute]
private void set_ShouldSerialize(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShouldDeserialize();
    [CompilerGeneratedAttribute]
private void set_ShouldDeserialize(bool value);
    private void VerifyRead(JsonTokenType tokenType, int depth, long bytesConsumed, Utf8JsonReader& reader);
    public void Write(WriteStack& state, Utf8JsonWriter writer);
    public void WriteDictionary(WriteStack& state, Utf8JsonWriter writer);
    public void WriteEnumerable(WriteStack& state, Utf8JsonWriter writer);
    private void VerifyWrite(int originalDepth, Utf8JsonWriter writer);
}
internal abstract class System.Text.Json.JsonPropertyInfoCommon`4 : JsonPropertyInfo {
    [CompilerGeneratedAttribute]
private Func`2<object, TDeclaredProperty> <Get>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<object, TDeclaredProperty> <Set>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonConverter`1<TConverter> <Converter>k__BackingField;
    public Func`2<object, TDeclaredProperty> Get { get; private set; }
    public Action`2<object, TDeclaredProperty> Set { get; private set; }
    public JsonConverter`1<TConverter> Converter { get; internal set; }
    public JsonConverter ConverterBase { get; public set; }
    [CompilerGeneratedAttribute]
public Func`2<object, TDeclaredProperty> get_Get();
    [CompilerGeneratedAttribute]
private void set_Get(Func`2<object, TDeclaredProperty> value);
    [CompilerGeneratedAttribute]
public Action`2<object, TDeclaredProperty> get_Set();
    [CompilerGeneratedAttribute]
private void set_Set(Action`2<object, TDeclaredProperty> value);
    [CompilerGeneratedAttribute]
public JsonConverter`1<TConverter> get_Converter();
    [CompilerGeneratedAttribute]
internal void set_Converter(JsonConverter`1<TConverter> value);
    public virtual void Initialize(Type parentClassType, Type declaredPropertyType, Type runtimePropertyType, Type implementedPropertyType, PropertyInfo propertyInfo, Type elementType, JsonConverter converter, JsonSerializerOptions options);
    public virtual JsonConverter get_ConverterBase();
    public virtual void set_ConverterBase(JsonConverter value);
    public virtual object GetValueAsObject(object obj);
    public virtual void SetValueAsObject(object obj, object value);
    public virtual IList CreateConverterList();
    public virtual Type GetConcreteType(Type parentType);
    public virtual IEnumerable CreateDerivedEnumerableInstance(ReadStack& state, JsonPropertyInfo collectionPropertyInfo, IList sourceList);
    public virtual object CreateDerivedDictionaryInstance(ReadStack& state, JsonPropertyInfo collectionPropertyInfo, IDictionary sourceDictionary);
    public virtual IEnumerable CreateIEnumerableInstance(ReadStack& state, Type parentType, IList sourceList);
    public virtual IDictionary CreateIDictionaryInstance(ReadStack& state, Type parentType, IDictionary sourceDictionary);
    public virtual IEnumerable CreateImmutableCollectionInstance(ReadStack& state, Type collectionType, string delegateKey, IList sourceList, JsonSerializerOptions options);
    public virtual IDictionary CreateImmutableDictionaryInstance(ReadStack& state, Type collectionType, string delegateKey, IDictionary sourceDictionary, JsonSerializerOptions options);
    [IteratorStateMachineAttribute("System.Text.Json.JsonPropertyInfoCommon`4/<CreateGenericTDeclaredPropertyIEnumerable>d__26")]
private IEnumerable`1<TDeclaredProperty> CreateGenericTDeclaredPropertyIEnumerable(IList sourceList);
}
internal class System.Text.Json.JsonPropertyInfoNotNullable`4 : JsonPropertyInfoCommon`4<TClass, TDeclaredProperty, TRuntimeProperty, TConverter> {
    protected virtual void OnRead(ReadStack& state, Utf8JsonReader& reader);
    protected virtual void OnReadEnumerable(ReadStack& state, Utf8JsonReader& reader);
    protected virtual void OnWrite(WriteStackFrame& current, Utf8JsonWriter writer);
    protected virtual void OnWriteDictionary(WriteStackFrame& current, Utf8JsonWriter writer);
    protected virtual void OnWriteEnumerable(WriteStackFrame& current, Utf8JsonWriter writer);
    public virtual Type GetDictionaryConcreteType();
    public virtual void GetDictionaryKeyAndValueFromGenericDictionary(WriteStackFrame& writeStackFrame, String& key, Object& value);
}
internal class System.Text.Json.JsonPropertyInfoNullable`2 : JsonPropertyInfoCommon`4<TClass, Nullable`1<TProperty>, TProperty, TProperty> {
    private static Type s_underlyingType;
    private static JsonPropertyInfoNullable`2();
    protected virtual void OnRead(ReadStack& state, Utf8JsonReader& reader);
    protected virtual void OnReadEnumerable(ReadStack& state, Utf8JsonReader& reader);
    protected virtual void OnWrite(WriteStackFrame& current, Utf8JsonWriter writer);
    protected virtual void OnWriteDictionary(WriteStackFrame& current, Utf8JsonWriter writer);
    protected virtual void OnWriteEnumerable(WriteStackFrame& current, Utf8JsonWriter writer);
    public virtual Type GetDictionaryConcreteType();
    public virtual void GetDictionaryKeyAndValueFromGenericDictionary(WriteStackFrame& writeStackFrame, String& key, Object& value);
}
internal class System.Text.Json.JsonReaderException : JsonException {
    public JsonReaderException(string message, long lineNumber, long bytePositionInLine);
    private JsonReaderException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class System.Text.Json.JsonReaderHelper : object {
    private static ulong XorPowerOfTwoToHighByte;
    public static UTF8Encoding s_utf8Encoding;
    private static JsonReaderHelper();
    public static ValueTuple`2<int, int> CountNewLines(ReadOnlySpan`1<byte> data);
    [ExtensionAttribute]
internal static JsonValueKind ToValueKind(JsonTokenType tokenType);
    public static bool IsTokenTypePrimitive(JsonTokenType tokenType);
    public static bool IsHexDigit(byte nextByte);
    [ExtensionAttribute]
public static int IndexOfQuoteOrAnyControlOrBackSlash(ReadOnlySpan`1<byte> span);
    private static int IndexOfOrLessThan(Byte& searchSpace, byte value0, byte value1, byte lessThan, int length);
    private static int LocateFirstFoundByte(Vector`1<byte> match);
    private static int LocateFirstFoundByte(ulong match);
    public static bool IsValidDateTimeOffsetParseLength(int length);
    public static bool IsValidDateTimeOffsetParseLength(long length);
    public static bool TryGetEscapedDateTime(ReadOnlySpan`1<byte> source, DateTime& value);
    public static bool TryGetEscapedDateTimeOffset(ReadOnlySpan`1<byte> source, DateTimeOffset& value);
    public static bool TryGetEscapedGuid(ReadOnlySpan`1<byte> source, Guid& value);
    public static bool TryGetUnescapedBase64Bytes(ReadOnlySpan`1<byte> utf8Source, int idx, Byte[]& bytes);
    public static string GetUnescapedString(ReadOnlySpan`1<byte> utf8Source, int idx);
    public static bool UnescapeAndCompare(ReadOnlySpan`1<byte> utf8Source, ReadOnlySpan`1<byte> other);
    public static bool UnescapeAndCompare(ReadOnlySequence`1<byte> utf8Source, ReadOnlySpan`1<byte> other);
    public static bool TryDecodeBase64InPlace(Span`1<byte> utf8Unescaped, Byte[]& bytes);
    public static bool TryDecodeBase64(ReadOnlySpan`1<byte> utf8Unescaped, Byte[]& bytes);
    public static string TranscodeHelper(ReadOnlySpan`1<byte> utf8Unescaped);
    internal static int GetUtf8ByteCount(ReadOnlySpan`1<char> text);
    internal static int GetUtf8FromText(ReadOnlySpan`1<char> text, Span`1<byte> dest);
    internal static string GetTextFromUtf8(ReadOnlySpan`1<byte> utf8Text);
    internal static void Unescape(ReadOnlySpan`1<byte> source, Span`1<byte> destination, int idx, Int32& written);
    private static void EncodeToUtf8Bytes(UInt32 scalar, Span`1<byte> utf8Destination, Int32& bytesWritten);
}
public class System.Text.Json.JsonReaderOptions : ValueType {
    internal static int DefaultMaxDepth;
    private int _maxDepth;
    private JsonCommentHandling _commentHandling;
    [CompilerGeneratedAttribute]
private bool <AllowTrailingCommas>k__BackingField;
    public JsonCommentHandling CommentHandling { get; public set; }
    public int MaxDepth { get; public set; }
    public bool AllowTrailingCommas { get; public set; }
    [IsReadOnlyAttribute]
public JsonCommentHandling get_CommentHandling();
    public void set_CommentHandling(JsonCommentHandling value);
    [IsReadOnlyAttribute]
public int get_MaxDepth();
    public void set_MaxDepth(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_AllowTrailingCommas();
    [CompilerGeneratedAttribute]
public void set_AllowTrailingCommas(bool value);
}
public class System.Text.Json.JsonReaderState : ValueType {
    internal long _lineNumber;
    internal long _bytePositionInLine;
    internal bool _inObject;
    internal bool _isNotPrimitive;
    internal char _numberFormat;
    internal bool _stringHasEscaping;
    internal bool _trailingCommaBeforeComment;
    internal JsonTokenType _tokenType;
    internal JsonTokenType _previousTokenType;
    internal JsonReaderOptions _readerOptions;
    internal BitStack _bitStack;
    public JsonReaderOptions Options { get; }
    public JsonReaderState(JsonReaderOptions options);
    public JsonReaderOptions get_Options();
}
public static class System.Text.Json.JsonSerializer : object {
    private static void HandleStartArray(JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& state);
    private static bool HandleEndArray(JsonSerializerOptions options, ReadStack& state);
    internal static void ApplyObjectToEnumerable(object value, ReadStack& state, bool setPropertyDirectly);
    internal static void ApplyValueToEnumerable(TProperty& value, ReadStack& state);
    private static void HandleStartDictionary(JsonSerializerOptions options, ReadStack& state);
    private static void HandleEndDictionary(JsonSerializerOptions options, ReadStack& state);
    private static void HandleStartObject(JsonSerializerOptions options, ReadStack& state);
    private static void HandleEndObject(ReadStack& state);
    private static void HandlePropertyName(JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& state);
    private static void CreateDataExtensionProperty(JsonPropertyInfo jsonPropertyInfo, ReadStack& state);
    private static void HandleValue(JsonTokenType tokenType, JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& state);
    private static object ReadCore(Type returnType, JsonSerializerOptions options, Utf8JsonReader& reader);
    public static ValueTask`1<TValue> DeserializeAsync(Stream utf8Json, JsonSerializerOptions options, CancellationToken cancellationToken);
    public static ValueTask`1<object> DeserializeAsync(Stream utf8Json, Type returnType, JsonSerializerOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Text.Json.JsonSerializer/<ReadAsync>d__14`1")]
private static ValueTask`1<TValue> ReadAsync(Stream utf8Json, Type returnType, JsonSerializerOptions options, CancellationToken cancellationToken);
    private static void ReadCore(JsonReaderState& readerState, bool isFinalBlock, ReadOnlySpan`1<byte> buffer, JsonSerializerOptions options, ReadStack& readStack);
    public static TValue Deserialize(string json, JsonSerializerOptions options);
    public static object Deserialize(string json, Type returnType, JsonSerializerOptions options);
    private static void ReadCore(JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& readStack);
    private static bool HandleObjectAsValue(JsonTokenType tokenType, JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& readStack, JsonReaderState& initialState, long initialBytesConsumed);
    private static ReadOnlySpan`1<byte> GetUnescapedString(ReadOnlySpan`1<byte> utf8Source, int idx);
    private static bool HandleNull(Utf8JsonReader& reader, ReadStack& state);
    private static void AddNullToCollection(JsonPropertyInfo jsonPropertyInfo, Utf8JsonReader& reader, ReadStack& state);
    public static TValue Deserialize(ReadOnlySpan`1<byte> utf8Json, JsonSerializerOptions options);
    public static object Deserialize(ReadOnlySpan`1<byte> utf8Json, Type returnType, JsonSerializerOptions options);
    private static object ParseCore(ReadOnlySpan`1<byte> utf8Json, Type returnType, JsonSerializerOptions options);
    public static TValue Deserialize(Utf8JsonReader& reader, JsonSerializerOptions options);
    public static object Deserialize(Utf8JsonReader& reader, Type returnType, JsonSerializerOptions options);
    private static object ReadValueCore(Utf8JsonReader& reader, Type returnType, JsonSerializerOptions options);
    private static void CheckSupportedOptions(JsonReaderOptions readerOptions, string paramName);
    private static void ReadValueCore(JsonSerializerOptions options, Utf8JsonReader& reader, ReadStack& readStack);
    private static bool Write(Utf8JsonWriter writer, int originalWriterDepth, int flushThreshold, JsonSerializerOptions options, WriteStack& state);
    public static Byte[] SerializeToUtf8Bytes(TValue value, JsonSerializerOptions options);
    public static Byte[] SerializeToUtf8Bytes(object value, Type inputType, JsonSerializerOptions options);
    private static bool HandleDictionary(JsonClassInfo elementClassInfo, JsonSerializerOptions options, Utf8JsonWriter writer, WriteStack& state);
    internal static void WriteDictionary(JsonConverter`1<TProperty> converter, JsonSerializerOptions options, WriteStackFrame& current, Utf8JsonWriter writer);
    private static bool HandleEnumerable(JsonClassInfo elementClassInfo, JsonSerializerOptions options, Utf8JsonWriter writer, WriteStack& state);
    private static bool WriteObject(JsonSerializerOptions options, Utf8JsonWriter writer, WriteStack& state);
    private static bool WriteEndObject(WriteStack& state);
    private static void HandleObject(JsonPropertyInfo jsonPropertyInfo, JsonSerializerOptions options, Utf8JsonWriter writer, WriteStack& state);
    private static void GetRuntimeClassInfo(object value, JsonClassInfo& jsonClassInfo, JsonSerializerOptions options);
    private static void GetRuntimePropertyInfo(object value, JsonClassInfo jsonClassInfo, JsonPropertyInfo& jsonPropertyInfo, JsonSerializerOptions options);
    private static void VerifyValueAndType(object value, Type type);
    private static Byte[] WriteCoreBytes(object value, Type type, JsonSerializerOptions options);
    private static string WriteCoreString(object value, Type type, JsonSerializerOptions options);
    private static void WriteValueCore(Utf8JsonWriter writer, object value, Type type, JsonSerializerOptions options);
    private static void WriteCore(PooledByteBufferWriter output, object value, Type type, JsonSerializerOptions options);
    private static void WriteCore(Utf8JsonWriter writer, object value, Type type, JsonSerializerOptions options);
    public static Task SerializeAsync(Stream utf8Json, TValue value, JsonSerializerOptions options, CancellationToken cancellationToken);
    public static Task SerializeAsync(Stream utf8Json, object value, Type inputType, JsonSerializerOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Text.Json.JsonSerializer/<WriteAsyncCore>d__50")]
private static Task WriteAsyncCore(Stream utf8Json, object value, Type inputType, JsonSerializerOptions options, CancellationToken cancellationToken);
    public static string Serialize(TValue value, JsonSerializerOptions options);
    public static string Serialize(object value, Type inputType, JsonSerializerOptions options);
    public static void Serialize(Utf8JsonWriter writer, TValue value, JsonSerializerOptions options);
    public static void Serialize(Utf8JsonWriter writer, object value, Type inputType, JsonSerializerOptions options);
}
public class System.Text.Json.JsonSerializerOptions : object {
    internal static int BufferSizeDefault;
    internal static JsonSerializerOptions s_defaultOptions;
    private ConcurrentDictionary`2<Type, JsonClassInfo> _classes;
    private ConcurrentDictionary`2<Type, JsonPropertyInfo> _objectJsonProperties;
    private static ConcurrentDictionary`2<string, ImmutableCollectionCreator> s_createRangeDelegates;
    private MemberAccessor _memberAccessorStrategy;
    private JsonNamingPolicy _dictionayKeyPolicy;
    private JsonNamingPolicy _jsonPropertyNamingPolicy;
    private JsonCommentHandling _readCommentHandling;
    private JavaScriptEncoder _encoder;
    private int _defaultBufferSize;
    private int _maxDepth;
    private bool _allowTrailingCommas;
    private bool _haveTypesBeenCreated;
    private bool _ignoreNullValues;
    private bool _ignoreReadOnlyProperties;
    private bool _propertyNameCaseInsensitive;
    private bool _writeIndented;
    [CompilerGeneratedAttribute]
private int <EffectiveMaxDepth>k__BackingField;
    private static Dictionary`2<Type, JsonConverter> s_defaultSimpleConverters;
    private static List`1<JsonConverter> s_defaultFactoryConverters;
    private ConcurrentDictionary`2<Type, JsonConverter> _converters;
    [CompilerGeneratedAttribute]
private IList`1<JsonConverter> <Converters>k__BackingField;
    private static int NumberOfSimpleConverters;
    public bool AllowTrailingCommas { get; public set; }
    public int DefaultBufferSize { get; public set; }
    public JavaScriptEncoder Encoder { get; public set; }
    public JsonNamingPolicy DictionaryKeyPolicy { get; public set; }
    public bool IgnoreNullValues { get; public set; }
    public bool IgnoreReadOnlyProperties { get; public set; }
    public int MaxDepth { get; public set; }
    internal int EffectiveMaxDepth { get; private set; }
    public JsonNamingPolicy PropertyNamingPolicy { get; public set; }
    public bool PropertyNameCaseInsensitive { get; public set; }
    public JsonCommentHandling ReadCommentHandling { get; public set; }
    public bool WriteIndented { get; public set; }
    internal MemberAccessor MemberAccessorStrategy { get; }
    public IList`1<JsonConverter> Converters { get; }
    private static IEnumerable`1<JsonConverter> DefaultSimpleConverters { get; }
    private static JsonSerializerOptions();
    public bool get_AllowTrailingCommas();
    public void set_AllowTrailingCommas(bool value);
    public int get_DefaultBufferSize();
    public void set_DefaultBufferSize(int value);
    public JavaScriptEncoder get_Encoder();
    public void set_Encoder(JavaScriptEncoder value);
    public JsonNamingPolicy get_DictionaryKeyPolicy();
    public void set_DictionaryKeyPolicy(JsonNamingPolicy value);
    public bool get_IgnoreNullValues();
    public void set_IgnoreNullValues(bool value);
    public bool get_IgnoreReadOnlyProperties();
    public void set_IgnoreReadOnlyProperties(bool value);
    public int get_MaxDepth();
    public void set_MaxDepth(int value);
    [CompilerGeneratedAttribute]
internal int get_EffectiveMaxDepth();
    [CompilerGeneratedAttribute]
private void set_EffectiveMaxDepth(int value);
    public JsonNamingPolicy get_PropertyNamingPolicy();
    public void set_PropertyNamingPolicy(JsonNamingPolicy value);
    public bool get_PropertyNameCaseInsensitive();
    public void set_PropertyNameCaseInsensitive(bool value);
    public JsonCommentHandling get_ReadCommentHandling();
    public void set_ReadCommentHandling(JsonCommentHandling value);
    public bool get_WriteIndented();
    public void set_WriteIndented(bool value);
    internal MemberAccessor get_MemberAccessorStrategy();
    internal JsonClassInfo GetOrAddClass(Type classType);
    internal JsonReaderOptions GetReaderOptions();
    internal JsonWriterOptions GetWriterOptions();
    internal JsonPropertyInfo GetJsonPropertyInfoFromClassInfo(Type objectType, JsonSerializerOptions options);
    internal bool CreateRangeDelegatesContainsKey(string key);
    internal bool TryGetCreateRangeDelegate(string delegateKey, ImmutableCollectionCreator& createRangeDelegate);
    internal bool TryAddCreateRangeDelegate(string key, ImmutableCollectionCreator createRangeDelegate);
    internal void VerifyMutable();
    private static Dictionary`2<Type, JsonConverter> GetDefaultSimpleConverters();
    private static List`1<JsonConverter> GetDefaultConverters();
    [CompilerGeneratedAttribute]
public IList`1<JsonConverter> get_Converters();
    internal JsonConverter DetermineConverterForProperty(Type parentClassType, Type runtimePropertyType, PropertyInfo propertyInfo);
    public JsonConverter GetConverter(Type typeToConvert);
    internal bool HasConverter(Type typeToConvert);
    private JsonConverter GetConverterFromAttribute(JsonConverterAttribute converterAttribute, Type typeToConvert, Type classTypeAttributeIsOn, PropertyInfo propertyInfo);
    private static Attribute GetAttributeThatCanHaveMultiple(Type classType, Type attributeType, PropertyInfo propertyInfo);
    private static Attribute GetAttributeThatCanHaveMultiple(Type classType, Type attributeType);
    private static Attribute GetAttributeThatCanHaveMultiple(Type attributeType, Type classType, PropertyInfo propertyInfo, Object[] attributes);
    [IteratorStateMachineAttribute("System.Text.Json.JsonSerializerOptions/<get_DefaultSimpleConverters>d__83")]
private static IEnumerable`1<JsonConverter> get_DefaultSimpleConverters();
}
public enum System.Text.Json.JsonTokenType : Enum {
    public byte value__;
    public static JsonTokenType None;
    public static JsonTokenType StartObject;
    public static JsonTokenType EndObject;
    public static JsonTokenType StartArray;
    public static JsonTokenType EndArray;
    public static JsonTokenType PropertyName;
    public static JsonTokenType Comment;
    public static JsonTokenType String;
    public static JsonTokenType Number;
    public static JsonTokenType True;
    public static JsonTokenType False;
    public static JsonTokenType Null;
}
public enum System.Text.Json.JsonValueKind : Enum {
    public byte value__;
    public static JsonValueKind Undefined;
    public static JsonValueKind Object;
    public static JsonValueKind Array;
    public static JsonValueKind String;
    public static JsonValueKind Number;
    public static JsonValueKind True;
    public static JsonValueKind False;
    public static JsonValueKind Null;
}
internal static class System.Text.Json.JsonWriterHelper : object {
    public static int LastAsciiCharacter;
    private static StandardFormat s_hexStandardFormat;
    private static ReadOnlySpan`1<byte> AllowList { get; }
    private static JsonWriterHelper();
    public static void WriteIndentation(Span`1<byte> buffer, int indent);
    public static void ValidateProperty(ReadOnlySpan`1<byte> propertyName);
    public static void ValidateValue(ReadOnlySpan`1<byte> value);
    public static void ValidateBytes(ReadOnlySpan`1<byte> bytes);
    public static void ValidateDouble(double value);
    public static void ValidateSingle(float value);
    public static void ValidateProperty(ReadOnlySpan`1<char> propertyName);
    public static void ValidateValue(ReadOnlySpan`1<char> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<char> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<byte> value);
    public static void ValidatePropertyAndValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    public static void ValidatePropertyAndBytes(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    public static void ValidatePropertyAndBytes(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<byte> bytes);
    internal static void ValidateNumber(ReadOnlySpan`1<byte> utf8FormattedNumber);
    public static void TrimDateTimeOffset(Span`1<byte> buffer, Int32& bytesWritten);
    private static UInt32 DivMod(UInt32 numerator, UInt32 denominator, UInt32& modulo);
    private static ReadOnlySpan`1<byte> get_AllowList();
    private static bool NeedsEscaping(byte value);
    private static bool NeedsEscapingNoBoundsCheck(char value);
    private static bool NeedsEscaping(char value);
    public static int NeedsEscaping(ReadOnlySpan`1<byte> value, JavaScriptEncoder encoder);
    public static int NeedsEscaping(ReadOnlySpan`1<char> value, JavaScriptEncoder encoder);
    public static int GetMaxEscapedLength(int textLength, int firstIndexToEscape);
    private static void EscapeString(ReadOnlySpan`1<byte> value, Span`1<byte> destination, JavaScriptEncoder encoder, Int32& written);
    public static void EscapeString(ReadOnlySpan`1<byte> value, Span`1<byte> destination, int indexOfFirstByteToEscape, JavaScriptEncoder encoder, Int32& written);
    private static void EscapeNextBytes(byte value, Span`1<byte> destination, Int32& written);
    private static bool IsAsciiValue(byte value);
    private static bool IsAsciiValue(char value);
    private static void EscapeString(ReadOnlySpan`1<char> value, Span`1<char> destination, JavaScriptEncoder encoder, Int32& written);
    public static void EscapeString(ReadOnlySpan`1<char> value, Span`1<char> destination, int indexOfFirstByteToEscape, JavaScriptEncoder encoder, Int32& written);
    private static void EscapeNextChars(char value, Span`1<char> destination, Int32& written);
    private static int WriteHex(int value, Span`1<char> destination, int written);
    private static byte Int32LsbToHexDigit(int value);
    public static OperationStatus ToUtf8(ReadOnlySpan`1<byte> utf16Source, Span`1<byte> utf8Destination, Int32& bytesConsumed, Int32& bytesWritten);
    private static int PtrDiff(Char* a, Char* b);
    private static int PtrDiff(Byte* a, Byte* b);
}
public class System.Text.Json.JsonWriterOptions : ValueType {
    private int _optionsMask;
    [CompilerGeneratedAttribute]
private JavaScriptEncoder <Encoder>k__BackingField;
    private static int IndentBit;
    private static int SkipValidationBit;
    public JavaScriptEncoder Encoder { get; public set; }
    public bool Indented { get; public set; }
    public bool SkipValidation { get; public set; }
    internal bool IndentedOrNotSkipValidation { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public JavaScriptEncoder get_Encoder();
    [CompilerGeneratedAttribute]
public void set_Encoder(JavaScriptEncoder value);
    public bool get_Indented();
    public void set_Indented(bool value);
    public bool get_SkipValidation();
    public void set_SkipValidation(bool value);
    internal bool get_IndentedOrNotSkipValidation();
}
internal abstract class System.Text.Json.MemberAccessor : object {
    public abstract virtual ConstructorDelegate CreateConstructor(Type classType);
    public abstract virtual ImmutableCollectionCreator ImmutableCollectionCreateRange(Type constructingType, Type collectionType, Type elementType);
    public abstract virtual ImmutableCollectionCreator ImmutableDictionaryCreateRange(Type constructingType, Type collectionType, Type elementType);
    protected MethodInfo ImmutableCollectionCreateRangeMethod(Type constructingType, Type elementType);
    protected MethodInfo ImmutableDictionaryCreateRangeMethod(Type constructingType, Type elementType);
    private MethodInfo FindImmutableCreateRangeMethod(Type constructingType);
    public abstract virtual Func`2<object, TProperty> CreatePropertyGetter(PropertyInfo propertyInfo);
    public abstract virtual Action`2<object, TProperty> CreatePropertySetter(PropertyInfo propertyInfo);
}
internal enum System.Text.Json.NumericType : Enum {
    public int value__;
    public static NumericType Byte;
    public static NumericType SByte;
    public static NumericType Int16;
    public static NumericType Int32;
    public static NumericType Int64;
    public static NumericType UInt16;
    public static NumericType UInt32;
    public static NumericType UInt64;
    public static NumericType Single;
    public static NumericType Double;
    public static NumericType Decimal;
}
internal class System.Text.Json.PooledByteBufferWriter : object {
    private Byte[] _rentedBuffer;
    private int _index;
    private static int MinimumBufferSize;
    public ReadOnlyMemory`1<byte> WrittenMemory { get; }
    public int WrittenCount { get; }
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public PooledByteBufferWriter(int initialCapacity);
    public ReadOnlyMemory`1<byte> get_WrittenMemory();
    public int get_WrittenCount();
    public int get_Capacity();
    public int get_FreeCapacity();
    public void Clear();
    private void ClearHelper();
    public sealed virtual void Dispose();
    public sealed virtual void Advance(int count);
    public sealed virtual Memory`1<byte> GetMemory(int sizeHint);
    public sealed virtual Span`1<byte> GetSpan(int sizeHint);
    internal Task WriteToStreamAsync(Stream destination, CancellationToken cancellationToken);
    private void CheckAndResizeBuffer(int sizeHint);
}
[IsReadOnlyAttribute]
internal class System.Text.Json.PropertyRef : ValueType {
    public ulong Key;
    public JsonPropertyInfo Info;
    public PropertyRef(ulong key, JsonPropertyInfo info);
}
[DebuggerDisplayAttribute("Path:{JsonPath()} Current: ClassType.{Current.JsonClassInfo.ClassType}, {Current.JsonClassInfo.Type.Name}")]
internal class System.Text.Json.ReadStack : ValueType {
    internal static Char[] SpecialCharacters;
    public ReadStackFrame Current;
    private List`1<ReadStackFrame> _previous;
    public int _index;
    public long BytesConsumed;
    internal bool ReadAhead;
    public bool IsLastFrame { get; }
    private static ReadStack();
    public void Push();
    public void Pop();
    public bool get_IsLastFrame();
    public string JsonPath();
    private void AppendStackFrame(StringBuilder sb, ReadStackFrame& frame);
    private void AppendPropertyName(StringBuilder sb, string propertyName);
    private string GetPropertyName(ReadStackFrame& frame);
}
[DebuggerDisplayAttribute("ClassType.{JsonClassInfo.ClassType}, {JsonClassInfo.Type.Name}")]
internal class System.Text.Json.ReadStackFrame : ValueType {
    public object ReturnValue;
    public JsonClassInfo JsonClassInfo;
    public string KeyName;
    public Byte[] JsonPropertyName;
    public JsonPropertyInfo JsonPropertyInfo;
    public IList TempEnumerableValues;
    public bool CollectionPropertyInitialized;
    public bool Drain;
    public IDictionary TempDictionaryValues;
    public int PropertyIndex;
    public List`1<PropertyRef> PropertyRefCache;
    public bool SkipProperty { get; }
    public bool IsProcessingCollectionObject();
    public bool IsProcessingCollectionProperty();
    public bool IsProcessingCollection();
    public bool IsProcessingDictionary();
    public bool IsProcessingIDictionaryConstructible();
    public bool IsProcessingDictionaryOrIDictionaryConstructibleObject();
    public bool IsProcessingDictionaryOrIDictionaryConstructibleProperty();
    public bool IsProcessingDictionaryOrIDictionaryConstructible();
    public bool IsProcessingEnumerable();
    public bool IsProcessingObject(ClassType classTypes);
    public bool IsProcessingProperty(ClassType classTypes);
    public bool IsProcessingValue();
    public void Initialize(Type type, JsonSerializerOptions options);
    public void InitializeJsonPropertyInfo();
    public void Reset();
    public void EndObject();
    public void EndProperty();
    public static object CreateEnumerableValue(Utf8JsonReader& reader, ReadStack& state);
    public Type GetElementType();
    public static IEnumerable GetEnumerableValue(ReadStackFrame& current);
    public void SetReturnValue(object value);
    public bool get_SkipProperty();
}
internal class System.Text.Json.ReflectionMemberAccessor : MemberAccessor {
    private static MethodInfo s_createStructPropertyGetterMethod;
    private static MethodInfo s_createStructPropertySetterMethod;
    private static ReflectionMemberAccessor();
    public virtual ConstructorDelegate CreateConstructor(Type type);
    public virtual ImmutableCollectionCreator ImmutableCollectionCreateRange(Type constructingType, Type collectionType, Type elementType);
    public virtual ImmutableCollectionCreator ImmutableDictionaryCreateRange(Type constructingType, Type collectionType, Type elementType);
    public virtual Func`2<object, TProperty> CreatePropertyGetter(PropertyInfo propertyInfo);
    public virtual Action`2<object, TProperty> CreatePropertySetter(PropertyInfo propertyInfo);
    private static TDelegate CreateDelegate(MethodInfo methodInfo);
    private static Func`2<object, TProperty> CreateStructPropertyGetter(GetPropertyByRef`2<TClass, TProperty> get);
    private static Action`2<object, TProperty> CreateStructPropertySetter(SetPropertyByRef`2<TClass, TProperty> set);
}
[DefaultMemberAttribute("Item")]
internal class System.Text.Json.Serialization.ConverterList : object {
    private List`1<JsonConverter> _list;
    private JsonSerializerOptions _options;
    public JsonConverter Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ConverterList(JsonSerializerOptions options);
    public sealed virtual JsonConverter get_Item(int index);
    public sealed virtual void set_Item(int index, JsonConverter value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(JsonConverter item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JsonConverter item);
    public sealed virtual void CopyTo(JsonConverter[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<JsonConverter> GetEnumerator();
    public sealed virtual int IndexOf(JsonConverter item);
    public sealed virtual void Insert(int index, JsonConverter item);
    public sealed virtual bool Remove(JsonConverter item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Text.Json.Serialization.Converters.DefaultArrayConverter : JsonEnumerableConverter {
    public virtual IEnumerable CreateFromList(ReadStack& state, IList sourceList, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.DefaultDerivedDictionaryConverter : JsonDictionaryConverter {
    public virtual object CreateFromDictionary(ReadStack& state, IDictionary sourceDictionary, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.DefaultDerivedEnumerableConverter : JsonEnumerableConverter {
    public virtual IEnumerable CreateFromList(ReadStack& state, IList sourceList, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.DefaultICollectionConverter : JsonEnumerableConverter {
    public virtual IEnumerable CreateFromList(ReadStack& state, IList sourceList, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.DefaultIDictionaryConverter : JsonDictionaryConverter {
    public virtual object CreateFromDictionary(ReadStack& state, IDictionary sourceDictionary, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.DefaultImmutableDictionaryConverter : JsonDictionaryConverter {
    public static string ImmutableDictionaryTypeName;
    public static string ImmutableDictionaryGenericTypeName;
    public static string ImmutableDictionaryGenericInterfaceTypeName;
    public static string ImmutableSortedDictionaryTypeName;
    public static string ImmutableSortedDictionaryGenericTypeName;
    public static void RegisterImmutableDictionary(Type immutableCollectionType, Type elementType, JsonSerializerOptions options);
    public static bool IsImmutableDictionary(Type type);
    public virtual object CreateFromDictionary(ReadStack& state, IDictionary sourceDictionary, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.DefaultImmutableEnumerableConverter : JsonEnumerableConverter {
    public static string ImmutableArrayTypeName;
    public static string ImmutableArrayGenericTypeName;
    private static string ImmutableListTypeName;
    public static string ImmutableListGenericTypeName;
    public static string ImmutableListGenericInterfaceTypeName;
    private static string ImmutableStackTypeName;
    public static string ImmutableStackGenericTypeName;
    public static string ImmutableStackGenericInterfaceTypeName;
    private static string ImmutableQueueTypeName;
    public static string ImmutableQueueGenericTypeName;
    public static string ImmutableQueueGenericInterfaceTypeName;
    public static string ImmutableSortedSetTypeName;
    public static string ImmutableSortedSetGenericTypeName;
    private static string ImmutableHashSetTypeName;
    public static string ImmutableHashSetGenericTypeName;
    public static string ImmutableSetGenericInterfaceTypeName;
    public static string GetDelegateKey(Type immutableCollectionType, Type elementType, Type& underlyingType, String& constructingTypeName);
    public static void RegisterImmutableCollection(Type immutableCollectionType, Type elementType, JsonSerializerOptions options);
    public virtual IEnumerable CreateFromList(ReadStack& state, IList sourceList, JsonSerializerOptions options);
}
[FlagsAttribute]
internal enum System.Text.Json.Serialization.Converters.EnumConverterOptions : Enum {
    public int value__;
    public static EnumConverterOptions AllowStrings;
    public static EnumConverterOptions AllowNumbers;
}
internal class System.Text.Json.Serialization.Converters.JsonConverterBoolean : JsonConverter`1<bool> {
    public virtual bool Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, bool value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterByte : JsonConverter`1<byte> {
    public virtual byte Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, byte value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterByteArray : JsonConverter`1<Byte[]> {
    public virtual Byte[] Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Byte[] value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterChar : JsonConverter`1<char> {
    public virtual char Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, char value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterDateTime : JsonConverter`1<DateTime> {
    public virtual DateTime Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DateTime value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterDateTimeOffset : JsonConverter`1<DateTimeOffset> {
    public virtual DateTimeOffset Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, DateTimeOffset value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterDecimal : JsonConverter`1<decimal> {
    public virtual decimal Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, decimal value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterDouble : JsonConverter`1<double> {
    public virtual double Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, double value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterEnum : JsonConverterFactory {
    public virtual bool CanConvert(Type type);
    public virtual JsonConverter CreateConverter(Type type, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterEnum`1 : JsonConverter`1<T> {
    private static TypeCode s_enumTypeCode;
    private static string s_negativeSign;
    private EnumConverterOptions _converterOptions;
    private JsonNamingPolicy _namingPolicy;
    private ConcurrentDictionary`2<string, string> _nameCache;
    public JsonConverterEnum`1(EnumConverterOptions options);
    public JsonConverterEnum`1(EnumConverterOptions options, JsonNamingPolicy namingPolicy);
    private static JsonConverterEnum`1();
    public virtual bool CanConvert(Type type);
    public virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    private static bool IsValidIdentifier(string value);
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterGuid : JsonConverter`1<Guid> {
    public virtual Guid Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Guid value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterInt16 : JsonConverter`1<short> {
    public virtual short Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, short value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterInt32 : JsonConverter`1<int> {
    public virtual int Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, int value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterInt64 : JsonConverter`1<long> {
    public virtual long Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, long value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterJsonElement : JsonConverter`1<JsonElement> {
    public virtual JsonElement Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, JsonElement value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterObject : JsonConverter`1<object> {
    public virtual object Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, object value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterSByte : JsonConverter`1<sbyte> {
    public virtual sbyte Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, sbyte value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterSingle : JsonConverter`1<float> {
    public virtual float Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, float value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterString : JsonConverter`1<string> {
    public virtual string Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterUInt16 : JsonConverter`1<ushort> {
    public virtual ushort Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ushort value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterUInt32 : JsonConverter`1<UInt32> {
    public virtual UInt32 Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, UInt32 value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterUInt64 : JsonConverter`1<ulong> {
    public virtual ulong Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, ulong value, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonConverterUri : JsonConverter`1<Uri> {
    public virtual Uri Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Uri value, JsonSerializerOptions options);
}
internal abstract class System.Text.Json.Serialization.Converters.JsonDictionaryConverter : object {
    public abstract virtual object CreateFromDictionary(ReadStack& state, IDictionary sourceDictionary, JsonSerializerOptions options);
}
internal abstract class System.Text.Json.Serialization.Converters.JsonEnumerableConverter : object {
    public abstract virtual IEnumerable CreateFromList(ReadStack& state, IList sourceList, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonKeyValuePairConverter : JsonConverterFactory {
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type type, JsonSerializerOptions options);
}
internal class System.Text.Json.Serialization.Converters.JsonKeyValuePairConverter`2 : JsonConverter`1<KeyValuePair`2<TKey, TValue>> {
    private static string KeyName;
    private static string ValueName;
    private static JsonEncodedText _keyName;
    private static JsonEncodedText _valueName;
    private static JsonKeyValuePairConverter`2();
    public virtual KeyValuePair`2<TKey, TValue> Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    private T ReadProperty(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    private void WriteProperty(Utf8JsonWriter writer, T value, JsonEncodedText name, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, KeyValuePair`2<TKey, TValue> value, JsonSerializerOptions options);
}
internal enum System.Text.Json.Serialization.ExtensionDataWriteStatus : Enum {
    public byte value__;
    public static ExtensionDataWriteStatus NotStarted;
    public static ExtensionDataWriteStatus Writing;
    public static ExtensionDataWriteStatus Finished;
}
public abstract class System.Text.Json.Serialization.JsonAttribute : Attribute {
}
public abstract class System.Text.Json.Serialization.JsonConverter : object {
    internal Type TypeToConvert { get; }
    public abstract virtual bool CanConvert(Type typeToConvert);
    internal virtual Type get_TypeToConvert();
}
public abstract class System.Text.Json.Serialization.JsonConverter`1 : JsonConverter {
    internal Type TypeToConvert { get; }
    public virtual bool CanConvert(Type typeToConvert);
    public abstract virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public abstract virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    internal virtual Type get_TypeToConvert();
}
[AttributeUsageAttribute("156")]
public class System.Text.Json.Serialization.JsonConverterAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private Type <ConverterType>k__BackingField;
    public Type ConverterType { get; private set; }
    public JsonConverterAttribute(Type converterType);
    [CompilerGeneratedAttribute]
public Type get_ConverterType();
    [CompilerGeneratedAttribute]
private void set_ConverterType(Type value);
    public virtual JsonConverter CreateConverter(Type typeToConvert);
}
public abstract class System.Text.Json.Serialization.JsonConverterFactory : JsonConverter {
    internal JsonConverter GetConverterInternal(Type typeToConvert, JsonSerializerOptions options);
    public abstract virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
[AttributeUsageAttribute("128")]
public class System.Text.Json.Serialization.JsonExtensionDataAttribute : JsonAttribute {
}
[AttributeUsageAttribute("128")]
public class System.Text.Json.Serialization.JsonIgnoreAttribute : JsonAttribute {
}
internal class System.Text.Json.Serialization.JsonPropertyInfoNotNullableContravariant`4 : JsonPropertyInfoCommon`4<TClass, TDeclaredProperty, TRuntimeProperty, TConverter> {
    protected virtual void OnRead(ReadStack& state, Utf8JsonReader& reader);
    protected virtual void OnReadEnumerable(ReadStack& state, Utf8JsonReader& reader);
    protected virtual void OnWrite(WriteStackFrame& current, Utf8JsonWriter writer);
    protected virtual void OnWriteDictionary(WriteStackFrame& current, Utf8JsonWriter writer);
    protected virtual void OnWriteEnumerable(WriteStackFrame& current, Utf8JsonWriter writer);
    public virtual Type GetDictionaryConcreteType();
    public virtual void GetDictionaryKeyAndValueFromGenericDictionary(WriteStackFrame& writeStackFrame, String& key, Object& value);
}
[AttributeUsageAttribute("128")]
public class System.Text.Json.Serialization.JsonPropertyNameAttribute : JsonAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    public JsonPropertyNameAttribute(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
}
public class System.Text.Json.Serialization.JsonStringEnumConverter : JsonConverterFactory {
    private JsonNamingPolicy _namingPolicy;
    private EnumConverterOptions _converterOptions;
    public JsonStringEnumConverter(JsonNamingPolicy namingPolicy, bool allowIntegerValues);
    public virtual bool CanConvert(Type typeToConvert);
    public virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
internal static class System.Text.Json.ThrowHelper : object {
    public static string ExceptionSourceValueToRethrowAsJsonException;
    public static ArgumentOutOfRangeException GetArgumentOutOfRangeException_MaxDepthMustBePositive(string parameterName);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(string parameterName, string message);
    public static ArgumentOutOfRangeException GetArgumentOutOfRangeException_CommentEnumMustBeInRange(string parameterName);
    private static ArgumentException GetArgumentException(string message);
    public static void ThrowArgumentException(string message);
    public static InvalidOperationException GetInvalidOperationException_CallFlushFirst(int _buffered);
    public static void ThrowArgumentException_PropertyNameTooLarge(int tokenLength);
    public static void ThrowArgumentException_ValueTooLarge(int tokenLength);
    public static void ThrowArgumentException_ValueNotSupported();
    public static void ThrowInvalidOperationException_NeedLargerSpan();
    public static void ThrowArgumentException(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<byte> value);
    public static void ThrowArgumentException(ReadOnlySpan`1<byte> propertyName, ReadOnlySpan`1<char> value);
    public static void ThrowArgumentException(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    public static void ThrowArgumentException(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    public static void ThrowInvalidOperationOrArgumentException(ReadOnlySpan`1<byte> propertyName, int currentDepth);
    public static void ThrowInvalidOperationException(int currentDepth);
    public static void ThrowInvalidOperationException(string message);
    private static InvalidOperationException GetInvalidOperationException(string message);
    public static void ThrowInvalidOperationException_DepthNonZeroOrEmptyJson(int currentDepth);
    private static InvalidOperationException GetInvalidOperationException(int currentDepth);
    public static void ThrowInvalidOperationOrArgumentException(ReadOnlySpan`1<char> propertyName, int currentDepth);
    public static InvalidOperationException GetInvalidOperationException_ExpectedNumber(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedBoolean(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedString(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedStringComparison(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_ExpectedComment(JsonTokenType tokenType);
    public static InvalidOperationException GetInvalidOperationException_CannotSkipOnPartial();
    private static InvalidOperationException GetInvalidOperationException(string message, JsonTokenType tokenType);
    private static InvalidOperationException GetInvalidOperationException(JsonTokenType tokenType);
    internal static InvalidOperationException GetJsonElementWrongTypeException(JsonTokenType expectedType, JsonTokenType actualType);
    internal static InvalidOperationException GetJsonElementWrongTypeException(string expectedTypeName, JsonTokenType actualType);
    public static void ThrowJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, byte nextByte, ReadOnlySpan`1<byte> bytes);
    public static JsonException GetJsonReaderException(Utf8JsonReader& json, ExceptionResource resource, byte nextByte, ReadOnlySpan`1<byte> bytes);
    private static bool IsPrintable(byte value);
    internal static string GetPrintableString(byte value);
    private static string GetResourceString(Utf8JsonReader& json, ExceptionResource resource, byte nextByte, string characters);
    public static void ThrowInvalidOperationException(ExceptionResource resource, int currentDepth, byte token, JsonTokenType tokenType);
    public static void ThrowArgumentException_InvalidCommentValue();
    public static void ThrowArgumentException_InvalidUTF8(ReadOnlySpan`1<byte> value);
    public static void ThrowArgumentException_InvalidUTF16(int charAsInt);
    public static void ThrowInvalidOperationException_ReadInvalidUTF16(int charAsInt);
    public static void ThrowInvalidOperationException_ReadInvalidUTF16();
    public static InvalidOperationException GetInvalidOperationException_ReadInvalidUTF8(DecoderFallbackException innerException);
    public static ArgumentException GetArgumentException_ReadInvalidUTF16(EncoderFallbackException innerException);
    public static InvalidOperationException GetInvalidOperationException(string message, Exception innerException);
    public static InvalidOperationException GetInvalidOperationException(ExceptionResource resource, int currentDepth, byte token, JsonTokenType tokenType);
    private static string GetResourceString(ExceptionResource resource, int currentDepth, byte token, JsonTokenType tokenType);
    public static FormatException GetFormatException();
    public static FormatException GetFormatException(NumericType numericType);
    public static FormatException GetFormatException(DataType dateType);
    public static void ThrowArgumentException_DeserializeWrongType(Type type, object value);
    public static NotSupportedException GetNotSupportedException_SerializationNotSupportedCollection(Type propertyType, Type parentType, MemberInfo memberInfo);
    public static void ThrowInvalidOperationException_SerializerCycleDetected(int maxDepth);
    public static void ThrowJsonException_DeserializeUnableToConvertValue(Type propertyType);
    public static void ThrowJsonException_DeserializeUnableToConvertValue(Type propertyType, string path, Exception innerException);
    public static void ThrowJsonException_DepthTooLarge(int currentDepth, JsonSerializerOptions options);
    public static void ThrowJsonException_SerializationConverterRead(JsonConverter converter);
    public static void ThrowJsonException_SerializationConverterWrite(JsonConverter converter);
    public static void ThrowJsonException();
    public static void ThrowInvalidOperationException_SerializationConverterNotCompatible(Type converterType, Type type);
    public static void ThrowInvalidOperationException_SerializationConverterOnAttributeInvalid(Type classType, PropertyInfo propertyInfo);
    public static void ThrowInvalidOperationException_SerializationConverterOnAttributeNotCompatible(Type classTypeAttributeIsOn, PropertyInfo propertyInfo, Type typeToConvert);
    public static void ThrowInvalidOperationException_SerializerOptionsImmutable();
    public static void ThrowInvalidOperationException_SerializerPropertyNameConflict(JsonClassInfo jsonClassInfo, JsonPropertyInfo jsonPropertyInfo);
    public static void ThrowInvalidOperationException_SerializerPropertyNameNull(Type parentType, JsonPropertyInfo jsonPropertyInfo);
    public static void ThrowInvalidOperationException_SerializerDictionaryKeyNull(Type policyType);
    public static void ReThrowWithPath(ReadStack& readStack, JsonReaderException ex);
    public static void ReThrowWithPath(ReadStack& readStack, Utf8JsonReader& reader, Exception ex);
    public static void AddExceptionInformation(ReadStack& readStack, Utf8JsonReader& reader, JsonException ex);
    public static void ReThrowWithPath(WriteStack& writeStack, Exception ex);
    public static void AddExceptionInformation(WriteStack& writeStack, JsonException ex);
    public static void ThrowInvalidOperationException_SerializationDuplicateAttribute(Type attribute, Type classType, PropertyInfo propertyInfo);
    public static void ThrowInvalidOperationException_SerializationDuplicateTypeAttribute(Type classType, Type attribute);
    public static void ThrowInvalidOperationException_SerializationDataExtensionPropertyInvalid(JsonClassInfo jsonClassInfo, JsonPropertyInfo jsonPropertyInfo);
    public static void ThrowNotSupportedException_DeserializeCreateObjectDelegateIsNull(Type invalidType);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.Utf8JsonReader : ValueType {
    private ReadOnlySpan`1<byte> _buffer;
    private bool _isFinalBlock;
    private bool _isInputSequence;
    private long _lineNumber;
    private long _bytePositionInLine;
    private int _consumed;
    private bool _inObject;
    private bool _isNotPrimitive;
    internal char _numberFormat;
    private JsonTokenType _tokenType;
    private JsonTokenType _previousTokenType;
    private JsonReaderOptions _readerOptions;
    private BitStack _bitStack;
    private long _totalConsumed;
    private bool _isLastSegment;
    internal bool _stringHasEscaping;
    private bool _isMultiSegment;
    private bool _trailingCommaBeforeComment;
    private SequencePosition _nextPosition;
    private SequencePosition _currentPosition;
    private ReadOnlySequence`1<byte> _sequence;
    [CompilerGeneratedAttribute]
private ReadOnlySpan`1<byte> <ValueSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private long <TokenStartIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValueSequence>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlySequence`1<byte> <ValueSequence>k__BackingField;
    private bool IsLastSpan { get; }
    internal ReadOnlySequence`1<byte> OriginalSequence { get; }
    internal ReadOnlySpan`1<byte> OriginalSpan { get; }
    public ReadOnlySpan`1<byte> ValueSpan { get; private set; }
    public long BytesConsumed { get; }
    public long TokenStartIndex { get; private set; }
    public int CurrentDepth { get; }
    internal bool IsInArray { get; }
    public JsonTokenType TokenType { get; }
    public bool HasValueSequence { get; private set; }
    public bool IsFinalBlock { get; }
    public ReadOnlySequence`1<byte> ValueSequence { get; private set; }
    public SequencePosition Position { get; }
    public JsonReaderState CurrentState { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private string DebugTokenType { get; }
    public Utf8JsonReader(ReadOnlySpan`1<byte> jsonData, bool isFinalBlock, JsonReaderState state);
    public Utf8JsonReader(ReadOnlySpan`1<byte> jsonData, JsonReaderOptions options);
    public Utf8JsonReader(ReadOnlySequence`1<byte> jsonData, bool isFinalBlock, JsonReaderState state);
    public Utf8JsonReader(ReadOnlySequence`1<byte> jsonData, JsonReaderOptions options);
    private bool get_IsLastSpan();
    internal ReadOnlySequence`1<byte> get_OriginalSequence();
    internal ReadOnlySpan`1<byte> get_OriginalSpan();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySpan`1<byte> get_ValueSpan();
    [CompilerGeneratedAttribute]
private void set_ValueSpan(ReadOnlySpan`1<byte> value);
    public long get_BytesConsumed();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public long get_TokenStartIndex();
    [CompilerGeneratedAttribute]
private void set_TokenStartIndex(long value);
    public int get_CurrentDepth();
    internal bool get_IsInArray();
    public JsonTokenType get_TokenType();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public bool get_HasValueSequence();
    [CompilerGeneratedAttribute]
private void set_HasValueSequence(bool value);
    public bool get_IsFinalBlock();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ReadOnlySequence`1<byte> get_ValueSequence();
    [CompilerGeneratedAttribute]
private void set_ValueSequence(ReadOnlySequence`1<byte> value);
    public SequencePosition get_Position();
    public JsonReaderState get_CurrentState();
    public bool Read();
    public void Skip();
    private void SkipHelper();
    public bool TrySkip();
    private bool TrySkipHelper();
    public bool ValueTextEquals(ReadOnlySpan`1<byte> utf8Text);
    public bool ValueTextEquals(string text);
    private bool TextEqualsHelper(ReadOnlySpan`1<byte> otherUtf8Text);
    public bool ValueTextEquals(ReadOnlySpan`1<char> text);
    private bool CompareToSequence(ReadOnlySpan`1<byte> other);
    private bool UnescapeAndCompare(ReadOnlySpan`1<byte> other);
    private bool UnescapeSequenceAndCompare(ReadOnlySpan`1<byte> other);
    private static bool IsTokenTypeString(JsonTokenType tokenType);
    private bool MatchNotPossible(int charTextLength);
    private bool MatchNotPossibleSequence(int charTextLength);
    private void StartObject();
    private void EndObject();
    private void StartArray();
    private void EndArray();
    private void UpdateBitStackOnEndToken();
    private bool ReadSingleSegment();
    private bool HasMoreData();
    private bool HasMoreData(ExceptionResource resource);
    private bool ReadFirstToken(byte first);
    private void SkipWhiteSpace();
    private bool ConsumeValue(byte marker);
    private bool ConsumeLiteral(ReadOnlySpan`1<byte> literal, JsonTokenType tokenType);
    private bool CheckLiteral(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> literal);
    private void ThrowInvalidLiteral(ReadOnlySpan`1<byte> span);
    private bool ConsumeNumber();
    private bool ConsumePropertyName();
    private bool ConsumeString();
    private bool ConsumeStringAndValidate(ReadOnlySpan`1<byte> data, int idx);
    private bool ValidateHexDigits(ReadOnlySpan`1<byte> data, int idx);
    private bool TryGetNumber(ReadOnlySpan`1<byte> data, Int32& consumed);
    private ConsumeNumberResult ConsumeNegativeSign(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeZero(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeIntegerDigits(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeDecimalDigits(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeSign(ReadOnlySpan`1& data, Int32& i);
    private bool ConsumeNextTokenOrRollback(byte marker);
    private ConsumeTokenResult ConsumeNextToken(byte marker);
    private ConsumeTokenResult ConsumeNextTokenFromLastNonCommentToken();
    private bool SkipAllComments(Byte& marker);
    private bool SkipAllComments(Byte& marker, ExceptionResource resource);
    private ConsumeTokenResult ConsumeNextTokenUntilAfterAllCommentsAreSkipped(byte marker);
    private bool SkipComment();
    private bool SkipSingleLineComment(ReadOnlySpan`1<byte> localBuffer, Int32& idx);
    private int FindLineSeparator(ReadOnlySpan`1<byte> localBuffer);
    private void ThrowOnDangerousLineSeparator(ReadOnlySpan`1<byte> localBuffer);
    private bool SkipMultiLineComment(ReadOnlySpan`1<byte> localBuffer, Int32& idx);
    private bool ConsumeComment();
    private bool ConsumeSingleLineComment(ReadOnlySpan`1<byte> localBuffer, int previousConsumed);
    private bool ConsumeMultiLineComment(ReadOnlySpan`1<byte> localBuffer, int previousConsumed);
    private string get_DebuggerDisplay();
    private string get_DebugTokenType();
    private bool ReadMultiSegment();
    private bool ValidateStateAtEndOfData();
    private bool HasMoreDataMultiSegment();
    private bool HasMoreDataMultiSegment(ExceptionResource resource);
    private bool GetNextSpan();
    private bool ReadFirstTokenMultiSegment(byte first);
    private void SkipWhiteSpaceMultiSegment();
    private bool ConsumeValueMultiSegment(byte marker);
    private bool ConsumeLiteralMultiSegment(ReadOnlySpan`1<byte> literal, JsonTokenType tokenType);
    private bool CheckLiteralMultiSegment(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> literal, Int32& consumed);
    private int FindMismatch(ReadOnlySpan`1<byte> span, ReadOnlySpan`1<byte> literal);
    private JsonException GetInvalidLiteralMultiSegment(ReadOnlySpan`1<byte> span);
    private bool ConsumeNumberMultiSegment();
    private bool ConsumePropertyNameMultiSegment();
    private bool ConsumeStringMultiSegment();
    private bool ConsumeStringNextSegment();
    private bool ConsumeStringAndValidateMultiSegment(ReadOnlySpan`1<byte> data, int idx);
    private void RollBackState(PartialStateForRollback& state, bool isError);
    private bool TryGetNumberMultiSegment(ReadOnlySpan`1<byte> data, Int32& consumed);
    private ConsumeNumberResult ConsumeNegativeSignMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private ConsumeNumberResult ConsumeZeroMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private ConsumeNumberResult ConsumeIntegerDigitsMultiSegment(ReadOnlySpan`1& data, Int32& i);
    private ConsumeNumberResult ConsumeDecimalDigitsMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private ConsumeNumberResult ConsumeSignMultiSegment(ReadOnlySpan`1& data, Int32& i, PartialStateForRollback& rollBackState);
    private bool ConsumeNextTokenOrRollbackMultiSegment(byte marker);
    private ConsumeTokenResult ConsumeNextTokenMultiSegment(byte marker);
    private ConsumeTokenResult ConsumeNextTokenFromLastNonCommentTokenMultiSegment();
    private bool SkipAllCommentsMultiSegment(Byte& marker);
    private bool SkipAllCommentsMultiSegment(Byte& marker, ExceptionResource resource);
    private ConsumeTokenResult ConsumeNextTokenUntilAfterAllCommentsAreSkippedMultiSegment(byte marker);
    private bool SkipOrConsumeCommentMultiSegmentWithRollback();
    private bool SkipCommentMultiSegment(Int32& tailBytesToIgnore);
    private bool SkipSingleLineCommentMultiSegment(ReadOnlySpan`1<byte> localBuffer, Int32& tailBytesToSkip);
    private int FindLineSeparatorMultiSegment(ReadOnlySpan`1<byte> localBuffer, Int32& dangerousLineSeparatorBytesConsumed);
    private void ThrowOnDangerousLineSeparatorMultiSegment(ReadOnlySpan`1<byte> localBuffer, Int32& dangerousLineSeparatorBytesConsumed);
    private bool SkipMultiLineCommentMultiSegment(ReadOnlySpan`1<byte> localBuffer);
    private PartialStateForRollback CaptureState();
    public string GetString();
    public string GetComment();
    public bool GetBoolean();
    public Byte[] GetBytesFromBase64();
    public byte GetByte();
    [CLSCompliantAttribute("False")]
public sbyte GetSByte();
    public short GetInt16();
    public int GetInt32();
    public long GetInt64();
    [CLSCompliantAttribute("False")]
public ushort GetUInt16();
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32();
    [CLSCompliantAttribute("False")]
public ulong GetUInt64();
    public float GetSingle();
    public double GetDouble();
    public decimal GetDecimal();
    public DateTime GetDateTime();
    public DateTimeOffset GetDateTimeOffset();
    public Guid GetGuid();
    public bool TryGetBytesFromBase64(Byte[]& value);
    public bool TryGetByte(Byte& value);
    [CLSCompliantAttribute("False")]
public bool TryGetSByte(SByte& value);
    public bool TryGetInt16(Int16& value);
    public bool TryGetInt32(Int32& value);
    public bool TryGetInt64(Int64& value);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt16(UInt16& value);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt32(UInt32& value);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt64(UInt64& value);
    public bool TryGetSingle(Single& value);
    public bool TryGetDouble(Double& value);
    public bool TryGetDecimal(Decimal& value);
    public bool TryGetDateTime(DateTime& value);
    public bool TryGetDateTimeOffset(DateTimeOffset& value);
    public bool TryGetGuid(Guid& value);
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class System.Text.Json.Utf8JsonWriter : object {
    private static int s_newLineLength;
    private static int DefaultGrowthSize;
    private static int InitialGrowthSize;
    private IBufferWriter`1<byte> _output;
    private Stream _stream;
    private ArrayBufferWriter`1<byte> _arrayBufferWriter;
    private Memory`1<byte> _memory;
    private bool _inObject;
    private JsonTokenType _tokenType;
    private BitStack _bitStack;
    private int _currentDepth;
    private JsonWriterOptions _options;
    [CompilerGeneratedAttribute]
private int <BytesPending>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BytesCommitted>k__BackingField;
    private static Char[] s_singleLineCommentDelimiter;
    private static StandardFormat s_dateTimeStandardFormat;
    public int BytesPending { get; private set; }
    public long BytesCommitted { get; private set; }
    public JsonWriterOptions Options { get; }
    private int Indentation { get; }
    public int CurrentDepth { get; }
    [DebuggerBrowsableAttribute("0")]
private string DebuggerDisplay { get; }
    private static ReadOnlySpan`1<byte> SingleLineCommentDelimiterUtf8 { get; }
    public Utf8JsonWriter(IBufferWriter`1<byte> bufferWriter, JsonWriterOptions options);
    public Utf8JsonWriter(Stream utf8Json, JsonWriterOptions options);
    private static Utf8JsonWriter();
    [CompilerGeneratedAttribute]
public int get_BytesPending();
    [CompilerGeneratedAttribute]
private void set_BytesPending(int value);
    [CompilerGeneratedAttribute]
public long get_BytesCommitted();
    [CompilerGeneratedAttribute]
private void set_BytesCommitted(long value);
    public JsonWriterOptions get_Options();
    private int get_Indentation();
    public int get_CurrentDepth();
    public void Reset();
    public void Reset(Stream utf8Json);
    public void Reset(IBufferWriter`1<byte> bufferWriter);
    private void ResetHelper();
    private void CheckNotDisposed();
    public void Flush();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("System.Text.Json.Utf8JsonWriter/<DisposeAsync>d__35")]
public sealed virtual ValueTask DisposeAsync();
    [AsyncStateMachineAttribute("System.Text.Json.Utf8JsonWriter/<FlushAsync>d__36")]
public Task FlushAsync(CancellationToken cancellationToken);
    public void WriteStartArray();
    public void WriteStartObject();
    private void WriteStart(byte token);
    private void WriteStartMinimized(byte token);
    private void WriteStartSlow(byte token);
    private void ValidateStart();
    private void WriteStartIndented(byte token);
    public void WriteStartArray(JsonEncodedText propertyName);
    public void WriteStartObject(JsonEncodedText propertyName);
    private void WriteStartHelper(ReadOnlySpan`1<byte> utf8PropertyName, byte token);
    public void WriteStartArray(ReadOnlySpan`1<byte> utf8PropertyName);
    public void WriteStartObject(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WriteStartEscape(ReadOnlySpan`1<byte> utf8PropertyName, byte token);
    private void WriteStartByOptions(ReadOnlySpan`1<byte> utf8PropertyName, byte token);
    private void WriteStartEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, byte token, int firstEscapeIndexProp);
    public void WriteStartArray(string propertyName);
    public void WriteStartObject(string propertyName);
    public void WriteStartArray(ReadOnlySpan`1<char> propertyName);
    public void WriteStartObject(ReadOnlySpan`1<char> propertyName);
    private void WriteStartEscape(ReadOnlySpan`1<char> propertyName, byte token);
    private void WriteStartByOptions(ReadOnlySpan`1<char> propertyName, byte token);
    private void WriteStartEscapeProperty(ReadOnlySpan`1<char> propertyName, byte token, int firstEscapeIndexProp);
    public void WriteEndArray();
    public void WriteEndObject();
    private void WriteEnd(byte token);
    private void WriteEndMinimized(byte token);
    private void WriteEndSlow(byte token);
    private void ValidateEnd(byte token);
    private void WriteEndIndented(byte token);
    private void WriteNewLine(Span`1<byte> output);
    private void UpdateBitStackOnStart(byte token);
    private void Grow(int requiredSize);
    private void FirstCallToGetMemory(int requiredSize);
    private void SetFlagToAddListSeparatorBeforeNextItem();
    private string get_DebuggerDisplay();
    public void WriteBase64String(JsonEncodedText propertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64StringHelper(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(string propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Escape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Escape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64EscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes, int firstEscapeIndexProp);
    private void WriteBase64EscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes, int firstEscapeIndexProp);
    private void WriteBase64ByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64ByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Minimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Minimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Indented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Indented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteString(JsonEncodedText propertyName, DateTime value);
    private void WriteStringHelper(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    public void WriteString(string propertyName, DateTime value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, DateTime value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, DateTime value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, DateTime value, int firstEscapeIndexProp);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value, int firstEscapeIndexProp);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, DateTime value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, DateTime value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, DateTime value);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, DateTime value);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, DateTime value);
    public void WriteString(JsonEncodedText propertyName, DateTimeOffset value);
    private void WriteStringHelper(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    public void WriteString(string propertyName, DateTimeOffset value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, DateTimeOffset value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, DateTimeOffset value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, DateTimeOffset value, int firstEscapeIndexProp);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value, int firstEscapeIndexProp);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, DateTimeOffset value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, DateTimeOffset value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, DateTimeOffset value);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, DateTimeOffset value);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, DateTimeOffset value);
    public void WriteNumber(JsonEncodedText propertyName, decimal value);
    private void WriteNumberHelper(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    public void WriteNumber(string propertyName, decimal value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, decimal value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, decimal value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, decimal value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, decimal value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, decimal value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, decimal value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, decimal value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, decimal value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, decimal value);
    public void WriteNumber(JsonEncodedText propertyName, double value);
    private void WriteNumberHelper(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    public void WriteNumber(string propertyName, double value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, double value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, double value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, double value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, double value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, double value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, double value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, double value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, double value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, double value);
    public void WriteNumber(JsonEncodedText propertyName, float value);
    private void WriteNumberHelper(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    public void WriteNumber(string propertyName, float value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, float value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, float value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, float value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, float value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, float value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, float value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, float value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, float value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, float value);
    internal void WriteNumber(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8FormattedNumber);
    internal void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8FormattedNumber);
    internal void WriteNumber(JsonEncodedText propertyName, ReadOnlySpan`1<byte> utf8FormattedNumber);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    public void WriteString(JsonEncodedText propertyName, Guid value);
    private void WriteStringHelper(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    public void WriteString(string propertyName, Guid value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, Guid value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, Guid value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, Guid value, int firstEscapeIndexProp);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, Guid value, int firstEscapeIndexProp);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, Guid value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, Guid value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, Guid value);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, Guid value);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, Guid value);
    private void ValidatePropertyNameAndDepth(ReadOnlySpan`1<char> propertyName);
    private void ValidatePropertyNameAndDepth(ReadOnlySpan`1<byte> utf8PropertyName);
    private void ValidateDepth();
    private void ValidateWritingProperty();
    private void ValidateWritingProperty(byte token);
    private void WritePropertyNameMinimized(ReadOnlySpan`1<byte> escapedPropertyName, byte token);
    private void WritePropertyNameIndented(ReadOnlySpan`1<byte> escapedPropertyName, byte token);
    private void WritePropertyNameMinimized(ReadOnlySpan`1<char> escapedPropertyName, byte token);
    private void WritePropertyNameIndented(ReadOnlySpan`1<char> escapedPropertyName, byte token);
    private void TranscodeAndWrite(ReadOnlySpan`1<char> escapedPropertyName, Span`1<byte> output);
    public void WriteNull(JsonEncodedText propertyName);
    private void WriteLiteralHelper(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    public void WriteNull(string propertyName);
    public void WriteNull(ReadOnlySpan`1<char> propertyName);
    public void WriteNull(ReadOnlySpan`1<byte> utf8PropertyName);
    public void WriteBoolean(JsonEncodedText propertyName, bool value);
    public void WriteBoolean(string propertyName, bool value);
    public void WriteBoolean(ReadOnlySpan`1<char> propertyName, bool value);
    public void WriteBoolean(ReadOnlySpan`1<byte> utf8PropertyName, bool value);
    private void WriteLiteralEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralEscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteLiteralEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value, int firstEscapeIndexProp);
    private void WriteLiteralByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralMinimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralIndented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> value);
    private void WriteLiteralIndented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> value);
    public void WriteNumber(JsonEncodedText propertyName, long value);
    private void WriteNumberHelper(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    public void WriteNumber(string propertyName, long value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, long value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    public void WriteNumber(JsonEncodedText propertyName, int value);
    public void WriteNumber(string propertyName, int value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, int value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, int value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, long value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, long value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, long value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, long value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, long value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, long value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, long value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, long value);
    public void WritePropertyName(JsonEncodedText propertyName);
    private void WritePropertyNameHelper(ReadOnlySpan`1<byte> utf8PropertyName);
    public void WritePropertyName(string propertyName);
    public void WritePropertyName(ReadOnlySpan`1<char> propertyName);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<char> propertyName, int firstEscapeIndexProp);
    private void WriteStringByOptionsPropertyName(ReadOnlySpan`1<char> propertyName);
    private void WriteStringMinimizedPropertyName(ReadOnlySpan`1<char> escapedPropertyName);
    private void WriteStringIndentedPropertyName(ReadOnlySpan`1<char> escapedPropertyName);
    public void WritePropertyName(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WriteStringEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, int firstEscapeIndexProp);
    private void WriteStringByOptionsPropertyName(ReadOnlySpan`1<byte> utf8PropertyName);
    private void WriteStringMinimizedPropertyName(ReadOnlySpan`1<byte> escapedPropertyName);
    private void WriteStringIndentedPropertyName(ReadOnlySpan`1<byte> escapedPropertyName);
    public void WriteString(JsonEncodedText propertyName, JsonEncodedText value);
    private void WriteStringHelper(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(string propertyName, JsonEncodedText value);
    public void WriteString(string propertyName, string value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(JsonEncodedText propertyName, string value);
    public void WriteString(JsonEncodedText propertyName, ReadOnlySpan`1<char> value);
    private void WriteStringHelperEscapeValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    public void WriteString(string propertyName, ReadOnlySpan`1<char> value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    public void WriteString(JsonEncodedText propertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringHelperEscapeValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(string propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, JsonEncodedText value);
    private void WriteStringHelperEscapeProperty(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, string value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, JsonEncodedText value);
    private void WriteStringHelperEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, string value);
    private void WriteStringEscapeValueOnly(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndex);
    private void WriteStringEscapeValueOnly(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<char> value, int firstEscapeIndex);
    private void WriteStringEscapePropertyOnly(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> escapedValue, int firstEscapeIndex);
    private void WriteStringEscapePropertyOnly(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> escapedValue, int firstEscapeIndex);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringEscape(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringEscapePropertyOrValue(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value, int firstEscapeIndexProp, int firstEscapeIndexVal);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringByOptions(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedPropertyName, ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedPropertyName, ReadOnlySpan`1<char> escapedValue);
    [CLSCompliantAttribute("False")]
public void WriteNumber(JsonEncodedText propertyName, ulong value);
    private void WriteNumberHelper(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(string propertyName, ulong value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<char> propertyName, ulong value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(JsonEncodedText propertyName, UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(string propertyName, UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<char> propertyName, UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, UInt32 value);
    private void WriteNumberEscape(ReadOnlySpan`1<char> propertyName, ulong value);
    private void WriteNumberEscape(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<char> propertyName, ulong value, int firstEscapeIndexProp);
    private void WriteNumberEscapeProperty(ReadOnlySpan`1<byte> utf8PropertyName, ulong value, int firstEscapeIndexProp);
    private void WriteNumberByOptions(ReadOnlySpan`1<char> propertyName, ulong value);
    private void WriteNumberByOptions(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    private void WriteNumberMinimized(ReadOnlySpan`1<char> escapedPropertyName, ulong value);
    private void WriteNumberMinimized(ReadOnlySpan`1<byte> escapedPropertyName, ulong value);
    private void WriteNumberIndented(ReadOnlySpan`1<char> escapedPropertyName, ulong value);
    private void WriteNumberIndented(ReadOnlySpan`1<byte> escapedPropertyName, ulong value);
    public void WriteBase64StringValue(ReadOnlySpan`1<byte> bytes);
    private void WriteBase64ByOptions(ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Minimized(ReadOnlySpan`1<byte> bytes);
    private void WriteBase64Indented(ReadOnlySpan`1<byte> bytes);
    private static ReadOnlySpan`1<byte> get_SingleLineCommentDelimiterUtf8();
    public void WriteCommentValue(string value);
    public void WriteCommentValue(ReadOnlySpan`1<char> value);
    private void WriteCommentByOptions(ReadOnlySpan`1<char> value);
    private void WriteCommentMinimized(ReadOnlySpan`1<char> value);
    private void WriteCommentIndented(ReadOnlySpan`1<char> value);
    public void WriteCommentValue(ReadOnlySpan`1<byte> utf8Value);
    private void WriteCommentByOptions(ReadOnlySpan`1<byte> utf8Value);
    private void WriteCommentMinimized(ReadOnlySpan`1<byte> utf8Value);
    private void WriteCommentIndented(ReadOnlySpan`1<byte> utf8Value);
    public void WriteStringValue(DateTime value);
    private void WriteStringValueMinimized(DateTime value);
    private void WriteStringValueIndented(DateTime value);
    public void WriteStringValue(DateTimeOffset value);
    private void WriteStringValueMinimized(DateTimeOffset value);
    private void WriteStringValueIndented(DateTimeOffset value);
    public void WriteNumberValue(decimal value);
    private void WriteNumberValueMinimized(decimal value);
    private void WriteNumberValueIndented(decimal value);
    public void WriteNumberValue(double value);
    private void WriteNumberValueMinimized(double value);
    private void WriteNumberValueIndented(double value);
    private static bool TryFormatDouble(double value, Span`1<byte> destination, Int32& bytesWritten);
    public void WriteNumberValue(float value);
    private void WriteNumberValueMinimized(float value);
    private void WriteNumberValueIndented(float value);
    private static bool TryFormatSingle(float value, Span`1<byte> destination, Int32& bytesWritten);
    internal void WriteNumberValue(ReadOnlySpan`1<byte> utf8FormattedNumber);
    private void WriteNumberValueMinimized(ReadOnlySpan`1<byte> utf8Value);
    private void WriteNumberValueIndented(ReadOnlySpan`1<byte> utf8Value);
    public void WriteStringValue(Guid value);
    private void WriteStringValueMinimized(Guid value);
    private void WriteStringValueIndented(Guid value);
    private void ValidateWritingValue();
    private void Base64EncodeAndWrite(ReadOnlySpan`1<byte> bytes, Span`1<byte> output, int encodingLength);
    public void WriteNullValue();
    public void WriteBooleanValue(bool value);
    private void WriteLiteralByOptions(ReadOnlySpan`1<byte> utf8Value);
    private void WriteLiteralMinimized(ReadOnlySpan`1<byte> utf8Value);
    private void WriteLiteralIndented(ReadOnlySpan`1<byte> utf8Value);
    public void WriteNumberValue(int value);
    public void WriteNumberValue(long value);
    private void WriteNumberValueMinimized(long value);
    private void WriteNumberValueIndented(long value);
    public void WriteStringValue(JsonEncodedText value);
    private void WriteStringValueHelper(ReadOnlySpan`1<byte> utf8Value);
    public void WriteStringValue(string value);
    public void WriteStringValue(ReadOnlySpan`1<char> value);
    private void WriteStringEscape(ReadOnlySpan`1<char> value);
    private void WriteStringByOptions(ReadOnlySpan`1<char> value);
    private void WriteStringMinimized(ReadOnlySpan`1<char> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<char> escapedValue);
    private void WriteStringEscapeValue(ReadOnlySpan`1<char> value, int firstEscapeIndexVal);
    public void WriteStringValue(ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringEscape(ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringByOptions(ReadOnlySpan`1<byte> utf8Value);
    private void WriteStringMinimized(ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringIndented(ReadOnlySpan`1<byte> escapedValue);
    private void WriteStringEscapeValue(ReadOnlySpan`1<byte> utf8Value, int firstEscapeIndexVal);
    [CLSCompliantAttribute("False")]
public void WriteNumberValue(UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumberValue(ulong value);
    private void WriteNumberValueMinimized(ulong value);
    private void WriteNumberValueIndented(ulong value);
}
[DebuggerDisplayAttribute("Path:{PropertyPath()} Current: ClassType.{Current.JsonClassInfo.ClassType}, {Current.JsonClassInfo.Type.Name}")]
internal class System.Text.Json.WriteStack : ValueType {
    public WriteStackFrame Current;
    private List`1<WriteStackFrame> _previous;
    private int _index;
    public void Push();
    public void Push(JsonClassInfo nextClassInfo, object nextValue);
    public void Pop();
    public string PropertyPath();
    private void AppendStackFrame(StringBuilder sb, WriteStackFrame& frame);
    private void AppendPropertyName(StringBuilder sb, string propertyName);
}
internal class System.Text.Json.WriteStackFrame : ValueType {
    public object CurrentValue;
    public JsonClassInfo JsonClassInfo;
    public string KeyName;
    public IEnumerator CollectionEnumerator;
    public bool PopStackOnEndCollection;
    public bool IsIDictionaryConstructible;
    public bool IsIDictionaryConstructibleProperty;
    public bool PopStackOnEndObject;
    public bool StartObjectWritten;
    public bool MoveToNextProperty;
    public int PropertyEnumeratorIndex;
    public ExtensionDataWriteStatus ExtensionDataStatus;
    public JsonPropertyInfo JsonPropertyInfo;
    public void Initialize(Type type, JsonSerializerOptions options);
    public void WriteObjectOrArrayStart(ClassType classType, Utf8JsonWriter writer, JsonSerializerOptions options, bool writeNull);
    private void WriteObjectOrArrayStart(ClassType classType, JsonEncodedText propertyName, Utf8JsonWriter writer, bool writeNull);
    public void Reset();
    public void EndProperty();
    public void EndDictionary();
    public void EndArray();
    public void NextProperty();
}
