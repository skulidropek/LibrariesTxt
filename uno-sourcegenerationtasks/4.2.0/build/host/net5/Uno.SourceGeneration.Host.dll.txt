[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
internal abstract class Uno.SourceGeneration.Engine.Workspace.CommandLineArgumentReader : object {
    protected ProjectInstance Project;
    private Builder<string> _builder;
    private static ImmutableDictionary`2<string, string> s_debugTypeValues;
    protected CommandLineArgumentReader(ProjectInstance project);
    private static CommandLineArgumentReader();
    protected abstract virtual void ReadCore();
    private static void ValidateName(string name);
    protected void Add(string name);
    protected void Add(string name, string value, bool addQuoteIfValueContainsWhitespace);
    protected void Add(string name, int value);
    protected void AddIfNotNullOrWhiteSpace(string name, string value, bool addQuoteIfValueContainsWhitespace);
    protected void AddIfTrue(string name, bool condition);
    protected void AddIfTrue(string name, string value, bool condition);
    protected void AddIfFalse(string name, bool condition);
    protected void AddWithPlus(string name);
    protected void AddWithMinus(string name);
    protected void AddWithPlusOrMinus(string name, bool condition);
    protected string GetDocumentFilePath(ITaskItem documentItem);
    protected string GetAbsolutePath(string path);
    protected void ReadAdditionalFiles();
    protected void ReadAnalyzers();
    protected void ReadCodePage();
    protected void ReadDebugInfo();
    protected void ReadDelaySign();
    protected void ReadErrorReport();
    protected void ReadFeatures();
    protected void ReadImports();
    protected void ReadPlatform();
    protected void ReadReferences();
    protected void ReadSigning();
    protected ImmutableArray`1<string> Read();
    [CompilerGeneratedAttribute]
internal static string <ReadImports>g__ReadImportItem|25_0(ITaskItem item);
}
internal static class Uno.SourceGeneration.Engine.Workspace.CompilerOptionParseUtilities : object {
    public static IList`1<string> ParseFeatureFromMSBuild(string features);
    public static void ParseFeatures(IDictionary`2<string, string> builder, List`1<string> values);
    private static void ParseFeatureCore(IDictionary`2<string, string> builder, string feature);
}
internal static class Uno.SourceGeneration.Engine.Workspace.Constants.ItemNames : object {
    public static string AdditionalFiles;
    public static string Analyzer;
    public static string Compile;
    public static string CscCommandLineArgs;
    public static string DocFileItem;
    public static string EditorConfigFiles;
    public static string Import;
    public static string ProjectReference;
    public static string Reference;
    public static string ReferencePath;
    public static string VbcCommandLineArgs;
}
internal static class Uno.SourceGeneration.Engine.Workspace.Constants.MetadataNames : object {
    public static string Aliases;
    public static string HintPath;
    public static string Link;
    public static string Name;
    public static string ReferenceOutputAssembly;
}
internal static class Uno.SourceGeneration.Engine.Workspace.Constants.PropertyNames : object {
    public static string AllowUnsafeBlocks;
    public static string AppConfigForCompiler;
    public static string BaseAddress;
    public static string BuildProjectReferences;
    public static string BuildingInsideVisualStudio;
    public static string BuildingProject;
    public static string CheckForOverflowUnderflow;
    public static string CodePage;
    public static string ContinueOnError;
    public static string DebugSymbols;
    public static string DebugType;
    public static string DefineConstants;
    public static string DelaySign;
    public static string DesignTimeBuild;
    public static string DocFileItem;
    public static string ErrorReport;
    public static string Features;
    public static string FileAlignment;
    public static string FinalDefineConstants;
    public static string FrameworkPathOverride;
    public static string GenerateDocumentation;
    public static string GenerateFullPaths;
    public static string HighEntropyVA;
    public static string IntermediateAssembly;
    public static string KeyContainerName;
    public static string KeyOriginatorFile;
    public static string LangVersion;
    public static string ModuleAssemblyName;
    public static string NoCompilerStandardLib;
    public static string NoWarn;
    public static string _NoWarnings;
    public static string Optimize;
    public static string OptionCompare;
    public static string OptionExplicit;
    public static string OptionInfer;
    public static string OptionStrict;
    public static string OptionStrictType;
    public static string OutputType;
    public static string PdbFile;
    public static string PlatformTarget;
    public static string Prefer32Bit;
    public static string ProvideCommandLineArgs;
    public static string RemoveIntegerChecks;
    public static string ResolvedCodeAnalysisRuleSet;
    public static string RootNamespace;
    public static string SignAssembly;
    public static string SkipCompilerExecution;
    public static string StartupObject;
    public static string SubsystemVersion;
    public static string TargetCompactFramework;
    public static string TargetFramework;
    public static string TargetFrameworks;
    public static string TargetPath;
    public static string TargetRefPath;
    public static string TreatWarningsAsErrors;
    public static string VbRuntime;
    public static string WarningLevel;
    public static string WarningsAsErrors;
    public static string WarningsNotAsErrors;
}
internal static class Uno.SourceGeneration.Engine.Workspace.Conversions : object {
    public static bool ToBool(string value);
    public static int ToInt(string value);
    public static ulong ToULong(string value);
    public static Nullable`1<TEnum> ToEnum(string value, bool ignoreCase);
}
internal class Uno.SourceGeneration.Engine.Workspace.CSharpCommandLineArgumentReader : CommandLineArgumentReader {
    private CSharpCommandLineArgumentReader(ProjectInstance project);
    public static ImmutableArray`1<string> Read(ProjectInstance project);
    protected virtual void ReadCore();
}
internal class Uno.SourceGeneration.Engine.Workspace.DocumentFileInfo : object {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogicalPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLinked>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGenerated>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceCodeKind <SourceCodeKind>k__BackingField;
    public string FilePath { get; }
    public string LogicalPath { get; }
    public bool IsLinked { get; }
    public bool IsGenerated { get; }
    public SourceCodeKind SourceCodeKind { get; }
    public DocumentFileInfo(string filePath, string logicalPath, bool isLinked, bool isGenerated, SourceCodeKind sourceCodeKind);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public string get_LogicalPath();
    [CompilerGeneratedAttribute]
public bool get_IsLinked();
    [CompilerGeneratedAttribute]
public bool get_IsGenerated();
    [CompilerGeneratedAttribute]
public SourceCodeKind get_SourceCodeKind();
}
[ExtensionAttribute]
internal static class Uno.SourceGeneration.Engine.Workspace.Extensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<ITaskItem> GetAdditionalFiles(ProjectInstance executedProject);
    [ExtensionAttribute]
public static IEnumerable`1<ITaskItem> GetAnalyzers(ProjectInstance executedProject);
    [ExtensionAttribute]
public static IEnumerable`1<ITaskItem> GetDocuments(ProjectInstance executedProject);
    [ExtensionAttribute]
public static IEnumerable`1<ITaskItem> GetEditorConfigFiles(ProjectInstance executedProject);
    [ExtensionAttribute]
public static IEnumerable`1<ITaskItem> GetMetadataReferences(ProjectInstance executedProject);
    [ExtensionAttribute]
public static IEnumerable`1<ProjectFileReference> GetProjectReferences(ProjectInstance executedProject);
    private static ProjectFileReference CreateProjectFileReference(ProjectItemInstance reference);
    [ExtensionAttribute]
public static bool HasReferenceOutputAssemblyMetadataEqualToTrue(ITaskItem item);
    [ExtensionAttribute]
public static ImmutableArray`1<string> GetAliases(ITaskItem item);
    [ExtensionAttribute]
public static bool ReferenceOutputAssemblyIsTrue(ITaskItem item);
    [ExtensionAttribute]
public static string ReadPropertyString(ProjectInstance executedProject, string propertyName);
    [ExtensionAttribute]
public static bool ReadPropertyBool(ProjectInstance executedProject, string propertyName);
    [ExtensionAttribute]
public static int ReadPropertyInt(ProjectInstance executedProject, string propertyName);
    [ExtensionAttribute]
public static ulong ReadPropertyULong(ProjectInstance executedProject, string propertyName);
    [ExtensionAttribute]
public static Nullable`1<TEnum> ReadPropertyEnum(ProjectInstance executedProject, string propertyName, bool ignoreCase);
    [ExtensionAttribute]
public static string ReadItemsAsString(ProjectInstance executedProject, string itemType);
    [ExtensionAttribute]
public static IEnumerable`1<ITaskItem> GetTaskItems(ProjectInstance executedProject, string itemType);
}
internal interface Uno.SourceGeneration.Engine.Workspace.IMetadataService {
    public abstract virtual PortableExecutableReference GetReference(string resolvedPath, MetadataReferenceProperties properties);
}
internal class Uno.SourceGeneration.Engine.Workspace.MetadataReferenceCache : object {
    private ImmutableDictionary`2<string, ReferenceSet> _referenceSets;
    private Func`3<string, MetadataReferenceProperties, MetadataReference> _createReference;
    [CompilerGeneratedAttribute]
private static MetadataReferenceCache <Default>k__BackingField;
    public static MetadataReferenceCache Default { get; }
    public MetadataReferenceCache(Func`3<string, MetadataReferenceProperties, MetadataReference> createReference);
    private static MetadataReferenceCache();
    [CompilerGeneratedAttribute]
public static MetadataReferenceCache get_Default();
    private static MetadataReference DefaultCreateReference(string path, MetadataReferenceProperties properties);
    public MetadataReference GetReference(string path, MetadataReferenceProperties properties);
}
internal class Uno.SourceGeneration.Engine.Workspace.ProjectFileInfo : object {
    [CompilerGeneratedAttribute]
private bool <IsEmpty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputRefFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <CommandLineArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DocumentFileInfo> <Documents>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DocumentFileInfo> <AdditionalDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<DocumentFileInfo> <AnalyzerConfigDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ProjectFileReference> <ProjectReferences>k__BackingField;
    public bool IsEmpty { get; }
    public string Language { get; }
    public string FilePath { get; }
    public string OutputFilePath { get; }
    public string OutputRefFilePath { get; }
    public string TargetFramework { get; }
    public ImmutableArray`1<string> CommandLineArgs { get; }
    public ImmutableArray`1<DocumentFileInfo> Documents { get; }
    public ImmutableArray`1<DocumentFileInfo> AdditionalDocuments { get; }
    public ImmutableArray`1<DocumentFileInfo> AnalyzerConfigDocuments { get; }
    public ImmutableArray`1<ProjectFileReference> ProjectReferences { get; }
    private ProjectFileInfo(bool isEmpty, string language, string filePath, string outputFilePath, string outputRefFilePath, string targetFramework, ImmutableArray`1<string> commandLineArgs, ImmutableArray`1<DocumentFileInfo> documents, ImmutableArray`1<DocumentFileInfo> additionalDocuments, ImmutableArray`1<DocumentFileInfo> analyzerConfigDocuments, ImmutableArray`1<ProjectFileReference> projectReferences);
    [CompilerGeneratedAttribute]
public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public string get_OutputFilePath();
    [CompilerGeneratedAttribute]
public string get_OutputRefFilePath();
    [CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_CommandLineArgs();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DocumentFileInfo> get_Documents();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DocumentFileInfo> get_AdditionalDocuments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DocumentFileInfo> get_AnalyzerConfigDocuments();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ProjectFileReference> get_ProjectReferences();
    public virtual string ToString();
    public static ProjectFileInfo Create(string language, string filePath, string outputFilePath, string outputRefFilePath, string targetFramework, ImmutableArray`1<string> commandLineArgs, ImmutableArray`1<DocumentFileInfo> documents, ImmutableArray`1<DocumentFileInfo> additionalDocuments, ImmutableArray`1<DocumentFileInfo> analyzerConfigDocuments, ImmutableArray`1<ProjectFileReference> projectReferences);
    public static ProjectFileInfo CreateEmpty(string language, string filePath);
    public static ProjectFileInfo FromMSBuildProjectInstance(string language, Project loadedProject, ProjectInstance project);
}
internal class Uno.SourceGeneration.Engine.Workspace.ProjectFileReference : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Aliases>k__BackingField;
    public string Path { get; }
    public ImmutableArray`1<string> Aliases { get; }
    public ProjectFileReference(string path, ImmutableArray`1<string> aliases);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Aliases();
}
internal class Uno.SourceGeneration.Engine.Workspace.ProjectInfoBuilder : object {
    private static MetadataService _metadataService;
    private static Char[] s_directorySplitChars;
    private static ProjectInfoBuilder();
    public static ProjectInfo CreateProjectInfo(ProjectFileInfo projectFileInfo);
    private static ResolvedReferences ResolveReferencesAsync(ProjectId id, ProjectFileInfo projectFileInfo, CommandLineArguments commandLineArgs);
    private static ImmutableArray`1<DocumentInfo> CreateDocumentInfos(IReadOnlyList`1<DocumentFileInfo> documentFileInfos, ProjectId projectId, Encoding encoding);
    private static void GetDocumentNameAndFolders(string logicalPath, String& name, ImmutableArray`1& folders);
    private static string GetAssemblyNameFromProjectPath(string projectFilePath);
}
internal class Uno.SourceGeneration.Engine.Workspace.RelativePathResolver : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <SearchPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseDirectory>k__BackingField;
    public ImmutableArray`1<string> SearchPaths { get; }
    public string BaseDirectory { get; }
    public RelativePathResolver(ImmutableArray`1<string> searchPaths, string baseDirectory);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_SearchPaths();
    [CompilerGeneratedAttribute]
public string get_BaseDirectory();
    public string ResolvePath(string reference, string baseFilePath);
    protected virtual bool FileExists(string fullPath);
    public RelativePathResolver WithSearchPaths(ImmutableArray`1<string> searchPaths);
    public RelativePathResolver WithBaseDirectory(string baseDirectory);
    public sealed virtual bool Equals(RelativePathResolver other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
[ExtensionAttribute]
internal static class Uno.SourceGeneration.Engine.Workspace.Utilities.IDictionaryExtensions : object {
    [ExtensionAttribute]
public static V GetOrAdd(IDictionary`2<K, V> dictionary, K key, Func`2<K, V> function);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static void MultiAdd(IDictionary`2<TKey, TCollection> dictionary, TKey key, TValue value);
}
internal class Uno.SourceGeneration.Engine.Workspace.WorkspaceMetadataFileReferenceResolver : MetadataReferenceResolver {
    private IMetadataService _metadataService;
    internal RelativePathResolver PathResolver;
    public WorkspaceMetadataFileReferenceResolver(IMetadataService metadataService, RelativePathResolver pathResolver);
    public virtual ImmutableArray`1<PortableExecutableReference> ResolveReference(string reference, string baseFilePath, MetadataReferenceProperties properties);
    public sealed virtual bool Equals(WorkspaceMetadataFileReferenceResolver other);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
}
public class Uno.SourceGeneration.Helpers.BinaryLoggerEventSource : object {
    [CompilerGeneratedAttribute]
private BuildMessageEventHandler MessageRaised;
    [CompilerGeneratedAttribute]
private BuildErrorEventHandler ErrorRaised;
    [CompilerGeneratedAttribute]
private BuildWarningEventHandler WarningRaised;
    [CompilerGeneratedAttribute]
private BuildStartedEventHandler BuildStarted;
    [CompilerGeneratedAttribute]
private BuildFinishedEventHandler BuildFinished;
    [CompilerGeneratedAttribute]
private ProjectStartedEventHandler ProjectStarted;
    [CompilerGeneratedAttribute]
private ProjectFinishedEventHandler ProjectFinished;
    [CompilerGeneratedAttribute]
private TargetStartedEventHandler TargetStarted;
    [CompilerGeneratedAttribute]
private TargetFinishedEventHandler TargetFinished;
    [CompilerGeneratedAttribute]
private TaskStartedEventHandler TaskStarted;
    [CompilerGeneratedAttribute]
private TaskFinishedEventHandler TaskFinished;
    [CompilerGeneratedAttribute]
private CustomBuildEventHandler CustomEventRaised;
    [CompilerGeneratedAttribute]
private BuildStatusEventHandler StatusEventRaised;
    [CompilerGeneratedAttribute]
private AnyEventHandler AnyEventRaised;
    [CompilerGeneratedAttribute]
public sealed virtual void add_MessageRaised(BuildMessageEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MessageRaised(BuildMessageEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ErrorRaised(BuildErrorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ErrorRaised(BuildErrorEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_WarningRaised(BuildWarningEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_WarningRaised(BuildWarningEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BuildStarted(BuildStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BuildStarted(BuildStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_BuildFinished(BuildFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_BuildFinished(BuildFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProjectStarted(ProjectStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ProjectFinished(ProjectFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TargetStarted(TargetStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TargetStarted(TargetStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TargetFinished(TargetFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TargetFinished(TargetFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TaskStarted(TaskStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TaskStarted(TaskStartedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_TaskFinished(TaskFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_TaskFinished(TaskFinishedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CustomEventRaised(CustomBuildEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CustomEventRaised(CustomBuildEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_StatusEventRaised(BuildStatusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_StatusEventRaised(BuildStatusEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_AnyEventRaised(AnyEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_AnyEventRaised(AnyEventHandler value);
    public void RaiseMessage(string senderName, string message, MessageImportance importance);
    public void RaiseWarning(string senderName, string message);
    public void RaiseError(string senderName, string message);
    public void RaiseBuildStart();
    public void RaiseBuildFinished();
}
internal class Uno.SourceGeneration.Helpers.BinaryLoggerForwarder : object {
    private BinaryLoggerEventSource _eventSource;
    private string _categoryName;
    public BinaryLoggerForwarder(string categoryName, BinaryLoggerEventSource eventSource);
    public sealed virtual IDisposable BeginScope(TState state);
    public sealed virtual bool IsEnabled(LogLevel logLevel);
    public sealed virtual void Log(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func`3<TState, Exception, string> formatter);
    public void Dispose();
}
internal class Uno.SourceGeneration.Helpers.BinaryLoggerForwarderProvider : object {
    private BinaryLoggerEventSource _source;
    private BinaryLogger _msbuildLogger;
    public BinaryLoggerForwarderProvider(string outputFilePath);
    public sealed virtual ILogger CreateLogger(string categoryName);
    public sealed virtual void Dispose();
}
internal class Uno.SourceGeneration.Helpers.BinaryLoggerReplayHelper : object {
    public static void Replay(IBuildEngine engine, string filePath, TaskLoggingHelper log);
}
public class Uno.SourceGeneration.Helpers.RuntimeHelpers : object {
    public static bool IsNetCore { get; }
    public static bool IsMono { get; }
    public static bool get_IsNetCore();
    public static bool get_IsMono();
}
public class Uno.SourceGeneration.Host.AssemblyResolver : object {
    private static bool _additionalAssembliesPreloaded;
    public static IDisposable RegisterAssemblyLoader(BuildEnvironment environment);
    private static void TryLoadAdditionalAssemblies(BuildEnvironment environment);
}
internal class Uno.SourceGeneration.Host.CachingMetadataReferenceResolver : MetadataReferenceResolver {
    private Func`3<string, MetadataReferenceProperties, PortableExecutableReference> _assemblyReferenceProvider;
    public bool ResolveMissingAssemblies { get; }
    public CachingMetadataReferenceResolver(Func`3<string, MetadataReferenceProperties, PortableExecutableReference> assemblyReferenceProvider);
    public virtual bool get_ResolveMissingAssemblies();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual ImmutableArray`1<PortableExecutableReference> ResolveReference(string reference, string baseFilePath, MetadataReferenceProperties properties);
}
internal class Uno.SourceGeneration.Host.GenerationClient.GenerationServerConnection : object {
    private static ILogger _log;
    internal static string ServerNameDesktop;
    internal static string ServerNameCoreClr;
    internal static int TimeOutMsExistingProcess;
    internal static int TimeOutMsNewProcess;
    private static GenerationServerConnection();
    internal static bool IsCompilerServerSupported(string tempPath);
    public static Task`1<GenerationResponse> RunServerGeneration(string sharedCompilationId, List`1<string> arguments, GenerationsPathsInfo buildPaths, string keepAlive, CancellationToken cancellationToken);
    internal bool TryShutdownGenerationServer(string pipeName, GenerationsPathsInfo buildPaths);
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.GenerationClient.GenerationServerConnection/<RunServerGenerationCore>d__8")]
internal static Task`1<GenerationResponse> RunServerGenerationCore(List`1<string> arguments, GenerationsPathsInfo buildPaths, string pipeName, string keepAlive, Nullable`1<int> timeoutOverride, Func`4<string, string, bool, bool> tryCreateServerFunc, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.GenerationClient.GenerationServerConnection/<TryGeneration>d__9")]
private static Task`1<GenerationResponse> TryGeneration(NamedPipeClientStream pipeStream, GenerationRequest request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.GenerationClient.GenerationServerConnection/<CreateMonitorDisconnectTask>d__10")]
internal static Task CreateMonitorDisconnectTask(PipeStream pipeStream, string identifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.GenerationClient.GenerationServerConnection/<TryConnectToServerAsync>d__11")]
internal static Task`1<NamedPipeClientStream> TryConnectToServerAsync(string pipeName, int timeoutMs, CancellationToken cancellationToken);
    internal static bool TryCreateServerCore(string clientDir, string pipeName, bool isShutdown);
    private static bool CheckPipeConnectionOwnership(NamedPipeClientStream pipeStream);
    private static UInt32 GetEUid();
    private static int GetPeerID(SafeHandle socket, UInt32& euid);
    internal static bool CheckIdentityUnix(PipeStream stream);
    private static ObjectSecurity GetPipeSecurity(PipeStream pipeStream);
    internal static string GetPipeNameForPathOpt(string serverExeDirectory);
    internal static bool IsPipePathTooLong(string pipeName, string tempPath);
    internal static string GetBasePipeName(string compilerExeDirectory);
    internal static bool WasServerMutexOpen(string mutexName);
    internal static string GetServerMutexName(string pipeName);
    internal static string GetClientMutexName(string pipeName);
    public static string GetTempPath(string workingDir);
}
internal class Uno.SourceGeneration.Host.GenerationClient.GenerationsPathsInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <ClientDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TempDirectory>k__BackingField;
    internal string ClientDirectory { get; }
    internal string WorkingDirectory { get; }
    internal string TempDirectory { get; }
    internal GenerationsPathsInfo(string clientDir, string workingDir, string tempDir);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal string get_ClientDirectory();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal string get_WorkingDirectory();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal string get_TempDirectory();
}
public class Uno.SourceGeneration.Host.GeneratorLogger : object {
    private ILogger _logger;
    public GeneratorLogger(ILogger logger);
    public sealed virtual void Debug(IFormattable message, Exception exception);
    public sealed virtual void Debug(string message, Exception exception);
    public sealed virtual void Info(IFormattable message, Exception exception);
    public sealed virtual void Info(string message, Exception exception);
    public sealed virtual void Warn(IFormattable message, Exception exception);
    public sealed virtual void Warn(string message, Exception exception);
    public sealed virtual void Error(IFormattable message, Exception exception);
    public sealed virtual void Error(string message, Exception exception);
}
[AttributeUsageAttribute("1")]
internal class Uno.SourceGeneration.Host.Helpers.CommitHashAttribute : Attribute {
    internal string Hash;
    public CommitHashAttribute(string hash);
}
[DefaultMemberAttribute("Item")]
internal class Uno.SourceGeneration.Host.Helpers.ConcurrentLruCache`2 : object {
    private int _capacity;
    private Dictionary`2<K, CacheValue<K, V>> _cache;
    private LinkedList`1<K> _nodeList;
    private object _lockObject;
    internal IEnumerable`1<KeyValuePair`2<K, V>> TestingEnumerable { get; }
    public V Item { get; public set; }
    public ConcurrentLruCache`2(int capacity);
    public ConcurrentLruCache`2(KeyValuePair`2[] array);
    internal IEnumerable`1<KeyValuePair`2<K, V>> get_TestingEnumerable();
    public void Add(K key, V value);
    private void MoveNodeToTop(LinkedListNode`1<K> node);
    private void UnsafeEvictLastNode();
    private void UnsafeAddNodeToTop(K key, V value);
    private void UnsafeAdd(K key, V value, bool throwExceptionIfKeyExists);
    public V get_Item(K key);
    public void set_Item(K key, V value);
    public bool TryGetValue(K key, V& value);
    public bool UnsafeTryGetValue(K key, V& value);
    public V GetOrAdd(K key, V value);
    public V GetOrAdd(K key, Func`1<V> creator);
    public V GetOrAdd(K key, T arg, Func`2<T, V> creator);
}
internal static class Uno.SourceGeneration.Host.Helpers.CoreClrShim : object {
    internal static bool IsRunningOnCoreClr { get; }
    internal static bool get_IsRunningOnCoreClr();
}
internal class Uno.SourceGeneration.Host.Helpers.FileKey : ValueType {
    public string FullPath;
    public DateTime Timestamp;
    public FileKey(string fullPath, DateTime timestamp);
    public static FileKey Create(string fullPath);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public sealed virtual bool Equals(FileKey other);
}
internal static class Uno.SourceGeneration.Host.Helpers.FileNameUtilities : object {
    private static string DirectorySeparatorStr;
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static char VolumeSeparatorChar;
    internal static bool IsFileName(string path);
    private static int IndexOfExtension(string path);
    internal static string GetExtension(string path);
    private static string RemoveExtension(string path);
    internal static string ChangeExtension(string path, string extension);
    internal static int IndexOfFileName(string path);
    internal static string GetFileName(string path, bool includeExtension);
}
internal static class Uno.SourceGeneration.Host.Helpers.FileUtilities : object {
    private static Char[] s_invalidPathChars;
    private static FileUtilities();
    internal static string ResolveRelativePath(string path, string basePath, string baseDirectory, IEnumerable`1<string> searchPaths, Func`2<string, bool> fileExists);
    internal static string ResolveRelativePath(string path, string baseDirectory);
    internal static string ResolveRelativePath(string path, string basePath, string baseDirectory);
    private static string ResolveRelativePath(PathKind kind, string path, string basePath, string baseDirectory);
    private static string GetBaseDirectory(string basePath, string baseDirectory);
    internal static string NormalizeRelativePath(string path, string basePath, string baseDirectory);
    internal static string NormalizeAbsolutePath(string path);
    internal static string NormalizeDirectoryPath(string path);
    internal static string TryNormalizeAbsolutePath(string path);
    internal static Stream OpenRead(string fullPath);
    internal static Stream OpenAsyncRead(string fullPath);
    internal static T RethrowExceptionsAsIOException(Func`1<T> operation);
    internal static Stream CreateFileStreamChecked(Func`2<string, Stream> factory, string path, string paramName);
    internal static DateTime GetFileTimeStamp(string fullPath);
    internal static long GetFileLength(string fullPath);
    internal static Stream OpenFileStream(string path);
}
internal static class Uno.SourceGeneration.Host.Helpers.Hash : object {
    internal static int FnvOffsetBias;
    internal static int FnvPrime;
    internal static int Combine(int newKey, int currentKey);
    internal static int Combine(bool newKeyPart, int currentKey);
    internal static int Combine(T newKeyPart, int currentKey);
    internal static int CombineValues(IEnumerable`1<T> values, int maxItemsToHash);
    internal static int CombineValues(T[] values, int maxItemsToHash);
    internal static int CombineValues(ImmutableArray`1<T> values, int maxItemsToHash);
    internal static int CombineValues(IEnumerable`1<string> values, StringComparer stringComparer, int maxItemsToHash);
    internal static int GetFNVHashCode(Byte[] data);
    internal static int GetFNVHashCode(ReadOnlySpan`1<byte> data, Boolean& isAscii);
    internal static int GetFNVHashCode(ImmutableArray`1<byte> data);
    internal static int GetFNVHashCode(string text, int start, int length);
    internal static int GetCaseInsensitiveFNVHashCode(string text);
    internal static int GetCaseInsensitiveFNVHashCode(string text, int start, int length);
    internal static int GetFNVHashCode(string text, int start);
    internal static int GetFNVHashCode(string text);
    internal static int GetFNVHashCode(StringBuilder text);
    internal static int GetFNVHashCode(Char[] text, int start, int length);
    internal static int GetFNVHashCode(char ch);
    internal static int CombineFNVHash(int hashCode, string text);
    internal static int CombineFNVHash(int hashCode, char ch);
}
internal class Uno.SourceGeneration.Host.Helpers.MemoryHelper : object {
    public int Length;
    public int PercentPhysicalUsed;
    public ulong MaxPhysical;
    public ulong AvailablePhysical;
    public ulong MaxPageFile;
    public ulong AvailablePageFile;
    public ulong MaxVirtual;
    public ulong AvailableVirtual;
    public ulong Reserved;
    public static bool IsMemoryAvailable();
    private static bool GlobalMemoryStatusEx(MemoryHelper buffer);
}
internal static class Uno.SourceGeneration.Host.Helpers.NativeMethods : object {
    internal static IntPtr NullPtr;
    internal static IntPtr InvalidIntPtr;
    internal static UInt32 NORMAL_PRIORITY_CLASS;
    internal static UInt32 CREATE_NO_WINDOW;
    internal static int STARTF_USESTDHANDLES;
    internal static int ERROR_SUCCESS;
    private static NativeMethods();
    internal static bool CloseHandle(IntPtr hObject);
    internal static bool CreateProcess(string lpApplicationName, StringBuilder lpCommandLine, IntPtr lpProcessAttributes, IntPtr lpThreadAttributes, bool bInheritHandles, UInt32 dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, STARTUPINFO& lpStartupInfo, PROCESS_INFORMATION& lpProcessInformation);
    internal static IntPtr GetCommandLine();
}
internal enum Uno.SourceGeneration.Host.Helpers.PathKind : Enum {
    public int value__;
    public static PathKind Empty;
    public static PathKind Relative;
    public static PathKind RelativeToCurrentDirectory;
    public static PathKind RelativeToCurrentParent;
    public static PathKind RelativeToCurrentRoot;
    public static PathKind RelativeToDriveDirectory;
    public static PathKind Absolute;
}
internal static class Uno.SourceGeneration.Host.Helpers.PathUtilities : object {
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static string ParentRelativeDirectory;
    internal static string ThisDirectory;
    internal static string DirectorySeparatorStr;
    internal static char VolumeSeparatorChar;
    private static Char[] s_pathChars;
    public static IEqualityComparer`1<string> Comparer;
    internal static bool IsUnixLikePlatform { get; }
    private static PathUtilities();
    internal static bool get_IsUnixLikePlatform();
    public static bool IsDirectorySeparator(char c);
    public static bool IsAnyDirectorySeparator(char c);
    public static string TrimTrailingSeparators(string s);
    public static string EnsureTrailingSeparator(string s);
    public static string GetExtension(string path);
    public static string ChangeExtension(string path, string extension);
    public static string RemoveExtension(string path);
    public static string GetFileName(string path, bool includeExtension);
    public static string GetDirectoryName(string path);
    internal static string GetDirectoryName(string path, bool isUnixLike);
    internal static bool IsSameDirectoryOrChildOf(string child, string parent);
    public static string GetPathRoot(string path);
    private static string GetPathRoot(string path, bool isUnixLike);
    private static string GetWindowsRoot(string path);
    private static int ConsumeDirectorySeparators(string path, int length, int i);
    private static string GetUnixRoot(string path);
    public static PathKind GetPathKind(string path);
    public static bool IsAbsolute(string path);
    private static bool IsDriveRootedAbsolutePath(string path);
    public static string CombineAbsoluteAndRelativePaths(string root, string relativePath);
    public static string CombinePossiblyRelativeAndRelativePaths(string rootOpt, string relativePath);
    public static string CombinePathsUnchecked(string root, string relativePath);
    private static string RemoveTrailingDirectorySeparator(string path);
    public static bool IsFilePath(string assemblyDisplayNameOrPath);
    public static bool ContainsPathComponent(string path, string component, bool ignoreCase);
    public static string GetRelativePath(string directory, string fullPath);
    public static bool IsChildPath(string parentPath, string childPath);
    private static string GetRelativeChildPath(string parentPath, string childPath);
    private static String[] GetPathParts(string path);
    public static bool PathsEqual(string path1, string path2);
    private static bool PathsEqual(string path1, string path2, int length);
    private static bool PathCharEqual(char x, char y);
    private static int PathHashCode(string path);
    public static string NormalizePathPrefix(string filePath, ImmutableArray`1<KeyValuePair`2<string, string>> pathMap);
    public static bool IsValidFilePath(string fullPath);
}
internal static class Uno.SourceGeneration.Host.Helpers.PlatformInformation : object {
    public static bool IsWindows { get; }
    public static bool IsUnix { get; }
    public static bool IsRunningOnMono { get; }
    public static bool get_IsWindows();
    public static bool get_IsUnix();
    public static bool get_IsRunningOnMono();
}
internal class Uno.SourceGeneration.Host.Helpers.PROCESS_INFORMATION : ValueType {
    public IntPtr hProcess;
    public IntPtr hThread;
    public int dwProcessId;
    public int dwThreadId;
}
[ExtensionAttribute]
internal static class Uno.SourceGeneration.Host.Helpers.ReflectionUtilities : object {
    private static Type Missing;
    private static ReflectionUtilities();
    public static Type TryGetType(string assemblyQualifiedName);
    public static Type TryGetType(Type& lazyType, string assemblyQualifiedName);
    public static Type GetTypeFromEither(string contractName, string desktopName);
    public static Type GetTypeFromEither(Type& lazyType, string contractName, string desktopName);
    public static T FindItem(IEnumerable`1<T> collection, Type[] paramTypes);
    [ExtensionAttribute]
internal static MethodInfo GetDeclaredMethod(TypeInfo typeInfo, string name, Type[] paramTypes);
    [ExtensionAttribute]
internal static ConstructorInfo GetDeclaredConstructor(TypeInfo typeInfo, Type[] paramTypes);
    [ExtensionAttribute]
public static T CreateDelegate(MethodInfo methodInfo);
    [ExtensionAttribute]
public static T InvokeConstructor(ConstructorInfo constructorInfo, Object[] args);
    [ExtensionAttribute]
public static object InvokeConstructor(ConstructorInfo constructorInfo, Object[] args);
    [ExtensionAttribute]
public static T Invoke(MethodInfo methodInfo, object obj, Object[] args);
}
internal class Uno.SourceGeneration.Host.Helpers.STARTUPINFO : ValueType {
    internal int cb;
    internal string lpReserved;
    internal string lpDesktop;
    internal string lpTitle;
    internal int dwX;
    internal int dwY;
    internal int dwXSize;
    internal int dwYSize;
    internal int dwXCountChars;
    internal int dwYCountChars;
    internal int dwFillAttribute;
    internal int dwFlags;
    internal short wShowWindow;
    internal short cbReserved2;
    internal IntPtr lpReserved2;
    internal IntPtr hStdInput;
    internal IntPtr hStdOutput;
    internal IntPtr hStdError;
}
[ExtensionAttribute]
internal static class Uno.SourceGeneration.host.Helpers.TopologicalSorting : object {
    [ExtensionAttribute]
internal static IReadOnlyCollection`1<IReadOnlyCollection`1<T>> GroupSort(IReadOnlyCollection`1<T> nodes, IReadOnlyCollection`1<ValueTuple`2<T, T>> edges, IEqualityComparer`1<T> comparer);
}
internal class Uno.SourceGeneration.Host.InternalGeneratorExecutionContext : GeneratorExecutionContext {
    private ConcurrentBag`1<KeyValuePair`2<string, string>> _trees;
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    internal IEnumerable`1<KeyValuePair`2<string, string>> Trees { get; }
    internal Project Project { get; private set; }
    public ImmutableArray`1<AdditionalText> AdditionalFiles { get; }
    public InternalGeneratorExecutionContext(Compilation compilation, ParseOptions parseOptions, CancellationToken token, Project project);
    public virtual void AddSource(string hintName, string source);
    public virtual void AddSource(string hintName, SourceText sourceText);
    public virtual void ReportDiagnostic(Diagnostic diagnostic);
    public virtual bool TryGetOptionValue(SyntaxTree tree, string key, String& value);
    public virtual bool TryGetOptionValue(AdditionalText textFile, string key, String& value);
    public virtual bool TryGetGlobalOptionValue(string key, String& value);
    internal IEnumerable`1<KeyValuePair`2<string, string>> get_Trees();
    [CompilerGeneratedAttribute]
internal Project get_Project();
    [CompilerGeneratedAttribute]
private void set_Project(Project value);
    public virtual ImmutableArray`1<AdditionalText> get_AdditionalFiles();
}
internal class Uno.SourceGeneration.Host.InternalSourceGeneratorContext : SourceGeneratorContext {
    private ConcurrentBag`1<KeyValuePair`2<string, string>> _trees;
    [CompilerGeneratedAttribute]
private Compilation <Compilation>k__BackingField;
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    public IEnumerable`1<KeyValuePair`2<string, string>> Trees { get; }
    public Compilation Compilation { get; }
    public Project Project { get; }
    public InternalSourceGeneratorContext(Compilation compilation, Project project);
    public IEnumerable`1<KeyValuePair`2<string, string>> get_Trees();
    [CompilerGeneratedAttribute]
public virtual Compilation get_Compilation();
    [CompilerGeneratedAttribute]
public virtual Project get_Project();
    public virtual void AddCompilationUnit(string name, string tree);
    public virtual void AddCompilationUnit(string name, SyntaxTree tree);
    public virtual void ReportDiagnostic(Diagnostic diagnostic);
}
internal class Uno.SourceGeneration.Host.Messages.CompletedGenerationResponse : GenerationResponse {
    public int ReturnCode;
    public bool Utf8Output;
    public string Output;
    public string ErrorOutput;
    public ResponseType Type { get; }
    public CompletedGenerationResponse(int returnCode, bool utf8output, string output);
    public virtual ResponseType get_Type();
    public static CompletedGenerationResponse Create(BinaryReader reader);
    protected virtual void AddResponseBody(BinaryWriter writer);
}
internal static class Uno.SourceGeneration.Host.Messages.GenerationProtocolConstants : object {
    public static UInt32 ProtocolVersion;
    public static string ReadLengthPrefixedString(BinaryReader reader);
    public static void WriteLengthPrefixedString(BinaryWriter writer, string value);
    public static string GetCommitHash();
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.Messages.GenerationProtocolConstants/<ReadAllAsync>d__5")]
internal static Task ReadAllAsync(Stream stream, Byte[] buffer, int count, CancellationToken cancellationToken);
}
internal class Uno.SourceGeneration.Host.Messages.GenerationRequest : object {
    public UInt32 ProtocolVersion;
    public ReadOnlyCollection`1<Argument> Arguments;
    public string CompilerHash;
    public GenerationRequest(UInt32 protocolVersion, string compilerHash, IEnumerable`1<Argument> arguments);
    public static GenerationRequest Create(string workingDirectory, string tempDirectory, string compilerHash, IList`1<string> args, string keepAlive);
    public static GenerationRequest CreateShutdown();
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.Messages.GenerationRequest/<ReadAsync>d__6")]
public static Task`1<GenerationRequest> ReadAsync(Stream inStream, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.Messages.GenerationRequest/<WriteAsync>d__7")]
public Task WriteAsync(Stream outStream, CancellationToken cancellationToken);
}
internal abstract class Uno.SourceGeneration.Host.Messages.GenerationResponse : object {
    public ResponseType Type { get; }
    public abstract virtual ResponseType get_Type();
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.Messages.GenerationResponse/<WriteAsync>d__3")]
public Task WriteAsync(Stream outStream, CancellationToken cancellationToken);
    protected abstract virtual void AddResponseBody(BinaryWriter writer);
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.Messages.GenerationResponse/<ReadAsync>d__5")]
public static Task`1<GenerationResponse> ReadAsync(Stream stream, CancellationToken cancellationToken);
}
internal class Uno.SourceGeneration.Host.Messages.IncorrectHashGenerationResponse : GenerationResponse {
    public ResponseType Type { get; }
    public virtual ResponseType get_Type();
    protected virtual void AddResponseBody(BinaryWriter writer);
}
internal class Uno.SourceGeneration.Host.Messages.MismatchedVersionGenerationResponse : GenerationResponse {
    public ResponseType Type { get; }
    public virtual ResponseType get_Type();
    protected virtual void AddResponseBody(BinaryWriter writer);
}
internal class Uno.SourceGeneration.Host.Messages.RejectedGenerationResponse : GenerationResponse {
    public ResponseType Type { get; }
    public virtual ResponseType get_Type();
    protected virtual void AddResponseBody(BinaryWriter writer);
}
internal class Uno.SourceGeneration.Host.Messages.ShutdownGenerationResponse : GenerationResponse {
    public int ServerProcessId;
    public ResponseType Type { get; }
    public ShutdownGenerationResponse(int serverProcessId);
    public virtual ResponseType get_Type();
    protected virtual void AddResponseBody(BinaryWriter writer);
    public static ShutdownGenerationResponse Create(BinaryReader reader);
}
internal class Uno.SourceGeneration.Host.Program : object {
    private static int Main(String[] args);
    private static int RunGenerationServer(String[] args);
    private static int RunSingleUseGeneration(String[] args);
    private static int RunGeneration(string generatedFilesOutputPath, string binlogOutputPath, BuildEnvironment environment, bool enableConsole);
}
public class Uno.SourceGeneration.Host.ProjectDetails : object {
    private ValueTuple`2[] _timeStamps;
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectInstance <ExecutedProject>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueTuple`3[] <Generators>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IntermediatePath>k__BackingField;
    [CompilerGeneratedAttribute]
private Project <LoadedProject>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <References>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectCollection <Collection>k__BackingField;
    public string Configuration { get; internal set; }
    public ProjectInstance ExecutedProject { get; internal set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`3[] Generators { get; internal set; }
    public string IntermediatePath { get; internal set; }
    public Project LoadedProject { get; internal set; }
    public String[] References { get; internal set; }
    public ProjectCollection Collection { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Configuration();
    [CompilerGeneratedAttribute]
internal void set_Configuration(string value);
    [CompilerGeneratedAttribute]
public ProjectInstance get_ExecutedProject();
    [CompilerGeneratedAttribute]
internal void set_ExecutedProject(ProjectInstance value);
    [CompilerGeneratedAttribute]
public ValueTuple`3[] get_Generators();
    [CompilerGeneratedAttribute]
internal void set_Generators(ValueTuple`3[] value);
    [CompilerGeneratedAttribute]
public string get_IntermediatePath();
    [CompilerGeneratedAttribute]
internal void set_IntermediatePath(string value);
    [CompilerGeneratedAttribute]
public Project get_LoadedProject();
    [CompilerGeneratedAttribute]
internal void set_LoadedProject(Project value);
    [CompilerGeneratedAttribute]
public String[] get_References();
    [CompilerGeneratedAttribute]
internal void set_References(String[] value);
    [CompilerGeneratedAttribute]
public ProjectCollection get_Collection();
    [CompilerGeneratedAttribute]
internal void set_Collection(ProjectCollection value);
    public void BuildImportsMap();
    private string GetItemFullPath(ProjectItemInstance item);
    public sealed virtual void Dispose();
    public bool HasChanged();
}
public class Uno.SourceGeneration.Host.ProjectLoader : object {
    private static ILogger _log;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<ValueTuple`3<string, string, string>, ProjectDetails> _allProjects;
    private static ProjectLoader();
    public static ProjectDetails LoadProjectDetails(BuildEnvironment environment, Dictionary`2<string, string> globalProperties);
    private static void LogFailedTargets(string projectFile, BuildResult result);
    private static void ValidateOutputPath(ProjectInstance project);
    private static ValueTuple`3[] LoadAnalyzers(IEnumerable`1<string> enumerable);
    private static bool IsTypeRoslynGenerator(Type type);
    private static bool IsTypeUnoGenerators(Type type);
    private static bool ContainsGenerators(string assembly);
    private static string GetInterfaceTypeName(InterfaceImplementation i);
    private static BuildResult BuildAsync(BuildParameters parameters, BuildRequestData requestData);
}
internal class Uno.SourceGeneration.Host.Server.CachingMetadataReference : PortableExecutableReference {
    private static MetadataAndSymbolCache s_mdCache;
    private Metadata _metadata;
    public CachingMetadataReference(string fullPath, MetadataReferenceProperties properties);
    private static CachingMetadataReference();
    protected virtual DocumentationProvider CreateDocumentationProvider();
    protected virtual Metadata GetMetadataImpl();
    protected virtual PortableExecutableReference WithPropertiesImpl(MetadataReferenceProperties properties);
}
internal abstract class Uno.SourceGeneration.Host.Server.ClientConnection : object {
    private IGenerationServerHost _generationServerHost;
    private string _loggingIdentifier;
    private Stream _stream;
    public string LoggingIdentifier { get; }
    public ClientConnection(IGenerationServerHost compilerServerHost, string loggingIdentifier, Stream stream);
    public sealed virtual string get_LoggingIdentifier();
    protected abstract virtual Task CreateMonitorDisconnectTask(CancellationToken cancellationToken);
    protected virtual void ValidateGenerationRequest(GenerationRequest request);
    public abstract virtual void Close();
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.Server.ClientConnection/<HandleConnection>d__9")]
public sealed virtual Task`1<ConnectionData> HandleConnection(bool allowCompilationRequests, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.Server.ClientConnection/<HandleCompilationRequest>d__10")]
private Task`1<ConnectionData> HandleCompilationRequest(GenerationRequest request, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.Server.ClientConnection/<HandleMismatchedVersionRequest>d__11")]
private Task`1<ConnectionData> HandleMismatchedVersionRequest(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.Server.ClientConnection/<HandleIncorrectHashRequest>d__12")]
private Task`1<ConnectionData> HandleIncorrectHashRequest(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.Server.ClientConnection/<HandleRejectedRequest>d__13")]
private Task`1<ConnectionData> HandleRejectedRequest(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.Server.ClientConnection/<HandleShutdownRequest>d__14")]
private Task`1<ConnectionData> HandleShutdownRequest(CancellationToken cancellationToken);
    private Nullable`1<TimeSpan> CheckForNewKeepAlive(GenerationRequest request);
    private bool IsShutdownRequest(GenerationRequest request);
    protected virtual Task`1<GenerationResponse> ServeGenerationRequest(GenerationRequest generationRequest, CancellationToken cancellationToken);
    private void Log(string message);
    private void LogException(Exception e, string message);
}
internal class Uno.SourceGeneration.Host.Server.CommonGenerator : object {
    internal static int Failed;
    internal static int Succeeded;
}
internal enum Uno.SourceGeneration.Host.Server.CompletionReason : Enum {
    public int value__;
    public static CompletionReason CompilationNotStarted;
    public static CompletionReason CompilationCompleted;
    public static CompletionReason ClientDisconnect;
    public static CompletionReason ClientException;
    public static CompletionReason ClientShutdownRequest;
}
internal class Uno.SourceGeneration.Host.Server.ConnectionData : ValueType {
    public CompletionReason CompletionReason;
    public Nullable`1<TimeSpan> KeepAlive;
    public ConnectionData(CompletionReason completionReason, Nullable`1<TimeSpan> keepAlive);
}
internal class Uno.SourceGeneration.Host.Server.DesktopGenerationServerController : GenerationServerController {
    internal static string KeepAliveSettingName;
    private NameValueCollection _appSettings;
    internal DesktopGenerationServerController(NameValueCollection appSettings);
    protected virtual IClientConnectionHost CreateClientConnectionHost(string pipeName);
    internal static IGenerationServerHost CreateCompilerServerHost();
    internal static IClientConnectionHost CreateClientConnectionHostForServerHost(IGenerationServerHost compilerServerHost, string pipeName);
    protected internal virtual Nullable`1<TimeSpan> GetKeepAliveTimeout();
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.Server.DesktopGenerationServerController/<ConnectForShutdownAsync>d__7")]
protected virtual Task`1<Stream> ConnectForShutdownAsync(string pipeName, int timeout);
    protected virtual string GetDefaultPipeName();
    protected virtual Nullable`1<bool> WasServerRunning(string pipeName);
    protected virtual int RunServerCore(string pipeName, IClientConnectionHost connectionHost, IDiagnosticListener listener, Nullable`1<TimeSpan> keepAlive, CancellationToken cancellationToken);
    internal static int RunServer(string pipeName, string tempPath, IClientConnectionHost clientConnectionHost, IDiagnosticListener listener, Nullable`1<TimeSpan> keepAlive, CancellationToken cancellationToken);
}
internal class Uno.SourceGeneration.Host.Server.DesktopGenerationServerHost : GenerationServerHost {
    public static Func`3<string, MetadataReferenceProperties, PortableExecutableReference> SharedAssemblyReferenceProvider;
    public Func`3<string, MetadataReferenceProperties, PortableExecutableReference> AssemblyReferenceProvider { get; }
    internal DesktopGenerationServerHost(string clientDirectory);
    private static DesktopGenerationServerHost();
    public virtual Func`3<string, MetadataReferenceProperties, PortableExecutableReference> get_AssemblyReferenceProvider();
}
internal class Uno.SourceGeneration.Host.Server.EmptyDiagnosticListener : object {
    public sealed virtual void UpdateKeepAlive(TimeSpan timeSpan);
    public sealed virtual void ConnectionListening();
    public sealed virtual void ConnectionReceived();
    public sealed virtual void ConnectionCompleted(int count);
    public sealed virtual void ConnectionRudelyEnded();
    public sealed virtual void KeepAliveReached();
}
internal static class Uno.SourceGeneration.Host.Server.GenerationProtocolUtil : object {
    internal static RunRequest GetRunRequest(GenerationRequest req);
    internal static String[] GetCommandLineArguments(GenerationRequest req, String& currentDirectory, String& tempDirectory, String& libDirectory);
}
internal abstract class Uno.SourceGeneration.Host.Server.GenerationServerController : object {
    internal int Run(String[] args);
    protected internal abstract virtual Nullable`1<TimeSpan> GetKeepAliveTimeout();
    protected abstract virtual string GetDefaultPipeName();
    protected abstract virtual IClientConnectionHost CreateClientConnectionHost(string pipeName);
    protected abstract virtual Task`1<Stream> ConnectForShutdownAsync(string pipeName, int timeout);
    protected virtual Nullable`1<bool> WasServerRunning(string pipeName);
    protected virtual int RunServerCore(string pipeName, IClientConnectionHost connectionHost, IDiagnosticListener listener, Nullable`1<TimeSpan> keepAlive, CancellationToken cancellationToken);
    internal int RunServer(string pipeName, string tempPath, IClientConnectionHost clientConnectionHost, IDiagnosticListener listener, Nullable`1<TimeSpan> keepAlive, CancellationToken cancellationToken);
    internal int RunShutdown(string pipeName, bool waitForProcess, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.Server.GenerationServerController/<RunShutdownAsync>d__9")]
internal Task`1<int> RunShutdownAsync(string pipeName, bool waitForProcess, Nullable`1<TimeSpan> timeout, CancellationToken cancellationToken);
    internal static bool ParseCommandLine(String[] args, String& pipeName, Boolean& shutdown);
}
internal abstract class Uno.SourceGeneration.Host.Server.GenerationServerHost : object {
    [CompilerGeneratedAttribute]
private string <ClientDirectory>k__BackingField;
    public Func`3<string, MetadataReferenceProperties, PortableExecutableReference> AssemblyReferenceProvider { get; }
    public string ClientDirectory { get; }
    protected GenerationServerHost(string clientDirectory);
    public abstract virtual Func`3<string, MetadataReferenceProperties, PortableExecutableReference> get_AssemblyReferenceProvider();
    [CompilerGeneratedAttribute]
public string get_ClientDirectory();
    public sealed virtual GenerationResponse RunGeneration(RunRequest request, CancellationToken cancellationToken);
    private void Log(string message);
    private String[] Generate(BuildEnvironment environment);
}
internal interface Uno.SourceGeneration.Host.Server.IClientConnection {
    public string LoggingIdentifier { get; }
    public abstract virtual string get_LoggingIdentifier();
    public abstract virtual Task`1<ConnectionData> HandleConnection(bool allowCompilationRequests, CancellationToken cancellationToken);
    public abstract virtual void Close();
}
internal interface Uno.SourceGeneration.Host.Server.IClientConnectionHost {
    public abstract virtual Task`1<IClientConnection> CreateListenTask(CancellationToken cancellationToken);
}
internal interface Uno.SourceGeneration.Host.Server.IDiagnosticListener {
    public abstract virtual void UpdateKeepAlive(TimeSpan timeSpan);
    public abstract virtual void ConnectionListening();
    public abstract virtual void ConnectionReceived();
    public abstract virtual void ConnectionCompleted(int count);
    public abstract virtual void ConnectionRudelyEnded();
    public abstract virtual void KeepAliveReached();
}
internal interface Uno.SourceGeneration.Host.Server.IGenerationServerHost {
    public abstract virtual GenerationResponse RunGeneration(RunRequest request, CancellationToken cancellationToken);
}
internal class Uno.SourceGeneration.Host.Server.MetadataAndSymbolCache : object {
    private static int CacheSize;
    private ConcurrentLruCache`2<FileKey, Metadata> _metadataCache;
    private ModuleMetadata CreateModuleMetadata(string path, bool prefetchEntireImage);
    private ImmutableArray`1<ModuleMetadata> GetAllModules(ModuleMetadata manifestModule, string assemblyDir);
    internal Metadata GetMetadata(string fullPath, MetadataReferenceProperties properties);
    private Nullable`1<FileKey> GetUniqueFileKey(string filePath);
}
internal class Uno.SourceGeneration.Host.Server.NamedPipeClientConnection : ClientConnection {
    private NamedPipeServerStream _pipeStream;
    internal NamedPipeClientConnection(IGenerationServerHost compilerServerHost, string loggingIdentifier, NamedPipeServerStream pipeStream);
    protected virtual Task CreateMonitorDisconnectTask(CancellationToken cancellationToken);
    protected virtual void ValidateGenerationRequest(GenerationRequest request);
    private bool ClientAndOurIdentitiesMatch(NamedPipeServerStream pipeStream);
    private static ValueTuple`2<string, bool> GetIdentity(bool impersonating);
    public virtual void Close();
}
internal class Uno.SourceGeneration.Host.Server.NamedPipeClientConnectionHost : object {
    private static int PipeBufferSize;
    private IGenerationServerHost _compilerServerHost;
    private string _pipeName;
    private int _loggingIdentifier;
    internal NamedPipeClientConnectionHost(IGenerationServerHost compilerServerHost, string pipeName);
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.Server.NamedPipeClientConnectionHost/<CreateListenTask>d__5")]
public sealed virtual Task`1<IClientConnection> CreateListenTask(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.Server.NamedPipeClientConnectionHost/<CreateListenTaskCore>d__6")]
private Task`1<NamedPipeServerStream> CreateListenTaskCore(CancellationToken cancellationToken);
    private NamedPipeServerStream ConstructPipe(string pipeName);
}
internal class Uno.SourceGeneration.Host.Server.RunRequest : ValueType {
    [CompilerGeneratedAttribute]
private string <CurrentDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TempDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    public string CurrentDirectory { get; }
    public string TempDirectory { get; }
    public String[] Arguments { get; }
    public RunRequest(string currentDirectory, string tempDirectory, String[] arguments);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_CurrentDirectory();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TempDirectory();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public String[] get_Arguments();
}
internal class Uno.SourceGeneration.Host.Server.ServerDispatcher : object {
    internal static TimeSpan DefaultServerKeepAlive;
    internal static TimeSpan GCTimeout;
    private IClientConnectionHost _clientConnectionHost;
    private IDiagnosticListener _diagnosticListener;
    private State _state;
    private Task _timeoutTask;
    private Task _gcTask;
    private Task`1<IClientConnection> _listenTask;
    private CancellationTokenSource _listenCancellationTokenSource;
    private List`1<Task`1<ConnectionData>> _connectionList;
    private Nullable`1<TimeSpan> _keepAlive;
    private bool _keepAliveIsDefault;
    internal ServerDispatcher(IClientConnectionHost clientConnectionHost, IDiagnosticListener diagnosticListener);
    private static ServerDispatcher();
    public void ListenAndDispatchConnections(Nullable`1<TimeSpan> keepAlive, CancellationToken cancellationToken);
    public void ListenAndDispatchConnectionsCore(CancellationToken cancellationToken);
    private void CheckCompletedTasks(CancellationToken cancellationToken);
    private void HandleCancellation();
    private void WaitForAnyCompletion(CancellationToken cancellationToken);
    private void CreateListenTask();
    private void CloseListenTask();
    private void HandleCompletedListenTask(CancellationToken cancellationToken);
    private void HandleCompletedTimeoutTask();
    private void HandleCompletedGCTask();
    private void MaybeCreateTimeoutTask();
    private void MaybeCreateGCTask();
    private void HandleCompletedConnections();
    private void ChangeKeepAlive(Nullable`1<TimeSpan> value);
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.Server.ServerDispatcher/<HandleClientConnection>d__28")]
internal static Task`1<ConnectionData> HandleClientConnection(Task`1<IClientConnection> clientConnectionTask, bool allowCompilationRequests, CancellationToken cancellationToken);
}
public class Uno.SourceGeneration.Host.SourceGeneratorEngine : object {
    private BuildEnvironment _environment;
    private CachingMetadataReferenceResolver _metadataResolver;
    public SourceGeneratorEngine(BuildEnvironment environment, Func`3<string, MetadataReferenceProperties, MetadataReference> assemblyReferenceProvider);
    private void PreInit();
    public String[] Generate();
    private string BuildTreeFileName(Type generatorType, string key);
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.SourceGeneratorEngine/<GetCompilation>d__6")]
private Task`1<ValueTuple`2<Compilation, Project>> GetCompilation(ProjectDetails details);
    private Dictionary`2<string, string> BuildGlobalMSBuildProperties();
    [AsyncStateMachineAttribute("Uno.SourceGeneration.Host.SourceGeneratorEngine/<AddToCompilation>d__8")]
private Task`1<ValueTuple`2<Compilation, Project>> AddToCompilation(ValueTuple`2<Compilation, Project> previousCompilation, IEnumerable`1<ValueTuple`2<string, string>> files);
    private Project RemoveGeneratedDocuments(Project project);
    [CompilerGeneratedAttribute]
private void <PreInit>b__3_0();
    [CompilerGeneratedAttribute]
private ImmutableArray`1<PortableExecutableReference> <PreInit>b__3_1(string r);
    [CompilerGeneratedAttribute]
private bool <RemoveGeneratedDocuments>b__9_0(Document d);
}
[DataContractAttribute]
public class Uno.SourceGeneratorTasks.BuildEnvironment : object {
    [CompilerGeneratedAttribute]
private string <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VisualStudioVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetFrameworkRootPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BinLogOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BinLogEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildBinPath>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AdditionalAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SourceGenerators>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ReferencePath>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <AdditionalProperties>k__BackingField;
    [DataMemberAttribute]
public string Configuration { get; public set; }
    [DataMemberAttribute]
public string Platform { get; public set; }
    [DataMemberAttribute]
public string ProjectFile { get; public set; }
    [DataMemberAttribute]
public string OutputPath { get; public set; }
    [DataMemberAttribute]
public string TargetFramework { get; public set; }
    [DataMemberAttribute]
public string VisualStudioVersion { get; public set; }
    [DataMemberAttribute]
public string TargetFrameworkRootPath { get; public set; }
    [DataMemberAttribute]
public string BinLogOutputPath { get; public set; }
    [DataMemberAttribute]
public bool BinLogEnabled { get; public set; }
    [DataMemberAttribute]
public string MSBuildBinPath { get; public set; }
    [DataMemberAttribute]
public String[] AdditionalAssemblies { get; public set; }
    [DataMemberAttribute]
public String[] SourceGenerators { get; public set; }
    [DataMemberAttribute]
public String[] ReferencePath { get; public set; }
    [DataMemberAttribute]
public Dictionary`2<string, string> AdditionalProperties { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Configuration();
    [CompilerGeneratedAttribute]
public void set_Configuration(string value);
    [CompilerGeneratedAttribute]
public string get_Platform();
    [CompilerGeneratedAttribute]
public void set_Platform(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectFile();
    [CompilerGeneratedAttribute]
public void set_ProjectFile(string value);
    [CompilerGeneratedAttribute]
public string get_OutputPath();
    [CompilerGeneratedAttribute]
public void set_OutputPath(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(string value);
    [CompilerGeneratedAttribute]
public string get_VisualStudioVersion();
    [CompilerGeneratedAttribute]
public void set_VisualStudioVersion(string value);
    [CompilerGeneratedAttribute]
public string get_TargetFrameworkRootPath();
    [CompilerGeneratedAttribute]
public void set_TargetFrameworkRootPath(string value);
    [CompilerGeneratedAttribute]
public string get_BinLogOutputPath();
    [CompilerGeneratedAttribute]
public void set_BinLogOutputPath(string value);
    [CompilerGeneratedAttribute]
public bool get_BinLogEnabled();
    [CompilerGeneratedAttribute]
public void set_BinLogEnabled(bool value);
    [CompilerGeneratedAttribute]
public string get_MSBuildBinPath();
    [CompilerGeneratedAttribute]
public void set_MSBuildBinPath(string value);
    [CompilerGeneratedAttribute]
public String[] get_AdditionalAssemblies();
    [CompilerGeneratedAttribute]
public void set_AdditionalAssemblies(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_SourceGenerators();
    [CompilerGeneratedAttribute]
public void set_SourceGenerators(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_ReferencePath();
    [CompilerGeneratedAttribute]
public void set_ReferencePath(String[] value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_AdditionalProperties();
    [CompilerGeneratedAttribute]
public void set_AdditionalProperties(Dictionary`2<string, string> value);
}
internal class Uno.SourceGeneratorTasks.Helpers.BuildTargets : object {
    private Project _project;
    private List`1<string> _buildTargets;
    private static Char[] s_targetsSplitChars;
    public String[] Targets { get; }
    public BuildTargets(Project project, String[] targets);
    private static BuildTargets();
    public String[] get_Targets();
    public void Remove(string target);
    public void RemoveAfter(string target, bool includeTargetInRemoval);
    private bool DependsOn(string target, string dependentTarget);
    private static IEnumerable`1<string> SplitTargets(string targets);
    private static IEnumerable`1<string> GetTargetDependents(Project project, string targetName);
    internal static IEnumerable`1<string> GetTopLevelTargets(Project project);
}
public class Uno.SourceGeneratorTasks.Helpers.DisposableAction : object {
    [CompilerGeneratedAttribute]
private Action <Action>k__BackingField;
    public Action Action { get; private set; }
    public DisposableAction(Action action);
    [CompilerGeneratedAttribute]
public Action get_Action();
    [CompilerGeneratedAttribute]
private void set_Action(Action value);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Uno.SourceGeneratorTasks.Helpers.LogExtensionPoint : object {
    private static ILoggerFactory _loggerFactory;
    private static object _gate;
    public static ILoggerFactory AmbientLoggerFactory { get; }
    private static LogExtensionPoint();
    public static ILoggerFactory get_AmbientLoggerFactory();
    [ExtensionAttribute]
public static ILogger Log(Type forType);
    [ExtensionAttribute]
public static ILogger Log(T instance);
}
[ExtensionAttribute]
public static class Uno.SourceGeneratorTasks.Helpers.LogExtensions : object {
    [ExtensionAttribute]
public static void DebugFormat(ILogger log, object message);
    [ExtensionAttribute]
public static void DebugFormat(ILogger log, string format, object arg0);
    [ExtensionAttribute]
public static void DebugFormat(ILogger log, string format, object arg0, object arg1);
    [ExtensionAttribute]
public static void DebugFormat(ILogger log, string format, object arg0, object arg1, object arg2);
    [ExtensionAttribute]
public static void DebugFormat(ILogger log, string format, Object[] args);
    [ExtensionAttribute]
public static void Debug(ILogger log, string message, Exception exception);
    [ExtensionAttribute]
public static void Debug(ILogger log, Func`1<object> messageBuilder, Exception exception);
    [ExtensionAttribute]
public static void InfoFormat(ILogger log, object message);
    [ExtensionAttribute]
public static void InfoFormat(ILogger log, string format, object arg0);
    [ExtensionAttribute]
public static void InfoFormat(ILogger log, string format, object arg0, object arg1);
    [ExtensionAttribute]
public static void InfoFormat(ILogger log, string format, object arg0, object arg1, object arg2);
    [ExtensionAttribute]
public static void InfoFormat(ILogger log, string format, Object[] args);
    [ExtensionAttribute]
public static void Info(ILogger log, string message, Exception exception);
    [ExtensionAttribute]
public static void Info(ILogger log, Func`1<object> messageBuilder, Exception exception);
    [ExtensionAttribute]
public static void WarnFormat(ILogger log, object message);
    [ExtensionAttribute]
public static void WarnFormat(ILogger log, string format, object arg0);
    [ExtensionAttribute]
public static void WarnFormat(ILogger log, string format, object arg0, object arg1);
    [ExtensionAttribute]
public static void WarnFormat(ILogger log, string format, object arg0, object arg1, object arg2);
    [ExtensionAttribute]
public static void WarnFormat(ILogger log, string format, Object[] args);
    [ExtensionAttribute]
public static void Warn(ILogger log, Func`1<object> messageBuilder, Exception exception);
    [ExtensionAttribute]
public static void Warn(ILogger log, string message, Exception exception);
    [ExtensionAttribute]
public static void ErrorFormat(ILogger log, object message);
    [ExtensionAttribute]
public static void ErrorFormat(ILogger log, string format, object arg0);
    [ExtensionAttribute]
public static void ErrorFormat(ILogger log, string format, object arg0, object arg1);
    [ExtensionAttribute]
public static void ErrorFormat(ILogger log, string format, object arg0, object arg1, object arg2);
    [ExtensionAttribute]
public static void ErrorFormat(ILogger log, string format, Object[] args);
    [ExtensionAttribute]
public static void Error(ILogger log, string message, Exception exception);
    [ExtensionAttribute]
public static void Error(ILogger log, Func`1<object> messageBuilder, Exception exception);
}
[ExtensionAttribute]
public static class Uno.SourceGeneratorTasks.Helpers.StringExtensions : object {
    [ExtensionAttribute]
public static string JoinBy(IEnumerable`1<string> items, string joinBy);
    [ExtensionAttribute]
public static bool HasValue(string instance);
}
[ExtensionAttribute]
public static class Uno.SourceGeneratorTasks.Helpers.TypeExtensions : object {
    [IteratorStateMachineAttribute("Uno.SourceGeneratorTasks.Helpers.TypeExtensions/<GetBaseTypes>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<Type> GetBaseTypes(Type type);
}
public class Uno.SourceGeneratorTasks.Logger.RemotableLogger2 : MarshalByRefObject {
    private ILogger _log;
    public RemotableLogger2(ILogger log);
    public virtual object InitializeLifetimeService();
    public void WriteLog(int logLevel, string message);
}
public class Uno.SourceGeneratorTasks.Logger.RemoteLogger : MarshalByRefObject {
    private RemotableLogger2 _taskLog;
    private string _loggerName;
    public RemotableLogger2 TaskLog { get; public set; }
    public RemoteLogger(string loggerName);
    public virtual object InitializeLifetimeService();
    public RemotableLogger2 get_TaskLog();
    public void set_TaskLog(RemotableLogger2 value);
    public sealed virtual IDisposable BeginScope(TState state);
    public sealed virtual bool IsEnabled(LogLevel logLevel);
    public sealed virtual void Log(LogLevel logLevel, EventId eventId, TState state, Exception exception, Func`3<TState, Exception, string> formatter);
}
public class Uno.SourceGeneratorTasks.Logger.RemoteLoggerProvider : object {
    private List`1<RemoteLogger> _loggers;
    private RemotableLogger2 _taskLog;
    public RemotableLogger2 TaskLog { get; public set; }
    public RemotableLogger2 get_TaskLog();
    public void set_TaskLog(RemotableLogger2 value);
    public sealed virtual ILogger CreateLogger(string categoryName);
    public sealed virtual void Dispose();
}
public class Uno.SourceGeneratorTasks.RemoteSourceGeneratorEngine : MarshalByRefObject {
    private RemoteLoggerProvider _remoteLoggerProvider;
    private bool _additionalAssembliesLoaded;
    private bool _initialized;
    [CompilerGeneratedAttribute]
private string <MSBuildBasePath>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <AdditionalAssemblies>k__BackingField;
    public string MSBuildBasePath { get; public set; }
    public String[] AdditionalAssemblies { get; public set; }
    private static bool IsMono { get; }
    [CompilerGeneratedAttribute]
public string get_MSBuildBasePath();
    [CompilerGeneratedAttribute]
public void set_MSBuildBasePath(string value);
    [CompilerGeneratedAttribute]
public String[] get_AdditionalAssemblies();
    [CompilerGeneratedAttribute]
public void set_AdditionalAssemblies(String[] value);
    public void Initialize();
    public virtual object InitializeLifetimeService();
    internal String[] Generate(RemotableLogger2 logger, BuildEnvironment environment);
    private void RegisterAssemblyLoader();
    private void TryLoadAdditionalAssemblies();
    private static void ApplyVS4MacWorkarounds();
    private void ApplyCacheFolderMSBuildWorkaround();
    internal bool Ping();
    private static bool get_IsMono();
    [CompilerGeneratedAttribute]
private void <Initialize>b__12_0(object s, EventArgs e);
    [CompilerGeneratedAttribute]
private Assembly <RegisterAssemblyLoader>b__15_0(object s, ResolveEventArgs e);
}
