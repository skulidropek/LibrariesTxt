[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.CodeCleanup.AsyncOrIteratorFunctionReturnTypeFixer : object {
    public static MethodStatementSyntax RewriteMethodStatement(MethodStatementSyntax func, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static MethodStatementSyntax RewriteMethodStatement(MethodStatementSyntax func, SemanticModel semanticModel, MethodStatementSyntax oldFunc, CancellationToken cancellationToken);
    public static LambdaHeaderSyntax RewriteLambdaHeader(LambdaHeaderSyntax lambdaHeader, SemanticModel semanticModel, CancellationToken cancellationToken);
    public static LambdaHeaderSyntax RewriteLambdaHeader(LambdaHeaderSyntax lambdaHeader, SemanticModel semanticModel, LambdaHeaderSyntax oldLambdaHeader, CancellationToken cancellationToken);
    private static bool RewriteFunctionStatement(SyntaxTokenList modifiers, AsClauseSyntax oldAsClauseOpt, ParameterListSyntax& parameterListOpt, SimpleAsClauseSyntax& asClauseOpt, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private static bool RewriteAsyncFunction(AsClauseSyntax oldAsClauseOpt, ParameterListSyntax& parameterListOpt, SimpleAsClauseSyntax& asClauseOpt, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private static bool RewriteIteratorFunction(AsClauseSyntax oldAsClauseOpt, ParameterListSyntax& parameterListOpt, SimpleAsClauseSyntax& asClauseOpt, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private static void GenerateFunctionAsClause(ITypeSymbol type, ParameterListSyntax& parameterListOpt, SimpleAsClauseSyntax& asClauseOpt, SemanticModel semanticModel, int position);
    private static void RewriteFunctionAsClause(INamedTypeSymbol genericType, SimpleAsClauseSyntax& asClauseOpt, SemanticModel semanticModel, int position);
}
internal abstract class Microsoft.CodeAnalysis.CodeCleanup.Providers.AbstractTokensCodeCleanupProvider : object {
    public string Name { get; }
    public abstract virtual override string get_Name();
    protected abstract virtual Task`1<Rewriter> GetRewriterAsync(Document document, SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.Providers.AbstractTokensCodeCleanupProvider/VB$StateMachine_4_CleanupAsync")]
public sealed virtual override Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.Providers.AbstractTokensCodeCleanupProvider/VB$StateMachine_5_CleanupAsync")]
public sealed virtual override Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
[ExportCodeCleanupProvider("AddMissingTokensCodeCleanupProvider", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.AddMissingTokensCodeCleanupProvider : AbstractTokensCodeCleanupProvider {
    public string Name { get; }
    public virtual string get_Name();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.Providers.AddMissingTokensCodeCleanupProvider/VB$StateMachine_3_GetRewriterAsync")]
protected virtual Task`1<Rewriter> GetRewriterAsync(Document document, SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
[ExportCodeCleanupProvider("CaseCorrectionCodeCleanupProvider", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.CaseCorrectionCodeCleanupProvider : object {
    public string Name { get; }
    public sealed virtual override string get_Name();
    public sealed virtual override Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    public sealed virtual override Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
[ExportCodeCleanupProvider("FixIncorrectTokensCodeCleanupProvider", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.FixIncorrectTokensCodeCleanupProvider : AbstractTokensCodeCleanupProvider {
    private static char s_ASCII_LSMART_Q;
    private static char s_ASCII_RSMART_Q;
    private static char s_UNICODE_LSMART_Q;
    private static char s_UNICODE_RSMART_Q;
    private static char s_CH_STRGHT_Q;
    private static Char[] s_smartSingleQuotes;
    public string Name { get; }
    private static FixIncorrectTokensCodeCleanupProvider();
    public virtual string get_Name();
    protected virtual Task`1<Rewriter> GetRewriterAsync(Document document, SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
[ExportCodeCleanupProvider("NormalizeModifiersOrOperatorsCodeCleanupProvider", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider : object {
    public string Name { get; }
    public sealed virtual override string get_Name();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.Providers.NormalizeModifiersOrOperatorsCodeCleanupProvider/VB$StateMachine_3_CleanupAsync")]
public sealed virtual override Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    public sealed virtual override Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
[ExportCodeCleanupProvider("ReduceTokensCodeCleanupProvider", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.ReduceTokensCodeCleanupProvider : AbstractTokensCodeCleanupProvider {
    public string Name { get; }
    public virtual string get_Name();
    protected virtual Task`1<Rewriter> GetRewriterAsync(Document document, SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
[ExportCodeCleanupProvider("RemoveUnnecessaryLineContinuation", "Mono.Cecil.CustomAttributeArgument[]")]
[SharedAttribute]
[ExtensionOrderAttribute]
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.RemoveUnnecessaryLineContinuationCodeCleanupProvider : object {
    public string Name { get; }
    public sealed virtual override string get_Name();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.Providers.RemoveUnnecessaryLineContinuationCodeCleanupProvider/VB$StateMachine_3_CleanupAsync")]
public sealed virtual override Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    public sealed virtual override Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ILanguageServiceReferenceFinder", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.FindSymbols.VisualBasicReferenceFinder : object {
    public sealed virtual override Task`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(ISymbol symbol, Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.VisualBasicReferenceFinder/VB$StateMachine_2_DetermineCascadedSymbolsAsync")]
private static Task`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(IPropertySymbol property, Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.VisualBasicReferenceFinder/VB$StateMachine_3_DetermineCascadedSymbolsAsync")]
private static Task`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(INamedTypeSymbol namedType, Project project, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.AddImports.IAddImportsService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.AddImports.VisualBasicAddImportsService : AbstractAddImportsService`4<CompilationUnitSyntax, NamespaceBlockSyntax, ImportsStatementSyntax, ImportsStatementSyntax> {
    private static ImportsStatementComparer ImportsStatementComparer;
    private static VisualBasicAddImportsService();
    protected virtual bool IsEquivalentImport(SyntaxNode a, SyntaxNode b);
    protected virtual ImmutableArray`1<SyntaxNode> GetGlobalImports(Compilation compilation, SyntaxGenerator generator);
    protected virtual SyntaxNode GetAlias(ImportsStatementSyntax usingOrAlias);
    protected virtual bool PlaceImportsInsideNamespaces(OptionSet options);
    protected virtual bool IsStaticUsing(ImportsStatementSyntax usingOrAlias);
    protected virtual SyntaxList`1<ImportsStatementSyntax> GetExterns(SyntaxNode node);
    protected virtual SyntaxList`1<ImportsStatementSyntax> GetUsingsAndAliases(SyntaxNode node);
    protected virtual SyntaxNode Rewrite(ImportsStatementSyntax[] externAliases, ImportsStatementSyntax[] usingDirectives, ImportsStatementSyntax[] staticUsingDirectives, ImportsStatementSyntax[] aliasDirectives, SyntaxNode externContainer, SyntaxNode usingContainer, SyntaxNode staticUsingContainer, SyntaxNode aliasContainer, bool placeSystemNamespaceFirst, bool allowInHiddenRegions, SyntaxNode root, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ILinkedFileMergeConflictCommentAdditionService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.BasicLinkedFileMergeConflictCommentAdditionService : AbstractLinkedFileMergeConflictCommentAdditionService {
    internal virtual string GetConflictCommentText(string header, string beforeString, string afterString);
    private static string GetCommentedText(string text);
}
internal class Microsoft.CodeAnalysis.VisualBasic.CaseCorrection.VisualBasicCaseCorrectionService : AbstractCaseCorrectionService {
    private static int s_threshold;
    private static string s_attributeSuffix;
    private ISyntaxFactsService _syntaxFactsService;
    public VisualBasicCaseCorrectionService(HostLanguageServices provider);
    protected virtual void AddReplacements(SemanticModel semanticModel, SyntaxNode root, ImmutableArray`1<TextSpan> spans, Workspace workspace, ConcurrentDictionary`2<SyntaxToken, SyntaxToken> replacements, CancellationToken cancellationToken);
    private void AddReplacementsWorker(SemanticModel semanticModel, SyntaxNode root, TextSpan span, ConcurrentDictionary`2<SyntaxToken, SyntaxToken> replacements, CancellationToken cancellationToken);
    private static void Rewrite(SyntaxToken token, Rewriter rewriter, ConcurrentDictionary`2<SyntaxToken, SyntaxToken> replacements);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.CaseCorrection.ICaseCorrectionService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CaseCorrection.VisualBasicCaseCorrectionServiceFactory : object {
    public sealed virtual override ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Classification.ClassificationHelpers : object {
    public static string GetClassification(SyntaxToken token);
    private static bool IsControlKeyword(SyntaxToken token);
    private static bool IsControlKeywordKind(SyntaxKind kind);
    private static bool IsControlStatementKind(SyntaxKind kind);
    private static string ClassifyPunctuation(SyntaxToken token);
    private static string ClassifyIdentifierSyntax(SyntaxToken identifier);
    private static bool IsNamespaceName(IdentifierNameSyntax identifierSyntax);
    public static bool IsStaticallyDeclared(SyntaxToken identifier);
    private static bool IsStringToken(SyntaxToken token);
    private static bool TryClassifyModifiedIdentifer(SyntaxNode node, SyntaxToken identifier, String& classification);
    private static string ClassifyTypeDeclarationIdentifier(SyntaxToken identifier);
    internal static void AddLexicalClassifications(SourceText text, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    internal static ClassifiedSpan AdjustStaleClassification(SourceText text, ClassifiedSpan classifiedSpan);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Classification.Classifiers.IdentifierNameSyntaxClassifier : AbstractSyntaxClassifier {
    private static string s_awaitText;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Type> _SyntaxNodeTypes;
    public ImmutableArray`1<Type> SyntaxNodeTypes { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<Type> get_SyntaxNodeTypes();
    public virtual void AddClassifications(Workspace workspace, SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Classification.Classifiers.ImportAliasClauseSyntaxClassifier : AbstractSyntaxClassifier {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Type> _SyntaxNodeTypes;
    public ImmutableArray`1<Type> SyntaxNodeTypes { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<Type> get_SyntaxNodeTypes();
    public virtual void AddClassifications(Workspace workspace, SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    private static void ClassifyImportAliasClauseSyntax(ImportAliasClauseSyntax node, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Classification.Classifiers.NameSyntaxClassifier : AbstractNameSyntaxClassifier {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Type> _SyntaxNodeTypes;
    public ImmutableArray`1<Type> SyntaxNodeTypes { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<Type> get_SyntaxNodeTypes();
    public virtual void AddClassifications(Workspace workspace, SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    protected virtual Nullable`1<int> GetRightmostNameArity(SyntaxNode node);
    protected virtual bool IsParentAnAttribute(SyntaxNode node);
    private void ClassifyNameSyntax(NameSyntax node, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    private static bool TryClassifySymbol(NameSyntax node, ISymbol symbol, ClassifiedSpan& classifiedSpan);
    private static bool TryClassifyMyNamespace(NameSyntax node, ISymbol symbol, SemanticModel semanticModel, ClassifiedSpan& classifiedSpan);
    private static bool TryClassifyIdentifier(NameSyntax node, SemanticModel semanticModel, CancellationToken cancellationToken, ClassifiedSpan& classifiedSpan);
    private static string GetClassificationForField(IFieldSymbol fieldSymbol);
    private static string GetClassificationForLocal(ILocalSymbol localSymbol);
    private static string GetClassificationForMethod(NameSyntax node, IMethodSymbol methodSymbol);
    private static void ClassifyModifiedIdentifier(ModifiedIdentifierSyntax modifiedIdentifier, ArrayBuilder`1<ClassifiedSpan> result);
    private static SyntaxToken GetNameToken(NameSyntax node);
    private static void ClassifyMethodStatement(MethodStatementSyntax methodStatement, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result);
    private static void ClassifyLabelSyntax(LabelSyntax node, ArrayBuilder`1<ClassifiedSpan> result);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Classification.Classifiers.OperatorOverloadSyntaxClassifier : AbstractSyntaxClassifier {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Type> _SyntaxNodeTypes;
    public ImmutableArray`1<Type> SyntaxNodeTypes { get; }
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<Type> get_SyntaxNodeTypes();
    public virtual void AddClassifications(Workspace workspace, SyntaxNode syntax, SemanticModel semanticModel, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Classification.IClassificationService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Classification.VisualBasicEditorClassificationService : AbstractClassificationService {
    public virtual void AddLexicalClassifications(SourceText text, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public virtual ClassifiedSpan AdjustStaleClassification(SourceText text, ClassifiedSpan classifiedSpan);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Classification.VisualBasicSyntaxClassificationService : AbstractSyntaxClassificationService {
    private ImmutableArray`1<ISyntaxClassifier> s_defaultSyntaxClassifiers;
    [ObsoleteAttribute("This factory method only provides services for the MEF export provider.", "True")]
public VisualBasicSyntaxClassificationService(HostLanguageServices languageServices);
    public virtual ImmutableArray`1<ISyntaxClassifier> GetDefaultSyntaxClassifiers();
    public virtual void AddLexicalClassifications(SourceText text, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public virtual void AddSyntacticClassifications(SyntaxNode root, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public virtual ClassifiedSpan FixClassification(SourceText text, ClassifiedSpan classifiedSpan);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.Classification.ISyntaxClassificationService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Classification.VisualBasicSyntaxClassificationServiceFactory : object {
    [ObsoleteAttribute("This factory method only provides services for the MEF export provider.", "True")]
public sealed virtual override ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Classification.Worker : object {
    private ArrayBuilder`1<ClassifiedSpan> _list;
    private TextSpan _textSpan;
    private DocumentationCommentClassifier _docCommentClassifier;
    private XmlClassifier _xmlClassifier;
    private CancellationToken _cancellationToken;
    private Worker(TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> list, CancellationToken cancellationToken);
    internal static void CollectClassifiedSpans(IEnumerable`1<SyntaxToken> tokens, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> list, CancellationToken cancellationToken);
    internal static void CollectClassifiedSpans(SyntaxNode node, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> list, CancellationToken cancellationToken);
    private void AddClassification(TextSpan textSpan, string classificationType);
    private void AddClassification(SyntaxToken token, string classificationType);
    private void AddClassification(SyntaxTrivia trivia, string classificationType);
    internal void ClassifyNode(SyntaxNode node);
    private static bool IsXmlNode(SyntaxNode node);
    private void ClassifyXmlNode(SyntaxNode node);
    internal void ClassifyToken(SyntaxToken token, string type);
    private void ClassifyTrivia(SyntaxToken token);
    public void ClassifyTrivia(SyntaxTriviaList triviaList);
    private void ClassifyTrivia(SyntaxTrivia trivia, SyntaxTriviaList triviaList);
    private void ClassifyConflictMarker(SyntaxTrivia trivia);
    private void ClassifyDisabledText(SyntaxTrivia trivia, SyntaxTriviaList triviaList);
    private void ClassifySkippedTokens(SkippedTokensTriviaSyntax skippedTokens);
    private void ClassifyDirectiveSyntax(SyntaxNode directiveSyntax);
}
internal class Microsoft.CodeAnalysis.VisualBasic.CodeCleanup.VisualBasicCodeCleanerService : AbstractCodeCleanerService {
    private static ImmutableArray`1<ICodeCleanupProvider> s_defaultProviders;
    private static VisualBasicCodeCleanerService();
    public virtual ImmutableArray`1<ICodeCleanupProvider> GetDefaultProviders();
    protected virtual ImmutableArray`1<TextSpan> GetSpansToAvoid(SyntaxNode root);
    private void ProcessNode(SyntaxNode node, ArrayBuilder`1<TextSpan> result);
    private void ProcessToken(SyntaxToken token, ArrayBuilder`1<TextSpan> result);
    private static bool SkipProcessing(SyntaxNodeOrToken nodeOrToken, ArrayBuilder`1<TextSpan> result);
    private static bool ContainsMultiLineStringLiteral(SyntaxNode node);
    private SyntaxNode GetMultiLineContainer(SyntaxNode node);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeCleanup.VisualBasicCodeCleanerServiceFactory : object {
    public sealed virtual override ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.ArgumentGenerator : object {
    public static ArgumentSyntax GenerateArgument(SyntaxNode argument);
    internal static ArgumentListSyntax GenerateArgumentList(IList`1<SyntaxNode> arguments);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.AttributeGenerator : object {
    public static SyntaxList`1<AttributeListSyntax> GenerateAttributeBlocks(ImmutableArray`1<AttributeData> attributes, CodeGenerationOptions options, Nullable`1<SyntaxToken> target);
    private static AttributeListSyntax GenerateAttributeBlock(AttributeData attribute, CodeGenerationOptions options, Nullable`1<SyntaxToken> target);
    private static AttributeSyntax GenerateAttribute(AttributeData attribute, CodeGenerationOptions options, Nullable`1<SyntaxToken> target);
    private static ArgumentListSyntax GenerateArgumentList(AttributeData attribute);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.ConstructorGenerator : object {
    private static TDeclaration LastConstructorOrField(SyntaxList`1<TDeclaration> members);
    internal static TypeBlockSyntax AddConstructorTo(TypeBlockSyntax destination, IMethodSymbol constructor, CodeGenerationOptions options, IList`1<bool> availableIndices);
    internal static StatementSyntax GenerateConstructorDeclaration(IMethodSymbol constructor, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static SyntaxList`1<StatementSyntax> GenerateStatements(IMethodSymbol constructor);
    private static SyntaxTokenList GenerateModifiers(IMethodSymbol constructor, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static StatementSyntax CreateBaseConstructorCall(IMethodSymbol constructor);
    private static StatementSyntax CreateThisConstructorCall(IList`1<SyntaxNode> arguments);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.ConversionGenerator : object {
    internal static TypeBlockSyntax AddConversionTo(TypeBlockSyntax destination, IMethodSymbol method, CodeGenerationOptions options, IList`1<bool> availableIndices);
    public static StatementSyntax GenerateConversionDeclaration(IMethodSymbol method, CodeGenerationOptions options);
    private static StatementSyntax GenerateConversionDeclarationWorker(IMethodSymbol method, CodeGenerationOptions options);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.EnumMemberGenerator : object {
    internal static EnumBlockSyntax AddEnumMemberTo(EnumBlockSyntax destination, IFieldSymbol enumMember, CodeGenerationOptions options);
    public static EnumMemberDeclarationSyntax GenerateEnumMemberDeclaration(IFieldSymbol enumMember, EnumBlockSyntax enumDeclarationOpt, CodeGenerationOptions options);
    private static ExpressionSyntax CreateEnumMemberValue(EnumBlockSyntax destinationOpt, IFieldSymbol enumMember);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.EventGenerator : object {
    private static StatementSyntax AfterMember(SyntaxList`1<StatementSyntax> members, StatementSyntax eventDeclaration);
    private static StatementSyntax BeforeMember(SyntaxList`1<StatementSyntax> members, StatementSyntax eventDeclaration);
    internal static TypeBlockSyntax AddEventTo(TypeBlockSyntax destination, IEventSymbol event, CodeGenerationOptions options, IList`1<bool> availableIndices);
    public static DeclarationStatementSyntax GenerateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static DeclarationStatementSyntax GenerateEventDeclarationWorker(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static DeclarationStatementSyntax GenerateCustomEventDeclarationWorker(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static EventStatementSyntax GenerateNotCustomEventDeclarationWorker(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static SyntaxTokenList GenerateModifiers(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static SimpleAsClauseSyntax GenerateAsClause(IEventSymbol event);
    private static IParameterSymbol RemoveOptionalOrParamArray(IParameterSymbol parameter);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.ExpressionGenerator : object {
    private static string s_doubleQuote;
    internal static ExpressionSyntax GenerateExpression(TypedConstant typedConstant);
    internal static ExpressionSyntax GenerateExpression(ITypeSymbol type, object value, bool canUseFieldReference);
    internal static ExpressionSyntax GenerateNonEnumValueExpression(ITypeSymbol type, object value, bool canUseFieldReference);
    private static ExpressionSyntax GenerateNothingLiteral();
    private static ExpressionSyntax GenerateDateLiteralExpression(DateTime value);
    private static ExpressionSyntax GenerateStringLiteralExpression(ITypeSymbol type, string value);
    private static MemberAccessExpressionSyntax GenerateMemberAccessExpression(String[] names);
    private static InvocationExpressionSyntax GenerateChrWExpression(char c);
    private static ExpressionSyntax GenerateNonNegativeIntegralLiteralExpression(ITypeSymbol type, SpecialType specialType, TStructure value, bool canUseFieldReference, IEnumerable`1<KeyValuePair`2<TStructure, string>> specialValues);
    private static ExpressionSyntax GenerateIntegralLiteralExpression(ITypeSymbol type, SpecialType specialType, TStructure value, bool canUseFieldReference, IEnumerable`1<KeyValuePair`2<TStructure, string>> specialValues, Func`2<TStructure, bool> isNegative, Func`2<TStructure, TStructure> negate, string integerMinValueString);
    private static void DetermineSuffix(ITypeSymbol type, object value, TypeCharacter& typeSuffix, String& suffix);
    private static ExpressionSyntax GenerateDoubleLiteralExpression(ITypeSymbol type, double value, bool canUseFieldReference);
    private static ExpressionSyntax GenerateSingleLiteralExpression(ITypeSymbol type, float value, bool canUseFieldReference);
    private static ExpressionSyntax GenerateFloatLiteralExpression(ITypeSymbol type, SpecialType specialType, TStructure value, bool canUseFieldReference, IEnumerable`1<KeyValuePair`2<TStructure, string>> specialValues, Func`2<TStructure, bool> isNegative, Func`2<TStructure, TStructure> negate);
    private static LiteralExpressionSyntax GenerateFloatLiteral(double value, string literal, TypeCharacter typeSuffix);
    private static ExpressionSyntax GenerateCharLiteralExpression(char c);
    private static ExpressionSyntax GenerateDecimalLiteralExpression(ITypeSymbol type, decimal value, bool canUseFieldReference);
    private static MemberAccessExpressionSyntax AddSpecialTypeAnnotation(SpecialType type, MemberAccessExpressionSyntax expression);
    private static MemberAccessExpressionSyntax GenerateFieldReference(SpecialType type, object value, IEnumerable`1<KeyValuePair`2<TStructure, string>> specialValues);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.FieldGenerator : object {
    private static TDeclaration LastField(SyntaxList`1<TDeclaration> members, FieldDeclarationSyntax fieldDeclaration);
    internal static CompilationUnitSyntax AddFieldTo(CompilationUnitSyntax destination, IFieldSymbol field, CodeGenerationOptions options, IList`1<bool> availableIndices);
    internal static TypeBlockSyntax AddFieldTo(TypeBlockSyntax destination, IFieldSymbol field, CodeGenerationOptions options, IList`1<bool> availableIndices);
    public static FieldDeclarationSyntax GenerateFieldDeclaration(IFieldSymbol field, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static EqualsValueSyntax GenerateEqualsValue(IFieldSymbol field);
    private static SyntaxTokenList GenerateModifiers(IFieldSymbol field, CodeGenerationDestination destination, CodeGenerationOptions options);
}
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.MethodGenerator : object {
    internal static NamespaceBlockSyntax AddMethodTo(NamespaceBlockSyntax destination, IMethodSymbol method, CodeGenerationOptions options, IList`1<bool> availableIndices);
    internal static CompilationUnitSyntax AddMethodTo(CompilationUnitSyntax destination, IMethodSymbol method, CodeGenerationOptions options, IList`1<bool> availableIndices);
    internal static TypeBlockSyntax AddMethodTo(TypeBlockSyntax destination, IMethodSymbol method, CodeGenerationOptions options, IList`1<bool> availableIndices);
    public static StatementSyntax GenerateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static StatementSyntax GenerateMethodDeclarationWorker(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static SimpleAsClauseSyntax GenerateAsClause(IMethodSymbol method, bool isSub, CodeGenerationOptions options);
    private static HandlesClauseSyntax GenerateHandlesClause(IList`1<SyntaxNode> expressions);
    private static TypeParameterListSyntax GenerateTypeParameterList(IMethodSymbol method);
    private static SyntaxTokenList GenerateModifiers(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationOptions options);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.NamedTypeGenerator : object {
    public static TypeBlockSyntax AddNamedTypeTo(ICodeGenerationService service, TypeBlockSyntax destination, INamedTypeSymbol namedType, CodeGenerationOptions options, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static NamespaceBlockSyntax AddNamedTypeTo(ICodeGenerationService service, NamespaceBlockSyntax destination, INamedTypeSymbol namedType, CodeGenerationOptions options, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static CompilationUnitSyntax AddNamedTypeTo(ICodeGenerationService service, CompilationUnitSyntax destination, INamedTypeSymbol namedType, CodeGenerationOptions options, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static StatementSyntax GenerateNamedTypeDeclaration(ICodeGenerationService service, INamedTypeSymbol namedType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static StatementSyntax UpdateNamedTypeDeclaration(ICodeGenerationService service, StatementSyntax declaration, IList`1<ISymbol> newMembers, CodeGenerationOptions options, CancellationToken cancellationToken);
    private static StatementSyntax GetDeclarationSyntaxWithoutMembers(INamedTypeSymbol namedType, CodeGenerationOptions options);
    private static StatementSyntax RemoveAllMembers(StatementSyntax declaration);
    private static StatementSyntax GenerateNamedTypeDeclarationWorker(INamedTypeSymbol namedType, CodeGenerationOptions options);
    private static StatementSyntax GenerateDelegateDeclaration(INamedTypeSymbol namedType, CodeGenerationOptions options);
    private static StatementSyntax GenerateEnumDeclaration(INamedTypeSymbol namedType, CodeGenerationOptions options);
    private static SyntaxList`1<AttributeListSyntax> GenerateAttributes(INamedTypeSymbol namedType, CodeGenerationOptions options);
    private static SyntaxTokenList GenerateModifiers(INamedTypeSymbol namedType);
    private static TypeParameterListSyntax GenerateTypeParameterList(INamedTypeSymbol namedType);
    private static SyntaxList`1<InheritsStatementSyntax> GenerateInheritsStatements(INamedTypeSymbol namedType);
    private static SyntaxList`1<ImplementsStatementSyntax> GenerateImplementsStatements(INamedTypeSymbol namedType);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.NamespaceGenerator : object {
    public static CompilationUnitSyntax AddNamespaceTo(ICodeGenerationService service, CompilationUnitSyntax destination, INamespaceSymbol namespace, CodeGenerationOptions options, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static NamespaceBlockSyntax AddNamespaceTo(ICodeGenerationService service, NamespaceBlockSyntax destination, INamespaceSymbol namespace, CodeGenerationOptions options, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public static SyntaxNode GenerateNamespaceDeclaration(ICodeGenerationService service, INamespaceSymbol namespace, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static SyntaxNode UpdateCompilationUnitOrNamespaceDeclaration(ICodeGenerationService service, SyntaxNode declaration, IList`1<ISymbol> newMembers, CodeGenerationOptions options, CancellationToken cancellationToken);
    private static SyntaxNode GetDeclarationSyntaxWithoutMembers(INamespaceSymbol namespace, INamespaceSymbol innermostNamespace, string name, CodeGenerationOptions options);
    private static SyntaxNode RemoveAllMembers(SyntaxNode declaration);
    private static SyntaxNode GenerateNamespaceDeclarationWorker(string name, INamespaceSymbol namespace);
    private static SyntaxList`1<ImportsStatementSyntax> GenerateImportsStatements(INamespaceSymbol namespace);
    private static ImportsStatementSyntax GenerateImportsStatement(ISymbol import);
    private static NameSyntax GenerateName(INamespaceOrTypeSymbol symbol);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.OperatorGenerator : object {
    internal static TypeBlockSyntax AddOperatorTo(TypeBlockSyntax destination, IMethodSymbol method, CodeGenerationOptions options, IList`1<bool> availableIndices);
    public static StatementSyntax GenerateOperatorDeclaration(IMethodSymbol method, CodeGenerationOptions options);
    private static StatementSyntax GenerateOperatorDeclarationWorker(IMethodSymbol method, CodeGenerationOptions options);
}
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.ParameterGenerator : object {
    public static ParameterListSyntax GenerateParameterList(ImmutableArray`1<IParameterSymbol> parameterDefinitions, CodeGenerationOptions options);
    public static ParameterListSyntax GenerateParameterList(IEnumerable`1<IParameterSymbol> parameterDefinitions, CodeGenerationOptions options);
    internal static ParameterSyntax GenerateParameter(IParameterSymbol parameter, bool seenOptional, CodeGenerationOptions options);
    private static SyntaxTokenList GenerateModifiers(IParameterSymbol parameter, bool seenOptional);
    private static EqualsValueSyntax GenerateEqualsValue(IParameterSymbol parameter, bool seenOptional);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.PropertyGenerator : object {
    private static TDeclaration LastPropertyOrField(SyntaxList`1<TDeclaration> members);
    internal static CompilationUnitSyntax AddPropertyTo(CompilationUnitSyntax destination, IPropertySymbol property, CodeGenerationOptions options, IList`1<bool> availableIndices);
    internal static TypeBlockSyntax AddPropertyTo(TypeBlockSyntax destination, IPropertySymbol property, CodeGenerationOptions options, IList`1<bool> availableIndices);
    public static StatementSyntax GeneratePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static StatementSyntax GeneratePropertyDeclarationWorker(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static ParameterListSyntax GeneratePropertyParameterList(IPropertySymbol property, CodeGenerationOptions options);
    private static SyntaxList`1<AccessorBlockSyntax> GenerateAccessorList(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static AccessorBlockSyntax GenerateAccessor(IPropertySymbol property, IMethodSymbol accessor, bool isGetter, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static SyntaxList`1<StatementSyntax> GenerateAccessorStatements(IMethodSymbol accessor);
    private static SyntaxTokenList GenerateAccessorModifiers(IPropertySymbol property, IMethodSymbol accessor, CodeGenerationDestination destination, CodeGenerationOptions options);
    private static SyntaxTokenList GenerateModifiers(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationOptions options, ParameterListSyntax parameterList);
    private static bool IsRequired(ParameterSyntax parameter);
    private static AsClauseSyntax GenerateAsClause(IPropertySymbol property, CodeGenerationOptions options);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.StatementGenerator : object {
    internal static SyntaxList`1<StatementSyntax> GenerateStatements(IEnumerable`1<SyntaxNode> statements);
    internal static SyntaxList`1<StatementSyntax> GenerateStatements(IMethodSymbol method);
}
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.TypeParameterGenerator : object {
    public static TypeParameterListSyntax GenerateTypeParameterList(ImmutableArray`1<ITypeParameterSymbol> typeParameters);
    private static TypeParameterSyntax GenerateTypeParameter(ITypeParameterSymbol symbol);
    private static TypeParameterConstraintClauseSyntax GenerateTypeParameterConstraintClause(ITypeParameterSymbol symbol);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.VisualBasicCodeGenerationHelpers : object {
    internal static void AddAccessibilityModifiers(Accessibility accessibility, ArrayBuilder`1<SyntaxToken> tokens, CodeGenerationDestination destination, CodeGenerationOptions options, Accessibility nonStructureAccessibility);
    public static SyntaxList`1<StatementSyntax> InsertAtIndex(SyntaxList`1<StatementSyntax> members, StatementSyntax member, int index);
    public static ImplementsClauseSyntax GenerateImplementsClause(ISymbol explicitInterfaceOpt);
    public static T EnsureLastElasticTrivia(T statement);
    public static TDeclaration FirstMember(SyntaxList`1<TDeclaration> members);
    public static TDeclaration FirstMethod(SyntaxList`1<TDeclaration> members);
    public static TDeclaration LastField(SyntaxList`1<TDeclaration> members);
    public static TDeclaration LastConstructor(SyntaxList`1<TDeclaration> members);
    public static TDeclaration LastMethod(SyntaxList`1<TDeclaration> members);
    public static TDeclaration LastOperator(SyntaxList`1<TDeclaration> members);
    private static Func`2<SyntaxList`1<TDeclaration>, TDeclaration> AfterDeclaration(CodeGenerationOptions options, Func`2<SyntaxList`1<TDeclaration>, TDeclaration> next);
    private static Func`2<SyntaxList`1<TDeclaration>, TDeclaration> BeforeDeclaration(CodeGenerationOptions options, Func`2<SyntaxList`1<TDeclaration>, TDeclaration> next);
    public static SyntaxList`1<TDeclaration> Insert(SyntaxList`1<TDeclaration> declarationList, TDeclaration declaration, CodeGenerationOptions options, IList`1<bool> availableIndices, Func`2<SyntaxList`1<TDeclaration>, TDeclaration> after, Func`2<SyntaxList`1<TDeclaration>, TDeclaration> before);
    public static CodeGenerationDestination GetDestination(SyntaxNode destination);
    public static TSyntaxNode ConditionallyAddDocumentationCommentTo(TSyntaxNode node, ISymbol symbol, CodeGenerationOptions options, CancellationToken cancellationToken);
    public static T GetReuseableSyntaxNodeForSymbol(ISymbol symbol, CodeGenerationOptions options);
}
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.VisualBasicCodeGenerationService : AbstractCodeGenerationService {
    public VisualBasicCodeGenerationService(HostLanguageServices provider);
    public virtual CodeGenerationDestination GetDestination(SyntaxNode containerNode);
    protected virtual IComparer`1<SyntaxNode> GetMemberComparer();
    protected virtual IList`1<bool> GetAvailableInsertionIndices(SyntaxNode destination, CancellationToken cancellationToken);
    private static IList`1<bool> GetAvailableInsertionIndices(CompilationUnitSyntax destination, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddEvent(TDeclarationNode destinationType, IEventSymbol event, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected virtual TDeclarationNode AddField(TDeclarationNode destinationType, IFieldSymbol field, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected virtual TDeclarationNode AddProperty(TDeclarationNode destinationType, IPropertySymbol property, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected virtual TDeclarationNode AddMethod(TDeclarationNode destination, IMethodSymbol method, CodeGenerationOptions options, IList`1<bool> availableIndices);
    protected virtual TDeclarationNode AddNamedType(TDeclarationNode destination, INamedTypeSymbol namedType, CodeGenerationOptions options, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddNamespace(TDeclarationNode destination, INamespaceSymbol namespace, CodeGenerationOptions options, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    public virtual TDeclarationNode AddParameters(TDeclarationNode destinationMember, IEnumerable`1<IParameterSymbol> parameters, CodeGenerationOptions options, CancellationToken cancellationToken);
    protected virtual TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<SyntaxNode> members);
    private static TDeclarationNode AddParametersToMethod(MethodBaseSyntax methodStatement, MethodBlockBaseSyntax methodBlock, IEnumerable`1<IParameterSymbol> parameters, CodeGenerationOptions options);
    private static TDeclarationNode AddParametersToProperty(PropertyBlockSyntax propertyBlock, IEnumerable`1<IParameterSymbol> parameters, CodeGenerationOptions options);
    private static ParameterListSyntax AddParameters(ParameterListSyntax parameterList, IEnumerable`1<IParameterSymbol> parameters, CodeGenerationOptions options);
    public virtual TDeclarationNode AddAttributes(TDeclarationNode destination, IEnumerable`1<AttributeData> attributes, Nullable`1<SyntaxToken> target, CodeGenerationOptions options, CancellationToken cancellationToken);
    public virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, AttributeData attributeToRemove, CodeGenerationOptions options, CancellationToken cancellationToken);
    public virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, SyntaxNode attributeToRemove, CodeGenerationOptions options, CancellationToken cancellationToken);
    private static SyntaxList`1<AttributeListSyntax> RemoveAttributeFromAttributeLists(SyntaxList`1<AttributeListSyntax> attributeLists, SyntaxNode attributeToRemove, Boolean& attributeRemoved, Int32& positionOfRemovedNode, SyntaxTriviaList& triviaOfRemovedNode);
    private static SyntaxList`1<AttributesStatementSyntax> RemoveAttributeFromAttributeStatements(SyntaxList`1<AttributesStatementSyntax> attributeStatements, SyntaxNode attributeToRemove, Boolean& attributeRemoved, Int32& positionOfRemovedNode, SyntaxTriviaList& triviaOfRemovedNode);
    private static void VerifyAttributeRemoved(bool attributeRemoved);
    public virtual TDeclarationNode AddStatements(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, CodeGenerationOptions options, CancellationToken cancellationToken);
    private static TDeclarationNode AddStatementsWorker(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, CodeGenerationOptions options, CancellationToken cancellationToken);
    public virtual SyntaxNode CreateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationOptions options);
    public virtual SyntaxNode CreateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationOptions options);
    public virtual SyntaxNode CreateFieldDeclaration(IFieldSymbol field, CodeGenerationDestination destination, CodeGenerationOptions options);
    public virtual SyntaxNode CreatePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationOptions options);
    public virtual SyntaxNode CreateNamedTypeDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CodeGenerationOptions options, CancellationToken cancellationToken);
    public virtual SyntaxNode CreateNamespaceDeclaration(INamespaceSymbol namespace, CodeGenerationDestination destination, CodeGenerationOptions options, CancellationToken cancellationToken);
    private static TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, Func`2<SyntaxTokenList, SyntaxTokenList> computeNewModifiersList);
    public virtual TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, IEnumerable`1<SyntaxToken> newModifiers, CodeGenerationOptions options, CancellationToken cancellationToken);
    public virtual TDeclarationNode UpdateDeclarationAccessibility(TDeclarationNode declaration, Accessibility newAccessibility, CodeGenerationOptions options, CancellationToken cancellationToken);
    private static SyntaxTokenList UpdateDeclarationAccessibility(SyntaxTokenList modifiersList, Accessibility newAccessibility, CodeGenerationOptions options);
    private static SimpleAsClauseSyntax UpdateSimpleAsClause(SimpleAsClauseSyntax asClause, ITypeSymbol newType);
    private static AsClauseSyntax UpdateAsClause(AsClauseSyntax asClause, ITypeSymbol newType);
    public virtual TDeclarationNode UpdateDeclarationType(TDeclarationNode declaration, ITypeSymbol newType, CodeGenerationOptions options, CancellationToken cancellationToken);
    public virtual TDeclarationNode UpdateDeclarationMembers(TDeclarationNode declaration, IList`1<ISymbol> newMembers, CodeGenerationOptions options, CancellationToken cancellationToken);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.VisualBasicCodeGenerationServiceFactory : object {
    public sealed virtual override ILanguageService CreateLanguageService(HostLanguageServices provider);
}
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.VisualBasicDeclarationComparer : object {
    private static Dictionary`2<SyntaxKind, int> s_kindPrecedenceMap;
    private static Dictionary`2<SyntaxKind, int> s_operatorPrecedenceMap;
    public static VisualBasicDeclarationComparer WithNamesInstance;
    public static VisualBasicDeclarationComparer WithoutNamesInstance;
    private bool _includeName;
    private static VisualBasicDeclarationComparer();
    private VisualBasicDeclarationComparer(bool includeName);
    public sealed virtual override int Compare(SyntaxNode x, SyntaxNode y);
    private static SyntaxNode ConvertBlockToStatement(SyntaxNode node);
    private int Compare(DelegateStatementSyntax x, DelegateStatementSyntax y);
    private int Compare(FieldDeclarationSyntax x, FieldDeclarationSyntax y);
    private static int Compare(SubNewStatementSyntax x, SubNewStatementSyntax y);
    private int Compare(MethodStatementSyntax x, MethodStatementSyntax y);
    private int Compare(EventStatementSyntax x, EventStatementSyntax y);
    private int Compare(PropertyStatementSyntax x, PropertyStatementSyntax y);
    private static int Compare(OperatorStatementSyntax x, OperatorStatementSyntax y);
    private int Compare(EnumStatementSyntax x, EnumStatementSyntax y);
    private int Compare(TypeStatementSyntax x, TypeStatementSyntax y);
    private static bool NeitherNull(object x, object y, Int32& comparisonResult);
    private static bool ContainsToken(IEnumerable`1<SyntaxToken> list, SyntaxKind kind);
    private static int GetAccessibilityPrecedence(SyntaxNode declaration, IEnumerable`1<SyntaxToken> modifiers);
    private static bool BothHaveModifier(SyntaxTokenList x, SyntaxTokenList y, SyntaxKind modifierKind, Int32& comparisonResult);
    private static bool EqualSharedness(SyntaxTokenList x, SyntaxTokenList y, Int32& comparisonResult);
    private static bool EqualReadOnlyness(SyntaxTokenList x, SyntaxTokenList y, Int32& comparisonResult);
    private static bool EqualConstness(SyntaxTokenList x, SyntaxTokenList y, Int32& comparisonResult);
    private static bool EqualAccessibility(SyntaxNode x, SyntaxTokenList xModifiers, SyntaxNode y, SyntaxTokenList yModifiers, Int32& comparisonResult);
    private static bool EqualIdentifierName(SyntaxToken x, SyntaxToken y, Int32& comparisonResult);
    private static bool EqualOperatorPrecedence(SyntaxToken x, SyntaxToken y, Int32& comparisonResult);
    private static bool EqualParameterLists(ParameterListSyntax x, ParameterListSyntax y, Int32& comparisonResult);
}
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.VisualBasicFlagsEnumGenerator : AbstractFlagsEnumGenerator {
    public static VisualBasicFlagsEnumGenerator Instance;
    private static SyntaxGenerator s_syntaxGeneratorInstance;
    private static VisualBasicFlagsEnumGenerator();
    protected virtual SyntaxNode CreateExplicitlyCastedLiteralValue(INamedTypeSymbol enumType, SpecialType underlyingSpecialType, object constantValue);
    protected virtual SyntaxGenerator GetSyntaxGenerator();
    protected virtual bool IsValidName(INamedTypeSymbol enumType, string name);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Editing.SyntaxGenerator", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.VisualBasicSyntaxGenerator : SyntaxGenerator {
    public static SyntaxGenerator Instance;
    [CompilerGeneratedAttribute]
private SyntaxTrivia _ElasticCarriageReturnLineFeed;
    [CompilerGeneratedAttribute]
private SyntaxTrivia _CarriageReturnLineFeed;
    [CompilerGeneratedAttribute]
private bool _RequiresExplicitImplementationForInterfaceMembers;
    [CompilerGeneratedAttribute]
private SyntaxGeneratorInternal _SyntaxGeneratorInternal;
    private static DeclarationModifiers s_fieldModifiers;
    private static DeclarationModifiers s_methodModifiers;
    private static DeclarationModifiers s_constructorModifiers;
    private static DeclarationModifiers s_propertyModifiers;
    private static DeclarationModifiers s_indexerModifiers;
    private static DeclarationModifiers s_classModifiers;
    private static DeclarationModifiers s_structModifiers;
    private static DeclarationModifiers s_interfaceModifiers;
    private static DeclarationModifiers s_accessorModifiers;
    internal SyntaxTrivia ElasticCarriageReturnLineFeed { get; }
    internal SyntaxTrivia CarriageReturnLineFeed { get; }
    internal bool RequiresExplicitImplementationForInterfaceMembers { get; }
    internal SyntaxGeneratorInternal SyntaxGeneratorInternal { get; }
    private static VisualBasicSyntaxGenerator();
    [CompilerGeneratedAttribute]
internal virtual SyntaxTrivia get_ElasticCarriageReturnLineFeed();
    [CompilerGeneratedAttribute]
internal virtual SyntaxTrivia get_CarriageReturnLineFeed();
    [CompilerGeneratedAttribute]
internal virtual bool get_RequiresExplicitImplementationForInterfaceMembers();
    [CompilerGeneratedAttribute]
internal virtual SyntaxGeneratorInternal get_SyntaxGeneratorInternal();
    internal virtual SyntaxTrivia Whitespace(string text);
    internal virtual SyntaxTrivia SingleLineComment(string text);
    internal virtual SeparatedSyntaxList`1<TElement> SeparatedList(SyntaxNodeOrTokenList list);
    internal virtual SyntaxToken CreateInterpolatedStringStartToken(bool isVerbatim);
    internal virtual SyntaxToken CreateInterpolatedStringEndToken();
    internal virtual SeparatedSyntaxList`1<TElement> SeparatedList(IEnumerable`1<TElement> nodes, IEnumerable`1<SyntaxToken> separators);
    internal virtual SyntaxTrivia Trivia(SyntaxNode node);
    internal virtual SyntaxNode DocumentationCommentTrivia(IEnumerable`1<SyntaxNode> nodes, SyntaxTriviaList trailingTrivia, SyntaxTrivia lastWhitespaceTrivia, string endOfLineString);
    internal virtual SyntaxNode DocumentationCommentTriviaWithUpdatedContent(SyntaxTrivia trivia, IEnumerable`1<SyntaxNode> content);
    public virtual SyntaxNode AddEventHandler(SyntaxNode event, SyntaxNode handler);
    public virtual SyntaxNode RemoveEventHandler(SyntaxNode event, SyntaxNode handler);
    public virtual SyntaxNode AwaitExpression(SyntaxNode expression);
    public virtual SyntaxNode NameOfExpression(SyntaxNode expression);
    public virtual SyntaxNode TupleExpression(IEnumerable`1<SyntaxNode> arguments);
    private static ParenthesizedExpressionSyntax Parenthesize(SyntaxNode expression, bool addSimplifierAnnotation);
    public virtual SyntaxNode AddExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode Argument(string name, RefKind refKind, SyntaxNode expression);
    public virtual SyntaxNode TryCastExpression(SyntaxNode expression, SyntaxNode type);
    public virtual SyntaxNode AssignmentStatement(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode BaseExpression();
    public virtual SyntaxNode BitwiseAndExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode BitwiseOrExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode CastExpression(SyntaxNode type, SyntaxNode expression);
    public virtual SyntaxNode ConvertExpression(SyntaxNode type, SyntaxNode expression);
    public virtual SyntaxNode ConditionalExpression(SyntaxNode condition, SyntaxNode whenTrue, SyntaxNode whenFalse);
    public virtual SyntaxNode LiteralExpression(object value);
    public virtual SyntaxNode TypedConstantExpression(TypedConstant value);
    internal virtual SyntaxToken NumericLiteralToken(string text, ulong value);
    public virtual SyntaxNode DefaultExpression(ITypeSymbol type);
    public virtual SyntaxNode DefaultExpression(SyntaxNode type);
    public virtual SyntaxNode ElementAccessExpression(SyntaxNode expression, IEnumerable`1<SyntaxNode> arguments);
    public virtual SyntaxNode ExpressionStatement(SyntaxNode expression);
    public virtual SyntaxNode GenericName(string identifier, IEnumerable`1<SyntaxNode> typeArguments);
    internal virtual SyntaxNode GenericName(SyntaxToken identifier, IEnumerable`1<SyntaxNode> typeArguments);
    public virtual SyntaxNode IdentifierName(string identifier);
    public virtual SyntaxNode IfStatement(SyntaxNode condition, IEnumerable`1<SyntaxNode> trueStatements, IEnumerable`1<SyntaxNode> falseStatements);
    private SyntaxList`1<StatementSyntax> GetStatementList(IEnumerable`1<SyntaxNode> nodes);
    private StatementSyntax AsStatement(SyntaxNode node);
    public virtual SyntaxNode InvocationExpression(SyntaxNode expression, IEnumerable`1<SyntaxNode> arguments);
    public virtual SyntaxNode IsTypeExpression(SyntaxNode expression, SyntaxNode type);
    public virtual SyntaxNode TypeOfExpression(SyntaxNode type);
    public virtual SyntaxNode LogicalAndExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode LogicalNotExpression(SyntaxNode expression);
    public virtual SyntaxNode LogicalOrExpression(SyntaxNode left, SyntaxNode right);
    internal virtual SyntaxNode MemberAccessExpressionWorker(SyntaxNode expression, SyntaxNode simpleName);
    public virtual SyntaxNode ConditionalAccessExpression(SyntaxNode expression, SyntaxNode whenNotNull);
    public virtual SyntaxNode MemberBindingExpression(SyntaxNode name);
    public virtual SyntaxNode ElementBindingExpression(IEnumerable`1<SyntaxNode> arguments);
    private static ExpressionSyntax ParenthesizeLeft(SyntaxNode expression);
    public virtual SyntaxNode MultiplyExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode NegateExpression(SyntaxNode expression);
    private static SeparatedSyntaxList`1<ExpressionSyntax> AsExpressionList(IEnumerable`1<SyntaxNode> expressions);
    public virtual SyntaxNode ArrayCreationExpression(SyntaxNode elementType, SyntaxNode size);
    public virtual SyntaxNode ArrayCreationExpression(SyntaxNode elementType, IEnumerable`1<SyntaxNode> elements);
    public virtual SyntaxNode ObjectCreationExpression(SyntaxNode typeName, IEnumerable`1<SyntaxNode> arguments);
    internal virtual SyntaxNode ObjectCreationExpression(SyntaxNode typeName, SyntaxToken openParen, SeparatedSyntaxList`1<SyntaxNode> arguments, SyntaxToken closeParen);
    public virtual SyntaxNode QualifiedName(SyntaxNode left, SyntaxNode right);
    internal virtual SyntaxNode GlobalAliasedName(SyntaxNode name);
    public virtual SyntaxNode ReferenceEqualsExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ReferenceNotEqualsExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ReturnStatement(SyntaxNode expressionOpt);
    public virtual SyntaxNode ThisExpression();
    public virtual SyntaxNode ThrowStatement(SyntaxNode expressionOpt);
    public virtual SyntaxNode ThrowExpression(SyntaxNode expression);
    internal virtual bool SupportsThrowExpression();
    public virtual SyntaxNode NameExpression(INamespaceOrTypeSymbol namespaceOrTypeSymbol);
    public virtual SyntaxNode TypeExpression(ITypeSymbol typeSymbol);
    public virtual SyntaxNode TypeExpression(SpecialType specialType);
    public virtual SyntaxNode UsingStatement(SyntaxNode type, string identifier, SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode UsingStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode LockStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode ValueEqualsExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ValueNotEqualsExpression(SyntaxNode left, SyntaxNode right);
    private ArgumentListSyntax CreateArgumentList(IEnumerable`1<SyntaxNode> arguments);
    private SeparatedSyntaxList`1<ArgumentSyntax> CreateArguments(IEnumerable`1<SyntaxNode> arguments);
    private ArgumentSyntax AsArgument(SyntaxNode argOrExpression);
    private SimpleArgumentSyntax AsSimpleArgument(SyntaxNode argOrExpression);
    public virtual SyntaxNode LocalDeclarationStatement(SyntaxNode type, string identifier, SyntaxNode initializer, bool isConst);
    public virtual SyntaxNode SwitchStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> caseClauses);
    public virtual SyntaxNode SwitchSection(IEnumerable`1<SyntaxNode> expressions, IEnumerable`1<SyntaxNode> statements);
    internal virtual SyntaxNode SwitchSectionFromLabels(IEnumerable`1<SyntaxNode> labels, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode DefaultSwitchSection(IEnumerable`1<SyntaxNode> statements);
    private static SeparatedSyntaxList`1<CaseClauseSyntax> GetCaseClauses(IEnumerable`1<SyntaxNode> expressions);
    public virtual SyntaxNode ExitSwitchStatement();
    public virtual SyntaxNode ValueReturningLambdaExpression(IEnumerable`1<SyntaxNode> parameters, SyntaxNode expression);
    public virtual SyntaxNode VoidReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, SyntaxNode expression);
    public virtual SyntaxNode ValueReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode VoidReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode LambdaParameter(string identifier, SyntaxNode type);
    public virtual SyntaxNode ArrayTypeExpression(SyntaxNode type);
    public virtual SyntaxNode NullableTypeExpression(SyntaxNode type);
    internal virtual SyntaxNode CreateTupleType(IEnumerable`1<SyntaxNode> elements);
    public virtual SyntaxNode TupleElementExpression(SyntaxNode type, string name);
    public virtual SyntaxNode WithTypeArguments(SyntaxNode name, IEnumerable`1<SyntaxNode> typeArguments);
    public virtual SyntaxNode SubtractExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode DivideExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode ModuloExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode BitwiseNotExpression(SyntaxNode operand);
    public virtual SyntaxNode CoalesceExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode LessThanExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode LessThanOrEqualExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode GreaterThanExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode GreaterThanOrEqualExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode TryCatchStatement(IEnumerable`1<SyntaxNode> tryStatements, IEnumerable`1<SyntaxNode> catchClauses, IEnumerable`1<SyntaxNode> finallyStatements);
    public virtual SyntaxNode CatchClause(SyntaxNode type, string identifier, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode WhileStatement(SyntaxNode condition, IEnumerable`1<SyntaxNode> statements);
    internal virtual SyntaxNode ScopeBlock(IEnumerable`1<SyntaxNode> statements);
    internal virtual SyntaxNode ParseExpression(string stringToParse);
    private static DeclarationModifiers GetAllowedModifiers(SyntaxKind kind);
    public virtual SyntaxNode FieldDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, SyntaxNode initializer);
    public virtual SyntaxNode MethodDeclaration(string identifier, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<string> typeParameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode OperatorDeclaration(OperatorKind kind, IEnumerable`1<SyntaxNode> parameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> statements);
    private static SyntaxKind GetTokenKind(OperatorKind kind);
    private static ParameterListSyntax GetParameterList(IEnumerable`1<SyntaxNode> parameters);
    public virtual SyntaxNode ParameterDeclaration(string name, SyntaxNode type, SyntaxNode initializer, RefKind refKind);
    private static SyntaxTokenList GetParameterModifiers(RefKind refKind, SyntaxNode initializer);
    public virtual SyntaxNode GetAccessorDeclaration(Accessibility accessibility, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode SetAccessorDeclaration(Accessibility accessibility, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode WithAccessorDeclarations(SyntaxNode declaration, IEnumerable`1<SyntaxNode> accessorDeclarations);
    private static PropertyBlockSyntax GetPropertyBlock(SyntaxNode declaration);
    public virtual SyntaxNode PropertyDeclaration(string identifier, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    public virtual SyntaxNode IndexerDeclaration(IEnumerable`1<SyntaxNode> parameters, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    private AccessorBlockSyntax AccessorBlock(SyntaxKind kind, IEnumerable`1<SyntaxNode> statements, SyntaxNode type);
    private AccessorBlockSyntax CreateGetAccessorBlock(IEnumerable`1<SyntaxNode> statements);
    private AccessorBlockSyntax CreateSetAccessorBlock(SyntaxNode type, IEnumerable`1<SyntaxNode> statements);
    private AccessorBlockSyntax CreateAddHandlerAccessorBlock(SyntaxNode delegateType, IEnumerable`1<SyntaxNode> statements);
    private AccessorBlockSyntax CreateRemoveHandlerAccessorBlock(SyntaxNode delegateType, IEnumerable`1<SyntaxNode> statements);
    private AccessorBlockSyntax CreateRaiseEventAccessorBlock(IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode AsPublicInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceTypeName, string interfaceMemberName);
    private SyntaxNode AsPublicInterfaceImplementationInternal(SyntaxNode declaration, SyntaxNode interfaceTypeName, string interfaceMemberName);
    public virtual SyntaxNode AsPrivateInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceTypeName, string interfaceMemberName);
    private SyntaxNode AsPrivateInterfaceImplementationInternal(SyntaxNode declaration, SyntaxNode interfaceTypeName, string interfaceMemberName);
    private string GetInterfaceMemberName(SyntaxNode declaration);
    private static ImplementsClauseSyntax GetImplementsClause(SyntaxNode declaration);
    private static SyntaxNode WithImplementsClause(SyntaxNode declaration, ImplementsClauseSyntax clause);
    private string GetNameAsIdentifier(SyntaxNode type);
    private SyntaxNode WithBody(SyntaxNode declaration, bool allowDefault);
    private static bool GetIsDefault(SyntaxTokenList modifierList);
    private SyntaxTokenList WithIsDefault(SyntaxTokenList modifierList, bool isDefault, SyntaxNode declaration);
    public virtual SyntaxNode ConstructorDeclaration(string name, IEnumerable`1<SyntaxNode> parameters, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> baseConstructorArguments, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode ClassDeclaration(string name, IEnumerable`1<string> typeParameters, Accessibility accessibility, DeclarationModifiers modifiers, SyntaxNode baseType, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    private SyntaxList`1<StatementSyntax> AsClassMembers(IEnumerable`1<SyntaxNode> nodes);
    private StatementSyntax AsClassMember(SyntaxNode node);
    public virtual SyntaxNode StructDeclaration(string name, IEnumerable`1<string> typeParameters, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    public virtual SyntaxNode InterfaceDeclaration(string name, IEnumerable`1<string> typeParameters, Accessibility accessibility, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    private SyntaxList`1<StatementSyntax> AsInterfaceMembers(IEnumerable`1<SyntaxNode> nodes);
    internal virtual SyntaxNode AsInterfaceMember(SyntaxNode node);
    public virtual SyntaxNode EnumDeclaration(string name, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> members);
    internal virtual SyntaxNode EnumDeclaration(string name, SyntaxNode underlyingType, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> members);
    public virtual SyntaxNode EnumMember(string name, SyntaxNode expression);
    private SyntaxList`1<StatementSyntax> AsEnumMembers(IEnumerable`1<SyntaxNode> nodes);
    private StatementSyntax AsEnumMember(SyntaxNode node);
    public virtual SyntaxNode DelegateDeclaration(string name, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<string> typeParameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers);
    public virtual SyntaxNode CompilationUnit(IEnumerable`1<SyntaxNode> declarations);
    private SyntaxList`1<ImportsStatementSyntax> AsImports(IEnumerable`1<SyntaxNode> declarations);
    private SyntaxNode AsNamespaceImport(SyntaxNode node);
    private static SyntaxList`1<StatementSyntax> AsNamespaceMembers(IEnumerable`1<SyntaxNode> declarations);
    public virtual SyntaxNode NamespaceImportDeclaration(SyntaxNode name);
    public virtual SyntaxNode AliasImportDeclaration(string aliasIdentifierName, SyntaxNode name);
    public virtual SyntaxNode NamespaceDeclaration(SyntaxNode name, IEnumerable`1<SyntaxNode> nestedDeclarations);
    public virtual SyntaxNode Attribute(SyntaxNode name, IEnumerable`1<SyntaxNode> attributeArguments);
    private ArgumentListSyntax AsArgumentList(IEnumerable`1<SyntaxNode> arguments);
    public virtual SyntaxNode AttributeArgument(string name, SyntaxNode expression);
    public virtual TNode ClearTrivia(TNode node);
    private SyntaxList`1<AttributeListSyntax> AsAttributeLists(IEnumerable`1<SyntaxNode> attributes);
    private AttributeListSyntax AsAttributeList(SyntaxNode node);
    private AttributeListSyntax WithNoTargets(AttributeListSyntax attrs);
    private static AttributeSyntax WithNoTarget(AttributeSyntax attr);
    internal virtual ImmutableArray`1<SyntaxNode> GetTypeInheritance(SyntaxNode declaration);
    public virtual IReadOnlyList`1<SyntaxNode> GetAttributes(SyntaxNode declaration);
    public virtual SyntaxNode InsertAttributes(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributes);
    private SyntaxNode InsertAttributesInternal(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributes);
    private static bool HasAssemblyTarget(AttributeSyntax attr);
    private AttributeListSyntax WithAssemblyTargets(AttributeListSyntax attrs);
    private AttributeSyntax WithAssemblyTarget(AttributeSyntax attr);
    public virtual IReadOnlyList`1<SyntaxNode> GetReturnAttributes(SyntaxNode declaration);
    public virtual SyntaxNode InsertReturnAttributes(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributes);
    private SyntaxNode InsertReturnAttributesInternal(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributes);
    private static SyntaxList`1<AttributeListSyntax> GetReturnAttributeLists(SyntaxNode declaration);
    private SyntaxNode WithReturnAttributeLists(SyntaxNode declaration, IEnumerable`1<AttributeListSyntax> lists);
    private SyntaxNode WithAttributeLists(SyntaxNode node, IEnumerable`1<AttributeListSyntax> lists);
    public virtual DeclarationKind GetDeclarationKind(SyntaxNode declaration);
    private static bool IsIndexer(SyntaxNode declaration);
    private static int GetDeclarationCount(SyntaxNode node);
    private static bool IsChildOf(SyntaxNode node, SyntaxKind kind);
    private static bool IsChildOfVariableDeclaration(SyntaxNode node);
    private SyntaxNode Isolate(SyntaxNode declaration, Func`2<SyntaxNode, SyntaxNode> editor);
    private SyntaxNode GetFullDeclaration(SyntaxNode declaration);
    private SyntaxNode AsIsolatedDeclaration(SyntaxNode declaration);
    private static SyntaxNode WithSingleVariable(SyntaxNode declaration, ModifiedIdentifierSyntax variable);
    public virtual string GetName(SyntaxNode declaration);
    public virtual SyntaxNode WithName(SyntaxNode declaration, string name);
    private SyntaxNode WithNameInternal(SyntaxNode declaration, string name);
    public virtual SyntaxNode GetType(SyntaxNode declaration);
    public virtual SyntaxNode WithType(SyntaxNode declaration, SyntaxNode type);
    private SyntaxNode WithTypeInternal(SyntaxNode declaration, SyntaxNode type);
    private static AsClauseSyntax GetAsClause(SyntaxNode declaration);
    private static SyntaxNode WithAsClause(SyntaxNode declaration, AsClauseSyntax asClause);
    private SyntaxNode AsFunction(SyntaxNode declaration);
    private SyntaxNode AsFunctionInternal(SyntaxNode declaration);
    private SyntaxNode AsSub(SyntaxNode declaration);
    private SyntaxNode AsSubInternal(SyntaxNode declaration);
    public virtual DeclarationModifiers GetModifiers(SyntaxNode declaration);
    private static void GetAccessibilityAndModifiers(SyntaxTokenList modifierTokens, Accessibility& accessibility, DeclarationModifiers& modifiers, Boolean& isDefault);
    private static SyntaxTokenList GetModifierTokens(SyntaxNode declaration);
    public virtual SyntaxNode WithModifiers(SyntaxNode declaration, DeclarationModifiers modifiers);
    private SyntaxNode WithModifiersInternal(SyntaxNode declaration, DeclarationModifiers modifiers);
    private SyntaxNode WithModifierTokens(SyntaxNode declaration, SyntaxTokenList tokens);
    public virtual Accessibility GetAccessibility(SyntaxNode declaration);
    public virtual SyntaxNode WithAccessibility(SyntaxNode declaration, Accessibility accessibility);
    private static bool CanHaveAccessibility(SyntaxNode declaration);
    private SyntaxNode WithAccessibilityInternal(SyntaxNode declaration, Accessibility accessibility);
    private static SyntaxTokenList GetModifierList(Accessibility accessibility, DeclarationModifiers modifiers, SyntaxNode declaration, DeclarationKind kind, bool isDefault);
    private static TypeParameterListSyntax GetTypeParameters(IEnumerable`1<string> typeParameterNames);
    public virtual SyntaxNode WithTypeParameters(SyntaxNode declaration, IEnumerable`1<string> typeParameterNames);
    private static SyntaxNode ReplaceTypeParameterList(SyntaxNode declaration, Func`2<TypeParameterListSyntax, TypeParameterListSyntax> replacer);
    internal virtual SyntaxNode WithExplicitInterfaceImplementations(SyntaxNode declaration, ImmutableArray`1<ISymbol> explicitInterfaceImplementations);
    private QualifiedNameSyntax GenerateInterfaceMember(ISymbol method);
    public virtual SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, IEnumerable`1<SyntaxNode> types);
    private static TypeParameterListSyntax WithTypeParameterConstraints(TypeParameterListSyntax typeParameterList, string typeParameterName, TypeParameterConstraintClauseSyntax clause);
    public virtual IReadOnlyList`1<SyntaxNode> GetParameters(SyntaxNode declaration);
    public virtual SyntaxNode InsertParameters(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> parameters);
    public virtual IReadOnlyList`1<SyntaxNode> GetSwitchSections(SyntaxNode switchStatement);
    public virtual SyntaxNode InsertSwitchSections(SyntaxNode switchStatement, int index, IEnumerable`1<SyntaxNode> switchSections);
    internal virtual SyntaxNode GetParameterListNode(SyntaxNode declaration);
    private SyntaxNode WithParameterList(SyntaxNode declaration, ParameterListSyntax list);
    public virtual SyntaxNode GetExpression(SyntaxNode declaration);
    private static ExpressionSyntax AsExpression(SyntaxNode node);
    public virtual SyntaxNode WithExpression(SyntaxNode declaration, SyntaxNode expression);
    private SyntaxNode WithExpressionInternal(SyntaxNode declaration, SyntaxNode expression);
    private static EqualsValueSyntax GetEqualsValue(SyntaxNode declaration);
    private static SyntaxNode WithEqualsValue(SyntaxNode declaration, EqualsValueSyntax ev);
    public virtual IReadOnlyList`1<SyntaxNode> GetNamespaceImports(SyntaxNode declaration);
    private static IReadOnlyList`1<SyntaxNode> GetUnflattenedNamespaceImports(SyntaxNode declaration);
    public virtual SyntaxNode InsertNamespaceImports(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> imports);
    private SyntaxNode InsertNamespaceImportsInternal(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> imports);
    public virtual IReadOnlyList`1<SyntaxNode> GetMembers(SyntaxNode declaration);
    private static IReadOnlyList`1<SyntaxNode> GetUnflattenedMembers(SyntaxNode declaration);
    private IEnumerable`1<StatementSyntax> AsMembersOf(SyntaxNode declaration, IEnumerable`1<SyntaxNode> members);
    public virtual SyntaxNode InsertMembers(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> members);
    private SyntaxNode InsertMembersInternal(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> members);
    public virtual IReadOnlyList`1<SyntaxNode> GetStatements(SyntaxNode declaration);
    public virtual SyntaxNode WithStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    private SyntaxNode WithStatementsInternal(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    public virtual IReadOnlyList`1<SyntaxNode> GetAccessors(SyntaxNode declaration);
    public virtual SyntaxNode InsertAccessors(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> accessors);
    internal static SyntaxList`1<AccessorBlockSyntax> GetAccessorList(SyntaxNode declaration);
    private static SyntaxNode WithAccessorList(SyntaxNode declaration, SyntaxList`1<AccessorBlockSyntax> accessorList);
    private static SyntaxList`1<AccessorBlockSyntax> AsAccessorList(IEnumerable`1<SyntaxNode> nodes, SyntaxKind parentKind);
    private static AccessorBlockSyntax AsAccessor(SyntaxNode node, SyntaxKind parentKind);
    private static bool CanHaveAccessors(SyntaxKind kind);
    public virtual IReadOnlyList`1<SyntaxNode> GetGetAccessorStatements(SyntaxNode declaration);
    public virtual SyntaxNode WithGetAccessorStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    public virtual IReadOnlyList`1<SyntaxNode> GetSetAccessorStatements(SyntaxNode declaration);
    public virtual SyntaxNode WithSetAccessorStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    private IReadOnlyList`1<SyntaxNode> GetAccessorStatements(SyntaxNode declaration, SyntaxKind kind);
    private SyntaxNode WithAccessorStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements, SyntaxKind kind);
    private static AccessorBlockSyntax GetAccessorBlock(SyntaxNode declaration, SyntaxKind kind);
    private SyntaxNode WithAccessorBlock(SyntaxNode declaration, SyntaxKind kind, AccessorBlockSyntax accessor);
    public virtual SyntaxNode EventDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers);
    public virtual SyntaxNode CustomEventDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<SyntaxNode> addAccessorStatements, IEnumerable`1<SyntaxNode> removeAccessorStatements);
    public SyntaxNode CustomEventDeclarationWithRaise(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<SyntaxNode> addAccessorStatements, IEnumerable`1<SyntaxNode> removeAccessorStatements, IEnumerable`1<SyntaxNode> raiseAccessorStatements);
    public virtual IReadOnlyList`1<SyntaxNode> GetAttributeArguments(SyntaxNode attributeDeclaration);
    public virtual SyntaxNode InsertAttributeArguments(SyntaxNode attributeDeclaration, int index, IEnumerable`1<SyntaxNode> attributeArguments);
    private SyntaxNode InsertAttributeArgumentsInternal(SyntaxNode attributeDeclaration, int index, IEnumerable`1<SyntaxNode> attributeArguments);
    private static ArgumentListSyntax GetArgumentList(SyntaxNode declaration);
    private static SyntaxNode WithArgumentList(SyntaxNode declaration, ArgumentListSyntax argumentList);
    public virtual IReadOnlyList`1<SyntaxNode> GetBaseAndInterfaceTypes(SyntaxNode declaration);
    public virtual SyntaxNode AddBaseType(SyntaxNode declaration, SyntaxNode baseType);
    public virtual SyntaxNode AddInterfaceType(SyntaxNode declaration, SyntaxNode interfaceType);
    private static SyntaxList`1<InheritsStatementSyntax> GetInherits(SyntaxNode declaration);
    private static SyntaxNode WithInherits(SyntaxNode declaration, SyntaxList`1<InheritsStatementSyntax> list);
    private static SyntaxList`1<ImplementsStatementSyntax> GetImplements(SyntaxNode declaration);
    private static SyntaxNode WithImplements(SyntaxNode declaration, SyntaxList`1<ImplementsStatementSyntax> list);
    public virtual SyntaxNode ReplaceNode(SyntaxNode root, SyntaxNode declaration, SyntaxNode newDeclaration);
    private bool AreInlineReplaceableSubDeclarations(SyntaxNode decl1, SyntaxNode decl2);
    private bool AreSimilarExceptForSubDeclarations(SyntaxNode decl1, SyntaxNode decl2);
    public virtual SyntaxNode InsertNodesBefore(SyntaxNode root, SyntaxNode declaration, IEnumerable`1<SyntaxNode> newDeclarations);
    private SyntaxNode InsertDeclarationsBeforeInternal(SyntaxNode root, SyntaxNode declaration, IEnumerable`1<SyntaxNode> newDeclarations);
    public virtual SyntaxNode InsertNodesAfter(SyntaxNode root, SyntaxNode declaration, IEnumerable`1<SyntaxNode> newDeclarations);
    private SyntaxNode InsertNodesAfterInternal(SyntaxNode root, SyntaxNode declaration, IEnumerable`1<SyntaxNode> newDeclarations);
    private IEnumerable`1<SyntaxNode> SplitAndInsert(SyntaxNode multiPartDeclaration, IReadOnlyList`1<SyntaxNode> subDeclarations, int index, IEnumerable`1<SyntaxNode> newDeclarations);
    private SyntaxNode ReplaceSubDeclaration(SyntaxNode root, SyntaxNode declaration, int index, SyntaxNode newDeclaration);
    private SyntaxNode WithSubDeclarationsRemoved(SyntaxNode declaration, int index, int count);
    private static IReadOnlyList`1<SyntaxNode> GetSubDeclarations(SyntaxNode declaration);
    private IReadOnlyList`1<SyntaxNode> Flatten(IReadOnlyList`1<SyntaxNode> members);
    private void Flatten(ArrayBuilder`1<SyntaxNode> builder, IReadOnlyList`1<SyntaxNode> members);
    public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode declaration);
    public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode declaration, SyntaxRemoveOptions options);
    private SyntaxNode RemoveNodeInternal(SyntaxNode root, SyntaxNode node, SyntaxRemoveOptions options);
    internal virtual SyntaxNode IdentifierName(SyntaxToken identifier);
    internal virtual SyntaxNode NamedAnonymousObjectMemberDeclarator(SyntaxNode identifier, SyntaxNode expression);
    internal virtual bool IsRegularOrDocComment(SyntaxTrivia trivia);
    internal virtual SyntaxNode RemoveAllComments(SyntaxNode node);
    internal virtual SyntaxTriviaList RemoveCommentLines(SyntaxTriviaList syntaxList);
    [CompilerGeneratedAttribute]
private string _Lambda$__159-0(TypeSyntax t);
    [CompilerGeneratedAttribute]
private AttributeListSyntax _Lambda$__204-0(AttributeListSyntax lst);
    [CompilerGeneratedAttribute]
private bool _Lambda$__318-0(SyntaxTrivia s);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeGeneration.VisualBasicSyntaxGeneratorInternal : SyntaxGeneratorInternal {
    public static SyntaxGeneratorInternal Instance;
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFacts;
    internal ISyntaxFacts SyntaxFacts { get; }
    private static VisualBasicSyntaxGeneratorInternal();
    [CompilerGeneratedAttribute]
internal virtual ISyntaxFacts get_SyntaxFacts();
    internal virtual SyntaxTrivia EndOfLine(string text);
    internal virtual SyntaxNode LocalDeclarationStatement(SyntaxNode type, SyntaxToken identifier, SyntaxNode initializer, bool isConst);
    internal virtual SyntaxNode WithInitializer(SyntaxNode variableDeclarator, SyntaxNode initializer);
    internal virtual SyntaxNode EqualsValueClause(SyntaxToken operatorToken, SyntaxNode value);
    internal static VariableDeclaratorSyntax VariableDeclarator(SyntaxNode type, ModifiedIdentifierSyntax name, SyntaxNode expression);
    internal virtual SyntaxToken Identifier(string text);
    internal virtual SyntaxNode ConditionalAccessExpression(SyntaxNode expression, SyntaxNode whenNotNull);
    internal virtual SyntaxNode MemberBindingExpression(SyntaxNode name);
    internal virtual SyntaxNode RefExpression(SyntaxNode expression);
    internal virtual SyntaxNode AddParentheses(SyntaxNode expression, bool includeElasticTrivia, bool addSimplifierAnnotation);
    internal static ParenthesizedExpressionSyntax Parenthesize(SyntaxNode expression, bool addSimplifierAnnotation);
    internal virtual SyntaxNode YieldReturnStatement(SyntaxNode expression);
    internal virtual bool RequiresLocalDeclarationType();
    internal virtual SyntaxNode InterpolatedStringExpression(SyntaxToken startToken, IEnumerable`1<SyntaxNode> content, SyntaxToken endToken);
    internal virtual SyntaxNode InterpolatedStringText(SyntaxToken textToken);
    internal virtual SyntaxToken InterpolatedStringTextToken(string content, string value);
    internal virtual SyntaxNode Interpolation(SyntaxNode syntaxNode);
    internal virtual SyntaxNode InterpolationAlignmentClause(SyntaxNode alignment);
    internal virtual SyntaxNode InterpolationFormatClause(string format);
    internal virtual SyntaxNode TypeParameterList(IEnumerable`1<string> typeParameterNames);
    internal virtual SyntaxNode Type(ITypeSymbol typeSymbol, bool typeContext);
    internal virtual bool SupportsPatterns(ParseOptions options);
    internal virtual SyntaxNode IsPatternExpression(SyntaxNode expression, SyntaxToken isToken, SyntaxNode pattern);
    internal virtual SyntaxNode ConstantPattern(SyntaxNode expression);
    internal virtual SyntaxNode DeclarationPattern(INamedTypeSymbol type, string name);
    internal virtual SyntaxNode AndPattern(SyntaxNode left, SyntaxNode right);
    internal virtual SyntaxNode NotPattern(SyntaxNode pattern);
    internal virtual SyntaxNode OrPattern(SyntaxNode left, SyntaxNode right);
    internal virtual SyntaxNode ParenthesizedPattern(SyntaxNode pattern);
    internal virtual SyntaxNode TypePattern(SyntaxNode type);
}
internal class Microsoft.CodeAnalysis.VisualBasic.CodeStyle.VisualBasicCodeStyleOptionGroups : object {
    public static OptionGroup Modifier;
    public static OptionGroup ExpressionLevelPreferences;
    private static VisualBasicCodeStyleOptionGroups();
}
internal class Microsoft.CodeAnalysis.VisualBasic.CodeStyle.VisualBasicCodeStyleOptions : object {
    private static Builder<IOption2> s_allOptionsBuilder;
    [CompilerGeneratedAttribute]
private static ImmutableArray`1<IOption2> _AllOptions;
    public static ImmutableArray`1<SyntaxKind> PreferredModifierOrderDefault;
    public static Option2`1<CodeStyleOption2`1<string>> PreferredModifierOrder;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferIsNotExpression;
    public static Option2`1<CodeStyleOption2`1<bool>> PreferSimplifiedObjectCreation;
    public static Option2`1<CodeStyleOption2`1<UnusedValuePreference>> UnusedValueExpressionStatement;
    public static Option2`1<CodeStyleOption2`1<UnusedValuePreference>> UnusedValueAssignment;
    public static ImmutableArray`1<IOption2> AllOptions { get; }
    private static VisualBasicCodeStyleOptions();
    private static Option2`1<T> CreateOption(OptionGroup group, string name, T defaultValue, OptionStorageLocation2 storageLocation);
    private static Option2`1<T> CreateOption(OptionGroup group, string name, T defaultValue, OptionStorageLocation2 storageLocation1, OptionStorageLocation2 storageLocation2);
    private static Option2`1<CodeStyleOption2`1<bool>> CreateOption(OptionGroup group, string name, CodeStyleOption2`1<bool> defaultValue, string editorconfigKeyName, string roamingProfileStorageKeyName);
    private static Option2`1<CodeStyleOption2`1<string>> CreateOption(OptionGroup group, string name, CodeStyleOption2`1<string> defaultValue, string editorconfigKeyName, string roamingProfileStorageKeyName);
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<IOption2> get_AllOptions();
}
[ExportOptionProviderAttribute("Visual Basic")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.CodeStyle.VisualBasicCodeStyleOptionsProvider : object {
    public ImmutableArray`1<IOption> Options { get; }
    public sealed virtual override ImmutableArray`1<IOption> get_Options();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Diagnostics.IDiagnosticPropertiesService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Diagnostics.VisualBasicDiagnosticPropertiesService : AbstractDiagnosticPropertiesService {
    private static Compilation s_compilation;
    private static VisualBasicDiagnosticPropertiesService();
    protected virtual Compilation GetCompilation();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Editing.ImportAdderService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Editing.VisualBasicImportAdder : ImportAdderService {
    protected virtual INamespaceSymbol GetExplicitNamespaceSymbol(SyntaxNode node, SemanticModel model);
    protected virtual void AddPotentiallyConflictingImports(SemanticModel model, SyntaxNode container, ImmutableArray`1<INamespaceSymbol> namespaceSymbols, HashSet`1<INamespaceSymbol> conflicts, CancellationToken cancellationToken);
    private static INamespaceSymbol GetExplicitNamespaceSymbol(ExpressionSyntax fullName, ExpressionSyntax namespacePart, SemanticModel model);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.EmbeddedLanguages.LanguageServices.IEmbeddedLanguagesProvider", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.EmbeddedLanguages.LanguageServices.VisualBasicEmbeddedLanguagesProvider : AbstractEmbeddedLanguagesProvider {
    public static EmbeddedLanguageInfo Info;
    private static VisualBasicEmbeddedLanguagesProvider();
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.IVirtualCharLanguageService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.EmbeddedLanguages.VirtualChars.VisualBasicVirtualCharLanguageServiceFactory : object {
    public sealed virtual override ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
internal class Microsoft.CodeAnalysis.VisualBasic.EmbeddedLanguages.VirtualChars.VisualBasicVirtualCharService : AbstractVirtualCharService {
    public static IVirtualCharService Instance;
    private static VisualBasicVirtualCharService();
    public virtual bool TryGetEscapeCharacter(VirtualChar ch, Char& escapedChar);
    protected virtual bool IsStringOrCharLiteralToken(SyntaxToken token);
    protected virtual VirtualCharSequence TryConvertToVirtualCharsWorker(SyntaxToken token);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.ArgumentListSyntaxExtensions : object {
    [ExtensionAttribute]
public static int GetArgumentCount(ArgumentListSyntax argumentList);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.ArgumentSyntaxExtensions : object {
    [ExtensionAttribute]
public static ITypeSymbol DetermineType(ArgumentSyntax argument, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IParameterSymbol DetermineParameter(ArgumentSyntax argument, SemanticModel semanticModel, bool allowParamArray, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ExpressionSyntax GetArgumentExpression(ArgumentSyntax argument);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.CallStatementSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool CanRemoveCallKeyword(CallStatementSyntax callStatement);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.CastAnalyzer : object {
    private ExpressionSyntax _castNode;
    private ExpressionSyntax _castExpressionNode;
    private SemanticModel _semanticModel;
    private bool _assumeCallKeyword;
    private CancellationToken _cancellationToken;
    private CastAnalyzer(ExpressionSyntax castNode, ExpressionSyntax castExpressionNode, SemanticModel semanticModel, bool assumeCallKeyword, CancellationToken cancellationToken);
    private bool CastPassedToParamArrayDefinitelyCantBeRemoved(ITypeSymbol castType);
    private static ITypeSymbol GetOuterCastType(ExpressionSyntax expression, TypeInfo expressionTypeInfo, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static Conversion GetSpeculatedExpressionToOuterTypeConversion(SpeculationAnalyzer speculationAnalyzer, ExpressionSyntax speculatedExpression, ExpressionSyntax outerSpeculatedExpression, CancellationToken cancellationToken, ITypeSymbol& speculatedExpressionOuterType);
    private static ITypeSymbol AsTypeInVariableDeclarator(SyntaxNode node, SemanticModel semanticModel);
    private bool IsStartOfExecutableStatement();
    private bool ExpressionCanStartExecutableStatement();
    private bool IsUnnecessary();
    private static bool HaveSameUserDefinedConversion(Conversion conversion1, Conversion conversion2);
    private static bool UserDefinedConversionIsAllowed(ExpressionSyntax expression);
    private static bool IsRequiredWideningNumericConversion(ITypeSymbol sourceType, ITypeSymbol destinationType);
    private static bool CastRemovalChangesDefaultValue(ITypeSymbol castType, ITypeSymbol outerType);
    public static bool IsUnnecessary(ExpressionSyntax castNode, ExpressionSyntax castExpressionNode, SemanticModel semanticModel, bool assumeCallKeyword, CancellationToken cancellationToken);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.CastExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static ExpressionSyntax Uncast(CastExpressionSyntax cast);
    [ExtensionAttribute]
public static ExpressionSyntax Uncast(PredefinedCastExpressionSyntax cast);
    private static ExpressionSyntax Uncast(ExpressionSyntax castNode, ExpressionSyntax innerNode);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.CompilationUnitSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool CanAddImportsStatements(SyntaxNode contextNode, Document document, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool CanAddImportsStatements(SyntaxNode contextNode, bool allowInHiddenRegions, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static CompilationUnitSyntax AddImportsStatement(CompilationUnitSyntax root, ImportsStatementSyntax importStatement, bool placeSystemNamespaceFirst, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static CompilationUnitSyntax AddImportsStatements(CompilationUnitSyntax root, IList`1<ImportsStatementSyntax> importsStatements, bool placeSystemNamespaceFirst, SyntaxAnnotation[] annotations);
    private static List`1<ImportsStatementSyntax> AddImportsStatements(CompilationUnitSyntax root, IList`1<ImportsStatementSyntax> importsStatements);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.IsStatementTerminatingTokenVisitor : VisualBasicSyntaxVisitor`1<bool> {
    private SyntaxToken _targetToken;
    public IsStatementTerminatingTokenVisitor(SyntaxToken targetToken);
    public virtual bool DefaultVisit(SyntaxNode node);
    public virtual bool VisitAddRemoveHandlerStatement(AddRemoveHandlerStatementSyntax node);
    public virtual bool VisitAssignmentStatement(AssignmentStatementSyntax node);
    public virtual bool VisitCallStatement(CallStatementSyntax node);
    public virtual bool VisitExpressionStatement(ExpressionStatementSyntax node);
    public virtual bool VisitContinueStatement(ContinueStatementSyntax node);
    public virtual bool VisitEraseStatement(EraseStatementSyntax node);
    public virtual bool VisitErrorStatement(ErrorStatementSyntax node);
    public virtual bool VisitExitStatement(ExitStatementSyntax node);
    public virtual bool VisitGoToStatement(GoToStatementSyntax node);
    public virtual bool VisitLocalDeclarationStatement(LocalDeclarationStatementSyntax node);
    public virtual bool VisitRaiseEventStatement(RaiseEventStatementSyntax node);
    public virtual bool VisitReDimStatement(ReDimStatementSyntax node);
    public virtual bool VisitResumeStatement(ResumeStatementSyntax node);
    public virtual bool VisitReturnStatement(ReturnStatementSyntax node);
    public virtual bool VisitStopOrEndStatement(StopOrEndStatementSyntax node);
    public virtual bool VisitThrowStatement(ThrowStatementSyntax node);
    private bool TargetTokenMatches(SyntaxToken token);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTokenExtensions : object {
    [ExtensionAttribute]
internal static bool HasColonBeforePosition(SyntaxToken token, int position);
    private static bool CheckTrivia(SyntaxTriviaList triviaList, int position, Boolean& checkForSecondEol, Boolean& allowsImplicitLineContinuation);
    [ExtensionAttribute]
internal static bool HasNonContinuableEndOfLineBeforePosition(SyntaxToken token, int position, bool checkForSecondEol);
    [ExtensionAttribute]
internal static bool FollowsBadEndDirective(SyntaxToken targetToken);
    [ExtensionAttribute]
internal static bool FollowsEndOfStatement(SyntaxToken token, int position);
    [ExtensionAttribute]
internal static bool MustBeginNewStatement(SyntaxToken token, int position);
    [ExtensionAttribute]
internal static bool IsMandatoryNamedParameterPosition(SyntaxToken token);
    [ExtensionAttribute]
internal static bool IsModifier(SyntaxToken token);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.SyntaxTreeExtensions : object {
    private static SyntaxKind[] s_multilineStatementBlockStartKinds;
    private static SyntaxTreeExtensions();
    [ExtensionAttribute]
internal static SyntaxToken GetTargetToken(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPreProcessorKeywordContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPreProcessorKeywordContext(SyntaxTree syntaxTree, int position, SyntaxToken preProcessorTokenOnLeftOfPosition, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsNamespaceContext(SyntaxTree syntaxTree, int position, SyntaxToken token, CancellationToken cancellationToken, SemanticModel semanticModelOpt);
    [ExtensionAttribute]
public static bool IsNamespaceDeclarationNameContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsPartialTypeDeclarationNameContext(SyntaxTree tree, int position, CancellationToken cancellationToken, TypeStatementSyntax& statementSyntax);
    [ExtensionAttribute]
public static TypeBlockSyntax GetContainingTypeBlock(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsTypeDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxToken token, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsDeclarationContextWithinTypeBlocks(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, bool allowAfterModifiersOrDim, CancellationToken cancellationToken, SyntaxKind[] allowedParentBlocks);
    private static bool IsDimOrModifierOrAttributeList(SyntaxToken token);
    [ExtensionAttribute]
internal static bool IsTypeMemberDeclarationKeywordContext(SyntaxTree syntaxTree, int position, SyntaxToken token, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsInterfaceMemberDeclarationKeywordContext(SyntaxTree syntaxTree, int position, SyntaxToken token, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsTypeDeclarationKeywordContext(SyntaxTree syntaxTree, int position, SyntaxToken token, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsFieldNameDeclarationContext(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsParameterNameDeclarationContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsLabelContext(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsEnumMemberNameContext(SyntaxTree syntaxTree, VisualBasicSyntaxContext context);
    [ExtensionAttribute]
public static bool IsDelegateCreationContext(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsExpressionContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, SemanticModel semanticModelOpt);
    [ExtensionAttribute]
internal static bool IsExpressionContext(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, CancellationToken cancellationToken, SemanticModel semanticModelOpt);
    [ExtensionAttribute]
public static bool IsAttributeNameContext(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken token, CancellationToken cancellationToken, SemanticModel semanticModelOpt);
    private static void PositionOutsideTupleIfApplicable(SyntaxTree syntaxTree, Int32& position, SyntaxToken& token, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsNameOfContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsSingleLineStatementContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsSingleLineStatementContext(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsMultiLineStatementStartContext(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsStartOfSelectCaseBlock(SyntaxTree syntaxTree, int position, SyntaxToken token, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsAfterStatementOfKind(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, CancellationToken cancellationToken, SyntaxKind[] kinds);
    [ExtensionAttribute]
internal static bool IsInStatementBlockOfKind(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, CancellationToken cancellationToken, SyntaxKind[] kinds);
    [ExtensionAttribute]
public static bool IsQueryIntoClauseContext(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsRaiseEventContext(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsObjectCreationTypeContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsObjectCreationTypeContext(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsEnumTypeMemberAccessContext(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsFollowingCompleteExpression(SyntaxTree syntaxTree, int position, SyntaxToken targetToken, Func`2<TParent, ExpressionSyntax> childGetter, CancellationToken cancellationToken, bool allowImplicitLineContinuation);
    internal static SyntaxToken GetExpressionTerminatingToken(SyntaxNode expression);
    private static SyntaxToken GetQueryClauseTerminatingToken(QueryClauseSyntax queryClause);
    [ExtensionAttribute]
internal static ExpressionSyntax LastCollectionExpression(SeparatedSyntaxList`1<CollectionRangeVariableSyntax> collection);
    [ExtensionAttribute]
internal static ExpressionSyntax LastRangeExpression(SeparatedSyntaxList`1<ExpressionRangeVariableSyntax> collection);
    [ExtensionAttribute]
internal static AggregationSyntax LastAggregation(SeparatedSyntaxList`1<AggregationRangeVariableSyntax> collection);
    [ExtensionAttribute]
internal static bool IsPossibleTupleContext(SyntaxTree syntaxTree, SyntaxToken tokenOnLeftOfPosition, int position);
    [ExtensionAttribute]
public static bool IsInPreprocessorExpressionContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.VisualBasicSyntaxContext : SyntaxContext {
    public bool FollowsEndOfStatement;
    public bool MustBeginNewStatement;
    public bool IsSingleLineStatementContext;
    public bool IsMultiLineStatementContext;
    public bool IsGlobalStatementContext;
    public bool IsTypeDeclarationKeywordContext;
    public bool IsTypeMemberDeclarationKeywordContext;
    public bool IsInterfaceMemberDeclarationKeywordContext;
    public ModifierCollectionFacts ModifierCollectionFacts;
    public bool IsPreprocessorStartContext;
    public bool IsInLambda;
    public bool IsQueryOperatorContext;
    public CancellableLazy`1<INamedTypeSymbol> EnclosingNamedType;
    public bool IsCustomEventContext;
    public bool IsPreprocessorEndDirectiveKeywordContext;
    public bool IsWithinPreprocessorContext;
    private VisualBasicSyntaxContext(Document document, SemanticModel semanticModel, int position, SyntaxToken leftToken, SyntaxToken targetToken, bool isTypeContext, bool isNamespaceContext, bool isNamespaceDeclarationNameContext, bool isPreProcessorDirectiveContext, bool isPreProcessorExpressionContext, bool isRightOfNameSeparator, bool isSingleLineStatementContext, bool isExpressionContext, bool isAttributeNameContext, bool isEnumTypeMemberAccessContext, bool isNameOfContext, bool isInLambda, bool isInQuery, bool isInImportsDirective, bool isCustomEventContext, bool isPossibleTupleContext, bool isInArgumentList, CancellationToken cancellationToken);
    private static bool IsWithinAsyncMethod(SyntaxToken targetToken);
    public static VisualBasicSyntaxContext CreateContext(Document document, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    internal virtual bool IsAwaitKeywordContext();
    private INamedTypeSymbol ComputeEnclosingNamedType(CancellationToken cancellationToken);
    private static bool ComputeIsWithinPreprocessorContext(int position, SyntaxToken targetToken);
    private static bool ComputeIsPreprocessorStartContext(int position, SyntaxToken targetToken);
    public bool IsFollowingParameterListOrAsClauseOfMethodDeclaration();
    public bool IsFollowingCompleteEventDeclaration();
    public bool IsFollowingCompletePropertyDeclaration(CancellationToken cancellationToken);
    public bool IsAdditionalJoinOperatorContext(CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.ISyntaxContextService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.VisualBasicSyntaxContextService : object {
    public sealed virtual override SyntaxContext CreateContext(Document document, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.ContextQuery.VisualBasicSyntaxTreeExtensions : object {
    [ExtensionAttribute]
internal static bool IsAccessibleEventContext(VisualBasicSyntaxContext context, bool startAtEnclosingBaseType, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static bool IsFollowingCompleteStatement(VisualBasicSyntaxContext context, Func`2<TParent, StatementSyntax> childGetter);
    [ExtensionAttribute]
internal static bool IsAfterStatementOfKind(VisualBasicSyntaxContext context, SyntaxKind[] kinds);
    [ExtensionAttribute]
internal static bool IsInStatementBlockOfKind(VisualBasicSyntaxContext context, SyntaxKind kind);
    [ExtensionAttribute]
internal static bool IsInStatementBlockOfKind(VisualBasicSyntaxContext context, SyntaxKind[] kinds);
    private static bool IsInStatementBlockHelper(VisualBasicSyntaxContext context, Func`3<SyntaxNode, TArg, bool> predicate, TArg arg);
    [ExtensionAttribute]
public static bool IsDelegateCreationContext(VisualBasicSyntaxContext context);
    [ExtensionAttribute]
public static bool CanDeclareCustomEventAccessor(VisualBasicSyntaxContext context, SyntaxKind accessorBlockKind);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.DirectiveSyntaxExtensions : object {
    private static ConditionalWeakTable`2<SyntaxNode, DirectiveInfo> s_rootToDirectiveInfo;
    private static DirectiveSyntaxExtensions();
    private static DirectiveInfo GetDirectiveInfo(SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static SyntaxNode GetAbsoluteRoot(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<DirectiveTriviaSyntax> GetStartDirectives(SyntaxTree syntaxTree, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static DirectiveTriviaSyntax GetMatchingStartOrEndDirective(DirectiveTriviaSyntax directive, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IReadOnlyList`1<DirectiveTriviaSyntax> GetMatchingConditionalDirectives(DirectiveTriviaSyntax directive, CancellationToken cancellationToken);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.ExpressionSyntaxExtensions : object {
    public static SymbolDisplayFormat typeNameFormatWithGenerics;
    public static SymbolDisplayFormat typeNameFormatWithoutGenerics;
    private static ExpressionSyntaxExtensions();
    [ExtensionAttribute]
public static ExpressionSyntax WalkUpParentheses(ExpressionSyntax expression);
    [ExtensionAttribute]
public static ExpressionSyntax WalkDownParentheses(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsLeftSideOfDot(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsNewOnRightSideOfDotOrBang(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsSimpleMemberAccessExpressionName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsAnyMemberAccessExpressionName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsRightSideOfDotOrBang(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsRightSideOfDot(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsRightSideOfQualifiedName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsLeftSideOfQualifiedName(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsAnyLiteralExpression(ExpressionSyntax expression);
    [ExtensionAttribute]
public static ITypeSymbol DetermineType(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static ITypeSymbol DetermineType(CollectionInitializerSyntax collectionInitializer, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsUnnecessaryCast(ExpressionSyntax castNode, ExpressionSyntax castExpressionNode, SemanticModel semanticModel, bool assumeCallKeyword, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsUnnecessaryCast(CastExpressionSyntax node, SemanticModel semanticModel, CancellationToken cancellationToken, bool assumeCallKeyword);
    [ExtensionAttribute]
public static bool IsUnnecessaryCast(PredefinedCastExpressionSyntax node, SemanticModel semanticModel, CancellationToken cancellationToken, bool assumeCallKeyword);
    [ExtensionAttribute]
public static OperatorPrecedence GetOperatorPrecedence(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsInOutContext(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsInRefContext(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsInInContext(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsOnlyWrittenTo(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsWrittenTo(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void DecomposeName(ExpressionSyntax expression, ExpressionSyntax& qualifier, String& name, Int32& arity);
    private static bool CanReplace(ISymbol symbol);
    [ExtensionAttribute]
public static bool CanReplaceWithRValue(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool CanReplaceWithLValue(ExpressionSyntax expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ParenthesizedExpressionSyntax Parenthesize(ExpressionSyntax expression, bool addSimplifierAnnotation);
    [ExtensionAttribute]
public static bool TryGetNameParts(ExpressionSyntax expression, IList`1& parts);
    [ExtensionAttribute]
public static bool TryGetNameParts(ExpressionSyntax expression, List`1<string> parts);
    private static bool AddSimpleName(SimpleNameSyntax simpleName, List`1<string> parts);
    [ExtensionAttribute]
public static ExpressionSyntax Cast(ExpressionSyntax expression, ITypeSymbol targetType, Boolean& isResultPredefinedCast);
    [ExtensionAttribute]
public static ExpressionSyntax CastIfPossible(ExpressionSyntax expression, ITypeSymbol targetType, int position, SemanticModel semanticModel, Boolean& wasCastAdded, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsObjectCreationWithoutArgumentList(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsMeMyBaseOrMyClass(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsFirstStatementInCtor(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsNamedArgumentIdentifier(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool ContainsImplicitMemberAccess(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool ContainsImplicitMemberAccess(StatementSyntax statement);
    [ExtensionAttribute]
public static IEnumerable`1<ExpressionSyntax> GetImplicitMemberAccessExpressions(SyntaxNode expression, TextSpan span);
    [ExtensionAttribute]
public static IEnumerable`1<ExpressionSyntax> GetImplicitMemberAccessExpressions(SyntaxNode expression);
    private static bool ContainsImplicitMemberAccessWorker(SyntaxNode expression);
    [ExtensionAttribute]
public static bool InsideCrefReference(ExpressionSyntax expression);
    [ExtensionAttribute]
public static bool IsDirectChildOfMemberAccessExpression(ExpressionSyntax expression);
    [ExtensionAttribute]
public static SimpleNameSyntax GetRightmostName(ExpressionSyntax node);
    [ExtensionAttribute]
public static bool IsNameOfArgumentExpression(ExpressionSyntax expression);
    public static bool IsReservedNameInAttribute(NameSyntax originalName, ExpressionSyntax simplifiedNode);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.ExpressionSyntaxGeneratorVisitor : SymbolVisitor`1<ExpressionSyntax> {
    private bool _addGlobal;
    public ExpressionSyntaxGeneratorVisitor(bool addGlobal);
    public virtual ExpressionSyntax DefaultVisit(ISymbol symbol);
    private static TExpressionSyntax AddInformationTo(TExpressionSyntax expression, ISymbol symbol);
    public virtual ExpressionSyntax VisitNamedType(INamedTypeSymbol symbol);
    public virtual ExpressionSyntax VisitNamespace(INamespaceSymbol symbol);
    private static ExpressionSyntax CreateMemberAccessExpression(ISymbol symbol, ExpressionSyntax container, SimpleNameSyntax simpleName);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.IMethodSymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsAggregateFunction(IMethodSymbol symbol);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.INamespaceOrTypeSymbolExtensions : object {
    [ExtensionAttribute]
public static TypeSyntax GenerateTypeSyntax(INamespaceOrTypeSymbol symbol, bool addGlobal);
    [ExtensionAttribute]
public static IAliasSymbol GetAliasForSymbol(INamespaceOrTypeSymbol symbol, SyntaxNode node, SemanticModel semanticModel);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.InvocationExpressionExtensions : object {
    [ExtensionAttribute]
public static bool CanRemoveEmptyArgumentList(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel);
    private static bool CanHaveOmittedArgumentList(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel);
    [ExtensionAttribute]
public static ExpressionSyntax GetExpression(InvocationExpressionSyntax invocationExpression);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.ITypeSymbolExtensions : object {
    [ExtensionAttribute]
public static ExpressionSyntax GenerateExpressionSyntax(ITypeSymbol typeSymbol);
    [ExtensionAttribute]
public static SyntaxKind GetPredefinedCastKeyword(SpecialType specialType);
    [ExtensionAttribute]
public static ITypeSymbol GetTypeFromPredefinedCastKeyword(Compilation compilation, SyntaxKind castKeyword);
    [ExtensionAttribute]
public static bool IsIntrinsicType(ITypeSymbol this);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.MemberAccessExpressionSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool IsConstructorInitializer(MemberAccessExpressionSyntax memberAccess);
    [ExtensionAttribute]
public static bool IsThisConstructorInitializer(MemberAccessExpressionSyntax memberAccess);
    [ExtensionAttribute]
public static bool IsBaseConstructorInitializer(MemberAccessExpressionSyntax memberAccess);
    private static bool IsFirstStatementInConstructor(MemberAccessExpressionSyntax memberAccess);
    [ExtensionAttribute]
public static ExpressionSyntax GetExpressionOfMemberAccessExpression(MemberAccessExpressionSyntax memberAccessExpression, bool allowImplicitTarget);
    [ExtensionAttribute]
public static SimpleNameSyntax GetNameWithTriviaMoved(MemberAccessExpressionSyntax memberAccess);
    private static SyntaxTriviaList GetLeadingTriviaForSimplifiedMemberAccess(MemberAccessExpressionSyntax memberAccess);
    private static IEnumerable`1<SyntaxTrivia> WithoutElasticTrivia(IEnumerable`1<SyntaxTrivia> list);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.NameSyntaxExtensions : object {
    [ExtensionAttribute]
public static IList`1<NameSyntax> GetNameParts(NameSyntax nameSyntax);
    [ExtensionAttribute]
public static NameSyntax GetLastDottedName(NameSyntax nameSyntax);
    [ExtensionAttribute]
public static bool CanBeReplacedWithAnyName(NameSyntax nameSyntax);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.ObjectCreationExpressionExtensions : object {
    [ExtensionAttribute]
public static bool CanRemoveEmptyArgumentList(ObjectCreationExpressionSyntax objectCreationExpression);
}
internal enum Microsoft.CodeAnalysis.VisualBasic.Extensions.OperatorPrecedence : Enum {
    public int value__;
    public static OperatorPrecedence PrecedenceNone;
    public static OperatorPrecedence PrecedenceXor;
    public static OperatorPrecedence PrecedenceOr;
    public static OperatorPrecedence PrecedenceAnd;
    public static OperatorPrecedence PrecedenceNot;
    public static OperatorPrecedence PrecedenceRelational;
    public static OperatorPrecedence PrecedenceShift;
    public static OperatorPrecedence PrecedenceConcatenate;
    public static OperatorPrecedence PrecedenceAdd;
    public static OperatorPrecedence PrecedenceModulus;
    public static OperatorPrecedence PrecedenceIntegerDivide;
    public static OperatorPrecedence PrecedenceMultiply;
    public static OperatorPrecedence PrecedenceNegate;
    public static OperatorPrecedence PrecedenceExponentiate;
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.ParameterSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool CanRemoveAsClause(ParameterSyntax parameter, SemanticModel semanticModel, CancellationToken cancellationToken);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.ParenthesizedExpressionSyntaxExtensions : object {
    private static bool EndsQuery(SyntaxToken token, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool EndsVariableDeclarator(SyntaxToken token);
    private static bool EndsLambda(SyntaxToken token);
    [ExtensionAttribute]
public static bool CanRemoveParentheses(ParenthesizedExpressionSyntax node, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsAssociative(SyntaxKind kind);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.SemanticModelExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, ArgumentListSyntax arguments, IEnumerable`1<string> reservedNames, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, IList`1<ArgumentSyntax> arguments, IEnumerable`1<string> reservedNames, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, IList`1<ArgumentSyntax> arguments, Func`2<string, bool> canUse, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ParameterName> GenerateParameterNames(SemanticModel semanticModel, IList`1<ArgumentSyntax> arguments, Func`2<string, bool> canUse, NamingRule parameterNamingRule, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static string GenerateNameForArgument(SemanticModel semanticModel, ArgumentSyntax argument, CancellationToken cancellationToken);
    private static string GenerateNameForArgumentWorker(SemanticModel semanticModel, ArgumentSyntax argument, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static string GenerateNameForExpression(SemanticModel semanticModel, ExpressionSyntax expression, bool capitalize, CancellationToken cancellationToken);
    private static string TryGenerateNameForArgumentExpression(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IList`1<ITypeSymbol> LookupTypeRegardlessOfArity(SemanticModel semanticModel, SyntaxToken name, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IList`1<ISymbol> LookupName(SemanticModel semanticModel, SyntaxToken name, bool namespacesAndTypesOnly, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IList`1<ISymbol> LookupName(SemanticModel semanticModel, ExpressionSyntax expression, bool namespacesAndTypesOnly, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, SyntaxToken token);
    [ExtensionAttribute]
public static ISet`1<INamespaceSymbol> GetImportNamespacesInScope(SemanticModel semanticModel, SyntaxNode location);
    [ExtensionAttribute]
public static IAliasSymbol GetAliasInfo(SemanticModel semanticModel, ExpressionSyntax expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Accessibility DetermineAccessibilityConstraint(SemanticModel semanticModel, TypeSyntax type, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Extensions.SemanticModelExtensions/VB$StateMachine_15_GetAliasSymbols")]
[ExtensionAttribute]
public static IEnumerable`1<IAliasSymbol> GetAliasSymbols(SemanticModel semanticModel);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.SimpleNameSyntaxExtensions : object {
    [ExtensionAttribute]
public static ExpressionSyntax GetLeftSideOfDot(SimpleNameSyntax name);
    [ExtensionAttribute]
public static bool LooksLikeStandaloneTypeName(SimpleNameSyntax simpleName);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.SingleLineRewriter : VisualBasicSyntaxRewriter {
    private static Regex s_newlinePattern;
    private bool _useElasticTrivia;
    private bool _lastTokenEndedInWhitespace;
    private static SingleLineRewriter();
    public SingleLineRewriter(bool useElasticTrivia);
    public virtual SyntaxToken VisitToken(SyntaxToken token);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.StatementSyntaxExtensions : object {
    [ExtensionAttribute]
public static SyntaxList`1<AttributeListSyntax> GetAttributes(StatementSyntax member);
    [ExtensionAttribute]
public static StatementSyntax WithAttributeLists(StatementSyntax member, SyntaxList`1<AttributeListSyntax> attributeLists);
    [ExtensionAttribute]
public static StatementSyntax AddAttributeLists(StatementSyntax member, AttributeListSyntax[] attributeLists);
    [ExtensionAttribute]
public static SyntaxTokenList GetModifiers(SyntaxNode member);
    [ExtensionAttribute]
public static TNode WithModifiers(TNode member, SyntaxTokenList modifiers);
    private static SyntaxNode WithModifiersHelper(SyntaxNode member, SyntaxTokenList modifiers);
    [ExtensionAttribute]
public static SyntaxToken GetNameToken(StatementSyntax member);
    [ExtensionAttribute]
public static SyntaxToken GetMemberKeywordToken(DeclarationStatementSyntax member);
    [ExtensionAttribute]
public static int GetArity(StatementSyntax member);
    [ExtensionAttribute]
public static TypeParameterListSyntax GetTypeParameterList(StatementSyntax member);
    [ExtensionAttribute]
public static ParameterListSyntax GetParameterList(StatementSyntax member);
    [ExtensionAttribute]
public static AsClauseSyntax GetAsClause(StatementSyntax member);
    [ExtensionAttribute]
public static TypeSyntax GetReturnType(StatementSyntax member);
    [ExtensionAttribute]
public static bool HasReturnType(StatementSyntax member);
    [ExtensionAttribute]
public static bool IsTopLevelDeclaration(StatementSyntax statement);
    [ExtensionAttribute]
public static bool IsTopLevelBlock(StatementSyntax statement);
    [ExtensionAttribute]
public static DeclarationStatementSyntax GetTopLevelBlockBegin(StatementSyntax statement);
    [ExtensionAttribute]
public static bool IsMemberDeclaration(StatementSyntax statement);
    [ExtensionAttribute]
public static bool IsMemberBlock(StatementSyntax statement);
    [ExtensionAttribute]
public static DeclarationStatementSyntax GetMemberBlockBegin(StatementSyntax statement);
    [ExtensionAttribute]
public static StatementSyntax GetPreviousStatement(StatementSyntax statement);
    [ExtensionAttribute]
public static StatementSyntax GetNextStatement(StatementSyntax statement);
    [ExtensionAttribute]
public static StatementSyntax GetNextNonEmptyStatement(StatementSyntax statement);
    [ExtensionAttribute]
public static bool IsConstructorInitializer(StatementSyntax statement);
}
[StandardModuleAttribute]
[ExtensionAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static bool TryReduceAttributeSuffix(string identifierText, String& withoutSuffix);
    [ExtensionAttribute]
public static string EscapeIdentifier(string text, bool afterDot, ISymbol symbol, bool withinAsyncMethod);
    [ExtensionAttribute]
public static SyntaxToken ToIdentifierToken(string text, bool afterDot, ISymbol symbol, bool withinAsyncMethod);
    [ExtensionAttribute]
public static ModifiedIdentifierSyntax ToModifiedIdentifier(string text);
    [ExtensionAttribute]
public static IdentifierNameSyntax ToIdentifierName(string text);
    private static bool IsPredefinedType(ITypeSymbol type);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.SymbolDisplayPartExtensions : object {
    [ExtensionAttribute]
public static SymbolDisplayPart MassageErrorTypeNames(SymbolDisplayPart p, string replacement);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.SymbolExtensions : object {
    [ExtensionAttribute]
public static bool IsMyNamespace(ISymbol symbol, Compilation compilation);
    [ExtensionAttribute]
public static bool IsMyFormsProperty(ISymbol symbol, Compilation compilation);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxKindExtensions : object {
    [ExtensionAttribute]
public static bool Contains(SyntaxKind[] kinds, SyntaxKind kind);
    [ExtensionAttribute]
public static int IndexOf(SyntaxKind[] kinds, SyntaxKind kind, int start);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxListExtensions : object {
    [ExtensionAttribute]
public static SyntaxList`1<T> RemoveRange(SyntaxList`1<T> syntaxList, int index, int count);
    [ExtensionAttribute]
public static SyntaxList`1<T> ToSyntaxList(IEnumerable`1<T> sequence);
    [ExtensionAttribute]
public static SyntaxList`1<T> Insert(SyntaxList`1<T> syntaxList, int index, T item);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxNodeExtensions : object {
    [ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2);
    [ExtensionAttribute]
public static bool IsParentKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    [ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2);
    [ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    [ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3, SyntaxKind kind4);
    [ExtensionAttribute]
public static bool IsKind(SyntaxNode node, SyntaxKind[] kinds);
    [ExtensionAttribute]
public static bool IsInConstantContext(SyntaxNode expression);
    [ExtensionAttribute]
public static bool IsInStaticContext(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsStatementContainerNode(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxList`1<StatementSyntax> GetStatements(SyntaxNode node);
    [ExtensionAttribute]
internal static bool IsAsyncSupportedFunctionSyntax(SyntaxNode node);
    [ExtensionAttribute]
internal static bool IsMultiLineLambda(SyntaxNode node);
    [ExtensionAttribute]
internal static string GetTypeCharacterString(TypeCharacter type);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(IEnumerable`1<TSyntaxNode> list);
    [ExtensionAttribute]
public static TNode ConvertToSingleLine(TNode node, bool useElasticTrivia);
    [ExtensionAttribute]
public static IList`1<IList`1<TSyntaxNode>> SplitNodesOnPreprocessorBoundaries(IEnumerable`1<TSyntaxNode> nodes, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(SyntaxToken token, TextSpan textSpan, CancellationToken cancellationToken);
    private static bool ContainsInterleavedDirective(TextSpan textSpan, SyntaxTriviaList list, CancellationToken cancellationToken);
    private static bool ContainsInterleavedDirective(TextSpan textSpan, SyntaxTrivia trivia, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxTrivia> GetLeadingBlankLines(TSyntaxNode node);
    [ExtensionAttribute]
public static TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node);
    [ExtensionAttribute]
public static TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxTrivia> GetLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    [ExtensionAttribute]
public static TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    [ExtensionAttribute]
public static TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
    [ExtensionAttribute]
public static bool IsExecutableBlock(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetContainingExecutableBlocks(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetContainingMultiLineExecutableBlocks(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode FindInnermostCommonExecutableBlock(IEnumerable`1<SyntaxNode> nodes);
    [ExtensionAttribute]
public static SyntaxList`1<StatementSyntax> GetExecutableBlockStatements(SyntaxNode node);
    [ExtensionAttribute]
internal static SyntaxNodeOrToken ChildThatContainsPosition(SyntaxNode self, int position, Int32& childIndex);
    [ExtensionAttribute]
public static SyntaxNode ReplaceStatements(SyntaxNode node, SyntaxList`1<StatementSyntax> statements, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static SyntaxNode ReplaceSingleLineLambdaExpressionStatements(SingleLineLambdaExpressionSyntax node, SyntaxList`1<StatementSyntax> statements, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static SyntaxNode ReplaceStatements(SyntaxTree tree, SyntaxNode executableBlock, SyntaxList`1<StatementSyntax> statements, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static bool IsSingleLineExecutableBlock(SyntaxNode executableBlock);
    [ExtensionAttribute]
public static bool IsMultiLineExecutableBlock(SyntaxNode node);
    private static void UpdateStatements(SyntaxNode executableBlock, SyntaxList`1<StatementSyntax> newStatements, SyntaxAnnotation[] annotations, SingleLineIfStatementSyntax& singleLineIf, MultiLineIfBlockSyntax& multiLineIf);
    [ExtensionAttribute]
public static SyntaxNode ConvertSingleLineToMultiLineExecutableBlock(SyntaxTree tree, SyntaxNode block, SyntaxList`1<StatementSyntax> statements, SyntaxAnnotation[] annotations);
    [ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetBraces(SyntaxNode node);
    [ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> GetParentheses(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsLeftSideOfSimpleAssignmentStatement(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsLeftSideOfAnyAssignmentStatement(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsAnyAssignmentStatement(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsLeftSideOfCompoundAssignmentStatement(SyntaxNode node);
    [ExtensionAttribute]
public static bool IsCompoundAssignmentStatement(SyntaxNode node);
    [ExtensionAttribute]
public static bool ParentingNodeContainsDiagnostics(SyntaxNode node);
    [ExtensionAttribute]
public static bool CheckTopLevel(SyntaxNode node, TextSpan span);
    [ExtensionAttribute]
public static bool ContainsInMethodBlockBody(MethodBlockBaseSyntax block, TextSpan textSpan);
    [ExtensionAttribute]
public static SyntaxList`1<StatementSyntax> GetMembers(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetBodies(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxNodeExtensions/VB$StateMachine_52_GetAliasImportsClauses")]
[ExtensionAttribute]
public static IEnumerable`1<SimpleImportsClauseSyntax> GetAliasImportsClauses(CompilationUnitSyntax root);
    [ExtensionAttribute]
internal static ConditionalAccessExpressionSyntax GetParentConditionalAccessExpression(ExpressionSyntax node);
    [ExtensionAttribute]
internal static ConditionalAccessExpressionSyntax GetRootConditionalAccessExpression(ExpressionSyntax node);
    [ExtensionAttribute]
public static bool IsInExpressionTree(SyntaxNode node, SemanticModel semanticModel, INamedTypeSymbol expressionTypeOpt, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ParameterListSyntax GetParameterList(SyntaxNode declaration);
    [ExtensionAttribute]
public static SyntaxList`1<AttributeListSyntax> GetAttributeLists(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetBlockFromBegin(SyntaxNode node);
    [ExtensionAttribute]
public static DeclarationStatementSyntax GetDeclarationBlockFromBegin(DeclarationStatementSyntax node);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTokenExtensions : object {
    [ExtensionAttribute]
public static bool IsKind(SyntaxToken token, SyntaxKind kind1, SyntaxKind kind2);
    [ExtensionAttribute]
public static bool IsKind(SyntaxToken token, SyntaxKind[] kinds);
    [ExtensionAttribute]
public static bool IsKindOrHasMatchingText(SyntaxToken token, SyntaxKind kind);
    [ExtensionAttribute]
public static bool HasMatchingText(SyntaxToken token, SyntaxKind kind);
    [ExtensionAttribute]
public static bool IsCharacterLiteral(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsNumericLiteral(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsNewOnRightSideOfDotOrBang(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsSkipped(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxNode FirstAncestorOrSelf(SyntaxToken token, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
public static bool HasAncestor(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsChildToken(SyntaxToken token, Func`2<TParent, SyntaxToken> childGetter);
    [ExtensionAttribute]
public static bool IsChildSeparatorToken(SyntaxToken token, Func`2<TParent, SeparatedSyntaxList`1<TChild>> childGetter);
    [ExtensionAttribute]
public static bool IsDescendantOf(SyntaxToken token, SyntaxNode node);
    [ExtensionAttribute]
internal static SyntaxNode GetInnermostDeclarationContext(SyntaxToken node);
    private static IEnumerable`1<SyntaxNode> FilterAncestors(IEnumerable`1<SyntaxNode> ancestors, EndBlockStatementSyntax parentEndBlock, EndBlockStatementSyntax precedingEndBlock);
    [ExtensionAttribute]
public static DeclarationStatementSyntax GetContainingMember(SyntaxToken token);
    [ExtensionAttribute]
public static StatementSyntax GetContainingMemberBlockBegin(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsFirstTokenOnLine(SyntaxToken token);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(IEnumerable`1<SyntaxToken> tokens);
    [ExtensionAttribute]
public static SyntaxToken GetPreviousTokenIfTouchingWord(SyntaxToken token, int position);
    [ExtensionAttribute]
public static bool IsWord(SyntaxToken token);
    [ExtensionAttribute]
public static bool IntersectsWith(SyntaxToken token, int position);
    [ExtensionAttribute]
public static SyntaxToken GetNextNonZeroWidthTokenOrEndOfFile(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsValidAttributeTarget(SyntaxToken token);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTreeExtensions : object {
    [ExtensionAttribute]
public static bool IsLastTokenOfStatementWithEndOfLine(SyntaxToken token);
    [ExtensionAttribute]
public static bool IsLastTokenOfStatement(SyntaxToken token, bool checkColonTrivia, StatementSyntax& statement);
    private static Nullable`1<SyntaxTrivia> GetTrailingColonTrivia(StatementSyntax statement);
    private static bool PartOfSingleLineLambda(SyntaxNode node);
    private static bool PartOfMultilineLambdaFooter(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxTrivia FindTriviaToLeft(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static SyntaxTrivia FindTriviaToLeft(SyntaxNodeOrToken nodeOrToken, int position);
    [ExtensionAttribute]
public static bool IsInNonUserCode(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsWithinPartialMethodDeclaration(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinComment(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinStringLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsEntirelyWithinStringOrCharOrNumericLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static bool AtEndOfIncompleteStringOrCharLiteral(SyntaxToken token, int position, string lastChar);
    [ExtensionAttribute]
public static bool IsInInactiveRegion(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsInSkippedText(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    private static bool IsGlobalStatementContext(SyntaxToken token, int position);
    [ExtensionAttribute]
public static bool IsGlobalStatementContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsRightOfDot(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsRightOfIntegerLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsInPreprocessorDirectiveContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    internal static bool IsInPreprocessorDirectiveContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, DirectiveTriviaSyntax& directive);
    [ExtensionAttribute]
public static StatementSyntax GetFirstStatementOnLine(SyntaxTree syntaxTree, int lineNumber, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static StatementSyntax GetFirstEnclosingStatement(SyntaxNode node);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTriviaExtensions : object {
    [ExtensionAttribute]
public static bool IsKind(SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2);
    [ExtensionAttribute]
public static bool IsKind(SyntaxTrivia trivia, SyntaxKind kind1, SyntaxKind kind2, SyntaxKind kind3);
    [ExtensionAttribute]
public static bool IsWhitespaceOrEndOfLine(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsWhitespace(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsEndOfLine(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsRegularOrDocComment(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsPragmaDirective(SyntaxTrivia trivia, Boolean& isDisable, Boolean& isActive, SeparatedSyntaxList`1& errorCodes);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.SyntaxTriviaListExtensions : object {
    [ExtensionAttribute]
public static bool ContainsPreprocessorDirective(SyntaxTriviaList list);
    [ExtensionAttribute]
public static SyntaxTriviaList WithoutLeadingWhitespaceOrEndOfLine(IEnumerable`1<SyntaxTrivia> list);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.TypeBlockSyntaxExtensions : object {
    [ExtensionAttribute]
public static IList`1<bool> GetInsertionIndices(TypeBlockSyntax destination, CancellationToken cancellationToken);
    private static TNode ReplaceTrailingColonToEndOfLineTrivia(TNode node);
    private static SyntaxList`1<TSyntax> EnsureProperList(SyntaxList`1<TSyntax> list);
    private static SyntaxList`1<InheritsStatementSyntax> EnsureProperInherits(TypeBlockSyntax destinationType);
    private static SyntaxList`1<ImplementsStatementSyntax> EnsureProperImplements(TypeBlockSyntax destinationType);
    private static TypeStatementSyntax EnsureProperBegin(TypeBlockSyntax destinationType);
    private static EndBlockStatementSyntax EnsureEndTokens(TypeBlockSyntax destinationType);
    [ExtensionAttribute]
public static TypeBlockSyntax FixTerminators(TypeBlockSyntax destinationType);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.TypeSyntaxGeneratorVisitor : SymbolVisitor`1<TypeSyntax> {
    private bool _addGlobal;
    private static TypeSyntaxGeneratorVisitor AddGlobalInstance;
    private static TypeSyntaxGeneratorVisitor NotAddGlobalInstance;
    private static TypeSyntaxGeneratorVisitor();
    private TypeSyntaxGeneratorVisitor(bool addGlobal);
    public static TypeSyntaxGeneratorVisitor Create(bool addGlobal);
    public virtual TypeSyntax DefaultVisit(ISymbol node);
    private static TTypeSyntax AddInformationTo(TTypeSyntax type, ISymbol symbol);
    public virtual TypeSyntax VisitAlias(IAliasSymbol symbol);
    public virtual TypeSyntax VisitArrayType(IArrayTypeSymbol symbol);
    public virtual TypeSyntax VisitDynamicType(IDynamicTypeSymbol symbol);
    public TypeSyntax CreateSimpleTypeSyntax(INamedTypeSymbol symbol);
    private static TypeSyntax TryCreateSpecializedNamedTypeSyntax(INamedTypeSymbol symbol);
    private static TypeSyntax CreateTupleTypeSyntax(INamedTypeSymbol symbol);
    public virtual TypeSyntax VisitNamedType(INamedTypeSymbol symbol);
    public virtual TypeSyntax VisitNamespace(INamespaceSymbol symbol);
    public virtual TypeSyntax VisitPointerType(IPointerTypeSymbol symbol);
    public virtual TypeSyntax VisitTypeParameter(ITypeParameterSymbol symbol);
    [CompilerGeneratedAttribute]
private TypeSyntax _Lambda$__11-0(ITypeSymbol t);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Extensions.VariableDeclaratorSyntaxExtensions : object {
    [ExtensionAttribute]
public static bool HasInitializer(VariableDeclaratorSyntax variableDeclarator);
    [ExtensionAttribute]
public static ExpressionSyntax GetInitializer(VariableDeclaratorSyntax variableDeclarator);
    [ExtensionAttribute]
public static ITypeSymbol Type(VariableDeclaratorSyntax variableDeclarator, SemanticModel semanticModel);
    [ExtensionAttribute]
public static bool IsTypeInferred(VariableDeclaratorSyntax variableDeclarator, SemanticModel semanticModel);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.FindSymbols.IDeclaredSymbolInfoFactoryService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.FindSymbols.VisualBasicDeclaredSymbolInfoFactoryService : AbstractDeclaredSymbolInfoFactoryService`9<CompilationUnitSyntax, ImportsStatementSyntax, NamespaceBlockSyntax, TypeBlockSyntax, EnumBlockSyntax, StatementSyntax, NameSyntax, QualifiedNameSyntax, IdentifierNameSyntax> {
    private static string ExtensionName;
    private static string ExtensionAttributeName;
    private static ImmutableArray`1<string> GetInheritanceNames(StringTable stringTable, TypeBlockSyntax typeBlock);
    private static Dictionary`2<string, string> GetAliasMap(TypeBlockSyntax typeBlock);
    private static void AddInheritanceNames(ArrayBuilder`1<string> builder, SeparatedSyntaxList`1<TypeSyntax> types, Dictionary`2<string, string> aliasMap);
    private static void AddInheritanceName(ArrayBuilder`1<string> builder, TypeSyntax typeSyntax, Dictionary`2<string, string> aliasMap);
    private static string GetTypeName(TypeSyntax typeSyntax);
    private static string GetSimpleName(SimpleNameSyntax simpleName);
    protected virtual string GetContainerDisplayName(StatementSyntax node);
    protected virtual string GetFullyQualifiedContainerName(StatementSyntax node, string rootNamespace);
    protected virtual void AddDeclaredSymbolInfosWorker(SyntaxNode container, StatementSyntax node, StringTable stringTable, ArrayBuilder`1<DeclaredSymbolInfo> declaredSymbolInfos, Dictionary`2<string, string> aliases, Dictionary`2<string, ArrayBuilder`1<int>> extensionMethodInfo, string containerDisplayName, string fullyQualifiedContainerName, CancellationToken cancellationToken);
    protected virtual SyntaxList`1<StatementSyntax> GetChildren(CompilationUnitSyntax node);
    protected virtual SyntaxList`1<StatementSyntax> GetChildren(NamespaceBlockSyntax node);
    protected virtual SyntaxList`1<StatementSyntax> GetChildren(TypeBlockSyntax node);
    protected virtual IEnumerable`1<StatementSyntax> GetChildren(EnumBlockSyntax node);
    protected virtual SyntaxList`1<ImportsStatementSyntax> GetUsingAliases(CompilationUnitSyntax node);
    protected virtual SyntaxList`1<ImportsStatementSyntax> GetUsingAliases(NamespaceBlockSyntax node);
    protected virtual NameSyntax GetName(NamespaceBlockSyntax node);
    protected virtual NameSyntax GetLeft(QualifiedNameSyntax node);
    protected virtual NameSyntax GetRight(QualifiedNameSyntax node);
    protected virtual SyntaxToken GetIdentifier(IdentifierNameSyntax node);
    private static bool IsExtensionMethod(MethodStatementSyntax node);
    private static bool IsNestedType(DeclarationStatementSyntax node);
    private static Accessibility GetAccessibility(SyntaxNode container, StatementSyntax node, SyntaxTokenList modifiers);
    private static string GetMethodSuffix(MethodStatementSyntax method);
    private static string GetConstructorSuffix(SubNewStatementSyntax method);
    private static string GetPropertySuffix(PropertyStatementSyntax property);
    private static string GetTypeParameterSuffix(TypeParameterListSyntax typeParameterList);
    private static string GetSuffix(ParameterListSyntax parameterList);
    private static void AppendParameters(SeparatedSyntaxList`1<ParameterSyntax> parameters, StringBuilder builder);
    protected virtual string GetReceiverTypeName(StatementSyntax node);
    protected virtual bool TryGetAliasesFromUsingDirective(ImportsStatementSyntax importStatement, ImmutableArray`1& aliases);
    private static bool TryGetSimpleTypeNameWorker(SyntaxNode node, Nullable`1<ImmutableArray`1<string>> typeParameterNames, String& simpleTypeName, Boolean& isArray);
    private static string GetSpecialTypeName(PredefinedTypeSyntax predefinedTypeNode);
    protected virtual string GetRootNamespace(CompilationOptions compilationOptions);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.AdjustSpaceFormattingRule : BaseFormattingRule {
    internal static string Name;
    public virtual AdjustSpacesOperation GetAdjustSpacesOperationSlow(SyntaxToken& previousToken, SyntaxToken& currentToken, NextGetAdjustSpacesOperation& nextFunc);
    private static bool PrecedingTriviaContainsLineBreak(SyntaxToken previousToken);
    private static bool ContainsLineBreak(SyntaxTriviaList triviaList);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.AggregatedFormattingResult : AbstractAggregatedFormattingResult {
    public AggregatedFormattingResult(SyntaxNode node, IList`1<AbstractFormattingResult> results, SimpleIntervalTree`2<TextSpan, TextSpanIntervalIntrospector> formattingSpans);
    protected virtual SyntaxNode Rewriter(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> changeMap, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.AlignTokensFormattingRule : BaseFormattingRule {
    internal static string Name;
    public virtual void AddAlignTokensOperationsSlow(List`1<AlignTokensOperation> operations, SyntaxNode node, NextAlignTokensOperationAction& nextOperation);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.BaseFormattingRule : CompatAbstractFormattingRule {
    protected static void AddIndentBlockOperation(List`1<IndentBlockOperation> operations, SyntaxToken startToken, SyntaxToken endToken, IndentBlockOption option);
    protected static void AddIndentBlockOperation(List`1<IndentBlockOperation> operations, SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, IndentBlockOption option);
    protected static void SetAlignmentBlockOperation(List`1<IndentBlockOperation> operations, SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, IndentBlockOption option);
    protected static void SetAlignmentBlockOperation(List`1<IndentBlockOperation> operations, SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, TextSpan span, IndentBlockOption option);
    protected static void AddAbsolutePositionIndentBlockOperation(List`1<IndentBlockOperation> operations, SyntaxToken startToken, SyntaxToken endToken, int indentation, IndentBlockOption option);
    protected static void AddAbsolutePositionIndentBlockOperation(List`1<IndentBlockOperation> operations, SyntaxToken startToken, SyntaxToken endToken, int indentation, TextSpan span, IndentBlockOption option);
    private static TextSpan GetAlignmentSpan(SyntaxToken startToken, SyntaxToken endToken);
    private static TextSpan GetIndentBlockSpan(SyntaxToken startToken, SyntaxToken endToken);
    protected static void AddSuppressWrappingIfOnSingleLineOperation(List`1<SuppressOperation> operations, SyntaxToken startToken, SyntaxToken endToken);
    protected static void AddSuppressAllOperationIfOnMultipleLine(List`1<SuppressOperation> operations, SyntaxToken startToken, SyntaxToken endToken);
    protected static void AddAnchorIndentationOperation(List`1<AnchorIndentationOperation> operations, SyntaxToken startToken, SyntaxToken endToken);
    protected static void AddAlignIndentationOfTokensToBaseTokenOperation(List`1<AlignTokensOperation> operations, SyntaxNode containingNode, SyntaxToken baseToken, IEnumerable`1<SyntaxToken> tokens);
    protected static AdjustNewLinesOperation CreateAdjustNewLinesOperation(int line, AdjustNewLinesOption option);
    protected static AdjustSpacesOperation CreateAdjustSpacesOperation(int space, AdjustSpacesOption option);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.DefaultOperationProvider : CompatAbstractFormattingRule {
    public static DefaultOperationProvider Instance;
    private CachedOptions _options;
    private static DefaultOperationProvider();
    private DefaultOperationProvider(CachedOptions options);
    public virtual AbstractFormattingRule WithOptions(AnalyzerConfigOptions options);
    public virtual void AddSuppressOperationsSlow(List`1<SuppressOperation> operations, SyntaxNode node, NextSuppressOperationAction& nextAction);
    public virtual void AddAnchorIndentationOperationsSlow(List`1<AnchorIndentationOperation> operations, SyntaxNode node, NextAnchorIndentationOperationAction& nextAction);
    public virtual void AddIndentBlockOperationsSlow(List`1<IndentBlockOperation> operations, SyntaxNode node, NextIndentBlockOperationAction& nextAction);
    public virtual void AddAlignTokensOperationsSlow(List`1<AlignTokensOperation> operations, SyntaxNode node, NextAlignTokensOperationAction& nextAction);
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperationSlow(SyntaxToken& previousToken, SyntaxToken& currentToken, NextGetAdjustNewLinesOperation& nextOperation);
    private AdjustNewLinesOperation AdjustNewLinesBetweenStatements(StatementSyntax previousStatement, SyntaxToken currentToken);
    private static bool IsSingleLineIfOrElseClauseSyntax(SyntaxNode node);
    private static bool ColonOrLineContinuationTrivia(SyntaxTrivia trivia);
    private static SyntaxTrivia LastOrDefaultTrivia(ValueTuple`2<SyntaxTriviaList, SyntaxTriviaList> triviaListPair, Func`2<SyntaxTrivia, bool> predicate);
    private static bool ContainEndOfLine(SyntaxToken previousToken, SyntaxToken nextToken);
    private static bool IsFirstXmlTag(SyntaxToken currentToken);
    public virtual AdjustSpacesOperation GetAdjustSpacesOperationSlow(SyntaxToken& previousToken, SyntaxToken& currentToken, NextGetAdjustSpacesOperation& nextOperation);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.ElasticTriviaFormattingRule : BaseFormattingRule {
    internal static string Name;
    public virtual void AddSuppressOperationsSlow(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& nextOperation);
    public virtual void AddIndentBlockOperationsSlow(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& nextOperation);
    public virtual void AddAlignTokensOperationsSlow(List`1<AlignTokensOperation> list, SyntaxNode node, NextAlignTokensOperationAction& nextOperation);
    public virtual AdjustSpacesOperation GetAdjustSpacesOperationSlow(SyntaxToken& previousToken, SyntaxToken& currentToken, NextGetAdjustSpacesOperation& nextOperation);
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperationSlow(SyntaxToken& previousToken, SyntaxToken& currentToken, NextGetAdjustNewLinesOperation& nextOperation);
    private static bool AfterLastImportStatement(SyntaxToken token, SyntaxToken nextToken);
    private static bool AfterLastInheritsOrImplements(SyntaxToken token, SyntaxToken nextToken);
    private static bool IsBeginStatement(StatementSyntax node);
    private static bool IsEndBlockStatement(StatementSyntax node);
    private static Nullable`1<int> LineBreaksAfter(SyntaxToken previousToken, SyntaxToken currentToken);
    private static int GetActualLines(SyntaxToken token1, SyntaxToken token2, int lines, int leadingBlankLines);
    private static int GetNumberOfLines(IEnumerable`1<SyntaxTrivia> list);
    private static bool TopLevelStatement(StatementSyntax statement);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.FormattingHelpers : object {
    public static bool IsLessThanInAttribute(SyntaxToken token);
    public static bool IsGreaterThanInAttribute(SyntaxToken token);
    public static bool IsQuoteInXmlString(SyntaxToken token);
    public static bool IsContentInXmlString(SyntaxToken token);
    public static bool IsXmlToken(SyntaxToken token);
    public static bool IsGreaterThanInXmlTag(SyntaxNode tag, SyntaxToken token);
    public static bool IsQuestionInNullableType(SyntaxToken currentToken);
    public static bool IsColonAfterAttributeTarget(SyntaxToken previousToken, SyntaxToken currentToken);
    public static bool IsExclamationInDictionaryAccess(SyntaxToken token);
    public static bool IsParenInArgumentList(SyntaxToken token);
    public static bool IsParenInBinaryCondition(SyntaxToken token);
    public static bool IsParenInTernaryCondition(SyntaxToken token);
    public static bool IsXmlTokenInXmlDeclaration(SyntaxToken token);
    public static bool IsMemberAccessDotWithoutExpression(SyntaxToken token);
    public static bool IsDictionaryAccessExclamationWithoutExpression(SyntaxToken token);
    public static bool IsNamedFieldInitializerDot(SyntaxToken token);
    internal static bool IsOverloadableOperator(SyntaxToken token);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.FormattingResult : AbstractFormattingResult {
    internal FormattingResult(TreeData treeInfo, TokenStream tokenStream, TextSpan spanToFormat);
    protected virtual SyntaxNode Rewriter(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> changeMap, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.NodeBasedFormattingRule : BaseFormattingRule {
    internal static string Name;
    public virtual void AddAnchorIndentationOperationsSlow(List`1<AnchorIndentationOperation> operations, SyntaxNode node, NextAnchorIndentationOperationAction& nextOperation);
    private static bool IsBlockSyntax(SyntaxNode node);
    public virtual void AddIndentBlockOperationsSlow(List`1<IndentBlockOperation> operations, SyntaxNode node, NextIndentBlockOperationAction& nextOperation);
    private static SyntaxNode GetOuterBlockWithDifferentStartTokenUsingXmlElement(SyntaxToken firstTokenOfInnerBlock);
    private static void AddXmlEmptyElement(List`1<IndentBlockOperation> operations, XmlNodeSyntax node, SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken);
    private static void AddXmlElementIndentBlockOperation(List`1<IndentBlockOperation> operations, XmlNodeSyntax xmlNode, SyntaxToken baseToken, SyntaxToken alignmentStartToken, SyntaxToken alignmentEndToken, SyntaxToken indentationStartToken, SyntaxToken indentationEndToken);
    private static bool IsFirstXmlElementTokenOnLine(SyntaxToken xmlToken);
    private static ValueTuple`2<SyntaxToken, SyntaxToken> GetFirstAndLastMembers(SyntaxNode node);
    private static SyntaxToken GetEndTokenForForBlock(ForOrForEachBlockSyntax node);
    private static int GetForBlockCount(ForOrForEachBlockSyntax node, IEnumerable`1<ForOrForEachBlockSyntax> forBlocks);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.StructuredTriviaFormattingRule : BaseFormattingRule {
    internal static string Name;
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperationSlow(SyntaxToken& previousToken, SyntaxToken& currentToken, NextGetAdjustNewLinesOperation& nextOperation);
    public virtual AdjustSpacesOperation GetAdjustSpacesOperationSlow(SyntaxToken& previousToken, SyntaxToken& currentToken, NextGetAdjustSpacesOperation& nextOperation);
    private static bool UnderStructuredTrivia(SyntaxToken previousToken, SyntaxToken currentToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.TriviaDataFactory : AbstractTriviaDataFactory {
    private static int s_lineContinuationCacheSize;
    private LineContinuationTrivia[] _lineContinuations;
    public TriviaDataFactory(TreeData treeInfo, AnalyzerConfigOptions options);
    public virtual TriviaData CreateLeadingTrivia(SyntaxToken token);
    public virtual TriviaData CreateTrailingTrivia(SyntaxToken token);
    public virtual TriviaData Create(SyntaxToken token1, SyntaxToken token2);
    private TriviaData GetLineContinuationTriviaInfo(SyntaxToken token1, SyntaxToken token2, AnalysisResult result);
    private void EnsureLineContinuationTriviaInfo(int indentation, string originalString);
    private static bool ContainsOnlyLineContinuation(AnalysisResult result);
    private static bool ContainsOnlyWhitespace(AnalysisResult result);
    private TriviaData GetWhitespaceOnlyTriviaInfo(SyntaxToken token1, SyntaxToken token2, AnalysisResult result);
    private int CalculateSpaces(SyntaxToken token1, SyntaxToken token2);
    private ValueTuple`3<bool, int, int> GetLineBreaksAndIndentation(AnalysisResult result);
    private static int GetSpaceOnSingleLine(AnalysisResult result);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.VisualBasicFormatEngine : AbstractFormatEngine {
    [CompilerGeneratedAttribute]
private IHeaderFacts _HeaderFacts;
    internal IHeaderFacts HeaderFacts { get; }
    public VisualBasicFormatEngine(SyntaxNode node, AnalyzerConfigOptions options, IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxToken token1, SyntaxToken token2);
    [CompilerGeneratedAttribute]
internal virtual IHeaderFacts get_HeaderFacts();
    protected virtual AbstractTriviaDataFactory CreateTriviaFactory();
    protected virtual AbstractFormattingResult CreateFormattingResult(TokenStream tokenStream);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Formatting.IFormattingService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.VisualBasicFormattingService : AbstractFormattingService {
}
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.VisualBasicStructuredTriviaFormatEngine : AbstractFormatEngine {
    [CompilerGeneratedAttribute]
private IHeaderFacts _HeaderFacts;
    internal IHeaderFacts HeaderFacts { get; }
    private VisualBasicStructuredTriviaFormatEngine(SyntaxTrivia trivia, int initialColumn, AnalyzerConfigOptions options, ChainedFormattingRules formattingRules, SyntaxToken token1, SyntaxToken token2);
    public static IFormattingResult FormatTrivia(SyntaxTrivia trivia, int initialColumn, AnalyzerConfigOptions options, ChainedFormattingRules formattingRules, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal virtual IHeaderFacts get_HeaderFacts();
    protected virtual AbstractTriviaDataFactory CreateTriviaFactory();
    protected virtual FormattingContext CreateFormattingContext(TokenStream tokenStream, CancellationToken cancellationToken);
    protected virtual NodeOperations CreateNodeOperations(CancellationToken cancellationToken);
    protected virtual AbstractFormattingResult CreateFormattingResult(TokenStream tokenStream);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Formatting.ISyntaxFormattingService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.VisualBasicSyntaxFormattingService : AbstractSyntaxFormattingService {
    private ImmutableList`1<AbstractFormattingRule> _rules;
    public virtual IEnumerable`1<AbstractFormattingRule> GetDefaultFormattingRules();
    protected virtual IFormattingResult CreateAggregatedFormattingResult(SyntaxNode node, IList`1<AbstractFormattingResult> results, SimpleIntervalTree`2<TextSpan, TextSpanIntervalIntrospector> formattingSpans);
    protected virtual AbstractFormattingResult Format(SyntaxNode root, AnalyzerConfigOptions options, IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxToken token1, SyntaxToken token2, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Formatting.VisualBasicTriviaFormatter : AbstractTriviaFormatter {
    private SyntaxTrivia _lineContinuationTrivia;
    private SyntaxTrivia _newLine;
    private bool _succeeded;
    public VisualBasicTriviaFormatter(FormattingContext context, ChainedFormattingRules formattingRules, SyntaxToken token1, SyntaxToken token2, string originalString, int lineBreaks, int spaces);
    protected virtual bool Succeeded();
    protected virtual bool IsWhitespace(SyntaxTrivia trivia);
    protected virtual bool IsEndOfLine(SyntaxTrivia trivia);
    protected virtual bool IsWhitespace(char ch);
    protected virtual bool IsNewLine(char ch);
    protected virtual SyntaxTrivia CreateWhitespace(string text);
    protected virtual SyntaxTrivia CreateEndOfLine();
    protected virtual LineColumnRule GetLineColumnRuleBetween(SyntaxTrivia trivia1, LineColumnDelta existingWhitespaceBetween, bool implicitLineBreak, SyntaxTrivia trivia2);
    protected virtual bool ContainsImplicitLineBreak(SyntaxTrivia syntaxTrivia);
    private bool IsStartOrEndOfFile(SyntaxTrivia trivia1, SyntaxTrivia trivia2);
    protected virtual LineColumnDelta Format(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<SyntaxTrivia> changes, CancellationToken cancellationToken);
    protected virtual LineColumnDelta Format(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<TextChange> changes, CancellationToken cancellationToken);
    private SyntaxTrivia FormatLineContinuationTrivia(SyntaxTrivia trivia);
    private LineColumnDelta FormatStructuredTrivia(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<SyntaxTrivia> changes, CancellationToken cancellationToken);
    private LineColumnDelta FormatStructuredTrivia(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<TextChange> changes, CancellationToken cancellationToken);
    private SyntaxTrivia FormatDocumentComment(LineColumn lineColumn, SyntaxTrivia trivia);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.GeneratedCodeRecognition.IGeneratedCodeRecognitionService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.GeneratedCodeRecognition.VisualBasicGeneratedCodeRecognitionService : AbstractGeneratedCodeRecognitionService {
}
internal class Microsoft.CodeAnalysis.VisualBasic.Indentation.SpecialFormattingRule : CompatAbstractFormattingRule {
    private IndentStyle _indentStyle;
    public SpecialFormattingRule(IndentStyle indentStyle);
    public virtual void AddSuppressOperationsSlow(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& nextOperation);
    public virtual AdjustNewLinesOperation GetAdjustNewLinesOperationSlow(SyntaxToken& previousToken, SyntaxToken& currentToken, NextGetAdjustNewLinesOperation& nextOperation);
    public virtual AdjustSpacesOperation GetAdjustSpacesOperationSlow(SyntaxToken& previousToken, SyntaxToken& currentToken, NextGetAdjustSpacesOperation& nextOperation);
    public virtual void AddIndentBlockOperationsSlow(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& nextOperation);
    private static void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, Func`2<T, bool> predicate, int indentationDelta);
    private static void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode parameterOrArgumentList, int indentationDelta);
    private static void AddArgumentListIndentBlockOperations(List`1<IndentBlockOperation> operations, SyntaxNode node);
    public virtual void AddAlignTokensOperationsSlow(List`1<AlignTokensOperation> operations, SyntaxNode node, NextAlignTokensOperationAction& nextAction);
    private static void AddCaseClauseAlignTokensOperations(List`1<AlignTokensOperation> operations, SyntaxNode node);
    private static void AddAlignTokensOperations(List`1<AlignTokensOperation> operations, SyntaxNode node, Func`2<T, SyntaxToken> baseTokenGetter);
    private static void AddAlignTokensOperations(List`1<AlignTokensOperation> operations, SyntaxToken baseToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Indentation.IIndentationService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Indentation.VisualBasicIndentationService : AbstractIndentationService`1<CompilationUnitSyntax> {
    public static VisualBasicIndentationService WithoutParameterAlignmentInstance;
    private AbstractFormattingRule _specializedIndentationRule;
    private static VisualBasicIndentationService();
    private VisualBasicIndentationService(AbstractFormattingRule specializedIndentationRule);
    protected virtual bool ShouldUseTokenIndenter(Indenter<CompilationUnitSyntax> indenter, SyntaxToken& token);
    protected virtual ISmartTokenFormatter CreateSmartTokenFormatter(Indenter<CompilationUnitSyntax> indenter);
    protected virtual Nullable`1<IndentationResult> GetDesiredIndentationWorker(Indenter<CompilationUnitSyntax> indenter, Nullable`1<SyntaxToken> tokenOpt, Nullable`1<SyntaxTrivia> triviaOpt);
    private static SyntaxToken GetTokenOnLeft(SyntaxTrivia trivia);
    private static IndentationResult GetIndentationBasedOnToken(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token, SyntaxTrivia trivia);
    private static IndentationResult GetIndentationOfCurrentPosition(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token, int position);
    private static IndentationResult GetIndentationOfCurrentPosition(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token, int position, int extraSpaces);
    private static bool IsLineContinuable(SyntaxToken lastVisibleTokenOnPreviousLine, SyntaxTrivia trivia);
    private static bool IsCloseBraceOfInitializerSyntax(SyntaxToken visibleTokenOnCurrentLine);
    private static bool ContainingStatementHasDiagnostic(SyntaxNode node);
    private static Nullable`1<IndentationResult> GetIndentationFromOperationService(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token, int position);
    private static IndentationResult GetIndentationFromTokenLineAfterLineContinuation(Indenter<CompilationUnitSyntax> indenter, SyntaxToken token, SyntaxTrivia trivia);
    private static bool IsCommaInParameters(SyntaxToken token);
    private static IndentationResult GetIndentationFromTwoLines(Indenter<CompilationUnitSyntax> indenter, TextLine firstLine, TextLine secondLine, SyntaxToken token, int position);
    private static bool HasLinesBetween(int lineNumber1, int lineNumber2);
    protected virtual AbstractFormattingRule GetSpecializedIndentationFormattingRule(IndentStyle indentStyle);
    public static bool ShouldUseSmartTokenFormatterInsteadOfIndenter(IEnumerable`1<AbstractFormattingRule> formattingRules, CompilationUnitSyntax root, TextLine line, IOptionService optionService, OptionSet optionSet, SyntaxToken& token, bool neverUseWhenHavingMissingToken);
    private static bool IsInvalidToken(SyntaxToken token);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Indentation.VisualBasicSmartTokenFormatter : object {
    private OptionSet _optionSet;
    private IEnumerable`1<AbstractFormattingRule> _formattingRules;
    private CompilationUnitSyntax _root;
    public VisualBasicSmartTokenFormatter(OptionSet optionSet, IEnumerable`1<AbstractFormattingRule> formattingRules, CompilationUnitSyntax root);
    public sealed virtual override Task`1<IList`1<TextChange>> FormatTokenAsync(Workspace workspace, SyntaxToken token, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.LanguageServices.VisualBasicAccessibilityFacts : object {
    public static IAccessibilityFacts Instance;
    private static VisualBasicAccessibilityFacts();
    public sealed virtual override bool CanHaveAccessibility(SyntaxNode declaration);
    private static bool IsChildOf(SyntaxNode node, SyntaxKind kind);
    private static bool IsChildOfVariableDeclaration(SyntaxNode node);
    public sealed virtual override Accessibility GetAccessibility(SyntaxNode declaration);
    public static SyntaxTokenList GetModifierTokens(SyntaxNode declaration);
    public static void GetAccessibilityAndModifiers(SyntaxTokenList modifierTokens, Accessibility& accessibility, DeclarationModifiers& modifiers, Boolean& isDefault);
}
internal class Microsoft.CodeAnalysis.VisualBasic.LanguageServices.VisualBasicDocumentationCommentService : AbstractDocumentationCommentService`10<DocumentationCommentTriviaSyntax, XmlNodeSyntax, XmlNodeSyntax, CrefReferenceSyntax, XmlElementSyntax, XmlTextSyntax, XmlEmptyElementSyntax, XmlCrefAttributeSyntax, XmlNameAttributeSyntax, XmlAttributeSyntax> {
    public static VisualBasicDocumentationCommentService Instance;
    private static VisualBasicDocumentationCommentService();
    protected virtual SyntaxToken GetIdentifier(XmlNameAttributeSyntax xmlName);
    protected virtual CrefReferenceSyntax GetCref(XmlCrefAttributeSyntax xmlCref);
    protected virtual SyntaxList`1<XmlNodeSyntax> GetAttributes(XmlEmptyElementSyntax xmlEmpty);
    protected virtual SyntaxTokenList GetTextTokens(XmlTextSyntax xmlText);
    protected virtual SyntaxTokenList GetTextTokens(XmlAttributeSyntax xmlTextAttribute);
    protected virtual SyntaxNode GetName(XmlElementSyntax xmlElement);
}
internal class Microsoft.CodeAnalysis.VisualBasic.LanguageServices.VisualBasicFileBannerFacts : AbstractFileBannerFacts {
    public static IFileBannerFacts Instance;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected IDocumentationCommentService DocumentationCommentService { get; }
    private static VisualBasicFileBannerFacts();
    protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual IDocumentationCommentService get_DocumentationCommentService();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageServices.IFileBannerFactsService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.LanguageServices.VisualBasicFileBannerFactsService : VisualBasicFileBannerFacts {
}
internal class Microsoft.CodeAnalysis.VisualBasic.LanguageServices.VisualBasicHeaderFacts : AbstractHeaderFacts {
    public static IHeaderFacts Instance;
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFacts;
    protected ISyntaxFacts SyntaxFacts { get; }
    private static VisualBasicHeaderFacts();
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFacts();
    public virtual bool IsOnTypeHeader(SyntaxNode root, int position, bool fullHeader, SyntaxNode& typeDeclaration);
    public virtual bool IsOnPropertyDeclarationHeader(SyntaxNode root, int position, SyntaxNode& propertyDeclaration);
    public virtual bool IsOnParameterHeader(SyntaxNode root, int position, SyntaxNode& parameter);
    public virtual bool IsOnMethodHeader(SyntaxNode root, int position, SyntaxNode& method);
    public virtual bool IsOnLocalFunctionHeader(SyntaxNode root, int position, SyntaxNode& localFunction);
    public virtual bool IsOnLocalDeclarationHeader(SyntaxNode root, int position, SyntaxNode& localDeclaration);
    public virtual bool IsOnIfStatementHeader(SyntaxNode root, int position, SyntaxNode& ifStatement);
    public virtual bool IsOnWhileStatementHeader(SyntaxNode root, int position, SyntaxNode& whileStatement);
    public virtual bool IsOnForeachHeader(SyntaxNode root, int position, SyntaxNode& foreachStatement);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageServices.IHeaderFactsService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.LanguageServices.VisualBasicHeaderFactsService : VisualBasicHeaderFacts {
}
internal class Microsoft.CodeAnalysis.VisualBasic.LanguageServices.VisualBasicSelectedMembers : AbstractSelectedMembers`5<StatementSyntax, FieldDeclarationSyntax, PropertyStatementSyntax, TypeBlockSyntax, ModifiedIdentifierSyntax> {
    public static VisualBasicSelectedMembers Instance;
    private static VisualBasicSelectedMembers();
    protected virtual IEnumerable`1<ModifiedIdentifierSyntax> GetAllDeclarators(FieldDeclarationSyntax field);
    protected virtual SyntaxList`1<StatementSyntax> GetMembers(TypeBlockSyntax containingType);
    protected virtual SyntaxToken GetPropertyIdentifier(PropertyStatementSyntax declarator);
    protected virtual SyntaxToken GetVariableIdentifier(ModifiedIdentifierSyntax declarator);
}
internal class Microsoft.CodeAnalysis.VisualBasic.LanguageServices.VisualBasicSyntaxFacts : object {
    [CompilerGeneratedAttribute]
private static VisualBasicSyntaxFacts _Instance;
    [CompilerGeneratedAttribute]
private ISyntaxKinds _SyntaxKinds;
    private static string s_dotToken;
    public static VisualBasicSyntaxFacts Instance { get; }
    public bool IsCaseSensitive { get; }
    public StringComparer StringComparer { get; }
    public SyntaxTrivia ElasticMarker { get; }
    public SyntaxTrivia ElasticCarriageReturnLineFeed { get; }
    public ISyntaxKinds SyntaxKinds { get; }
    private static VisualBasicSyntaxFacts();
    [CompilerGeneratedAttribute]
public static VisualBasicSyntaxFacts get_Instance();
    public sealed virtual override bool get_IsCaseSensitive();
    public sealed virtual override StringComparer get_StringComparer();
    public sealed virtual override SyntaxTrivia get_ElasticMarker();
    public sealed virtual override SyntaxTrivia get_ElasticCarriageReturnLineFeed();
    [CompilerGeneratedAttribute]
public sealed virtual override ISyntaxKinds get_SyntaxKinds();
    public sealed virtual override bool SupportsIndexingInitializer(ParseOptions options);
    public sealed virtual override bool SupportsThrowExpression(ParseOptions options);
    public sealed virtual override bool SupportsLocalFunctionDeclaration(ParseOptions options);
    public sealed virtual override bool SupportsRecord(ParseOptions options);
    public sealed virtual override bool SupportsRecordStruct(ParseOptions options);
    public sealed virtual override SyntaxToken ParseToken(string text);
    public sealed virtual override SyntaxTriviaList ParseLeadingTrivia(string text);
    public sealed virtual override string EscapeIdentifier(string identifier);
    public sealed virtual override bool IsVerbatimIdentifier(SyntaxToken token);
    public sealed virtual override bool IsOperator(SyntaxToken token);
    public sealed virtual override bool IsContextualKeyword(SyntaxToken token);
    public sealed virtual override bool IsReservedKeyword(SyntaxToken token);
    public sealed virtual override bool IsPreprocessorKeyword(SyntaxToken token);
    public sealed virtual override bool IsPreProcessorDirectiveContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public sealed virtual override bool TryGetCorrespondingOpenBrace(SyntaxToken token, SyntaxToken& openBrace);
    public sealed virtual override bool IsEntirelyWithinStringOrCharOrNumericLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public sealed virtual override bool IsDirective(SyntaxNode node);
    public sealed virtual override bool TryGetExternalSourceInfo(SyntaxNode node, ExternalSourceInfo& info);
    public sealed virtual override bool IsDeclarationExpression(SyntaxNode node);
    public sealed virtual override bool IsAttributeName(SyntaxNode node);
    public sealed virtual override bool IsNameOfSimpleMemberAccessExpression(SyntaxNode node);
    public sealed virtual override bool IsNameOfAnyMemberAccessExpression(SyntaxNode node);
    public sealed virtual override SyntaxNode GetStandaloneExpression(SyntaxNode node);
    public sealed virtual override SyntaxNode GetRootConditionalAccessExpression(SyntaxNode node);
    public sealed virtual override bool IsNamedArgument(SyntaxNode node);
    public sealed virtual override bool IsNameOfNamedArgument(SyntaxNode node);
    public sealed virtual override Nullable`1<SyntaxToken> GetNameOfParameter(SyntaxNode node);
    public sealed virtual override SyntaxNode GetDefaultOfParameter(SyntaxNode node);
    public sealed virtual override SyntaxNode GetParameterList(SyntaxNode node);
    public sealed virtual override bool IsParameterList(SyntaxNode node);
    public sealed virtual override SyntaxToken GetIdentifierOfGenericName(SyntaxNode genericName);
    public sealed virtual override bool IsUsingDirectiveName(SyntaxNode node);
    public sealed virtual override bool IsDeconstructionAssignment(SyntaxNode node);
    public sealed virtual override bool IsDeconstructionForEachStatement(SyntaxNode node);
    public sealed virtual override bool IsStatement(SyntaxNode node);
    public sealed virtual override bool IsExecutableStatement(SyntaxNode node);
    public sealed virtual override bool IsMethodBody(SyntaxNode node);
    public sealed virtual override SyntaxNode GetExpressionOfReturnStatement(SyntaxNode node);
    public sealed virtual override bool IsThisConstructorInitializer(SyntaxToken token);
    public sealed virtual override bool IsBaseConstructorInitializer(SyntaxToken token);
    public sealed virtual override bool IsQueryKeyword(SyntaxToken token);
    public sealed virtual override bool IsPredefinedType(SyntaxToken token);
    public sealed virtual override bool IsPredefinedType(SyntaxToken token, PredefinedType type);
    public sealed virtual override bool TryGetPredefinedType(SyntaxToken token, PredefinedType& type);
    private static PredefinedType GetPredefinedType(SyntaxToken token);
    public sealed virtual override bool IsPredefinedOperator(SyntaxToken token);
    public sealed virtual override bool IsPredefinedOperator(SyntaxToken token, PredefinedOperator op);
    public sealed virtual override bool TryGetPredefinedOperator(SyntaxToken token, PredefinedOperator& op);
    private static PredefinedOperator GetPredefinedOperator(SyntaxToken token);
    public sealed virtual override string GetText(int kind);
    public sealed virtual override bool IsIdentifierPartCharacter(char c);
    public sealed virtual override bool IsIdentifierStartCharacter(char c);
    public sealed virtual override bool IsIdentifierEscapeCharacter(char c);
    public sealed virtual override bool IsValidIdentifier(string identifier);
    public sealed virtual override bool IsVerbatimIdentifier(string identifier);
    public sealed virtual override bool IsTypeCharacter(char c);
    public sealed virtual override bool IsStartOfUnicodeEscapeSequence(char c);
    public sealed virtual override bool IsLiteral(SyntaxToken token);
    public sealed virtual override bool IsStringLiteralOrInterpolatedStringLiteral(SyntaxToken token);
    public sealed virtual override bool IsBindableToken(SyntaxToken token);
    public sealed virtual override bool IsPointerMemberAccessExpression(SyntaxNode node);
    public sealed virtual override void GetNameAndArityOfSimpleName(SyntaxNode node, String& name, Int32& arity);
    public sealed virtual override bool LooksGeneric(SyntaxNode name);
    public sealed virtual override SyntaxNode GetExpressionOfMemberAccessExpression(SyntaxNode node, bool allowImplicitTarget);
    public sealed virtual override SyntaxNode GetTargetOfMemberBinding(SyntaxNode node);
    public sealed virtual override SyntaxNode GetNameOfMemberBindingExpression(SyntaxNode node);
    public sealed virtual override void GetPartsOfElementAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& argumentList);
    public sealed virtual override SyntaxNode GetExpressionOfInterpolation(SyntaxNode node);
    public sealed virtual override bool IsInNamespaceOrTypeContext(SyntaxNode node);
    public sealed virtual override bool IsBaseTypeList(SyntaxNode node);
    public sealed virtual override bool IsInStaticContext(SyntaxNode node);
    public sealed virtual override SyntaxNode GetExpressionOfArgument(SyntaxNode node);
    public sealed virtual override RefKind GetRefKindOfArgument(SyntaxNode node);
    public sealed virtual override bool IsArgument(SyntaxNode node);
    public sealed virtual override bool IsSimpleArgument(SyntaxNode node);
    public sealed virtual override bool IsInConstantContext(SyntaxNode node);
    public sealed virtual override bool IsInConstructor(SyntaxNode node);
    public sealed virtual override bool IsUnsafeContext(SyntaxNode node);
    public sealed virtual override SyntaxNode GetNameOfAttribute(SyntaxNode node);
    public sealed virtual override bool IsAttributeNamedArgumentIdentifier(SyntaxNode node);
    public sealed virtual override SyntaxNode GetContainingTypeDeclaration(SyntaxNode root, int position);
    public sealed virtual override SyntaxNode GetContainingVariableDeclaratorOfFieldDeclaration(SyntaxNode node);
    public sealed virtual override bool IsMemberInitializerNamedAssignmentIdentifier(SyntaxNode node);
    public sealed virtual override bool IsMemberInitializerNamedAssignmentIdentifier(SyntaxNode node, SyntaxNode& initializedInstance);
    public sealed virtual override bool IsNameOfSubpattern(SyntaxNode node);
    public sealed virtual override bool IsPropertyPatternClause(SyntaxNode node);
    public sealed virtual override bool IsElementAccessExpression(SyntaxNode node);
    public sealed virtual override bool IsIndexerMemberCRef(SyntaxNode node);
    public sealed virtual override SyntaxNode GetContainingMemberDeclaration(SyntaxNode root, int position, bool useFullSpan);
    public sealed virtual override bool IsMethodLevelMember(SyntaxNode node);
    public sealed virtual override TextSpan GetMemberBodySpanForSpeculativeBinding(SyntaxNode node);
    public sealed virtual override bool ContainsInMemberBody(SyntaxNode node, TextSpan span);
    private static bool ContainsExclusively(TextSpan outerSpan, TextSpan innerSpan);
    private static TextSpan GetSyntaxListSpan(SyntaxList`1<T> list);
    private static TextSpan GetSeparatedSyntaxListSpan(SeparatedSyntaxList`1<T> list);
    public sealed virtual override List`1<SyntaxNode> GetTopLevelAndMethodLevelMembers(SyntaxNode root);
    public sealed virtual override List`1<SyntaxNode> GetMethodLevelMembers(SyntaxNode root);
    public sealed virtual override SyntaxList`1<SyntaxNode> GetMembersOfTypeDeclaration(SyntaxNode typeDeclaration);
    public sealed virtual override bool IsTopLevelNodeWithMembers(SyntaxNode node);
    public sealed virtual override string GetDisplayName(SyntaxNode node, DisplayNameOptions options, string rootNamespace);
    private static string GetName(SyntaxNode node, DisplayNameOptions options, Boolean& containsGlobalKeyword);
    private static void AppendTypeParameterList(StringBuilder builder, TypeParameterListSyntax typeParameterList);
    private void AppendMembers(SyntaxNode node, List`1<SyntaxNode> list, bool topLevel, bool methodLevel);
    public sealed virtual override SyntaxNode TryGetBindableParent(SyntaxToken token);
    public sealed virtual override IEnumerable`1<SyntaxNode> GetConstructors(SyntaxNode root, CancellationToken cancellationToken);
    private void AppendConstructors(SyntaxList`1<StatementSyntax> members, List`1<SyntaxNode> constructors, CancellationToken cancellationToken);
    public sealed virtual override TextSpan GetInactiveRegionSpanAroundPosition(SyntaxTree tree, int position, CancellationToken cancellationToken);
    public sealed virtual override string GetNameForArgument(SyntaxNode argument);
    public sealed virtual override string GetNameForAttributeArgument(SyntaxNode argument);
    public sealed virtual override bool IsLeftSideOfDot(SyntaxNode node);
    public sealed virtual override SyntaxNode GetRightSideOfDot(SyntaxNode node);
    public sealed virtual override SyntaxNode GetLeftSideOfDot(SyntaxNode node, bool allowImplicitTarget);
    public sealed virtual override bool IsLeftSideOfExplicitInterfaceSpecifier(SyntaxNode node);
    public sealed virtual override bool IsLeftSideOfAssignment(SyntaxNode node);
    public sealed virtual override bool IsLeftSideOfAnyAssignment(SyntaxNode node);
    public sealed virtual override bool IsLeftSideOfCompoundAssignment(SyntaxNode node);
    public sealed virtual override SyntaxNode GetRightHandSideOfAssignment(SyntaxNode node);
    public sealed virtual override bool IsInferredAnonymousObjectMemberDeclarator(SyntaxNode node);
    public sealed virtual override bool IsOperandOfIncrementExpression(SyntaxNode node);
    public sealed virtual override bool IsOperandOfIncrementOrDecrementExpression(SyntaxNode node);
    public sealed virtual override SyntaxList`1<SyntaxNode> GetContentsOfInterpolatedString(SyntaxNode interpolatedString);
    public sealed virtual override bool IsNumericLiteral(SyntaxToken token);
    public sealed virtual override bool IsVerbatimStringLiteral(SyntaxToken token);
    public sealed virtual override SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfInvocationExpression(SyntaxNode node);
    public sealed virtual override SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfObjectCreationExpression(SyntaxNode node);
    public sealed virtual override SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfArgumentList(SyntaxNode node);
    public sealed virtual override SyntaxNode ConvertToSingleLine(SyntaxNode node, bool useElasticTrivia);
    public sealed virtual override bool IsDocumentationComment(SyntaxNode node);
    public sealed virtual override bool IsUsingOrExternOrImport(SyntaxNode node);
    public sealed virtual override bool IsGlobalAssemblyAttribute(SyntaxNode node);
    public sealed virtual override bool IsGlobalModuleAttribute(SyntaxNode node);
    private static bool IsGlobalAttribute(SyntaxNode node, SyntaxKind attributeTarget);
    public sealed virtual override bool IsDeclaration(SyntaxNode node);
    public sealed virtual override bool IsTypeDeclaration(SyntaxNode node);
    public sealed virtual override bool IsSimpleAssignmentStatement(SyntaxNode node);
    public sealed virtual override void GetPartsOfAssignmentStatement(SyntaxNode statement, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public sealed virtual override void GetPartsOfAssignmentExpressionOrStatement(SyntaxNode statement, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public sealed virtual override SyntaxToken GetIdentifierOfSimpleName(SyntaxNode node);
    public sealed virtual override SyntaxToken GetIdentifierOfVariableDeclarator(SyntaxNode node);
    public sealed virtual override SyntaxToken GetIdentifierOfParameter(SyntaxNode node);
    public sealed virtual override SyntaxToken GetIdentifierOfTypeDeclaration(SyntaxNode node);
    public sealed virtual override SyntaxToken GetIdentifierOfIdentifierName(SyntaxNode node);
    public sealed virtual override bool IsDeclaratorOfLocalDeclarationStatement(SyntaxNode declarator, SyntaxNode localDeclarationStatement);
    public sealed virtual override bool AreEquivalent(SyntaxToken token1, SyntaxToken token2);
    public sealed virtual override bool AreEquivalent(SyntaxNode node1, SyntaxNode node2);
    public sealed virtual override bool IsExpressionOfForeach(SyntaxNode node);
    public sealed virtual override SyntaxNode GetExpressionOfExpressionStatement(SyntaxNode node);
    public sealed virtual override bool IsIsExpression(SyntaxNode node);
    public sealed virtual override SyntaxNode WalkDownParentheses(SyntaxNode node);
    public sealed virtual override void GetPartsOfTupleExpression(SyntaxNode node, SyntaxToken& openParen, SeparatedSyntaxList`1& arguments, SyntaxToken& closeParen);
    public sealed virtual override bool IsPreprocessorDirective(SyntaxTrivia trivia);
    public sealed virtual override bool IsRegularComment(SyntaxTrivia trivia);
    public sealed virtual override bool IsDocumentationComment(SyntaxTrivia trivia);
    public sealed virtual override bool IsElastic(SyntaxTrivia trivia);
    public sealed virtual override bool IsPragmaDirective(SyntaxTrivia trivia, Boolean& isDisable, Boolean& isActive, SeparatedSyntaxList`1& errorCodes);
    public sealed virtual override bool ContainsInterleavedDirective(TextSpan span, SyntaxToken token, CancellationToken cancellationToken);
    public sealed virtual override bool IsDocumentationCommentExteriorTrivia(SyntaxTrivia trivia);
    public sealed virtual override SyntaxTokenList GetModifiers(SyntaxNode node);
    public sealed virtual override SyntaxNode WithModifiers(SyntaxNode node, SyntaxTokenList modifiers);
    public sealed virtual override SeparatedSyntaxList`1<SyntaxNode> GetVariablesOfLocalDeclarationStatement(SyntaxNode node);
    public sealed virtual override SyntaxNode GetInitializerOfVariableDeclarator(SyntaxNode node);
    public sealed virtual override SyntaxNode GetTypeOfVariableDeclarator(SyntaxNode node);
    public sealed virtual override SyntaxNode GetValueOfEqualsValueClause(SyntaxNode node);
    public sealed virtual override bool IsScopeBlock(SyntaxNode node);
    public sealed virtual override bool IsExecutableBlock(SyntaxNode node);
    public sealed virtual override IReadOnlyList`1<SyntaxNode> GetExecutableBlockStatements(SyntaxNode node);
    public sealed virtual override SyntaxNode FindInnermostCommonExecutableBlock(IEnumerable`1<SyntaxNode> nodes);
    public sealed virtual override bool IsStatementContainer(SyntaxNode node);
    public sealed virtual override IReadOnlyList`1<SyntaxNode> GetStatementContainerStatements(SyntaxNode node);
    public sealed virtual override bool IsConversionExpression(SyntaxNode node);
    public sealed virtual override bool IsCastExpression(SyntaxNode node);
    public sealed virtual override void GetPartsOfCastExpression(SyntaxNode node, SyntaxNode& type, SyntaxNode& expression);
    public sealed virtual override Location GetDeconstructionReferenceLocation(SyntaxNode node);
    public sealed virtual override Nullable`1<SyntaxToken> GetDeclarationIdentifierIfOverride(SyntaxToken token);
    public sealed virtual override bool IsPostfixUnaryExpression(SyntaxNode node);
    public sealed virtual override bool IsMemberBindingExpression(SyntaxNode node);
    public sealed virtual override bool IsNameOfMemberBindingExpression(SyntaxNode node);
    public sealed virtual override SyntaxList`1<SyntaxNode> GetAttributeLists(SyntaxNode node);
    public sealed virtual override bool IsUsingAliasDirective(SyntaxNode node);
    public sealed virtual override void GetPartsOfUsingAliasDirective(SyntaxNode node, SyntaxToken& globalKeyword, SyntaxToken& alias, SyntaxNode& name);
    public sealed virtual override bool IsParameterNameXmlElementSyntax(SyntaxNode node);
    public sealed virtual override SyntaxList`1<SyntaxNode> GetContentFromDocumentationCommentTriviaSyntax(SyntaxTrivia trivia);
    internal static bool IsChildOf(SyntaxNode node, SyntaxKind kind);
    internal static bool IsChildOfVariableDeclaration(SyntaxNode node);
    private static int GetDeclarationCount(IReadOnlyList`1<SyntaxNode> nodes);
    internal static int GetDeclarationCount(SyntaxNode node);
    public sealed virtual override bool SupportsNotPattern(ParseOptions options);
    public sealed virtual override bool IsIsPatternExpression(SyntaxNode node);
    public sealed virtual override bool IsAnyPattern(SyntaxNode node);
    public sealed virtual override bool IsAndPattern(SyntaxNode node);
    public sealed virtual override bool IsBinaryPattern(SyntaxNode node);
    public sealed virtual override bool IsConstantPattern(SyntaxNode node);
    public sealed virtual override bool IsDeclarationPattern(SyntaxNode node);
    public sealed virtual override bool IsNotPattern(SyntaxNode node);
    public sealed virtual override bool IsOrPattern(SyntaxNode node);
    public sealed virtual override bool IsParenthesizedPattern(SyntaxNode node);
    public sealed virtual override bool IsRecursivePattern(SyntaxNode node);
    public sealed virtual override bool IsUnaryPattern(SyntaxNode node);
    public sealed virtual override bool IsTypePattern(SyntaxNode node);
    public sealed virtual override bool IsVarPattern(SyntaxNode node);
    public sealed virtual override void GetPartsOfIsPatternExpression(SyntaxNode node, SyntaxNode& left, SyntaxToken& isToken, SyntaxNode& right);
    public sealed virtual override SyntaxNode GetExpressionOfConstantPattern(SyntaxNode node);
    public sealed virtual override void GetPartsOfParenthesizedPattern(SyntaxNode node, SyntaxToken& openParen, SyntaxNode& pattern, SyntaxToken& closeParen);
    public sealed virtual override void GetPartsOfBinaryPattern(SyntaxNode node, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public sealed virtual override void GetPartsOfUnaryPattern(SyntaxNode node, SyntaxToken& operatorToken, SyntaxNode& pattern);
    public sealed virtual override void GetPartsOfDeclarationPattern(SyntaxNode node, SyntaxNode& type, SyntaxNode& designation);
    public sealed virtual override void GetPartsOfRecursivePattern(SyntaxNode node, SyntaxNode& type, SyntaxNode& positionalPart, SyntaxNode& propertyPart, SyntaxNode& designation);
    public sealed virtual override SyntaxNode GetTypeOfTypePattern(SyntaxNode node);
    public sealed virtual override void GetPartsOfInterpolationExpression(SyntaxNode node, SyntaxToken& stringStartToken, SyntaxList`1& contents, SyntaxToken& stringEndToken);
    public sealed virtual override bool IsVerbatimInterpolatedStringExpression(SyntaxNode node);
    public sealed virtual override bool IsAnonymousFunctionExpression(SyntaxNode node);
    public sealed virtual override bool IsBaseNamespaceDeclaration(SyntaxNode node);
    public sealed virtual override bool IsBinaryExpression(SyntaxNode node);
    public sealed virtual override bool IsLiteralExpression(SyntaxNode node);
    public sealed virtual override bool IsMemberAccessExpression(SyntaxNode node);
    public sealed virtual override bool IsSimpleName(SyntaxNode node);
    public sealed virtual override void GetPartsOfBinaryExpression(SyntaxNode node, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public sealed virtual override void GetPartsOfCompilationUnit(SyntaxNode node, SyntaxList`1& imports, SyntaxList`1& attributeLists, SyntaxList`1& members);
    public sealed virtual override void GetPartsOfConditionalAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxToken& operatorToken, SyntaxNode& whenNotNull);
    public sealed virtual override void GetPartsOfConditionalExpression(SyntaxNode node, SyntaxNode& condition, SyntaxNode& whenTrue, SyntaxNode& whenFalse);
    public sealed virtual override void GetPartsOfInvocationExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& argumentList);
    public sealed virtual override void GetPartsOfMemberAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxToken& operatorToken, SyntaxNode& name);
    public sealed virtual override void GetPartsOfBaseNamespaceDeclaration(SyntaxNode node, SyntaxNode& name, SyntaxList`1& imports, SyntaxList`1& members);
    public sealed virtual override void GetPartsOfObjectCreationExpression(SyntaxNode node, SyntaxNode& type, SyntaxNode& argumentList, SyntaxNode& initializer);
    public sealed virtual override void GetPartsOfParenthesizedExpression(SyntaxNode node, SyntaxToken& openParen, SyntaxNode& expression, SyntaxToken& closeParen);
    public sealed virtual override void GetPartsOfPrefixUnaryExpression(SyntaxNode node, SyntaxToken& operatorToken, SyntaxNode& operand);
    public sealed virtual override void GetPartsOfQualifiedName(SyntaxNode node, SyntaxNode& left, SyntaxToken& dotToken, SyntaxNode& right);
    public sealed virtual override SyntaxNode GetExpressionOfAwaitExpression(SyntaxNode node);
    public sealed virtual override SyntaxNode GetExpressionOfThrowExpression(SyntaxNode node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.LanguageServices.VisualBasicSyntaxKinds : object {
    public static VisualBasicSyntaxKinds Instance;
    [CompilerGeneratedAttribute]
private int _ConflictMarkerTrivia;
    [CompilerGeneratedAttribute]
private int _DisabledTextTrivia;
    [CompilerGeneratedAttribute]
private int _EndOfLineTrivia;
    [CompilerGeneratedAttribute]
private int _SkippedTokensTrivia;
    [CompilerGeneratedAttribute]
private int _WhitespaceTrivia;
    [CompilerGeneratedAttribute]
private int _SingleLineCommentTrivia;
    [CompilerGeneratedAttribute]
private Nullable`1<int> _MultiLineCommentTrivia;
    [CompilerGeneratedAttribute]
private int _SingleLineDocCommentTrivia;
    [CompilerGeneratedAttribute]
private Nullable`1<int> _MultiLineDocCommentTrivia;
    [CompilerGeneratedAttribute]
private Nullable`1<int> _ShebangDirectiveTrivia;
    [CompilerGeneratedAttribute]
private int _CloseBraceToken;
    [CompilerGeneratedAttribute]
private int _ColonToken;
    [CompilerGeneratedAttribute]
private int _CharacterLiteralToken;
    [CompilerGeneratedAttribute]
private int _DotToken;
    [CompilerGeneratedAttribute]
private int _InterpolatedStringTextToken;
    [CompilerGeneratedAttribute]
private int _QuestionToken;
    [CompilerGeneratedAttribute]
private int _StringLiteralToken;
    [CompilerGeneratedAttribute]
private int _IfKeyword;
    [CompilerGeneratedAttribute]
private int _GenericName;
    [CompilerGeneratedAttribute]
private int _IdentifierName;
    [CompilerGeneratedAttribute]
private int _QualifiedName;
    [CompilerGeneratedAttribute]
private int _TupleType;
    [CompilerGeneratedAttribute]
private int _CharacterLiteralExpression;
    [CompilerGeneratedAttribute]
private int _DefaultLiteralExpression;
    [CompilerGeneratedAttribute]
private int _FalseLiteralExpression;
    [CompilerGeneratedAttribute]
private int _NullLiteralExpression;
    [CompilerGeneratedAttribute]
private int _NumericLiteralExpression;
    [CompilerGeneratedAttribute]
private int _StringLiteralExpression;
    [CompilerGeneratedAttribute]
private int _TrueLiteralExpression;
    [CompilerGeneratedAttribute]
private int _AnonymousObjectCreationExpression;
    [CompilerGeneratedAttribute]
private int _AwaitExpression;
    [CompilerGeneratedAttribute]
private int _BaseExpression;
    [CompilerGeneratedAttribute]
private int _ConditionalAccessExpression;
    [CompilerGeneratedAttribute]
private int _ConditionalExpression;
    [CompilerGeneratedAttribute]
private Nullable`1<int> _ImplicitObjectCreationExpression;
    [CompilerGeneratedAttribute]
private int _InvocationExpression;
    [CompilerGeneratedAttribute]
private int _LogicalAndExpression;
    [CompilerGeneratedAttribute]
private int _LogicalOrExpression;
    [CompilerGeneratedAttribute]
private int _LogicalNotExpression;
    [CompilerGeneratedAttribute]
private int _ObjectCreationExpression;
    [CompilerGeneratedAttribute]
private int _ParenthesizedExpression;
    [CompilerGeneratedAttribute]
private int _QueryExpression;
    [CompilerGeneratedAttribute]
private int _ReferenceEqualsExpression;
    [CompilerGeneratedAttribute]
private int _ReferenceNotEqualsExpression;
    [CompilerGeneratedAttribute]
private int _SimpleMemberAccessExpression;
    [CompilerGeneratedAttribute]
private int _TernaryConditionalExpression;
    [CompilerGeneratedAttribute]
private int _ThisExpression;
    [CompilerGeneratedAttribute]
private Nullable`1<int> _ThrowExpression;
    [CompilerGeneratedAttribute]
private int _TupleExpression;
    [CompilerGeneratedAttribute]
private int _EndOfFileToken;
    [CompilerGeneratedAttribute]
private int _AwaitKeyword;
    [CompilerGeneratedAttribute]
private int _AsyncKeyword;
    [CompilerGeneratedAttribute]
private int _IdentifierToken;
    [CompilerGeneratedAttribute]
private int _GlobalKeyword;
    [CompilerGeneratedAttribute]
private int _IncompleteMember;
    [CompilerGeneratedAttribute]
private int _HashToken;
    [CompilerGeneratedAttribute]
private int _ExpressionStatement;
    [CompilerGeneratedAttribute]
private int _ForEachStatement;
    [CompilerGeneratedAttribute]
private int _LocalDeclarationStatement;
    [CompilerGeneratedAttribute]
private Nullable`1<int> _LocalFunctionStatement;
    [CompilerGeneratedAttribute]
private int _LockStatement;
    [CompilerGeneratedAttribute]
private int _ReturnStatement;
    [CompilerGeneratedAttribute]
private int _ThrowStatement;
    [CompilerGeneratedAttribute]
private int _UsingStatement;
    [CompilerGeneratedAttribute]
private int _Attribute;
    [CompilerGeneratedAttribute]
private int _ClassDeclaration;
    [CompilerGeneratedAttribute]
private int _Parameter;
    [CompilerGeneratedAttribute]
private int _TypeConstraint;
    [CompilerGeneratedAttribute]
private int _VariableDeclarator;
    [CompilerGeneratedAttribute]
private int _FieldDeclaration;
    [CompilerGeneratedAttribute]
private int _ParameterList;
    [CompilerGeneratedAttribute]
private int _TypeArgumentList;
    [CompilerGeneratedAttribute]
private Nullable`1<int> _GlobalStatement;
    [CompilerGeneratedAttribute]
private int _EqualsValueClause;
    [CompilerGeneratedAttribute]
private int _Interpolation;
    [CompilerGeneratedAttribute]
private int _InterpolatedStringExpression;
    [CompilerGeneratedAttribute]
private int _InterpolatedStringText;
    public int ConflictMarkerTrivia { get; }
    public int DisabledTextTrivia { get; }
    public int EndOfLineTrivia { get; }
    public int SkippedTokensTrivia { get; }
    public int WhitespaceTrivia { get; }
    public int SingleLineCommentTrivia { get; }
    public Nullable`1<int> MultiLineCommentTrivia { get; }
    public int SingleLineDocCommentTrivia { get; }
    public Nullable`1<int> MultiLineDocCommentTrivia { get; }
    public Nullable`1<int> ShebangDirectiveTrivia { get; }
    public int CloseBraceToken { get; }
    public int ColonToken { get; }
    public int CharacterLiteralToken { get; }
    public int DotToken { get; }
    public int InterpolatedStringTextToken { get; }
    public int QuestionToken { get; }
    public int StringLiteralToken { get; }
    public int IfKeyword { get; }
    public int GenericName { get; }
    public int IdentifierName { get; }
    public int QualifiedName { get; }
    public int TupleType { get; }
    public int CharacterLiteralExpression { get; }
    public int DefaultLiteralExpression { get; }
    public int FalseLiteralExpression { get; }
    public int NullLiteralExpression { get; }
    public int NumericLiteralExpression { get; }
    public int StringLiteralExpression { get; }
    public int TrueLiteralExpression { get; }
    public int AnonymousObjectCreationExpression { get; }
    public int AwaitExpression { get; }
    public int BaseExpression { get; }
    public int ConditionalAccessExpression { get; }
    public int ConditionalExpression { get; }
    public Nullable`1<int> ImplicitObjectCreationExpression { get; }
    public int InvocationExpression { get; }
    public int LogicalAndExpression { get; }
    public int LogicalOrExpression { get; }
    public int LogicalNotExpression { get; }
    public int ObjectCreationExpression { get; }
    public int ParenthesizedExpression { get; }
    public int QueryExpression { get; }
    public int ReferenceEqualsExpression { get; }
    public int ReferenceNotEqualsExpression { get; }
    public int SimpleMemberAccessExpression { get; }
    public int TernaryConditionalExpression { get; }
    public int ThisExpression { get; }
    public Nullable`1<int> ThrowExpression { get; }
    public int TupleExpression { get; }
    public int EndOfFileToken { get; }
    public int AwaitKeyword { get; }
    public int AsyncKeyword { get; }
    public int IdentifierToken { get; }
    public int GlobalKeyword { get; }
    public int IncompleteMember { get; }
    public int HashToken { get; }
    public int ExpressionStatement { get; }
    public int ForEachStatement { get; }
    public int LocalDeclarationStatement { get; }
    public Nullable`1<int> LocalFunctionStatement { get; }
    public int LockStatement { get; }
    public int ReturnStatement { get; }
    public int ThrowStatement { get; }
    public int UsingStatement { get; }
    public int Attribute { get; }
    public int ClassDeclaration { get; }
    public int Parameter { get; }
    public int TypeConstraint { get; }
    public int VariableDeclarator { get; }
    public int FieldDeclaration { get; }
    public int ParameterList { get; }
    public int TypeArgumentList { get; }
    public Nullable`1<int> GlobalStatement { get; }
    public int EqualsValueClause { get; }
    public int Interpolation { get; }
    public int InterpolatedStringExpression { get; }
    public int InterpolatedStringText { get; }
    private static VisualBasicSyntaxKinds();
    public sealed virtual override TSyntaxKind Convert(int kind);
    [CompilerGeneratedAttribute]
public sealed virtual override int get_ConflictMarkerTrivia();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_DisabledTextTrivia();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_EndOfLineTrivia();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_SkippedTokensTrivia();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_WhitespaceTrivia();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_SingleLineCommentTrivia();
    [CompilerGeneratedAttribute]
public sealed virtual override Nullable`1<int> get_MultiLineCommentTrivia();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_SingleLineDocCommentTrivia();
    [CompilerGeneratedAttribute]
public sealed virtual override Nullable`1<int> get_MultiLineDocCommentTrivia();
    [CompilerGeneratedAttribute]
public sealed virtual override Nullable`1<int> get_ShebangDirectiveTrivia();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_CloseBraceToken();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_ColonToken();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_CharacterLiteralToken();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_DotToken();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_InterpolatedStringTextToken();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_QuestionToken();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_StringLiteralToken();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_IfKeyword();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_GenericName();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_IdentifierName();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_QualifiedName();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_TupleType();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_CharacterLiteralExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_DefaultLiteralExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_FalseLiteralExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_NullLiteralExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_NumericLiteralExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_StringLiteralExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_TrueLiteralExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_AnonymousObjectCreationExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_AwaitExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_BaseExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_ConditionalAccessExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_ConditionalExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override Nullable`1<int> get_ImplicitObjectCreationExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_InvocationExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_LogicalAndExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_LogicalOrExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_LogicalNotExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_ObjectCreationExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_ParenthesizedExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_QueryExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_ReferenceEqualsExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_ReferenceNotEqualsExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_SimpleMemberAccessExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_TernaryConditionalExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_ThisExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override Nullable`1<int> get_ThrowExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_TupleExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_EndOfFileToken();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_AwaitKeyword();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_AsyncKeyword();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_IdentifierToken();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_GlobalKeyword();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_IncompleteMember();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_HashToken();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_ExpressionStatement();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_ForEachStatement();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_LocalDeclarationStatement();
    [CompilerGeneratedAttribute]
public sealed virtual override Nullable`1<int> get_LocalFunctionStatement();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_LockStatement();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_ReturnStatement();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_ThrowStatement();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_UsingStatement();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_Attribute();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_ClassDeclaration();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_Parameter();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_TypeConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_VariableDeclarator();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_FieldDeclaration();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_ParameterList();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_TypeArgumentList();
    [CompilerGeneratedAttribute]
public sealed virtual override Nullable`1<int> get_GlobalStatement();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_EqualsValueClause();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_Interpolation();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_InterpolatedStringExpression();
    [CompilerGeneratedAttribute]
public sealed virtual override int get_InterpolatedStringText();
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.LanguageServices.ISyntaxKindsService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.LanguageServices.VisualBasicSyntaxKindsServiceFactory : object {
    public sealed virtual override ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.IMoveDeclarationNearReferenceService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.MoveDeclarationNearReference.VisualBasicMoveDeclarationNearReferenceService : AbstractMoveDeclarationNearReferenceService`4<VisualBasicMoveDeclarationNearReferenceService, StatementSyntax, LocalDeclarationStatementSyntax, VariableDeclaratorSyntax> {
    protected virtual bool IsMeaningfulBlock(SyntaxNode node);
    protected virtual SyntaxNode GetVariableDeclaratorSymbolNode(VariableDeclaratorSyntax variableDeclarator);
    protected virtual bool IsValidVariableDeclarator(VariableDeclaratorSyntax variableDeclarator);
    protected virtual SyntaxToken GetIdentifierOfVariableDeclarator(VariableDeclaratorSyntax variableDeclarator);
    protected virtual Task`1<bool> TypesAreCompatibleAsync(Document document, ILocalSymbol localSymbol, LocalDeclarationStatementSyntax declarationStatement, SyntaxNode right, CancellationToken cancellationToken);
    protected virtual bool CanMoveToBlock(ILocalSymbol localSymbol, SyntaxNode currentBlock, SyntaxNode destinationBlock);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.OrganizeImports.IOrganizeImportsService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.OrganizeImports.VisualBasicOrganizeImportsService : object {
    public string SortImportsDisplayStringWithAccelerator { get; }
    public string SortAndRemoveUnusedImportsDisplayStringWithAccelerator { get; }
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.OrganizeImports.VisualBasicOrganizeImportsService/VB$StateMachine_2_OrganizeImportsAsync")]
public sealed virtual override Task`1<Document> OrganizeImportsAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual override string get_SortImportsDisplayStringWithAccelerator();
    public sealed virtual override string get_SortAndRemoveUnusedImportsDisplayStringWithAccelerator();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Precedence.VisualBasicPrecedenceService : AbstractPrecedenceService`2<ExpressionSyntax, OperatorPrecedence> {
    public static VisualBasicPrecedenceService Instance;
    private static VisualBasicPrecedenceService();
    public virtual OperatorPrecedence GetOperatorPrecedence(ExpressionSyntax expression);
    public virtual PrecedenceKind GetPrecedenceKind(OperatorPrecedence operatorPrecedence);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.ReassignedVariable.IReassignedVariableService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.ReassignedVariable.VisualBasicReassignedVariableService : AbstractReassignedVariableService`4<ParameterSyntax, ModifiedIdentifierSyntax, ModifiedIdentifierSyntax, IdentifierNameSyntax> {
    protected virtual SyntaxToken GetIdentifierOfVariable(ModifiedIdentifierSyntax variable);
    protected virtual SyntaxToken GetIdentifierOfSingleVariableDesignation(ModifiedIdentifierSyntax variable);
    protected virtual SyntaxNode GetMemberBlock(SyntaxNode methodOrPropertyDeclaration);
    protected virtual bool HasInitializer(SyntaxNode variable);
    protected virtual SyntaxNode GetParentScope(SyntaxNode localDeclaration);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Recommendations.IRecommendationService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Recommendations.VisualBasicRecommendationService : AbstractRecommendationService`1<VisualBasicSyntaxContext> {
    protected virtual VisualBasicSyntaxContext CreateContext(Document document, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    protected virtual AbstractRecommendationServiceRunner`1<VisualBasicSyntaxContext> CreateRunner(VisualBasicSyntaxContext context, bool filterOutOfScopeLocals, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Recommendations.VisualBasicRecommendationServiceRunner : AbstractRecommendationServiceRunner`1<VisualBasicSyntaxContext> {
    public VisualBasicRecommendationServiceRunner(VisualBasicSyntaxContext context, bool filterOutOfScopeLocals, CancellationToken cancellationToken);
    public virtual RecommendedSymbols GetRecommendedSymbols();
    private ImmutableArray`1<ISymbol> GetSymbols();
    public virtual bool TryGetExplicitTypeOfLambdaParameter(SyntaxNode lambdaSyntax, int ordinalInLambda, ITypeSymbol& explicitLambdaParameterType);
    private bool IsWritableFieldOrLocal(ISymbol symbol);
    private ImmutableArray`1<ISymbol> GetSymbolsForGlobalStatementContext();
    private ImmutableArray`1<ISymbol> GetUnqualifiedSymbolsForQueryIntoContext();
    private ImmutableArray`1<ISymbol> GetUnqualifiedSymbolsForLabelContext();
    private ImmutableArray`1<ISymbol> GetUnqualifiedSymbolsForRaiseEvent();
    private ImmutableArray`1<ISymbol> GetUnqualifiedSymbolsForType();
    private ImmutableArray`1<ISymbol> GetUnqualifiedSymbolsForExpressionOrStatementContext();
    private static bool IsInEligibleDelegate(ISymbol s);
    private ImmutableArray`1<ISymbol> GetSymbolsForQualifiedNameSyntax(QualifiedNameSyntax node);
    private ImmutableArray`1<ISymbol> GetSymbolsForMemberAccessExpression(MemberAccessExpressionSyntax node);
    private static bool ContainsNamespaceCandidateSymbols(SymbolInfo symbolInfo);
    private bool FilterEventsAndGeneratedSymbols(MemberAccessExpressionSyntax node, ISymbol s);
    private IMethodSymbol GetEnclosingCtor(MemberAccessExpressionSyntax node);
    private ImmutableArray`1<ISymbol> FilterToValidAccessibleSymbols(ImmutableArray`1<ISymbol> symbols);
    private static bool IsInheritsStatementContext(SyntaxToken token);
    private static bool IsImplementsStatementContext(SyntaxToken token);
    private bool IsValidAccessibleInterfaceOrContainer(ISymbol symbol, ISymbol within);
    private bool IsOrContainsValidAccessibleInterface(INamespaceOrTypeSymbol namespaceOrTypeSymbol, ISymbol within);
    private bool IsValidAccessibleClassOrContainer(ISymbol symbol, ISymbol within);
    private bool IsOrContainsValidAccessibleClass(INamespaceOrTypeSymbol namespaceOrTypeSymbol, ISymbol within);
    [CompilerGeneratedAttribute]
private bool _Lambda$__10-0(ISymbol symbol);
    [CompilerGeneratedAttribute]
private bool _Lambda$__10-2(ISymbol s);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.RemoveUnnecessaryImports.IRemoveUnnecessaryImportsService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessaryImports.VisualBasicRemoveUnnecessaryImportsService : AbstractRemoveUnnecessaryImportsService`1<ImportsClauseSyntax> {
    protected IUnnecessaryImportsProvider UnnecessaryImportsProvider { get; }
    protected virtual IUnnecessaryImportsProvider get_UnnecessaryImportsProvider();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessaryImports.VisualBasicRemoveUnnecessaryImportsService/VB$StateMachine_4_RemoveUnnecessaryImportsAsync")]
public virtual Task`1<Document> RemoveUnnecessaryImportsAsync(Document document, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.RemoveUnnecessaryImports.VisualBasicUnnecessaryImportsProvider : AbstractUnnecessaryImportsProvider`1<ImportsClauseSyntax> {
    public static VisualBasicUnnecessaryImportsProvider Instance;
    private static VisualBasicUnnecessaryImportsProvider();
    protected virtual ImmutableArray`1<SyntaxNode> GetUnnecessaryImports(SemanticModel model, SyntaxNode root, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
    private static void AddRedundantImports(CompilationUnitSyntax compilationUnit, SemanticModel semanticModel, HashSet`1<SyntaxNode> unnecessaryImports, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
    private static void AddRedundantAliasImportsClause(SimpleImportsClauseSyntax clause, SemanticModel semanticModel, HashSet`1<SyntaxNode> unnecessaryImports, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
    private static void AddRedundantMemberImportsClause(SimpleImportsClauseSyntax clause, SemanticModel semanticModel, HashSet`1<SyntaxNode> unnecessaryImports, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Rename.LabelConflictVisitor : VisualBasicSyntaxVisitor {
    private ConflictingIdentifierTracker _tracker;
    public IEnumerable`1<SyntaxToken> ConflictingTokens { get; }
    public LabelConflictVisitor(SyntaxToken tokenBeingRenamed);
    public virtual void DefaultVisit(SyntaxNode node);
    public virtual void VisitLabelStatement(LabelStatementSyntax node);
    public virtual void VisitSingleLineLambdaExpression(SingleLineLambdaExpressionSyntax node);
    public virtual void VisitMultiLineLambdaExpression(MultiLineLambdaExpressionSyntax node);
    public IEnumerable`1<SyntaxToken> get_ConflictingTokens();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Rename.LocalConflictVisitor : VisualBasicSyntaxVisitor {
    private ConflictingIdentifierTracker _tracker;
    private Solution _newSolution;
    private CancellationToken _cancellationToken;
    public IEnumerable`1<SyntaxToken> ConflictingTokens { get; }
    public LocalConflictVisitor(SyntaxToken tokenBeingRenamed, Solution newSolution, CancellationToken cancellationToken);
    public virtual void DefaultVisit(SyntaxNode node);
    private void VisitMethodBlockBase(MethodBlockBaseSyntax node);
    public virtual void VisitMethodBlock(MethodBlockSyntax node);
    public virtual void VisitConstructorBlock(ConstructorBlockSyntax node);
    public virtual void VisitOperatorBlock(OperatorBlockSyntax node);
    public virtual void VisitAccessorBlock(AccessorBlockSyntax node);
    public virtual void VisitQueryExpression(QueryExpressionSyntax node);
    private void VisitBlock(SyntaxList`1<StatementSyntax> block);
    public virtual void VisitSingleLineLambdaExpression(SingleLineLambdaExpressionSyntax node);
    public virtual void VisitMultiLineLambdaExpression(MultiLineLambdaExpressionSyntax node);
    public virtual void VisitForBlock(ForBlockSyntax node);
    public virtual void VisitForEachBlock(ForEachBlockSyntax node);
    private void VisitForOrForEachBlock(ForOrForEachBlockSyntax node);
    public virtual void VisitUsingBlock(UsingBlockSyntax node);
    public virtual void VisitCatchBlock(CatchBlockSyntax node);
    public IEnumerable`1<SyntaxToken> get_ConflictingTokens();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Rename.VisualBasicRenameRewriterLanguageService : AbstractRenameRewriterLanguageService {
    public static VisualBasicRenameRewriterLanguageService Instance;
    private static VisualBasicRenameRewriterLanguageService();
    public virtual SyntaxNode AnnotateAndRename(RenameRewriterParameters parameters);
    public virtual bool LocalVariableConflict(SyntaxToken token, IEnumerable`1<ISymbol> newReferencedSymbols);
    public virtual Task`1<ImmutableArray`1<Location>> ComputeDeclarationConflictsAsync(string replacementText, ISymbol renamedSymbol, ISymbol renameSymbol, IEnumerable`1<ISymbol> referencedSymbols, Solution baseSolution, Solution newSolution, IDictionary`2<Location, Location> reverseMappedLocations, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.Rename.VisualBasicRenameRewriterLanguageService/VB$StateMachine_7_ComputeImplicitReferenceConflictsAsync")]
public virtual Task`1<ImmutableArray`1<Location>> ComputeImplicitReferenceConflictsAsync(ISymbol renameSymbol, ISymbol renamedSymbol, IEnumerable`1<ReferenceLocation> implicitReferenceLocations, CancellationToken cancellationToken);
    public virtual SyntaxNode GetExpansionTargetForLocation(SyntaxToken token);
    private static SyntaxNode GetExpansionTarget(SyntaxToken token);
    public virtual bool IsIdentifierValid(string replacementText, ISyntaxFactsService syntaxFactsService);
    public virtual ImmutableArray`1<Location> ComputePossibleImplicitUsageConflicts(ISymbol renamedSymbol, SemanticModel semanticModel, Location originalDeclarationLocation, int newDeclarationLocationStartingPosition, CancellationToken cancellationToken);
    public virtual void TryAddPossibleNameConflicts(ISymbol symbol, string replacementText, ICollection`1<string> possibleNameConflicts);
    public static SemanticModel GetSemanticModelForNode(SyntaxNode node, SemanticModel originalSemanticModel);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Rename.VisualBasicRenameRewriterLanguageServiceFactory : object {
    public sealed virtual override ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.SemanticModelReuse.ISemanticModelReuseLanguageService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.SemanticModelReuse.VisualBasicSemanticModelReuseLanguageService : AbstractSemanticModelReuseLanguageService`4<DeclarationStatementSyntax, MethodBlockBaseSyntax, DeclarationStatementSyntax, AccessorBlockSyntax> {
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFacts;
    protected ISyntaxFacts SyntaxFacts { get; }
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFacts();
    protected virtual DeclarationStatementSyntax GetBasePropertyDeclaration(AccessorBlockSyntax accessor);
    protected virtual SyntaxList`1<AccessorBlockSyntax> GetAccessors(DeclarationStatementSyntax member);
    public virtual SyntaxNode TryGetContainingMethodBodyForSpeculation(SyntaxNode node);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.VisualBasic.SemanticModelReuse.VisualBasicSemanticModelReuseLanguageService/VB$StateMachine_7_TryGetSpeculativeSemanticModelWorkerAsync")]
protected virtual Task`1<SemanticModel> TryGetSpeculativeSemanticModelWorkerAsync(SemanticModel previousSemanticModel, SyntaxNode currentBodyNode, CancellationToken cancellationToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Serialization.IOptionsSerializationService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Serialization.VisualBasicOptionsSerializationService : AbstractOptionsSerializationService {
    public virtual void WriteTo(CompilationOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    public virtual void WriteTo(ParseOptions options, ObjectWriter writer);
    public virtual CompilationOptions ReadCompilationOptionsFrom(ObjectReader reader, CancellationToken cancellationToken);
    public virtual ParseOptions ReadParseOptionsFrom(ObjectReader reader, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Simplification.AbstractVisualBasicReducer : AbstractReducer {
    protected static Func`5<ParenthesizedExpressionSyntax, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_reduceParentheses;
    private static AbstractVisualBasicReducer();
    protected AbstractVisualBasicReducer(ObjectPool`1<IReductionRewriter> pool);
    protected static SyntaxNode ReduceParentheses(ParenthesizedExpressionSyntax node, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Simplification.Simplifiers.AbstractVisualBasicSimplifier`2 : AbstractSimplifier`2<TSyntax, TSimplifiedSyntax> {
    protected static SyntaxKind GetPredefinedKeywordKind(SpecialType type);
    protected static bool TryReplaceWithAlias(ExpressionSyntax node, SemanticModel semanticModel, IAliasSymbol& aliasReplacement);
    private static bool IsAliasReplaceableExpression(ExpressionSyntax expression);
    private static bool ValidateAliasForTarget(IAliasSymbol aliasReplacement, SemanticModel semanticModel, ExpressionSyntax node, ISymbol symbol);
    protected static bool PreferPredefinedTypeKeywordInMemberAccess(ExpressionSyntax expression, OptionSet optionSet);
    protected static bool InsideNameOfExpression(ExpressionSyntax expr);
    private static bool IsInCrefReferenceForPredefinedTypeInMemberAccessContext(ExpressionSyntax expression);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Simplification.Simplifiers.ExpressionSimplifier : AbstractVisualBasicSimplifier`2<ExpressionSyntax, ExpressionSyntax> {
    public static ExpressionSimplifier Instance;
    private static ExpressionSimplifier();
    public virtual bool TrySimplify(ExpressionSyntax expression, SemanticModel semanticModel, OptionSet optionSet, ExpressionSyntax& replacementNode, TextSpan& issueSpan, CancellationToken cancellationToken);
    private static bool TryReduceExplicitName(ExpressionSyntax expression, SemanticModel semanticModel, ExpressionSyntax& replacementNode, TextSpan& issueSpan, OptionSet optionSet, CancellationToken cancellationToken);
    private static bool TryReduce(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel, ExpressionSyntax& replacementNode, TextSpan& issueSpan, OptionSet optionSet, CancellationToken cancellationToken);
    private static bool TrySimplify(ExpressionSyntax expression, SemanticModel semanticModel, ExpressionSyntax& replacementNode, TextSpan& issueSpan);
    private static bool ReplacementChangesSemantics(ExpressionSyntax originalExpression, ExpressionSyntax replacedExpression, SemanticModel semanticModel);
    private static bool TrySimplifyMemberAccessOrQualifiedName(ExpressionSyntax left, ExpressionSyntax right, SemanticModel semanticModel, ExpressionSyntax& replacementNode, TextSpan& issueSpan);
    private static bool TryOmitModuleName(MemberAccessExpressionSyntax memberAccess, SemanticModel semanticModel, ISymbol symbol, ExpressionSyntax& replacementNode, TextSpan& issueSpan, CancellationToken cancellationToken);
    private static bool CanReplaceWithReducedName(MemberAccessExpressionSyntax memberAccess, ExpressionSyntax reducedNode, SemanticModel semanticModel, ISymbol symbol, CancellationToken cancellationToken);
    private static bool IsMeOrNamedTypeOrNamespace(ExpressionSyntax expression, SemanticModel semanticModel);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Simplification.Simplifiers.NameSimplifier : AbstractVisualBasicSimplifier`2<NameSyntax, ExpressionSyntax> {
    public static NameSimplifier Instance;
    private static NameSimplifier();
    public virtual bool TrySimplify(NameSyntax name, SemanticModel semanticModel, OptionSet optionSet, ExpressionSyntax& replacementNode, TextSpan& issueSpan, CancellationToken cancellationToken);
    private static bool IsPartOfNamespaceDeclarationName(SyntaxNode node);
    private static bool CanReplaceWithReducedName(NameSyntax name, ExpressionSyntax replacementNode, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool CanReplaceWithReducedNameInContext(NameSyntax name, ExpressionSyntax replacementNode);
    private static bool IsNonNameSyntaxInImportsDirective(ExpressionSyntax expression, ExpressionSyntax simplifiedNode);
    private static bool IsNullableTypeSyntaxLeftOfDotInMemberAccess(ExpressionSyntax expression, ExpressionSyntax simplifiedNode);
    private static bool TryOmitModuleName(QualifiedNameSyntax name, SemanticModel semanticModel, ExpressionSyntax& replacementNode, TextSpan& issueSpan, CancellationToken cancellationToken);
    private static bool TryReduceAttributeSuffix(NameSyntax name, SyntaxToken identifierToken, SemanticModel semanticModel, bool isIdentifierNameFromAlias, ExpressionSyntax& replacementNode, TextSpan& issueSpan, CancellationToken cancellationToken);
    private static bool PreferPredefinedTypeKeywordInDeclarations(NameSyntax name, OptionSet optionSet);
    private static bool CanSimplifyNullable(INamedTypeSymbol type, NameSyntax name);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Simplification.VisualBasicCallReducer : AbstractVisualBasicReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<CallStatementSyntax, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_simplifyCallStatement;
    private static VisualBasicCallReducer();
    private static ExecutableStatementSyntax SimplifyCallStatement(CallStatementSyntax callStatement, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Simplification.VisualBasicCastReducer : AbstractVisualBasicReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<CastExpressionSyntax, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_simplifyCast;
    private static Func`5<PredefinedCastExpressionSyntax, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_simplifyPredefinedCast;
    private static VisualBasicCastReducer();
    private static ExpressionSyntax SimplifyCast(CastExpressionSyntax node, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    private static ExpressionSyntax SimplifyPredefinedCast(PredefinedCastExpressionSyntax node, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Simplification.VisualBasicEscapingReducer : AbstractVisualBasicReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static VisualBasicEscapingReducer();
    private static SyntaxToken TryUnescapeToken(SyntaxToken identifier, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    private static SyntaxToken CreateNewIdentifierTokenFromToken(SyntaxToken originalToken, bool escape);
    private static bool IsPreserveInReDim(SimpleNameSyntax node);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Simplification.VisualBasicExtensionMethodReducer : AbstractVisualBasicReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<InvocationExpressionSyntax, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_simplifyInvocationExpression;
    private static VisualBasicExtensionMethodReducer();
    private static InvocationExpressionSyntax SimplifyInvocationExpression(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Simplification.VisualBasicInferredMemberNameReducer : AbstractVisualBasicReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static VisualBasicInferredMemberNameReducer();
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Simplification.VisualBasicInferredMemberNameSimplifier : object {
    internal static bool CanSimplifyTupleName(SimpleArgumentSyntax node, VisualBasicParseOptions parseOptions);
    internal static bool CanSimplifyNamedFieldInitializer(NamedFieldInitializerSyntax node);
    private static bool RemovalCausesAmbiguity(SeparatedSyntaxList`1<SimpleArgumentSyntax> arguments, SimpleArgumentSyntax toRemove);
    private static bool RemovalCausesAmbiguity(SeparatedSyntaxList`1<FieldInitializerSyntax> initializers, NamedFieldInitializerSyntax toRemove);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Simplification.VisualBasicMiscellaneousReducer : AbstractVisualBasicReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<ParameterSyntax, SemanticModel, OptionSet, CancellationToken, ParameterSyntax> s_simplifyParameter;
    private static Func`5<InvocationExpressionSyntax, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_simplifyInvocationExpression;
    private static Func`5<ObjectCreationExpressionSyntax, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_simplifyObjectCreationExpression;
    private static VisualBasicMiscellaneousReducer();
    private static ParameterSyntax SimplifyParameter(ParameterSyntax parameter, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    private static InvocationExpressionSyntax SimplifyInvocationExpression(InvocationExpressionSyntax invocationExpression, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    private static ObjectCreationExpressionSyntax SimplifyObjectCreationExpression(ObjectCreationExpressionSyntax objectCreationExpression, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Simplification.VisualBasicNameReducer : AbstractVisualBasicReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<ExpressionSyntax, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_simplifyName;
    private static VisualBasicNameReducer();
    private static ExpressionSyntax SimplifyName(ExpressionSyntax node, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Simplification.VisualBasicParenthesesReducer : AbstractVisualBasicReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static VisualBasicParenthesesReducer();
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Simplification.VisualBasicSimplificationHelpers : object {
    public static SyntaxToken TryEscapeIdentifierToken(SyntaxToken identifierToken);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Simplification.ISimplificationService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Simplification.VisualBasicSimplificationService : AbstractSimplificationService`3<ExpressionSyntax, ExecutableStatementSyntax, CrefReferenceSyntax> {
    private static ImmutableArray`1<AbstractReducer> s_reducers;
    private static string s_BC50000_UnusedImportsClause;
    private static string s_BC50001_UnusedImportsStatement;
    private static VisualBasicSimplificationService();
    public virtual SyntaxNode Expand(SyntaxNode node, SemanticModel semanticModel, SyntaxAnnotation aliasReplacementAnnotation, Func`2<SyntaxNode, bool> expandInsideNode, bool expandParameter, CancellationToken cancellationToken);
    public virtual SyntaxToken Expand(SyntaxToken token, SemanticModel semanticModel, Func`2<SyntaxNode, bool> expandInsideNode, CancellationToken cancellationToken);
    protected virtual SemanticModel GetSpeculativeSemanticModel(SyntaxNode& nodeToSpeculate, SemanticModel originalSemanticModel, SyntaxNode originalNode);
    protected virtual SyntaxNode TransformReducedNode(SyntaxNode reducedNode, SyntaxNode originalNode);
    protected virtual ImmutableArray`1<NodeOrTokenToReduce> GetNodesAndTokensToReduce(SyntaxNode root, Func`2<SyntaxNodeOrToken, bool> isNodeOrTokenOutsideSimplifySpans);
    protected virtual bool CanNodeBeSimplifiedWithoutSpeculation(SyntaxNode node);
    protected virtual void GetUnusedNamespaceImports(SemanticModel model, HashSet`1<SyntaxNode> namespaceImports, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Simplification.VisualBasicVariableDeclaratorReducer : AbstractVisualBasicReducer {
    private static ObjectPool`1<IReductionRewriter> s_pool;
    private static Func`5<VariableDeclaratorSyntax, SemanticModel, OptionSet, CancellationToken, SyntaxNode> s_simplifyVariableDeclarator;
    private static VisualBasicVariableDeclaratorReducer();
    private static SyntaxNode SimplifyVariableDeclarator(VariableDeclaratorSyntax node, SemanticModel semanticModel, OptionSet optionSet, CancellationToken cancellationToken);
    private static bool TryReduceVariableDeclaratorWithoutType(VariableDeclaratorSyntax variableDeclarator, SemanticModel semanticModel, SyntaxNode& replacementNode, TextSpan& issueSpan);
    private static bool HasValidDeclaredTypeSymbol(ModifiedIdentifierSyntax modifiedIdentifier, SemanticModel semanticModel, ITypeSymbol& typeSymbol);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.DirectiveSyntaxEqualityComparer : object {
    public static DirectiveSyntaxEqualityComparer Instance;
    private static DirectiveSyntaxEqualityComparer();
    public sealed virtual override bool Equals(DirectiveTriviaSyntax x, DirectiveTriviaSyntax y);
    public sealed virtual override int GetHashCode(DirectiveTriviaSyntax obj);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.DirectiveWalker : VisualBasicSyntaxWalker {
    private Dictionary`2<DirectiveTriviaSyntax, DirectiveTriviaSyntax> _startEndMap;
    private Dictionary`2<DirectiveTriviaSyntax, IReadOnlyList`1<DirectiveTriviaSyntax>> _conditionalMap;
    private CancellationToken _cancellationToken;
    private Stack`1<DirectiveTriviaSyntax> _regionStack;
    private Stack`1<DirectiveTriviaSyntax> _ifStack;
    public DirectiveWalker(Dictionary`2<DirectiveTriviaSyntax, DirectiveTriviaSyntax> startEndMap, Dictionary`2<DirectiveTriviaSyntax, IReadOnlyList`1<DirectiveTriviaSyntax>> conditionalMap, CancellationToken cancellationToken);
    public virtual void DefaultVisit(SyntaxNode node);
    public virtual void VisitToken(SyntaxToken token);
    public virtual void VisitIfDirectiveTrivia(IfDirectiveTriviaSyntax directive);
    public virtual void VisitElseDirectiveTrivia(ElseDirectiveTriviaSyntax directive);
    public virtual void VisitRegionDirectiveTrivia(RegionDirectiveTriviaSyntax directive);
    public virtual void VisitEndIfDirectiveTrivia(EndIfDirectiveTriviaSyntax directive);
    private void FinishIf(EndIfDirectiveTriviaSyntax directiveOpt);
    public virtual void VisitEndRegionDirectiveTrivia(EndRegionDirectiveTriviaSyntax directive);
    internal void Finish();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.ImportsClauseComparer : object {
    public static IComparer`1<ImportsClauseSyntax> NormalInstance;
    private IComparer`1<NameSyntax> _nameComparer;
    private IComparer`1<SyntaxToken> _tokenComparer;
    private static ImportsClauseComparer();
    public ImportsClauseComparer(IComparer`1<SyntaxToken> tokenComparer);
    internal sealed virtual override int Compare(ImportsClauseSyntax x, ImportsClauseSyntax y);
    private int CompareXmlNames(XmlNameSyntax xmlName1, XmlNameSyntax xmlName2);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.ImportsOrganizer : object {
    private static SyntaxTrivia s_newLine;
    private static ImportsOrganizer();
    public static SyntaxList`1<ImportsStatementSyntax> Organize(SyntaxList`1<ImportsStatementSyntax> imports, bool placeSystemNamespaceFirst, bool separateGroups);
    public static bool NeedsGrouping(ImportsStatementSyntax import1, ImportsStatementSyntax import2);
    public static SyntaxList`1<ImportsStatementSyntax> OrganizeWorker(SyntaxList`1<ImportsStatementSyntax> imports, bool placeSystemNamespaceFirst);
    private static void EnsureNewLines(List`1<ImportsStatementSyntax> list);
    private static SyntaxTrivia GetExistingEndOfLineTrivia(List`1<ImportsStatementSyntax> list);
    public static SeparatedSyntaxList`1<ImportsClauseSyntax> Organize(SeparatedSyntaxList`1<ImportsClauseSyntax> clauses);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.ImportsStatementComparer : object {
    public static IComparer`1<ImportsStatementSyntax> SystemFirstInstance;
    public static IComparer`1<ImportsStatementSyntax> NormalInstance;
    private IComparer`1<ImportsClauseSyntax> _importsClauseComparer;
    private static ImportsStatementComparer();
    public ImportsStatementComparer(IComparer`1<SyntaxToken> tokenComparer);
    public sealed virtual override int Compare(ImportsStatementSyntax directive1, ImportsStatementSyntax directive2);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Utilities.IntrinsicOperators.AbstractAddRemoveHandlerStatementDocumentation : AbstractIntrinsicOperatorDocumentation {
    public bool IncludeAsType { get; }
    public int ParameterCount { get; }
    public virtual string GetParameterName(int index);
    public virtual bool get_IncludeAsType();
    public sealed virtual int get_ParameterCount();
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Utilities.IntrinsicOperators.AbstractCastExpressionDocumentation : AbstractIntrinsicOperatorDocumentation {
    public bool IncludeAsType { get; }
    public int ParameterCount { get; }
    public virtual string GetParameterDocumentation(int index);
    public virtual string GetParameterName(int index);
    public virtual bool get_IncludeAsType();
    public sealed virtual int get_ParameterCount();
    public virtual TypeSyntax TryGetTypeNameParameter(SyntaxNode syntaxNode, int index);
}
internal abstract class Microsoft.CodeAnalysis.VisualBasic.Utilities.IntrinsicOperators.AbstractIntrinsicOperatorDocumentation : object {
    public string DocumentationText { get; }
    public int ParameterCount { get; }
    public bool IncludeAsType { get; }
    public string ReturnTypeMetadataName { get; }
    public IList`1<SymbolDisplayPart> PrefixParts { get; }
    public abstract virtual string get_DocumentationText();
    public abstract virtual int get_ParameterCount();
    public abstract virtual bool get_IncludeAsType();
    public virtual string get_ReturnTypeMetadataName();
    public abstract virtual IList`1<SymbolDisplayPart> get_PrefixParts();
    public abstract virtual string GetParameterName(int index);
    public abstract virtual string GetParameterDocumentation(int index);
    public virtual IList`1<SymbolDisplayPart> GetParameterDisplayParts(int index);
    public virtual TypeSyntax TryGetTypeNameParameter(SyntaxNode syntaxNode, int index);
    public virtual IList`1<SymbolDisplayPart> GetSuffix(SemanticModel semanticModel, int position, SyntaxNode nodeToBind, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.IntrinsicOperators.AddHandlerStatementDocumentation : AbstractAddRemoveHandlerStatementDocumentation {
    public string DocumentationText { get; }
    public IList`1<SymbolDisplayPart> PrefixParts { get; }
    public virtual string get_DocumentationText();
    public virtual string GetParameterDocumentation(int index);
    public virtual IList`1<SymbolDisplayPart> get_PrefixParts();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.IntrinsicOperators.BinaryConditionalExpressionDocumentation : AbstractIntrinsicOperatorDocumentation {
    public string DocumentationText { get; }
    public bool IncludeAsType { get; }
    public int ParameterCount { get; }
    public IList`1<SymbolDisplayPart> PrefixParts { get; }
    public virtual string get_DocumentationText();
    public virtual string GetParameterDocumentation(int index);
    public virtual string GetParameterName(int index);
    public virtual bool get_IncludeAsType();
    public virtual int get_ParameterCount();
    public virtual IList`1<SymbolDisplayPart> get_PrefixParts();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.IntrinsicOperators.CTypeCastExpressionDocumentation : AbstractCastExpressionDocumentation {
    public string DocumentationText { get; }
    public IList`1<SymbolDisplayPart> PrefixParts { get; }
    public virtual string get_DocumentationText();
    public virtual IList`1<SymbolDisplayPart> get_PrefixParts();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.IntrinsicOperators.DirectCastExpressionDocumentation : AbstractCastExpressionDocumentation {
    public string DocumentationText { get; }
    public IList`1<SymbolDisplayPart> PrefixParts { get; }
    public virtual string get_DocumentationText();
    public virtual IList`1<SymbolDisplayPart> get_PrefixParts();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.IntrinsicOperators.GetTypeExpressionDocumentation : AbstractIntrinsicOperatorDocumentation {
    public int ParameterCount { get; }
    public string DocumentationText { get; }
    public IList`1<SymbolDisplayPart> PrefixParts { get; }
    public bool IncludeAsType { get; }
    public string ReturnTypeMetadataName { get; }
    public virtual string GetParameterDocumentation(int index);
    public virtual string GetParameterName(int index);
    public virtual int get_ParameterCount();
    public virtual string get_DocumentationText();
    public virtual IList`1<SymbolDisplayPart> get_PrefixParts();
    public virtual bool get_IncludeAsType();
    public virtual TypeSyntax TryGetTypeNameParameter(SyntaxNode syntaxNode, int index);
    public virtual string get_ReturnTypeMetadataName();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.IntrinsicOperators.GetXmlNamespaceExpressionDocumentation : AbstractIntrinsicOperatorDocumentation {
    public int ParameterCount { get; }
    public string DocumentationText { get; }
    public IList`1<SymbolDisplayPart> PrefixParts { get; }
    public bool IncludeAsType { get; }
    public string ReturnTypeMetadataName { get; }
    public virtual IList`1<SymbolDisplayPart> GetParameterDisplayParts(int index);
    public virtual string GetParameterDocumentation(int index);
    public virtual string GetParameterName(int index);
    public virtual int get_ParameterCount();
    public virtual string get_DocumentationText();
    public virtual IList`1<SymbolDisplayPart> get_PrefixParts();
    public virtual bool get_IncludeAsType();
    public virtual string get_ReturnTypeMetadataName();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.IntrinsicOperators.MidAssignmentDocumentation : AbstractIntrinsicOperatorDocumentation {
    public string DocumentationText { get; }
    public bool IncludeAsType { get; }
    public int ParameterCount { get; }
    public IList`1<SymbolDisplayPart> PrefixParts { get; }
    public virtual string get_DocumentationText();
    public virtual string GetParameterDocumentation(int index);
    public virtual string GetParameterName(int index);
    public virtual IList`1<SymbolDisplayPart> GetParameterDisplayParts(int index);
    public virtual bool get_IncludeAsType();
    public virtual int get_ParameterCount();
    public virtual IList`1<SymbolDisplayPart> GetSuffix(SemanticModel semanticModel, int position, SyntaxNode nodeToBind, CancellationToken cancellationToken);
    public virtual IList`1<SymbolDisplayPart> get_PrefixParts();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.IntrinsicOperators.NameOfExpressionDocumentation : AbstractIntrinsicOperatorDocumentation {
    public string DocumentationText { get; }
    public bool IncludeAsType { get; }
    public int ParameterCount { get; }
    public IList`1<SymbolDisplayPart> PrefixParts { get; }
    public string ReturnTypeMetadataName { get; }
    public virtual string get_DocumentationText();
    public virtual bool get_IncludeAsType();
    public virtual int get_ParameterCount();
    public virtual IList`1<SymbolDisplayPart> get_PrefixParts();
    public virtual string GetParameterDocumentation(int index);
    public virtual string GetParameterName(int index);
    public virtual string get_ReturnTypeMetadataName();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.IntrinsicOperators.PredefinedCastExpressionDocumentation : AbstractIntrinsicOperatorDocumentation {
    private ITypeSymbol _resultingType;
    private string _keywordText;
    public string DocumentationText { get; }
    public bool IncludeAsType { get; }
    public int ParameterCount { get; }
    public IList`1<SymbolDisplayPart> PrefixParts { get; }
    public string ReturnTypeMetadataName { get; }
    public PredefinedCastExpressionDocumentation(SyntaxKind keywordKind, Compilation compilation);
    public virtual string get_DocumentationText();
    public virtual string GetParameterDocumentation(int index);
    public virtual string GetParameterName(int index);
    public virtual bool get_IncludeAsType();
    public virtual int get_ParameterCount();
    public virtual IList`1<SymbolDisplayPart> get_PrefixParts();
    public virtual string get_ReturnTypeMetadataName();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.IntrinsicOperators.RemoveHandlerStatementDocumentation : AbstractAddRemoveHandlerStatementDocumentation {
    public string DocumentationText { get; }
    public IList`1<SymbolDisplayPart> PrefixParts { get; }
    public virtual string get_DocumentationText();
    public virtual string GetParameterDocumentation(int index);
    public virtual IList`1<SymbolDisplayPart> get_PrefixParts();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.IntrinsicOperators.TernaryConditionalExpressionDocumentation : AbstractIntrinsicOperatorDocumentation {
    public string DocumentationText { get; }
    public bool IncludeAsType { get; }
    public int ParameterCount { get; }
    public IList`1<SymbolDisplayPart> PrefixParts { get; }
    public virtual string get_DocumentationText();
    public virtual IList`1<SymbolDisplayPart> GetParameterDisplayParts(int index);
    public virtual string GetParameterDocumentation(int index);
    public virtual string GetParameterName(int index);
    public virtual bool get_IncludeAsType();
    public virtual int get_ParameterCount();
    public virtual IList`1<SymbolDisplayPart> get_PrefixParts();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.IntrinsicOperators.TryCastExpressionDocumentation : AbstractCastExpressionDocumentation {
    public string DocumentationText { get; }
    public IList`1<SymbolDisplayPart> PrefixParts { get; }
    public virtual string get_DocumentationText();
    public virtual IList`1<SymbolDisplayPart> get_PrefixParts();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.ModifierCollectionFacts : object {
    private SyntaxToken _accessibilityKeyword;
    private SyntaxToken _asyncKeyword;
    private bool _hasProtectedAndFriend;
    private SyntaxToken _inheritenceKeyword;
    private SyntaxToken _iteratorKeyword;
    private SyntaxToken _overridableSharedOrPartialKeyword;
    private SyntaxToken _overridesOrShadowsKeyword;
    private SyntaxToken _narrowingOrWideningKeyword;
    private SyntaxToken _mutabilityOrWithEventsKeyword;
    private SyntaxToken _defaultKeyword;
    private SyntaxToken _overloadsKeyword;
    private SyntaxToken _customKeyword;
    private SyntaxToken _dimKeyword;
    private SyntaxToken _sharedKeyword;
    private PossibleDeclarationTypes _declarationTypes;
    public SyntaxToken AccessibilityKeyword { get; }
    public SyntaxToken AsyncKeyword { get; }
    public SyntaxToken IteratorKeyword { get; }
    public bool HasProtectedAndFriend { get; }
    public SyntaxToken OverridableSharedOrPartialKeyword { get; }
    public SyntaxToken OverridesOrShadowsKeyword { get; }
    public SyntaxToken InheritenceKeyword { get; }
    public SyntaxToken DefaultKeyword { get; }
    public SyntaxToken NarrowingOrWideningKeyword { get; }
    public SyntaxToken OverloadsKeyword { get; }
    public SyntaxToken MutabilityOrWithEventsKeyword { get; }
    public SyntaxToken CustomKeyword { get; }
    public SyntaxToken DimKeyword { get; }
    public SyntaxToken SharedKeyword { get; }
    public ModifierCollectionFacts(SyntaxTree syntaxTree, int position, SyntaxToken token, CancellationToken cancellationToken);
    public bool CouldApplyToOneOf(PossibleDeclarationTypes declarationTypes);
    public SyntaxToken get_AccessibilityKeyword();
    public SyntaxToken get_AsyncKeyword();
    public SyntaxToken get_IteratorKeyword();
    public bool get_HasProtectedAndFriend();
    public SyntaxToken get_OverridableSharedOrPartialKeyword();
    public SyntaxToken get_OverridesOrShadowsKeyword();
    public SyntaxToken get_InheritenceKeyword();
    public SyntaxToken get_DefaultKeyword();
    public SyntaxToken get_NarrowingOrWideningKeyword();
    public SyntaxToken get_OverloadsKeyword();
    public SyntaxToken get_MutabilityOrWithEventsKeyword();
    public SyntaxToken get_CustomKeyword();
    public SyntaxToken get_DimKeyword();
    public SyntaxToken get_SharedKeyword();
    private static PossibleDeclarationTypes ComputeAllowableDeclarationTypes(SyntaxTree syntaxTree, int position, SyntaxToken token, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.NameSyntaxComparer : object {
    private IComparer`1<SyntaxToken> _tokenComparer;
    internal TypeSyntaxComparer typeComparer;
    internal NameSyntaxComparer(IComparer`1<SyntaxToken> tokenComparer);
    public static IComparer`1<NameSyntax> Create();
    public static IComparer`1<NameSyntax> Create(IComparer`1<SyntaxToken> tokenComparer);
    public sealed virtual override int Compare(NameSyntax x, NameSyntax y);
    private IList`1<NameSyntax> DecomposeNameParts(NameSyntax name);
    private void DecomposeNameParts(NameSyntax name, List`1<NameSyntax> result);
    private int Compare(GenericNameSyntax x, GenericNameSyntax y);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.NameSyntaxIterator : object {
    private NameSyntax _name;
    public NameSyntaxIterator(NameSyntax name);
    public sealed virtual override IEnumerator`1<NameSyntax> GetEnumerator();
    private sealed virtual override IEnumerator GetEnumerator1();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.VisualBasic.Utilities.PossibleDeclarationTypes : Enum {
    public UInt32 value__;
    public static PossibleDeclarationTypes Method;
    public static PossibleDeclarationTypes Class;
    public static PossibleDeclarationTypes Structure;
    public static PossibleDeclarationTypes Interface;
    public static PossibleDeclarationTypes Enum;
    public static PossibleDeclarationTypes Delegate;
    public static PossibleDeclarationTypes Module;
    public static PossibleDeclarationTypes AllTypes;
    public static PossibleDeclarationTypes Operator;
    public static PossibleDeclarationTypes Property;
    public static PossibleDeclarationTypes Field;
    public static PossibleDeclarationTypes Event;
    public static PossibleDeclarationTypes ExternalMethod;
    public static PossibleDeclarationTypes ProtectedMember;
    public static PossibleDeclarationTypes OverridableMethod;
    public static PossibleDeclarationTypes Accessor;
    public static PossibleDeclarationTypes IteratorFunction;
    public static PossibleDeclarationTypes IteratorProperty;
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.SpeculationAnalyzer : AbstractSpeculationAnalyzer`7<ExpressionSyntax, TypeSyntax, AttributeSyntax, ArgumentSyntax, ForEachStatementSyntax, ThrowStatementSyntax, Conversion> {
    public SpeculationAnalyzer(ExpressionSyntax expression, ExpressionSyntax newExpression, SemanticModel semanticModel, CancellationToken cancellationToken, bool skipVerificationForReplacedNode, bool failOnOverloadResolutionFailuresInOriginalCode);
    protected virtual SyntaxNode GetSemanticRootForSpeculation(ExpressionSyntax expression);
    public static bool CanSpeculateOnNode(SyntaxNode node);
    protected virtual SyntaxNode GetSemanticRootOfReplacedExpression(SyntaxNode semanticRootOfOriginalExpr, ExpressionSyntax annotatedReplacedExpression);
    protected virtual void ValidateSpeculativeSemanticModel(SemanticModel speculativeSemanticModel, SyntaxNode nodeToSpeculate);
    protected virtual SemanticModel CreateSpeculativeSemanticModel(SyntaxNode originalNode, SyntaxNode nodeToSpeculate, SemanticModel semanticModel);
    public static SemanticModel CreateSpeculativeSemanticModelForNode(SyntaxNode originalNode, SyntaxNode nodeToSpeculate, SemanticModel semanticModel);
    public static SemanticModel CreateSpeculativeSemanticModelForNode(SyntaxNode nodeToSpeculate, SemanticModel semanticModel, int position, bool isInNamespaceOrTypeContext);
    private bool QuerySymbolsAreCompatible(CollectionRangeVariableSyntax originalNode, CollectionRangeVariableSyntax newNode);
    private bool QuerySymbolsAreCompatible(AggregateClauseSyntax originalNode, AggregateClauseSyntax newNode);
    private bool QuerySymbolsAreCompatible(ExpressionRangeVariableSyntax originalNode, ExpressionRangeVariableSyntax newNode);
    private bool QuerySymbolsAreCompatible(OrderingSyntax originalNode, OrderingSyntax newNode);
    private bool QuerySymbolsAreCompatible(QueryClauseSyntax originalNode, QueryClauseSyntax newNode);
    private bool SymbolInfosAreCompatible(CollectionRangeVariableSymbolInfo originalSymbolInfo, CollectionRangeVariableSymbolInfo newSymbolInfo);
    private bool SymbolInfosAreCompatible(AggregateClauseSymbolInfo originalSymbolInfo, AggregateClauseSymbolInfo newSymbolInfo);
    public bool ReplacementChangesSemanticsOfUnchangedLambda(ExpressionSyntax originalLambda, ExpressionSyntax replacedLambda);
    private bool HaveSameParameterType(ParameterSyntax originalParam, ParameterSyntax replacedParam);
    private bool ReplacementChangesSemanticsForNodes(IEnumerable`1<IdentifierNameSyntax> originalIdentifierNodes, IEnumerable`1<IdentifierNameSyntax> replacedIdentifierNodes, SyntaxNode originalRoot);
    protected virtual bool ReplacementChangesSemanticsForNodeLanguageSpecific(SyntaxNode currentOriginalNode, SyntaxNode currentReplacedNode, SyntaxNode previousOriginalNode, SyntaxNode previousReplacedNode);
    private bool ReplacementBreaksWithStatement(WithStatementSyntax originalWithStatement, WithStatementSyntax replacedWithStatement);
    private bool ReplacementBreaksCollectionInitializerAddMethod(ExpressionSyntax originalInitializer, ExpressionSyntax newInitializer);
    protected virtual bool IsForEachTypeInferred(ForEachStatementSyntax forEachStatement, SemanticModel semanticModel);
    protected virtual bool ExpressionMightReferenceMember(SyntaxNode node);
    protected virtual ExpressionSyntax GetReceiver(ExpressionSyntax expression);
    protected virtual bool IsNamedArgument(ArgumentSyntax argument);
    protected virtual string GetNamedArgumentIdentifierValueText(ArgumentSyntax argument);
    protected virtual ImmutableArray`1<ArgumentSyntax> GetArguments(ExpressionSyntax expression);
    private static ArgumentListSyntax GetArgumentList(ExpressionSyntax expression);
    private bool ReplacementBreaksBinaryExpression(BinaryExpressionSyntax binaryExpression, BinaryExpressionSyntax newBinaryExpression);
    private bool ReplacementBreaksConditionalAccessExpression(ConditionalAccessExpressionSyntax conditionalAccessExpression, ConditionalAccessExpressionSyntax newConditionalAccessExpression);
    private bool ReplacementBreaksInterpolation(InterpolationSyntax interpolation, InterpolationSyntax newInterpolation);
    protected virtual ExpressionSyntax GetForEachStatementExpression(ForEachStatementSyntax forEachStatement);
    protected virtual ExpressionSyntax GetThrowStatementExpression(ThrowStatementSyntax throwStatement);
    protected virtual bool IsInNamespaceOrTypeContext(ExpressionSyntax node);
    protected virtual bool IsParenthesizedExpression(SyntaxNode node);
    protected virtual bool ConversionsAreCompatible(SemanticModel originalModel, ExpressionSyntax originalExpression, SemanticModel newModel, ExpressionSyntax newExpression);
    protected virtual bool ConversionsAreCompatible(ExpressionSyntax originalExpression, ITypeSymbol originalTargetType, ExpressionSyntax newExpression, ITypeSymbol newTargetType);
    private bool ConversionsAreCompatible(Conversion originalConversion, Conversion newConversion);
    protected virtual bool ForEachConversionsAreCompatible(SemanticModel originalModel, ForEachStatementSyntax originalForEach, SemanticModel newModel, ForEachStatementSyntax newForEach);
    protected virtual void GetForEachSymbols(SemanticModel model, ForEachStatementSyntax forEach, IMethodSymbol& getEnumeratorMethod, ITypeSymbol& elementType);
    protected virtual bool IsReferenceConversion(Compilation compilation, ITypeSymbol sourceType, ITypeSymbol targetType);
    protected virtual Conversion ClassifyConversion(SemanticModel model, ExpressionSyntax expression, ITypeSymbol targetType);
    protected virtual Conversion ClassifyConversion(SemanticModel model, ITypeSymbol originalType, ITypeSymbol targetType);
}
[ExtensionAttribute]
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.SymbolExtensions : object {
    [ExtensionAttribute]
public static ISymbol FindRelatedExplicitlyDeclaredSymbol(ISymbol symbol, Compilation compilation);
}
[StandardModuleAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.SyntaxKindSet : object {
    public static ISet`1<SyntaxKind> AllOperators;
    private static SyntaxKindSet();
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.TokenComparer : object {
    private static string s_systemNamespace;
    public static TokenComparer NormalInstance;
    public static TokenComparer SystemFirstInstance;
    private bool _specialCaseSystem;
    private static TokenComparer();
    private TokenComparer(bool specialCaseSystem);
    public sealed virtual override int Compare(SyntaxToken token1, SyntaxToken token2);
    private static bool IsSystem(string s);
    private static int CompareWorker(SyntaxToken x, SyntaxToken y);
}
internal class Microsoft.CodeAnalysis.VisualBasic.Utilities.TypeSyntaxComparer : object {
    private IComparer`1<SyntaxToken> _tokenComparer;
    internal IComparer`1<NameSyntax> nameComparer;
    internal TypeSyntaxComparer(IComparer`1<SyntaxToken> tokenComparer);
    public static IComparer`1<NameSyntax> Create();
    public static IComparer`1<TypeSyntax> Create(IComparer`1<SyntaxToken> tokenComparer);
    public sealed virtual override int Compare(TypeSyntax x, TypeSyntax y);
    private static TypeSyntax UnwrapType(TypeSyntax type);
}
internal class Microsoft.CodeAnalysis.VisualBasic.VBWorkspaceResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo _Culture;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Namespace_can_not_be_added_in_this_destination { get; }
    internal static string Only_attributes_expressions_or_statements_can_be_made_explicit { get; }
    internal static string event_ { get; }
    internal static string handler { get; }
    internal static string The_expression_to_be_evaluated_and_converted { get; }
    internal static string The_name_of_the_data_type_to_which_the_value_of_expression_will_be_converted { get; }
    internal static string expression { get; }
    internal static string typeName { get; }
    internal static string Associates_an_event_with_an_event_handler_delegate_or_lambda_expression_at_run_time { get; }
    internal static string The_event_to_associate_an_event_handler_delegate_or_lambda_expression_with { get; }
    internal static string The_event_handler_to_associate_with_the_event_This_may_take_the_form_of_AddressOf_eventHandler_delegate_lambdaExpression { get; }
    internal static string If_expression_evaluates_to_a_reference_or_Nullable_value_that_is_not_Nothing_the_function_returns_that_value_Otherwise_it_calculates_and_returns_expressionIfNothing { get; }
    internal static string Returned_if_it_evaluates_to_a_reference_or_nullable_type_that_is_not_Nothing { get; }
    internal static string Evaluated_and_returned_if_expression_evaluates_to_Nothing { get; }
    internal static string expressionIfNothing { get; }
    internal static string Returns_the_result_of_explicitly_converting_an_expression_to_a_specified_data_type { get; }
    internal static string Introduces_a_type_conversion_operation_similar_to_CType_The_difference_is_that_CType_succeeds_as_long_as_there_is_a_valid_conversion_whereas_DirectCast_requires_that_one_type_inherit_from_or_implement_the_other_type { get; }
    internal static string The_type_name_to_return_a_System_Type_object_for { get; }
    internal static string Returns_a_System_Type_object_for_the_specified_type_name { get; }
    internal static string The_XML_namespace_prefix_to_return_a_System_Xml_Linq_XNamespace_object_for_If_this_is_omitted_the_object_for_the_default_XML_namespace_is_returned { get; }
    internal static string xmlNamespacePrefix { get; }
    internal static string Returns_the_System_Xml_Linq_XNamespace_object_corresponding_to_the_specified_XML_namespace_prefix { get; }
    internal static string Replaces_a_specified_number_of_characters_in_a_String_variable_with_characters_from_another_string { get; }
    internal static string The_name_of_the_string_variable_to_modify { get; }
    internal static string The_one_based_character_position_in_the_string_where_the_replacement_of_text_begins { get; }
    internal static string The_number_of_characters_to_replace_If_omitted_the_length_of_stringExpression_is_used { get; }
    internal static string stringName { get; }
    internal static string startIndex { get; }
    internal static string length { get; }
    internal static string stringExpression { get; }
    internal static string Converts_an_expression_to_the_0_data_type { get; }
    internal static string Removes_the_association_between_an_event_and_an_event_handler_or_delegate_at_run_time { get; }
    internal static string The_event_to_disassociate_an_event_handler_or_delegate_from { get; }
    internal static string The_event_handler_to_disassociate_from_the_event_This_may_take_the_form_of_AddressOf_eventHandler_delegate { get; }
    internal static string If_condition_returns_True_the_function_calculates_and_returns_expressionIfTrue_Otherwise_it_returns_expressionIfFalse { get; }
    internal static string The_expression_to_evaluate { get; }
    internal static string Evaluated_and_returned_if_condition_evaluates_to_True { get; }
    internal static string Evaluated_and_returned_if_condition_evaluates_to_False { get; }
    internal static string condition { get; }
    internal static string expressionIfTrue { get; }
    internal static string expressionIfFalse { get; }
    internal static string Introduces_a_type_conversion_operation_that_does_not_throw_an_exception_If_an_attempted_conversion_fails_TryCast_returns_Nothing_which_your_program_can_test_for { get; }
    internal static string Node_does_not_descend_from_root { get; }
    internal static string Node_not_in_parent_s_child_list { get; }
    internal static string Trivia_is_not_associated_with_token { get; }
    internal static string typeOrMember { get; }
    internal static string The_type_of_member_to_return_the_name_of { get; }
    internal static string Produces_a_string_for_the_name_of_the_specified_type_or_member { get; }
    internal static string result { get; }
    internal static string Remove_and_Sort_Imports { get; }
    internal static string Sort_Imports { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo AutoPropertyValue);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Namespace_can_not_be_added_in_this_destination();
    internal static string get_Only_attributes_expressions_or_statements_can_be_made_explicit();
    internal static string get_event_();
    internal static string get_handler();
    internal static string get_The_expression_to_be_evaluated_and_converted();
    internal static string get_The_name_of_the_data_type_to_which_the_value_of_expression_will_be_converted();
    internal static string get_expression();
    internal static string get_typeName();
    internal static string get_Associates_an_event_with_an_event_handler_delegate_or_lambda_expression_at_run_time();
    internal static string get_The_event_to_associate_an_event_handler_delegate_or_lambda_expression_with();
    internal static string get_The_event_handler_to_associate_with_the_event_This_may_take_the_form_of_AddressOf_eventHandler_delegate_lambdaExpression();
    internal static string get_If_expression_evaluates_to_a_reference_or_Nullable_value_that_is_not_Nothing_the_function_returns_that_value_Otherwise_it_calculates_and_returns_expressionIfNothing();
    internal static string get_Returned_if_it_evaluates_to_a_reference_or_nullable_type_that_is_not_Nothing();
    internal static string get_Evaluated_and_returned_if_expression_evaluates_to_Nothing();
    internal static string get_expressionIfNothing();
    internal static string get_Returns_the_result_of_explicitly_converting_an_expression_to_a_specified_data_type();
    internal static string get_Introduces_a_type_conversion_operation_similar_to_CType_The_difference_is_that_CType_succeeds_as_long_as_there_is_a_valid_conversion_whereas_DirectCast_requires_that_one_type_inherit_from_or_implement_the_other_type();
    internal static string get_The_type_name_to_return_a_System_Type_object_for();
    internal static string get_Returns_a_System_Type_object_for_the_specified_type_name();
    internal static string get_The_XML_namespace_prefix_to_return_a_System_Xml_Linq_XNamespace_object_for_If_this_is_omitted_the_object_for_the_default_XML_namespace_is_returned();
    internal static string get_xmlNamespacePrefix();
    internal static string get_Returns_the_System_Xml_Linq_XNamespace_object_corresponding_to_the_specified_XML_namespace_prefix();
    internal static string get_Replaces_a_specified_number_of_characters_in_a_String_variable_with_characters_from_another_string();
    internal static string get_The_name_of_the_string_variable_to_modify();
    internal static string get_The_one_based_character_position_in_the_string_where_the_replacement_of_text_begins();
    internal static string get_The_number_of_characters_to_replace_If_omitted_the_length_of_stringExpression_is_used();
    internal static string get_stringName();
    internal static string get_startIndex();
    internal static string get_length();
    internal static string get_stringExpression();
    internal static string get_Converts_an_expression_to_the_0_data_type();
    internal static string get_Removes_the_association_between_an_event_and_an_event_handler_or_delegate_at_run_time();
    internal static string get_The_event_to_disassociate_an_event_handler_or_delegate_from();
    internal static string get_The_event_handler_to_disassociate_from_the_event_This_may_take_the_form_of_AddressOf_eventHandler_delegate();
    internal static string get_If_condition_returns_True_the_function_calculates_and_returns_expressionIfTrue_Otherwise_it_returns_expressionIfFalse();
    internal static string get_The_expression_to_evaluate();
    internal static string get_Evaluated_and_returned_if_condition_evaluates_to_True();
    internal static string get_Evaluated_and_returned_if_condition_evaluates_to_False();
    internal static string get_condition();
    internal static string get_expressionIfTrue();
    internal static string get_expressionIfFalse();
    internal static string get_Introduces_a_type_conversion_operation_that_does_not_throw_an_exception_If_an_attempted_conversion_fails_TryCast_returns_Nothing_which_your_program_can_test_for();
    internal static string get_Node_does_not_descend_from_root();
    internal static string get_Node_not_in_parent_s_child_list();
    internal static string get_Trivia_is_not_associated_with_token();
    internal static string get_typeOrMember();
    internal static string get_The_type_of_member_to_return_the_name_of();
    internal static string get_Produces_a_string_for_the_name_of_the_specified_type_or_member();
    internal static string get_result();
    internal static string get_Remove_and_Sort_Imports();
    internal static string get_Sort_Imports();
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Host.ICommandLineParserService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicCommandLineParserService : object {
    public sealed virtual override CommandLineArguments Parse(IEnumerable`1<string> arguments, string baseDirectory, bool isInteractive, string sdkDirectory);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.Host.ICompilationFactoryService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicCompilationFactoryService : object {
    private static VisualBasicCompilationOptions s_defaultOptions;
    private static VisualBasicCompilationFactoryService();
    public sealed virtual override Compilation CreateCompilation(string assemblyName, CompilationOptions options);
    public sealed virtual override Compilation CreateSubmissionCompilation(string assemblyName, CompilationOptions options, Type hostObjectType);
    public sealed virtual override CompilationOptions GetDefaultCompilationOptions();
    public sealed virtual override GeneratorDriver CreateGeneratorDriver(ParseOptions parseOptions, ImmutableArray`1<ISourceGenerator> generators, AnalyzerConfigOptionsProvider optionsProvider, ImmutableArray`1<AdditionalText> additionalTexts);
}
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicSemanticFacts : object {
    public static VisualBasicSemanticFacts Instance;
    public bool SupportsImplicitInterfaceImplementation { get; }
    public bool ExposesAnonymousFunctionParameterNames { get; }
    public bool SupportsParameterizedProperties { get; }
    private static VisualBasicSemanticFacts();
    public sealed virtual override string GenerateNameForExpression(SemanticModel semanticModel, SyntaxNode expression, bool capitalize, CancellationToken cancellationToken);
    public sealed virtual override bool get_SupportsImplicitInterfaceImplementation();
    public sealed virtual override bool get_ExposesAnonymousFunctionParameterNames();
    public sealed virtual override bool IsOnlyWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual override bool IsWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual override bool IsInOutContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual override bool IsInRefContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual override bool IsInInContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual override bool CanReplaceWithRValue(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    public sealed virtual override ISymbol GetDeclaredSymbol(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    public sealed virtual override bool LastEnumValueHasInitializer(INamedTypeSymbol namedTypeSymbol);
    public sealed virtual override bool get_SupportsParameterizedProperties();
    public sealed virtual override bool TryGetSpeculativeSemanticModel(SemanticModel oldSemanticModel, SyntaxNode oldNode, SyntaxNode newNode, SemanticModel& speculativeModel);
    public sealed virtual override ImmutableHashSet`1<string> GetAliasNameSet(SemanticModel model, CancellationToken cancellationToken);
    public sealed virtual override ForEachSymbols GetForEachSymbols(SemanticModel model, SyntaxNode forEachStatement);
    public sealed virtual override IMethodSymbol GetGetAwaiterMethod(SemanticModel model, SyntaxNode node);
    public sealed virtual override ImmutableArray`1<IMethodSymbol> GetDeconstructionAssignmentMethods(SemanticModel model, SyntaxNode deconstruction);
    public sealed virtual override ImmutableArray`1<IMethodSymbol> GetDeconstructionForEachMethods(SemanticModel model, SyntaxNode deconstruction);
    public sealed virtual override bool IsPartial(ITypeSymbol typeSymbol, CancellationToken cancellationToken);
    public sealed virtual override IEnumerable`1<ISymbol> GetDeclaredSymbols(SemanticModel semanticModel, SyntaxNode memberDeclaration, CancellationToken cancellationToken);
    public sealed virtual override IParameterSymbol FindParameterForArgument(SemanticModel semanticModel, SyntaxNode argumentNode, CancellationToken cancellationToken);
    public sealed virtual override ImmutableArray`1<ISymbol> GetBestOrAllSymbols(SemanticModel semanticModel, SyntaxNode node, SyntaxToken token, CancellationToken cancellationToken);
    public sealed virtual override bool IsInsideNameOfExpression(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicSemanticFactsService : AbstractSemanticFactsService {
    public static VisualBasicSemanticFactsService Instance;
    [CompilerGeneratedAttribute]
private ISyntaxFacts _SyntaxFacts;
    [CompilerGeneratedAttribute]
private ISemanticFacts _SemanticFacts;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected ISemanticFacts SemanticFacts { get; }
    private static VisualBasicSemanticFactsService();
    [CompilerGeneratedAttribute]
protected virtual ISyntaxFacts get_SyntaxFacts();
    [CompilerGeneratedAttribute]
protected virtual ISemanticFacts get_SemanticFacts();
    protected virtual SyntaxToken ToIdentifierToken(string identifier);
    public sealed virtual override bool IsExpressionContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual override bool IsInExpressionTree(SemanticModel semanticModel, SyntaxNode node, INamedTypeSymbol expressionTypeOpt, CancellationToken cancellationToken);
    public sealed virtual override bool IsMemberDeclarationContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual override bool IsNamespaceContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual override bool IsStatementContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual override bool IsTypeContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual override bool IsTypeDeclarationContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual override bool IsGlobalStatementContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual override bool IsLabelContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual override bool IsAttributeNameContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public sealed virtual override bool IsNamespaceDeclarationNameContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken ISemanticFactsService_GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken ISemanticFactsService_GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken ISemanticFactsService_GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken ISemanticFactsService_GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, IEnumerable`1<string> usedName, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken ISemanticFactsService_GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, Func`2<ISymbol, bool> filter, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    private sealed virtual override SyntaxToken ISemanticFactsService_GenerateUniqueName(string baseName, IEnumerable`1<string> usedNames);
    public sealed virtual override CommonConversion ClassifyConversion(SemanticModel semanticModel, SyntaxNode expression, ITypeSymbol destination);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.LanguageServices.ISemanticFactsService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicSemanticFactsServiceFactory : object {
    public sealed virtual override ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageServices.ISymbolDeclarationService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicSymbolDeclarationService : object {
    public sealed virtual override ImmutableArray`1<SyntaxReference> GetDeclarations(ISymbol symbol);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.LanguageServices.ISyntaxFactsService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxFactsServiceFactory : object {
    public sealed virtual override ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
[ExportLanguageServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.ISyntaxTreeFactoryService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicSyntaxTreeFactoryServiceFactory : object {
    private static VisualBasicParseOptions _parseOptionsWithLatestLanguageVersion;
    private static VisualBasicSyntaxTreeFactoryServiceFactory();
    public sealed virtual override ILanguageService CreateLanguageService(HostLanguageServices provider);
}
[ExportLanguageServiceAttribute("Microsoft.CodeAnalysis.LanguageServices.ITypeInferenceService", "Visual Basic", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.VisualBasic.VisualBasicTypeInferenceService : AbstractTypeInferenceService {
    protected virtual AbstractTypeInferrer CreateTypeInferrer(SemanticModel semanticModel, CancellationToken cancellationToken);
}
[Embedded]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[EditorBrowsableAttribute("1")]
internal class Microsoft.VisualBasic.CompilerServices.Conversions : object {
    private static object GetEnumValue(object Value);
    public static bool ToBoolean(string Value);
    public static bool ToBoolean(object Value);
    public static byte ToByte(string Value);
    public static byte ToByte(object Value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string Value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object Value);
    public static short ToShort(string Value);
    public static short ToShort(object Value);
    [CLSCompliantAttribute("False")]
public static ushort ToUShort(string Value);
    [CLSCompliantAttribute("False")]
public static ushort ToUShort(object Value);
    public static int ToInteger(string Value);
    public static int ToInteger(object Value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInteger(string Value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInteger(object Value);
    public static long ToLong(string Value);
    public static long ToLong(object Value);
    [CLSCompliantAttribute("False")]
public static ulong ToULong(string Value);
    [CLSCompliantAttribute("False")]
public static ulong ToULong(object Value);
    public static decimal ToDecimal(bool Value);
    public static decimal ToDecimal(string Value);
    public static decimal ToDecimal(object Value);
    private static decimal ParseDecimal(string Value, NumberFormatInfo NumberFormat);
    private static NumberFormatInfo GetNormalizedNumberFormat(NumberFormatInfo InNumberFormat);
    public static float ToSingle(string Value);
    public static float ToSingle(object Value);
    public static double ToDouble(string Value);
    public static double ToDouble(object Value);
    private static double ParseDouble(string Value);
    public static DateTime ToDate(string Value);
    public static DateTime ToDate(object Value);
    public static char ToChar(string Value);
    public static char ToChar(object Value);
    public static string ToString(int Value);
    [CLSCompliantAttribute("False")]
public static string ToString(UInt32 Value);
    public static string ToString(long Value);
    [CLSCompliantAttribute("False")]
public static string ToString(ulong Value);
    public static string ToString(float Value);
    public static string ToString(double Value);
    public static string ToString(DateTime Value);
    public static string ToString(decimal Value);
    public static string ToString(object Value);
    public static string ToString(bool Value);
    public static string ToString(byte Value);
    public static string ToString(char Value);
    internal static CultureInfo GetCultureInfo();
    internal static string ToHalfwidthNumbers(string s, CultureInfo culture);
    internal static bool IsHexOrOctValue(string Value, Int64& i64Value);
    internal static bool IsHexOrOctValue(string Value, UInt64& ui64Value);
    public static T ToGenericParameter(object Value);
}
[Embedded]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[EditorBrowsableAttribute("1")]
internal class Microsoft.VisualBasic.CompilerServices.EmbeddedOperators : object {
    public static int CompareString(string Left, string Right, bool TextCompare);
}
[Embedded]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
[EditorBrowsableAttribute("1")]
internal class Microsoft.VisualBasic.CompilerServices.ProjectData : object {
    public static void SetProjectError(Exception ex);
    public static void ClearProjectError();
}
[Embedded]
[AttributeUsageAttribute("4")]
[EditorBrowsableAttribute("1")]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualBasic.CompilerServices.StandardModuleAttribute : Attribute {
}
[Embedded]
[AttributeUsageAttribute("7")]
[EditorBrowsableAttribute("1")]
[CompilerGeneratedAttribute]
internal class Microsoft.VisualBasic.Embedded : Attribute {
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("def={def}, expr1={expr1}")]
internal class VB$AnonymousType_0`2 : object {
    private T0 $def;
    private T1 $expr1;
    public T0 def { get; }
    public T1 expr1 { get; }
    public VB$AnonymousType_0`2(T0 def, T1 expr1);
    public T0 get_def();
    public T1 get_expr1();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual override bool Equals(VB$AnonymousType_0`2<T0, T1> val);
    public virtual bool Equals(object obj);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("$VB$It={$VB$It}, expr2={expr2}")]
internal class VB$AnonymousType_1`2 : object {
    private T0 $$VB$It;
    private T1 $expr2;
    public T0 $VB$It { get; }
    public T1 expr2 { get; }
    public VB$AnonymousType_1`2(T0 $VB$It, T1 expr2);
    public T0 get_$VB$It();
    public T1 get_expr2();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual override bool Equals(VB$AnonymousType_1`2<T0, T1> val);
    public virtual bool Equals(object obj);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("$VB$It={$VB$It}, children={children}")]
internal class VB$AnonymousType_2`2 : object {
    private T0 $$VB$It;
    private T1 $children;
    public T0 $VB$It { get; }
    public T1 children { get; }
    public VB$AnonymousType_2`2(T0 $VB$It, T1 children);
    public T0 get_$VB$It();
    public T1 get_children();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual override bool Equals(VB$AnonymousType_2`2<T0, T1> val);
    public virtual bool Equals(object obj);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("$VB$It={$VB$It}, token={token}")]
internal class VB$AnonymousType_3`2 : object {
    private T0 $$VB$It;
    private T1 $token;
    public T0 $VB$It { get; }
    public T1 token { get; }
    public VB$AnonymousType_3`2(T0 $VB$It, T1 token);
    public T0 get_$VB$It();
    public T1 get_token();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual override bool Equals(VB$AnonymousType_3`2<T0, T1> val);
    public virtual bool Equals(object obj);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("$VB$It={$VB$It}, identifier={identifier}")]
internal class VB$AnonymousType_4`2 : object {
    private T0 $$VB$It;
    private T1 $identifier;
    public T0 $VB$It { get; }
    public T1 identifier { get; }
    public VB$AnonymousType_4`2(T0 $VB$It, T1 identifier);
    public T0 get_$VB$It();
    public T1 get_identifier();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual override bool Equals(VB$AnonymousType_4`2<T0, T1> val);
    public virtual bool Equals(object obj);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("childNamespace={childNamespace}, type={type}")]
internal class VB$AnonymousType_5`2 : object {
    private T0 $childNamespace;
    private T1 $type;
    public T0 childNamespace { get; }
    public T1 type { get; }
    public VB$AnonymousType_5`2(T0 childNamespace, T1 type);
    public T0 get_childNamespace();
    public T1 get_type();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual override bool Equals(VB$AnonymousType_5`2<T0, T1> val);
    public virtual bool Equals(object obj);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("$VB$It1={$VB$It1}, childProperty={childProperty}")]
internal class VB$AnonymousType_6`2 : object {
    private T0 $$VB$It1;
    private T1 $childProperty;
    public T0 $VB$It1 { get; }
    public T1 childProperty { get; }
    public VB$AnonymousType_6`2(T0 $VB$It1, T1 childProperty);
    public T0 get_$VB$It1();
    public T1 get_childProperty();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual override bool Equals(VB$AnonymousType_6`2<T0, T1> val);
    public virtual bool Equals(object obj);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("u={u}, importClause={importClause}")]
internal class VB$AnonymousType_7`2 : object {
    private T0 $u;
    private T1 $importClause;
    public T0 u { get; }
    public T1 importClause { get; }
    public VB$AnonymousType_7`2(T0 u, T1 importClause);
    public T0 get_u();
    public T1 get_importClause();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual override bool Equals(VB$AnonymousType_7`2<T0, T1> val);
    public virtual bool Equals(object obj);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("$VB$It={$VB$It}, info={info}")]
internal class VB$AnonymousType_8`2 : object {
    private T0 $$VB$It;
    private T1 $info;
    public T0 $VB$It { get; }
    public T1 info { get; }
    public VB$AnonymousType_8`2(T0 $VB$It, T1 info);
    public T0 get_$VB$It();
    public T1 get_info();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual override bool Equals(VB$AnonymousType_8`2<T0, T1> val);
    public virtual bool Equals(object obj);
}
[CompilerGeneratedAttribute]
[DebuggerDisplayAttribute("$VB$It={$VB$It}, ns={ns}")]
internal class VB$AnonymousType_9`2 : object {
    private T0 $$VB$It;
    private T1 $ns;
    public T0 $VB$It { get; }
    public T1 ns { get; }
    public VB$AnonymousType_9`2(T0 $VB$It, T1 ns);
    public T0 get_$VB$It();
    public T1 get_ns();
    public virtual string ToString();
    public virtual int GetHashCode();
    public sealed virtual override bool Equals(VB$AnonymousType_9`2<T0, T1> val);
    public virtual bool Equals(object obj);
}
internal class VisualBasicCompilerExtensionsResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo _Culture;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string EmptyResource { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo AutoPropertyValue);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_EmptyResource();
}
internal class VisualBasicWorkspaceExtensionsResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo _Culture;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string EmptyResource { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo AutoPropertyValue);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_EmptyResource();
}
