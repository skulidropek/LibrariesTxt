[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1 : object {
    [NullableAttribute("2")]
private T _firstItem;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Element[] _items;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Factory<T> _factory;
    internal ObjectPool`1(Factory<T> factory);
    internal ObjectPool`1(Factory<T> factory, int size);
    internal ObjectPool`1(Func`2<ObjectPool`1<T>, T> factory, int size);
    private T CreateInstance();
    internal T Allocate();
    private T AllocateSlow();
    internal void Free(T obj);
    private void FreeSlow(T obj);
    [ConditionalAttribute("DEBUG")]
internal void ForgetTrackedObject(T old, T replacement);
    [ConditionalAttribute("DEBUG")]
private void Validate(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder : object {
    public StringBuilder Builder;
    private ObjectPool`1<PooledStringBuilder> _pool;
    private static ObjectPool`1<PooledStringBuilder> s_poolInstance;
    public int Length { get; }
    private PooledStringBuilder(ObjectPool`1<PooledStringBuilder> pool);
    private static PooledStringBuilder();
    public int get_Length();
    public void Free();
    [ObsoleteAttribute("Consider calling ToStringAndFree instead.")]
public string ToString();
    public string ToStringAndFree();
    public string ToStringAndFree(int startIndex, int length);
    public static ObjectPool`1<PooledStringBuilder> CreatePool(int size);
    public static PooledStringBuilder GetInstance();
    public static StringBuilder op_Implicit(PooledStringBuilder obj);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class System.Diagnostics.CI : object {
    [ConditionalAttribute("IS_CI_OR_DEBUG")]
public static void Assert(bool condition);
    [ConditionalAttribute("IS_CI_OR_DEBUG")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("IS_CI_OR_DEBUG")]
public static void Assert(bool condition, AssertInterpolatedStringHandler& message);
    [ConditionalAttribute("IS_CI_OR_DEBUG")]
public static void Assert(bool condition, string message, string detailMessage);
    [ConditionalAttribute("IS_CI_OR_DEBUG")]
public static void Assert(bool condition, AssertInterpolatedStringHandler& message, AssertInterpolatedStringHandler& detailMessage);
    [NullableContextAttribute("1")]
[ConditionalAttribute("IS_CI_OR_DEBUG")]
public static void Assert(bool condition, string message, string detailMessageFormat, Object[] args);
    [ConditionalAttribute("IS_CI_OR_DEBUG")]
[DoesNotReturnAttribute]
public static void Fail(string message);
    [ConditionalAttribute("IS_CI_OR_DEBUG")]
[DoesNotReturnAttribute]
public static void Fail(string message, string detailMessage);
}
[ExtensionAttribute]
public static class System.Numerics.VectorExtensions : object {
    [ExtensionAttribute]
public static Point ToPoint(Vector2 vector);
    [ExtensionAttribute]
public static Size ToSize(Vector2 vector);
    [ExtensionAttribute]
public static Vector2 ToVector2(Point point);
    [ExtensionAttribute]
public static Vector2 ToVector2(Size size);
}
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.10.32707")]
internal static class System.Text.RegularExpressions.Generated.<RegexGenerator_g>F3294612A236667325ED2850F4F9965575EEFCEEFCAD833B0FA13BD1B156B7EDE__Utilities : object {
    internal static TimeSpan s_defaultTimeout;
    internal static bool s_hasTimeout;
    internal static SearchValues`1<char> s_asciiExceptDigits;
    private static <RegexGenerator_g>F3294612A236667325ED2850F4F9965575EEFCEEFCAD833B0FA13BD1B156B7EDE__Utilities();
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static int IndexOfAnyDigit(ReadOnlySpan`1<char> span);
    internal static void StackPop(Int32[] stack, Int32& pos, Int32& arg0, Int32& arg1);
    internal static void StackPush(Int32[]& stack, Int32& pos, int arg0);
    internal static void StackPush(Int32[]& stack, Int32& pos, int arg0, int arg1);
    internal static void StackPush(Int32[]& stack, Int32& pos, int arg0, int arg1, int arg2);
    [CompilerGeneratedAttribute]
internal static void <StackPush>g__WithResize|4_0(Int32[]& stack, Int32& pos, int arg0);
    [CompilerGeneratedAttribute]
internal static void <StackPush>g__WithResize|5_0(Int32[]& stack, Int32& pos, int arg0, int arg1);
    [CompilerGeneratedAttribute]
internal static void <StackPush>g__WithResize|6_0(Int32[]& stack, Int32& pos, int arg0, int arg1, int arg2);
}
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.10.32707")]
[SkipLocalsInitAttribute]
internal class System.Text.RegularExpressions.Generated.<RegexGenerator_g>F3294612A236667325ED2850F4F9965575EEFCEEFCAD833B0FA13BD1B156B7EDE__VersionMatch_0 : Regex {
    [NullableAttribute("1")]
internal static <RegexGenerator_g>F3294612A236667325ED2850F4F9965575EEFCEEFCAD833B0FA13BD1B156B7EDE__VersionMatch_0 Instance;
    private static <RegexGenerator_g>F3294612A236667325ED2850F4F9965575EEFCEEFCAD833B0FA13BD1B156B7EDE__VersionMatch_0();
}
internal static class Uno.Actions : object {
    public static Action CreateOnce(Action action);
}
internal class Uno.CachedTuple : object {
    public static CachedTuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static CachedTuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static CachedTuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
}
internal class Uno.CachedTuple`2 : object {
    private int _cachedHashCode;
    [CompilerGeneratedAttribute]
private T1 <Item1>k__BackingField;
    [CompilerGeneratedAttribute]
private T2 <Item2>k__BackingField;
    public static IEqualityComparer`1<CachedTuple`2<T1, T2>> Comparer;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public CachedTuple`2(T1 item1, T2 item2);
    private static CachedTuple`2();
    [CompilerGeneratedAttribute]
public T1 get_Item1();
    [CompilerGeneratedAttribute]
public T2 get_Item2();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private static bool InternalEquals(CachedTuple`2<T1, T2> t1, CachedTuple`2<T1, T2> t2);
}
internal class Uno.CachedTuple`3 : object {
    private int _cachedHashCode;
    public static IEqualityComparer`1<CachedTuple`3<T1, T2, T3>> Comparer;
    [CompilerGeneratedAttribute]
private T1 <Item1>k__BackingField;
    [CompilerGeneratedAttribute]
private T2 <Item2>k__BackingField;
    [CompilerGeneratedAttribute]
private T3 <Item3>k__BackingField;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public CachedTuple`3(T1 item1, T2 item2, T3 item3);
    private static CachedTuple`3();
    [CompilerGeneratedAttribute]
public T1 get_Item1();
    [CompilerGeneratedAttribute]
public T2 get_Item2();
    [CompilerGeneratedAttribute]
public T3 get_Item3();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private static bool InternalEquals(CachedTuple`3<T1, T2, T3> t1, CachedTuple`3<T1, T2, T3> t2);
}
internal class Uno.CachedTuple`4 : object {
    private int _cachedHashCode;
    public static IEqualityComparer`1<CachedTuple`4<T1, T2, T3, T4>> Comparer;
    [CompilerGeneratedAttribute]
private T1 <Item1>k__BackingField;
    [CompilerGeneratedAttribute]
private T2 <Item2>k__BackingField;
    [CompilerGeneratedAttribute]
private T3 <Item3>k__BackingField;
    [CompilerGeneratedAttribute]
private T4 <Item4>k__BackingField;
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public CachedTuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    private static CachedTuple`4();
    [CompilerGeneratedAttribute]
public T1 get_Item1();
    [CompilerGeneratedAttribute]
public T2 get_Item2();
    [CompilerGeneratedAttribute]
public T3 get_Item3();
    [CompilerGeneratedAttribute]
public T4 get_Item4();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    private static bool InternalEquals(CachedTuple`4<T1, T2, T3, T4> t1, CachedTuple`4<T1, T2, T3, T4> t2);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Uno.Client.ICommandExtensions : object {
    [ExtensionAttribute]
public static void ExecuteIfPossible(ICommand command, object parameter);
}
[DefaultMemberAttribute("Item")]
internal class Uno.Collections.ImmutableList`1 : object {
    private T[] _data;
    [CompilerGeneratedAttribute]
private static ImmutableList`1<T> <Empty>k__BackingField;
    public static ImmutableList`1<T> Empty { get; }
    public T[] Data { get; }
    public int Count { get; }
    public T Item { get; }
    public ImmutableList`1(T[] data, bool copyData);
    public ImmutableList`1(IEnumerable`1<T> source);
    private static ImmutableList`1();
    [CompilerGeneratedAttribute]
public static ImmutableList`1<T> get_Empty();
    public sealed virtual IImmutableList`1<T> Clear();
    public sealed virtual int IndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual int LastIndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Add(T value);
    public sealed virtual IImmutableList`1<T> AddRange(IEnumerable`1<T> items);
    public sealed virtual IImmutableList`1<T> Insert(int index, T element);
    public sealed virtual IImmutableList`1<T> InsertRange(int index, IEnumerable`1<T> items);
    public sealed virtual IImmutableList`1<T> Remove(T value, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual IImmutableList`1<T> RemoveAll(Predicate`1<T> match);
    public sealed virtual IImmutableList`1<T> RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public sealed virtual IImmutableList`1<T> RemoveRange(int index, int count);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAt(int index);
    public sealed virtual IImmutableList`1<T> SetItem(int index, T value);
    public sealed virtual IImmutableList`1<T> Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    public ImmutableList`1<T> Add(T value);
    public ImmutableList`1<T> Remove(T value);
    public bool Contains(T value);
    public ImmutableList`1<T> RemoveAt(int index);
    public int IndexOf(T value);
    public T[] get_Data();
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
}
[ExtensionAttribute]
internal static class Uno.Collections.MemoryExtensions : object {
    [ExtensionAttribute]
public static int Count(Span`1<T> span, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Any(Span`1<T> span, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionary(Span`1<TIn> span, Func`2<TIn, TKey> keySelector, Func`2<TIn, TValue> valueSelector);
    [ExtensionAttribute]
public static double Sum(Span`1<double> span);
    [ExtensionAttribute]
public static double Sum(Span`1<TIn> span, Func`2<TIn, double> selector);
}
internal class Uno.Collections.UnsafeWeakAttachedDictionary`2 : object {
    private ConditionalWeakTable`2<TOwner, Dictionary`2<TKey, object>> _instances;
    public TValue GetValue(TOwner owner, TKey key, Func`1<TValue> defaultSelector);
    public void SetValue(TOwner owner, TKey key, TValue value);
    private Dictionary`2<TKey, object> GetValuesForOwner(TOwner owner);
}
internal class Uno.Collections.WeakAttachedDictionary`2 : object {
    private ConditionalWeakTable`2<TOwner, ConcurrentDictionary`2<TKey, object>> _instances;
    private static ConcurrentDictionary`2<TKey, object> CreateDictionary(TOwner key);
    public TValue GetValue(TOwner owner, TKey key, Func`1<TValue> defaultSelector);
    public TValue GetValue(TOwner owner, TKey key, Func`2<TKey, TValue> defaultSelector);
    public void SetValue(TOwner owner, TKey key, TValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Uno.Core.Comparison.FastTypeComparer : object {
    [CompilerGeneratedAttribute]
private static FastTypeComparer <Default>k__BackingField;
    public static FastTypeComparer Default { get; }
    private static FastTypeComparer();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Type x, Type y);
    public sealed virtual int GetHashCode(Type obj);
    [CompilerGeneratedAttribute]
public static FastTypeComparer get_Default();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Uno.Diagnostics.UI.DiagnosticViewNotification : object {
    [CompilerGeneratedAttribute]
private object <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ContentTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <Duration>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticViewNotificationDisplayOptions <Options>k__BackingField;
    public object Content { get; public set; }
    public object ContentTemplate { get; public set; }
    public Nullable`1<TimeSpan> Duration { get; public set; }
    public DiagnosticViewNotificationDisplayOptions Options { get; public set; }
    [NullableContextAttribute("1")]
public DiagnosticViewNotification(object content, Nullable`1<TimeSpan> duration);
    [CompilerGeneratedAttribute]
public object get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(object value);
    [CompilerGeneratedAttribute]
public object get_ContentTemplate();
    [CompilerGeneratedAttribute]
public void set_ContentTemplate(object value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_Duration();
    [CompilerGeneratedAttribute]
public void set_Duration(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public DiagnosticViewNotificationDisplayOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(DiagnosticViewNotificationDisplayOptions value);
}
[FlagsAttribute]
public enum Uno.Diagnostics.UI.DiagnosticViewNotificationDisplayOptions : Enum {
    public int value__;
    public static DiagnosticViewNotificationDisplayOptions Default;
    public static DiagnosticViewNotificationDisplayOptions EvenIfExpended;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Uno.Diagnostics.UI.DiagnosticViewRegistration : object {
    [CompilerGeneratedAttribute]
private DiagnosticViewRegistrationMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private IDiagnosticView <View>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public DiagnosticViewRegistrationMode Mode { get; public set; }
    public IDiagnosticView View { get; public set; }
    public DiagnosticViewRegistration(DiagnosticViewRegistrationMode Mode, IDiagnosticView View);
    [CompilerGeneratedAttribute]
protected DiagnosticViewRegistration(DiagnosticViewRegistration original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public DiagnosticViewRegistrationMode get_Mode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Mode(DiagnosticViewRegistrationMode value);
    [CompilerGeneratedAttribute]
public IDiagnosticView get_View();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_View(IDiagnosticView value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(DiagnosticViewRegistration left, DiagnosticViewRegistration right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(DiagnosticViewRegistration left, DiagnosticViewRegistration right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(DiagnosticViewRegistration other);
    [CompilerGeneratedAttribute]
public virtual DiagnosticViewRegistration <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(DiagnosticViewRegistrationMode& Mode, IDiagnosticView& View);
}
internal enum Uno.Diagnostics.UI.DiagnosticViewRegistrationMode : Enum {
    public int value__;
    public static DiagnosticViewRegistrationMode One;
    public static DiagnosticViewRegistrationMode All;
    public static DiagnosticViewRegistrationMode OnDemand;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Uno.Diagnostics.UI.DiagnosticViewRegistry : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static EventHandler`1<IImmutableList`1<DiagnosticViewRegistration>> Added;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<DiagnosticViewRegistration> _registrations;
    internal static IImmutableList`1<DiagnosticViewRegistration> Registrations { get; }
    private static DiagnosticViewRegistry();
    internal static IImmutableList`1<DiagnosticViewRegistration> get_Registrations();
    public static void Register(IDiagnosticView view, DiagnosticViewRegistrationMode mode);
}
[NullableContextAttribute("1")]
public interface Uno.Diagnostics.UI.IDiagnosticView {
    public string Id { get; }
    public string Name { get; }
    public abstract virtual string get_Id();
    public abstract virtual string get_Name();
    public abstract virtual object GetElement(IDiagnosticViewContext context);
    public abstract virtual ValueTask`1<object> GetDetailsAsync(IDiagnosticViewContext context, CancellationToken ct);
}
[NullableContextAttribute("1")]
public interface Uno.Diagnostics.UI.IDiagnosticViewContext {
    public abstract virtual void Schedule(Action action);
    public abstract virtual void ScheduleRecurrent(Action action);
    public abstract virtual void AbortRecurrent(Action action);
    public abstract virtual void Notify(DiagnosticViewNotification notification);
}
internal class Uno.DisposableAction : object {
    [CompilerGeneratedAttribute]
private Action <Action>k__BackingField;
    public Action Action { get; private set; }
    public DisposableAction(Action action);
    [CompilerGeneratedAttribute]
public Action get_Action();
    [CompilerGeneratedAttribute]
private void set_Action(Action value);
    public sealed virtual void Dispose();
}
internal class Uno.Disposables.AnonymousDisposable : object {
    [NullableAttribute("2")]
private Action modreq(System.Runtime.CompilerServices.IsVolatile) _dispose;
    public bool IsDisposed { get; }
    [NullableContextAttribute("1")]
public AnonymousDisposable(Action dispose);
    public sealed virtual bool get_IsDisposed();
    public sealed virtual void Dispose();
}
internal class Uno.Disposables.CancellationDisposable : object {
    private CancellationTokenSource _cts;
    public CancellationToken Token { get; }
    public bool IsDisposed { get; }
    public CancellationDisposable(CancellationTokenSource cts);
    public CancellationToken get_Token();
    public sealed virtual void Dispose();
    public sealed virtual bool get_IsDisposed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Uno.Disposables.CompositeDisposable : object {
    private object _gate;
    private bool _disposed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IDisposable> _disposables;
    private int _count;
    private static int SHRINK_THRESHOLD;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsDisposed { get; }
    public CompositeDisposable(int capacity);
    public CompositeDisposable(IDisposable[] disposables);
    public CompositeDisposable(IEnumerable`1<IDisposable> disposables);
    public sealed virtual int get_Count();
    public sealed virtual void Add(IDisposable item);
    public sealed virtual bool Remove(IDisposable item);
    public sealed virtual void Dispose();
    public sealed virtual void Clear();
    public sealed virtual bool Contains(IDisposable item);
    public sealed virtual void CopyTo(IDisposable[] array, int arrayIndex);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual IEnumerator`1<IDisposable> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool get_IsDisposed();
}
[ExtensionAttribute]
internal static class Uno.Disposables.CompositeDisposableExtensions : object {
    [ExtensionAttribute]
public static CompositeDisposable Add(CompositeDisposable disposable, Action action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Uno.Disposables.ConditionalDisposable : object {
    private static ConditionalWeakTable`2<object, List`1<IDisposable>> _registrations;
    private bool _disposed;
    [NullableAttribute("2")]
private WeakReference _conditionSource;
    private List`1<IDisposable> _list;
    public ConditionalDisposable(object target, WeakReference conditionSource);
    private static ConditionalDisposable();
    private static List`1<IDisposable> CreateList(object key);
    public sealed virtual void Dispose();
    protected abstract virtual void TargetFinalized();
    private void Dispose(bool disposing);
    protected virtual override void Finalize();
}
internal class Uno.Disposables.DefaultDisposable : object {
    public static DefaultDisposable Instance;
    private static DefaultDisposable();
    public sealed virtual void Dispose();
}
internal static class Uno.Disposables.Disposable : object {
    public static IDisposable Empty { get; }
    public static IDisposable get_Empty();
    public static IDisposable Create(Action dispose);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Uno.Disposables.DisposableExtensions : object {
    [ExtensionAttribute]
public static T DisposeWith(T disposable, ICollection`1<IDisposable> composite);
    [ExtensionAttribute]
public static T DisposeWith(T disposable, SerialDisposable serialDisposable);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void SafeDispose(IDisposable disposable);
    [ExtensionAttribute]
public static bool TryDispose(object maybeDisposableObject);
}
internal class Uno.Disposables.DisposableStruct`1 : ValueType {
    [CompilerGeneratedAttribute]
private Action`1<T> <disposingAction>P;
    [CompilerGeneratedAttribute]
private T <argToAction>P;
    private bool _disposed;
    public DisposableStruct`1(Action`1<T> disposingAction, T argToAction);
    public sealed virtual void Dispose();
}
internal interface Uno.Disposables.ICancelable {
    public bool IsDisposed { get; }
    public abstract virtual bool get_IsDisposed();
}
internal class Uno.Disposables.RefCountDisposable : object {
    private bool _throwWhenDisposed;
    [NullableAttribute("2")]
private IDisposable _disposable;
    private int _count;
    public bool IsDisposed { get; }
    [NullableContextAttribute("1")]
public RefCountDisposable(IDisposable disposable);
    [NullableContextAttribute("1")]
public RefCountDisposable(IDisposable disposable, bool throwWhenDisposed);
    public sealed virtual bool get_IsDisposed();
    [NullableContextAttribute("1")]
public IDisposable GetDisposable();
    public sealed virtual void Dispose();
    private void Release();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Uno.Disposables.SerialDisposable : object {
    [NullableAttribute("1")]
private object _gate;
    private IDisposable _current;
    private bool _disposed;
    public bool IsDisposed { get; }
    public IDisposable Disposable { get; public set; }
    public sealed virtual bool get_IsDisposed();
    public IDisposable get_Disposable();
    public void set_Disposable(IDisposable value);
    public sealed virtual void Dispose();
}
internal static class Uno.Equality.ByteSequenceComparer : object {
    internal static bool Equals(ImmutableArray`1<byte> x, ImmutableArray`1<byte> y);
    internal static int GetHashCode(ImmutableArray`1<byte> x);
}
internal static class Uno.Equality.Hash : object {
    internal static int FnvOffsetBias;
    internal static int FnvPrime;
    internal static int GetFNVHashCode(ImmutableArray`1<byte> data);
}
internal interface Uno.Equality.IKeyEquatable {
    public abstract virtual int GetKeyHashCode();
    public abstract virtual bool KeyEquals(object other);
}
internal interface Uno.Equality.IKeyEquatable`1 {
    public abstract virtual int GetKeyHashCode();
    public abstract virtual bool KeyEquals(T other);
}
internal class Uno.Equality.KeyEqualityComparer : object {
    [CompilerGeneratedAttribute]
private static IEqualityComparer <Default>k__BackingField;
    public static IEqualityComparer Default { get; }
    private static KeyEqualityComparer();
    [CompilerGeneratedAttribute]
public static IEqualityComparer get_Default();
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    public sealed virtual int GetHashCode(object obj);
    private IKeyEquatable GetKeyEquatable(object o);
}
[ExtensionAttribute]
internal static class Uno.Extensions.AssemblyExtensions : object {
    [ExtensionAttribute]
public static Version GetVersionNumber(Assembly assembly);
    [GeneratedRegexAttribute("(\d+)(.\d+)(.\d+)?(.\d+)?")]
[GeneratedCodeAttribute("System.Text.RegularExpressions.Generator", "9.0.10.32707")]
private static Regex VersionMatch();
}
internal class Uno.Extensions.BindableGroup`2 : object {
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<TItem> <Items>k__BackingField;
    public TKey Key { get; private set; }
    public IList`1<TItem> Items { get; private set; }
    public bool HasItems { get; }
    public BindableGroup`2(TKey key);
    public BindableGroup`2(TKey key, IList`1<TItem> items);
    [CompilerGeneratedAttribute]
public sealed virtual TKey get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(TKey value);
    [CompilerGeneratedAttribute]
public IList`1<TItem> get_Items();
    [CompilerGeneratedAttribute]
private void set_Items(IList`1<TItem> value);
    public sealed virtual bool get_HasItems();
    public sealed virtual IEnumerator`1<TItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Uno.Extensions.CollectionExtensions : object {
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static int Remove(ICollection`1<T> collection, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool AddDistinct(ICollection`1<T> collection, T item);
    [ExtensionAttribute]
public static TResult[] SelectToArray(TSource[] source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static TResult[] SelectToArray(IReadOnlyList`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static TResult[] SelectToArray(ICollection`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static List`1<TResult> SelectToList(ICollection`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static List`1<TResult> SelectToList(IList`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static List`1<TResult> SelectToList(List`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
public static List`1<TResult> SelectToList(List`1<TSource> source, Func`3<TSource, int, TResult> selector);
    [ExtensionAttribute]
public static List`1<TSource> WhereToList(List`1<TSource> source, Func`2<TSource, bool> selector);
}
[ExtensionAttribute]
internal static class Uno.Extensions.DateTimeExtensions : object {
    private static int DaysPerYear;
    private static int DaysPer4Years;
    private static int DaysPer100Years;
    private static int DaysPer400Years;
    private static int DaysTo1970;
    private static long UnixEpochTicks;
    private static long UnixEpochMilliseconds;
    [ExtensionAttribute]
public static long ToUnixTimeMilliseconds(DateTime instance);
}
[ExtensionAttribute]
internal static class Uno.Extensions.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue FindOrCreate(IDictionary`2<TKey, TValue> items, TKey key, Func`1<TValue> factory);
    [ExtensionAttribute]
public static TValue UnoGetValueOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue UnoGetValueOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    [ExtensionAttribute]
public static IEnumerable`1<TKey> RemoveKeys(IDictionary`2<TKey, TValue> items, IEnumerable`1<TKey> range);
    [ExtensionAttribute]
public static void Merge(IDictionary`2<TKey, TValue> dictionnary, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
}
[ExtensionAttribute]
internal static class Uno.Extensions.EnumerableExtensions : object {
    private static Char[] _allowedGroupNames;
    private static EnumerableExtensions();
    [ExtensionAttribute]
public static IEnumerable`1<T> ForEach(IEnumerable`1<T> items, Action`1<KeyValuePair`2<int, T>> action);
    [ExtensionAttribute]
public static IEnumerable`1<T> ForEach(IEnumerable`1<T> items, Action`2<int, T> action);
    [ExtensionAttribute]
public static IEnumerable`1<T> ForEach(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static IEnumerable`1<T> ForEach(IEnumerable`1<T> items, Action`1<T> action);
    [ExtensionAttribute]
public static bool None(IEnumerable`1<T> items, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool None(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool Empty(IEnumerable`1<T> items);
    [IteratorStateMachineAttribute("Uno.Extensions.EnumerableExtensions/<Concat>d__7`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> items, T item);
    [ExtensionAttribute]
public static IEnumerable`1<T> Except(IEnumerable`1<T> source, T[] items);
    [ExtensionAttribute]
public static IEnumerable`1<T> Except(IEnumerable`1<T> source, IEqualityComparer`1<T> equalityComparer, T[] items);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> items, T item);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> items, T item, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> items, T item, Func`3<T, T, bool> predicate);
    [ExtensionAttribute]
public static TResult SingleOrDefault(IEnumerable`1<T> items, Func`2<T, TResult> selector);
    [ExtensionAttribute]
public static T MaxOrDefault(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ValueTuple`2<TSource, TComparable> MinBy(IEnumerable`1<TSource> source, Func`2<TSource, TComparable> selector);
    [ExtensionAttribute]
public static IEnumerable`1<T> Range(IEnumerable`1<T> collection, int start, int before, int after, bool fixedCount);
    [IteratorStateMachineAttribute("Uno.Extensions.EnumerableExtensions/<Do>d__17`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Do(IEnumerable`1<T> source, Action`1<T> action);
    [ExtensionAttribute]
public static IEnumerable`1<T> Trim(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static IEnumerable`1<T> Trim(IEnumerable`1<Nullable`1<T>> items);
    [ExtensionAttribute]
public static IEnumerable`1<T> Safe(IEnumerable`1<T> items);
    [IteratorStateMachineAttribute("Uno.Extensions.EnumerableExtensions/<Flatten>d__21`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Flatten(IEnumerable`1<T> enumerable, Func`2<T, IEnumerable`1<T>> predicate);
    [IteratorStateMachineAttribute("Uno.Extensions.EnumerableExtensions/<Flatten>d__22`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Flatten(T item, Func`2<T, IEnumerable`1<T>> predicate);
    [IteratorStateMachineAttribute("Uno.Extensions.EnumerableExtensions/<Flatten>d__23`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> Flatten(T item, Func`2<T, T> predicate);
    [ExtensionAttribute]
public static bool AllTrue(IEnumerable`1<bool> source);
    public static TResult MaxOrDefault(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector, TResult defaultValue);
    [ExtensionAttribute]
public static Dictionary`2<TKey, IEnumerable`1<TValue>> ToDictionary(IEnumerable`1<IGrouping`2<TKey, TValue>> groups);
    [ExtensionAttribute]
public static Dictionary`2<TKey, IEnumerable`1<TValue>> ToDictionary(IEnumerable`1<IGrouping`2<TKey, TValue>> groups, IEqualityComparer`1<TKey> equalityComparer);
    [IteratorStateMachineAttribute("Uno.Extensions.EnumerableExtensions/<SelectManyUntyped>d__28`1")]
[ExtensionAttribute]
public static IEnumerable SelectManyUntyped(IEnumerable`1<TSource> source, Func`2<TSource, IEnumerable> selector);
    [IteratorStateMachineAttribute("Uno.Extensions.EnumerableExtensions/<GroupBy>d__29`1")]
[ExtensionAttribute]
public static IEnumerable`1<IEnumerable`1<T>> GroupBy(IEnumerable`1<T> items, int itemsByGroup);
    [IteratorStateMachineAttribute("Uno.Extensions.EnumerableExtensions/<Take>d__30`1")]
private static IEnumerable`1<T> Take(IEnumerator`1<T> enumerator, T first, int count);
    [ExtensionAttribute]
public static IEnumerable`1<IBindableGrouping`2<string, T>> GroupAlphabetically(IEnumerable`1<T> items, Func`2<T, string> keySelector, bool includeEmptyGroups);
    [ExtensionAttribute]
public static IEnumerable`1<IBindableGrouping`2<TKey, TItem>> GroupBy(IEnumerable`1<TItem> items, GroupDescriptor`2[] descriptors);
}
[ExtensionAttribute]
internal static class Uno.Extensions.FormattableExtensions : object {
    [ExtensionAttribute]
public static string ToStringInvariant(T number);
}
[ExtensionAttribute]
internal static class Uno.Extensions.FuncAsyncExtensions : object {
    [ExtensionAttribute]
public static FuncAsync`1<TResult> LockInvocation(FuncAsync`1<TResult> func, InvocationLockingMode mode);
    [ExtensionAttribute]
public static FuncAsync`2<TParam, TResult> LockInvocation(FuncAsync`2<TParam, TResult> func, InvocationLockingMode mode);
}
[ExtensionAttribute]
internal static class Uno.Extensions.FuncExtensions : object {
    private static ConditionalWeakTable`2<object, ConcurrentDictionary`2<object, object>> _weakResults;
    private static FuncExtensions();
    [ExtensionAttribute]
public static Func`1<TResult> AsWeakMemoized(Func`2<TSource, TResult> selector, TSource source);
}
[ExtensionAttribute]
internal static class Uno.Extensions.FuncMemoizeExtensions : object {
    [ExtensionAttribute]
public static Func`1<T> AsMemoized(Func`1<T> func);
    [ExtensionAttribute]
public static Func`2<TParam, TResult> AsMemoized(Func`2<TParam, TResult> func);
    [ExtensionAttribute]
public static Func`3<TParam1, TParam2, TResult> AsMemoized(Func`3<TParam1, TParam2, TResult> func);
    [ExtensionAttribute]
public static Func`4<TParam1, TParam2, TParam3, TResult> AsMemoized(Func`4<TParam1, TParam2, TParam3, TResult> func);
    [ExtensionAttribute]
public static Func`5<TParam1, TParam2, TParam3, TParam4, TResult> AsMemoized(Func`5<TParam1, TParam2, TParam3, TParam4, TResult> func);
    [ExtensionAttribute]
public static Func`6<TParam1, TParam2, TParam3, TParam4, TParam5, TResult> AsMemoized(Func`6<TParam1, TParam2, TParam3, TParam4, TParam5, TResult> func);
    [ExtensionAttribute]
public static Func`1<T> AsLockedMemoized(Func`1<T> func);
    [ExtensionAttribute]
public static Func`2<TKey, TResult> AsLockedMemoized(Func`2<TKey, TResult> func);
    [ExtensionAttribute]
public static Func`3<TArg1, TArg2, TResult> AsLockedMemoized(Func`3<TArg1, TArg2, TResult> func);
    [ExtensionAttribute]
public static Func`4<TArg1, TArg2, TArg3, TResult> AsLockedMemoized(Func`4<TArg1, TArg2, TArg3, TResult> func);
    [ExtensionAttribute]
public static Func`5<TArg1, TArg2, TArg3, TArg4, TResult> AsLockedMemoized(Func`5<TArg1, TArg2, TArg3, TArg4, TResult> func);
}
internal class Uno.Extensions.GroupDescriptor`2 : object {
    [CompilerGeneratedAttribute]
private Func`2<TItem, bool> <Selector>k__BackingField;
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Required>k__BackingField;
    public Func`2<TItem, bool> Selector { get; private set; }
    public TKey Key { get; private set; }
    public bool Required { get; private set; }
    public GroupDescriptor`2(TKey key);
    public GroupDescriptor`2(TKey key, Func`2<TItem, bool> selector, bool required);
    [CompilerGeneratedAttribute]
public Func`2<TItem, bool> get_Selector();
    [CompilerGeneratedAttribute]
private void set_Selector(Func`2<TItem, bool> value);
    [CompilerGeneratedAttribute]
public TKey get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(TKey value);
    [CompilerGeneratedAttribute]
public bool get_Required();
    [CompilerGeneratedAttribute]
private void set_Required(bool value);
}
internal class Uno.Extensions.GroupDescriptorComparer`1 : object {
    private List`1<TKey> _keys;
    public GroupDescriptorComparer`1(IEnumerable`1<TKey> descriptors);
    public sealed virtual int Compare(TKey x, TKey y);
}
internal interface Uno.Extensions.IBindableGrouping`2 {
    public bool HasItems { get; }
    public abstract virtual bool get_HasItems();
}
internal interface Uno.Extensions.IIndentedStringBuilder {
    public int CurrentLevel { get; }
    public abstract virtual int get_CurrentLevel();
    public abstract virtual void Append(string text);
    public abstract virtual void AppendLine();
    public abstract virtual void AppendMultiLineIndented(string text);
    public abstract virtual IDisposable Block(int count);
    public abstract virtual IDisposable Block(IFormatProvider formatProvider, string pattern, Object[] parameters);
    public abstract virtual IDisposable Indent(int count);
    public abstract virtual string ToString();
    public abstract virtual void AppendIndented(string text);
    public abstract virtual void AppendIndented(ReadOnlySpan`1<char> text);
    public abstract virtual void AppendFormatIndented(IFormatProvider formatProvider, string text, Object[] replacements);
}
internal class Uno.Extensions.IndentedStringBuilder : object {
    [CompilerGeneratedAttribute]
private StringBuilder <Builder>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentLevel>k__BackingField;
    public StringBuilder Builder { get; }
    public int CurrentLevel { get; private set; }
    [CompilerGeneratedAttribute]
public StringBuilder get_Builder();
    [CompilerGeneratedAttribute]
public sealed virtual int get_CurrentLevel();
    [CompilerGeneratedAttribute]
private void set_CurrentLevel(int value);
    public sealed virtual IDisposable Indent(int count);
    public sealed virtual IDisposable Block(int count);
    public sealed virtual IDisposable Block(IFormatProvider formatProvider, string pattern, Object[] parameters);
    public sealed virtual void Append(string text);
    public sealed virtual void AppendIndented(string text);
    public sealed virtual void AppendIndented(ReadOnlySpan`1<char> text);
    private void AppendIndented(char c, int indentCount);
    public sealed virtual void AppendFormatIndented(IFormatProvider formatProvider, string text, Object[] replacements);
    public sealed virtual void AppendLine();
    public sealed virtual void AppendMultiLineIndented(string text);
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class Uno.Extensions.IndentedStringBuilderExtensions : object {
    [ExtensionAttribute]
public static void AppendLineIndented(IIndentedStringBuilder builder, string pattern);
    [ExtensionAttribute]
public static void AppendLineInvariantIndented(IIndentedStringBuilder builder, string pattern, Object[] replacements);
    [ExtensionAttribute]
public static IDisposable Indent(IIndentedStringBuilder builder, string opening, string closing);
    [ExtensionAttribute]
public static IDisposable BlockInvariant(IIndentedStringBuilder builder, string pattern, Object[] parameters);
    [ExtensionAttribute]
public static IDisposable BlockInvariant(IIndentedStringBuilder builder, string pattern);
}
internal enum Uno.Extensions.InvocationLockingMode : Enum {
    public int value__;
    public static InvocationLockingMode Serial;
    public static InvocationLockingMode Share;
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class Uno.Extensions.JavaObjectExtensions : object {
    [ExtensionAttribute]
public static void RunIfNativeInstanceAvailable(T instance, Action`1<T> action, string member, int line, string filePath);
}
[ExtensionAttribute]
internal static class Uno.Extensions.ListExtensions : object {
    [ExtensionAttribute]
public static IList`1<T> AsReadOnly(IList`1<T> items);
    [ExtensionAttribute]
public static void AddRange(IList destination, IEnumerable source);
    [ExtensionAttribute]
public static void AddOrReplaceRange(IList`1<T> list, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static void AddOrReplaceRange(IList`1<T> list, IEnumerable`1<T> items, Func`3<T, T, bool> predicate);
    [ExtensionAttribute]
public static void RemoveAllAt(List`1<T> list, int index);
    [ExtensionAttribute]
public static int Replace(IList`1<T> list, Func`2<T, bool> selector, T replacement);
    [IteratorStateMachineAttribute("Uno.Extensions.ListExtensions/<ToDivergentEnumerable>d__6`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> ToDivergentEnumerable(IList`1<T> list, int startingAt);
    [IteratorStateMachineAttribute("Uno.Extensions.ListExtensions/<ToDivergentEnumerable>d__7`1")]
[ExtensionAttribute]
public static IEnumerable`1<T> ToDivergentEnumerable(IReadOnlyList`1<T> list, int startingAt);
    [ExtensionAttribute]
public static bool ContainsIndex(IList`1<T> list, int index);
    [ExtensionAttribute]
public static bool ContainsIndex(IReadOnlyList`1<T> list, int index);
    [ExtensionAttribute]
public static T FindNearestItem(IList`1<T> list, Func`2<T, bool> predicate, int startingAt);
    [ExtensionAttribute]
public static T FindNearestItem(IReadOnlyList`1<T> list, Func`2<T, bool> predicate, int startingAt);
    [ExtensionAttribute]
public static int IndexOf(IList list, object value, IEqualityComparer comparer);
    [ExtensionAttribute]
public static int IndexOf(IReadOnlyList`1<T> list, T value);
    [ExtensionAttribute]
public static int IndexOf(IReadOnlyList`1<T> list, T value, IEqualityComparer comparer);
    [ExtensionAttribute]
public static bool SequenceKeyEqual(IList`1<T> first, IList`1<T> second);
}
[ExtensionAttribute]
public static class Uno.Extensions.NotifyCollectionChangedEventArgsExtensions : object {
    [ExtensionAttribute]
public static IVectorChangedEventArgs ToVectorChangedEventArgs(NotifyCollectionChangedEventArgs notifyCollectionChangedEventArgs);
    [ExtensionAttribute]
public static CollectionChange ToCollectionChange(NotifyCollectionChangedAction action);
    [ExtensionAttribute]
public static NotifyCollectionChangedEventArgs ToNotifyCollectionChangedEventArgs(IVectorChangedEventArgs vectorChangedEventArgs);
    [ExtensionAttribute]
public static NotifyCollectionChangedAction ToNotifyCollectionChangedAction(CollectionChange change);
}
[ExtensionAttribute]
internal static class Uno.Extensions.ObjectExtensions : object {
    [ExtensionAttribute]
public static void Maybe(TInstance instance, Action`1<TInstance> action);
    [ExtensionAttribute]
public static void Maybe(object instance, Action`1<TInstance> action);
    [ExtensionAttribute]
public static TResult SelectOrDefault(TInstance instance, Func`2<TInstance, TResult> selector);
    [ExtensionAttribute]
public static TResult SelectOrDefault(TInstance instance, Func`2<TInstance, TResult> selector, TResult defaultValue);
    [ExtensionAttribute]
public static bool SafeEquals(T obj, T other);
    [ExtensionAttribute]
public static TSource Apply(TSource source, Action`1<TSource> action);
}
[ExtensionAttribute]
internal static class Uno.Extensions.ObservableCollectionExtensions : object {
    [ExtensionAttribute]
public static void Update(IList`1<T> collection, IEnumerable`1<T> updated, bool tryDispose, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static ObservableCollectionUpdateResults`1<T> UpdateWithResults(IList`1<T> collection, IEnumerable`1<T> updated, bool tryDispose, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
private static ValueTuple`4<IEnumerable`1<T>, IEnumerable`1<T>, IEnumerable`1<T>, KeptInfo`1[]> InternalUpdate(IList`1<T> collection, IEnumerable`1<T> updated, bool tryDispose, bool needKept, IEqualityComparer`1<T> comparer);
    private static void InsertNewItems(IList`1<T> collection, T[] array, T[] added, IEqualityComparer`1<T> comparer);
    private static void ManipulateItems(IList`1<T> collection, KeptInfo`1[] kept);
    private static KeptInfo`1[] GetKeptItems(IList`1<T> collection, T[] array, IEqualityComparer`1<T> comparer);
}
internal class Uno.Extensions.ObservableCollectionUpdateResults`1 : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<T> <Added>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<T> <Moved>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<T> <Removed>k__BackingField;
    public IEnumerable`1<T> Added { get; }
    public IEnumerable`1<T> Moved { get; }
    public IEnumerable`1<T> Removed { get; }
    public ObservableCollectionUpdateResults`1(IEnumerable`1<T> added, IEnumerable`1<T> moved, IEnumerable`1<T> removed);
    [CompilerGeneratedAttribute]
public IEnumerable`1<T> get_Added();
    [CompilerGeneratedAttribute]
public IEnumerable`1<T> get_Moved();
    [CompilerGeneratedAttribute]
public IEnumerable`1<T> get_Removed();
}
[ExtensionAttribute]
internal static class Uno.Extensions.QueueExtensions : object {
    [ExtensionAttribute]
public static bool Remove(Queue`1<T> queue, Func`2<T, bool> predicate);
}
public class Uno.Extensions.SpanAction`2 : MulticastDelegate {
    public SpanAction`2(object object, IntPtr method);
    public virtual void Invoke(Span`1<T> span, TArg arg);
    public virtual IAsyncResult BeginInvoke(Span`1<T> span, TArg arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class Uno.Extensions.Specialized.EnumerableExtensions : object {
    [ExtensionAttribute]
public static int Count(IEnumerable enumerable);
    [ExtensionAttribute]
public static bool Any(IEnumerable items);
    [ExtensionAttribute]
public static Object[] ToObjectArray(IEnumerable items);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable items, object item);
    [ExtensionAttribute]
public static object ElementAt(IEnumerable items, int position);
    [ExtensionAttribute]
public static object ElementAtOrDefault(IEnumerable items, int position);
    [ExtensionAttribute]
public static void ForEach(IEnumerable enumerable, Action`1<object> action);
    [ExtensionAttribute]
public static bool None(IEnumerable source);
    [IteratorStateMachineAttribute("Uno.Extensions.Specialized.EnumerableExtensions/<Where>d__8")]
[ExtensionAttribute]
public static IEnumerable Where(IEnumerable source, Func`2<object, bool> predicate);
    [ExtensionAttribute]
public static bool Contains(IEnumerable source, object value);
}
[ExtensionAttribute]
internal static class Uno.Extensions.StackExtensions : object {
    [ExtensionAttribute]
public static IDisposable Subscribe(Stack`1<T> stack, T value);
}
[ExtensionAttribute]
internal static class Uno.Extensions.StreamExtensions : object {
    [AsyncStateMachineAttribute("Uno.Extensions.StreamExtensions/<ReadBytesAsync>d__0")]
[ExtensionAttribute]
public static Task`1<Byte[]> ReadBytesAsync(Stream stream);
}
[ExtensionAttribute]
internal static class Uno.Extensions.StringBuilderExtensions : object {
    [ExtensionAttribute]
public static void AppendFormatInvariant(StringBuilder builder, string format, Object[] args);
}
[ExtensionAttribute]
internal static class Uno.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static LineSplitEnumerator SplitLines(string instance);
    [ExtensionAttribute]
public static LineSplitEnumerator SplitLines(ReadOnlySpan`1<char> instance);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(string instance);
    [ExtensionAttribute]
public static bool IsNullOrWhiteSpace(string instance);
    [ExtensionAttribute]
public static bool Contains(string instance, string value, StringComparison comparisonType);
    [ExtensionAttribute]
public static string JoinBy(IEnumerable`1<string> items, string joinBy);
    [ExtensionAttribute]
public static string InvariantCultureFormat(string instance, Object[] array);
    [ExtensionAttribute]
public static string TrimStart(string source, string trimText, bool ignoreCase);
    [ExtensionAttribute]
public static string TrimEnd(string source, string trimText);
    public static string Create(int length, TState state, SpanAction`2<char, TState> action);
}
[ExtensionAttribute]
internal static class Uno.Extensions.TypeExtensions : object {
    [ExtensionAttribute]
public static bool Is(Type type);
    [ExtensionAttribute]
public static bool Is(Type instance, Type type);
    [ExtensionAttribute]
public static IEnumerable`1<ConstructorInfo> GetConstructors(TypeInfo type);
    [ExtensionAttribute]
public static bool IsNullable(Type type);
    [ExtensionAttribute]
public static bool IsGenericDescentOf(Type type, Type genericTypeDefinition);
    [IteratorStateMachineAttribute("Uno.Extensions.TypeExtensions/<EnumerateAncestorTypes>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<Type> EnumerateAncestorTypes(Type type, bool includeSelf);
}
[ExtensionAttribute]
public static class Uno.Extensions.UriExtensions : object {
    private static int EscapeDataStringCharactersMaxLength;
    private static Char[] _uriSplitChars;
    private static UriExtensions();
    [ExtensionAttribute]
public static IDictionary`2<string, string> GetParameters(Uri uri);
    [ExtensionAttribute]
internal static Uri TrimEndUriSlash(Uri uri);
    [ExtensionAttribute]
public static string GetExtension(Uri uri);
    [ExtensionAttribute]
public static bool IsAppData(Uri uri);
    [ExtensionAttribute]
public static bool IsLocalResource(Uri uri);
    public static string EscapeDataString(string value);
}
[ExtensionAttribute]
internal static class Uno.Extensions.WeakReferenceExtensions : object {
    [ExtensionAttribute]
public static T GetTarget(WeakReference`1<T> wr);
}
[AttributeUsageAttribute("1")]
internal class Uno.Foundation.Diagnostics.CodeAnalysis.AdditionalLinkerHintAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FullTypeName>k__BackingField;
    public string FullTypeName { get; }
    public AdditionalLinkerHintAttribute(string fullTypeName);
    [CompilerGeneratedAttribute]
public string get_FullTypeName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Uno.Foundation.Extensibility.ApiExtensibility : object {
    private static object _gate;
    private static Dictionary`2<Type, Func`2<object, object>> _registrations;
    private static ApiExtensibility();
    public static void Register(Type type, Func`2<object, object> builder);
    public static void Register(Type type, Func`2<TOwner, object> builder);
    [NullableContextAttribute("2")]
public static bool IsRegistered();
    public static bool CreateInstance(object owner, T& instance);
    internal static T CreateInstance(object owner);
}
[AttributeUsageAttribute("1")]
public class Uno.Foundation.Extensibility.ApiExtensionAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ExtensionType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ExtendedType>k__BackingField;
    public Type ExtensionType { get; }
    public Type ExtendedType { get; }
    public ApiExtensionAttribute(Type extendedType, Type extensionType);
    [CompilerGeneratedAttribute]
public Type get_ExtensionType();
    [CompilerGeneratedAttribute]
public Type get_ExtendedType();
}
public static class Uno.FoundationFeatureConfiguration : object {
    internal static void RestoreDefaults();
}
internal class Uno.FuncAsync`1 : MulticastDelegate {
    public FuncAsync`1(object object, IntPtr method);
    public virtual Task`1<TResult> Invoke(CancellationToken ct);
    public virtual IAsyncResult BeginInvoke(CancellationToken ct, AsyncCallback callback, object object);
    public virtual Task`1<TResult> EndInvoke(IAsyncResult result);
}
internal class Uno.FuncAsync`2 : MulticastDelegate {
    public FuncAsync`2(object object, IntPtr method);
    public virtual Task`1<TResult> Invoke(CancellationToken ct, T1 t1);
    public virtual IAsyncResult BeginInvoke(CancellationToken ct, T1 t1, AsyncCallback callback, object object);
    public virtual Task`1<TResult> EndInvoke(IAsyncResult result);
}
internal class Uno.FuncAsync`3 : MulticastDelegate {
    public FuncAsync`3(object object, IntPtr method);
    public virtual Task`1<TResult> Invoke(CancellationToken ct, T1 t1, T2 t2);
    public virtual IAsyncResult BeginInvoke(CancellationToken ct, T1 t1, T2 t2, AsyncCallback callback, object object);
    public virtual Task`1<TResult> EndInvoke(IAsyncResult result);
}
internal class Uno.FuncAsync`4 : MulticastDelegate {
    public FuncAsync`4(object object, IntPtr method);
    public virtual Task`1<TResult> Invoke(CancellationToken ct, T1 t1, T2 t2, T3 t3);
    public virtual IAsyncResult BeginInvoke(CancellationToken ct, T1 t1, T2 t2, T3 t3, AsyncCallback callback, object object);
    public virtual Task`1<TResult> EndInvoke(IAsyncResult result);
}
internal class Uno.FuncAsync`5 : MulticastDelegate {
    public FuncAsync`5(object object, IntPtr method);
    public virtual Task`1<TResult> Invoke(CancellationToken ct, T1 t1, T2 t2, T3 t3, T4 t4);
    public virtual IAsyncResult BeginInvoke(CancellationToken ct, T1 t1, T2 t2, T3 t3, T4 t4, AsyncCallback callback, object object);
    public virtual Task`1<TResult> EndInvoke(IAsyncResult result);
}
internal static class Uno.Funcs : object {
    public static Func`1<TResult> Create(Func`1<TResult> function);
    public static Func`2<TParam, TResult> Create(Func`2<TParam, TResult> function);
    public static Func`3<TParam1, TParam2, TResult> Create(Func`3<TParam1, TParam2, TResult> function);
    public static Func`4<TParam1, TParam2, TParam3, TResult> Create(Func`4<TParam1, TParam2, TParam3, TResult> function);
    public static Func`1<TResult> CreateMemoized(Func`1<TResult> function);
    public static Func`1<TResult> CreateLockedMemoized(Func`1<TResult> function);
    public static Func`2<TParam, TResult> CreateMemoized(Func`2<TParam, TResult> function);
    public static Func`3<TParam1, TParam2, TResult> CreateMemoized(Func`3<TParam1, TParam2, TResult> function);
    public static Func`4<TParam1, TParam2, TParam3, TResult> CreateMemoized(Func`4<TParam1, TParam2, TParam3, TResult> function);
    public static Func`5<TParam1, TParam2, TParam3, TParam4, TResult> CreateMemoized(Func`5<TParam1, TParam2, TParam3, TParam4, TResult> function);
    public static Func`6<TParam1, TParam2, TParam3, TParam4, TParam5, TResult> CreateMemoized(Func`6<TParam1, TParam2, TParam3, TParam4, TParam5, TResult> function);
}
internal class Uno.Grouping`2 : object {
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TValues> <Values>k__BackingField;
    public TKey Key { get; private set; }
    public IEnumerable`1<TValues> Values { get; private set; }
    public Grouping`2(TKey key, IEnumerable`1<TValues> values);
    [CompilerGeneratedAttribute]
public sealed virtual TKey get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(TKey value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<TValues> get_Values();
    [CompilerGeneratedAttribute]
private void set_Values(IEnumerable`1<TValues> value);
    public sealed virtual IEnumerator`1<TValues> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[AttributeUsageAttribute("32767")]
public class Uno.NotImplementedAttribute : Attribute {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private String[] <Platforms>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Platforms { get; }
    [NullableContextAttribute("1")]
public NotImplementedAttribute(String[] platforms);
    [CompilerGeneratedAttribute]
public String[] get_Platforms();
}
[AttributeUsageAttribute("32767")]
[EditorBrowsableAttribute("1")]
public class Uno.PreserveAttribute : Attribute {
    public bool AllMembers;
    public bool Conditional;
    public PreserveAttribute(bool allMembers, bool conditional);
}
internal class Uno.ReferenceEqualityComparer`1 : object {
    public static ReferenceEqualityComparer`1<T> Default;
    private static ReferenceEqualityComparer`1();
    public sealed virtual bool Equals(T left, T right);
    public sealed virtual int GetHashCode(T obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Uno.StringBuilderCache : object {
    internal static int MaxBuilderSize;
    private static int DefaultCapacity;
    [NullableAttribute("2")]
[ThreadStaticAttribute]
private static StringBuilder t_cachedInstance;
    public static StringBuilder Acquire(int capacity);
    public static void Release(StringBuilder sb);
    public static string GetStringAndRelease(StringBuilder sb);
}
internal class Uno.Threading.AsyncLock : object {
    private SemaphoreSlim _semaphore;
    [AsyncStateMachineAttribute("Uno.Threading.AsyncLock/<LockAsync>d__1")]
public Task`1<IDisposable> LockAsync(CancellationToken ct);
    [CompilerGeneratedAttribute]
private void <LockAsync>b__1_0();
}
internal class Uno.Threading.FastTaskCompletionSource`1 : object {
    private int _terminationType;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _terminationSet;
    private ImmutableList`1<Action> _continuations;
    [CompilerGeneratedAttribute]
private ExceptionDispatchInfo <ExceptionInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Result>k__BackingField;
    private static SpinWait _spin;
    private Task`1<T> _task;
    public TerminationType<T> Termination { get; }
    public bool IsCompleted { get; }
    public bool IsCanceled { get; }
    public ExceptionDispatchInfo ExceptionInfo { get; private set; }
    public T Result { get; private set; }
    public Exception Exception { get; }
    public Task`1<T> Task { get; }
    public TerminationType<T> get_Termination();
    public bool get_IsCompleted();
    public bool get_IsCanceled();
    [CompilerGeneratedAttribute]
public ExceptionDispatchInfo get_ExceptionInfo();
    [CompilerGeneratedAttribute]
private void set_ExceptionInfo(ExceptionDispatchInfo value);
    [CompilerGeneratedAttribute]
public T get_Result();
    [CompilerGeneratedAttribute]
private void set_Result(T value);
    public Exception get_Exception();
    public void SetCanceled();
    public bool TrySetCanceled();
    public void SetException(Exception exception);
    public void SetException(ExceptionDispatchInfo exceptionInfo);
    public bool TrySetException(Exception exception);
    public bool TrySetException(ExceptionDispatchInfo exceptionInfo);
    public void SetResult(T result);
    public bool TrySetResult(T result);
    private void RaiseOnCompleted();
    public T GetResult();
    public FastTaskCompletionSource`1<T> GetAwaiter();
    public sealed virtual void OnCompleted(Action continuation);
    public Task`1<T> get_Task();
    private Task`1<T> CreateSyncTask();
    private void SpinUntilTermination();
    [AsyncStateMachineAttribute("Uno.Threading.FastTaskCompletionSource`1/<CreateAsyncTask>d__38")]
private Task`1<T> CreateAsyncTask();
}
internal static class Uno.Transactional : object {
    [NullableContextAttribute("1")]
public static T Update(T& original, Func`2<T, T> selector);
    [NullableContextAttribute("1")]
public static object Update(Object& original, Func`2<object, object> selector);
    [NullableContextAttribute("1")]
public static T Update(T& original, TParam param, Func`3<T, TParam, T> selector);
    [NullableContextAttribute("1")]
public static T Update(T& original, TParam1 param1, TParam2 param2, Func`4<T, TParam1, TParam2, T> selector);
    [NullableContextAttribute("1")]
public static TResult Update(TSource& original, Func`2<TSource, Tuple`2<TSource, TResult>> selector);
    [NullableContextAttribute("1")]
public static TResult Update(TSource& original, TParam param, Func`3<TSource, TParam, Tuple`2<TSource, TResult>> selector);
    public static TValue GetOrAdd(TDictionary& dictionary, TKey key, Func`2<TKey, TValue> factory);
    public static TValue GetOrAdd(TDictionary& dictionary, TKey key, TContext context, Func`3<TKey, TContext, TValue> factory);
    public static bool TryAdd(TDictionary& dictionary, TKey key, Func`2<TKey, TValue> factory, TValue& value);
    public static bool TryRemove(TDictionary& dictionary, TKey key, TValue& value);
    public static int Remove(TDictionary& list, Func`2<KeyValuePair`2<TKey, TValue>, bool> removeSelector);
    public static TValue SetItem(TDictionary& dictionary, TKey key, TValue value);
    public static TValue SetItem(TDictionary& dictionary, TKey key, Func`2<TKey, TValue> factory);
    public static bool TryUpdateItem(TDictionary& dictionary, TKey key, TValue value);
    public static bool TryUpdateItem(IImmutableDictionary`2& dictionary, TKey key, Func`3<TKey, TValue, TValue> factory);
    public static bool TryUpdateItem(ImmutableDictionary`2& dictionary, TKey key, Func`3<TKey, TValue, TValue> factory);
    public static bool TryUpdateItem(ImmutableSortedDictionary`2& dictionary, TKey key, Func`3<TKey, TValue, TValue> factory);
    public static TValue UpdateItem(IImmutableDictionary`2& dictionary, TKey key, Func`3<TKey, TValue, TValue> factory);
    public static TValue UpdateItem(ImmutableDictionary`2& dictionary, TKey key, Func`3<TKey, TValue, TValue> factory);
    public static TValue UpdateItem(ImmutableSortedDictionary`2& dictionary, TKey key, Func`3<TKey, TValue, TValue> factory);
    public static void Enqueue(TQueue& queue, T value);
    public static T Enqueue(TQueue& queue, Func`2<TQueue, T> valueFactory);
    public static bool TryDequeue(TQueue& queue, T& value);
    public static T Dequeue(TQueue& queue);
    public static TList Add(TList& list, T item);
    public static TList AddDistinct(TList& list, T item);
    public static TList AddDistinct(TList& list, T item, IEqualityComparer`1<T> comparer);
    public static bool TryAddDistinct(TList& list, T item);
    public static bool TryAddDistinct(TList& list, T item, IEqualityComparer`1<T> comparer);
    public static bool Remove(TList& list, T item);
    public static int Remove(TList& list, Func`2<T, bool> removeSelector);
    public static int RemoveRange(TList& list, T[] items);
    public static int RemoveRange(TList& list, T[] items, IEnumerable`1& removedItems);
}
internal class Uno.UI.Common.DelegateCommand : object {
    private Action _action;
    private bool _canExecuteEnabled;
    [CompilerGeneratedAttribute]
private EventHandler CanExecuteChanged;
    public bool CanExecuteEnabled { get; public set; }
    public DelegateCommand(Action action);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CanExecuteChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    public sealed virtual bool CanExecute(object parameter);
    public sealed virtual void Execute(object parameter);
    private void OnCanExecuteChanged();
    public bool get_CanExecuteEnabled();
    public void set_CanExecuteEnabled(bool value);
}
internal class Uno.UI.Common.DelegateCommand`1 : object {
    private Action`1<T> _action;
    private bool _canExecuteEnabled;
    [CompilerGeneratedAttribute]
private EventHandler CanExecuteChanged;
    public bool CanExecuteEnabled { get; public set; }
    public DelegateCommand`1(Action`1<T> action);
    [CompilerGeneratedAttribute]
public sealed virtual void add_CanExecuteChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CanExecuteChanged(EventHandler value);
    public sealed virtual bool CanExecute(object parameter);
    public sealed virtual void Execute(object parameter);
    private void OnCanExecuteChanged();
    public bool get_CanExecuteEnabled();
    public void set_CanExecuteEnabled(bool value);
}
[DebuggerDisplayAttribute("{DebugDisplay,nq}")]
[EditorBrowsableAttribute("1")]
internal class Uno.UI.IndexPath : ValueType {
    [CompilerGeneratedAttribute]
private int <Row>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Section>k__BackingField;
    [CompilerGeneratedAttribute]
private static IndexPath <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private static IndexPath <NotFound>k__BackingField;
    public int Row { get; }
    public int Section { get; }
    public static IndexPath Zero { get; }
    public static IndexPath NotFound { get; }
    private string DebugDisplay { get; }
    private IndexPath(int row, int section);
    private static IndexPath();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Row();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Section();
    public static IndexPath FromRowSection(int row, int section);
    private sealed virtual override int System.IComparable<Uno.UI.IndexPath>.CompareTo(IndexPath other);
    [CompilerGeneratedAttribute]
public static IndexPath get_Zero();
    [CompilerGeneratedAttribute]
public static IndexPath get_NotFound();
    public static bool op_LessThan(IndexPath indexPath1, IndexPath indexPath2);
    public static bool op_GreaterThan(IndexPath indexPath1, IndexPath indexPath2);
    public static bool op_LessThanOrEqual(IndexPath indexPath1, IndexPath indexPath2);
    public static bool op_GreaterThanOrEqual(IndexPath indexPath1, IndexPath indexPath2);
    public static bool op_Equality(IndexPath indexPath1, IndexPath indexPath2);
    public static bool op_Inequality(IndexPath indexPath1, IndexPath indexPath2);
    private static int Compare(IndexPath thisOne, IndexPath other);
    public virtual string ToString();
    private string get_DebugDisplay();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[AttributeUsageAttribute("32767")]
public class Uno.UnoOnlyAttribute : Attribute {
}
internal class Windows.Foundation.AsyncAction : object {
    private Task _task;
    private CancellationTokenSource _cancellationTokenSource;
    private AsyncActionCompletedHandler _onCompleted;
    private AsyncStatus _status;
    [CompilerGeneratedAttribute]
private Exception <ErrorCode>k__BackingField;
    public Task Task { get; }
    public UInt32 Id { get; }
    public Exception ErrorCode { get; private set; }
    public AsyncActionCompletedHandler Completed { get; public set; }
    public AsyncStatus Status { get; public set; }
    private AsyncAction(Func`2<CancellationToken, Task> taskBuilder);
    public static AsyncAction FromTask(Func`2<CancellationToken, Task> taskBuilder);
    public sealed virtual Task get_Task();
    public sealed virtual UInt32 get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual Exception get_ErrorCode();
    [CompilerGeneratedAttribute]
private void set_ErrorCode(Exception value);
    public sealed virtual AsyncActionCompletedHandler get_Completed();
    public sealed virtual void set_Completed(AsyncActionCompletedHandler value);
    public sealed virtual AsyncStatus get_Status();
    public void set_Status(AsyncStatus value);
    public sealed virtual void Cancel();
    public sealed virtual void Close();
    public sealed virtual void GetResults();
    [AsyncStateMachineAttribute("Windows.Foundation.AsyncAction/<BuildTaskAsync>d__23")]
private Task BuildTaskAsync(Func`2<CancellationToken, Task> taskBuilder);
}
public class Windows.Foundation.AsyncActionCompletedHandler : MulticastDelegate {
    public AsyncActionCompletedHandler(object object, IntPtr method);
    public virtual void Invoke(IAsyncAction asyncInfo, AsyncStatus asyncStatus);
    public virtual IAsyncResult BeginInvoke(IAsyncAction asyncInfo, AsyncStatus asyncStatus, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Windows.Foundation.AsyncActionProgressHandler`1 : MulticastDelegate {
    public AsyncActionProgressHandler`1(object object, IntPtr method);
    public virtual void Invoke(IAsyncActionWithProgress`1<TProgress> asyncInfo, TProgress progressInfo);
    public virtual IAsyncResult BeginInvoke(IAsyncActionWithProgress`1<TProgress> asyncInfo, TProgress progressInfo, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Windows.Foundation.AsyncActionWithProgressCompletedHandler`1 : MulticastDelegate {
    public AsyncActionWithProgressCompletedHandler`1(object object, IntPtr method);
    public virtual void Invoke(IAsyncActionWithProgress`1<TProgress> asyncInfo, AsyncStatus asyncStatus);
    public virtual IAsyncResult BeginInvoke(IAsyncActionWithProgress`1<TProgress> asyncInfo, AsyncStatus asyncStatus, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class Windows.Foundation.AsyncOperation : object {
    private static long _nextId;
    internal static UInt32 CreateId();
    public static AsyncOperation`1<TResult> FromTask(Func`2<CancellationToken, Task`1<TResult>> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Windows.Foundation.AsyncOperation`1 : object {
    private CancellationTokenSource _cts;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncOperationCompletedHandler`1<TResult> _onCompleted;
    private AsyncStatus _status;
    [CompilerGeneratedAttribute]
private UInt32 <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Task`1<TResult> <Task>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Exception <ErrorCode>k__BackingField;
    public UInt32 Id { get; }
    public Task`1<TResult> Task { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public AsyncOperationCompletedHandler`1<TResult> Completed { get; public set; }
    [NullableAttribute("2")]
public Exception ErrorCode { get; private set; }
    public AsyncStatus Status { get; public set; }
    public AsyncOperation`1(FuncAsync`2<AsyncOperation`1<TResult>, TResult> taskBuilder);
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_Id();
    [CompilerGeneratedAttribute]
public sealed virtual Task`1<TResult> get_Task();
    public sealed virtual AsyncOperationCompletedHandler`1<TResult> get_Completed();
    public sealed virtual void set_Completed(AsyncOperationCompletedHandler`1<TResult> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Exception get_ErrorCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_ErrorCode(Exception value);
    public sealed virtual AsyncStatus get_Status();
    public void set_Status(AsyncStatus value);
    public sealed virtual void Cancel();
    public sealed virtual void Close();
    public sealed virtual TResult GetResults();
    [AsyncStateMachineAttribute("Windows.Foundation.AsyncOperation`1/<BuildTaskAsync>d__23")]
private Task`1<TResult> BuildTaskAsync(FuncAsync`2<AsyncOperation`1<TResult>, TResult> taskBuilder);
}
public class Windows.Foundation.AsyncOperationCompletedHandler`1 : MulticastDelegate {
    public AsyncOperationCompletedHandler`1(object object, IntPtr method);
    public virtual void Invoke(IAsyncOperation`1<TResult> asyncInfo, AsyncStatus asyncStatus);
    public virtual IAsyncResult BeginInvoke(IAsyncOperation`1<TResult> asyncInfo, AsyncStatus asyncStatus, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Windows.Foundation.AsyncOperationProgressHandler`2 : MulticastDelegate {
    public AsyncOperationProgressHandler`2(object object, IntPtr method);
    public virtual void Invoke(IAsyncOperationWithProgress`2<TResult, TProgress> asyncInfo, TProgress progressInfo);
    public virtual IAsyncResult BeginInvoke(IAsyncOperationWithProgress`2<TResult, TProgress> asyncInfo, TProgress progressInfo, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class Windows.Foundation.AsyncOperationWithProgress : object {
    public static AsyncOperationWithProgress`2<TResult, TProgress> FromFuncAsync(FuncAsync`2<AsyncOperationWithProgress`2<TResult, TProgress>, TResult> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Windows.Foundation.AsyncOperationWithProgress`2 : AsyncOperation`1<TResult> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress> _completed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private AsyncOperationProgressHandler`2<TResult, TProgress> <Progress>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public AsyncOperationProgressHandler`2<TResult, TProgress> Progress { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress> Completed { get; public set; }
    public AsyncOperationWithProgress`2(FuncAsync`2<AsyncOperationWithProgress`2<TResult, TProgress>, TResult> taskBuilder);
    [CompilerGeneratedAttribute]
public sealed virtual AsyncOperationProgressHandler`2<TResult, TProgress> get_Progress();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Progress(AsyncOperationProgressHandler`2<TResult, TProgress> value);
    public sealed virtual AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress> get_Completed();
    public sealed virtual void set_Completed(AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress> value);
    public void NotifyProgress(TProgress progressInfo);
    private static FuncAsync`2<AsyncOperation`1<TResult>, TResult> Wrap(FuncAsync`2<AsyncOperationWithProgress`2<TResult, TProgress>, TResult> taskBuilder);
    private static AsyncOperationCompletedHandler`1<TResult> Wrap(AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress> handler);
}
public class Windows.Foundation.AsyncOperationWithProgressCompletedHandler`2 : MulticastDelegate {
    public AsyncOperationWithProgressCompletedHandler`2(object object, IntPtr method);
    public virtual void Invoke(IAsyncOperationWithProgress`2<TResult, TProgress> asyncInfo, AsyncStatus asyncStatus);
    public virtual IAsyncResult BeginInvoke(IAsyncOperationWithProgress`2<TResult, TProgress> asyncInfo, AsyncStatus asyncStatus, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Windows.Foundation.AsyncStatus : Enum {
    public int value__;
    public static AsyncStatus Started;
    public static AsyncStatus Completed;
    public static AsyncStatus Canceled;
    public static AsyncStatus Error;
}
public enum Windows.Foundation.Collections.CollectionChange : Enum {
    public int value__;
    public static CollectionChange Reset;
    public static CollectionChange ItemInserted;
    public static CollectionChange ItemRemoved;
    public static CollectionChange ItemChanged;
}
public interface Windows.Foundation.Collections.IIterator`1 {
    public T Current { get; }
    public bool HasCurrent { get; }
    public abstract virtual T get_Current();
    public abstract virtual bool get_HasCurrent();
    public abstract virtual bool MoveNext();
    public abstract virtual UInt32 GetMany(T[] items);
}
public interface Windows.Foundation.Collections.IMapChangedEventArgs`1 {
    public CollectionChange CollectionChange { get; }
    public K Key { get; }
    public abstract virtual CollectionChange get_CollectionChange();
    public abstract virtual K get_Key();
}
public interface Windows.Foundation.Collections.IObservableMap`2 {
    [CompilerGeneratedAttribute]
public abstract virtual void add_MapChanged(MapChangedEventHandler`2<K, V> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_MapChanged(MapChangedEventHandler`2<K, V> value);
}
[DefaultMemberAttribute("Item")]
internal interface Windows.Foundation.Collections.IObservableVector {
    public object Item { get; }
    public int Count { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_UntypedVectorChanged(VectorChangedEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_UntypedVectorChanged(VectorChangedEventHandler value);
    public abstract virtual object get_Item(int index);
    public abstract virtual int get_Count();
    public abstract virtual int IndexOf(object item);
    public abstract virtual void Add(object item);
    public abstract virtual void Insert(int index, object item);
    public abstract virtual void RemoveAt(int index);
}
public interface Windows.Foundation.Collections.IObservableVector`1 {
    [CompilerGeneratedAttribute]
public abstract virtual void add_VectorChanged(VectorChangedEventHandler`1<T> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_VectorChanged(VectorChangedEventHandler`1<T> value);
}
public interface Windows.Foundation.Collections.IPropertySet {
}
public interface Windows.Foundation.Collections.IVectorChangedEventArgs {
    public CollectionChange CollectionChange { get; }
    public UInt32 Index { get; }
    public abstract virtual CollectionChange get_CollectionChange();
    public abstract virtual UInt32 get_Index();
}
internal class Windows.Foundation.Collections.MapChangedEventArgs : object {
    [CompilerGeneratedAttribute]
private CollectionChange <CollectionChange>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public CollectionChange CollectionChange { get; public set; }
    public string Key { get; public set; }
    public MapChangedEventArgs(CollectionChange CollectionChange, string Key);
    [CompilerGeneratedAttribute]
protected MapChangedEventArgs(MapChangedEventArgs original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public sealed virtual CollectionChange get_CollectionChange();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CollectionChange(CollectionChange value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Key(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(MapChangedEventArgs left, MapChangedEventArgs right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(MapChangedEventArgs left, MapChangedEventArgs right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(MapChangedEventArgs other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual MapChangedEventArgs <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(CollectionChange& CollectionChange, String& Key);
}
public class Windows.Foundation.Collections.MapChangedEventHandler`2 : MulticastDelegate {
    public MapChangedEventHandler`2(object object, IntPtr method);
    public virtual void Invoke(IObservableMap`2<K, V> sender, IMapChangedEventArgs`1<K> event);
    public virtual IAsyncResult BeginInvoke(IObservableMap`2<K, V> sender, IMapChangedEventArgs`1<K> event, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[DefaultMemberAttribute("Item")]
internal class Windows.Foundation.Collections.NonNullList`1 : object {
    private List`1<T> _innerList;
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class Windows.Foundation.Collections.ObservableVector`1 : object {
    private List`1<T> _list;
    [CompilerGeneratedAttribute]
private VectorChangedEventHandler`1<T> VectorChanged;
    [CompilerGeneratedAttribute]
private VectorChangedEventHandler UntypedVectorChanged;
    private object Windows.Foundation.Collections.IObservableVector.Item { get; }
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.IList.Item { get; private set; }
    private sealed virtual override object Windows.Foundation.Collections.IObservableVector.get_Item(int index);
    public virtual T get_Item(int index);
    public virtual void set_Item(int index, T value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public sealed virtual void add_VectorChanged(VectorChangedEventHandler`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_VectorChanged(VectorChangedEventHandler`1<T> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_UntypedVectorChanged(VectorChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_UntypedVectorChanged(VectorChangedEventHandler value);
    private sealed virtual override void Windows.Foundation.Collections.IObservableVector.Add(object item);
    public virtual void Add(T item);
    public virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override int Windows.Foundation.Collections.IObservableVector.IndexOf(object item);
    public sealed virtual int IndexOf(T item);
    private sealed virtual override void Windows.Foundation.Collections.IObservableVector.Insert(int index, object item);
    public virtual void Insert(int index, T item);
    public sealed virtual bool Remove(T item);
    public virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void RaiseVectorChanged(CollectionChange change, int index);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private int GenericIndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
}
[DefaultMemberAttribute("Item")]
internal class Windows.Foundation.Collections.ObservableVectorEnumerableWrapper : ObservableVectorWrapper {
    private IEnumerable _source;
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public ObservableVectorEnumerableWrapper(IEnumerable source);
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(object item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object item);
    public sealed virtual void CopyTo(Object[] array, int arrayIndex);
    [IteratorStateMachineAttribute("Windows.Foundation.Collections.ObservableVectorEnumerableWrapper/<System-Collections-Generic-IEnumerable<System-Object>-GetEnumerator>d__13")]
private sealed virtual override IEnumerator`1<object> System.Collections.Generic.IEnumerable<System.Object>.GetEnumerator();
    public sealed virtual int IndexOf(object item);
    public sealed virtual void Insert(int index, object item);
    public sealed virtual bool Remove(object item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DefaultMemberAttribute("Item")]
internal class Windows.Foundation.Collections.ObservableVectorListWrapper : ObservableVectorWrapper {
    private IList _source;
    public object Item { get; public set; }
    public bool IsReadOnly { get; }
    public bool IsFixedSize { get; }
    public int Count { get; }
    public object SyncRoot { get; }
    public bool IsSynchronized { get; }
    public ObservableVectorListWrapper(IList source);
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    public sealed virtual bool get_IsReadOnly();
    public bool get_IsFixedSize();
    public sealed virtual int get_Count();
    public object get_SyncRoot();
    public bool get_IsSynchronized();
    public sealed virtual void Add(object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object value);
    public void CopyTo(Array array, int index);
    public sealed virtual void CopyTo(Object[] array, int arrayIndex);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int IndexOf(object value);
    public sealed virtual void Insert(int index, object value);
    public sealed virtual bool Remove(object value);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override IEnumerator`1<object> System.Collections.Generic.IEnumerable<System.Object>.GetEnumerator();
}
internal abstract class Windows.Foundation.Collections.ObservableVectorWrapper : object {
    [CompilerGeneratedAttribute]
private VectorChangedEventHandler`1<object> VectorChanged;
    public ObservableVectorWrapper(object source);
    [CompilerGeneratedAttribute]
public sealed virtual void add_VectorChanged(VectorChangedEventHandler`1<object> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_VectorChanged(VectorChangedEventHandler`1<object> value);
    private void OnSourceCollectionChanged(object sender, NotifyCollectionChangedEventArgs e);
    public static IObservableVector`1<object> Create(object source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Windows.Foundation.Collections.PropertySet : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, object> _dictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MapChangedEventHandler`2<string, object> MapChanged;
    public UInt32 Size { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ICollection`1<object> Values { get; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_MapChanged(MapChangedEventHandler`2<string, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MapChanged(MapChangedEventHandler`2<string, object> value);
    public UInt32 get_Size();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Windows.Foundation.Collections.StringMap : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, string> _dictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MapChangedEventHandler`2<string, string> MapChanged;
    public UInt32 Size { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [NullableAttribute("2")]
public string Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ICollection`1<string> Values { get; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_MapChanged(MapChangedEventHandler`2<string, string> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MapChanged(MapChangedEventHandler`2<string, string> value);
    public UInt32 get_Size();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(string key, string value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, String& value);
    public sealed virtual string get_Item(string key);
    public sealed virtual void set_Item(string key, string value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<string> get_Values();
    public sealed virtual void Add(KeyValuePair`2<string, string> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, string> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, string> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, string>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class Windows.Foundation.Collections.ValueSet : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, object> _dictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private MapChangedEventHandler`2<string, object> MapChanged;
    public UInt32 Size { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    public ICollection`1<string> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ICollection`1<object> Values { get; }
    [CompilerGeneratedAttribute]
public sealed virtual void add_MapChanged(MapChangedEventHandler`2<string, object> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_MapChanged(MapChangedEventHandler`2<string, object> value);
    public UInt32 get_Size();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(string key, object value);
    public sealed virtual bool ContainsKey(string key);
    public sealed virtual bool Remove(string key);
    public sealed virtual bool TryGetValue(string key, Object& value);
    public sealed virtual object get_Item(string key);
    public sealed virtual void set_Item(string key, object value);
    public sealed virtual ICollection`1<string> get_Keys();
    public sealed virtual ICollection`1<object> get_Values();
    public sealed virtual void Add(KeyValuePair`2<string, object> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<string, object> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<string, object> item);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, object>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Windows.Foundation.Collections.VectorChangedEventArgs : object {
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventArgs <NotifyCollectionChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private CollectionChange <CollectionChange>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Index>k__BackingField;
    public NotifyCollectionChangedEventArgs NotifyCollectionChanged { get; }
    public CollectionChange CollectionChange { get; }
    public UInt32 Index { get; }
    public VectorChangedEventArgs(CollectionChange change, UInt32 index);
    [NullableContextAttribute("1")]
public VectorChangedEventArgs(NotifyCollectionChangedEventArgs ncArgs, CollectionChange change, UInt32 index);
    [CompilerGeneratedAttribute]
public NotifyCollectionChangedEventArgs get_NotifyCollectionChanged();
    [CompilerGeneratedAttribute]
public sealed virtual CollectionChange get_CollectionChange();
    [CompilerGeneratedAttribute]
public sealed virtual UInt32 get_Index();
}
internal class Windows.Foundation.Collections.VectorChangedEventHandler : MulticastDelegate {
    public VectorChangedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, IVectorChangedEventArgs event);
    public virtual IAsyncResult BeginInvoke(object sender, IVectorChangedEventArgs event, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Windows.Foundation.Collections.VectorChangedEventHandler`1 : MulticastDelegate {
    public VectorChangedEventHandler`1(object object, IntPtr method);
    public virtual void Invoke(IObservableVector`1<T> sender, IVectorChangedEventArgs event);
    public virtual IAsyncResult BeginInvoke(IObservableVector`1<T> sender, IVectorChangedEventArgs event, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Windows.Foundation.Deferral : object {
    private DeferralCompletedHandler _handler;
    public Deferral(DeferralCompletedHandler handler);
    public void Complete();
    public sealed virtual void Dispose();
    [EditorBrowsableAttribute("1")]
public void Close();
}
public class Windows.Foundation.DeferralCompletedHandler : MulticastDelegate {
    public DeferralCompletedHandler(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Windows.Foundation.FoundationContract : ValueType {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Windows.Foundation.Gen2GcCallback : object {
    [NullableAttribute("2")]
private Func`1<bool> _callback0;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<object, bool> _callback1;
    private GCHandle _weakTargetObj;
    private Gen2GcCallback(Func`1<bool> callback);
    private Gen2GcCallback(Func`2<object, bool> callback, object targetObj);
    public static void Register(Func`1<bool> callback);
    public static void Register(Func`2<object, bool> callback, object targetObj);
    protected virtual override void Finalize();
}
public interface Windows.Foundation.IAsyncAction {
    public AsyncActionCompletedHandler Completed { get; public set; }
    public abstract virtual AsyncActionCompletedHandler get_Completed();
    public abstract virtual void set_Completed(AsyncActionCompletedHandler value);
    public abstract virtual void GetResults();
}
internal interface Windows.Foundation.IAsyncActionInternal {
    [NullableAttribute("1")]
public Task Task { get; }
    [NullableContextAttribute("1")]
public abstract virtual Task get_Task();
}
public interface Windows.Foundation.IAsyncActionWithProgress`1 {
    public AsyncActionWithProgressCompletedHandler`1<TProgress> Completed { get; public set; }
    public AsyncActionProgressHandler`1<TProgress> Progress { get; public set; }
    public abstract virtual AsyncActionWithProgressCompletedHandler`1<TProgress> get_Completed();
    public abstract virtual void set_Completed(AsyncActionWithProgressCompletedHandler`1<TProgress> value);
    public abstract virtual AsyncActionProgressHandler`1<TProgress> get_Progress();
    public abstract virtual void set_Progress(AsyncActionProgressHandler`1<TProgress> value);
    public abstract virtual void GetResults();
}
[NullableContextAttribute("1")]
internal interface Windows.Foundation.IAsyncActionWithProgressInternal`1 {
    public Task Task { get; }
    public abstract virtual Task get_Task();
}
public interface Windows.Foundation.IAsyncInfo {
    public Exception ErrorCode { get; }
    public UInt32 Id { get; }
    public AsyncStatus Status { get; }
    public abstract virtual Exception get_ErrorCode();
    public abstract virtual UInt32 get_Id();
    public abstract virtual AsyncStatus get_Status();
    public abstract virtual void Cancel();
    public abstract virtual void Close();
}
public interface Windows.Foundation.IAsyncOperation`1 {
    public AsyncOperationCompletedHandler`1<TResult> Completed { get; public set; }
    public abstract virtual AsyncOperationCompletedHandler`1<TResult> get_Completed();
    public abstract virtual void set_Completed(AsyncOperationCompletedHandler`1<TResult> value);
    public abstract virtual TResult GetResults();
}
[NullableContextAttribute("1")]
internal interface Windows.Foundation.IAsyncOperationInternal`1 {
    public Task`1<TResult> Task { get; }
    public abstract virtual Task`1<TResult> get_Task();
}
public interface Windows.Foundation.IAsyncOperationWithProgress`2 {
    public AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress> Completed { get; public set; }
    public AsyncOperationProgressHandler`2<TResult, TProgress> Progress { get; public set; }
    public abstract virtual AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress> get_Completed();
    public abstract virtual void set_Completed(AsyncOperationWithProgressCompletedHandler`2<TResult, TProgress> value);
    public abstract virtual AsyncOperationProgressHandler`2<TResult, TProgress> get_Progress();
    public abstract virtual void set_Progress(AsyncOperationProgressHandler`2<TResult, TProgress> value);
    public abstract virtual TResult GetResults();
}
[NullableContextAttribute("1")]
internal interface Windows.Foundation.IAsyncOperationWithProgressInternal`2 {
    public Task`1<TResult> Task { get; }
    public abstract virtual Task`1<TResult> get_Task();
}
public interface Windows.Foundation.IPropertyValue {
    public bool IsNumericScalar { get; }
    public PropertyType Type { get; }
    public abstract virtual bool get_IsNumericScalar();
    public abstract virtual PropertyType get_Type();
    public abstract virtual bool GetBoolean();
    public abstract virtual void GetBooleanArray(Boolean[]& value);
    public abstract virtual char GetChar16();
    public abstract virtual void GetChar16Array(Char[]& value);
    public abstract virtual DateTimeOffset GetDateTime();
    public abstract virtual void GetDateTimeArray(DateTimeOffset[]& value);
    public abstract virtual double GetDouble();
    public abstract virtual void GetDoubleArray(Double[]& value);
    public abstract virtual Guid GetGuid();
    public abstract virtual void GetGuidArray(Guid[]& value);
    public abstract virtual void GetInspectableArray(Object[]& value);
    public abstract virtual short GetInt16();
    public abstract virtual void GetInt16Array(Int16[]& value);
    public abstract virtual int GetInt32();
    public abstract virtual void GetInt32Array(Int32[]& value);
    public abstract virtual long GetInt64();
    public abstract virtual void GetInt64Array(Int64[]& value);
    public abstract virtual Point GetPoint();
    public abstract virtual void GetPointArray(Point[]& value);
    public abstract virtual Rect GetRect();
    public abstract virtual void GetRectArray(Rect[]& value);
    public abstract virtual float GetSingle();
    public abstract virtual void GetSingleArray(Single[]& value);
    public abstract virtual Size GetSize();
    public abstract virtual void GetSizeArray(Size[]& value);
    public abstract virtual string GetString();
    public abstract virtual void GetStringArray(String[]& value);
    public abstract virtual TimeSpan GetTimeSpan();
    public abstract virtual void GetTimeSpanArray(TimeSpan[]& value);
    public abstract virtual ushort GetUInt16();
    public abstract virtual void GetUInt16Array(UInt16[]& value);
    public abstract virtual UInt32 GetUInt32();
    public abstract virtual void GetUInt32Array(UInt32[]& value);
    public abstract virtual ulong GetUInt64();
    public abstract virtual void GetUInt64Array(UInt64[]& value);
    public abstract virtual byte GetUInt8();
    public abstract virtual void GetUInt8Array(Byte[]& value);
}
public interface Windows.Foundation.IReferenceArray`1 {
    public T[] Value { get; }
    public abstract virtual T[] get_Value();
}
public interface Windows.Foundation.IStringable {
    public abstract virtual string ToString();
}
[AttributeUsageAttribute("4")]
public class Windows.Foundation.Metadata.ActivatableAttribute : Attribute {
    public ActivatableAttribute(UInt32 version);
    public ActivatableAttribute(UInt32 version, string type);
    public ActivatableAttribute(UInt32 version, Platform platform);
    public ActivatableAttribute(Type type, UInt32 version);
    public ActivatableAttribute(Type type, UInt32 version, string contractName);
    public ActivatableAttribute(Type type, UInt32 version, Platform platform);
}
[AttributeUsageAttribute("4")]
public class Windows.Foundation.Metadata.AllowForWebAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class Windows.Foundation.Metadata.AllowMultipleAttribute : Attribute {
}
[AttributeUsageAttribute("16")]
public class Windows.Foundation.Metadata.ApiContractAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Windows.Foundation.Metadata.ApiInformation : object {
    private static HashSet`1<string> _notImplementedOnce;
    private static object _gate;
    private static Dictionary`2<string, bool> _isTypePresent;
    private static Dictionary`2<string, Type> _typeCache;
    private static List`1<Assembly> _assemblies;
    [CompilerGeneratedAttribute]
private static bool <IsFailWhenNotImplemented>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <AlwaysLogNotImplementedMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private static LogLevel <NotImplementedLogLevel>k__BackingField;
    public static bool IsFailWhenNotImplemented { get; public set; }
    public static bool AlwaysLogNotImplementedMessages { get; public set; }
    public static LogLevel NotImplementedLogLevel { get; public set; }
    private static ApiInformation();
    internal static void RegisterAssembly(Assembly assembly);
    [NullableContextAttribute("2")]
private static bool IsImplementedByUno(MemberInfo member);
    public static bool IsTypePresent(string typeName);
    internal static bool IsMethodPresent(Type type, string methodName);
    public static bool IsMethodPresent(string typeName, string methodName);
    public static bool IsMethodPresent(string typeName, string methodName, UInt32 inputParameterCount);
    internal static bool IsEventPresent(Type type, string methodName);
    public static bool IsEventPresent(string typeName, string eventName);
    internal static bool IsPropertyPresent(Type type, string methodName);
    public static bool IsPropertyPresent(string typeName, string propertyName);
    public static bool IsReadOnlyPropertyPresent(string typeName, string propertyName);
    public static bool IsWriteablePropertyPresent(string typeName, string propertyName);
    public static bool IsEnumNamedValuePresent(string enumTypeName, string valueName);
    [CompilerGeneratedAttribute]
public static bool get_IsFailWhenNotImplemented();
    [CompilerGeneratedAttribute]
public static void set_IsFailWhenNotImplemented(bool value);
    [CompilerGeneratedAttribute]
public static bool get_AlwaysLogNotImplementedMessages();
    [CompilerGeneratedAttribute]
public static void set_AlwaysLogNotImplementedMessages(bool value);
    [CompilerGeneratedAttribute]
public static LogLevel get_NotImplementedLogLevel();
    [CompilerGeneratedAttribute]
public static void set_NotImplementedLogLevel(LogLevel value);
    private static Type GetValidType(string typeName);
    internal static void TryRaiseNotImplemented(string type, string memberName, LogLevel errorLogLevelOverride);
    [NullableContextAttribute("0")]
public static bool IsApiContractPresent(string contractName, ushort majorVersion);
    [NullableContextAttribute("0")]
public static bool IsApiContractPresent(string contractName, ushort majorVersion, ushort minorVersion);
}
[AttributeUsageAttribute("4")]
public class Windows.Foundation.Metadata.AttributeNameAttribute : Attribute {
    public AttributeNameAttribute(string A_0);
}
[AttributeUsageAttribute("4")]
public class Windows.Foundation.Metadata.ComposableAttribute : Attribute {
    public ComposableAttribute(Type type, CompositionType compositionType, UInt32 version);
    public ComposableAttribute(Type type, CompositionType compositionType, UInt32 version, Platform platform);
    public ComposableAttribute(Type type, CompositionType compositionType, UInt32 version, string contract);
}
public enum Windows.Foundation.Metadata.CompositionType : Enum {
    public int value__;
    public static CompositionType Protected;
    public static CompositionType Public;
}
[AttributeUsageAttribute("6108")]
public class Windows.Foundation.Metadata.ContractVersionAttribute : Attribute {
    public ContractVersionAttribute(UInt32 version);
    public ContractVersionAttribute(Type contract, UInt32 version);
    public ContractVersionAttribute(string contract, UInt32 version);
}
[AttributeUsageAttribute("1024")]
public class Windows.Foundation.Metadata.DefaultAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class Windows.Foundation.Metadata.DefaultOverloadAttribute : Attribute {
}
[AttributeUsageAttribute("6140")]
public class Windows.Foundation.Metadata.DeprecatedAttribute : Attribute {
    public DeprecatedAttribute(string message, DeprecationType type, UInt32 version);
    public DeprecatedAttribute(string message, DeprecationType type, UInt32 version, Platform platform);
    public DeprecatedAttribute(string message, DeprecationType type, UInt32 version, string contract);
}
public enum Windows.Foundation.Metadata.DeprecationType : Enum {
    public int value__;
    public static DeprecationType Deprecate;
    public static DeprecationType Remove;
}
[AttributeUsageAttribute("4")]
public class Windows.Foundation.Metadata.DualApiPartitionAttribute : Attribute {
    public UInt32 version;
}
[AttributeUsageAttribute("1024")]
public class Windows.Foundation.Metadata.ExclusiveToAttribute : Attribute {
    public ExclusiveToAttribute(Type typeName);
}
[AttributeUsageAttribute("5148")]
public class Windows.Foundation.Metadata.ExperimentalAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class Windows.Foundation.Metadata.FastAbiAttribute : Attribute {
    public FastAbiAttribute(UInt32 version);
    public FastAbiAttribute(UInt32 version, Platform platform);
    public FastAbiAttribute(UInt32 version, string contractName);
}
[AttributeUsageAttribute("5468")]
public class Windows.Foundation.Metadata.FeatureAttribute : Attribute {
    public FeatureAttribute(FeatureStage featureStage, bool validInAllBranches);
}
public enum Windows.Foundation.Metadata.FeatureStage : Enum {
    public int value__;
    public static FeatureStage AlwaysDisabled;
    public static FeatureStage DisabledByDefault;
    public static FeatureStage EnabledByDefault;
    public static FeatureStage AlwaysEnabled;
}
public enum Windows.Foundation.Metadata.GCPressureAmount : Enum {
    public int value__;
    public static GCPressureAmount Low;
    public static GCPressureAmount Medium;
    public static GCPressureAmount High;
}
[AttributeUsageAttribute("4")]
public class Windows.Foundation.Metadata.GCPressureAttribute : Attribute {
    public GCPressureAmount amount;
}
[AttributeUsageAttribute("5120")]
public class Windows.Foundation.Metadata.GuidAttribute : Attribute {
    public GuidAttribute(UInt32 a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
}
[AttributeUsageAttribute("32767")]
[AttributeNameAttribute("hasvariant")]
public class Windows.Foundation.Metadata.HasVariantAttribute : Attribute {
}
[AttributeUsageAttribute("5150")]
public class Windows.Foundation.Metadata.InternalAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class Windows.Foundation.Metadata.LengthIsAttribute : Attribute {
    public LengthIsAttribute(int indexLengthParameter);
}
[AttributeUsageAttribute("4")]
public class Windows.Foundation.Metadata.MarshalingBehaviorAttribute : Attribute {
    public MarshalingBehaviorAttribute(MarshalingType behavior);
}
public enum Windows.Foundation.Metadata.MarshalingType : Enum {
    public int value__;
    public static MarshalingType InvalidMarshaling;
    public static MarshalingType None;
    public static MarshalingType Agile;
    public static MarshalingType Standard;
}
[AttributeUsageAttribute("5124")]
[AttributeNameAttribute("metadata_marshal")]
public class Windows.Foundation.Metadata.MetadataMarshalAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class Windows.Foundation.Metadata.MuseAttribute : Attribute {
    public UInt32 Version;
}
[AttributeNameAttribute("noexcept")]
[AttributeUsageAttribute("192")]
public class Windows.Foundation.Metadata.NoExceptionAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class Windows.Foundation.Metadata.OverloadAttribute : Attribute {
    public OverloadAttribute(string method);
}
[AttributeUsageAttribute("1028")]
public class Windows.Foundation.Metadata.OverridableAttribute : Attribute {
}
public enum Windows.Foundation.Metadata.Platform : Enum {
    public int value__;
    public static Platform Windows;
    public static Platform WindowsPhone;
}
public class Windows.Foundation.Metadata.PlatformAttribute : Attribute {
    public PlatformAttribute(Platform platform);
}
[AttributeUsageAttribute("6108")]
public class Windows.Foundation.Metadata.PreviousContractVersionAttribute : Attribute {
    public PreviousContractVersionAttribute(string contract, UInt32 versionLow, UInt32 versionHigh, string newContract);
    public PreviousContractVersionAttribute(string contract, UInt32 versionLow, UInt32 versionHigh);
}
[AttributeUsageAttribute("4")]
public class Windows.Foundation.Metadata.ProtectedAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class Windows.Foundation.Metadata.RangeAttribute : Attribute {
    public RangeAttribute(int minValue, int maxValue);
}
[AttributeUsageAttribute("68")]
public class Windows.Foundation.Metadata.RemoteAsyncAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class Windows.Foundation.Metadata.StaticAttribute : Attribute {
    public StaticAttribute(Type type, UInt32 version);
    public StaticAttribute(Type type, UInt32 version, Platform platform);
    public StaticAttribute(Type type, UInt32 version, string contractName);
}
[AttributeUsageAttribute("4")]
public class Windows.Foundation.Metadata.ThreadingAttribute : Attribute {
    public ThreadingAttribute(ThreadingModel model);
}
public enum Windows.Foundation.Metadata.ThreadingModel : Enum {
    public int value__;
    public static ThreadingModel InvalidThreading;
    public static ThreadingModel STA;
    public static ThreadingModel MTA;
    public static ThreadingModel Both;
}
[AttributeUsageAttribute("10368")]
public class Windows.Foundation.Metadata.VariantAttribute : Attribute {
}
[AttributeUsageAttribute("6108")]
public class Windows.Foundation.Metadata.VersionAttribute : Attribute {
    public VersionAttribute(UInt32 version);
    public VersionAttribute(UInt32 version, Platform platform);
}
[AttributeUsageAttribute("5148")]
public class Windows.Foundation.Metadata.WebHostHiddenAttribute : Attribute {
}
[DebuggerDisplayAttribute("{DebugDisplay,nq}")]
public class Windows.Foundation.Point : ValueType {
    private float _x;
    private float _y;
    internal static Point Zero { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    private string DebugDisplay { get; }
    public Point(float x, float y);
    public Point(double x, double y);
    internal static Point From(Action`1<Int32[]> getter);
    internal static Point get_Zero();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    internal Point WithX(double x);
    internal Point WithY(double y);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public bool Equals(Point value);
    private static bool Equals(Point left, Point right);
    public static bool op_Equality(Point left, Point right);
    public static bool op_Inequality(Point left, Point right);
    public static Point op_Addition(Point p1, Point p2);
    public static Point op_Subtraction(Point p1, Point p2);
    public static Point op_UnaryNegation(Point a);
    public virtual string ToString();
    internal string ToDebugString();
    private string get_DebugDisplay();
}
public enum Windows.Foundation.PropertyType : Enum {
    public int value__;
    public static PropertyType Empty;
    public static PropertyType UInt8;
    public static PropertyType Int16;
    public static PropertyType UInt16;
    public static PropertyType Int32;
    public static PropertyType UInt32;
    public static PropertyType Int64;
    public static PropertyType UInt64;
    public static PropertyType Single;
    public static PropertyType Double;
    public static PropertyType Char16;
    public static PropertyType Boolean;
    public static PropertyType String;
    public static PropertyType Inspectable;
    public static PropertyType DateTime;
    public static PropertyType TimeSpan;
    public static PropertyType Guid;
    public static PropertyType Point;
    public static PropertyType Size;
    public static PropertyType Rect;
    public static PropertyType OtherType;
    public static PropertyType UInt8Array;
    public static PropertyType Int16Array;
    public static PropertyType UInt16Array;
    public static PropertyType Int32Array;
    public static PropertyType UInt32Array;
    public static PropertyType Int64Array;
    public static PropertyType UInt64Array;
    public static PropertyType SingleArray;
    public static PropertyType DoubleArray;
    public static PropertyType Char16Array;
    public static PropertyType BooleanArray;
    public static PropertyType StringArray;
    public static PropertyType InspectableArray;
    public static PropertyType DateTimeArray;
    public static PropertyType TimeSpanArray;
    public static PropertyType GuidArray;
    public static PropertyType PointArray;
    public static PropertyType SizeArray;
    public static PropertyType RectArray;
    public static PropertyType OtherTypeArray;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Windows.Foundation.PropertyValue : object {
    [NullableContextAttribute("2")]
public static object CreateEmpty();
    public static object CreateUInt8(byte value);
    public static object CreateInt16(short value);
    public static object CreateUInt16(ushort value);
    public static object CreateInt32(int value);
    public static object CreateUInt32(UInt32 value);
    public static object CreateInt64(long value);
    public static object CreateUInt64(ulong value);
    public static object CreateSingle(float value);
    public static object CreateDouble(double value);
    public static object CreateChar16(char value);
    public static object CreateBoolean(bool value);
    public static object CreateString(string value);
    public static object CreateInspectable(object value);
    public static object CreateGuid(Guid value);
    public static object CreateDateTime(DateTimeOffset value);
    internal static object CreateDateTime(WindowsFoundationDateTime value);
    public static object CreateTimeSpan(TimeSpan value);
    public static object CreatePoint(Point value);
    public static object CreateSize(Size value);
    public static object CreateRect(Rect value);
    public static object CreateUInt8Array(Byte[] value);
    public static object CreateInt16Array(Int16[] value);
    public static object CreateUInt16Array(UInt16[] value);
    public static object CreateInt32Array(Int32[] value);
    public static object CreateUInt32Array(UInt32[] value);
    public static object CreateInt64Array(Int64[] value);
    public static object CreateUInt64Array(UInt64[] value);
    public static object CreateSingleArray(Single[] value);
    public static object CreateDoubleArray(Double[] value);
    public static object CreateChar16Array(Char[] value);
    public static object CreateBooleanArray(Boolean[] value);
    public static object CreateStringArray(String[] value);
    public static object CreateInspectableArray(Object[] value);
    public static object CreateGuidArray(Guid[] value);
    public static object CreateDateTimeArray(DateTimeOffset[] value);
    public static object CreateTimeSpanArray(TimeSpan[] value);
    public static object CreatePointArray(Point[] value);
    public static object CreateSizeArray(Size[] value);
    public static object CreateRectArray(Rect[] value);
    [NullableContextAttribute("0")]
internal static void CreateFromDateTime(DateTimeOffset date, Object& value);
    [NullableContextAttribute("0")]
internal static void CreateFromDateTime(WindowsFoundationDateTime date, Object& value);
    [NullableContextAttribute("0")]
internal static bool AreEqualImpl(object oldValue, object newValue);
    [CompilerGeneratedAttribute]
internal static bool <AreEqualImpl>g__CompareOtherType|42_0(<>c__DisplayClass42_0& , <>c__DisplayClass42_1& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("[Rect {Size}@{Location}]")]
public class Windows.Foundation.Rect : ValueType {
    private float _x;
    private float _y;
    private float _width;
    private float _height;
    private static string _negativeErrorMessage;
    private static float Epsilon;
    private static Char[] _commaSpaceArray;
    [CompilerGeneratedAttribute]
private static Rect <Empty>k__BackingField;
    [CompilerGeneratedAttribute]
private static Rect <Infinite>k__BackingField;
    public static Rect Empty { get; }
    internal static Rect Infinite { get; }
    public double X { get; public set; }
    public double Y { get; public set; }
    public double Width { get; public set; }
    public double Height { get; public set; }
    public double Left { get; }
    public double Top { get; }
    public double Right { get; }
    public double Bottom { get; }
    public bool IsEmpty { get; }
    internal bool IsInfinite { get; }
    internal bool IsFinite { get; }
    internal bool IsValid { get; }
    internal bool IsUniform { get; }
    internal Size Size { get; internal set; }
    internal Point Location { get; internal set; }
    public Rect(Point point, Size size);
    public Rect(double x, double y, double width, double height);
    public Rect(float x, float y, float width, float height);
    public Rect(Point point1, Point point2);
    private static Rect();
    [NullableContextAttribute("0")]
public static Rect op_Implicit(Rect rect);
    [NullableContextAttribute("0")]
public static Rect op_Implicit(Rect rect);
    [NullableContextAttribute("0")]
public static Rect op_Implicit(RectF rect);
    [NullableContextAttribute("0")]
public static RectF op_Implicit(Rect rect);
    [CompilerGeneratedAttribute]
public static Rect get_Empty();
    [CompilerGeneratedAttribute]
internal static Rect get_Infinite();
    public double get_X();
    public void set_X(double value);
    public double get_Y();
    public void set_Y(double value);
    public double get_Width();
    public void set_Width(double value);
    public double get_Height();
    public void set_Height(double value);
    public double get_Left();
    public double get_Top();
    public double get_Right();
    public double get_Bottom();
    public bool get_IsEmpty();
    internal bool get_IsInfinite();
    internal bool get_IsFinite();
    internal bool get_IsValid();
    internal bool get_IsUniform();
    public static Rect op_Implicit(string text);
    public static string op_Implicit(Rect rect);
    public virtual string ToString();
    internal string ToDebugString();
    internal Size get_Size();
    internal void set_Size(Size value);
    internal Point get_Location();
    internal void set_Location(Point value);
    internal Point GetLocation();
    internal void Inflate(double width, double height);
    public bool Contains(Point point);
    public void Intersect(Rect rect);
    public void Union(Rect rect);
    public virtual int GetHashCode();
    public bool Equals(Rect value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(Rect left, Rect right);
    public static bool op_Inequality(Rect left, Rect right);
}
[ExtensionAttribute]
internal static class Windows.Foundation.RectExtensions : object {
    [ExtensionAttribute]
internal static double GetMidX(Rect rect);
    [ExtensionAttribute]
internal static double GetMidY(Rect rect);
}
[DebuggerDisplayAttribute("{DebugDisplay,nq}")]
[TypeConverterAttribute("Windows.Foundation.SizeConverter")]
public class Windows.Foundation.Size : ValueType {
    private float _width;
    private float _height;
    public static Size Empty { get; }
    public bool IsEmpty { get; }
    public double Height { get; public set; }
    public double Width { get; public set; }
    private string DebugDisplay { get; }
    public Size(float width, float height);
    public Size(double width, double height);
    public static Size get_Empty();
    public bool get_IsEmpty();
    public double get_Height();
    public void set_Height(double value);
    public double get_Width();
    public void set_Width(double value);
    public virtual bool Equals(object o);
    public bool Equals(Size value);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal string ToString(string format);
    internal string ToDebugString();
    public static bool op_Equality(Size size1, Size size2);
    public static bool op_Inequality(Size size1, Size size2);
    private string get_DebugDisplay();
}
[EditorBrowsableAttribute("1")]
internal class Windows.Foundation.SizeConverter : TypeConverter {
    public virtual bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType);
    public virtual object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value);
}
[ExtensionAttribute]
internal static class Windows.Foundation.SizeExtensions : object {
    [ExtensionAttribute]
internal static double AspectRatio(Size size);
}
public class Windows.Foundation.TypedEventHandler`2 : MulticastDelegate {
    public TypedEventHandler`2(object object, IntPtr method);
    public virtual void Invoke(TSender sender, TResult args);
    public virtual IAsyncResult BeginInvoke(TSender sender, TResult args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Windows.Foundation.WindowsFoundationDateTime : ValueType {
    public long UniversalTime;
    private static long ManagedUtcTicksAtNativeZero;
    internal int Year { get; }
    internal int Month { get; }
    internal int Day { get; }
    internal int Hour { get; }
    internal int Minute { get; }
    internal int Second { get; }
    internal int Millisecond { get; }
    public static DateTimeOffset op_Implicit(WindowsFoundationDateTime value);
    public static WindowsFoundationDateTime op_Implicit(DateTimeOffset value);
    public static WindowsFoundationDateTime op_Implicit(DateTime value);
    public static bool op_Equality(WindowsFoundationDateTime left, WindowsFoundationDateTime right);
    public static bool op_Inequality(WindowsFoundationDateTime left, WindowsFoundationDateTime right);
    internal string ToString(string format, IFormatProvider formatProvider);
    internal int CompareTo(DateTimeOffset other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal int get_Year();
    internal int get_Month();
    internal int get_Day();
    internal int get_Hour();
    internal int get_Minute();
    internal int get_Second();
    internal int get_Millisecond();
}
