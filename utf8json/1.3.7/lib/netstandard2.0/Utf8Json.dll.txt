public class Utf8Json.FormatterNotRegisteredException : Exception {
    public FormatterNotRegisteredException(string message);
}
public class Utf8Json.Formatters.AnonymousFormatter`1 : object {
    private JsonSerializeAction`1<T> serialize;
    private JsonDeserializeFunc`1<T> deserialize;
    public AnonymousFormatter`1(JsonSerializeAction`1<T> serialize, JsonDeserializeFunc`1<T> deserialize);
    public sealed virtual void Serialize(JsonWriter& writer, T value, IJsonFormatterResolver formatterResolver);
    public sealed virtual T Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ArrayFormatter`1 : object {
    private static ArrayPool`1<T> arrayPool;
    private static ArrayFormatter`1();
    public sealed virtual void Serialize(JsonWriter& writer, T[] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual T[] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ArraySegmentFormatter`1 : object {
    private static ArrayPool`1<T> arrayPool;
    private static ArraySegmentFormatter`1();
    public sealed virtual void Serialize(JsonWriter& writer, ArraySegment`1<T> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ArraySegment`1<T> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.BigIntegerFormatter : object {
    public static IJsonFormatter`1<BigInteger> Default;
    private static BigIntegerFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, BigInteger value, IJsonFormatterResolver formatterResolver);
    public sealed virtual BigInteger Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.BitArrayFormatter : object {
    public static IJsonFormatter`1<BitArray> Default;
    private static BitArrayFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, BitArray value, IJsonFormatterResolver formatterResolver);
    public sealed virtual BitArray Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.BooleanArrayFormatter : object {
    public static BooleanArrayFormatter Default;
    private static BooleanArrayFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Boolean[] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Boolean[] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.BooleanFormatter : object {
    public static BooleanFormatter Default;
    private static BooleanFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, bool value, IJsonFormatterResolver formatterResolver);
    public sealed virtual bool Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, bool value, IJsonFormatterResolver formatterResolver);
    public sealed virtual bool DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ByteArrayFormatter : object {
    public static IJsonFormatter`1<Byte[]> Default;
    private static ByteArrayFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Byte[] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Byte[] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ByteArraySegmentFormatter : object {
    public static IJsonFormatter`1<ArraySegment`1<byte>> Default;
    private static ByteArraySegmentFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, ArraySegment`1<byte> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ArraySegment`1<byte> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ByteFormatter : object {
    public static ByteFormatter Default;
    private static ByteFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, byte value, IJsonFormatterResolver formatterResolver);
    public sealed virtual byte Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, byte value, IJsonFormatterResolver formatterResolver);
    public sealed virtual byte DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.CharArrayFormatter : object {
    public static CharArrayFormatter Default;
    private static CharArrayFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Char[] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Char[] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.CharFormatter : object {
    public static CharFormatter Default;
    private static CharFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, char value, IJsonFormatterResolver formatterResolver);
    public sealed virtual char Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public abstract class Utf8Json.Formatters.CollectionFormatterBase`2 : CollectionFormatterBase`3<TElement, TCollection, TCollection> {
    protected sealed virtual TCollection Complete(TCollection& intermediateCollection);
}
public abstract class Utf8Json.Formatters.CollectionFormatterBase`3 : CollectionFormatterBase`4<TElement, TIntermediate, IEnumerator`1<TElement>, TCollection> {
    protected virtual IEnumerator`1<TElement> GetSourceEnumerator(TCollection source);
}
public abstract class Utf8Json.Formatters.CollectionFormatterBase`4 : object {
    public sealed virtual void Serialize(JsonWriter& writer, TCollection value, IJsonFormatterResolver formatterResolver);
    public sealed virtual TCollection Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    protected abstract virtual TEnumerator GetSourceEnumerator(TCollection source);
    protected abstract virtual TIntermediate Create();
    protected abstract virtual void Add(TIntermediate& collection, int index, TElement value);
    protected abstract virtual TCollection Complete(TIntermediate& intermediateCollection);
}
public class Utf8Json.Formatters.ComplexFormatter : object {
    public static IJsonFormatter`1<Complex> Default;
    private static ComplexFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Complex value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Complex Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ConcurrentBagFormatter`1 : CollectionFormatterBase`2<T, ConcurrentBag`1<T>> {
    protected virtual void Add(ConcurrentBag`1& collection, int index, T value);
    protected virtual ConcurrentBag`1<T> Create();
}
public class Utf8Json.Formatters.ConcurrentDictionaryFormatter`2 : DictionaryFormatterBase`3<TKey, TValue, ConcurrentDictionary`2<TKey, TValue>> {
    protected virtual void Add(ConcurrentDictionary`2& collection, int index, TKey key, TValue value);
    protected virtual ConcurrentDictionary`2<TKey, TValue> Create();
}
public class Utf8Json.Formatters.ConcurrentQueueFormatter`1 : CollectionFormatterBase`2<T, ConcurrentQueue`1<T>> {
    protected virtual void Add(ConcurrentQueue`1& collection, int index, T value);
    protected virtual ConcurrentQueue`1<T> Create();
}
public class Utf8Json.Formatters.ConcurrentStackFormatter`1 : CollectionFormatterBase`3<T, ArrayBuffer`1<T>, ConcurrentStack`1<T>> {
    protected virtual void Add(ArrayBuffer`1& collection, int index, T value);
    protected virtual ArrayBuffer`1<T> Create();
    protected virtual ConcurrentStack`1<T> Complete(ArrayBuffer`1& intermediateCollection);
}
public class Utf8Json.Formatters.DateTimeFormatter : object {
    private string formatString;
    public DateTimeFormatter(string formatString);
    public sealed virtual void Serialize(JsonWriter& writer, DateTime value, IJsonFormatterResolver formatterResolver);
    public sealed virtual DateTime Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.DateTimeOffsetFormatter : object {
    private string formatString;
    public DateTimeOffsetFormatter(string formatString);
    public sealed virtual void Serialize(JsonWriter& writer, DateTimeOffset value, IJsonFormatterResolver formatterResolver);
    public sealed virtual DateTimeOffset Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.DecimalFormatter : object {
    public static IJsonFormatter`1<decimal> Default;
    private bool serializeAsString;
    public DecimalFormatter(bool serializeAsString);
    private static DecimalFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, decimal value, IJsonFormatterResolver formatterResolver);
    public sealed virtual decimal Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.DictionaryFormatter`2 : DictionaryFormatterBase`5<TKey, TValue, Dictionary`2<TKey, TValue>, Enumerator<TKey, TValue>, Dictionary`2<TKey, TValue>> {
    protected virtual void Add(Dictionary`2& collection, int index, TKey key, TValue value);
    protected virtual Dictionary`2<TKey, TValue> Complete(Dictionary`2& intermediateCollection);
    protected virtual Dictionary`2<TKey, TValue> Create();
    protected virtual Enumerator<TKey, TValue> GetSourceEnumerator(Dictionary`2<TKey, TValue> source);
}
public abstract class Utf8Json.Formatters.DictionaryFormatterBase`3 : DictionaryFormatterBase`4<TKey, TValue, TDictionary, TDictionary> {
    protected virtual TDictionary Complete(TDictionary& intermediateCollection);
}
public abstract class Utf8Json.Formatters.DictionaryFormatterBase`4 : DictionaryFormatterBase`5<TKey, TValue, TIntermediate, IEnumerator`1<KeyValuePair`2<TKey, TValue>>, TDictionary> {
    protected virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetSourceEnumerator(TDictionary source);
}
public abstract class Utf8Json.Formatters.DictionaryFormatterBase`5 : object {
    public sealed virtual void Serialize(JsonWriter& writer, TDictionary value, IJsonFormatterResolver formatterResolver);
    public sealed virtual TDictionary Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    protected abstract virtual TEnumerator GetSourceEnumerator(TDictionary source);
    protected abstract virtual TIntermediate Create();
    protected abstract virtual void Add(TIntermediate& collection, int index, TKey key, TValue value);
    protected abstract virtual TDictionary Complete(TIntermediate& intermediateCollection);
}
public class Utf8Json.Formatters.DoubleArrayFormatter : object {
    public static DoubleArrayFormatter Default;
    private static DoubleArrayFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Double[] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Double[] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.DoubleFormatter : object {
    public static DoubleFormatter Default;
    private static DoubleFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, double value, IJsonFormatterResolver formatterResolver);
    public sealed virtual double Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, double value, IJsonFormatterResolver formatterResolver);
    public sealed virtual double DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.DynamicObjectTypeFallbackFormatter : object {
    private ThreadsafeTypeKeyHashTable`1<KeyValuePair`2<object, SerializeMethod>> serializers;
    private IJsonFormatterResolver[] innerResolvers;
    public DynamicObjectTypeFallbackFormatter(IJsonFormatterResolver[] innerResolvers);
    public sealed virtual void Serialize(JsonWriter& writer, object value, IJsonFormatterResolver formatterResolver);
    public sealed virtual object Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.EnumFormatter`1 : object {
    private static ByteArrayStringHashTable`1<T> nameValueMapping;
    private static Dictionary`2<T, string> valueNameMapping;
    private static JsonSerializeAction`1<T> defaultSerializeByUnderlyingValue;
    private static JsonDeserializeFunc`1<T> defaultDeserializeByUnderlyingValue;
    private bool serializeByName;
    private JsonSerializeAction`1<T> serializeByUnderlyingValue;
    private JsonDeserializeFunc`1<T> deserializeByUnderlyingValue;
    private static EnumFormatter`1();
    public EnumFormatter`1(bool serializeByName);
    public EnumFormatter`1(JsonSerializeAction`1<T> valueSerializeAction, JsonDeserializeFunc`1<T> valueDeserializeAction);
    public sealed virtual void Serialize(JsonWriter& writer, T value, IJsonFormatterResolver formatterResolver);
    public sealed virtual T Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, T value, IJsonFormatterResolver formatterResolver);
    public sealed virtual T DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public static class Utf8Json.Formatters.EnumFormatterHelper : object {
    public static object GetSerializeDelegate(Type type, Boolean& isBoxed);
    public static object GetDeserializeDelegate(Type type, Boolean& isBoxed);
}
public class Utf8Json.Formatters.ExpandoObjectFormatter : object {
    public static IJsonFormatter`1<ExpandoObject> Default;
    private static ExpandoObjectFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, ExpandoObject value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ExpandoObject Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.FourDimentionalArrayFormatter`1 : object {
    public sealed virtual void Serialize(JsonWriter& writer, T[0...,0...,0...,0...] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual T[0...,0...,0...,0...] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.GenericCollectionFormatter`2 : CollectionFormatterBase`2<TElement, TCollection> {
    protected virtual TCollection Create();
    protected virtual void Add(TCollection& collection, int index, TElement value);
}
public class Utf8Json.Formatters.GenericDictionaryFormatter`3 : DictionaryFormatterBase`3<TKey, TValue, TDictionary> {
    protected virtual void Add(TDictionary& collection, int index, TKey key, TValue value);
    protected virtual TDictionary Create();
}
internal class Utf8Json.Formatters.Grouping`2 : object {
    private TKey key;
    private IEnumerable`1<TElement> elements;
    public TKey Key { get; }
    public Grouping`2(TKey key, IEnumerable`1<TElement> elements);
    public sealed virtual TKey get_Key();
    public sealed virtual IEnumerator`1<TElement> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Utf8Json.Formatters.GuidFormatter : object {
    public static IJsonFormatter`1<Guid> Default;
    private static GuidFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Guid value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Guid Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, Guid value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Guid DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.HashSetFormatter`1 : CollectionFormatterBase`4<T, HashSet`1<T>, Enumerator<T>, HashSet`1<T>> {
    protected virtual void Add(HashSet`1& collection, int index, T value);
    protected virtual HashSet`1<T> Complete(HashSet`1& intermediateCollection);
    protected virtual HashSet`1<T> Create();
    protected virtual Enumerator<T> GetSourceEnumerator(HashSet`1<T> source);
}
public class Utf8Json.Formatters.IgnoreFormatter`1 : object {
    public sealed virtual void Serialize(JsonWriter& writer, T value, IJsonFormatterResolver formatterResolver);
    public sealed virtual T Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.Int16ArrayFormatter : object {
    public static Int16ArrayFormatter Default;
    private static Int16ArrayFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Int16[] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Int16[] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.Int16Formatter : object {
    public static Int16Formatter Default;
    private static Int16Formatter();
    public sealed virtual void Serialize(JsonWriter& writer, short value, IJsonFormatterResolver formatterResolver);
    public sealed virtual short Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, short value, IJsonFormatterResolver formatterResolver);
    public sealed virtual short DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.Int32ArrayFormatter : object {
    public static Int32ArrayFormatter Default;
    private static Int32ArrayFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Int32[] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Int32[] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.Int32Formatter : object {
    public static Int32Formatter Default;
    private static Int32Formatter();
    public sealed virtual void Serialize(JsonWriter& writer, int value, IJsonFormatterResolver formatterResolver);
    public sealed virtual int Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, int value, IJsonFormatterResolver formatterResolver);
    public sealed virtual int DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.Int64ArrayFormatter : object {
    public static Int64ArrayFormatter Default;
    private static Int64ArrayFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Int64[] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Int64[] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.Int64Formatter : object {
    public static Int64Formatter Default;
    private static Int64Formatter();
    public sealed virtual void Serialize(JsonWriter& writer, long value, IJsonFormatterResolver formatterResolver);
    public sealed virtual long Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, long value, IJsonFormatterResolver formatterResolver);
    public sealed virtual long DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.InterfaceCollectionFormatter`1 : CollectionFormatterBase`3<T, List`1<T>, ICollection`1<T>> {
    protected virtual void Add(List`1& collection, int index, T value);
    protected virtual List`1<T> Create();
    protected virtual ICollection`1<T> Complete(List`1& intermediateCollection);
}
public class Utf8Json.Formatters.InterfaceDictionaryFormatter`2 : DictionaryFormatterBase`4<TKey, TValue, Dictionary`2<TKey, TValue>, IDictionary`2<TKey, TValue>> {
    protected virtual void Add(Dictionary`2& collection, int index, TKey key, TValue value);
    protected virtual Dictionary`2<TKey, TValue> Create();
    protected virtual IDictionary`2<TKey, TValue> Complete(Dictionary`2& intermediateCollection);
}
public class Utf8Json.Formatters.InterfaceEnumerableFormatter`1 : CollectionFormatterBase`3<T, ArrayBuffer`1<T>, IEnumerable`1<T>> {
    protected virtual void Add(ArrayBuffer`1& collection, int index, T value);
    protected virtual ArrayBuffer`1<T> Create();
    protected virtual IEnumerable`1<T> Complete(ArrayBuffer`1& intermediateCollection);
}
public class Utf8Json.Formatters.InterfaceGroupingFormatter`2 : object {
    public sealed virtual void Serialize(JsonWriter& writer, IGrouping`2<TKey, TElement> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual IGrouping`2<TKey, TElement> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.InterfaceListFormatter`1 : CollectionFormatterBase`3<T, List`1<T>, IList`1<T>> {
    protected virtual void Add(List`1& collection, int index, T value);
    protected virtual List`1<T> Create();
    protected virtual IList`1<T> Complete(List`1& intermediateCollection);
}
public class Utf8Json.Formatters.InterfaceLookupFormatter`2 : object {
    public sealed virtual void Serialize(JsonWriter& writer, ILookup`2<TKey, TElement> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ILookup`2<TKey, TElement> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.InterfaceReadOnlyCollectionFormatter`1 : CollectionFormatterBase`3<T, ArrayBuffer`1<T>, IReadOnlyCollection`1<T>> {
    protected virtual void Add(ArrayBuffer`1& collection, int index, T value);
    protected virtual ArrayBuffer`1<T> Create();
    protected virtual IReadOnlyCollection`1<T> Complete(ArrayBuffer`1& intermediateCollection);
}
public class Utf8Json.Formatters.InterfaceReadOnlyDictionaryFormatter`2 : DictionaryFormatterBase`4<TKey, TValue, Dictionary`2<TKey, TValue>, IReadOnlyDictionary`2<TKey, TValue>> {
    protected virtual void Add(Dictionary`2& collection, int index, TKey key, TValue value);
    protected virtual IReadOnlyDictionary`2<TKey, TValue> Complete(Dictionary`2& intermediateCollection);
    protected virtual Dictionary`2<TKey, TValue> Create();
}
public class Utf8Json.Formatters.InterfaceReadOnlyListFormatter`1 : CollectionFormatterBase`3<T, ArrayBuffer`1<T>, IReadOnlyList`1<T>> {
    protected virtual void Add(ArrayBuffer`1& collection, int index, T value);
    protected virtual ArrayBuffer`1<T> Create();
    protected virtual IReadOnlyList`1<T> Complete(ArrayBuffer`1& intermediateCollection);
}
public class Utf8Json.Formatters.InterfaceSetFormatter`1 : CollectionFormatterBase`3<T, HashSet`1<T>, ISet`1<T>> {
    protected virtual void Add(HashSet`1& collection, int index, T value);
    protected virtual ISet`1<T> Complete(HashSet`1& intermediateCollection);
    protected virtual HashSet`1<T> Create();
}
internal static class Utf8Json.Formatters.Internal.CollectionFormatterHelper : object {
    internal static Byte[][] groupingName;
    internal static AutomataDictionary groupingAutomata;
    private static CollectionFormatterHelper();
}
internal static class Utf8Json.Formatters.Internal.StandardClassLibraryFormatterHelper : object {
    internal static Byte[][] keyValuePairName;
    internal static AutomataDictionary keyValuePairAutomata;
    private static StandardClassLibraryFormatterHelper();
}
internal static class Utf8Json.Formatters.Internal.TupleFormatterHelper : object {
    internal static Byte[][] nameCache1;
    internal static AutomataDictionary dictionary1;
    internal static Byte[][] nameCache2;
    internal static AutomataDictionary dictionary2;
    internal static Byte[][] nameCache3;
    internal static AutomataDictionary dictionary3;
    internal static Byte[][] nameCache4;
    internal static AutomataDictionary dictionary4;
    internal static Byte[][] nameCache5;
    internal static AutomataDictionary dictionary5;
    internal static Byte[][] nameCache6;
    internal static AutomataDictionary dictionary6;
    internal static Byte[][] nameCache7;
    internal static AutomataDictionary dictionary7;
    internal static Byte[][] nameCache8;
    internal static AutomataDictionary dictionary8;
    private static TupleFormatterHelper();
}
internal static class Utf8Json.Formatters.Internal.ValueTupleFormatterHelper : object {
    internal static Byte[][] nameCache1;
    internal static AutomataDictionary dictionary1;
    internal static Byte[][] nameCache2;
    internal static AutomataDictionary dictionary2;
    internal static Byte[][] nameCache3;
    internal static AutomataDictionary dictionary3;
    internal static Byte[][] nameCache4;
    internal static AutomataDictionary dictionary4;
    internal static Byte[][] nameCache5;
    internal static AutomataDictionary dictionary5;
    internal static Byte[][] nameCache6;
    internal static AutomataDictionary dictionary6;
    internal static Byte[][] nameCache7;
    internal static AutomataDictionary dictionary7;
    internal static Byte[][] nameCache8;
    internal static AutomataDictionary dictionary8;
    private static ValueTupleFormatterHelper();
}
public class Utf8Json.Formatters.ISO8601DateTimeFormatter : object {
    public static IJsonFormatter`1<DateTime> Default;
    private static ISO8601DateTimeFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, DateTime value, IJsonFormatterResolver formatterResolver);
    public sealed virtual DateTime Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ISO8601DateTimeOffsetFormatter : object {
    public static IJsonFormatter`1<DateTimeOffset> Default;
    private static ISO8601DateTimeOffsetFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, DateTimeOffset value, IJsonFormatterResolver formatterResolver);
    public sealed virtual DateTimeOffset Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ISO8601TimeSpanFormatter : object {
    public static IJsonFormatter`1<TimeSpan> Default;
    private static Byte[] minValue;
    private static ISO8601TimeSpanFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, TimeSpan value, IJsonFormatterResolver formatterResolver);
    public sealed virtual TimeSpan Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.KeyValuePairFormatter`2 : object {
    public sealed virtual void Serialize(JsonWriter& writer, KeyValuePair`2<TKey, TValue> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual KeyValuePair`2<TKey, TValue> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.LazyFormatter`1 : object {
    public sealed virtual void Serialize(JsonWriter& writer, Lazy`1<T> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Lazy`1<T> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.LinkedListFormatter`1 : CollectionFormatterBase`4<T, LinkedList`1<T>, Enumerator<T>, LinkedList`1<T>> {
    protected virtual void Add(LinkedList`1& collection, int index, T value);
    protected virtual LinkedList`1<T> Complete(LinkedList`1& intermediateCollection);
    protected virtual LinkedList`1<T> Create();
    protected virtual Enumerator<T> GetSourceEnumerator(LinkedList`1<T> source);
}
public class Utf8Json.Formatters.ListFormatter`1 : object {
    public sealed virtual void Serialize(JsonWriter& writer, List`1<T> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual List`1<T> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
[DefaultMemberAttribute("Item")]
internal class Utf8Json.Formatters.Lookup`2 : object {
    private Dictionary`2<TKey, IGrouping`2<TKey, TElement>> groupings;
    public IEnumerable`1<TElement> Item { get; }
    public int Count { get; }
    public Lookup`2(Dictionary`2<TKey, IGrouping`2<TKey, TElement>> groupings);
    public sealed virtual IEnumerable`1<TElement> get_Item(TKey key);
    public sealed virtual int get_Count();
    public sealed virtual bool Contains(TKey key);
    public sealed virtual IEnumerator`1<IGrouping`2<TKey, TElement>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public class Utf8Json.Formatters.NonGenericDictionaryFormatter`1 : object {
    public sealed virtual void Serialize(JsonWriter& writer, T value, IJsonFormatterResolver formatterResolver);
    public sealed virtual T Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NonGenericInterfaceCollectionFormatter : object {
    public static IJsonFormatter`1<ICollection> Default;
    private static NonGenericInterfaceCollectionFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, ICollection value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ICollection Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NonGenericInterfaceDictionaryFormatter : object {
    public static IJsonFormatter`1<IDictionary> Default;
    private static NonGenericInterfaceDictionaryFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, IDictionary value, IJsonFormatterResolver formatterResolver);
    public sealed virtual IDictionary Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NonGenericInterfaceEnumerableFormatter : object {
    public static IJsonFormatter`1<IEnumerable> Default;
    private static NonGenericInterfaceEnumerableFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, IEnumerable value, IJsonFormatterResolver formatterResolver);
    public sealed virtual IEnumerable Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NonGenericInterfaceListFormatter : object {
    public static IJsonFormatter`1<IList> Default;
    private static NonGenericInterfaceListFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, IList value, IJsonFormatterResolver formatterResolver);
    public sealed virtual IList Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NonGenericListFormatter`1 : object {
    public sealed virtual void Serialize(JsonWriter& writer, T value, IJsonFormatterResolver formatterResolver);
    public sealed virtual T Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableBooleanFormatter : object {
    public static NullableBooleanFormatter Default;
    private static NullableBooleanFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<bool> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<bool> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, Nullable`1<bool> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<bool> DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableByteFormatter : object {
    public static NullableByteFormatter Default;
    private static NullableByteFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<byte> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<byte> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, Nullable`1<byte> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<byte> DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableCharFormatter : object {
    public static NullableCharFormatter Default;
    private static NullableCharFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<char> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<char> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableDateTimeFormatter : object {
    private DateTimeFormatter innerFormatter;
    public NullableDateTimeFormatter(string formatString);
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<DateTime> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<DateTime> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableDateTimeOffsetFormatter : object {
    private DateTimeOffsetFormatter innerFormatter;
    public NullableDateTimeOffsetFormatter(string formatString);
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<DateTimeOffset> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<DateTimeOffset> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableDoubleFormatter : object {
    public static NullableDoubleFormatter Default;
    private static NullableDoubleFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<double> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<double> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, Nullable`1<double> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<double> DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableFormatter`1 : object {
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<T> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<T> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableInt16Formatter : object {
    public static NullableInt16Formatter Default;
    private static NullableInt16Formatter();
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<short> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<short> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, Nullable`1<short> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<short> DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableInt32Formatter : object {
    public static NullableInt32Formatter Default;
    private static NullableInt32Formatter();
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<int> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<int> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, Nullable`1<int> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<int> DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableInt64Formatter : object {
    public static NullableInt64Formatter Default;
    private static NullableInt64Formatter();
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<long> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<long> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, Nullable`1<long> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<long> DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableSByteFormatter : object {
    public static NullableSByteFormatter Default;
    private static NullableSByteFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<sbyte> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<sbyte> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, Nullable`1<sbyte> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<sbyte> DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableSingleFormatter : object {
    public static NullableSingleFormatter Default;
    private static NullableSingleFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<float> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<float> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, Nullable`1<float> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<float> DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableStringArrayFormatter : object {
    public static NullableStringArrayFormatter Default;
    private static NullableStringArrayFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, String[] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual String[] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableStringFormatter : object {
    public static IJsonFormatter`1<string> Default;
    private static NullableStringFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, string value, IJsonFormatterResolver formatterResolver);
    public sealed virtual string Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, string value, IJsonFormatterResolver formatterResolver);
    public sealed virtual string DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableTimeSpanFormatter : object {
    private TimeSpanFormatter innerFormatter;
    public NullableTimeSpanFormatter(string formatString);
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<TimeSpan> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<TimeSpan> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableUInt16Formatter : object {
    public static NullableUInt16Formatter Default;
    private static NullableUInt16Formatter();
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<ushort> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<ushort> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, Nullable`1<ushort> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<ushort> DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableUInt32Formatter : object {
    public static NullableUInt32Formatter Default;
    private static NullableUInt32Formatter();
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<UInt32> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<UInt32> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, Nullable`1<UInt32> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<UInt32> DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.NullableUInt64Formatter : object {
    public static NullableUInt64Formatter Default;
    private static NullableUInt64Formatter();
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<ulong> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<ulong> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, Nullable`1<ulong> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<ulong> DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ObservableCollectionFormatter`1 : CollectionFormatterBase`2<T, ObservableCollection`1<T>> {
    protected virtual void Add(ObservableCollection`1& collection, int index, T value);
    protected virtual ObservableCollection`1<T> Create();
}
public class Utf8Json.Formatters.PrimitiveObjectFormatter : object {
    public static IJsonFormatter`1<object> Default;
    private static Dictionary`2<Type, int> typeToJumpCode;
    private static PrimitiveObjectFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, object value, IJsonFormatterResolver formatterResolver);
    public sealed virtual object Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.QeueueFormatter`1 : CollectionFormatterBase`4<T, Queue`1<T>, Enumerator<T>, Queue`1<T>> {
    protected virtual void Add(Queue`1& collection, int index, T value);
    protected virtual Queue`1<T> Create();
    protected virtual Enumerator<T> GetSourceEnumerator(Queue`1<T> source);
    protected virtual Queue`1<T> Complete(Queue`1& intermediateCollection);
}
public class Utf8Json.Formatters.ReadOnlyCollectionFormatter`1 : CollectionFormatterBase`3<T, ArrayBuffer`1<T>, ReadOnlyCollection`1<T>> {
    protected virtual void Add(ArrayBuffer`1& collection, int index, T value);
    protected virtual ReadOnlyCollection`1<T> Complete(ArrayBuffer`1& intermediateCollection);
    protected virtual ArrayBuffer`1<T> Create();
}
public class Utf8Json.Formatters.ReadOnlyDictionaryFormatter`2 : DictionaryFormatterBase`4<TKey, TValue, Dictionary`2<TKey, TValue>, ReadOnlyDictionary`2<TKey, TValue>> {
    protected virtual void Add(Dictionary`2& collection, int index, TKey key, TValue value);
    protected virtual ReadOnlyDictionary`2<TKey, TValue> Complete(Dictionary`2& intermediateCollection);
    protected virtual Dictionary`2<TKey, TValue> Create();
}
public class Utf8Json.Formatters.ReadOnlyObservableCollectionFormatter`1 : CollectionFormatterBase`3<T, ObservableCollection`1<T>, ReadOnlyObservableCollection`1<T>> {
    protected virtual void Add(ObservableCollection`1& collection, int index, T value);
    protected virtual ObservableCollection`1<T> Create();
    protected virtual ReadOnlyObservableCollection`1<T> Complete(ObservableCollection`1& intermediateCollection);
}
public class Utf8Json.Formatters.SByteArrayFormatter : object {
    public static SByteArrayFormatter Default;
    private static SByteArrayFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, SByte[] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual SByte[] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.SByteFormatter : object {
    public static SByteFormatter Default;
    private static SByteFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, sbyte value, IJsonFormatterResolver formatterResolver);
    public sealed virtual sbyte Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, sbyte value, IJsonFormatterResolver formatterResolver);
    public sealed virtual sbyte DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.SingleArrayFormatter : object {
    public static SingleArrayFormatter Default;
    private static SingleArrayFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Single[] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Single[] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.SingleFormatter : object {
    public static SingleFormatter Default;
    private static SingleFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, float value, IJsonFormatterResolver formatterResolver);
    public sealed virtual float Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, float value, IJsonFormatterResolver formatterResolver);
    public sealed virtual float DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.SortedDictionaryFormatter`2 : DictionaryFormatterBase`5<TKey, TValue, SortedDictionary`2<TKey, TValue>, Enumerator<TKey, TValue>, SortedDictionary`2<TKey, TValue>> {
    protected virtual void Add(SortedDictionary`2& collection, int index, TKey key, TValue value);
    protected virtual SortedDictionary`2<TKey, TValue> Complete(SortedDictionary`2& intermediateCollection);
    protected virtual SortedDictionary`2<TKey, TValue> Create();
    protected virtual Enumerator<TKey, TValue> GetSourceEnumerator(SortedDictionary`2<TKey, TValue> source);
}
public class Utf8Json.Formatters.SortedListFormatter`2 : DictionaryFormatterBase`3<TKey, TValue, SortedList`2<TKey, TValue>> {
    protected virtual void Add(SortedList`2& collection, int index, TKey key, TValue value);
    protected virtual SortedList`2<TKey, TValue> Create();
}
public class Utf8Json.Formatters.StackFormatter`1 : CollectionFormatterBase`4<T, ArrayBuffer`1<T>, Enumerator<T>, Stack`1<T>> {
    protected virtual void Add(ArrayBuffer`1& collection, int index, T value);
    protected virtual ArrayBuffer`1<T> Create();
    protected virtual Enumerator<T> GetSourceEnumerator(Stack`1<T> source);
    protected virtual Stack`1<T> Complete(ArrayBuffer`1& intermediateCollection);
}
public class Utf8Json.Formatters.StaticNullableFormatter`1 : object {
    private IJsonFormatter`1<T> underlyingFormatter;
    public StaticNullableFormatter`1(IJsonFormatter`1<T> underlyingFormatter);
    public StaticNullableFormatter`1(Type formatterType, Object[] formatterArguments);
    public sealed virtual void Serialize(JsonWriter& writer, Nullable`1<T> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Nullable`1<T> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.StringBuilderFormatter : object {
    public static IJsonFormatter`1<StringBuilder> Default;
    private static StringBuilderFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, StringBuilder value, IJsonFormatterResolver formatterResolver);
    public sealed virtual StringBuilder Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.TaskUnitFormatter : object {
    public static IJsonFormatter`1<Task> Default;
    private static Task CompletedTask;
    private static TaskUnitFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Task value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Task Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.TaskValueFormatter`1 : object {
    public sealed virtual void Serialize(JsonWriter& writer, Task`1<T> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Task`1<T> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ThreeDimentionalArrayFormatter`1 : object {
    public sealed virtual void Serialize(JsonWriter& writer, T[0...,0...,0...] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual T[0...,0...,0...] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.TimeSpanFormatter : object {
    private string formatString;
    public TimeSpanFormatter(string formatString);
    public sealed virtual void Serialize(JsonWriter& writer, TimeSpan value, IJsonFormatterResolver formatterResolver);
    public sealed virtual TimeSpan Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.TupleFormatter`1 : object {
    private static Byte[][] cache;
    private static AutomataDictionary dictionary;
    private static TupleFormatter`1();
    public sealed virtual void Serialize(JsonWriter& writer, Tuple`1<T1> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Tuple`1<T1> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.TupleFormatter`2 : object {
    private static Byte[][] cache;
    private static AutomataDictionary dictionary;
    private static TupleFormatter`2();
    public sealed virtual void Serialize(JsonWriter& writer, Tuple`2<T1, T2> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Tuple`2<T1, T2> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.TupleFormatter`3 : object {
    private static Byte[][] cache;
    private static AutomataDictionary dictionary;
    private static TupleFormatter`3();
    public sealed virtual void Serialize(JsonWriter& writer, Tuple`3<T1, T2, T3> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Tuple`3<T1, T2, T3> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.TupleFormatter`4 : object {
    private static Byte[][] cache;
    private static AutomataDictionary dictionary;
    private static TupleFormatter`4();
    public sealed virtual void Serialize(JsonWriter& writer, Tuple`4<T1, T2, T3, T4> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Tuple`4<T1, T2, T3, T4> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.TupleFormatter`5 : object {
    private static Byte[][] cache;
    private static AutomataDictionary dictionary;
    private static TupleFormatter`5();
    public sealed virtual void Serialize(JsonWriter& writer, Tuple`5<T1, T2, T3, T4, T5> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Tuple`5<T1, T2, T3, T4, T5> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.TupleFormatter`6 : object {
    private static Byte[][] cache;
    private static AutomataDictionary dictionary;
    private static TupleFormatter`6();
    public sealed virtual void Serialize(JsonWriter& writer, Tuple`6<T1, T2, T3, T4, T5, T6> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Tuple`6<T1, T2, T3, T4, T5, T6> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.TupleFormatter`7 : object {
    private static Byte[][] cache;
    private static AutomataDictionary dictionary;
    private static TupleFormatter`7();
    public sealed virtual void Serialize(JsonWriter& writer, Tuple`7<T1, T2, T3, T4, T5, T6, T7> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Tuple`7<T1, T2, T3, T4, T5, T6, T7> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.TupleFormatter`8 : object {
    private static Byte[][] cache;
    private static AutomataDictionary dictionary;
    private static TupleFormatter`8();
    public sealed virtual void Serialize(JsonWriter& writer, Tuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Tuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.TwoDimentionalArrayFormatter`1 : object {
    public sealed virtual void Serialize(JsonWriter& writer, T[0...,0...] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual T[0...,0...] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.TypeFormatter : object {
    public static TypeFormatter Default;
    private static Regex SubtractFullNameRegex;
    private bool serializeAssemblyQualifiedName;
    private bool deserializeSubtractAssemblyQualifiedName;
    private bool throwOnError;
    public TypeFormatter(bool serializeAssemblyQualifiedName, bool deserializeSubtractAssemblyQualifiedName, bool throwOnError);
    private static TypeFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Type value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Type Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.UInt16ArrayFormatter : object {
    public static UInt16ArrayFormatter Default;
    private static UInt16ArrayFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, UInt16[] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual UInt16[] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.UInt16Formatter : object {
    public static UInt16Formatter Default;
    private static UInt16Formatter();
    public sealed virtual void Serialize(JsonWriter& writer, ushort value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ushort Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, ushort value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ushort DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.UInt32ArrayFormatter : object {
    public static UInt32ArrayFormatter Default;
    private static UInt32ArrayFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, UInt32[] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual UInt32[] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.UInt32Formatter : object {
    public static UInt32Formatter Default;
    private static UInt32Formatter();
    public sealed virtual void Serialize(JsonWriter& writer, UInt32 value, IJsonFormatterResolver formatterResolver);
    public sealed virtual UInt32 Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, UInt32 value, IJsonFormatterResolver formatterResolver);
    public sealed virtual UInt32 DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.UInt64ArrayFormatter : object {
    public static UInt64ArrayFormatter Default;
    private static UInt64ArrayFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, UInt64[] value, IJsonFormatterResolver formatterResolver);
    public sealed virtual UInt64[] Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.UInt64Formatter : object {
    public static UInt64Formatter Default;
    private static UInt64Formatter();
    public sealed virtual void Serialize(JsonWriter& writer, ulong value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ulong Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
    public sealed virtual void SerializeToPropertyName(JsonWriter& writer, ulong value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ulong DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.UnixTimestampDateTimeFormatter : object {
    private static DateTime UnixEpoch;
    private static UnixTimestampDateTimeFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, DateTime value, IJsonFormatterResolver formatterResolver);
    public sealed virtual DateTime Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.UriFormatter : object {
    public static IJsonFormatter`1<Uri> Default;
    private static UriFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Uri value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Uri Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ValueTaskFormatter`1 : object {
    public sealed virtual void Serialize(JsonWriter& writer, ValueTask`1<T> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ValueTask`1<T> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ValueTupleFormatter`1 : object {
    private static Byte[][] cache;
    private static AutomataDictionary dictionary;
    private static ValueTupleFormatter`1();
    public sealed virtual void Serialize(JsonWriter& writer, ValueTuple`1<T1> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ValueTuple`1<T1> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ValueTupleFormatter`2 : object {
    private static Byte[][] cache;
    private static AutomataDictionary dictionary;
    private static ValueTupleFormatter`2();
    public sealed virtual void Serialize(JsonWriter& writer, ValueTuple`2<T1, T2> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ValueTuple`2<T1, T2> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ValueTupleFormatter`3 : object {
    private static Byte[][] cache;
    private static AutomataDictionary dictionary;
    private static ValueTupleFormatter`3();
    public sealed virtual void Serialize(JsonWriter& writer, ValueTuple`3<T1, T2, T3> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ValueTuple`3<T1, T2, T3> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ValueTupleFormatter`4 : object {
    private static Byte[][] cache;
    private static AutomataDictionary dictionary;
    private static ValueTupleFormatter`4();
    public sealed virtual void Serialize(JsonWriter& writer, ValueTuple`4<T1, T2, T3, T4> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ValueTuple`4<T1, T2, T3, T4> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ValueTupleFormatter`5 : object {
    private static Byte[][] cache;
    private static AutomataDictionary dictionary;
    private static ValueTupleFormatter`5();
    public sealed virtual void Serialize(JsonWriter& writer, ValueTuple`5<T1, T2, T3, T4, T5> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ValueTuple`5<T1, T2, T3, T4, T5> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ValueTupleFormatter`6 : object {
    private static Byte[][] cache;
    private static AutomataDictionary dictionary;
    private static ValueTupleFormatter`6();
    public sealed virtual void Serialize(JsonWriter& writer, ValueTuple`6<T1, T2, T3, T4, T5, T6> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ValueTuple`6<T1, T2, T3, T4, T5, T6> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ValueTupleFormatter`7 : object {
    private static Byte[][] cache;
    private static AutomataDictionary dictionary;
    private static ValueTupleFormatter`7();
    public sealed virtual void Serialize(JsonWriter& writer, ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.ValueTupleFormatter`8 : object {
    private static Byte[][] cache;
    private static AutomataDictionary dictionary;
    private static ValueTupleFormatter`8();
    public sealed virtual void Serialize(JsonWriter& writer, ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> value, IJsonFormatterResolver formatterResolver);
    public sealed virtual ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.Formatters.VersionFormatter : object {
    public static IJsonFormatter`1<Version> Default;
    private static VersionFormatter();
    public sealed virtual void Serialize(JsonWriter& writer, Version value, IJsonFormatterResolver formatterResolver);
    public sealed virtual Version Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public interface Utf8Json.IJsonFormatter {
}
public interface Utf8Json.IJsonFormatter`1 {
    public abstract virtual void Serialize(JsonWriter& writer, T value, IJsonFormatterResolver formatterResolver);
    public abstract virtual T Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public interface Utf8Json.IJsonFormatterResolver {
    public abstract virtual IJsonFormatter`1<T> GetFormatter();
}
public class Utf8Json.Internal.ArrayBuffer`1 : ValueType {
    public T[] Buffer;
    public int Size;
    public ArrayBuffer`1(int initialSize);
    public void Add(T value);
    public T[] ToArray();
}
internal class Utf8Json.Internal.ArrayPool`1 : object {
    private int bufferLength;
    private object gate;
    private int index;
    private T[][] buffers;
    public ArrayPool`1(int bufferLength);
    public T[] Rent();
    public void Return(T[] array);
}
public class Utf8Json.Internal.AutomataDictionary : object {
    private AutomataNode root;
    public void Add(string str, int value);
    public void Add(Byte[] bytes, int value);
    public bool TryGetValue(ArraySegment`1<byte> bytes, Int32& value);
    public bool TryGetValue(Byte[] bytes, int offset, int count, Int32& value);
    public bool TryGetValueSafe(ArraySegment`1<byte> key, Int32& value);
    public virtual string ToString();
    private static void ToStringCore(IEnumerable`1<AutomataNode> nexts, StringBuilder sb, int depth);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, int>> GetEnumerator();
    [IteratorStateMachineAttribute("Utf8Json.Internal.AutomataDictionary/<YieldCore>d__11")]
private static IEnumerable`1<KeyValuePair`2<string, int>> YieldCore(IEnumerable`1<AutomataNode> nexts);
    public void EmitMatch(ILGenerator il, LocalBuilder p, LocalBuilder rest, LocalBuilder key, Action`1<KeyValuePair`2<string, int>> onFound, Action onNotFound);
}
public static class Utf8Json.Internal.AutomataKeyGen : object {
    public static MethodInfo GetKeyMethod;
    private static AutomataKeyGen();
    public static ulong GetKey(Byte*& p, Int32& rest);
    public static ulong GetKeySafe(Byte[] bytes, Int32& offset, Int32& rest);
}
public static class Utf8Json.Internal.BinaryUtil : object {
    private static int ArrayMaxSize;
    public static void EnsureCapacity(Byte[]& bytes, int offset, int appendLength);
    public static void FastResize(Byte[]& array, int newSize);
    public static Byte[] FastCloneWithResize(Byte[] src, int newSize);
}
internal class Utf8Json.Internal.BufferPool : ArrayPool`1<byte> {
    public static BufferPool Default;
    public BufferPool(int bufferLength);
    private static BufferPool();
}
public static class Utf8Json.Internal.ByteArrayComparer : object {
    private static bool Is32Bit;
    private static ByteArrayComparer();
    public static int GetHashCode(Byte[] bytes, int offset, int count);
    public static bool Equals(Byte[] xs, int xsOffset, int xsCount, Byte[] ys);
    public static bool Equals(Byte[] xs, int xsOffset, int xsCount, Byte[] ys, int ysOffset, int ysCount);
}
internal class Utf8Json.Internal.ByteArrayStringHashTable`1 : object {
    private Entry[][] buckets;
    private ulong indexFor;
    private static bool Is32Bit;
    public ByteArrayStringHashTable`1(int capacity);
    public ByteArrayStringHashTable`1(int capacity, float loadFactor);
    private static ByteArrayStringHashTable`1();
    public void Add(string key, T value);
    public void Add(Byte[] key, T value);
    private bool TryAddInternal(Byte[] key, T value);
    public bool TryGetValue(ArraySegment`1<byte> key, T& value);
    private static ulong ByteArrayGetHashCode(Byte[] x, int offset, int count);
    private static int CalculateCapacity(int collectionSize, float loadFactor);
    [IteratorStateMachineAttribute("Utf8Json.Internal.ByteArrayStringHashTable`1/<GetEnumerator>d__11")]
public sealed virtual IEnumerator`1<KeyValuePair`2<string, T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Utf8Json.Internal.DoubleConversion.CachedPower : ValueType {
    public ulong significand;
    public short binary_exponent;
    public short decimal_exponent;
    public CachedPower(ulong significand, short binary_exponent, short decimal_exponent);
}
internal class Utf8Json.Internal.DoubleConversion.DiyFp : ValueType {
    public static int kSignificandSize;
    public static ulong kUint64MSB;
    public ulong f;
    public int e;
    public DiyFp(ulong significand, int exponent);
    public void Subtract(DiyFp& other);
    public static DiyFp Minus(DiyFp& a, DiyFp& b);
    public static DiyFp op_Subtraction(DiyFp lhs, DiyFp rhs);
    public void Multiply(DiyFp& other);
    public static DiyFp Times(DiyFp& a, DiyFp& b);
    public static DiyFp op_Multiply(DiyFp lhs, DiyFp rhs);
    public void Normalize();
    public static DiyFp Normalize(DiyFp& a);
}
internal class Utf8Json.Internal.DoubleConversion.Double : ValueType {
    public static ulong kSignMask;
    public static ulong kExponentMask;
    public static ulong kSignificandMask;
    public static ulong kHiddenBit;
    public static int kPhysicalSignificandSize;
    public static int kSignificandSize;
    private static int kExponentBias;
    private static int kDenormalExponent;
    private static int kMaxExponent;
    private static ulong kInfinity;
    private static ulong kNaN;
    private ulong d64_;
    public Double(double d);
    public Double(DiyFp d);
    public DiyFp AsDiyFp();
    public DiyFp AsNormalizedDiyFp();
    public ulong AsUint64();
    public double NextDouble();
    public double PreviousDouble();
    public int Exponent();
    public ulong Significand();
    public bool IsDenormal();
    public bool IsSpecial();
    public bool IsNan();
    public bool IsInfinite();
    public int Sign();
    public DiyFp UpperBoundary();
    public void NormalizedBoundaries(DiyFp& out_m_minus, DiyFp& out_m_plus);
    public bool LowerBoundaryIsCloser();
    public double value();
    public static int SignificandSizeForOrderOfMagnitude(int order);
    public static double Infinity();
    public static double NaN();
    public static ulong DiyFpToUint64(DiyFp diy_fp);
}
internal static class Utf8Json.Internal.DoubleConversion.DoubleToStringConverter : object {
    [ThreadStaticAttribute]
private static Byte[] decimalRepBuffer;
    [ThreadStaticAttribute]
private static Byte[] exponentialRepBuffer;
    [ThreadStaticAttribute]
private static Byte[] toStringBuffer;
    private static Byte[] infinity_symbol_;
    private static Byte[] nan_symbol_;
    private static Flags flags_;
    private static char exponent_character_;
    private static int decimal_in_shortest_low_;
    private static int decimal_in_shortest_high_;
    private static int kBase10MaximalLength;
    private static int kFastDtoaMaximalLength;
    private static int kFastDtoaMaximalSingleLength;
    private static int kMinimalTargetExponent;
    private static int kMaximalTargetExponent;
    private static UInt32[] kSmallPowersOfTen;
    private static DoubleToStringConverter();
    private static Byte[] GetDecimalRepBuffer(int size);
    private static Byte[] GetExponentialRepBuffer(int size);
    private static Byte[] GetToStringBuffer();
    public static int GetBytes(Byte[]& buffer, int offset, float value);
    public static int GetBytes(Byte[]& buffer, int offset, double value);
    private static bool RoundWeed(Byte[] buffer, int length, ulong distance_too_high_w, ulong unsafe_interval, ulong rest, ulong ten_kappa, ulong unit);
    private static void BiggestPowerTen(UInt32 number, int number_bits, UInt32& power, Int32& exponent_plus_one);
    private static bool DigitGen(DiyFp low, DiyFp w, DiyFp high, Byte[] buffer, Int32& length, Int32& kappa);
    private static bool Grisu3(double v, FastDtoaMode mode, Byte[] buffer, Int32& length, Int32& decimal_exponent);
    private static bool FastDtoa(double v, FastDtoaMode mode, Byte[] buffer, Int32& length, Int32& decimal_point);
    private static bool HandleSpecialValues(double value, StringBuilder& result_builder);
    private static bool ToShortestIeeeNumber(double value, StringBuilder& result_builder, DtoaMode mode);
    private static void CreateDecimalRepresentation(Byte[] decimal_digits, int length, int decimal_point, int digits_after_point, StringBuilder& result_builder);
    private static void CreateExponentialRepresentation(Byte[] decimal_digits, int length, int exponent, StringBuilder& result_builder);
    private static bool DoubleToAscii(double v, DtoaMode mode, int requested_digits, Byte[] vector, Boolean& sign, Int32& length, Int32& point);
}
internal class Utf8Json.Internal.DoubleConversion.Iterator : ValueType {
    private Byte[] buffer;
    private int offset;
    public byte Value { get; }
    public Iterator(Byte[] buffer, int offset);
    public byte get_Value();
    public static Iterator op_Increment(Iterator self);
    public static Iterator op_Addition(Iterator self, int length);
    public static int op_Subtraction(Iterator lhs, Iterator rhs);
    public static bool op_Equality(Iterator lhs, Iterator rhs);
    public static bool op_Inequality(Iterator lhs, Iterator rhs);
    public static bool op_Equality(Iterator lhs, char rhs);
    public static bool op_Inequality(Iterator lhs, char rhs);
    public static bool op_Equality(Iterator lhs, byte rhs);
    public static bool op_Inequality(Iterator lhs, byte rhs);
    public static bool op_GreaterThanOrEqual(Iterator lhs, char rhs);
    public static bool op_LessThanOrEqual(Iterator lhs, char rhs);
    public static bool op_GreaterThan(Iterator lhs, char rhs);
    public static bool op_LessThan(Iterator lhs, char rhs);
}
internal static class Utf8Json.Internal.DoubleConversion.PowersOfTenCache : object {
    private static CachedPower[] kCachedPowers;
    public static int kCachedPowersOffset;
    public static double kD_1_LOG2_10;
    public static int kDecimalExponentDistance;
    public static int kMinDecimalExponent;
    public static int kMaxDecimalExponent;
    private static PowersOfTenCache();
    public static void GetCachedPowerForBinaryExponentRange(int min_exponent, int max_exponent, DiyFp& power, Int32& decimal_exponent);
    public static void GetCachedPowerForDecimalExponent(int requested_exponent, DiyFp& power, Int32& found_exponent);
}
internal class Utf8Json.Internal.DoubleConversion.Single : ValueType {
    private static int kExponentBias;
    private static int kDenormalExponent;
    private static int kMaxExponent;
    private static UInt32 kInfinity;
    private static UInt32 kNaN;
    public static UInt32 kSignMask;
    public static UInt32 kExponentMask;
    public static UInt32 kSignificandMask;
    public static UInt32 kHiddenBit;
    public static int kPhysicalSignificandSize;
    public static int kSignificandSize;
    private UInt32 d32_;
    public Single(float f);
    public DiyFp AsDiyFp();
    public UInt32 AsUint32();
    public int Exponent();
    public UInt32 Significand();
    public bool IsDenormal();
    public bool IsSpecial();
    public bool IsNan();
    public bool IsInfinite();
    public int Sign();
    public void NormalizedBoundaries(DiyFp& out_m_minus, DiyFp& out_m_plus);
    public DiyFp UpperBoundary();
    public bool LowerBoundaryIsCloser();
    public float value();
    public static float Infinity();
    public static float NaN();
}
internal class Utf8Json.Internal.DoubleConversion.StringBuilder : ValueType {
    public Byte[] buffer;
    public int offset;
    public StringBuilder(Byte[] buffer, int position);
    public void AddCharacter(byte str);
    public void AddString(Byte[] str);
    public void AddSubstring(Byte[] str, int length);
    public void AddSubstring(Byte[] str, int start, int length);
    public void AddPadding(byte c, int count);
    public void AddStringSlow(string str);
}
internal static class Utf8Json.Internal.DoubleConversion.StringToDouble : object {
    [ThreadStaticAttribute]
private static Byte[] copyBuffer;
    private static int kMaxExactDoubleIntegerDecimalDigits;
    private static int kMaxUint64DecimalDigits;
    private static int kMaxDecimalPower;
    private static int kMinDecimalPower;
    private static ulong kMaxUint64;
    private static Double[] exact_powers_of_ten;
    private static int kExactPowersOfTenSize;
    private static int kMaxSignificantDecimalDigits;
    private static StringToDouble();
    private static Byte[] GetCopyBuffer();
    private static Vector TrimLeadingZeros(Vector buffer);
    private static Vector TrimTrailingZeros(Vector buffer);
    private static void CutToMaxSignificantDigits(Vector buffer, int exponent, Byte[] significant_buffer, Int32& significant_exponent);
    private static void TrimAndCut(Vector buffer, int exponent, Byte[] buffer_copy_space, int space_size, Vector& trimmed, Int32& updated_exponent);
    private static ulong ReadUint64(Vector buffer, Int32& number_of_read_digits);
    private static void ReadDiyFp(Vector buffer, DiyFp& result, Int32& remaining_decimals);
    private static bool DoubleStrtod(Vector trimmed, int exponent, Double& result);
    private static DiyFp AdjustmentPowerOfTen(int exponent);
    private static bool DiyFpStrtod(Vector buffer, int exponent, Double& result);
    private static bool ComputeGuess(Vector trimmed, int exponent, Double& guess);
    public static Nullable`1<double> Strtod(Vector buffer, int exponent);
    public static Nullable`1<float> Strtof(Vector buffer, int exponent);
}
internal static class Utf8Json.Internal.DoubleConversion.StringToDoubleConverter : object {
    [ThreadStaticAttribute]
private static Byte[] kBuffer;
    [ThreadStaticAttribute]
private static Byte[] fallbackBuffer;
    private static Flags flags_;
    private static double empty_string_value_;
    private static double junk_string_value_;
    private static int kMaxSignificantDigits;
    private static int kBufferSize;
    private static Byte[] infinity_symbol_;
    private static Byte[] nan_symbol_;
    private static Byte[] kWhitespaceTable7;
    private static int kWhitespaceTable7Length;
    private static UInt16[] kWhitespaceTable16;
    private static int kWhitespaceTable16Length;
    private static StringToDoubleConverter();
    private static Byte[] GetBuffer();
    private static Byte[] GetFallbackBuffer();
    public static double ToDouble(Byte[] buffer, int offset, Int32& readCount);
    public static float ToSingle(Byte[] buffer, int offset, Int32& readCount);
    private static bool isWhitespace(int x);
    private static bool AdvanceToNonspace(Iterator& current, Iterator end);
    private static bool ConsumeSubString(Iterator& current, Iterator end, Byte[] substring);
    private static bool ConsumeFirstCharacter(Iterator& iter, Byte[] str, int offset);
    private static double SignedZero(bool sign);
    private static double StringToIeee(Iterator input, int length, bool read_as_double, Int32& processed_characters_count);
}
internal class Utf8Json.Internal.DoubleConversion.UnionDoubleULong : ValueType {
    public double d;
    public ulong u64;
}
internal class Utf8Json.Internal.DoubleConversion.UnionFloatUInt : ValueType {
    public float f;
    public UInt32 u32;
}
[DefaultMemberAttribute("Item")]
internal class Utf8Json.Internal.DoubleConversion.Vector : ValueType {
    public Byte[] bytes;
    public int start;
    public int _length;
    public byte Item { get; public set; }
    public Vector(Byte[] bytes, int start, int length);
    public byte get_Item(int i);
    public void set_Item(int i, byte value);
    public int length();
    public byte first();
    public byte last();
    public bool is_empty();
    public Vector SubVector(int from, int to);
}
internal class Utf8Json.Internal.Emit.ArgumentField : ValueType {
    private int i;
    private bool ref;
    private ILGenerator il;
    public ArgumentField(ILGenerator il, int i, bool ref);
    public ArgumentField(ILGenerator il, int i, Type type);
    public void EmitLoad();
    public void EmitStore();
}
internal class Utf8Json.Internal.Emit.DynamicAssembly : object {
    private AssemblyBuilder assemblyBuilder;
    private ModuleBuilder moduleBuilder;
    private object gate;
    public DynamicAssembly(string moduleName);
    public TypeBuilder DefineType(string name, TypeAttributes attr);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent);
    public TypeBuilder DefineType(string name, TypeAttributes attr, Type parent, Type[] interfaces);
}
internal static class Utf8Json.Internal.Emit.ExpressionUtility : object {
    private static MethodInfo GetMethodInfoCore(LambdaExpression expression);
    public static MethodInfo GetMethodInfo(Expression`1<Func`1<T>> expression);
    public static MethodInfo GetMethodInfo(Expression`1<Action> expression);
    public static MethodInfo GetMethodInfo(Expression`1<Func`2<T, TR>> expression);
    public static MethodInfo GetMethodInfo(Expression`1<Action`1<T>> expression);
    public static MethodInfo GetMethodInfo(Expression`1<Action`2<TArg1, TArg2>> expression);
    public static MethodInfo GetMethodInfo(Expression`1<Func`3<T, TArg1, TR>> expression);
    private static MemberInfo GetMemberInfoCore(Expression`1<T> source);
    public static PropertyInfo GetPropertyInfo(Expression`1<Func`2<T, TR>> expression);
    public static FieldInfo GetFieldInfo(Expression`1<Func`2<T, TR>> expression);
}
[ExtensionAttribute]
internal static class Utf8Json.Internal.Emit.ILGeneratorExtensions : object {
    [ExtensionAttribute]
public static void EmitLdloc(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitLdloc(ILGenerator il, LocalBuilder local);
    [ExtensionAttribute]
public static void EmitStloc(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitStloc(ILGenerator il, LocalBuilder local);
    [ExtensionAttribute]
public static void EmitLdloca(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitLdloca(ILGenerator il, LocalBuilder local);
    [ExtensionAttribute]
public static void EmitTrue(ILGenerator il);
    [ExtensionAttribute]
public static void EmitFalse(ILGenerator il);
    [ExtensionAttribute]
public static void EmitBoolean(ILGenerator il, bool value);
    [ExtensionAttribute]
public static void EmitLdc_I4(ILGenerator il, int value);
    [ExtensionAttribute]
public static void EmitUnboxOrCast(ILGenerator il, Type type);
    [ExtensionAttribute]
public static void EmitBoxOrDoNothing(ILGenerator il, Type type);
    [ExtensionAttribute]
public static void EmitLdarg(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitLoadThis(ILGenerator il);
    [ExtensionAttribute]
public static void EmitLdarga(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitStarg(ILGenerator il, int index);
    [ExtensionAttribute]
public static void EmitPop(ILGenerator il, int count);
    [ExtensionAttribute]
public static void EmitCall(ILGenerator il, MethodInfo methodInfo);
    [ExtensionAttribute]
public static void EmitLdfld(ILGenerator il, FieldInfo fieldInfo);
    [ExtensionAttribute]
public static void EmitLdsfld(ILGenerator il, FieldInfo fieldInfo);
    [ExtensionAttribute]
public static void EmitRet(ILGenerator il);
    [ExtensionAttribute]
public static void EmitIntZeroReturn(ILGenerator il);
    [ExtensionAttribute]
public static void EmitNullReturn(ILGenerator il);
    [ExtensionAttribute]
public static void EmitULong(ILGenerator il, ulong value);
    [ExtensionAttribute]
public static void EmitThrowNotimplemented(ILGenerator il);
    [ExtensionAttribute]
public static void EmitIncrementFor(ILGenerator il, LocalBuilder conditionGreater, Action`1<LocalBuilder> emitBody);
}
internal class Utf8Json.Internal.Emit.InnerExceptionMetaMember : MetaMember {
    private static MethodInfo getInnerException;
    private static MethodInfo nongenericSerialize;
    internal ArgumentField argWriter;
    internal ArgumentField argValue;
    internal ArgumentField argResolver;
    public InnerExceptionMetaMember(string name);
    private static InnerExceptionMetaMember();
    public virtual void EmitLoadValue(ILGenerator il);
    public virtual void EmitStoreValue(ILGenerator il);
    public void EmitSerializeDirectly(ILGenerator il);
}
internal class Utf8Json.Internal.Emit.MetaMember : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWritable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadable>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private FieldInfo <FieldInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyInfo <PropertyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <ShouldSerializeMethodInfo>k__BackingField;
    private MethodInfo getMethod;
    private MethodInfo setMethod;
    public string Name { get; private set; }
    public string MemberName { get; private set; }
    public bool IsProperty { get; }
    public bool IsField { get; }
    public bool IsWritable { get; private set; }
    public bool IsReadable { get; private set; }
    public Type Type { get; private set; }
    public FieldInfo FieldInfo { get; private set; }
    public PropertyInfo PropertyInfo { get; private set; }
    public MethodInfo ShouldSerializeMethodInfo { get; private set; }
    protected MetaMember(Type type, string name, string memberName, bool isWritable, bool isReadable);
    public MetaMember(FieldInfo info, string name, bool allowPrivate);
    public MetaMember(PropertyInfo info, string name, bool allowPrivate);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_MemberName();
    [CompilerGeneratedAttribute]
private void set_MemberName(string value);
    public bool get_IsProperty();
    public bool get_IsField();
    [CompilerGeneratedAttribute]
public bool get_IsWritable();
    [CompilerGeneratedAttribute]
private void set_IsWritable(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReadable();
    [CompilerGeneratedAttribute]
private void set_IsReadable(bool value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public FieldInfo get_FieldInfo();
    [CompilerGeneratedAttribute]
private void set_FieldInfo(FieldInfo value);
    [CompilerGeneratedAttribute]
public PropertyInfo get_PropertyInfo();
    [CompilerGeneratedAttribute]
private void set_PropertyInfo(PropertyInfo value);
    [CompilerGeneratedAttribute]
public MethodInfo get_ShouldSerializeMethodInfo();
    [CompilerGeneratedAttribute]
private void set_ShouldSerializeMethodInfo(MethodInfo value);
    private static MethodInfo GetShouldSerialize(MemberInfo info);
    public T GetCustomAttribute(bool inherit);
    public virtual void EmitLoadValue(ILGenerator il);
    public virtual void EmitStoreValue(ILGenerator il);
}
internal class Utf8Json.Internal.Emit.MetaType : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClass>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConcreteClass>k__BackingField;
    [CompilerGeneratedAttribute]
private ConstructorInfo <BestmatchConstructor>k__BackingField;
    [CompilerGeneratedAttribute]
private MetaMember[] <ConstructorParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private MetaMember[] <Members>k__BackingField;
    public Type Type { get; private set; }
    public bool IsClass { get; private set; }
    public bool IsStruct { get; }
    public bool IsConcreteClass { get; private set; }
    public ConstructorInfo BestmatchConstructor { get; internal set; }
    public MetaMember[] ConstructorParameters { get; internal set; }
    public MetaMember[] Members { get; internal set; }
    public MetaType(Type type, Func`2<string, string> nameMutetor, bool allowPrivate);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsClass();
    [CompilerGeneratedAttribute]
private void set_IsClass(bool value);
    public bool get_IsStruct();
    [CompilerGeneratedAttribute]
public bool get_IsConcreteClass();
    [CompilerGeneratedAttribute]
private void set_IsConcreteClass(bool value);
    [CompilerGeneratedAttribute]
public ConstructorInfo get_BestmatchConstructor();
    [CompilerGeneratedAttribute]
internal void set_BestmatchConstructor(ConstructorInfo value);
    [CompilerGeneratedAttribute]
public MetaMember[] get_ConstructorParameters();
    [CompilerGeneratedAttribute]
internal void set_ConstructorParameters(MetaMember[] value);
    [CompilerGeneratedAttribute]
public MetaMember[] get_Members();
    [CompilerGeneratedAttribute]
internal void set_Members(MetaMember[] value);
    private static bool TryGetNextConstructor(IEnumerator`1<ConstructorInfo> ctorEnumerator, ConstructorInfo& ctor);
}
internal class Utf8Json.Internal.Emit.StringConstantValueMetaMember : MetaMember {
    private string constant;
    public StringConstantValueMetaMember(string name, string constant);
    public virtual void EmitLoadValue(ILGenerator il);
    public virtual void EmitStoreValue(ILGenerator il);
}
internal static class Utf8Json.Internal.FarmHash : object {
    private static UInt32 c1;
    private static UInt32 c2;
    private static ulong k0;
    private static ulong k1;
    private static ulong k2;
    public static UInt32 Hash32(Byte[] bytes, int offset, int count);
    private static UInt32 Fetch32(Byte* p);
    private static UInt32 Rotate32(UInt32 val, int shift);
    private static UInt32 fmix(UInt32 h);
    private static UInt32 Mur(UInt32 a, UInt32 h);
    private static UInt32 Hash32Len0to4(Byte[] s, int offset, UInt32 len);
    private static UInt32 Hash32Len5to12(Byte* s, UInt32 len);
    private static UInt32 Hash32Len13to24(Byte* s, UInt32 len);
    private static UInt32 Hash32(Byte* s, UInt32 len);
    public static ulong Hash64(Byte[] bytes, int offset, int count);
    private static pair make_pair(ulong first, ulong second);
    private static void swap(UInt64& x, UInt64& z);
    private static ulong Fetch64(Byte* p);
    private static ulong Rotate64(ulong val, int shift);
    private static ulong ShiftMix(ulong val);
    private static ulong HashLen16(ulong u, ulong v, ulong mul);
    private static ulong Hash64(Byte* s, UInt32 len);
    private static ulong HashLen0to16(Byte* s, UInt32 len);
    private static ulong HashLen17to32(Byte* s, UInt32 len);
    private static ulong H32(Byte* s, UInt32 len, ulong mul, ulong seed0, ulong seed1);
    private static ulong HashLen33to64(Byte* s, UInt32 len);
    private static ulong HashLen65to96(Byte* s, UInt32 len);
    private static pair WeakHashLen32WithSeeds(ulong w, ulong x, ulong y, ulong z, ulong a, ulong b);
    private static pair WeakHashLen32WithSeeds(Byte* s, ulong a, ulong b);
    private static ulong Hash64NA(Byte* s, UInt32 len);
    private static ulong H(ulong x, ulong y, ulong mul, int r);
    private static ulong Hash64UO(Byte* s, UInt32 len);
}
[ExtensionAttribute]
internal static class Utf8Json.Internal.FuncExtensions : object {
    [ExtensionAttribute]
public static Func`1<T> AsFunc(T value);
    [ExtensionAttribute]
public static Func`1<T> AsFuncFast(T value);
    [ExtensionAttribute]
private static T Return(T value);
    [ExtensionAttribute]
private static T ReturnBox(object value);
}
internal class Utf8Json.Internal.GuidBits : ValueType {
    public Guid Value;
    public byte Byte0;
    public byte Byte1;
    public byte Byte2;
    public byte Byte3;
    public byte Byte4;
    public byte Byte5;
    public byte Byte6;
    public byte Byte7;
    public byte Byte8;
    public byte Byte9;
    public byte Byte10;
    public byte Byte11;
    public byte Byte12;
    public byte Byte13;
    public byte Byte14;
    public byte Byte15;
    private static Byte[] byteToHexStringHigh;
    private static Byte[] byteToHexStringLow;
    public GuidBits(Guid& value);
    public GuidBits(ArraySegment`1& utf8string);
    private static GuidBits();
    private static byte Parse(Byte[] bytes, int highOffset);
    private static byte SwitchParse(byte b);
    public void Write(Byte[] buffer, int offset);
}
internal class Utf8Json.Internal.ILStreamReader : BinaryReader {
    private static OpCode[] oneByteOpCodes;
    private static OpCode[] twoByteOpCodes;
    private int endPosition;
    public int CurrentPosition { get; }
    public bool EndOfStream { get; }
    private static ILStreamReader();
    public ILStreamReader(Byte[] ilByteArray);
    public int get_CurrentPosition();
    public bool get_EndOfStream();
    public OpCode ReadOpCode();
    public int ReadMetadataToken();
}
public static class Utf8Json.Internal.NumberConverter : object {
    public static bool IsNumber(byte c);
    public static bool IsNumberRepresentation(byte c);
    public static sbyte ReadSByte(Byte[] bytes, int offset, Int32& readCount);
    public static short ReadInt16(Byte[] bytes, int offset, Int32& readCount);
    public static int ReadInt32(Byte[] bytes, int offset, Int32& readCount);
    public static long ReadInt64(Byte[] bytes, int offset, Int32& readCount);
    public static byte ReadByte(Byte[] bytes, int offset, Int32& readCount);
    public static ushort ReadUInt16(Byte[] bytes, int offset, Int32& readCount);
    public static UInt32 ReadUInt32(Byte[] bytes, int offset, Int32& readCount);
    public static ulong ReadUInt64(Byte[] bytes, int offset, Int32& readCount);
    public static float ReadSingle(Byte[] bytes, int offset, Int32& readCount);
    public static double ReadDouble(Byte[] bytes, int offset, Int32& readCount);
    public static int WriteByte(Byte[]& buffer, int offset, byte value);
    public static int WriteUInt16(Byte[]& buffer, int offset, ushort value);
    public static int WriteUInt32(Byte[]& buffer, int offset, UInt32 value);
    public static int WriteUInt64(Byte[]& buffer, int offset, ulong value);
    public static int WriteSByte(Byte[]& buffer, int offset, sbyte value);
    public static int WriteInt16(Byte[]& buffer, int offset, short value);
    public static int WriteInt32(Byte[]& buffer, int offset, int value);
    public static int WriteInt64(Byte[]& buffer, int offset, long value);
    public static int WriteSingle(Byte[]& bytes, int offset, float value);
    public static int WriteDouble(Byte[]& bytes, int offset, double value);
    public static bool ReadBoolean(Byte[] bytes, int offset, Int32& readCount);
}
[ExtensionAttribute]
internal static class Utf8Json.Internal.ReflectionExtensions : object {
    [ExtensionAttribute]
public static bool IsNullable(TypeInfo type);
    [ExtensionAttribute]
public static bool IsPublic(TypeInfo type);
    [ExtensionAttribute]
public static bool IsAnonymous(TypeInfo type);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetAllProperties(Type type);
    [IteratorStateMachineAttribute("Utf8Json.Internal.ReflectionExtensions/<GetAllPropertiesCore>d__4")]
private static IEnumerable`1<PropertyInfo> GetAllPropertiesCore(Type type, HashSet`1<string> nameCheck);
    [ExtensionAttribute]
public static IEnumerable`1<FieldInfo> GetAllFields(Type type);
    [IteratorStateMachineAttribute("Utf8Json.Internal.ReflectionExtensions/<GetAllFieldsCore>d__6")]
private static IEnumerable`1<FieldInfo> GetAllFieldsCore(Type type, HashSet`1<string> nameCheck);
    [ExtensionAttribute]
public static bool IsConstructedGenericType(TypeInfo type);
    [ExtensionAttribute]
public static MethodInfo GetGetMethod(PropertyInfo propInfo);
    [ExtensionAttribute]
public static MethodInfo GetSetMethod(PropertyInfo propInfo);
}
internal static class Utf8Json.Internal.StringEncoding : object {
    public static Encoding UTF8;
    private static StringEncoding();
}
internal static class Utf8Json.Internal.StringMutator : object {
    public static string Original(string s);
    public static string ToCamelCase(string s);
    public static string ToSnakeCase(string s);
}
internal class Utf8Json.Internal.ThreadsafeTypeKeyHashTable`1 : object {
    private Entry[] buckets;
    private int size;
    private object writerLock;
    private float loadFactor;
    public ThreadsafeTypeKeyHashTable`1(int capacity, float loadFactor);
    public bool TryAdd(Type key, TValue value);
    public bool TryAdd(Type key, Func`2<Type, TValue> valueFactory);
    private bool TryAddInternal(Type key, Func`2<Type, TValue> valueFactory, TValue& resultingValue);
    private bool AddToBuckets(Entry[] buckets, Type newKey, Entry<TValue> newEntryOrNull, Func`2<Type, TValue> valueFactory, TValue& resultingValue);
    public bool TryGetValue(Type key, TValue& value);
    public TValue GetOrAdd(Type key, Func`2<Type, TValue> valueFactory);
    private static int CalculateCapacity(int collectionSize, float loadFactor);
    private static void VolatileWrite(Entry& location, Entry<TValue> value);
    private static void VolatileWrite(Entry[]& location, Entry[] value);
}
public static class Utf8Json.Internal.UnsafeMemory : object {
    public static bool Is32Bit;
    private static UnsafeMemory();
    public static void WriteRaw(JsonWriter& writer, Byte[] src);
    public static void MemoryCopy(JsonWriter& writer, Byte[] src);
}
public static class Utf8Json.Internal.UnsafeMemory32 : object {
    public static void WriteRaw4(JsonWriter& writer, Byte[] src);
    public static void WriteRaw5(JsonWriter& writer, Byte[] src);
    public static void WriteRaw6(JsonWriter& writer, Byte[] src);
    public static void WriteRaw7(JsonWriter& writer, Byte[] src);
    public static void WriteRaw8(JsonWriter& writer, Byte[] src);
    public static void WriteRaw9(JsonWriter& writer, Byte[] src);
    public static void WriteRaw10(JsonWriter& writer, Byte[] src);
    public static void WriteRaw11(JsonWriter& writer, Byte[] src);
    public static void WriteRaw12(JsonWriter& writer, Byte[] src);
    public static void WriteRaw13(JsonWriter& writer, Byte[] src);
    public static void WriteRaw14(JsonWriter& writer, Byte[] src);
    public static void WriteRaw15(JsonWriter& writer, Byte[] src);
    public static void WriteRaw16(JsonWriter& writer, Byte[] src);
    public static void WriteRaw17(JsonWriter& writer, Byte[] src);
    public static void WriteRaw18(JsonWriter& writer, Byte[] src);
    public static void WriteRaw19(JsonWriter& writer, Byte[] src);
    public static void WriteRaw20(JsonWriter& writer, Byte[] src);
    public static void WriteRaw21(JsonWriter& writer, Byte[] src);
    public static void WriteRaw22(JsonWriter& writer, Byte[] src);
    public static void WriteRaw23(JsonWriter& writer, Byte[] src);
    public static void WriteRaw24(JsonWriter& writer, Byte[] src);
    public static void WriteRaw25(JsonWriter& writer, Byte[] src);
    public static void WriteRaw26(JsonWriter& writer, Byte[] src);
    public static void WriteRaw27(JsonWriter& writer, Byte[] src);
    public static void WriteRaw28(JsonWriter& writer, Byte[] src);
    public static void WriteRaw29(JsonWriter& writer, Byte[] src);
    public static void WriteRaw30(JsonWriter& writer, Byte[] src);
    public static void WriteRaw31(JsonWriter& writer, Byte[] src);
    public static void WriteRaw1(JsonWriter& writer, Byte[] src);
    public static void WriteRaw2(JsonWriter& writer, Byte[] src);
    public static void WriteRaw3(JsonWriter& writer, Byte[] src);
}
public static class Utf8Json.Internal.UnsafeMemory64 : object {
    public static void WriteRaw8(JsonWriter& writer, Byte[] src);
    public static void WriteRaw9(JsonWriter& writer, Byte[] src);
    public static void WriteRaw10(JsonWriter& writer, Byte[] src);
    public static void WriteRaw11(JsonWriter& writer, Byte[] src);
    public static void WriteRaw12(JsonWriter& writer, Byte[] src);
    public static void WriteRaw13(JsonWriter& writer, Byte[] src);
    public static void WriteRaw14(JsonWriter& writer, Byte[] src);
    public static void WriteRaw15(JsonWriter& writer, Byte[] src);
    public static void WriteRaw16(JsonWriter& writer, Byte[] src);
    public static void WriteRaw17(JsonWriter& writer, Byte[] src);
    public static void WriteRaw18(JsonWriter& writer, Byte[] src);
    public static void WriteRaw19(JsonWriter& writer, Byte[] src);
    public static void WriteRaw20(JsonWriter& writer, Byte[] src);
    public static void WriteRaw21(JsonWriter& writer, Byte[] src);
    public static void WriteRaw22(JsonWriter& writer, Byte[] src);
    public static void WriteRaw23(JsonWriter& writer, Byte[] src);
    public static void WriteRaw24(JsonWriter& writer, Byte[] src);
    public static void WriteRaw25(JsonWriter& writer, Byte[] src);
    public static void WriteRaw26(JsonWriter& writer, Byte[] src);
    public static void WriteRaw27(JsonWriter& writer, Byte[] src);
    public static void WriteRaw28(JsonWriter& writer, Byte[] src);
    public static void WriteRaw29(JsonWriter& writer, Byte[] src);
    public static void WriteRaw30(JsonWriter& writer, Byte[] src);
    public static void WriteRaw31(JsonWriter& writer, Byte[] src);
    public static void WriteRaw1(JsonWriter& writer, Byte[] src);
    public static void WriteRaw2(JsonWriter& writer, Byte[] src);
    public static void WriteRaw3(JsonWriter& writer, Byte[] src);
    public static void WriteRaw4(JsonWriter& writer, Byte[] src);
    public static void WriteRaw5(JsonWriter& writer, Byte[] src);
    public static void WriteRaw6(JsonWriter& writer, Byte[] src);
    public static void WriteRaw7(JsonWriter& writer, Byte[] src);
}
public interface Utf8Json.IObjectPropertyNameFormatter`1 {
    public abstract virtual void SerializeToPropertyName(JsonWriter& writer, T value, IJsonFormatterResolver formatterResolver);
    public abstract virtual T DeserializeFromPropertyName(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
public class Utf8Json.JsonDeserializeFunc`1 : MulticastDelegate {
    public JsonDeserializeFunc`1(object object, IntPtr method);
    public virtual T Invoke(JsonReader& reader, IJsonFormatterResolver resolver);
    public virtual IAsyncResult BeginInvoke(JsonReader& reader, IJsonFormatterResolver resolver, AsyncCallback callback, object object);
    public virtual T EndInvoke(JsonReader& reader, IAsyncResult result);
}
[AttributeUsageAttribute("1420")]
public class Utf8Json.JsonFormatterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <FormatterType>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public Type FormatterType { get; private set; }
    public Object[] Arguments { get; private set; }
    public JsonFormatterAttribute(Type formatterType);
    public JsonFormatterAttribute(Type formatterType, Object[] arguments);
    [CompilerGeneratedAttribute]
public Type get_FormatterType();
    [CompilerGeneratedAttribute]
private void set_FormatterType(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
    [CompilerGeneratedAttribute]
private void set_Arguments(Object[] value);
}
[ExtensionAttribute]
public static class Utf8Json.JsonFormatterExtensions : object {
    [ExtensionAttribute]
public static string ToJsonString(IJsonFormatter`1<T> formatter, T value, IJsonFormatterResolver formatterResolver);
}
[ExtensionAttribute]
public static class Utf8Json.JsonFormatterResolverExtensions : object {
    [ExtensionAttribute]
public static IJsonFormatter`1<T> GetFormatterWithVerify(IJsonFormatterResolver resolver);
    [ExtensionAttribute]
public static object GetFormatterDynamic(IJsonFormatterResolver resolver, Type type);
}
public class Utf8Json.JsonParsingException : Exception {
    private WeakReference underyingBytes;
    private int limit;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActualChar>k__BackingField;
    public int Offset { get; private set; }
    public string ActualChar { get; public set; }
    public JsonParsingException(string message);
    public JsonParsingException(string message, Byte[] underlyingBytes, int offset, int limit, string actualChar);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
private void set_Offset(int value);
    [CompilerGeneratedAttribute]
public string get_ActualChar();
    [CompilerGeneratedAttribute]
public void set_ActualChar(string value);
    public Byte[] GetUnderlyingByteArrayUnsafe();
    public string GetUnderlyingStringUnsafe();
}
public class Utf8Json.JsonReader : ValueType {
    private static ArraySegment`1<byte> nullTokenSegment;
    private static Byte[] bom;
    private Byte[] bytes;
    private int offset;
    private bool IsInRange { get; }
    public JsonReader(Byte[] bytes);
    public JsonReader(Byte[] bytes, int offset);
    private static JsonReader();
    private JsonParsingException CreateParsingException(string expected);
    private JsonParsingException CreateParsingExceptionMessage(string message);
    private bool get_IsInRange();
    public void AdvanceOffset(int offset);
    public Byte[] GetBufferUnsafe();
    public int GetCurrentOffsetUnsafe();
    public JsonToken GetCurrentJsonToken();
    public void SkipWhiteSpace();
    public bool ReadIsNull();
    public bool ReadIsBeginArray();
    public void ReadIsBeginArrayWithVerify();
    public bool ReadIsEndArray();
    public void ReadIsEndArrayWithVerify();
    public bool ReadIsEndArrayWithSkipValueSeparator(Int32& count);
    public bool ReadIsInArray(Int32& count);
    public bool ReadIsBeginObject();
    public void ReadIsBeginObjectWithVerify();
    public bool ReadIsEndObject();
    public void ReadIsEndObjectWithVerify();
    public bool ReadIsEndObjectWithSkipValueSeparator(Int32& count);
    public bool ReadIsInObject(Int32& count);
    public bool ReadIsValueSeparator();
    public void ReadIsValueSeparatorWithVerify();
    public bool ReadIsNameSeparator();
    public void ReadIsNameSeparatorWithVerify();
    private void ReadStringSegmentCore(Byte[]& resultBytes, Int32& resultOffset, Int32& resultLength);
    private static int GetCodePoint(char a, char b, char c, char d);
    private static int ToNumber(char x);
    public ArraySegment`1<byte> ReadStringSegmentUnsafe();
    public string ReadString();
    public string ReadPropertyName();
    public ArraySegment`1<byte> ReadStringSegmentRaw();
    public ArraySegment`1<byte> ReadPropertyNameSegmentRaw();
    public bool ReadBoolean();
    private static bool IsWordBreak(byte c);
    public void ReadNext();
    private void ReadNextCore(JsonToken token);
    public void ReadNextBlock();
    private void ReadNextBlockCore(int stack);
    public ArraySegment`1<byte> ReadNextBlockSegment();
    public sbyte ReadSByte();
    public short ReadInt16();
    public int ReadInt32();
    public long ReadInt64();
    public byte ReadByte();
    public ushort ReadUInt16();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public float ReadSingle();
    public double ReadDouble();
    public ArraySegment`1<byte> ReadNumberSegment();
    private static int ReadComment(Byte[] bytes, int offset);
}
public class Utf8Json.JsonSerializeAction`1 : MulticastDelegate {
    public JsonSerializeAction`1(object object, IntPtr method);
    public virtual void Invoke(JsonWriter& writer, T value, IJsonFormatterResolver resolver);
    public virtual IAsyncResult BeginInvoke(JsonWriter& writer, T value, IJsonFormatterResolver resolver, AsyncCallback callback, object object);
    public virtual void EndInvoke(JsonWriter& writer, IAsyncResult result);
}
public static class Utf8Json.JsonSerializer : object {
    private static IJsonFormatterResolver defaultResolver;
    private static Byte[][] indent;
    private static Byte[] newLine;
    public static IJsonFormatterResolver DefaultResolver { get; }
    public static bool IsInitialized { get; }
    private static JsonSerializer();
    public static IJsonFormatterResolver get_DefaultResolver();
    public static bool get_IsInitialized();
    public static void SetDefaultResolver(IJsonFormatterResolver resolver);
    public static Byte[] Serialize(T obj);
    public static Byte[] Serialize(T value, IJsonFormatterResolver resolver);
    public static void Serialize(JsonWriter& writer, T value);
    public static void Serialize(JsonWriter& writer, T value, IJsonFormatterResolver resolver);
    public static void Serialize(Stream stream, T value);
    public static void Serialize(Stream stream, T value, IJsonFormatterResolver resolver);
    public static Task SerializeAsync(Stream stream, T value);
    [AsyncStateMachineAttribute("Utf8Json.JsonSerializer/<SerializeAsync>d__13`1")]
public static Task SerializeAsync(Stream stream, T value, IJsonFormatterResolver resolver);
    public static ArraySegment`1<byte> SerializeUnsafe(T obj);
    public static ArraySegment`1<byte> SerializeUnsafe(T value, IJsonFormatterResolver resolver);
    public static string ToJsonString(T value);
    public static string ToJsonString(T value, IJsonFormatterResolver resolver);
    public static T Deserialize(string json);
    public static T Deserialize(string json, IJsonFormatterResolver resolver);
    public static T Deserialize(Byte[] bytes);
    public static T Deserialize(Byte[] bytes, IJsonFormatterResolver resolver);
    public static T Deserialize(Byte[] bytes, int offset);
    public static T Deserialize(Byte[] bytes, int offset, IJsonFormatterResolver resolver);
    public static T Deserialize(JsonReader& reader);
    public static T Deserialize(JsonReader& reader, IJsonFormatterResolver resolver);
    public static T Deserialize(Stream stream);
    public static T Deserialize(Stream stream, IJsonFormatterResolver resolver);
    public static Task`1<T> DeserializeAsync(Stream stream);
    [AsyncStateMachineAttribute("Utf8Json.JsonSerializer/<DeserializeAsync>d__29`1")]
public static Task`1<T> DeserializeAsync(Stream stream, IJsonFormatterResolver resolver);
    public static string PrettyPrint(Byte[] json);
    public static string PrettyPrint(Byte[] json, int offset);
    public static string PrettyPrint(string json);
    public static Byte[] PrettyPrintByteArray(Byte[] json);
    public static Byte[] PrettyPrintByteArray(Byte[] json, int offset);
    public static Byte[] PrettyPrintByteArray(string json);
    private static void WritePrittyPrint(JsonReader& reader, JsonWriter& writer, int depth);
    private static int FillFromStream(Stream input, Byte[]& buffer);
}
public enum Utf8Json.JsonToken : Enum {
    public byte value__;
    public static JsonToken None;
    public static JsonToken BeginObject;
    public static JsonToken EndObject;
    public static JsonToken BeginArray;
    public static JsonToken EndArray;
    public static JsonToken Number;
    public static JsonToken String;
    public static JsonToken True;
    public static JsonToken False;
    public static JsonToken Null;
    public static JsonToken ValueSeparator;
    public static JsonToken NameSeparator;
}
public class Utf8Json.JsonWriter : ValueType {
    private static Byte[] emptyBytes;
    internal Byte[] buffer;
    internal int offset;
    public int CurrentOffset { get; }
    public JsonWriter(Byte[] initialBuffer);
    private static JsonWriter();
    public int get_CurrentOffset();
    public void AdvanceOffset(int offset);
    public static Byte[] GetEncodedPropertyName(string propertyName);
    public static Byte[] GetEncodedPropertyNameWithPrefixValueSeparator(string propertyName);
    public static Byte[] GetEncodedPropertyNameWithBeginObject(string propertyName);
    public static Byte[] GetEncodedPropertyNameWithoutQuotation(string propertyName);
    public ArraySegment`1<byte> GetBuffer();
    public Byte[] ToUtf8ByteArray();
    public virtual string ToString();
    public void EnsureCapacity(int appendLength);
    public void WriteRaw(byte rawValue);
    public void WriteRaw(Byte[] rawValue);
    public void WriteRawUnsafe(byte rawValue);
    public void WriteBeginArray();
    public void WriteEndArray();
    public void WriteBeginObject();
    public void WriteEndObject();
    public void WriteValueSeparator();
    public void WriteNameSeparator();
    public void WritePropertyName(string propertyName);
    public void WriteQuotation();
    public void WriteNull();
    public void WriteBoolean(bool value);
    public void WriteTrue();
    public void WriteFalse();
    public void WriteSingle(float value);
    public void WriteDouble(double value);
    public void WriteByte(byte value);
    public void WriteUInt16(ushort value);
    public void WriteUInt32(UInt32 value);
    public void WriteUInt64(ulong value);
    public void WriteSByte(sbyte value);
    public void WriteInt16(short value);
    public void WriteInt32(int value);
    public void WriteInt64(long value);
    public void WriteString(string value);
}
public class Utf8Json.Resolvers.AttributeFormatterResolver : object {
    public static IJsonFormatterResolver Instance;
    private static AttributeFormatterResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
public class Utf8Json.Resolvers.BuiltinResolver : object {
    public static IJsonFormatterResolver Instance;
    private static BuiltinResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
public class Utf8Json.Resolvers.CompositeResolver : object {
    public static CompositeResolver Instance;
    private static bool isFreezed;
    private static IJsonFormatter[] formatters;
    private static IJsonFormatterResolver[] resolvers;
    private static CompositeResolver();
    public static void Register(IJsonFormatterResolver[] resolvers);
    public static void Register(IJsonFormatter[] formatters);
    public static void Register(IJsonFormatter[] formatters, IJsonFormatterResolver[] resolvers);
    public static void RegisterAndSetAsDefault(IJsonFormatterResolver[] resolvers);
    public static void RegisterAndSetAsDefault(IJsonFormatter[] formatters);
    public static void RegisterAndSetAsDefault(IJsonFormatter[] formatters, IJsonFormatterResolver[] resolvers);
    public static IJsonFormatterResolver Create(IJsonFormatter[] formatters);
    public static IJsonFormatterResolver Create(IJsonFormatterResolver[] resolvers);
    public static IJsonFormatterResolver Create(IJsonFormatter[] formatters, IJsonFormatterResolver[] resolvers);
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
public abstract class Utf8Json.Resolvers.DynamicCompositeResolver : object {
    private static string ModuleName;
    private static DynamicAssembly assembly;
    public IJsonFormatter[] formatters;
    public IJsonFormatterResolver[] resolvers;
    private static DynamicCompositeResolver();
    public DynamicCompositeResolver(IJsonFormatter[] formatters, IJsonFormatterResolver[] resolvers);
    public static IJsonFormatterResolver Create(IJsonFormatter[] formatters, IJsonFormatterResolver[] resolvers);
    public IJsonFormatter`1<T> GetFormatterLoop();
    public abstract virtual IJsonFormatter`1<T> GetFormatter();
}
public class Utf8Json.Resolvers.DynamicGenericResolver : object {
    public static IJsonFormatterResolver Instance;
    private static DynamicGenericResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
public static class Utf8Json.Resolvers.DynamicObjectResolver : object {
    public static IJsonFormatterResolver Default;
    public static IJsonFormatterResolver CamelCase;
    public static IJsonFormatterResolver SnakeCase;
    public static IJsonFormatterResolver ExcludeNull;
    public static IJsonFormatterResolver ExcludeNullCamelCase;
    public static IJsonFormatterResolver ExcludeNullSnakeCase;
    public static IJsonFormatterResolver AllowPrivate;
    public static IJsonFormatterResolver AllowPrivateCamelCase;
    public static IJsonFormatterResolver AllowPrivateSnakeCase;
    public static IJsonFormatterResolver AllowPrivateExcludeNull;
    public static IJsonFormatterResolver AllowPrivateExcludeNullCamelCase;
    public static IJsonFormatterResolver AllowPrivateExcludeNullSnakeCase;
    private static DynamicObjectResolver();
}
public static class Utf8Json.Resolvers.EnumResolver : object {
    public static IJsonFormatterResolver Default;
    public static IJsonFormatterResolver UnderlyingValue;
    private static EnumResolver();
}
internal class Utf8Json.Resolvers.Internal.AllowPrivateCamelCaseStandardResolver : object {
    public static IJsonFormatterResolver Instance;
    private static IJsonFormatter`1<object> fallbackFormatter;
    private static AllowPrivateCamelCaseStandardResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.AllowPrivateExcludeNullCamelCaseStandardResolver : object {
    public static IJsonFormatterResolver Instance;
    private static IJsonFormatter`1<object> fallbackFormatter;
    private static AllowPrivateExcludeNullCamelCaseStandardResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.AllowPrivateExcludeNullSnakeCaseStandardResolver : object {
    public static IJsonFormatterResolver Instance;
    private static IJsonFormatter`1<object> fallbackFormatter;
    private static AllowPrivateExcludeNullSnakeCaseStandardResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.AllowPrivateExcludeNullStandardResolver : object {
    public static IJsonFormatterResolver Instance;
    private static IJsonFormatter`1<object> fallbackFormatter;
    private static AllowPrivateExcludeNullStandardResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.AllowPrivateSnakeCaseStandardResolver : object {
    public static IJsonFormatterResolver Instance;
    private static IJsonFormatter`1<object> fallbackFormatter;
    private static AllowPrivateSnakeCaseStandardResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.AllowPrivateStandardResolver : object {
    public static IJsonFormatterResolver Instance;
    private static IJsonFormatter`1<object> fallbackFormatter;
    private static AllowPrivateStandardResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.AnonymousJsonDeserializeFunc`1 : MulticastDelegate {
    public AnonymousJsonDeserializeFunc`1(object object, IntPtr method);
    public virtual T Invoke(Object[] customFormatters, JsonReader& reader, IJsonFormatterResolver resolver);
    public virtual IAsyncResult BeginInvoke(Object[] customFormatters, JsonReader& reader, IJsonFormatterResolver resolver, AsyncCallback callback, object object);
    public virtual T EndInvoke(JsonReader& reader, IAsyncResult result);
}
internal class Utf8Json.Resolvers.Internal.AnonymousJsonSerializeAction`1 : MulticastDelegate {
    public AnonymousJsonSerializeAction`1(object object, IntPtr method);
    public virtual void Invoke(Byte[][] stringByteKeysField, Object[] customFormatters, JsonWriter& writer, T value, IJsonFormatterResolver resolver);
    public virtual IAsyncResult BeginInvoke(Byte[][] stringByteKeysField, Object[] customFormatters, JsonWriter& writer, T value, IJsonFormatterResolver resolver, AsyncCallback callback, object object);
    public virtual void EndInvoke(JsonWriter& writer, IAsyncResult result);
}
internal class Utf8Json.Resolvers.Internal.CamelCaseStandardResolver : object {
    public static IJsonFormatterResolver Instance;
    private static IJsonFormatter`1<object> fallbackFormatter;
    private static CamelCaseStandardResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.DefaultStandardResolver : object {
    public static IJsonFormatterResolver Instance;
    private static IJsonFormatter`1<object> fallbackFormatter;
    private static DefaultStandardResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal static class Utf8Json.Resolvers.Internal.DynamicGenericResolverGetFormatterHelper : object {
    private static Dictionary`2<Type, Type> formatterMap;
    private static DynamicGenericResolverGetFormatterHelper();
    internal static object GetFormatter(Type t);
    private static object CreateInstance(Type genericType, Type[] genericTypeArguments, Object[] arguments);
}
internal class Utf8Json.Resolvers.Internal.DynamicMethodAnonymousFormatter`1 : object {
    private Byte[][] stringByteKeysField;
    private Object[] serializeCustomFormatters;
    private Object[] deserializeCustomFormatters;
    private AnonymousJsonSerializeAction`1<T> serialize;
    private AnonymousJsonDeserializeFunc`1<T> deserialize;
    public DynamicMethodAnonymousFormatter`1(Byte[][] stringByteKeysField, Object[] serializeCustomFormatters, Object[] deserializeCustomFormatters, AnonymousJsonSerializeAction`1<T> serialize, AnonymousJsonDeserializeFunc`1<T> deserialize);
    public sealed virtual void Serialize(JsonWriter& writer, T value, IJsonFormatterResolver formatterResolver);
    public sealed virtual T Deserialize(JsonReader& reader, IJsonFormatterResolver formatterResolver);
}
internal class Utf8Json.Resolvers.Internal.DynamicObjectResolverAllowPrivateFalseExcludeNullFalseNameMutateCamelCase : object {
    public static IJsonFormatterResolver Instance;
    private static Func`2<string, string> nameMutator;
    private static bool excludeNull;
    private static string ModuleName;
    private static DynamicAssembly assembly;
    private static DynamicObjectResolverAllowPrivateFalseExcludeNullFalseNameMutateCamelCase();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.DynamicObjectResolverAllowPrivateFalseExcludeNullFalseNameMutateOriginal : object {
    public static IJsonFormatterResolver Instance;
    private static Func`2<string, string> nameMutator;
    private static bool excludeNull;
    private static string ModuleName;
    private static DynamicAssembly assembly;
    private static DynamicObjectResolverAllowPrivateFalseExcludeNullFalseNameMutateOriginal();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.DynamicObjectResolverAllowPrivateFalseExcludeNullFalseNameMutateSnakeCase : object {
    public static IJsonFormatterResolver Instance;
    private static Func`2<string, string> nameMutator;
    private static bool excludeNull;
    private static string ModuleName;
    private static DynamicAssembly assembly;
    private static DynamicObjectResolverAllowPrivateFalseExcludeNullFalseNameMutateSnakeCase();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.DynamicObjectResolverAllowPrivateFalseExcludeNullTrueNameMutateCamelCase : object {
    public static IJsonFormatterResolver Instance;
    private static Func`2<string, string> nameMutator;
    private static bool excludeNull;
    private static string ModuleName;
    private static DynamicAssembly assembly;
    private static DynamicObjectResolverAllowPrivateFalseExcludeNullTrueNameMutateCamelCase();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.DynamicObjectResolverAllowPrivateFalseExcludeNullTrueNameMutateOriginal : object {
    public static IJsonFormatterResolver Instance;
    private static Func`2<string, string> nameMutator;
    private static bool excludeNull;
    private static string ModuleName;
    private static DynamicAssembly assembly;
    private static DynamicObjectResolverAllowPrivateFalseExcludeNullTrueNameMutateOriginal();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.DynamicObjectResolverAllowPrivateFalseExcludeNullTrueNameMutateSnakeCase : object {
    public static IJsonFormatterResolver Instance;
    private static Func`2<string, string> nameMutator;
    private static bool excludeNull;
    private static string ModuleName;
    private static DynamicAssembly assembly;
    private static DynamicObjectResolverAllowPrivateFalseExcludeNullTrueNameMutateSnakeCase();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.DynamicObjectResolverAllowPrivateTrueExcludeNullFalseNameMutateCamelCase : object {
    public static IJsonFormatterResolver Instance;
    private static Func`2<string, string> nameMutator;
    private static bool excludeNull;
    private static DynamicObjectResolverAllowPrivateTrueExcludeNullFalseNameMutateCamelCase();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.DynamicObjectResolverAllowPrivateTrueExcludeNullFalseNameMutateOriginal : object {
    public static IJsonFormatterResolver Instance;
    private static Func`2<string, string> nameMutator;
    private static bool excludeNull;
    private static DynamicObjectResolverAllowPrivateTrueExcludeNullFalseNameMutateOriginal();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.DynamicObjectResolverAllowPrivateTrueExcludeNullFalseNameMutateSnakeCase : object {
    public static IJsonFormatterResolver Instance;
    private static Func`2<string, string> nameMutator;
    private static bool excludeNull;
    private static DynamicObjectResolverAllowPrivateTrueExcludeNullFalseNameMutateSnakeCase();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.DynamicObjectResolverAllowPrivateTrueExcludeNullTrueNameMutateCamelCase : object {
    public static IJsonFormatterResolver Instance;
    private static Func`2<string, string> nameMutator;
    private static bool excludeNull;
    private static DynamicObjectResolverAllowPrivateTrueExcludeNullTrueNameMutateCamelCase();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.DynamicObjectResolverAllowPrivateTrueExcludeNullTrueNameMutateOriginal : object {
    public static IJsonFormatterResolver Instance;
    private static Func`2<string, string> nameMutator;
    private static bool excludeNull;
    private static DynamicObjectResolverAllowPrivateTrueExcludeNullTrueNameMutateOriginal();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.DynamicObjectResolverAllowPrivateTrueExcludeNullTrueNameMutateSnakeCase : object {
    public static IJsonFormatterResolver Instance;
    private static Func`2<string, string> nameMutator;
    private static bool excludeNull;
    private static DynamicObjectResolverAllowPrivateTrueExcludeNullTrueNameMutateSnakeCase();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal static class Utf8Json.Resolvers.Internal.DynamicObjectTypeBuilder : object {
    private static Regex SubtractFullNameRegex;
    private static int nameSequence;
    private static HashSet`1<Type> ignoreTypes;
    private static HashSet`1<Type> jsonPrimitiveTypes;
    private static DynamicObjectTypeBuilder();
    public static object BuildFormatterToAssembly(DynamicAssembly assembly, IJsonFormatterResolver selfResolver, Func`2<string, string> nameMutator, bool excludeNull);
    public static object BuildFormatterToDynamicMethod(IJsonFormatterResolver selfResolver, Func`2<string, string> nameMutator, bool excludeNull, bool allowPrivate);
    private static TypeInfo BuildType(DynamicAssembly assembly, Type type, Func`2<string, string> nameMutator, bool excludeNull);
    public static object BuildAnonymousFormatter(Type type, Func`2<string, string> nameMutator, bool excludeNull, bool allowPrivate, bool isException);
    private static Dictionary`2<MetaMember, FieldInfo> BuildConstructor(TypeBuilder builder, MetaType info, ConstructorInfo method, FieldBuilder stringByteKeysField, ILGenerator il, bool excludeNull, bool hasShouldSerialize);
    private static Dictionary`2<MetaMember, FieldInfo> BuildCustomFormatterField(TypeBuilder builder, MetaType info, ILGenerator il);
    private static void BuildSerialize(Type type, MetaType info, ILGenerator il, Action emitStringByteKeys, Func`3<int, MetaMember, bool> tryEmitLoadCustomFormatter, bool excludeNull, bool hasShouldSerialize, int firstArgIndex);
    private static void EmitSerializeValue(TypeInfo type, MetaMember member, ILGenerator il, int index, Func`3<int, MetaMember, bool> tryEmitLoadCustomFormatter, ArgumentField writer, ArgumentField argValue, ArgumentField argResolver);
    private static void BuildDeserialize(Type type, MetaType info, ILGenerator il, Func`3<int, MetaMember, bool> tryEmitLoadCustomFormatter, bool useGetUninitializedObject, int firstArgIndex);
    private static void EmitDeserializeValue(ILGenerator il, DeserializeInfo info, int index, Func`3<int, MetaMember, bool> tryEmitLoadCustomFormatter, ArgumentField reader, ArgumentField argResolver);
    private static LocalBuilder EmitNewObject(ILGenerator il, Type type, MetaType info, DeserializeInfo[] members, bool isSideEffectFreeType);
    private static bool IsSideEffectFreeConstructorType(ConstructorInfo ctorInfo);
    private static bool TryGetInterfaceEnumerableElementType(Type type, Type& elementType);
}
internal class Utf8Json.Resolvers.Internal.EnumDefaultResolver : object {
    public static IJsonFormatterResolver Instance;
    private static EnumDefaultResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.EnumUnderlyingValueResolver : object {
    public static IJsonFormatterResolver Instance;
    private static EnumUnderlyingValueResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.ExcludeNullCamelCaseStandardResolver : object {
    public static IJsonFormatterResolver Instance;
    private static IJsonFormatter`1<object> fallbackFormatter;
    private static ExcludeNullCamelCaseStandardResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.ExcludeNullSnakeCaseStandardResolver : object {
    public static IJsonFormatterResolver Instance;
    private static IJsonFormatter`1<object> fallbackFormatter;
    private static ExcludeNullSnakeCaseStandardResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.ExcludeNullStandardResolver : object {
    public static IJsonFormatterResolver Instance;
    private static IJsonFormatter`1<object> fallbackFormatter;
    private static ExcludeNullStandardResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal class Utf8Json.Resolvers.Internal.SnakeCaseStandardResolver : object {
    public static IJsonFormatterResolver Instance;
    private static IJsonFormatter`1<object> fallbackFormatter;
    private static SnakeCaseStandardResolver();
    public sealed virtual IJsonFormatter`1<T> GetFormatter();
}
internal static class Utf8Json.Resolvers.Internal.StandardResolverHelper : object {
    internal static IJsonFormatterResolver[] CompositeResolverBase;
    private static StandardResolverHelper();
}
public static class Utf8Json.Resolvers.StandardResolver : object {
    public static IJsonFormatterResolver Default;
    public static IJsonFormatterResolver CamelCase;
    public static IJsonFormatterResolver SnakeCase;
    public static IJsonFormatterResolver ExcludeNull;
    public static IJsonFormatterResolver ExcludeNullCamelCase;
    public static IJsonFormatterResolver ExcludeNullSnakeCase;
    public static IJsonFormatterResolver AllowPrivate;
    public static IJsonFormatterResolver AllowPrivateCamelCase;
    public static IJsonFormatterResolver AllowPrivateSnakeCase;
    public static IJsonFormatterResolver AllowPrivateExcludeNull;
    public static IJsonFormatterResolver AllowPrivateExcludeNullCamelCase;
    public static IJsonFormatterResolver AllowPrivateExcludeNullSnakeCase;
    private static StandardResolver();
}
[AttributeUsageAttribute("32")]
public class Utf8Json.SerializationConstructorAttribute : Attribute {
}
