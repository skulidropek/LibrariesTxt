[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class AggregateExceptionConverter : WriteOnlyJsonConverter`1<AggregateException> {
    public virtual void Write(VerifyJsonWriter writer, AggregateException exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class ApplyScrubbers : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static List`1<KeyValuePair`2<string, string>> replacements;
    private static ApplyScrubbers();
    [ExtensionAttribute]
private static string ReplaceAltDirChar(string directory);
    public static void UseAssembly(string solutionDir, string projectDir);
    private static void AddProjectAndSolutionReplacements(string solutionDir, string projectDir, Dictionary`2<string, string> replacements);
    public static void ApplyForExtension(string extension, StringBuilder target, VerifySettings settings, Counter counter);
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<char> ApplyForPropertyValue(ReadOnlySpan`1<char> value, VerifySettings settings, Counter counter);
    private static string CleanPath(string directory);
}
internal class CancelConverter : WriteOnlyJsonConverter`1<CancellationToken> {
    [NullableContextAttribute("1")]
public virtual void Write(VerifyJsonWriter writer, CancellationToken value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class ClaimConverter : WriteOnlyJsonConverter`1<Claim> {
    public virtual void Write(VerifyJsonWriter writer, Claim claim);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class ClaimsIdentityConverter : WriteOnlyJsonConverter`1<ClaimsIdentity> {
    public virtual void Write(VerifyJsonWriter writer, ClaimsIdentity identity);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class ClaimsPrincipalConverter : WriteOnlyJsonConverter`1<ClaimsPrincipal> {
    public virtual void Write(VerifyJsonWriter writer, ClaimsPrincipal principal);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Comparer : object {
    [AsyncStateMachineAttribute("Comparer/<Text>d__0")]
public static Task`1<EqualityResult> Text(FilePair filePair, StringBuilder received, VerifySettings settings);
    private static Task`1<CompareResult> CompareStrings(string extension, StringBuilder received, StringBuilder verified, VerifySettings settings);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class ConstructorInfoConverter : WriteOnlyJsonConverter`1<ConstructorInfo> {
    public virtual void Write(VerifyJsonWriter writer, ConstructorInfo value);
}
[IsReadOnlyAttribute]
internal class CultureDate : ValueType {
    [CompilerGeneratedAttribute]
private DateTime <Long>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Short>k__BackingField;
    public DateTime Long { get; }
    public DateTime Short { get; }
    public CultureDate(DateTime longDate, DateTime shortDate);
    [CompilerGeneratedAttribute]
public DateTime get_Long();
    [CompilerGeneratedAttribute]
public DateTime get_Short();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class CustomContractResolver : DefaultContractResolver {
    [CompilerGeneratedAttribute]
private SerializationSettings <settings>P;
    private static FieldInfo exceptionMessageField;
    public CustomContractResolver(SerializationSettings settings);
    private static CustomContractResolver();
    protected virtual JsonDictionaryContract CreateDictionaryContract(Type objectType);
    private static InterceptResult ToInterceptResult(ScrubOrIgnore scrubOrIgnore);
    private string ResolveDictionaryKey(JsonDictionaryContract contract, string name, object original);
    protected virtual IList`1<JsonProperty> CreateProperties(Type type, MemberSerialization memberSerialization);
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization serialization);
    protected virtual JsonArrayContract CreateArrayContract(Type objectType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class CustomValueProvider : object {
    [CompilerGeneratedAttribute]
private IValueProvider <inner>P;
    [CompilerGeneratedAttribute]
private Type <type>P;
    [CompilerGeneratedAttribute]
private Func`2<Exception, bool> <ignoreException>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ConvertTargetMember <converter>P;
    [CompilerGeneratedAttribute]
private SerializationSettings <settings>P;
    public CustomValueProvider(IValueProvider inner, Type type, Func`2<Exception, bool> ignoreException, ConvertTargetMember converter, SerializationSettings settings);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
    [NullableContextAttribute("2")]
private object GetDefault();
}
internal class DateConverter : WriteOnlyJsonConverter`1<DateOnly> {
    [NullableContextAttribute("1")]
public virtual void Write(VerifyJsonWriter writer, DateOnly value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class DateFormatter : object {
    public static string ToJsonString(DateTimeOffset value);
    private static string GetJsonDatePart(DateTimeOffset value);
    public static string ToParameterString(DateTimeOffset value);
    private static string GetParameterDatePart(DateTimeOffset value);
    public static string ToJsonString(DateTime value);
    private static string GetJsonDatePart(DateTime value);
    public static string ToParameterString(DateTime value);
    private static string GetParameterDatePart(DateTime value);
    private static string GetDateOffset(DateTimeOffset value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class DateScrubber : object {
    [NullableAttribute("0")]
private static IReadOnlyDictionary`2<string, CultureDate> cultureDates;
    private static DateScrubber();
    private static bool TryConvertDate(ReadOnlySpan`1<char> span, string format, Counter counter, CultureInfo culture, String& result);
    public static Action`2<StringBuilder, Counter> BuildDateScrubber(string format, CultureInfo culture);
    public static void ReplaceDates(StringBuilder builder, string format, Counter counter, CultureInfo culture);
    public static Action`2<StringBuilder, Counter> BuildDateTimeOffsetScrubber(string format, CultureInfo culture);
    private static bool TryConvertDateTimeOffset(ReadOnlySpan`1<char> span, string format, Counter counter, CultureInfo culture, String& result);
    public static void ReplaceDateTimeOffsets(StringBuilder builder, string format, Counter counter, CultureInfo culture);
    private static bool TryConvertDateTime(ReadOnlySpan`1<char> span, string format, Counter counter, CultureInfo culture, String& result);
    public static Action`2<StringBuilder, Counter> BuildDateTimeScrubber(string format, CultureInfo culture);
    public static void ReplaceDateTimes(StringBuilder builder, string format, Counter counter, CultureInfo culture);
    private static void ReplaceInner(StringBuilder builder, string format, Counter counter, CultureInfo culture, Func`2<DateTime, IFormattable> toDate, TryConvert tryConvertDate);
    internal static CultureDate GetCultureDates(CultureInfo culture);
    [CompilerGeneratedAttribute]
internal static int <ReplaceInner>g__Length|10_0(DateTime dateTime, <>c__DisplayClass10_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class DelegateConverter : WriteOnlyJsonConverter`1<Delegate> {
    public virtual void Write(VerifyJsonWriter writer, Delegate delegate);
    private static string CleanMethodName(string name);
}
internal enum Equality : Enum {
    public int value__;
    public static Equality Equal;
    public static Equality NotEqual;
    public static Equality New;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class EqualityResult : ValueType {
    [CompilerGeneratedAttribute]
private Equality <Equality>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilder <ReceivedText>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilder <VerifiedText>k__BackingField;
    public Equality Equality { get; }
    public string Message { get; }
    public StringBuilder ReceivedText { get; }
    public StringBuilder VerifiedText { get; }
    public EqualityResult(Equality equality, string message, StringBuilder receivedText, StringBuilder verifiedText);
    [CompilerGeneratedAttribute]
public Equality get_Equality();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public StringBuilder get_ReceivedText();
    [CompilerGeneratedAttribute]
public StringBuilder get_VerifiedText();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class ExpressionConverter : WriteOnlyJsonConverter`1<Expression> {
    public virtual void Write(VerifyJsonWriter writer, Expression value);
}
[ExtensionAttribute]
internal static class ExpressionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static MemberInfo FindMember(Expression`1<Func`2<T, TMember>> expression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Extensions : object {
    [ExtensionAttribute]
public static string Extension(FileStream file);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static bool ContainsNewline(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static Version MajorMinor(Version version);
    [AsyncStateMachineAttribute("Extensions/<ToList>d__3`1")]
[ExtensionAttribute]
public static Task`1<List`1<T>> ToList(IAsyncEnumerable`1<T> target);
    [ExtensionAttribute]
public static Task SafeCopy(Stream source, Stream target);
    [ExtensionAttribute]
public static bool CanSeekAndReadLength(Stream stream);
    [ExtensionAttribute]
private static bool CanReadLength(Stream stream);
    [ExtensionAttribute]
public static string TrimPreamble(string text);
    [ExtensionAttribute]
public static void Enqueue(Queue`1<T> queue, IEnumerable`1<T> items);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(StringBuilder builder);
    [ExtensionAttribute]
public static List`1<T> Clone(List`1<T> original);
    [ExtensionAttribute]
public static IReadOnlyList`1<string> ParameterNames(MethodInfo method);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Dictionary`2<TKey, TValue> Clone(Dictionary`2<TKey, TValue> original);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Dictionary`2<TKey, Nullable`1<TValue>> Clone(Dictionary`2<TKey, Nullable`1<TValue>> original);
    [ExtensionAttribute]
public static string NameWithParent(Type type);
    [ExtensionAttribute]
public static string Configuration(Assembly assembly);
    [ExtensionAttribute]
public static Nullable`1<char> FirstChar(StringBuilder builder);
    [ExtensionAttribute]
public static Nullable`1<char> LastChar(StringBuilder builder);
    [ExtensionAttribute]
public static void FilterLines(StringBuilder input, Func`2<string, bool> removeLine);
    [ExtensionAttribute]
public static void RemoveEmptyLines(StringBuilder builder);
    [ExtensionAttribute]
public static string Remove(string value, string toRemove);
    [ExtensionAttribute]
public static TValue GetOrAdd(Dictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> factory);
    [ExtensionAttribute]
public static void ReplaceIfLonger(StringBuilder builder, string oldValue, string newValue);
    [ExtensionAttribute]
public static void Overwrite(StringBuilder builder, string value, int index, int length);
    [ExtensionAttribute]
public static int Count(StringBuilder builder, char ch);
    [ExtensionAttribute]
public static bool IsException(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class FieldInfoConverter : WriteOnlyJsonConverter`1<FieldInfo> {
    public virtual void Write(VerifyJsonWriter writer, FieldInfo value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class FileComparer : object {
    [AsyncStateMachineAttribute("FileComparer/<DoCompare>d__0")]
public static Task`1<EqualityResult> DoCompare(VerifySettings settings, FilePair file, bool previousTextFailed, Stream receivedStream);
    [AsyncStateMachineAttribute("FileComparer/<InnerCompare>d__1")]
private static Task`1<EqualityResult> InnerCompare(FilePair file, Stream receivedStream, Func`3<Stream, Stream, Task`1<CompareResult>> func);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class FileNameBuilder : object {
    [ExtensionAttribute]
public static FrameworkNameVersion FrameworkName(Assembly assembly);
    public static string GetTypeAndMethod(string method, string type, VerifySettings settings, PathInfo pathInfo);
    public static ValueTuple`2<string, string> GetParameterText(IReadOnlyList`1<string> methodParameters, VerifySettings settings);
    private static IEnumerable`1<KeyValuePair`2<string, object>> GetVerifiedValues(HashSet`1<string> ignored, KeyValuePair`2[] allValues);
    private static string BuildParameterString(IEnumerable`1<KeyValuePair`2<string, object>> values, bool hashParameters);
    private static string HashString(string value);
}
internal static class FileNameCleaner : object {
    [NullableAttribute("1")]
private static Char[] invalidFileNameChars;
    private static FileNameCleaner();
    private static int IndexOfInvalidChar(ReadOnlySpan`1<char> span);
    private static bool IsInvalid(char ch);
    [NullableContextAttribute("1")]
public static void AppendValid(StringBuilder builder, string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class FrameworkNameVersion : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NameAndVersion>k__BackingField;
    public string Name { get; }
    public string NameAndVersion { get; }
    public FrameworkNameVersion(string name, string nameAndVersion);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_NameAndVersion();
}
internal class GetFileNames : MulticastDelegate {
    public GetFileNames(object object, IntPtr method);
    public virtual FilePair Invoke(Target target);
    public virtual IAsyncResult BeginInvoke(Target target, AsyncCallback callback, object object);
    public virtual FilePair EndInvoke(IAsyncResult result);
}
internal class GetIndexedFileNames : MulticastDelegate {
    public GetIndexedFileNames(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual FilePair Invoke(Target target, string index);
    public virtual IAsyncResult BeginInvoke(Target target, string index, AsyncCallback callback, object object);
    public virtual FilePair EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Guards : object {
    private static Char[] invalidFileChars;
    private static Char[] invalidPathChars;
    private static Guards();
    public static void BadFileNameNullable(string name, string argumentName);
    public static void BadFileName(string name, string argumentName);
    public static void BadDirectoryName(string name, string argumentName);
    public static void AgainstNullable(Type type, string argumentName);
    public static void AgainstBadSourceFile(string sourceFile);
    public static void AgainstBadExtension(string value, string argumentName);
}
internal static class GuidScrubber : object {
    [NullableContextAttribute("1")]
public static void ReplaceGuids(StringBuilder builder, Counter counter);
    private static bool TryParse(ReadOnlySpan`1<char> slice, Guid& guid);
    private static bool IsInvalidEndingChar(char ch);
    private static bool IsInvalidChar(char ch);
    private static bool IsInvalidStartingChar(char ch);
}
[NullableContextAttribute("1")]
internal interface IEnvironment {
    public string CurrentDirectory { get; }
    public char DirectorySeparatorChar { get; }
    public abstract virtual string get_CurrentDirectory();
    public abstract virtual char get_DirectorySeparatorChar();
    public abstract virtual bool PathExists(string path);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class InfoBuilder : object {
    [NullableAttribute("2")]
private object root;
    private List`1<Item> inner;
    public InfoBuilder(object root, List`1<ToAppend> appends);
    private void Add(string name, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class IoHelpers : object {
    [CompilerGeneratedAttribute]
private static char <DirectorySeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private static char <AltDirectorySeparator>k__BackingField;
    private static Char[] Separators;
    [NullableAttribute("2")]
private static VirtualizedRunHelper virtualizedRunHelper;
    private static ConcurrentDictionary`2<Assembly, VirtualizedRunHelper> virtualizedRunHelpers;
    public static char DirectorySeparator { get; }
    public static char AltDirectorySeparator { get; }
    private static IoHelpers();
    [CompilerGeneratedAttribute]
public static char get_DirectorySeparator();
    [CompilerGeneratedAttribute]
public static char get_AltDirectorySeparator();
    public static void DeleteDirectory(string path);
    public static void DeleteFileIfEmpty(string path);
    public static void DeleteFiles(string directory, string pattern);
    public static IEnumerable`1<string> Files(string directory, string pattern);
    public static void DeleteFiles(IEnumerable`1<string> files);
    public static void DeleteFile(string file);
    [ConditionalAttribute("DEBUG")]
public static void ValidateOsPathSeparators(string path, string argumentName);
    public static void CreateDirectory(string directory);
    [ExtensionAttribute]
public static void MoveToStart(Stream stream);
    [ExtensionAttribute]
public static void ThrowIfEmpty(Stream stream);
    [AsyncStateMachineAttribute("IoHelpers/<DisposeAsyncEx>d__18")]
[ExtensionAttribute]
public static Task DisposeAsyncEx(Stream stream);
    private static FileStream OpenWrite(string path);
    public static FileStream OpenRead(string path);
    public static long Length(string file);
    [AsyncStateMachineAttribute("IoHelpers/<ReadStringBuilderWithFixedLines>d__22")]
[ExtensionAttribute]
public static Task`1<StringBuilder> ReadStringBuilderWithFixedLines(Stream stream);
    [AsyncStateMachineAttribute("IoHelpers/<ReadStringBuilderWithFixedLines>d__23")]
internal static Task`1<StringBuilder> ReadStringBuilderWithFixedLines(TextReader reader);
    internal static void WriteText(string path, StringBuilder text);
    public static string GetRelativePath(string directory, string file);
    internal static void MapPathsForCallingAssembly(Assembly assembly);
    internal static string GetMappedBuildPath(string path);
    internal static string GetMappedBuildPath(string path, Assembly assembly);
    private static VirtualizedRunHelper GetForAssembly(Assembly assembly);
    internal static string ResolveDirectoryFromSourceFile(string sourceFile);
    [AsyncStateMachineAttribute("IoHelpers/<ReadStringBuilderWithFixedLines>d__33")]
public static Task`1<StringBuilder> ReadStringBuilderWithFixedLines(string path);
    [AsyncStateMachineAttribute("IoHelpers/<WriteStream>d__34")]
public static Task WriteStream(string path, Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class JArrayConverter : WriteOnlyJsonConverter`1<JArray> {
    public virtual void Write(VerifyJsonWriter writer, JArray value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class JObjectConverter : WriteOnlyJsonConverter`1<JObject> {
    public virtual void Write(VerifyJsonWriter writer, JObject value);
}
internal static class JsonFormatter : object {
    [NullableContextAttribute("1")]
public static StringBuilder AsJson(VerifySettings settings, Counter counter, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class KeyValuePairConverter : WriteOnlyJsonConverter {
    public virtual bool CanConvert(Type type);
    public virtual void Write(VerifyJsonWriter writer, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class LinesScrubber : object {
    [ExtensionAttribute]
public static void RemoveLinesContaining(StringBuilder input, StringComparison comparison, String[] stringToMatch);
    [ExtensionAttribute]
public static void ReplaceLines(StringBuilder input, Func`2<string, string> replaceLine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class MatchingFileFinder : object {
    public static void DeleteReceived(string fileNamePrefix, string directory);
    public static IEnumerable`1<string> FindVerified(string fileNamePrefix, string directory);
    private static IEnumerable`1<string> Find(string directory, string searchPattern, string nonIndexedPattern, string indexedPattern);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
private static bool SubStringEquals(ReadOnlySpan`1<char> value, ReadOnlySpan`1<char> match, int start);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class MethodInfoConverter : WriteOnlyJsonConverter`1<MethodInfo> {
    public virtual void Write(VerifyJsonWriter writer, MethodInfo value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class NameValueCollectionConverter : WriteOnlyJsonConverter`1<NameValueCollection> {
    public virtual void Write(VerifyJsonWriter writer, NameValueCollection collection);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class NewResult : ValueType {
    [CompilerGeneratedAttribute]
private FilePair <File>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilder <ReceivedText>k__BackingField;
    public FilePair File { get; }
    public StringBuilder ReceivedText { get; }
    public NewResult(FilePair file, StringBuilder receivedText);
    [CompilerGeneratedAttribute]
public FilePair get_File();
    [CompilerGeneratedAttribute]
public StringBuilder get_ReceivedText();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class NotEqualResult : ValueType {
    [CompilerGeneratedAttribute]
private FilePair <File>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilder <ReceivedText>k__BackingField;
    [CompilerGeneratedAttribute]
private StringBuilder <VerifiedText>k__BackingField;
    public FilePair File { get; }
    public string Message { get; }
    public StringBuilder ReceivedText { get; }
    public StringBuilder VerifiedText { get; }
    public NotEqualResult(FilePair file, string message, StringBuilder receivedText, StringBuilder verifiedText);
    [CompilerGeneratedAttribute]
public FilePair get_File();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public StringBuilder get_ReceivedText();
    [CompilerGeneratedAttribute]
public StringBuilder get_VerifiedText();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class ParameterInfoConverter : WriteOnlyJsonConverter`1<ParameterInfo> {
    public virtual void Write(VerifyJsonWriter writer, ParameterInfo value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class PhysicalEnvironment : object {
    public static IEnvironment Instance;
    public string CurrentDirectory { get; }
    public char DirectorySeparatorChar { get; }
    private static PhysicalEnvironment();
    public sealed virtual string get_CurrentDirectory();
    public sealed virtual char get_DirectorySeparatorChar();
    public sealed virtual bool PathExists(string path);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class Polyfills.BytePolyfill : object {
    [NullableContextAttribute("2")]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.byte.tryparse#system-byte-tryparse(system-string-system-iformatprovider-system-byte@)")]
public static bool TryParse(string target, IFormatProvider provider, Byte& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.byte.tryparse#system-byte-tryparse(system-readonlyspan((system-byte))-system-iformatprovider-system-byte@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, IFormatProvider provider, Byte& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.byte.tryparse#system-byte-tryparse(system-readonlyspan((system-char))-system-byte@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, Byte& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.byte.tryparse#system-byte-tryparse(system-readonlyspan((system-char))-system-iformatprovider-system-byte@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, IFormatProvider provider, Byte& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.byte.tryparse#system-byte-tryparse(system-readonlyspan((system-byte))-system-globalization-numberstyles-system-iformatprovider-system-byte@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, NumberStyles style, IFormatProvider provider, Byte& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.byte.tryparse#system-byte-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-byte@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, Byte& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.byte.tryparse#system-byte-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-byte@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, NumberStyles style, IFormatProvider provider, Byte& result);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class Polyfills.DoublePolyfill : object {
    [NullableContextAttribute("2")]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.double.tryparse#system-double-tryparse(system-string-system-iformatprovider-system-double@)")]
public static bool TryParse(string target, IFormatProvider provider, Double& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.double.tryparse#system-double-tryparse(system-readonlyspan((system-byte))-system-iformatprovider-system-double@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, IFormatProvider provider, Double& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.double.tryparse#system-double-tryparse(system-readonlyspan((system-char))-system-double@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, Double& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.double.tryparse#system-double-tryparse(system-readonlyspan((system-char))-system-iformatprovider-system-double@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, IFormatProvider provider, Double& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.double.tryparse#system-double-tryparse(system-readonlyspan((system-byte))-system-globalization-numberstyles-system-iformatprovider-system-double@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, NumberStyles style, IFormatProvider provider, Double& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.double.tryparse#system-double-tryparse(system-readonlyspan((system-byte))-system-double@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, Double& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.double.tryparse#system-double-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-double@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, NumberStyles style, IFormatProvider provider, Double& result);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class Polyfills.EnumPolyfill : object {
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.enum.getvalues")]
public static TEnum[] GetValues();
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.enum.isdefined#system-enum-isdefined-1(-0)")]
public static bool IsDefined(TEnum value);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.enum.getnames")]
public static String[] GetNames();
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.enum.parse#system-enum-parse-1(system-string-system-boolean)")]
public static TEnum Parse(string value);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.enum.parse#system-enum-parse-1(system-string-system-boolean)")]
public static TEnum Parse(string value, bool ignoreCase);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.enum.parse#system-enum-parse-1(system-readonlyspan((system-char)))")]
public static TEnum Parse(ReadOnlySpan`1<char> value);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.enum.parse#system-enum-parse-1(system-readonlyspan((system-char))-system-boolean)")]
public static TEnum Parse(ReadOnlySpan`1<char> value, bool ignoreCase);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.enum.tryparse#system-enum-tryparse-1(system-readonlyspan((system-char))-0@)")]
public static bool TryParse(ReadOnlySpan`1<char> value, TEnum& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.enum.tryparse#system-enum-tryparse-1(system-readonlyspan((system-char))-system-boolean-0@)")]
public static bool TryParse(ReadOnlySpan`1<char> value, bool ignoreCase, TEnum& result);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[StackTraceHiddenAttribute]
internal static class Polyfills.Guard : object {
    public static void FileExists(string path, string argumentName);
    public static void DirectoryExists(string path, string argumentName);
    public static void NotEmpty(string value, string argumentName);
    public static void NotEmpty(ReadOnlySpan`1<T> value, string argumentName);
    public static void NotEmpty(Span`1<T> value, string argumentName);
    public static void NotEmpty(Nullable`1<Memory`1<T>> value, string argumentName);
    public static void NotEmpty(Memory`1<T> value, string argumentName);
    public static void NotEmpty(Nullable`1<ReadOnlyMemory`1<T>> value, string argumentName);
    public static void NotEmpty(ReadOnlyMemory`1<T> value, string argumentName);
    public static void NotEmpty(T value, string argumentName);
    public static T NotNull(T argument, string name);
    [NullableContextAttribute("2")]
public static string NotNull(string argument, string name);
    public static string NotNullOrEmpty(string value, string argumentName);
    public static T NotNullOrEmpty(T value, string argumentName);
    public static Memory`1<char> NotNullOrEmpty(Nullable`1<Memory`1<char>> value, string argumentName);
    public static ReadOnlyMemory`1<char> NotNullOrEmpty(Nullable`1<ReadOnlyMemory`1<char>> value, string argumentName);
    public static string NotNullOrWhiteSpace(string value, string argumentName);
    public static Memory`1<char> NotNullOrWhiteSpace(Nullable`1<Memory`1<char>> value, string argumentName);
    public static ReadOnlyMemory`1<char> NotNullOrWhiteSpace(Nullable`1<ReadOnlyMemory`1<char>> value, string argumentName);
    public static void NotWhiteSpace(string value, string argumentName);
    public static void NotWhiteSpace(ReadOnlySpan`1<char> value, string argumentName);
    public static void NotWhiteSpace(Nullable`1<Memory`1<char>> value, string argumentName);
    public static void NotWhiteSpace(Nullable`1<ReadOnlyMemory`1<char>> value, string argumentName);
    public static void NotWhiteSpace(Span`1<char> value, string argumentName);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class Polyfills.GuidPolyfill : object {
    [NullableContextAttribute("2")]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.guid.tryparse#system-guid-tryparse(system-string-system-iformatprovider-system-guid@)")]
public static bool TryParse(string target, IFormatProvider provider, Guid& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.byte.tryparse#system-byte-tryparse(system-readonlyspan((system-byte))-system-iformatprovider-system-byte@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, IFormatProvider provider, Byte& result);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class Polyfills.IntPolyfill : object {
    [NullableContextAttribute("2")]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int32.tryparse#system-int32-tryparse(system-string-system-iformatprovider-system-int32@)")]
public static bool TryParse(string target, IFormatProvider provider, Int32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int32.tryparse#system-int32-tryparse(system-readonlyspan((system-byte))-system-iformatprovider-system-int32@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, IFormatProvider provider, Int32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int32.tryparse#system-int32-tryparse(system-readonlyspan((system-char))-system-int32@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, Int32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int32.tryparse#system-int32-tryparse(system-readonlyspan((system-char))-system-iformatprovider-system-int32@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, IFormatProvider provider, Int32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int32.tryparse#system-int32-tryparse(system-readonlyspan((system-byte))-system-globalization-numberstyles-system-iformatprovider-system-int32@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, NumberStyles style, IFormatProvider provider, Int32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int32.tryparse#system-int32-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-int32@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, Int32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int32.tryparse#system-int32-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-int32@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, NumberStyles style, IFormatProvider provider, Int32& result);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class Polyfills.LongPolyfill : object {
    [NullableContextAttribute("2")]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int64.tryparse#system-int64-tryparse(system-string-system-iformatprovider-system-int64@)")]
public static bool TryParse(string target, IFormatProvider provider, Int32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int64.tryparse#system-int64-tryparse(system-readonlyspan((system-byte))-system-iformatprovider-system-int64@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, IFormatProvider provider, Int32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int64.tryparse#system-int64-tryparse(system-readonlyspan((system-char))-system-int64@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, Int32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int64.tryparse#system-int64-tryparse(system-readonlyspan((system-char))-system-iformatprovider-system-int64@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, IFormatProvider provider, Int32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int64.tryparse#system-int64-tryparse(system-readonlyspan((system-byte))-system-globalization-numberstyles-system-iformatprovider-system-int64@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, NumberStyles style, IFormatProvider provider, Int32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int64.tryparse#system-int64-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-int64@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, Int32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int64.tryparse#system-int64-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-int64@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, NumberStyles style, IFormatProvider provider, Int32& result);
}
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class Polyfills.Polyfill : object {
    private static long TicksPerMicrosecond;
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.threading.cancellationtokensource.cancelasync")]
public static Task CancelAsync(CancellationTokenSource target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.collectionextensions.asreadonly#system-collections-generic-collectionextensions-asreadonly-2(system-collections-generic-idictionary((-0-1)))")]
public static ReadOnlyDictionary`2<TKey, TValue> AsReadOnly(IDictionary`2<TKey, TValue> target);
    [IteratorStateMachineAttribute("Polyfills.Polyfill/<Index>d__2`1")]
[ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.index#system-linq-enumerable-index-1(system-collections-generic-ienumerable((-0)))")]
public static IEnumerable`1<ValueTuple`2<int, TSource>> Index(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.aggregateby#system-linq-enumerable-aggregateby-3(system-collections-generic-ienumerable((-0))-system-func((-0-1))-system-func((-1-2))-system-func((-2-0-2))-system-collections-generic-iequalitycomparer((-1)))")]
public static IEnumerable`1<KeyValuePair`2<TKey, TAccumulate>> AggregateBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.aggregateby#system-linq-enumerable-aggregateby-3(system-collections-generic-ienumerable((-0))-system-func((-0-1))-2-system-func((-2-0-2))-system-collections-generic-iequalitycomparer((-1)))")]
public static IEnumerable`1<KeyValuePair`2<TKey, TAccumulate>> AggregateBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TKey, TAccumulate> seedSelector, Func`3<TAccumulate, TSource, TAccumulate> func, IEqualityComparer`1<TKey> keyComparer);
    [IteratorStateMachineAttribute("Polyfills.Polyfill/<AggregateByIterator>d__5`3")]
private static IEnumerable`1<KeyValuePair`2<TKey, TAccumulate>> AggregateByIterator(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, IEqualityComparer`1<TKey> keyComparer);
    [IteratorStateMachineAttribute("Polyfills.Polyfill/<AggregateByIterator>d__6`3")]
private static IEnumerable`1<KeyValuePair`2<TKey, TAccumulate>> AggregateByIterator(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TKey, TAccumulate> seedSelector, Func`3<TAccumulate, TSource, TAccumulate> func, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.countby")]
public static IEnumerable`1<KeyValuePair`2<TKey, int>> CountBy(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> keyComparer);
    [IteratorStateMachineAttribute("Polyfills.Polyfill/<CountByIterator>d__8`2")]
private static IEnumerable`1<KeyValuePair`2<TKey, int>> CountByIterator(IEnumerable`1<TSource> source, Func`2<TSource, TKey> selector, IEqualityComparer`1<TKey> comparer);
    private static Dictionary`2<TKey, int> BuildCountDictionary(IEnumerator`1<TSource> enumerator, Func`2<TSource, TKey> selector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.except#system-linq-enumerable-except-1(system-collections-generic-ienumerable((-0))-system-collections-generic-ienumerable((-0)))")]
public static IEnumerable`1<TSource> Except(IEnumerable`1<TSource> target, TSource item);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.except#system-linq-enumerable-except-1(system-collections-generic-ienumerable((-0))-system-collections-generic-ienumerable((-0)))")]
public static IEnumerable`1<TSource> Except(IEnumerable`1<TSource> target, TSource[] items);
    [IteratorStateMachineAttribute("Polyfills.Polyfill/<Except>d__12`1")]
[ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.except#system-linq-enumerable-except-1(system-collections-generic-ienumerable((-0))-system-collections-generic-ienumerable((-0))-system-collections-generic-iequalitycomparer((-0)))")]
public static IEnumerable`1<TSource> Except(IEnumerable`1<TSource> target, TSource item, IEqualityComparer`1<TSource> comparer);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.linq.enumerable.except#system-linq-enumerable-except-1(system-collections-generic-ienumerable((-0))-system-collections-generic-ienumerable((-0))-system-collections-generic-iequalitycomparer((-0)))")]
public static IEnumerable`1<TSource> Except(IEnumerable`1<TSource> target, IEqualityComparer`1<TSource> comparer, TSource[] items);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.collectionextensions.asreadonly#system-collections-generic-collectionextensions-asreadonly-1(system-collections-generic-ilist((-0)))")]
public static ReadOnlyCollection`1<T> AsReadOnly(IList`1<T> target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.collectionextensions.addrange")]
public static void AddRange(List`1<T> target, ReadOnlySpan`1<T> source);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.collectionextensions.insertrange")]
public static void InsertRange(List`1<T> target, int index, ReadOnlySpan`1<T> source);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.collectionextensions.copyto")]
public static void CopyTo(List`1<T> target, Span`1<T> destination);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.split#system-memoryextensions-split-1(system-readonlyspan((-0))-0)")]
public static SpanSplitEnumerator`1<T> Split(ReadOnlySpan`1<T> source, T separator);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.split#system-memoryextensions-split-1(system-readonlyspan((-0))-system-readonlyspan((-0)))")]
public static SpanSplitEnumerator`1<T> Split(ReadOnlySpan`1<T> source, ReadOnlySpan`1<T> separator);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.memoryextensions.splitany#system-memoryextensions-splitany-1(system-readonlyspan((-0))-system-readonlyspan((-0)))")]
public static SpanSplitEnumerator`1<T> SplitAny(ReadOnlySpan`1<T> source, ReadOnlySpan`1<T> separators);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.timespan.nanoseconds")]
public static int Nanoseconds(TimeSpan target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.datetime.nanosecond")]
public static int Nanosecond(DateTime target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.datetimeoffset.nanosecond")]
public static int Nanosecond(DateTimeOffset target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.timespan.microseconds")]
public static int Microseconds(TimeSpan target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.datetime.microsecond")]
public static int Microsecond(DateTime target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.datetimeoffset.microsecond")]
public static int Microsecond(DateTimeOffset target);
    [ExtensionAttribute]
private static long TicksComponent(TimeSpan target);
    [ExtensionAttribute]
private static long TicksComponent(DateTime target);
    [ExtensionAttribute]
private static long TicksComponent(DateTimeOffset target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.datetime.addmicroseconds")]
public static DateTime AddMicroseconds(DateTime target, double microseconds);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.datetimeoffset.addmicroseconds")]
public static DateTimeOffset AddMicroseconds(DateTimeOffset target, double microseconds);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.random.nextbytes#system-random-nextbytes(system-span((system-byte)))")]
public static void Shuffle(Random target, T[] values);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.random.nextbytes#system-random-nextbytes(system-span((system-byte)))")]
public static void Shuffle(Random target, Span`1<T> values);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedlist-2.getkeyatindex")]
public static TKey GetKeyAtIndex(SortedList`2<TKey, TValue> target, int index);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.collections.generic.sortedlist-2.getvalueatindex")]
public static TValue GetValueAtIndex(SortedList`2<TKey, TValue> target, int index);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.append#system-text-stringbuilder-append(system-text-stringbuilder-appendinterpolatedstringhandler@)")]
public static StringBuilder Append(StringBuilder target, AppendInterpolatedStringHandler& handler);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.append#system-text-stringbuilder-append(system-iformatprovider-system-text-stringbuilder-appendinterpolatedstringhandler@)")]
public static StringBuilder Append(StringBuilder target, IFormatProvider provider, AppendInterpolatedStringHandler& handler);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.appendline#system-text-stringbuilder-appendline(system-text-stringbuilder-appendinterpolatedstringhandler@)")]
public static StringBuilder AppendLine(StringBuilder target, AppendInterpolatedStringHandler& handler);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.appendline#system-text-stringbuilder-appendline(system-iformatprovider-system-text-stringbuilder-appendinterpolatedstringhandler@)")]
public static StringBuilder AppendLine(StringBuilder target, IFormatProvider provider, AppendInterpolatedStringHandler& handler);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.replace#system-text-stringbuilder-replace(system-readonlyspan((system-char))-system-readonlyspan((system-char)))")]
public static StringBuilder Replace(StringBuilder target, ReadOnlySpan`1<char> oldValue, ReadOnlySpan`1<char> newValue);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.stringbuilder.replace#system-text-stringbuilder-replace(system-char-system-char-system-int32-system-int32)")]
public static StringBuilder Replace(StringBuilder target, ReadOnlySpan`1<char> oldValue, ReadOnlySpan`1<char> newValue, int startIndex, int count);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.io.textreader.readtoendasync#system-io-textreader-readtoendasync(system-threading-cancellationtoken)")]
public static Task`1<string> ReadToEndAsync(TextReader target, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.io.textreader.readtoendasync#system-io-textreader-readlineasync(system-threading-cancellationtoken)")]
public static Task`1<string> ReadLineAsync(TextReader target, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.io.textwriter.flushasync#system-io-textwriter-flushasync(system-threading-cancellationtoken)")]
public static Task FlushAsync(TextWriter target, CancellationToken cancellationToken);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.datetimeoffset.tryformat")]
public static bool TryFormat(DateTimeOffset target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.datetime.tryformat")]
public static bool TryFormat(DateTime target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.dateonly.tryformat")]
public static bool TryFormat(DateOnly target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.timeonly.tryformat")]
public static bool TryFormat(TimeOnly target, Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private static bool CopyToSpan(Span`1<char> destination, Int32& charsWritten, string result);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.type.isgenericmethodparameter")]
public static bool IsGenericMethodParameter(Type target);
    [ExtensionAttribute]
public static bool IsAssignableTo(Type target);
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type target);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.ismatch#system-text-regularexpressions-regex-ismatch(system-readonlyspan((system-char))-system-int32)")]
public static bool IsMatch(Regex target, ReadOnlySpan`1<char> input, int startat);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.ismatch#system-text-regularexpressions-regex-ismatch(system-readonlyspan((system-char)))")]
public static bool IsMatch(Regex target, ReadOnlySpan`1<char> input);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.enumeratematches#system-text-regularexpressions-regex-enumeratematches(system-readonlyspan((system-char)))")]
public static ValueMatchEnumerator EnumerateMatches(Regex target, ReadOnlySpan`1<char> input);
    [ExtensionAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.enumeratematches#system-text-regularexpressions-regex-enumeratematches(system-readonlyspan((system-char))-system-int32)")]
public static ValueMatchEnumerator EnumerateMatches(Regex target, ReadOnlySpan`1<char> input, int startat);
    [CompilerGeneratedAttribute]
internal static Dictionary`2<TKey, TAccumulate> <AggregateByIterator>g__PopulateDictionary|5_0(IEnumerator`1<TSource> enumerator, Func`2<TSource, TKey> keySelector, TAccumulate seed, Func`3<TAccumulate, TSource, TAccumulate> func, IEqualityComparer`1<TKey> keyComparer);
    [CompilerGeneratedAttribute]
internal static Dictionary`2<TKey, TAccumulate> <AggregateByIterator>g__PopulateDictionary|6_0(IEnumerator`1<TSource> enumerator, Func`2<TSource, TKey> keySelector, Func`2<TKey, TAccumulate> seedSelector, Func`3<TAccumulate, TSource, TAccumulate> func, IEqualityComparer`1<TKey> keyComparer);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class Polyfills.RegexPolyfill : object {
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.ismatch#system-text-regularexpressions-regex-ismatch(system-readonlyspan((system-char))-system-string-system-text-regularexpressions-regexoptions-system-timespan)")]
public static bool IsMatch(ReadOnlySpan`1<char> input, string pattern, RegexOptions options, TimeSpan timeout);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.ismatch#system-text-regularexpressions-regex-ismatch(system-readonlyspan((system-char))-system-string-system-text-regularexpressions-regexoptions)")]
public static bool IsMatch(ReadOnlySpan`1<char> input, string pattern, RegexOptions options);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.ismatch#system-text-regularexpressions-regex-ismatch(system-readonlyspan((system-char))-system-string)")]
public static bool IsMatch(ReadOnlySpan`1<char> input, string pattern);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.enumeratematches#system-text-regularexpressions-regex-enumeratematches(system-readonlyspan((system-char))-system-string)")]
public static ValueMatchEnumerator EnumerateMatches(ReadOnlySpan`1<char> input, string pattern);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.enumeratematches#system-text-regularexpressions-regex-enumeratematches(system-readonlyspan((system-char))-system-string-system-text-regularexpressions-regexoptions-system-timespan)")]
public static ValueMatchEnumerator EnumerateMatches(ReadOnlySpan`1<char> input, string pattern, RegexOptions options, TimeSpan timeout);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.text.regularexpressions.regex.enumeratematches#system-text-regularexpressions-regex-enumeratematches(system-readonlyspan((system-char))-system-string-system-text-regularexpressions-regexoptions)")]
public static ValueMatchEnumerator EnumerateMatches(ReadOnlySpan`1<char> input, string pattern, RegexOptions options);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class Polyfills.SBytePolyfill : object {
    [NullableContextAttribute("2")]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.sbyte.tryparse#system-sbyte-tryparse(system-string-system-iformatprovider-system-sbyte@)")]
public static bool TryParse(string target, IFormatProvider provider, SByte& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.sbyte.tryparse#system-sbyte-tryparse(system-readonlyspan((system-byte))-system-iformatprovider-system-sbyte@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, IFormatProvider provider, SByte& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.sbyte.tryparse#system-sbyte-tryparse(system-readonlyspan((system-char))-system-sbyte@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, SByte& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.sbyte.tryparse#system-sbyte-tryparse(system-readonlyspan((system-char))-system-iformatprovider-system-sbyte@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, IFormatProvider provider, SByte& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.sbyte.tryparse#system-sbyte-tryparse(system-readonlyspan((system-byte))-system-globalization-numberstyles-system-iformatprovider-system-sbyte@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, NumberStyles style, IFormatProvider provider, SByte& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.sbyte.tryparse#system-sbyte-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-sbyte@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, SByte& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.sbyte.tryparse#system-sbyte-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-sbyte@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, NumberStyles style, IFormatProvider provider, SByte& result);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class Polyfills.ShortPolyfill : object {
    [NullableContextAttribute("2")]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int16.tryparse#system-int16-tryparse(system-string-system-iformatprovider-system-int16@)")]
public static bool TryParse(string target, IFormatProvider provider, Int16& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int16.tryparse#system-int16-tryparse(system-readonlyspan((system-byte))-system-iformatprovider-system-int16@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, IFormatProvider provider, Int16& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int16.tryparse#system-int16-tryparse(system-readonlyspan((system-char))-system-int16@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, Int16& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int16.tryparse#system-int16-tryparse(system-readonlyspan((system-char))-system-iformatprovider-system-int16@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, IFormatProvider provider, Int16& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int16.tryparse#system-int16-tryparse(system-readonlyspan((system-byte))-system-globalization-numberstyles-system-iformatprovider-system-int16@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, NumberStyles style, IFormatProvider provider, Int16& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int16.tryparse#system-int16-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-int16@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, Int16& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.int16.tryparse#system-int16-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-int16@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, NumberStyles style, IFormatProvider provider, Int16& result);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class Polyfills.StringPolyfill : object {
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.string.join#system-string-join(system-char-system-string())")]
public static string Join(char separator, String[] values);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.string.join#system-string-join(system-char-system-object())")]
public static string Join(char separator, Object[] values);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.string.join#system-string-join(system-char-system-string()-system-int32-system-int32)")]
public static string Join(char separator, String[] value, int startIndex, int count);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.string.join#system-string-join-1(system-char-system-collections-generic-ienumerable((-0)))")]
public static string Join(char separator, IEnumerable`1<T> values);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class Polyfills.UIntPolyfill : object {
    [NullableContextAttribute("2")]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint32.tryparse#system-uint32-tryparse(system-string-system-iformatprovider-system-uint32@)")]
public static bool TryParse(string target, IFormatProvider provider, UInt32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint32.tryparse#system-uint32-tryparse(system-readonlyspan((system-byte))-system-iformatprovider-system-uint32@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, IFormatProvider provider, UInt32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint32.tryparse#system-uint32-tryparse(system-readonlyspan((system-char))-system-uint32@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, UInt32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint32.tryparse#system-uint32-tryparse(system-readonlyspan((system-char))-system-iformatprovider-system-uint32@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, IFormatProvider provider, UInt32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint32.tryparse#system-uint32-tryparse(system-readonlyspan((system-byte))-system-globalization-numberstyles-system-iformatprovider-system-uint32@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, NumberStyles style, IFormatProvider provider, UInt32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint32.tryparse#system-uint32-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-uint32@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, UInt32& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint32.tryparse#system-uint32-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-uint32@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, NumberStyles style, IFormatProvider provider, UInt32& result);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class Polyfills.ULongPolyfill : object {
    [NullableContextAttribute("2")]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint64.tryparse#system-uint64-tryparse(system-string-system-iformatprovider-system-uint64@)")]
public static bool TryParse(string target, IFormatProvider provider, UInt64& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint64.tryparse#system-uint64-tryparse(system-readonlyspan((system-byte))-system-iformatprovider-system-uint64@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, IFormatProvider provider, UInt64& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint64.tryparse#system-uint64-tryparse(system-readonlyspan((system-char))-system-uint64@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, UInt64& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint64.tryparse#system-uint64-tryparse(system-readonlyspan((system-char))-system-iformatprovider-system-uint64@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, IFormatProvider provider, UInt64& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint64.tryparse#system-uint64-tryparse(system-readonlyspan((system-byte))-system-globalization-numberstyles-system-iformatprovider-system-uint64@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, NumberStyles style, IFormatProvider provider, UInt64& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint64.tryparse#system-uint64-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-uint64@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, UInt64& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint64.tryparse#system-uint64-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-uint64@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, NumberStyles style, IFormatProvider provider, UInt64& result);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal static class Polyfills.UShortPolyfill : object {
    [NullableContextAttribute("2")]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint16.tryparse#system-uint16-tryparse(system-string-system-iformatprovider-system-uint16@)")]
public static bool TryParse(string target, IFormatProvider provider, UInt16& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint16.tryparse#system-uint16-tryparse(system-readonlyspan((system-byte))-system-iformatprovider-system-uint16@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, IFormatProvider provider, UInt16& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint16.tryparse#system-uint16-tryparse(system-readonlyspan((system-char))-system-uint16@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, UInt16& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint16.tryparse#system-uint16-tryparse(system-readonlyspan((system-char))-system-iformatprovider-system-uint16@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, IFormatProvider provider, UInt16& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint16.tryparse#system-uint16-tryparse(system-readonlyspan((system-byte))-system-globalization-numberstyles-system-iformatprovider-system-uint16@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, NumberStyles style, IFormatProvider provider, UInt16& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint16.tryparse#system-uint16-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-uint16@)")]
public static bool TryParse(ReadOnlySpan`1<byte> target, UInt16& result);
    [DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.uint16.tryparse#system-uint16-tryparse(system-readonlyspan((system-char))-system-globalization-numberstyles-system-iformatprovider-system-uint16@)")]
public static bool TryParse(ReadOnlySpan`1<char> target, NumberStyles style, IFormatProvider provider, UInt16& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class PrefixUnique : object {
    private static ConcurrentBag`1<string> prefixList;
    private static PrefixUnique();
    public static void CheckPrefixIsUnique(string prefix);
    public static void Clear();
    public static UniquenessList SharedUniqueness(Namer namer);
    private static void AppendTargetFramework(Namer namer, UniquenessList builder);
    private static void AppendAssemblyConfiguration(Namer namer, UniquenessList builder);
    private static void AppendArchitecture(Namer namer, UniquenessList builder);
    private static void AppendOsPlatform(Namer namer, UniquenessList builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class ProjectDirectoryFinder : object {
    public static string Find(string testDirectory);
    private static bool ContainsProject(string currentDirectory);
    private static bool ContainsProject(string currentDirectory, string pattern);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class PropertyInfoConverter : WriteOnlyJsonConverter`1<PropertyInfo> {
    public virtual void Write(VerifyJsonWriter writer, PropertyInfo value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class ReflectionHelpers : object {
    [ExtensionAttribute]
public static bool InheritsFrom(Type type, Type parent);
    [ExtensionAttribute]
public static Type MemberType(MemberInfo member);
    [ExtensionAttribute]
public static bool IsEmptyCollectionOrDictionary(object target);
    [ExtensionAttribute]
public static bool TryGetCollectionOrDictionary(object target, Nullable`1& isEmpty, IEnumerable& enumerable);
    [ExtensionAttribute]
private static bool IsEnumerableEmpty(Type type);
    [ExtensionAttribute]
public static bool IsGeneric(Type type, Type[] generics);
    [ExtensionAttribute]
public static bool IsGeneric(Type type, Type generic);
    [ExtensionAttribute]
private static bool ImplementsGenericCollection(Type type);
}
internal class ScrubbedProvider : object {
    [NullableContextAttribute("1")]
public sealed virtual void SetValue(object target, object value);
    [NullableContextAttribute("1")]
public sealed virtual object GetValue(object target);
}
internal enum ScrubOrIgnore : Enum {
    public int value__;
    public static ScrubOrIgnore Scrub;
    public static ScrubOrIgnore Ignore;
    public static ScrubOrIgnore AlwaysInclude;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class SerializationSettings : object {
    internal static List`1<string> dateFormats;
    internal static List`1<string> timeFormats;
    internal static List`1<string> dateTimeFormats;
    internal static List`1<string> dateTimeOffsetFormats;
    private static JArrayConverter jArrayConverter;
    private static JObjectConverter jObjectConverter;
    private static KeyValuePairConverter keyValuePairConverter;
    private static Converter infoConverter;
    private static TimeConverter timeConverter;
    private static DateConverter dateConverter;
    private static StringEnumConverter stringEnumConverter;
    private static DelegateConverter delegateConverter;
    private static TargetInvocationExceptionConverter targetInvocationExceptionConverter;
    private static ToAppendConverter toAppendConverter;
    private static ExpressionConverter expressionConverter;
    private static TypeJsonConverter typeJsonConverter;
    private static MethodInfoConverter methodInfoConverter;
    private static FieldInfoConverter fieldInfoConverter;
    private static ConstructorInfoConverter constructorInfoConverter;
    private static CancelConverter cancelConverter;
    private static ParameterInfoConverter parameterInfoConverter;
    private static PropertyInfoConverter propertyInfoConverter;
    private static ClaimConverter claimConverter;
    private static AggregateExceptionConverter aggregateExceptionConverter;
    private static ClaimsPrincipalConverter claimsPrincipalConverter;
    private static ClaimsIdentityConverter claimsIdentityConverter;
    private static NameValueCollectionConverter nameValueCollectionConverter;
    private static StringDictionaryConverter stringDictionaryConverter;
    private static TaskConverter taskConverter;
    private static ValueTaskConverter valueTaskConverter;
    private JsonSerializerSettings jsonSettings;
    private bool scrubGuids;
    private bool scrubDateTimes;
    private List`1<Action`1<JsonSerializerSettings>> extraSettings;
    [NullableAttribute("2")]
private JsonSerializer serializer;
    internal bool SortDictionaries;
    private Dictionary`2<Type, Func`2<IEnumerable, IEnumerable>> enumerableInterceptors;
    private Dictionary`2<string, Nullable`1<ScrubOrIgnore>> ignoredByNameMembers;
    private bool ignoreEmptyCollections;
    private Dictionary`2<Type, Dictionary`2<string, ScrubOrIgnore>> ignoredMembers;
    private Dictionary`2<Type, List`1<Func`2<object, Nullable`1<ScrubOrIgnore>>>> ignoredInstances;
    private List`1<Func`2<Exception, bool>> ignoreMembersThatThrow;
    private bool includeObsoletes;
    private Dictionary`2<Type, ScrubOrIgnore> ignoredTypes;
    internal JsonSerializer Serializer { get; }
    public SerializationSettings(SerializationSettings settings);
    private static SerializationSettings();
    [NullableContextAttribute("0")]
internal bool TryConvertString(Counter counter, ReadOnlySpan`1<char> value, String& result);
    internal bool TryConvert(Counter counter, DateTime value, String& result);
    [NullableContextAttribute("0")]
internal bool TryParseConvertDate(Counter counter, ReadOnlySpan`1<char> value, String& result);
    internal bool TryConvert(Counter counter, DateOnly value, String& result);
    internal static string Convert(Counter counter, DateOnly date);
    [NullableContextAttribute("0")]
internal bool TryParseConvertTime(Counter counter, ReadOnlySpan`1<char> value, String& result);
    internal bool TryConvert(Counter counter, TimeOnly value, String& result);
    private static string Convert(Counter counter, TimeOnly time);
    internal bool TryConvert(Counter counter, DateTimeOffset value, String& result);
    internal static string Convert(Counter counter, DateTime date);
    internal static string Convert(Counter counter, DateTimeOffset date);
    [NullableContextAttribute("0")]
internal bool TryParseConvertDateTime(Counter counter, ReadOnlySpan`1<char> value, String& result);
    [NullableContextAttribute("0")]
private static bool TryParseDateTime(ReadOnlySpan`1<char> value, string format, DateTime& dateTime);
    [NullableContextAttribute("0")]
internal bool TryParseConvertDateTimeOffset(Counter counter, ReadOnlySpan`1<char> value, String& result);
    [NullableContextAttribute("0")]
private static bool TryParseDateTimeOffset(ReadOnlySpan`1<char> value, string format, DateTimeOffset& dateTimeOffset);
    internal bool TryConvert(Counter counter, Guid value, String& result);
    internal static string Convert(Counter counter, Guid guid);
    [NullableContextAttribute("0")]
internal bool TryParseConvertGuid(Counter counter, ReadOnlySpan`1<char> value, String& result);
    [NullableContextAttribute("0")]
internal bool TryParseConvert(Counter counter, ReadOnlySpan`1<char> value, String& result);
    public void DontScrubGuids();
    public void DontScrubDateTimes();
    private JsonSerializerSettings BuildSettings();
    public void AddExtraSettings(Action`1<JsonSerializerSettings> action);
    internal JsonSerializer get_Serializer();
    public void DontSortDictionaries();
    [NullableContextAttribute("2")]
public void OrderEnumerableBy(Func`2<T, object> keySelector);
    [NullableContextAttribute("2")]
public void OrderEnumerableByDescending(Func`2<T, object> keySelector);
    internal bool TryGetEnumerableInterceptors(Type memberType, Func`2& order);
    public void IgnoreStackTrace();
    public void IgnoreMember(string name);
    public void ScrubMember(string name);
    public void IgnoreMembers(String[] names);
    public void ScrubMembers(String[] names);
    internal bool ShouldIgnoreByName(string name);
    internal bool ShouldScrubByName(string name);
    internal bool TryGetScrubOrIgnoreByName(string name, Nullable`1& scrubOrIgnore);
    public void DontIgnoreEmptyCollections();
    public void IgnoreMembers(Expression`1[] expressions);
    public void ScrubMembers(Expression`1[] expressions);
    public void IgnoreMember(Expression`1<Func`2<T, object>> expression);
    public void ScrubMember(Expression`1<Func`2<T, object>> expression);
    private void IgnoreMember(Expression`1<Func`2<T, object>> expression, ScrubOrIgnore scrubOrIgnore);
    public void IgnoreMembers(String[] names);
    public void ScrubMembers(String[] names);
    public void IgnoreMember(string name);
    public void ScrubMember(string name);
    public void IgnoreMembers(Type declaringType, String[] names);
    public void ScrubMembers(Type declaringType, String[] names);
    public void IgnoreMember(Type declaringType, string name);
    public void ScrubMember(Type declaringType, string name);
    private void IgnoreMember(Type declaringType, string name, ScrubOrIgnore scrubOrIgnore);
    internal bool TryGetScrubOrIgnoreByMemberOfType(Type declaringType, string name, Nullable`1& scrubOrIgnore);
    public void IgnoreInstance(Func`2<T, bool> shouldIgnore);
    public void IgnoreInstance(Type type, ShouldIgnore shouldIgnore);
    public void ScrubInstance(Func`2<T, bool> shouldScrub);
    public void ScrubInstance(Type type, ShouldScrub shouldScrub);
    internal bool GetShouldIgnoreInstance(Type memberType, List`1& funcs);
    [NullableContextAttribute("0")]
public void IgnoreMembersThatThrow();
    public void IgnoreMembersThatThrow(Func`2<Exception, bool> item);
    public bool ShouldIgnoreException(Exception exception);
    public void IgnoreMembersThatThrow(Func`2<T, bool> item);
    public void IncludeObsoletes();
    private bool ShouldIgnoreIfObsolete(MemberInfo member);
    public void ScrubMembersWithType();
    public void ScrubMembersWithType(Type type);
    public void IgnoreMembersWithType();
    public void IgnoreMembersWithType(Type type);
    public void AlwaysIncludeMembersWithType();
    public void AlwaysIncludeMembersWithType(Type type);
    private void Add(Type type, ScrubOrIgnore scrubOrIgnore);
    private bool TryGetScrubOrIgnoreByType(Type memberType, Nullable`1& scrubOrIgnore);
    internal bool TryGetScrubOrIgnore(MemberInfo member, Nullable`1& scrubOrIgnore);
    internal bool TryGetScrubOrIgnore(Type declaringType, Type memberType, string name, Nullable`1& scrubOrIgnore);
    internal bool TryGetScrubOrIgnoreByInstance(object value, Nullable`1& scrubOrIgnore);
}
internal class ShortNameBinder : object {
    [NullableAttribute("1")]
public static ShortNameBinder Instance;
    private static ShortNameBinder();
    [NullableContextAttribute("2")]
public sealed virtual void BindToName(Type type, String& assemblyName, String& typeName);
    [NullableContextAttribute("1")]
public sealed virtual Type BindToType(string assemblyName, string typeName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class State : object {
    private List`1<ToAppend> items;
    [CompilerGeneratedAttribute]
private bool <Paused>k__BackingField;
    internal IReadOnlyCollection`1<ToAppend> Items { get; }
    public bool Paused { get; private set; }
    internal IReadOnlyCollection`1<ToAppend> get_Items();
    [CompilerGeneratedAttribute]
public bool get_Paused();
    [CompilerGeneratedAttribute]
private void set_Paused(bool value);
    public void Add(string name, object item);
    public void Pause();
    public void Resume();
    public void Clear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class StreamComparer : object {
    private static int bufferSize;
    [AsyncStateMachineAttribute("StreamComparer/<AreEqual>d__1")]
public static Task`1<CompareResult> AreEqual(Stream stream1, Stream stream2);
    private static void EnsureAtStart(Stream stream);
    [AsyncStateMachineAttribute("StreamComparer/<ReadBufferAsync>d__3")]
private static Task`1<int> ReadBufferAsync(Stream stream, Byte[] buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class StringDictionaryConverter : WriteOnlyJsonConverter`1<StringDictionary> {
    public virtual void Write(VerifyJsonWriter writer, StringDictionary collection);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("2048")]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.codeanalysis.constantexpectedattribute")]
internal class System.Diagnostics.CodeAnalysis.ConstantExpectedAttribute : Attribute {
    [CompilerGeneratedAttribute]
private object <Min>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Max>k__BackingField;
    public object Min { get; public set; }
    public object Max { get; public set; }
    [CompilerGeneratedAttribute]
public object get_Min();
    [CompilerGeneratedAttribute]
public void set_Min(object value);
    [CompilerGeneratedAttribute]
public object get_Max();
    [CompilerGeneratedAttribute]
public void set_Max(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6143")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.codeanalysis.experimentalattribute")]
internal class System.Diagnostics.CodeAnalysis.ExperimentalAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <DiagnosticId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <UrlFormat>k__BackingField;
    public string DiagnosticId { get; }
    [NullableAttribute("2")]
public string UrlFormat { get; public set; }
    public ExperimentalAttribute(string diagnosticId);
    [CompilerGeneratedAttribute]
public string get_DiagnosticId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_UrlFormat();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_UrlFormat(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresDynamicCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Url();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Url(string value);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("32")]
internal class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.StringSyntaxAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Syntax>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public static string CompositeFormat;
    public static string DateOnlyFormat;
    public static string DateTimeFormat;
    public static string EnumFormat;
    public static string GuidFormat;
    public static string Json;
    public static string NumericFormat;
    public static string Regex;
    public static string TimeOnlyFormat;
    public static string TimeSpanFormat;
    public static string Uri;
    public static string Xml;
    public string Syntax { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] Arguments { get; }
    public StringSyntaxAttribute(string syntax);
    public StringSyntaxAttribute(string syntax, Object[] arguments);
    [CompilerGeneratedAttribute]
public string get_Syntax();
    [CompilerGeneratedAttribute]
public Object[] get_Arguments();
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("2240")]
internal class System.Diagnostics.CodeAnalysis.UnscopedRefAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.UnreachableException : Exception {
    public UnreachableException(string message);
    public UnreachableException(string message, Exception innerException);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("1036")]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.collectionbuilderattribute")]
internal class System.Runtime.CompilerServices.CollectionBuilderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <BuilderType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public Type BuilderType { get; }
    public string MethodName { get; }
    public CollectionBuilderAttribute(Type builderType, string methodName);
    [CompilerGeneratedAttribute]
public Type get_BuilderType();
    [CompilerGeneratedAttribute]
public string get_MethodName();
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("32767")]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.compilerfeaturerequiredattribute")]
internal class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public bool get_IsOptional();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsOptional(bool value);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("1")]
[DescriptionAttribute("https://learn.microsoft.com/en-us/dotnet/api/system.runtime.compilerservices.disableruntimemarshallingattribute")]
internal class System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("224")]
internal class System.Runtime.CompilerServices.OverloadResolutionPriorityAttribute : Attribute {
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    public int Priority { get; }
    public OverloadResolutionPriorityAttribute(int priority);
    [CompilerGeneratedAttribute]
public int get_Priority();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.ParamCollectionAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("396")]
internal class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
[AttributeUsageAttribute("2047")]
internal class System.Runtime.Versioning.ObsoletedOSPlatformAttribute : OSPlatformAttribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    [NullableContextAttribute("1")]
public ObsoletedOSPlatformAttribute(string platformName);
    [NullableContextAttribute("1")]
public ObsoletedOSPlatformAttribute(string platformName, string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal abstract class System.Runtime.Versioning.OSPlatformAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PlatformName>k__BackingField;
    public string PlatformName { get; }
    protected OSPlatformAttribute(string platformName);
    [CompilerGeneratedAttribute]
public string get_PlatformName();
}
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Text.RegularExpressions.RegexCache : object {
    private static int DefaultMaxCacheSize;
    private static int MaxExamineOnDrop;
    [NullableAttribute("2")]
private static Node modreq(System.Runtime.CompilerServices.IsVolatile) s_lastAccessed;
    private static ConcurrentDictionary`2<Key, Node> s_cacheDictionary;
    private static List`1<Node> s_cacheList;
    private static Random s_random;
    private static int s_maxCacheSize;
    private static object SyncObj { get; }
    public static int MaxCacheSize { get; public set; }
    private static RegexCache();
    private static object get_SyncObj();
    public static int get_MaxCacheSize();
    public static void set_MaxCacheSize(int value);
    public static Regex GetOrAdd(string pattern);
    public static Regex GetOrAdd(string pattern, RegexOptions options, TimeSpan matchTimeout);
    [NullableContextAttribute("2")]
private static Regex Get(Key key);
    private static void Add(Key key, Regex regex);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Text.RegularExpressions.ValueMatch : ValueType {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Index { get; }
    public int Length { get; }
    internal ValueMatch(int index, int length);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public int get_Length();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Text.RegularExpressions.ValueMatchEnumerator : ValueType {
    private ReadOnlySpan`1<char> _input;
    private ValueMatch _current;
    private MatchCollection matchCollection;
    private int index;
    public ValueMatch Current { get; }
    internal ValueMatchEnumerator(Regex regex, ReadOnlySpan`1<char> input, int startAt);
    [IsReadOnlyAttribute]
public ValueMatchEnumerator GetEnumerator();
    public bool MoveNext();
    [IsReadOnlyAttribute]
public ValueMatch get_Current();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class TargetInvocationExceptionConverter : WriteOnlyJsonConverter`1<TargetInvocationException> {
    public virtual void Write(VerifyJsonWriter writer, TargetInvocationException exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class TaskConverter : WriteOnlyJsonConverter`1<Task> {
    public virtual void Write(VerifyJsonWriter writer, Task task);
    private static void WriteResult(VerifyJsonWriter writer, Task task);
}
internal class TimeConverter : WriteOnlyJsonConverter`1<TimeOnly> {
    [NullableContextAttribute("1")]
public virtual void Write(VerifyJsonWriter writer, TimeOnly value);
}
internal class ToAppendConverter : WriteOnlyJsonConverter`1<ToAppend> {
    [NullableContextAttribute("1")]
public virtual void Write(VerifyJsonWriter writer, ToAppend value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class TupleConverter : object {
    public static Dictionary`2<string, object> ExpressionToDictionary(Expression`1<Func`1<ITuple>> expression);
    private static TupleElementNamesAttribute ReadTupleElementNamesAttribute(MethodInfo method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class TypeConverter : object {
    [CompilerGeneratedAttribute]
private AsyncConversion <Conversion>k__BackingField;
    [CompilerGeneratedAttribute]
private CanConvert <CanConvert>k__BackingField;
    public AsyncConversion Conversion { get; }
    public CanConvert CanConvert { get; }
    public TypeConverter(AsyncConversion conversion, CanConvert canConvert);
    [CompilerGeneratedAttribute]
public AsyncConversion get_Conversion();
    [CompilerGeneratedAttribute]
public CanConvert get_CanConvert();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class TypeJsonConverter : WriteOnlyJsonConverter`1<Type> {
    public virtual void Write(VerifyJsonWriter writer, Type value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class TypeNameProvider : object {
    [CompilerGeneratedAttribute]
private Type <type>P;
    public TypeNameProvider(Type type);
    public sealed virtual void SetValue(object target, object value);
    public sealed virtual object GetValue(object target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class UniquenessList : object {
    private List`1<string> inner;
    public UniquenessList(UniquenessList value);
    public void Add(string value);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ValueTaskConverter : WriteOnlyJsonConverter {
    private static MethodInfo genericWriteDef;
    private static ValueTaskConverter();
    public virtual bool CanConvert(Type type);
    public virtual void Write(VerifyJsonWriter writer, object value);
    private static void WriteGeneric(VerifyJsonWriter writer, ValueTask`1<T> task);
    private static void WriteResult(VerifyJsonWriter writer, ValueTask`1<T> task);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class VerifyCheckException : Exception {
    public string StackTrace { get; }
    public VerifyCheckException(string message);
    public virtual string ToString();
    public virtual string get_StackTrace();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("new = {new.Count} | notEquals = {notEquals.Count} | equal = {equal.Count} | delete = {delete.Count}")]
internal class VerifyEngine : object {
    [CompilerGeneratedAttribute]
private string <directory>P;
    [CompilerGeneratedAttribute]
private VerifySettings <settings>P;
    [CompilerGeneratedAttribute]
private GetFileNames <getFileNames>P;
    [CompilerGeneratedAttribute]
private GetIndexedFileNames <getIndexedFileNames>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <typeName>P;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <methodName>P;
    private bool diffEnabled;
    private List`1<NewResult> new;
    private List`1<NotEqualResult> notEquals;
    private List`1<FilePair> equal;
    private List`1<FilePair> autoVerified;
    private HashSet`1<string> delete;
    public IReadOnlyList`1<FilePair> Equal { get; }
    public IReadOnlyList`1<FilePair> AutoVerified { get; }
    public VerifyEngine(string directory, VerifySettings settings, IEnumerable`1<string> verifiedFiles, GetFileNames getFileNames, GetIndexedFileNames getIndexedFileNames, string typeName, string methodName);
    public IReadOnlyList`1<FilePair> get_Equal();
    public IReadOnlyList`1<FilePair> get_AutoVerified();
    [AsyncStateMachineAttribute("VerifyEngine/<GetResult>d__17")]
private static Task`1<EqualityResult> GetResult(VerifySettings settings, FilePair file, Target target, bool previousTextFailed);
    [AsyncStateMachineAttribute("VerifyEngine/<HandleResults>d__18")]
public Task HandleResults(List`1<Target> targetList);
    private void HandleCompareResult(EqualityResult result, FilePair file);
    private void AddMissing(NewResult& item);
    private void AddNotEquals(NotEqualResult& notEqual);
    private void AddEquals(FilePair& item);
    [AsyncStateMachineAttribute("VerifyEngine/<ThrowIfRequired>d__23")]
public Task ThrowIfRequired();
    internal bool IsAutoVerify(string verifiedFile);
    [AsyncStateMachineAttribute("VerifyEngine/<ProcessDeletes>d__25")]
private Task`1<bool> ProcessDeletes();
    [AsyncStateMachineAttribute("VerifyEngine/<ProcessDeletes>d__26")]
private Task`1<bool> ProcessDeletes(string file);
    [AsyncStateMachineAttribute("VerifyEngine/<ProcessNotEquals>d__27")]
private Task`1<bool> ProcessNotEquals();
    private void ProcessEquals();
    [AsyncStateMachineAttribute("VerifyEngine/<RunDiffAutoCheck>d__29")]
private Task`1<bool> RunDiffAutoCheck(FilePair file, bool autoVerify);
    [AsyncStateMachineAttribute("VerifyEngine/<ProcessNew>d__30")]
private Task`1<bool> ProcessNew();
    private static void AcceptChanges(FilePair& file);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class VerifyException : Exception {
    public string StackTrace { get; }
    public VerifyException(string message);
    public virtual string get_StackTrace();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class VerifyExceptionMessageBuilder : object {
    public static string Build(string directory, IReadOnlyCollection`1<NewResult> new, IReadOnlyCollection`1<NotEqualResult> notEquals, IReadOnlyCollection`1<string> delete, IReadOnlyCollection`1<FilePair> equal);
    private static void AppendFile(string directory, StringBuilder builder, FilePair file);
    private static void AppendContent(string directory, IReadOnlyCollection`1<NewResult> new, IReadOnlyCollection`1<NotEqualResult> notEquals, StringBuilder builder);
    private static void AppendNotEqualContent(string directory, StringBuilder builder, NotEqualResult notEqual);
}
public class VerifyTests.AsString`1 : MulticastDelegate {
    public AsString`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual AsStringResult Invoke(T target, IReadOnlyDictionary`2<string, object> context);
    public virtual IAsyncResult BeginInvoke(T target, IReadOnlyDictionary`2<string, object> context, AsyncCallback callback, object object);
    public virtual AsStringResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class VerifyTests.AsStringResult : ValueType {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Extension>k__BackingField;
    public string Value { get; }
    [NullableAttribute("2")]
public string Extension { get; }
    public AsStringResult(string value, string extension);
    [CompilerGeneratedAttribute]
public string get_Value();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Extension();
    public static AsStringResult op_Implicit(string value);
}
public class VerifyTests.AsyncConversion : MulticastDelegate {
    public AsyncConversion(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task`1<ConversionResult> Invoke(object target, IReadOnlyDictionary`2<string, object> context);
    public virtual IAsyncResult BeginInvoke(object target, IReadOnlyDictionary`2<string, object> context, AsyncCallback callback, object object);
    public virtual Task`1<ConversionResult> EndInvoke(IAsyncResult result);
}
public class VerifyTests.AsyncConversion`1 : MulticastDelegate {
    public AsyncConversion`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task`1<ConversionResult> Invoke(T target, IReadOnlyDictionary`2<string, object> context);
    public virtual IAsyncResult BeginInvoke(T target, IReadOnlyDictionary`2<string, object> context, AsyncCallback callback, object object);
    public virtual Task`1<ConversionResult> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class VerifyTests.AttributeReader : object {
    public static string GetTargetFrameworks();
    public static string GetTargetFrameworks(Assembly assembly);
    [NullableContextAttribute("2")]
public static bool TryGetTargetFrameworks(String& targetFrameworks);
    public static bool TryGetTargetFrameworks(Assembly assembly, String& targetFrameworks);
    public static string GetProjectDirectory();
    public static string GetProjectName();
    public static string GetProjectDirectory(Assembly assembly);
    public static string GetProjectName(Assembly assembly);
    [NullableContextAttribute("2")]
public static bool TryGetProjectDirectory(String& projectDirectory);
    [NullableContextAttribute("2")]
public static bool TryGetProjectName(String& projectName);
    public static bool TryGetProjectDirectory(Assembly assembly, String& projectDirectory);
    public static bool TryGetProjectName(Assembly assembly, String& projectName);
    public static string GetSolutionDirectory();
    public static string GetSolutionName();
    public static string GetSolutionDirectory(Assembly assembly);
    public static string GetSolutionName(Assembly assembly);
    [NullableContextAttribute("2")]
public static bool TryGetSolutionDirectory(String& solutionDirectory);
    [NullableContextAttribute("2")]
public static bool TryGetSolutionName(String& solutionName);
    public static bool TryGetSolutionDirectory(Assembly assembly, String& solutionDirectory);
    public static bool TryGetSolutionName(Assembly assembly, String& solutionName);
    [NullableContextAttribute("2")]
internal static bool TryGetSolutionDirectory(bool mapPathForVirtualizedRun, String& solutionDirectory);
    internal static bool TryGetSolutionDirectory(Assembly assembly, bool mapPathForVirtualizedRun, String& solutionDirectory);
    internal static bool TryGetSolutionName(Assembly assembly, bool mapPathForVirtualizedRun, String& solutionName);
    internal static bool TryGetProjectDirectory(Assembly assembly, bool mapPathForVirtualizedRun, String& projectDirectory);
    internal static bool TryGetProjectName(Assembly assembly, bool mapPathForVirtualizedRun, String& projectName);
    private static bool TryGetValue(Assembly assembly, string key, String& value, bool isSourcePath);
    private static string GetValue(Assembly assembly, string key, bool isSourcePath);
}
public class VerifyTests.AutoVerify : MulticastDelegate {
    public AutoVerify(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(string verifiedFile);
    public virtual IAsyncResult BeginInvoke(string verifiedFile, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class VerifyTests.CanConvert : MulticastDelegate {
    public CanConvert(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(object target, IReadOnlyDictionary`2<string, object> context);
    public virtual IAsyncResult BeginInvoke(object target, IReadOnlyDictionary`2<string, object> context, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class VerifyTests.CanConvert`1 : MulticastDelegate {
    public CanConvert`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(T target, IReadOnlyDictionary`2<string, object> context);
    public virtual IAsyncResult BeginInvoke(T target, IReadOnlyDictionary`2<string, object> context, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("IsEqual = {IsEqual} | Message = {Message}")]
public class VerifyTests.CompareResult : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsEqual>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public static CompareResult Equal;
    public bool IsEqual { get; }
    public string Message { get; }
    private CompareResult(Boolean& isEqual, string message);
    public CompareResult(Boolean& isEqual);
    private static CompareResult();
    [CompilerGeneratedAttribute]
public bool get_IsEqual();
    [CompilerGeneratedAttribute]
public string get_Message();
    public static CompareResult NotEqual(String& message);
}
public class VerifyTests.Conversion : MulticastDelegate {
    public Conversion(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual ConversionResult Invoke(object target, IReadOnlyDictionary`2<string, object> context);
    public virtual IAsyncResult BeginInvoke(object target, IReadOnlyDictionary`2<string, object> context, AsyncCallback callback, object object);
    public virtual ConversionResult EndInvoke(IAsyncResult result);
}
public class VerifyTests.Conversion`1 : MulticastDelegate {
    public Conversion`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual ConversionResult Invoke(T target, IReadOnlyDictionary`2<string, object> context);
    public virtual IAsyncResult BeginInvoke(T target, IReadOnlyDictionary`2<string, object> context, AsyncCallback callback, object object);
    public virtual ConversionResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class VerifyTests.ConversionResult : ValueType {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Info>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Target> <Targets>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Func`1<Task> <Cleanup>k__BackingField;
    [NullableAttribute("2")]
public object Info { get; }
    public IEnumerable`1<Target> Targets { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<Task> Cleanup { get; }
    public ConversionResult(object info, IEnumerable`1<Target> targets, Func`1<Task> cleanup);
    public ConversionResult(object info, string extension, Stream stream, Func`1<Task> cleanup);
    public ConversionResult(object info, string extension, string data, Func`1<Task> cleanup);
    public ConversionResult(object info, string extension, StringBuilder data, Func`1<Task> cleanup);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Info();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Target> get_Targets();
    [CompilerGeneratedAttribute]
public Func`1<Task> get_Cleanup();
}
public class VerifyTests.ConvertMember : MulticastDelegate {
    public ConvertMember(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual object Invoke(object memberValue);
    public virtual IAsyncResult BeginInvoke(object memberValue, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class VerifyTests.ConvertMember`1 : MulticastDelegate {
    public ConvertMember`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TMember Invoke(TMember memberValue);
    public virtual IAsyncResult BeginInvoke(TMember memberValue, AsyncCallback callback, object object);
    public virtual TMember EndInvoke(IAsyncResult result);
}
public class VerifyTests.ConvertTargetMember : MulticastDelegate {
    public ConvertTargetMember(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual object Invoke(object target, object memberValue);
    public virtual IAsyncResult BeginInvoke(object target, object memberValue, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class VerifyTests.ConvertTargetMember`2 : MulticastDelegate {
    public ConvertTargetMember`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TMember Invoke(TTarget target, TMember memberValue);
    public virtual IAsyncResult BeginInvoke(TTarget target, TMember memberValue, AsyncCallback callback, object object);
    public virtual TMember EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class VerifyTests.Counter : object {
    private Dictionary`2<DateOnly, string> namedDates;
    private Dictionary`2<TimeOnly, string> namedTimes;
    private Dictionary`2<DateTime, string> namedDateTimes;
    private Dictionary`2<Guid, string> namedGuids;
    private Dictionary`2<DateTimeOffset, string> namedDateTimeOffsets;
    private bool dateCounting;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static AsyncLocal`1<Counter> local;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<DateOnly, ValueTuple`2<int, string>> dateCache;
    private static Dictionary`2<DateOnly, string> globalNamedDates;
    private int currentDate;
    private static IEqualityComparer`1<DateTime> dateTimeComparer;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<DateTime, ValueTuple`2<int, string>> dateTimeCache;
    private static Dictionary`2<DateTime, string> globalNamedDateTimes;
    private int currentDateTime;
    private static IEqualityComparer`1<DateTimeOffset> dateTimeOffsetComparer;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<DateTimeOffset, ValueTuple`2<int, string>> dateTimeOffsetCache;
    private static Dictionary`2<DateTimeOffset, string> globalNamedDateTimeOffsets;
    private int currentDateTimeOffset;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<Guid, ValueTuple`2<int, string>> guidCache;
    private static Dictionary`2<Guid, string> globalNamedGuids;
    private int currentGuid;
    private static IEqualityComparer`1<TimeOnly> timeComparer;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<TimeOnly, ValueTuple`2<int, string>> timeCache;
    private static Dictionary`2<TimeOnly, string> globalNamedTimes;
    private int currentTime;
    public static Counter Current { get; }
    private Counter(bool dateCounting, Dictionary`2<DateOnly, string> namedDates, Dictionary`2<TimeOnly, string> namedTimes, Dictionary`2<DateTime, string> namedDateTimes, Dictionary`2<Guid, string> namedGuids, Dictionary`2<DateTimeOffset, string> namedDateTimeOffsets);
    private static Counter();
    public static Counter get_Current();
    internal static Counter Start(bool dateCounting, Dictionary`2<DateOnly, string> namedDates, Dictionary`2<TimeOnly, string> namedTimes, Dictionary`2<DateTime, string> namedDateTimes, Dictionary`2<Guid, string> namedGuids, Dictionary`2<DateTimeOffset, string> namedDateTimeOffsets);
    internal static void Stop();
    internal static void AddNamed(DateOnly value, string name);
    public int Next(DateOnly input);
    public string NextString(DateOnly input);
    private ValueTuple`2<int, string> NextValue(DateOnly input);
    private ValueTuple`2<int, string> BuildDateValue();
    public static void UseDateTimeComparer(IEqualityComparer`1<DateTime> comparer);
    internal static void AddNamed(DateTime value, string name);
    public int Next(DateTime input);
    public string NextString(DateTime input);
    private ValueTuple`2<int, string> NextValue(DateTime input);
    private ValueTuple`2<int, string> BuildDateTimeValue();
    public static void UseDateTimeOffsetComparer(IEqualityComparer`1<DateTimeOffset> comparer);
    internal static void AddNamed(DateTimeOffset value, string name);
    public int Next(DateTimeOffset input);
    public string NextString(DateTimeOffset input);
    private ValueTuple`2<int, string> NextValue(DateTimeOffset input);
    private ValueTuple`2<int, string> BuildDateTimeOffsetValue();
    public int Next(Guid input);
    internal static void AddNamed(Guid value, string name);
    public string NextString(Guid input);
    private ValueTuple`2<int, string> NextValue(Guid input);
    private ValueTuple`2<int, string> BuildGuidValue();
    public static void UseTimeComparer(IEqualityComparer`1<TimeOnly> comparer);
    internal static void AddNamed(TimeOnly time, string name);
    public int Next(TimeOnly input);
    public string NextString(TimeOnly input);
    private ValueTuple`2<int, string> NextValue(TimeOnly input);
    private ValueTuple`2<int, string> BuildTimeValue();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ValueTuple`2<int, string> <NextValue>b__18_0(DateOnly _);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ValueTuple`2<int, string> <NextValue>b__29_0(DateTime _);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ValueTuple`2<int, string> <NextValue>b__40_0(DateTimeOffset _);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ValueTuple`2<int, string> <NextValue>b__48_0(Guid _);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private ValueTuple`2<int, string> <NextValue>b__58_0(TimeOnly _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class VerifyTests.CurrentFile : object {
    public static string Path(string file);
    public static string Directory(string file);
    public static string Relative(string relative, string file);
}
public class VerifyTests.FileAppender : MulticastDelegate {
    public FileAppender(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Nullable`1<Target> Invoke(IReadOnlyDictionary`2<string, object> context);
    public virtual IAsyncResult BeginInvoke(IReadOnlyDictionary`2<string, object> context, AsyncCallback callback, object object);
    public virtual Nullable`1<Target> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class VerifyTests.FilePair : ValueType {
    [CompilerGeneratedAttribute]
private string <Extension>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReceivedPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerifiedPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsText>k__BackingField;
    public string Extension { get; }
    public string ReceivedPath { get; }
    public string VerifiedPath { get; }
    public bool IsText { get; }
    public FilePair(string extension, string receivedPath, string verifiedPath);
    [CompilerGeneratedAttribute]
public string get_Extension();
    [CompilerGeneratedAttribute]
public string get_ReceivedPath();
    [CompilerGeneratedAttribute]
public string get_VerifiedPath();
    [CompilerGeneratedAttribute]
public bool get_IsText();
}
public class VerifyTests.FileScrubber : MulticastDelegate {
    public FileScrubber(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(string path, StringBuilder builder);
    public virtual IAsyncResult BeginInvoke(string path, StringBuilder builder, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class VerifyTests.FirstVerify : MulticastDelegate {
    public FirstVerify(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task Invoke(FilePair filePair, string receivedText, bool autoVerify);
    public virtual IAsyncResult BeginInvoke(FilePair filePair, string receivedText, bool autoVerify, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
public class VerifyTests.GlobalAutoVerify : MulticastDelegate {
    public GlobalAutoVerify(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(string typeName, string methodName, string verifiedFile);
    public virtual IAsyncResult BeginInvoke(string typeName, string methodName, string verifiedFile, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class VerifyTests.InnerVerifier : object {
    private VerifySettings settings;
    private string directory;
    private GetFileNames getFileNames;
    private GetIndexedFileNames getIndexedFileNames;
    private IEnumerable`1<string> verifiedFiles;
    private Counter counter;
    internal static bool verifyHasBeenRun;
    [NullableAttribute("2")]
private string typeName;
    [NullableAttribute("2")]
private string methodName;
    private static IEnumerable`1<Target> emptyTargets;
    [CompilerGeneratedAttribute]
private static object <IgnoreTarget>k__BackingField;
    internal static object IgnoreTarget { get; }
    public InnerVerifier(string sourceFile, VerifySettings settings, string typeName, string methodName, IReadOnlyList`1<string> methodParameters, PathInfo pathInfo);
    public InnerVerifier(string sourceFile, VerifySettings settings);
    private static InnerVerifier();
    public static void ThrowIfVerifyHasBeenRun();
    private static Counter StartCounter(VerifySettings settings);
    private void InitForDirectoryConvention(Namer namer, string typeAndMethod, string verifiedParameters);
    private string PrefixForDirectoryConvention(Namer namer, string typeAndMethod, string verifiedParameters);
    private static bool ShouldUseUniqueDirectorySplitMode(VerifySettings settings);
    private void InitForFileConvention(Namer namer, string typeAndMethod, string receivedParameters, string verifiedParameters);
    private ValueTuple`2<string, string> PrefixForFileConvention(Namer namer, string typeAndMethod, string receivedParameters, string verifiedParameters);
    private static UniquenessList GetUniquenessVerified(UniquenessList sharedUniqueness, Namer namer);
    private static string ResolveDirectory(string sourceFile, VerifySettings settings, PathInfo pathInfo);
    public Task`1<VerifyResult> Verify(object target, IEnumerable`1<Target> rawTargets);
    public Task`1<VerifyResult> Verify(Target target);
    public Task`1<VerifyResult> Verify(IEnumerable`1<Target> targets);
    private static void ValidatePrefix(VerifySettings settings, string filePathPrefix);
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyZip>d__25")]
public Task`1<VerifyResult> VerifyZip(string path, Func`2<ZipArchiveEntry, bool> include, object info, FileScrubber scrubber);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyZip>d__26")]
public Task`1<VerifyResult> VerifyZip(Stream stream, Func`2<ZipArchiveEntry, bool> include, object info, FileScrubber scrubber);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyZip>d__27")]
public Task`1<VerifyResult> VerifyZip(ZipArchive archive, Func`2<ZipArchiveEntry, bool> include, object info, FileScrubber scrubber);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyDirectory>d__28")]
public Task`1<VerifyResult> VerifyDirectory(string path, Func`2<string, bool> include, string pattern, EnumerationOptions option, object info, FileScrubber fileScrubber);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<ToTargets>d__29")]
private Task`1<List`1<Target>> ToTargets(string directoryPath, Func`2<string, bool> include, IEnumerable`1<string> enumerateFiles, object info, FileScrubber fileScrubber);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<TargetFromFile>d__30")]
private static Task`1<Target> TargetFromFile(string path, string relativePath, FileScrubber fileScrubber, Func`1<Stream> openStream);
    private static bool TryGetExtension(string path, String& extension);
    public Task`1<VerifyResult> VerifyFile(string path, object info, string extension);
    public Task`1<VerifyResult> VerifyFile(FileInfo target, object info, string extension);
    private Task`1<VerifyResult> VerifyInner(IEnumerable`1<Target> targets);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyInner>d__35")]
private Task`1<VerifyResult> VerifyInner(object root, Func`1<Task> cleanup, IEnumerable`1<Target> targets, bool doExpressionConversion);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<GetTargets>d__36")]
private Task`1<ValueTuple`2<List`1<Target>, Func`1<Task>>> GetTargets(IEnumerable`1<Target> targets, bool doExpressionConversion);
    [NullableContextAttribute("2")]
private bool TryGetRootTarget(object root, Nullable`1& target);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyJson>d__38")]
public Task`1<VerifyResult> VerifyJson(Task`1<string> target);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyJson>d__39")]
public Task`1<VerifyResult> VerifyJson(ValueTask`1<string> target);
    public Task`1<VerifyResult> VerifyJson(string target);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyJson>d__41")]
public Task`1<VerifyResult> VerifyJson(Task`1<Stream> target);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyJson>d__42")]
public Task`1<VerifyResult> VerifyJson(ValueTask`1<Stream> target);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyJson>d__43")]
public Task`1<VerifyResult> VerifyJson(Stream target);
    public Task`1<VerifyResult> VerifyJson(JToken target);
    [CompilerGeneratedAttribute]
internal static object get_IgnoreTarget();
    public Task`1<VerifyResult> Verify();
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<Verify>d__50")]
public Task`1<VerifyResult> Verify(object target);
    [NullableContextAttribute("2")]
public Task`1<VerifyResult> VerifyStream(FileStream stream, object info);
    [NullableContextAttribute("2")]
public Task`1<VerifyResult> VerifyStream(Byte[] bytes, object info);
    public Task`1<VerifyResult> VerifyStream(Byte[] bytes, string extension, object info);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyStream>d__54")]
public Task`1<VerifyResult> VerifyStream(Task`1<Byte[]> task, string extension, object info);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyStream>d__55")]
public Task`1<VerifyResult> VerifyStream(ValueTask`1<Byte[]> task, string extension, object info);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyStream>d__56`1")]
public Task`1<VerifyResult> VerifyStream(Task`1<T> task, string extension, object info);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyStream>d__57`1")]
public Task`1<VerifyResult> VerifyStream(ValueTask`1<T> task, string extension, object info);
    public Task`1<VerifyResult> VerifyStreams(IEnumerable`1<T> streams, string extension, object info);
    [NullableContextAttribute("2")]
public Task`1<VerifyResult> VerifyStream(Stream stream, object info);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyStream>d__60")]
public Task`1<VerifyResult> VerifyStream(Stream stream, string extension, object info);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<GetTarget>d__61")]
private static Task`1<Target> GetTarget(Stream stream, string extension);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<DoExtensionConversion>d__62")]
private Task`1<ValueTuple`3<object, List`1<Target>, Func`1<Task>>> DoExtensionConversion(string extension, Stream stream, object info);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyString>d__63")]
public Task`1<VerifyResult> VerifyString(Task`1<string> task);
    public Task`1<VerifyResult> VerifyString(string value);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyString>d__65")]
public Task`1<VerifyResult> VerifyString(Task`1<string> task, string extension);
    public Task`1<VerifyResult> VerifyString(string value, string extension);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<Verify>d__67`1")]
public Task`1<VerifyResult> Verify(Task`1<T> task);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<Verify>d__68`1")]
public Task`1<VerifyResult> Verify(IAsyncEnumerable`1<T> target);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<DoDispose>d__69`1")]
private static Task DoDispose(T target);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<Verify>d__70`1")]
public Task`1<VerifyResult> Verify(ValueTask`1<T> task);
    public Task`1<VerifyResult> Throws(Action target);
    private void ScrubInnerVerifier();
    public Task`1<VerifyResult> Throws(Func`1<object> target);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<ThrowsValueTask>d__74")]
public Task`1<VerifyResult> ThrowsValueTask(Func`1<ValueTask> target);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<ThrowsValueTask>d__75`1")]
public Task`1<VerifyResult> ThrowsValueTask(Func`1<ValueTask`1<T>> target);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<ThrowsTask>d__76")]
public Task`1<VerifyResult> ThrowsTask(Func`1<Task> target);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<ThrowsTask>d__77`1")]
public Task`1<VerifyResult> ThrowsTask(Func`1<Task`1<T>> target);
    public Task`1<VerifyResult> VerifyTuple(Expression`1<Func`1<ITuple>> target);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyXml>d__79")]
public Task`1<VerifyResult> VerifyXml(Task`1<string> target);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyXml>d__80")]
public Task`1<VerifyResult> VerifyXml(ValueTask`1<string> target);
    public Task`1<VerifyResult> VerifyXml(string target);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyXml>d__82")]
public Task`1<VerifyResult> VerifyXml(Task`1<Stream> target);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyXml>d__83")]
public Task`1<VerifyResult> VerifyXml(ValueTask`1<Stream> target);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyXml>d__84")]
public Task`1<VerifyResult> VerifyXml(Stream target);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifier/<VerifyXml>d__85")]
private Task`1<VerifyResult> VerifyXml(XmlNode target);
    private Task`1<VerifyResult> VerifyXml(XContainer target);
    private string ConvertValue(SerializationSettings serialization, string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExperimentalAttribute("InnerVerifyChecks")]
public static class VerifyTests.InnerVerifyChecks : object {
    public static Task Run(Assembly assembly);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifyChecks/<Run>d__1")]
internal static Task Run(string directory);
    internal static List`1<string> GetExtensions(string directory);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifyChecks/<CheckIncorrectlyImportedSnapshots>d__3")]
internal static Task CheckIncorrectlyImportedSnapshots(string solutionDirectory);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifyChecks/<CheckEditorConfig>d__4")]
internal static Task CheckEditorConfig(string solutionDirectory, List`1<string> extensions);
    private static bool HasAllExtensions(List`1<string> extensions, String[] lines);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifyChecks/<CheckGitAttributes>d__6")]
internal static Task CheckGitAttributes(string solutionDirectory, List`1<string> extensions);
    private static string GetPath(string path);
    [AsyncStateMachineAttribute("VerifyTests.InnerVerifyChecks/<CheckGitIgnore>d__8")]
internal static Task CheckGitIgnore(string solutionDirectory);
    private static Task`1<string> ReadText(string path);
    private static Task`1<String[]> ReadLines(string path);
}
public class VerifyTests.JsonAppender : MulticastDelegate {
    public JsonAppender(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Nullable`1<ToAppend> Invoke(IReadOnlyDictionary`2<string, object> context);
    public virtual IAsyncResult BeginInvoke(IReadOnlyDictionary`2<string, object> context, AsyncCallback callback, object object);
    public virtual Nullable`1<ToAppend> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class VerifyTests.Namer : object {
    [NullableAttribute("2")]
private static string assemblyConfig;
    internal bool UniqueForRuntime;
    internal bool UniqueForTargetFramework;
    [NullableAttribute("2")]
internal FrameworkNameVersion UniqueForTargetFrameworkName;
    internal bool UniqueForAssemblyConfiguration;
    [NullableAttribute("2")]
internal string UniqueForAssemblyConfigurationValue;
    internal bool UniqueForRuntimeAndVersion;
    internal bool UniqueForTargetFrameworkAndVersion;
    internal bool UniqueForArchitecture;
    internal bool UniqueForOSPlatform;
    [NullableAttribute("2")]
private static string targetFrameworkName;
    [NullableAttribute("2")]
private static string targetFrameworkNameAndVersion;
    [CompilerGeneratedAttribute]
private static string <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <RuntimeAndVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <Architecture>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OperatingSystemPlatform>k__BackingField;
    public static string AssemblyConfig { get; }
    public static string TargetFrameworkNameAndVersion { get; }
    public static string TargetFrameworkName { get; }
    public static string Runtime { get; }
    public static string RuntimeAndVersion { get; }
    public static string Architecture { get; }
    public static string OperatingSystemPlatform { get; }
    private static Namer();
    internal Namer(Namer namer);
    public static string get_AssemblyConfig();
    internal static void UseAssembly(Assembly assembly);
    public static string GetSimpleFrameworkName(FrameworkName name);
    internal bool ResolveUniqueForRuntime();
    internal bool ResolveUniqueForTargetFramework();
    internal void SetUniqueForAssemblyFrameworkName(Assembly assembly);
    [NullableContextAttribute("2")]
internal FrameworkNameVersion ResolveUniqueForTargetFrameworkName();
    internal bool ResolveUniqueForAssemblyConfiguration();
    internal void SetUniqueForAssemblyConfiguration(Assembly assembly);
    [NullableContextAttribute("2")]
internal string ResolveUniqueForAssemblyConfigurationValue();
    internal bool ResolveUniqueForRuntimeAndVersion();
    internal bool ResolveUniqueForTargetFrameworkAndVersion();
    internal bool ResolveUniqueForArchitecture();
    internal bool ResolveUniqueForOSPlatform();
    public static string get_TargetFrameworkNameAndVersion();
    public static string get_TargetFrameworkName();
    private static string GetOSPlatform();
    [CompilerGeneratedAttribute]
public static string get_Runtime();
    [CompilerGeneratedAttribute]
public static string get_RuntimeAndVersion();
    [CompilerGeneratedAttribute]
public static string get_Architecture();
    [CompilerGeneratedAttribute]
public static string get_OperatingSystemPlatform();
    internal static ValueTuple`2<string, Version> GetRuntimeAndVersion();
}
public class VerifyTests.ParameterToName`1 : MulticastDelegate {
    public ParameterToName`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual string Invoke(T parameter);
    public virtual IAsyncResult BeginInvoke(T parameter, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("Directory = {Directory} | TypeName = {TypeName} | MethodName = {MethodName}")]
public class VerifyTests.PathInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <Directory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    public string Directory { get; }
    public string TypeName { get; }
    public string MethodName { get; }
    public PathInfo(string directory, string typeName, string methodName);
    [CompilerGeneratedAttribute]
public string get_Directory();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [NullableContextAttribute("1")]
public static PathInfo DeriveDefault(string sourceFile, string projectDirectory, Type type, MethodInfo method);
    [NullableContextAttribute("1")]
internal static PathInfo DeriveDefault(string sourceFile, string projectDirectory, string typeName, string methodName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class VerifyTests.Recording : object {
    private static List`1<string> ignored;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static AsyncLocal`1<State> asyncLocal;
    private static ConcurrentDictionary`2<string, State> namedState;
    private static Recording();
    public static void IgnoreNames(String[] names);
    public static bool IsIgnored(string name);
    public static void Add(string name, object item);
    public static bool NameExists(string name);
    public static void TryAdd(string name, object item);
    public static bool IsRecording();
    public static IReadOnlyCollection`1<ToAppend> Stop();
    [NullableContextAttribute("2")]
public static bool TryStop(IReadOnlyCollection`1& recorded);
    private static State CurrentState(string caller);
    public static IDisposable Start();
    public static void Pause();
    public static void TryPause();
    public static void Resume();
    public static void TryResume();
    public static void Clear();
    public static void TryClear();
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<string, IReadOnlyList`1<object>> ToDictionary(IEnumerable`1<ToAppend> values);
    public static void Add(string identifier, string name, object item);
    public static void TryAdd(string identifier, string name, object item);
    public static bool IsRecording(string identifier);
    public static IReadOnlyCollection`1<ToAppend> Stop(string identifier);
    public static bool TryStop(string identifier, IReadOnlyCollection`1& recorded);
    private static State CurrentStateNamed(string identifier, string caller);
    public static IDisposable Start(string identifier);
    public static void Pause(string identifier);
    public static void TryPause(string identifier);
    public static void Resume(string identifier);
    public static void TryResume(string identifier);
    public static void Clear(string identifier);
    public static void TryClear(string identifier);
}
public enum VerifyTests.ScrubberLocation : Enum {
    public int value__;
    public static ScrubberLocation First;
    public static ScrubberLocation Last;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class VerifyTests.Scrubbers : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<FrozenDictionary`2<string, string>, FrozenDictionary`2<string, string>> machineNameReplacements;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueTuple`2<FrozenDictionary`2<string, string>, FrozenDictionary`2<string, string>> userNameReplacements;
    private static Char[] validWrappingChars;
    private static Scrubbers();
    internal static void ResetReplacements(string machineName, string userName);
    private static ValueTuple`2<FrozenDictionary`2<string, string>, FrozenDictionary`2<string, string>> CreateWrappedReplacements(string toReplace, string toReplaceWith);
    public static void ScrubMachineName(StringBuilder builder);
    public static void ScrubUserName(StringBuilder builder);
    private static void PerformReplacements(StringBuilder builder, ValueTuple`2<IReadOnlyDictionary`2<string, string>, IReadOnlyDictionary`2<string, string>> replacements);
    public static string ScrubStackTrace(string stackTrace, bool removeParams);
    [NullableContextAttribute("0")]
private static void WriteReplacePlus(StringBuilder builder, ReadOnlySpan`1<char> span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class VerifyTests.SettingsTask : object {
    [NullableAttribute("2")]
private VerifySettings settings;
    private Func`2<VerifySettings, Task`1<VerifyResult>> buildTask;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Task`1<VerifyResult> task;
    public VerifySettings CurrentSettings { get; }
    public SettingsTask(VerifySettings settings, Func`2<VerifySettings, Task`1<VerifyResult>> buildTask);
    public SettingsTask AddNamedDate(DateOnly value, string name);
    public SettingsTask AddNamedTime(TimeOnly value, string name);
    public SettingsTask AddNamedDateTime(DateTime value, string name);
    public SettingsTask AddNamedDateTimeOffset(DateTimeOffset value, string name);
    public SettingsTask AddNamedGuid(Guid value, string name);
    public SettingsTask AddExtraSettings(Action`1<JsonSerializerSettings> action);
    public SettingsTask AppendValue(string name, object data);
    public SettingsTask AppendValues(IEnumerable`1<KeyValuePair`2<string, object>> values);
    public SettingsTask AppendValues(KeyValuePair`2[] values);
    public SettingsTask IgnoreParameters(String[] parameterNames);
    public SettingsTask IgnoreParametersForVerified(Object[] parameters);
    public SettingsTask UseParameters(Object[] parameters);
    public SettingsTask UseParameters(T parameter);
    public SettingsTask UseParameters(T[] parameters);
    public SettingsTask UseStreamComparer(StreamCompare compare);
    public SettingsTask UseStringComparer(StringCompare compare);
    public SettingsTask DisableDiff();
    public SettingsTask UniqueForRuntime();
    public SettingsTask UniqueForTargetFramework();
    public SettingsTask UniqueForTargetFrameworkAndVersion();
    public SettingsTask UniqueForAssemblyConfiguration();
    public SettingsTask UniqueForTargetFramework(Assembly assembly);
    public SettingsTask UniqueForTargetFrameworkAndVersion(Assembly assembly);
    public SettingsTask UniqueForAssemblyConfiguration(Assembly assembly);
    public SettingsTask DisableRequireUniquePrefix();
    public SettingsTask UseMethodName(string name);
    public SettingsTask UseDirectory(string directory);
    public SettingsTask UseFileName(string fileName);
    public SettingsTask UseUniqueDirectory();
    public SettingsTask UseTypeName(string name);
    public SettingsTask UniqueForRuntimeAndVersion();
    public SettingsTask UseHashedParameters(Object[] parameters);
    public SettingsTask HashParameters();
    public SettingsTask UniqueForArchitecture();
    public SettingsTask UniqueForOSPlatform();
    public SettingsTask IgnoreStackTrace();
    public SettingsTask AutoVerify(bool includeBuildServer);
    public SettingsTask AutoVerify(AutoVerify autoVerify, bool includeBuildServer);
    public SettingsTask UseTextForParameters(string parametersText);
    public SettingsTask UseSplitModeForUniqueDirectory();
    public SettingsTask DontUseSplitModeForUniqueDirectory();
    public VerifySettings get_CurrentSettings();
    public Task`1<VerifyResult> ToTask();
    public ConfiguredTaskAwaitable`1<VerifyResult> ConfigureAwait(bool continueOnCapturedContext);
    public TaskAwaiter`1<VerifyResult> GetAwaiter();
    public static Task`1<VerifyResult> op_Implicit(SettingsTask settingsTask);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public SettingsTask AddScrubber(Action`1<StringBuilder> scrubber, ScrubberLocation location);
    public SettingsTask AddScrubber(string extension, Action`1<StringBuilder> scrubber, ScrubberLocation location);
    public SettingsTask ScrubInlineGuids(ScrubberLocation location);
    public SettingsTask ScrubInlineGuids(string extension, ScrubberLocation location);
    public SettingsTask DisableDateCounting();
    public SettingsTask ScrubInlineDateTimes(string format, CultureInfo culture, ScrubberLocation location);
    public SettingsTask ScrubInlineDateTimeOffsets(string format, CultureInfo culture, ScrubberLocation location);
    public SettingsTask ScrubInlineDates(string format, CultureInfo culture, ScrubberLocation location);
    public SettingsTask ScrubMachineName(ScrubberLocation location);
    public SettingsTask ScrubMachineName(string extension, ScrubberLocation location);
    public SettingsTask ScrubUserName(ScrubberLocation location);
    public SettingsTask ScrubUserName(string extension, ScrubberLocation location);
    public SettingsTask ScrubLinesContaining(StringComparison comparison, String[] stringToMatch);
    public SettingsTask ScrubLinesContaining(string extension, StringComparison comparison, String[] stringToMatch);
    public SettingsTask ScrubLinesContaining(StringComparison comparison, ScrubberLocation location, String[] stringToMatch);
    public SettingsTask ScrubLinesContaining(string extension, StringComparison comparison, ScrubberLocation location, String[] stringToMatch);
    public SettingsTask ScrubLines(Func`2<string, bool> removeLine, ScrubberLocation location);
    public SettingsTask ScrubLines(string extension, Func`2<string, bool> removeLine, ScrubberLocation location);
    public SettingsTask ScrubLinesWithReplace(Func`2<string, string> replaceLine, ScrubberLocation location);
    public SettingsTask ScrubLinesWithReplace(string extension, Func`2<string, string> replaceLine, ScrubberLocation location);
    public SettingsTask ScrubEmptyLines(ScrubberLocation location);
    public SettingsTask ScrubEmptyLines(string extension, ScrubberLocation location);
    public SettingsTask ScrubLinesContaining(String[] stringToMatch);
    public SettingsTask ScrubLinesContaining(ScrubberLocation location, String[] stringToMatch);
    public SettingsTask ScrubLinesContaining(string extension, ScrubberLocation location, String[] stringToMatch);
    public SettingsTask DontScrubGuids();
    public SettingsTask UseStrictJson();
    public SettingsTask DontScrubDateTimes();
    public SettingsTask DontSortDictionaries();
    public SettingsTask OrderEnumerableBy(Func`2<T, object> keySelector);
    public SettingsTask OrderEnumerableByDescending(Func`2<T, object> keySelector);
    public SettingsTask IncludeObsoletes();
    public SettingsTask DontIgnoreEmptyCollections();
    public SettingsTask IgnoreMembers(Expression`1[] expressions);
    public SettingsTask ScrubMembers(Expression`1[] expressions);
    public SettingsTask IgnoreMember(Expression`1<Func`2<T, object>> expression);
    public SettingsTask ScrubMember(Expression`1<Func`2<T, object>> expression);
    public SettingsTask IgnoreMembers(String[] names);
    public SettingsTask ScrubMembers(String[] names);
    public SettingsTask IgnoreMember(string name);
    public SettingsTask ScrubMember(string name);
    public SettingsTask IgnoreMembers(Type declaringType, String[] names);
    public SettingsTask ScrubMembers(Type declaringType, String[] names);
    public SettingsTask IgnoreMember(Type declaringType, string name);
    public SettingsTask ScrubMember(Type declaringType, string name);
    public SettingsTask IgnoreMember(string name);
    public SettingsTask ScrubMember(string name);
    public SettingsTask IgnoreMembers(String[] names);
    public SettingsTask ScrubMembers(String[] names);
    public SettingsTask IgnoreInstance(Func`2<T, bool> shouldIgnore);
    public SettingsTask ScrubInstance(Func`2<T, bool> shouldScrub);
    public SettingsTask IgnoreInstance(Type type, ShouldIgnore shouldIgnore);
    public SettingsTask ScrubInstance(Type type, ShouldScrub shouldScrub);
    public SettingsTask IgnoreMembersWithType();
    public SettingsTask ScrubMembersWithType();
    public SettingsTask AlwaysIncludeMembersWithType();
    public SettingsTask IgnoreMembersWithType(Type type);
    public SettingsTask ScrubMembersWithType(Type type);
    public SettingsTask AlwaysIncludeMembersWithType(Type type);
    public SettingsTask IgnoreMembersThatThrow();
    public SettingsTask IgnoreMembersThatThrow(Func`2<Exception, bool> item);
    public SettingsTask IgnoreMembersThatThrow(Func`2<T, bool> item);
    public SettingsTask AppendContentAsFile(StringBuilder content, string extension, string name);
    public SettingsTask AppendContentAsFile(string content, string extension, string name);
    public SettingsTask AppendContentAsFile(Byte[] content, string extension, string name);
    public SettingsTask AppendFile(FileStream stream, string name);
    public SettingsTask AppendFile(Stream stream, string extension, string name);
    public SettingsTask AppendFile(string file, string name);
    public SettingsTask AppendFile(FileInfo file, string name);
}
public class VerifyTests.ShouldIgnore : MulticastDelegate {
    public ShouldIgnore(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(object instance);
    public virtual IAsyncResult BeginInvoke(object instance, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class VerifyTests.ShouldScrub : MulticastDelegate {
    public ShouldScrub(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(object instance);
    public virtual IAsyncResult BeginInvoke(object instance, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class VerifyTests.StreamCompare : MulticastDelegate {
    public StreamCompare(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task`1<CompareResult> Invoke(Stream received, Stream verified, IReadOnlyDictionary`2<string, object> context);
    public virtual IAsyncResult BeginInvoke(Stream received, Stream verified, IReadOnlyDictionary`2<string, object> context, AsyncCallback callback, object object);
    public virtual Task`1<CompareResult> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class VerifyTests.StringBuilderExtensions : object {
    [ExtensionAttribute]
public static void FixNewlines(StringBuilder builder);
    [ExtensionAttribute]
public static StringBuilder AppendLineN(StringBuilder builder);
    [ExtensionAttribute]
public static StringBuilder AppendLineN(StringBuilder builder, string value);
    [ExtensionAttribute]
public static StringBuilder AppendLineN(StringBuilder builder, ReadOnlySpan`1<char> value);
    [ExtensionAttribute]
public static StringBuilder AppendLineN(StringBuilder builder, StringBuilder value);
    [ExtensionAttribute]
public static void TrimEnd(StringBuilder builder);
}
public class VerifyTests.StringCompare : MulticastDelegate {
    public StringCompare(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task`1<CompareResult> Invoke(string received, string verified, IReadOnlyDictionary`2<string, object> context);
    public virtual IAsyncResult BeginInvoke(string received, string verified, IReadOnlyDictionary`2<string, object> context, AsyncCallback callback, object object);
    public virtual Task`1<CompareResult> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class VerifyTests.Target : ValueType {
    [NullableAttribute("2")]
private StringBuilder stringBuilderData;
    [NullableAttribute("2")]
private Stream streamData;
    [CompilerGeneratedAttribute]
private string <Extension>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Extension { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public string NameOrTarget { get; }
    public Stream StreamData { get; }
    public bool IsStream { get; }
    public bool IsString { get; }
    public Target(string extension, Stream data, string name);
    public Target(string extension, StringBuilder data, string name);
    public Target(string extension, string data, string name);
    [CompilerGeneratedAttribute]
public string get_Extension();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    public string get_NameOrTarget();
    public Stream get_StreamData();
    public bool get_IsStream();
    public bool get_IsString();
    [NullableContextAttribute("2")]
internal bool TryGetStringBuilder(StringBuilder& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class VerifyTests.ToAppend : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    public string Name { get; }
    public object Data { get; }
    public ToAppend(string name, object data);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public object get_Data();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class VerifyTests.VerifierSettings : object {
    [NullableAttribute("2")]
private static FirstVerify handleOnFirstVerify;
    [NullableAttribute("2")]
private static VerifyDelete handleOnVerifyDelete;
    [NullableAttribute("2")]
private static VerifyMismatch handleOnVerifyMismatch;
    [NullableAttribute("2")]
private static Action beforeVerify;
    [NullableAttribute("2")]
private static Action afterVerify;
    private static Dictionary`2<string, StringCompare> stringComparers;
    private static Dictionary`2<string, StreamCompare> streamComparers;
    [NullableAttribute("2")]
private static StringCompare defaultStringComparer;
    internal static Namer SharedNamer;
    private static Dictionary`2<Type, Func`2<object, string>> parameterToNameLookup;
    internal static bool UseUniqueDirectorySplitMode;
    internal static bool UniquePrefixDisabled;
    internal static Dictionary`2<string, List`1<Action`2<StringBuilder, Counter>>> ExtensionMappedGlobalScrubbers;
    internal static List`1<Action`2<StringBuilder, Counter>> GlobalScrubbers;
    [CompilerGeneratedAttribute]
private static bool <DateCountingEnabled>k__BackingField;
    internal static SerializationSettings serialization;
    private static Dictionary`2<Type, Func`3<object, IReadOnlyDictionary`2<string, object>, AsStringResult>> typeToString;
    [CompilerGeneratedAttribute]
private static bool <StrictJson>k__BackingField;
    internal static bool scrubProjectDir;
    internal static bool scrubSolutionDir;
    internal static bool scrubUserProfile;
    internal static bool sortPropertiesAlphabetically;
    internal static bool sortJsonObjects;
    private static Dictionary`2<Type, Dictionary`2<string, ConvertTargetMember>> membersConverters;
    private static Dictionary`2<string, AsyncConversion`1<Stream>> extensionConverters;
    private static List`1<FileAppender> fileAppenders;
    private static List`1<JsonAppender> jsonAppenders;
    private static List`1<TypeConverter> typedConverters;
    internal static bool hashParameters;
    internal static bool omitContentFromException;
    [NullableAttribute("2")]
internal static GlobalAutoVerify autoVerify;
    private static Encoding encoding;
    [NullableAttribute("2")]
private static Assembly assembly;
    [CompilerGeneratedAttribute]
private static string <ProjectDir>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static string <SolutionDir>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <TargetsMultipleFramework>k__BackingField;
    internal static bool DateCountingEnabled { get; private set; }
    public static bool StrictJson { get; private set; }
    internal static Encoding Encoding { get; private set; }
    [ExperimentalAttribute("VerifyTestsProjectDir")]
public static string ProjectDir { get; private set; }
    [NullableAttribute("2")]
internal static string SolutionDir { get; private set; }
    internal static bool TargetsMultipleFramework { get; private set; }
    private static VerifierSettings();
    public static void OnFirstVerify(FirstVerify firstVerify);
    public static void OnDelete(VerifyDelete verifyDelete);
    internal static Task RunOnFirstVerify(NewResult item, bool autoVerify);
    internal static Task RunOnVerifyDelete(string file, bool autoVerify);
    internal static Task RunOnVerifyMismatch(FilePair item, string message, bool autoVerify);
    public static void OnVerifyMismatch(VerifyMismatch verifyMismatch);
    public static void OnVerify(Action before, Action after);
    internal static void RunBeforeCallbacks();
    internal static void RunAfterCallbacks();
    internal static bool TryGetStreamComparer(string extension, StreamCompare& comparer);
    internal static bool TryGetStringComparer(string extension, StringCompare& comparer);
    public static void RegisterStreamComparer(string extension, StreamCompare compare);
    public static void RegisterStringComparer(string extension, StringCompare compare);
    public static void SetDefaultStringComparer(StringCompare compare);
    public static void AddNamedDate(DateOnly value, string name);
    public static void AddNamedTime(TimeOnly value, string name);
    public static void AddNamedDateTime(DateTime value, string name);
    public static void AddNamedGuid(Guid value, string name);
    public static void AddNamedDateTimeOffset(DateTimeOffset value, string name);
    public static void NameForParameter(ParameterToName`1<T> func);
    public static string GetNameForParameter(object parameter);
    internal static void AppendParameter(object parameter, StringBuilder builder, bool isRoot);
    public static void UniqueForRuntime();
    public static void UseSplitModeForUniqueDirectory();
    public static void UniqueForTargetFramework();
    public static void UniqueForTargetFrameworkAndVersion();
    public static void UniqueForAssemblyConfiguration();
    public static void UniqueForTargetFramework(Assembly assembly);
    public static void UniqueForTargetFrameworkAndVersion(Assembly assembly);
    public static void UniqueForAssemblyConfiguration(Assembly assembly);
    public static void UniqueForRuntimeAndVersion();
    public static void UniqueForArchitecture();
    public static void UniqueForOSPlatform();
    public static void DisableRequireUniquePrefix();
    public static void AddScrubber(string extension, Action`1<StringBuilder> scrubber, ScrubberLocation location);
    public static void AddScrubber(string extension, Action`2<StringBuilder, Counter> scrubber, ScrubberLocation location);
    public static void ScrubLinesContaining(string extension, StringComparison comparison, String[] stringToMatch);
    public static void ScrubLinesContaining(string extension, StringComparison comparison, ScrubberLocation location, String[] stringToMatch);
    public static void ScrubLines(string extension, Func`2<string, bool> removeLine, ScrubberLocation location);
    public static void ScrubEmptyLines(string extension, ScrubberLocation location);
    public static void ScrubInlineGuids(string extension, ScrubberLocation location);
    public static void ScrubLinesWithReplace(string extension, Func`2<string, string> replaceLine, ScrubberLocation location);
    public static void ScrubLinesContaining(string extension, ScrubberLocation location, String[] stringToMatch);
    public static void ScrubMachineName(string extension, ScrubberLocation location);
    public static void ScrubUserName(string extension, ScrubberLocation location);
    public static void AddScrubber(Action`1<StringBuilder> scrubber, ScrubberLocation location);
    public static void AddScrubber(Action`2<StringBuilder, Counter> scrubber, ScrubberLocation location);
    public static void ScrubLinesContaining(StringComparison comparison, String[] stringToMatch);
    public static void ScrubLinesContaining(StringComparison comparison, ScrubberLocation location, String[] stringToMatch);
    public static void ScrubLines(Func`2<string, bool> removeLine, ScrubberLocation location);
    public static void ScrubEmptyLines(ScrubberLocation location);
    [CompilerGeneratedAttribute]
internal static bool get_DateCountingEnabled();
    [CompilerGeneratedAttribute]
private static void set_DateCountingEnabled(bool value);
    public static void DisableDateCounting();
    public static void ScrubInlineDateTimes(string format, CultureInfo culture, ScrubberLocation location);
    public static void ScrubInlineDateTimeOffsets(string format, CultureInfo culture, ScrubberLocation location);
    public static void ScrubInlineDates(string format, CultureInfo culture, ScrubberLocation location);
    public static void ScrubInlineGuids(ScrubberLocation location);
    public static void ScrubLinesWithReplace(Func`2<string, string> replaceLine, ScrubberLocation location);
    public static void ScrubLinesContaining(String[] stringToMatch);
    public static void ScrubLinesContaining(ScrubberLocation location, String[] stringToMatch);
    public static void ScrubMachineName(ScrubberLocation location);
    public static void ScrubUserName(ScrubberLocation location);
    public static bool TryGetToString(object target, Func`3& toString);
    public static void TreatAsString(AsString`1<T> toString);
    internal static void Reset();
    public static void UseStrictJson();
    [CompilerGeneratedAttribute]
public static bool get_StrictJson();
    [CompilerGeneratedAttribute]
private static void set_StrictJson(bool value);
    public static void DontScrubProjectDirectory();
    public static void DontScrubSolutionDirectory();
    public static void DontScrubUserProfile();
    public static void SortPropertiesAlphabetically();
    public static void SortJsonObjects();
    internal static ConvertTargetMember GetMemberConverter(MemberInfo member);
    [NullableContextAttribute("2")]
internal static ConvertTargetMember GetMemberConverter(string name);
    [NullableContextAttribute("2")]
internal static ConvertTargetMember GetMemberConverter(Type declaringType, string name);
    [NullableContextAttribute("2")]
public static void MemberConverter(Expression`1<Func`2<TTarget, TMember>> expression, ConvertTargetMember`2<TTarget, TMember> converter);
    [NullableContextAttribute("2")]
public static void MemberConverter(Expression`1<Func`2<TTarget, TMember>> expression, ConvertMember`1<TMember> converter);
    public static void MemberConverter(Type declaringType, string name, ConvertTargetMember converter);
    public static void MemberConverter(Type declaringType, string name, ConvertMember converter);
    public static void AddExtraSettings(Action`1<JsonSerializerSettings> action);
    public static void AddExtraDateFormat(string format);
    public static void AddExtraTimeFormat(string format);
    [ObsoleteAttribute("Use AddExtraDateTimeFormat instead.")]
public static void AddExtraDatetimeFormat(string format);
    public static void AddExtraDateTimeFormat(string format);
    [ObsoleteAttribute("Use AddExtraDateTimeOffsetFormat instead.")]
public static void AddExtraDatetimeOffsetFormat(string format);
    public static void AddExtraDateTimeOffsetFormat(string format);
    public static void DontScrubGuids();
    public static void DontScrubDateTimes();
    public static void DontSortDictionaries();
    public static void IncludeObsoletes();
    public static void DontIgnoreEmptyCollections();
    public static void IgnoreMembers(Expression`1[] expressions);
    public static void ScrubMembers(Expression`1[] expressions);
    public static void IgnoreMember(Expression`1<Func`2<T, object>> expression);
    public static void ScrubMember(Expression`1<Func`2<T, object>> expression);
    public static void IgnoreMembers(String[] names);
    public static void ScrubMembers(String[] names);
    public static void IgnoreMember(string name);
    public static void ScrubMember(string name);
    public static void IgnoreMembers(Type declaringType, String[] names);
    public static void ScrubMembers(Type declaringType, String[] names);
    public static void IgnoreMember(Type declaringType, string name);
    public static void ScrubMember(Type declaringType, string name);
    public static void IgnoreStackTrace();
    public static void IgnoreMember(string name);
    public static void ScrubMember(string name);
    public static void IgnoreMembers(String[] names);
    public static void ScrubMembers(String[] names);
    public static void IgnoreInstance(Func`2<T, bool> shouldIgnore);
    public static void ScrubInstance(Func`2<T, bool> shouldIgnore);
    [NullableContextAttribute("2")]
public static void OrderEnumerableBy(Func`2<T, object> keySelector);
    [NullableContextAttribute("2")]
public static void OrderEnumerableByDescending(Func`2<T, object> keySelector);
    public static void IgnoreInstance(Type type, ShouldIgnore shouldIgnore);
    public static void ScrubInstance(Type type, ShouldScrub shouldScrub);
    public static void IgnoreMembersWithType();
    public static void ScrubMembersWithType();
    public static void AlwaysIncludeMembersWithType();
    public static void IgnoreMembersWithType(Type type);
    public static void ScrubMembersWithType(Type type);
    public static void AlwaysIncludeMembersWithType(Type type);
    [NullableContextAttribute("0")]
public static void IgnoreMembersThatThrow();
    public static void IgnoreMembersThatThrow(Func`2<Exception, bool> item);
    public static void IgnoreMembersThatThrow(Func`2<T, bool> item);
    internal static bool TryGetExtensionConverter(string extension, AsyncConversion`1& converter);
    internal static bool HasExtensionConverter(string extension);
    public static void RegisterFileConverter(string fromExtension, Conversion`1<Stream> conversion);
    public static void RegisterFileConverter(string fromExtension, AsyncConversion`1<Stream> conversion);
    [IteratorStateMachineAttribute("VerifyTests.VerifierSettings/<GetFileAppenders>d__158")]
internal static IEnumerable`1<Target> GetFileAppenders(VerifySettings settings);
    public static void RegisterFileAppender(FileAppender appender);
    internal static List`1<ToAppend> GetJsonAppenders(VerifySettings settings);
    public static void RegisterJsonAppender(JsonAppender appender);
    internal static bool TryGetTypedConverter(T target, VerifySettings settings, TypeConverter& converter);
    public static void RegisterFileConverter(Conversion`1<T> conversion, CanConvert`1<T> canConvert);
    public static void RegisterFileConverter(AsyncConversion`1<T> conversion, CanConvert`1<T> canConvert);
    public static void RegisterFileConverter(Conversion conversion, CanConvert canConvert);
    public static void RegisterFileConverter(AsyncConversion conversion, CanConvert canConvert);
    private static CanConvert DefaultCanConvert(CanConvert`1<T> canConvert);
    public static void HashParameters();
    public static void OmitContentFromException();
    public static void AutoVerify(bool includeBuildServer);
    public static void AutoVerify(GlobalAutoVerify autoVerify, bool includeBuildServer);
    public static void UseUtf8NoBom();
    public static void UseEncoding(Encoding encoding);
    internal static Encoding get_Encoding();
    private static void set_Encoding(Encoding value);
    public static void InitializePlugins();
    private static string GetLocation();
    private static void ProcessFile(string file);
    internal static bool TryGetType(string file, Type& type);
    internal static string GetTypeName(string assemblyName);
    internal static void InvokeInitialize(Type type);
    [ExtensionAttribute]
private static object DefaultValue(Type type);
    internal static bool GetInitialized(Type type);
    [CompilerGeneratedAttribute]
public static string get_ProjectDir();
    [CompilerGeneratedAttribute]
private static void set_ProjectDir(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static string get_SolutionDir();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private static void set_SolutionDir(string value);
    [CompilerGeneratedAttribute]
internal static bool get_TargetsMultipleFramework();
    [CompilerGeneratedAttribute]
private static void set_TargetsMultipleFramework(bool value);
    public static void AssignTargetAssembly(Assembly assembly);
}
public class VerifyTests.VerifyDelete : MulticastDelegate {
    public VerifyDelete(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task Invoke(string file, bool autoVerify);
    public virtual IAsyncResult BeginInvoke(string file, bool autoVerify, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class VerifyTests.VerifyJsonWriter : JsonTextWriter {
    private StringBuilder builder;
    internal VerifySettings settings;
    internal SerializationSettings serialization;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private Counter <Counter>k__BackingField;
    public IReadOnlyDictionary`2<string, object> Context { get; }
    public Counter Counter { get; }
    public JsonSerializer Serializer { get; }
    internal VerifyJsonWriter(StringBuilder builder, VerifySettings settings, Counter counter);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Context();
    [CompilerGeneratedAttribute]
public Counter get_Counter();
    public void WriteRawValueIfNoStrict(string value);
    [NullableContextAttribute("0")]
public void WriteRawValueIfNoStrict(ReadOnlySpan`1<char> value);
    public void WriteRawValueWithScrubbers(string value);
    [NullableContextAttribute("0")]
public void WriteRawValueWithScrubbers(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("0")]
public virtual void WritePropertyName(ReadOnlySpan`1<char> name, bool escape);
    public virtual void WritePropertyName(string name, bool escape);
    [NullableContextAttribute("2")]
public virtual void WriteValue(string value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(StringBuilder value);
    [NullableContextAttribute("0")]
public virtual void WriteValue(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(Byte[] value);
    public virtual void WriteValue(DateTimeOffset value);
    public virtual void WriteValue(DateTime value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(Guid value);
    public void WriteMember(object target, T value, string name, T defaultIgnore);
    public void WriteMember(object target, object value, string name);
    private void WriteOrSerialize(object converted);
    public void Serialize(object value);
    public JsonSerializer get_Serializer();
}
public class VerifyTests.VerifyMismatch : MulticastDelegate {
    public VerifyMismatch(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Task Invoke(FilePair filePair, string message, bool autoVerify);
    public virtual IAsyncResult BeginInvoke(FilePair filePair, string message, bool autoVerify, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class VerifyTests.VerifyResult : object {
    private IReadOnlyList`1<FilePair> files;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Target>k__BackingField;
    public Exception Exception { get; }
    [NullableAttribute("2")]
public object Target { get; }
    public string Text { get; }
    public IEnumerable`1<string> TextFiles { get; }
    public IEnumerable`1<string> Files { get; }
    internal VerifyResult(IReadOnlyList`1<FilePair> files, object target);
    public Exception get_Exception();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_Target();
    public string get_Text();
    public IEnumerable`1<string> get_TextFiles();
    public IEnumerable`1<string> get_Files();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class VerifyTests.VerifySettings : object {
    [NullableAttribute("2")]
private FirstVerify handleOnFirstVerify;
    [NullableAttribute("2")]
private VerifyDelete handleOnVerifyDelete;
    [NullableAttribute("2")]
private VerifyMismatch handleOnVerifyMismatch;
    [NullableAttribute("2")]
private Action beforeVerify;
    [NullableAttribute("2")]
private Action afterVerify;
    [NullableAttribute("2")]
private StreamCompare streamComparer;
    [NullableAttribute("2")]
private StringCompare stringComparer;
    internal Dictionary`2<DateOnly, string> namedDates;
    internal Dictionary`2<TimeOnly, string> namedTimes;
    internal Dictionary`2<DateTime, string> namedDateTimes;
    internal Dictionary`2<Guid, string> namedGuids;
    internal Dictionary`2<DateTimeOffset, string> namedDateTimeOffsets;
    internal bool diffEnabled;
    [NullableAttribute("2")]
private Object[] parameters;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal HashSet`1<string> ignoredParameters;
    internal bool ignoreParametersForVerified;
    internal bool hashParameters;
    internal Namer Namer;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Directory>k__BackingField;
    [NullableAttribute("2")]
internal string typeName;
    [NullableAttribute("2")]
internal string methodName;
    [NullableAttribute("2")]
internal string fileName;
    internal bool useUniqueDirectory;
    internal bool UniquePrefixDisabled;
    internal Nullable`1<bool> UseUniqueDirectorySplitMode;
    internal Dictionary`2<string, List`1<Action`2<StringBuilder, Counter>>> ExtensionMappedInstanceScrubbers;
    internal List`1<Action`2<StringBuilder, Counter>> InstanceScrubbers;
    internal SerializationSettings serialization;
    private bool isCloned;
    private bool strictJson;
    internal List`1<ToAppend> Appends;
    private bool dateCountingEnable;
    internal List`1<Target> appendedFiles;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, object> <Context>k__BackingField;
    [NullableAttribute("2")]
internal string parametersText;
    [NullableAttribute("2")]
internal AutoVerify autoVerify;
    public bool HasParameters { get; }
    [NullableAttribute("2")]
public string Directory { get; internal set; }
    internal JsonSerializer Serializer { get; }
    public bool StrictJson { get; }
    public bool DateCountingEnable { get; }
    internal string TxtOrJson { get; }
    public Dictionary`2<string, object> Context { get; }
    [NullableContextAttribute("2")]
public VerifySettings(VerifySettings settings);
    public void OnFirstVerify(FirstVerify firstVerify);
    public void OnDelete(VerifyDelete verifyDelete);
    [AsyncStateMachineAttribute("VerifyTests.VerifySettings/<RunOnFirstVerify>d__4")]
internal Task RunOnFirstVerify(NewResult item, bool autoVerify);
    [AsyncStateMachineAttribute("VerifyTests.VerifySettings/<RunOnVerifyDelete>d__6")]
internal Task RunOnVerifyDelete(string file, bool autoVerify);
    [AsyncStateMachineAttribute("VerifyTests.VerifySettings/<RunOnVerifyMismatch>d__7")]
internal Task RunOnVerifyMismatch(FilePair item, string message, bool autoVerify);
    public void OnVerifyMismatch(VerifyMismatch verifyMismatch);
    public void OnVerify(Action before, Action after);
    internal void RunBeforeCallbacks();
    internal void RunAfterCallbacks();
    public void UseStreamComparer(StreamCompare compare);
    public void UseStringComparer(StringCompare compare);
    internal bool TryFindStreamComparer(string extension, StreamCompare& compare);
    internal bool TryFindStringComparer(string extension, StringCompare& compare);
    public void AddNamedDate(DateOnly value, string name);
    public void AddNamedTime(TimeOnly value, string name);
    public void AddNamedDateTime(DateTime value, string name);
    public void AddNamedGuid(Guid value, string name);
    public void AddNamedDateTimeOffset(DateTimeOffset value, string name);
    public void DisableDiff();
    [NullableContextAttribute("2")]
public bool TryGetParameters(Object[]& parameters);
    public bool get_HasParameters();
    public void UseParameters(T[] parameters);
    public void UseParameters(T parameter);
    public void UseParameters(Object[] parameters);
    [ExperimentalAttribute("VerifySetParameters")]
public void SetParameters(Object[] parameters);
    private void ThrowIfParametersTextDefined(string caller);
    public void IgnoreParameters(String[] parameterNames);
    public void IgnoreParametersForVerified(Object[] parameters);
    public void HashParameters();
    public void UseHashedParameters(Object[] parameters);
    public void UniqueForRuntime();
    public void UniqueForTargetFramework();
    public void UniqueForTargetFrameworkAndVersion();
    public void UniqueForAssemblyConfiguration();
    public void UniqueForTargetFramework(Assembly assembly);
    public void UniqueForTargetFrameworkAndVersion(Assembly assembly);
    public void UniqueForAssemblyConfiguration(Assembly assembly);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Directory();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Directory(string value);
    public void UseDirectory(string directory);
    public void UseTypeName(string name);
    public void UseMethodName(string name);
    private void ThrowIfFileNameDefined(string caller);
    public void UseFileName(string fileName);
    private void ThrowIfMethodOrTypeNameDefined();
    public void UseUniqueDirectory();
    public void UniqueForRuntimeAndVersion();
    public void UniqueForArchitecture();
    public void UniqueForOSPlatform();
    public void DisableRequireUniquePrefix();
    public void UseSplitModeForUniqueDirectory();
    public void DontUseSplitModeForUniqueDirectory();
    public void AddScrubber(string extension, Action`1<StringBuilder> scrubber, ScrubberLocation location);
    public void AddScrubber(string extension, Action`2<StringBuilder, Counter> scrubber, ScrubberLocation location);
    public void ScrubMachineName(string extension, ScrubberLocation location);
    public void ScrubUserName(string extension, ScrubberLocation location);
    public void ScrubLinesContaining(string extension, StringComparison comparison, String[] stringToMatch);
    public void ScrubLinesContaining(string extension, StringComparison comparison, ScrubberLocation location, String[] stringToMatch);
    public void ScrubInlineGuids(string extension, ScrubberLocation location);
    public void ScrubLines(string extension, Func`2<string, bool> removeLine, ScrubberLocation location);
    public void ScrubLinesWithReplace(string extension, Func`2<string, string> replaceLine, ScrubberLocation location);
    public void ScrubEmptyLines(string extension, ScrubberLocation location);
    public void ScrubLinesContaining(string extension, ScrubberLocation location, String[] stringToMatch);
    public void ScrubMachineName(ScrubberLocation location);
    public void ScrubUserName(ScrubberLocation location);
    public void AddScrubber(Action`1<StringBuilder> scrubber, ScrubberLocation location);
    public void AddScrubber(Action`2<StringBuilder, Counter> scrubber, ScrubberLocation location);
    public void ScrubLinesContaining(StringComparison comparison, String[] stringToMatch);
    public void ScrubLinesContaining(StringComparison comparison, ScrubberLocation location, String[] stringToMatch);
    public void ScrubInlineGuids(ScrubberLocation location);
    public void ScrubInlineDateTimes(string format, CultureInfo culture, ScrubberLocation location);
    public void ScrubInlineDateTimeOffsets(string format, CultureInfo culture, ScrubberLocation location);
    public void ScrubInlineDates(string format, CultureInfo culture, ScrubberLocation location);
    public void ScrubLines(Func`2<string, bool> removeLine, ScrubberLocation location);
    public void ScrubLinesWithReplace(Func`2<string, string> replaceLine, ScrubberLocation location);
    public void ScrubEmptyLines(ScrubberLocation location);
    public void ScrubLinesContaining(String[] stringToMatch);
    public void ScrubLinesContaining(ScrubberLocation location, String[] stringToMatch);
    private void CloneSettings();
    internal JsonSerializer get_Serializer();
    public void UseStrictJson();
    public bool get_StrictJson();
    public void AppendValue(string name, object data);
    public void AppendValues(IEnumerable`1<KeyValuePair`2<string, object>> values);
    public void AppendValues(KeyValuePair`2[] values);
    public void AddExtraSettings(Action`1<JsonSerializerSettings> action);
    public bool get_DateCountingEnable();
    public void DisableDateCounting();
    public void DontScrubGuids();
    public void DontScrubDateTimes();
    public void DontSortDictionaries();
    public void IgnoreStackTrace();
    public void IncludeObsoletes();
    public void DontIgnoreEmptyCollections();
    public void IgnoreMembers(Expression`1[] expressions);
    public void ScrubMembers(Expression`1[] expressions);
    public void IgnoreMember(Expression`1<Func`2<T, object>> expression);
    public void ScrubMember(Expression`1<Func`2<T, object>> expression);
    public void IgnoreMembers(String[] names);
    public void ScrubMembers(String[] names);
    public void IgnoreMember(string name);
    public void ScrubMember(string name);
    public void IgnoreMembers(Type declaringType, String[] names);
    public void ScrubMembers(Type declaringType, String[] names);
    public void IgnoreMember(Type declaringType, string name);
    public void ScrubMember(Type declaringType, string name);
    public void IgnoreMember(string name);
    public void ScrubMember(string name);
    public void IgnoreMembers(String[] names);
    public void ScrubMembers(String[] names);
    public void IgnoreInstance(Func`2<T, bool> shouldIgnore);
    public void ScrubInstance(Func`2<T, bool> shouldScrub);
    [NullableContextAttribute("2")]
public void OrderEnumerableBy(Func`2<T, object> keySelector);
    [NullableContextAttribute("2")]
public void OrderEnumerableByDescending(Func`2<T, object> keySelector);
    public void IgnoreInstance(Type type, ShouldIgnore shouldIgnore);
    public void ScrubInstance(Type type, ShouldScrub shouldScrub);
    public void IgnoreMembersWithType();
    public void ScrubMembersWithType();
    public void AlwaysIncludeMembersWithType();
    public void IgnoreMembersWithType(Type type);
    public void ScrubMembersWithType(Type type);
    public void AlwaysIncludeMembersWithType(Type type);
    [NullableContextAttribute("0")]
public void IgnoreMembersThatThrow();
    public void IgnoreMembersThatThrow(Func`2<Exception, bool> item);
    public void IgnoreMembersThatThrow(Func`2<T, bool> item);
    public void AppendContentAsFile(string content, string extension, string name);
    public void AppendContentAsFile(StringBuilder content, string extension, string name);
    public void AppendContentAsFile(Byte[] content, string extension, string name);
    public void AppendFile(string file, string name);
    public void AppendFile(FileInfo file, string name);
    public void AppendFile(FileStream stream, string name);
    public void AppendFile(Stream stream, string extension, string name);
    internal string get_TxtOrJson();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, object> get_Context();
    public void UseTextForParameters(string parametersText);
    public void AutoVerify(bool includeBuildServer);
    public void AutoVerify(AutoVerify autoVerify, bool includeBuildServer);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class VerifyTests.WriteOnlyJsonConverter : JsonConverter {
    public bool CanRead { get; }
    public sealed virtual bool get_CanRead();
    public sealed virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public abstract virtual void Write(VerifyJsonWriter writer, object value);
    public sealed virtual object ReadJson(JsonReader reader, Type type, object value, JsonSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class VerifyTests.WriteOnlyJsonConverter`1 : WriteOnlyJsonConverter {
    [NullableAttribute("2")]
private Type nullableType;
    public sealed virtual void Write(VerifyJsonWriter writer, object value);
    public abstract virtual void Write(VerifyJsonWriter writer, T value);
    public sealed virtual bool CanConvert(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class VirtualizedRunHelper : object {
    [CompilerGeneratedAttribute]
private static IEnvironment <Env>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AppearsToBeLocalVirtualizedRun>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Initialized>k__BackingField;
    [NullableAttribute("2")]
private string originalCodeBaseRootAbsolute;
    [NullableAttribute("2")]
private string mappedCodeBaseRootAbsolute;
    private static Char[] separators;
    private static IEnvironment Env { get; internal set; }
    internal bool AppearsToBeLocalVirtualizedRun { get; private set; }
    internal bool Initialized { get; private set; }
    private static char OtherDirectorySeparatorChar { get; }
    public VirtualizedRunHelper(Assembly userAssembly);
    [NullableContextAttribute("2")]
internal VirtualizedRunHelper(string solutionDir, string projectDir);
    private static VirtualizedRunHelper();
    [CompilerGeneratedAttribute]
private static IEnvironment get_Env();
    [CompilerGeneratedAttribute]
internal static void set_Env(IEnvironment value);
    [CompilerGeneratedAttribute]
internal bool get_AppearsToBeLocalVirtualizedRun();
    [CompilerGeneratedAttribute]
private void set_AppearsToBeLocalVirtualizedRun(bool value);
    [CompilerGeneratedAttribute]
internal bool get_Initialized();
    [CompilerGeneratedAttribute]
private void set_Initialized(bool value);
    public string GetMappedBuildPath(string path);
    private bool TryInitializeFromBuildTimePath(string originalCodeBaseRoot, string buildTimePath);
    [NullableContextAttribute("2")]
private static bool InnerTryInitializeFromBuildTimePath(string originalCodeBaseRoot, string buildTimePath, String& mappedCodeBaseRootAbsolute, String& originalCodeBaseRootAbsolute);
    [NullableContextAttribute("2")]
private static bool TryGetRelative(string originalCodeBaseRoot, string buildTimePath, String& codeBaseRootAbsolute, String& baseRootAbsolute);
    [NullableContextAttribute("2")]
private static bool TryFindByCrossSectionOfBuildRunPath(string originalCodeBaseRoot, String& mappedCodeBaseRootAbsolute, String& codeBaseRootAbsolute);
    private static string GetBuildTimePathRelative(string originalCodeBaseRoot, string buildTimePath);
    private static bool AppearsBuiltOnCurrentPlatform(string buildTimePath);
    private static bool TryRemoveDirFromStartOfPath(String& path);
    private static string TryRemoveDirFromEndOfPath(string path);
    private static string CombinePaths(string path1, string path2);
    private static char get_OtherDirectorySeparatorChar();
}
