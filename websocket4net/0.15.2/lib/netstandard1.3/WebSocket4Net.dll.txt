public class WebSocket4Net.ClosedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private short <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reason>k__BackingField;
    public short Code { get; private set; }
    public string Reason { get; private set; }
    public ClosedEventArgs(short code, string reason);
    [CompilerGeneratedAttribute]
public short get_Code();
    [CompilerGeneratedAttribute]
private void set_Code(short value);
    [CompilerGeneratedAttribute]
public string get_Reason();
    [CompilerGeneratedAttribute]
private void set_Reason(string value);
}
public class WebSocket4Net.Command.BadRequest : WebSocketCommandBase {
    private static string m_WebSocketVersion;
    private static String[] m_ValueSeparator;
    public string Name { get; }
    private static BadRequest();
    public virtual void ExecuteCommand(WebSocket session, WebSocketCommandInfo commandInfo);
    public virtual string get_Name();
}
public class WebSocket4Net.Command.Binary : WebSocketCommandBase {
    public string Name { get; }
    public virtual void ExecuteCommand(WebSocket session, WebSocketCommandInfo commandInfo);
    public virtual string get_Name();
}
public class WebSocket4Net.Command.Close : WebSocketCommandBase {
    public string Name { get; }
    public virtual void ExecuteCommand(WebSocket session, WebSocketCommandInfo commandInfo);
    public virtual string get_Name();
}
public class WebSocket4Net.Command.Handshake : WebSocketCommandBase {
    public string Name { get; }
    public virtual void ExecuteCommand(WebSocket session, WebSocketCommandInfo commandInfo);
    public virtual string get_Name();
}
public class WebSocket4Net.Command.Ping : WebSocketCommandBase {
    public string Name { get; }
    public virtual void ExecuteCommand(WebSocket session, WebSocketCommandInfo commandInfo);
    public virtual string get_Name();
}
public class WebSocket4Net.Command.Pong : WebSocketCommandBase {
    public string Name { get; }
    public virtual void ExecuteCommand(WebSocket session, WebSocketCommandInfo commandInfo);
    public virtual string get_Name();
}
public class WebSocket4Net.Command.Text : WebSocketCommandBase {
    public string Name { get; }
    public virtual void ExecuteCommand(WebSocket session, WebSocketCommandInfo commandInfo);
    public virtual string get_Name();
}
public abstract class WebSocket4Net.Command.WebSocketCommandBase : object {
    public string Name { get; }
    public abstract virtual void ExecuteCommand(WebSocket session, WebSocketCommandInfo commandInfo);
    public abstract virtual string get_Name();
}
internal class WebSocket4Net.Common.ArraySegmentEx`1 : object {
    [CompilerGeneratedAttribute]
private T[] <Array>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <From>k__BackingField;
    [CompilerGeneratedAttribute]
private int <To>k__BackingField;
    public T[] Array { get; private set; }
    public int Count { get; private set; }
    public int Offset { get; private set; }
    public int From { get; public set; }
    public int To { get; public set; }
    public ArraySegmentEx`1(T[] array, int offset, int count);
    [CompilerGeneratedAttribute]
public T[] get_Array();
    [CompilerGeneratedAttribute]
private void set_Array(T[] value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
private void set_Offset(int value);
    [CompilerGeneratedAttribute]
public int get_From();
    [CompilerGeneratedAttribute]
public void set_From(int value);
    [CompilerGeneratedAttribute]
public int get_To();
    [CompilerGeneratedAttribute]
public void set_To(int value);
}
public class WebSocket4Net.Common.ArraySegmentList : ArraySegmentList`1<byte> {
    public string Decode(Encoding encoding);
    public string Decode(Encoding encoding, int offset, int length);
    public void DecodeMask(Byte[] mask, int offset, int length);
}
[DefaultMemberAttribute("Item")]
public class WebSocket4Net.Common.ArraySegmentList`1 : object {
    private IList`1<ArraySegmentEx`1<T>> m_Segments;
    private ArraySegmentEx`1<T> m_PrevSegment;
    private int m_PrevSegmentIndex;
    private int m_Count;
    internal IList`1<ArraySegmentEx`1<T>> Segments { get; }
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    public int SegmentCount { get; }
    internal IList`1<ArraySegmentEx`1<T>> get_Segments();
    private void CalculateSegmentsInfo(IList`1<ArraySegmentEx`1<T>> segments);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    private int GetElementInternalIndex(int index, ArraySegmentEx`1& segment);
    internal ArraySegmentEx`1<T> QuickSearchSegment(int from, int to, int index, Int32& segmentIndex);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void RemoveSegmentAt(int index);
    public void AddSegment(T[] array, int offset, int length);
    public void AddSegment(T[] array, int offset, int length, bool toBeCopied);
    public int get_SegmentCount();
    public void ClearSegements();
    public T[] ToArrayData();
    public T[] ToArrayData(int startIndex, int length);
    public void TrimEnd(int trimSize);
    public int SearchLastSegment(SearchMarkState`1<T> state);
    public int CopyTo(T[] to);
    public int CopyTo(T[] to, int srcIndex, int toIndex, int length);
}
public class WebSocket4Net.Common.BinaryCommandInfo : CommandInfo`1<Byte[]> {
    public BinaryCommandInfo(string key, Byte[] data);
}
public class WebSocket4Net.Common.CommandDelegate`2 : MulticastDelegate {
    public CommandDelegate`2(object object, IntPtr method);
    public virtual void Invoke(TClientSession session, TCommandInfo commandInfo);
    public virtual IAsyncResult BeginInvoke(TClientSession session, TCommandInfo commandInfo, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class WebSocket4Net.Common.CommandInfo`1 : object {
    [CompilerGeneratedAttribute]
private TCommandData <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    public TCommandData Data { get; private set; }
    public string Key { get; private set; }
    public CommandInfo`1(string key, TCommandData data);
    [CompilerGeneratedAttribute]
public sealed virtual TCommandData get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(TCommandData value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
}
internal class WebSocket4Net.Common.DelegateCommand`2 : object {
    private CommandDelegate`2<TClientSession, TCommandInfo> m_Execution;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; private set; }
    public DelegateCommand`2(string name, CommandDelegate`2<TClientSession, TCommandInfo> execution);
    public sealed virtual void ExecuteCommand(TClientSession session, TCommandInfo commandInfo);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
}
public interface WebSocket4Net.Common.IClientCommandReader`1 {
    public IClientCommandReader`1<TCommandInfo> NextCommandReader { get; }
    public abstract virtual TCommandInfo GetCommandInfo(Byte[] readBuffer, int offset, int length, Int32& left);
    public abstract virtual IClientCommandReader`1<TCommandInfo> get_NextCommandReader();
}
public interface WebSocket4Net.Common.ICommand {
    public string Name { get; }
    public abstract virtual string get_Name();
}
public interface WebSocket4Net.Common.ICommand`2 {
    public abstract virtual void ExecuteCommand(TSession session, TCommandInfo commandInfo);
}
public interface WebSocket4Net.Common.ICommandInfo {
    public string Key { get; }
    public abstract virtual string get_Key();
}
public interface WebSocket4Net.Common.ICommandInfo`1 {
    public TCommandData Data { get; }
    public abstract virtual TCommandData get_Data();
}
[DefaultMemberAttribute("Item")]
public class WebSocket4Net.Common.StringCommandInfo : CommandInfo`1<string> {
    [CompilerGeneratedAttribute]
private String[] <Parameters>k__BackingField;
    public String[] Parameters { get; private set; }
    public string Item { get; }
    public StringCommandInfo(string key, string data, String[] parameters);
    [CompilerGeneratedAttribute]
public String[] get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(String[] value);
    public string GetFirstParam();
    public string get_Item(int index);
}
public class WebSocket4Net.DataReceivedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    public Byte[] Data { get; private set; }
    public DataReceivedEventArgs(Byte[] data);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(Byte[] value);
}
[ExtensionAttribute]
public static class WebSocket4Net.Extensions : object {
    private static Char[] m_CrCf;
    private static string m_Tab;
    private static char m_Colon;
    private static string m_Space;
    private static string m_ValueSeparator;
    private static Type[] m_SimpleTypes;
    private static Extensions();
    [ExtensionAttribute]
public static void AppendFormatWithCrCf(StringBuilder builder, string format, object arg);
    [ExtensionAttribute]
public static void AppendFormatWithCrCf(StringBuilder builder, string format, Object[] args);
    [ExtensionAttribute]
public static void AppendWithCrCf(StringBuilder builder, string content);
    [ExtensionAttribute]
public static void AppendWithCrCf(StringBuilder builder);
    [ExtensionAttribute]
public static bool ParseMimeHeader(string source, IDictionary`2<string, object> valueContainer, String& verbLine);
    [ExtensionAttribute]
public static TValue GetValue(IDictionary`2<string, object> valueContainer, string name);
    [ExtensionAttribute]
public static TValue GetValue(IDictionary`2<string, object> valueContainer, string name, TValue defaultValue);
    [ExtensionAttribute]
internal static bool IsSimpleType(Type type);
    [ExtensionAttribute]
public static string GetOrigin(Uri uri);
    [ExtensionAttribute]
public static Byte[] ComputeMD5Hash(Byte[] source);
    [ExtensionAttribute]
public static string CalculateChallenge(string source);
}
internal interface WebSocket4Net.IJsonExecutor {
    public Type Type { get; }
    public abstract virtual Type get_Type();
    public abstract virtual void Execute(JsonWebSocket websocket, string token, object param);
}
internal class WebSocket4Net.JsonExecutor`1 : JsonExecutorBase`1<T> {
    private Action`1<T> m_ExecutorAction;
    public JsonExecutor`1(Action`1<T> action);
    public virtual void Execute(JsonWebSocket websocket, string token, object param);
}
internal abstract class WebSocket4Net.JsonExecutorBase`1 : object {
    public Type Type { get; }
    public sealed virtual Type get_Type();
    public abstract virtual void Execute(JsonWebSocket websocket, string token, object param);
}
internal class WebSocket4Net.JsonExecutorFull`1 : JsonExecutorBase`1<T> {
    private Action`3<JsonWebSocket, string, T> m_ExecutorAction;
    public JsonExecutorFull`1(Action`3<JsonWebSocket, string, T> action);
    public virtual void Execute(JsonWebSocket websocket, string token, object param);
}
internal class WebSocket4Net.JsonExecutorWithSender`1 : JsonExecutorBase`1<T> {
    private Action`2<JsonWebSocket, T> m_ExecutorAction;
    public JsonExecutorWithSender`1(Action`2<JsonWebSocket, T> action);
    public virtual void Execute(JsonWebSocket websocket, string token, object param);
}
internal class WebSocket4Net.JsonExecutorWithSenderAndState`1 : JsonExecutorBase`1<T> {
    private Action`3<JsonWebSocket, T, object> m_ExecutorAction;
    private object m_State;
    public JsonExecutorWithSenderAndState`1(Action`3<JsonWebSocket, T, object> action, object state);
    public virtual void Execute(JsonWebSocket websocket, string token, object param);
}
internal class WebSocket4Net.JsonExecutorWithToken`1 : JsonExecutorBase`1<T> {
    private Action`2<string, T> m_ExecutorAction;
    public JsonExecutorWithToken`1(Action`2<string, T> action);
    public virtual void Execute(JsonWebSocket websocket, string token, object param);
}
public class WebSocket4Net.JsonWebSocket : object {
    private WebSocket m_WebSocket;
    private bool m_disposed;
    private EventHandler`1<ErrorEventArgs> m_Error;
    private EventHandler m_Opened;
    private EventHandler m_Closed;
    private static Random m_Random;
    private static string m_QueryTemplateA;
    private static string m_QueryTemplateB;
    private static string m_QueryTemplateC;
    private static string m_QueryKeyTokenTemplate;
    private Dictionary`2<string, IJsonExecutor> m_ExecutorDict;
    private Func`2<object, string> m_JsonSerialzier;
    private Func`3<string, Type, object> m_JsonDeserialzier;
    public bool EnableAutoSendPing { get; public set; }
    public int AutoSendPingInterval { get; public set; }
    public WebSocketState State { get; }
    public int ReceiveBufferSize { get; public set; }
    public SecurityOption Security { get; }
    public JsonWebSocket(string uri);
    public JsonWebSocket(string uri, WebSocketVersion version);
    public JsonWebSocket(string uri, string subProtocol);
    public JsonWebSocket(string uri, List`1<KeyValuePair`2<string, string>> cookies);
    public JsonWebSocket(string uri, string subProtocol, List`1<KeyValuePair`2<string, string>> cookies);
    public JsonWebSocket(string uri, string subProtocol, WebSocketVersion version);
    public JsonWebSocket(string uri, string subProtocol, List`1<KeyValuePair`2<string, string>> cookies, WebSocketVersion version);
    public JsonWebSocket(string uri, string subProtocol, List`1<KeyValuePair`2<string, string>> cookies, List`1<KeyValuePair`2<string, string>> customHeaderItems, string userAgent, WebSocketVersion version);
    public JsonWebSocket(string uri, string subProtocol, List`1<KeyValuePair`2<string, string>> cookies, List`1<KeyValuePair`2<string, string>> customHeaderItems, string userAgent, string origin, WebSocketVersion version);
    public JsonWebSocket(WebSocket websocket);
    private static JsonWebSocket();
    public bool get_EnableAutoSendPing();
    public void set_EnableAutoSendPing(bool value);
    public int get_AutoSendPingInterval();
    public void set_AutoSendPingInterval(int value);
    public WebSocketState get_State();
    private void SubscribeEvents();
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public void Open();
    public void Close();
    public void add_Error(EventHandler`1<ErrorEventArgs> value);
    public void remove_Error(EventHandler`1<ErrorEventArgs> value);
    private void m_WebSocket_Error(object sender, ErrorEventArgs e);
    public void add_Opened(EventHandler value);
    public void remove_Opened(EventHandler value);
    private void m_WebSocket_Opened(object sender, EventArgs e);
    private void m_WebSocket_MessageReceived(object sender, MessageReceivedEventArgs e);
    public void add_Closed(EventHandler value);
    public void remove_Closed(EventHandler value);
    private void m_WebSocket_Closed(object sender, EventArgs e);
    public void On(string name, Action`1<T> executor);
    public void On(string name, Action`2<JsonWebSocket, T> executor);
    public void Send(string name, object content);
    public string Query(string name, object content, Action`1<T> executor);
    public string Query(string name, object content, Action`2<string, T> executor);
    public string Query(string name, object content, Action`2<JsonWebSocket, T> executor);
    public string Query(string name, object content, Action`3<JsonWebSocket, string, T> executor);
    public string Query(string name, object content, Action`3<JsonWebSocket, T, object> executor, object state);
    private string Query(string name, object content, IJsonExecutor executor);
    private void RegisterExecutor(string name, string token, IJsonExecutor executor);
    private IJsonExecutor GetExecutor(string name, string token);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public void ConfigJsonSerialzier(Func`2<object, string> serialzier, Func`3<string, Type, object> deserializer);
    protected virtual string SerializeObject(object target);
    protected virtual object DeserializeObject(string json, Type type);
    public SecurityOption get_Security();
}
public class WebSocket4Net.MessageReceivedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; private set; }
    public MessageReceivedEventArgs(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private void set_Message(string value);
}
public class WebSocket4Net.OpCode : object {
    public static int Handshake;
    public static int Text;
    public static int Binary;
    public static int Close;
    public static int Ping;
    public static int Pong;
    public static int BadRequest;
}
public class WebSocket4Net.Protocol.CloseStatusCodeHybi10 : object {
    [CompilerGeneratedAttribute]
private short <NormalClosure>k__BackingField;
    [CompilerGeneratedAttribute]
private short <GoingAway>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ProtocolError>k__BackingField;
    [CompilerGeneratedAttribute]
private short <NotAcceptableData>k__BackingField;
    [CompilerGeneratedAttribute]
private short <TooLargeFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private short <InvalidUTF8>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ViolatePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ExtensionNotMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private short <UnexpectedCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private short <TLSHandshakeFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private short <NoStatusCode>k__BackingField;
    public short NormalClosure { get; private set; }
    public short GoingAway { get; private set; }
    public short ProtocolError { get; private set; }
    public short NotAcceptableData { get; private set; }
    public short TooLargeFrame { get; private set; }
    public short InvalidUTF8 { get; private set; }
    public short ViolatePolicy { get; private set; }
    public short ExtensionNotMatch { get; private set; }
    public short UnexpectedCondition { get; private set; }
    public short TLSHandshakeFailure { get; private set; }
    public short NoStatusCode { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual short get_NormalClosure();
    [CompilerGeneratedAttribute]
private void set_NormalClosure(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_GoingAway();
    [CompilerGeneratedAttribute]
private void set_GoingAway(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_ProtocolError();
    [CompilerGeneratedAttribute]
private void set_ProtocolError(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_NotAcceptableData();
    [CompilerGeneratedAttribute]
private void set_NotAcceptableData(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_TooLargeFrame();
    [CompilerGeneratedAttribute]
private void set_TooLargeFrame(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_InvalidUTF8();
    [CompilerGeneratedAttribute]
private void set_InvalidUTF8(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_ViolatePolicy();
    [CompilerGeneratedAttribute]
private void set_ViolatePolicy(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_ExtensionNotMatch();
    [CompilerGeneratedAttribute]
private void set_ExtensionNotMatch(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_UnexpectedCondition();
    [CompilerGeneratedAttribute]
private void set_UnexpectedCondition(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_TLSHandshakeFailure();
    [CompilerGeneratedAttribute]
private void set_TLSHandshakeFailure(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_NoStatusCode();
    [CompilerGeneratedAttribute]
private void set_NoStatusCode(short value);
}
public class WebSocket4Net.Protocol.CloseStatusCodeRfc6455 : object {
    [CompilerGeneratedAttribute]
private short <NormalClosure>k__BackingField;
    [CompilerGeneratedAttribute]
private short <GoingAway>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ProtocolError>k__BackingField;
    [CompilerGeneratedAttribute]
private short <NotAcceptableData>k__BackingField;
    [CompilerGeneratedAttribute]
private short <TooLargeFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private short <InvalidUTF8>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ViolatePolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private short <ExtensionNotMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private short <UnexpectedCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private short <TLSHandshakeFailure>k__BackingField;
    [CompilerGeneratedAttribute]
private short <NoStatusCode>k__BackingField;
    public short NormalClosure { get; private set; }
    public short GoingAway { get; private set; }
    public short ProtocolError { get; private set; }
    public short NotAcceptableData { get; private set; }
    public short TooLargeFrame { get; private set; }
    public short InvalidUTF8 { get; private set; }
    public short ViolatePolicy { get; private set; }
    public short ExtensionNotMatch { get; private set; }
    public short UnexpectedCondition { get; private set; }
    public short TLSHandshakeFailure { get; private set; }
    public short NoStatusCode { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual short get_NormalClosure();
    [CompilerGeneratedAttribute]
private void set_NormalClosure(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_GoingAway();
    [CompilerGeneratedAttribute]
private void set_GoingAway(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_ProtocolError();
    [CompilerGeneratedAttribute]
private void set_ProtocolError(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_NotAcceptableData();
    [CompilerGeneratedAttribute]
private void set_NotAcceptableData(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_TooLargeFrame();
    [CompilerGeneratedAttribute]
private void set_TooLargeFrame(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_InvalidUTF8();
    [CompilerGeneratedAttribute]
private void set_InvalidUTF8(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_ViolatePolicy();
    [CompilerGeneratedAttribute]
private void set_ViolatePolicy(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_ExtensionNotMatch();
    [CompilerGeneratedAttribute]
private void set_ExtensionNotMatch(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_UnexpectedCondition();
    [CompilerGeneratedAttribute]
private void set_UnexpectedCondition(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_TLSHandshakeFailure();
    [CompilerGeneratedAttribute]
private void set_TLSHandshakeFailure(short value);
    [CompilerGeneratedAttribute]
public sealed virtual short get_NoStatusCode();
    [CompilerGeneratedAttribute]
private void set_NoStatusCode(short value);
}
internal class WebSocket4Net.Protocol.DraftHybi00DataReader : ReaderBase {
    private Nullable`1<byte> m_Type;
    private int m_TempLength;
    private Nullable`1<int> m_Length;
    private static byte m_ClosingHandshakeType;
    public DraftHybi00DataReader(ReaderBase previousCommandReader);
    public virtual WebSocketCommandInfo GetCommandInfo(Byte[] readBuffer, int offset, int length, Int32& left);
    private void Reset(bool clearBuffer);
}
internal class WebSocket4Net.Protocol.DraftHybi00HandshakeReader : HandshakeReader {
    private int m_ReceivedChallengeLength;
    private int m_ExpectedChallengeLength;
    private WebSocketCommandInfo m_HandshakeCommand;
    private Byte[] m_Challenges;
    public DraftHybi00HandshakeReader(WebSocket websocket);
    private void SetDataReader();
    public virtual WebSocketCommandInfo GetCommandInfo(Byte[] readBuffer, int offset, int length, Int32& left);
}
internal class WebSocket4Net.Protocol.DraftHybi00Processor : ProtocolProcessorBase {
    private static List`1<char> m_CharLib;
    private static List`1<char> m_DigLib;
    private static Random m_Random;
    public static byte StartByte;
    public static byte EndByte;
    public static Byte[] CloseHandshake;
    private Byte[] m_ExpectedChallenge;
    private static string m_Error_ChallengeLengthNotMatch;
    private static string m_Error_ChallengeNotMatch;
    private static string m_Error_InvalidHandshake;
    public bool SupportBinary { get; }
    public bool SupportPingPong { get; }
    private static DraftHybi00Processor();
    public virtual ReaderBase CreateHandshakeReader(WebSocket websocket);
    public virtual bool VerifyHandshake(WebSocket websocket, WebSocketCommandInfo handshakeInfo, String& description);
    public virtual void SendMessage(WebSocket websocket, string message);
    public virtual void SendData(WebSocket websocket, Byte[] data, int offset, int length);
    public virtual void SendData(WebSocket websocket, IList`1<ArraySegment`1<byte>> segments);
    public virtual void SendCloseHandshake(WebSocket websocket, int statusCode, string closeReason);
    public virtual void SendPing(WebSocket websocket, string ping);
    public virtual void SendPong(WebSocket websocket, string pong);
    public virtual void SendHandshake(WebSocket websocket);
    private Byte[] GetResponseSecurityKey(string secKey1, string secKey2, Byte[] secKey3);
    private Byte[] GenerateSecKey();
    private Byte[] GenerateSecKey(int totalLen);
    public virtual bool get_SupportBinary();
    public virtual bool get_SupportPingPong();
}
internal class WebSocket4Net.Protocol.DraftHybi10DataReader : object {
    private List`1<WebSocketDataFrame> m_PreviousFrames;
    private WebSocketDataFrame m_Frame;
    private IDataFramePartReader m_PartReader;
    private int m_LastPartLength;
    public int LeftBufferSize { get; }
    public IClientCommandReader`1<WebSocketCommandInfo> NextCommandReader { get; }
    public int get_LeftBufferSize();
    public sealed virtual IClientCommandReader`1<WebSocketCommandInfo> get_NextCommandReader();
    protected void AddArraySegment(ArraySegmentList segments, Byte[] buffer, int offset, int length, bool isReusableBuffer);
    public sealed virtual WebSocketCommandInfo GetCommandInfo(Byte[] readBuffer, int offset, int length, Int32& left);
}
internal class WebSocket4Net.Protocol.DraftHybi10HandshakeReader : HandshakeReader {
    public DraftHybi10HandshakeReader(WebSocket websocket);
    public virtual WebSocketCommandInfo GetCommandInfo(Byte[] readBuffer, int offset, int length, Int32& left);
}
internal class WebSocket4Net.Protocol.DraftHybi10Processor : ProtocolProcessorBase {
    private static string m_Magic;
    private string m_ExpectedAcceptKey;
    private string m_OriginHeaderName;
    private static Random m_Random;
    private static string m_Error_InvalidHandshake;
    private static string m_Error_SubProtocolNotMatch;
    private static string m_Error_AcceptKeyNotMatch;
    public bool SupportBinary { get; }
    public bool SupportPingPong { get; }
    protected DraftHybi10Processor(WebSocketVersion version, ICloseStatusCode closeStatusCode, string originHeaderName);
    private static DraftHybi10Processor();
    public virtual void SendHandshake(WebSocket websocket);
    public virtual ReaderBase CreateHandshakeReader(WebSocket websocket);
    private void SendMessage(WebSocket websocket, int opCode, string message);
    private Byte[] EncodeDataFrame(int opCode, Byte[] playloadData, int offset, int length);
    private Byte[] EncodeDataFrame(int opCode, bool isFinal, Byte[] playloadData, int offset, int length);
    private void SendDataFragment(WebSocket websocket, int opCode, Byte[] playloadData, int offset, int length);
    public virtual void SendData(WebSocket websocket, Byte[] data, int offset, int length);
    public virtual void SendData(WebSocket websocket, IList`1<ArraySegment`1<byte>> segments);
    public virtual void SendMessage(WebSocket websocket, string message);
    public virtual void SendCloseHandshake(WebSocket websocket, int statusCode, string closeReason);
    public virtual void SendPing(WebSocket websocket, string ping);
    public virtual void SendPong(WebSocket websocket, string pong);
    public virtual bool VerifyHandshake(WebSocket websocket, WebSocketCommandInfo handshakeInfo, String& description);
    public virtual bool get_SupportBinary();
    public virtual bool get_SupportPingPong();
    private void GenerateMask(Byte[] mask, int offset);
    private void MaskData(Byte[] rawData, int offset, int length, Byte[] outputData, int outputOffset, Byte[] mask, int maskOffset);
}
internal abstract class WebSocket4Net.Protocol.FramePartReader.DataFramePartReader : object {
    [CompilerGeneratedAttribute]
private static IDataFramePartReader <FixPartReader>k__BackingField;
    [CompilerGeneratedAttribute]
private static IDataFramePartReader <ExtendedLenghtReader>k__BackingField;
    [CompilerGeneratedAttribute]
private static IDataFramePartReader <MaskKeyReader>k__BackingField;
    [CompilerGeneratedAttribute]
private static IDataFramePartReader <PayloadDataReader>k__BackingField;
    public static IDataFramePartReader NewReader { get; }
    protected static IDataFramePartReader FixPartReader { get; private set; }
    protected static IDataFramePartReader ExtendedLenghtReader { get; private set; }
    protected static IDataFramePartReader MaskKeyReader { get; private set; }
    protected static IDataFramePartReader PayloadDataReader { get; private set; }
    private static DataFramePartReader();
    public abstract virtual int Process(int lastLength, WebSocketDataFrame frame, IDataFramePartReader& nextPartReader);
    public static IDataFramePartReader get_NewReader();
    [CompilerGeneratedAttribute]
protected static IDataFramePartReader get_FixPartReader();
    [CompilerGeneratedAttribute]
private static void set_FixPartReader(IDataFramePartReader value);
    [CompilerGeneratedAttribute]
protected static IDataFramePartReader get_ExtendedLenghtReader();
    [CompilerGeneratedAttribute]
private static void set_ExtendedLenghtReader(IDataFramePartReader value);
    [CompilerGeneratedAttribute]
protected static IDataFramePartReader get_MaskKeyReader();
    [CompilerGeneratedAttribute]
private static void set_MaskKeyReader(IDataFramePartReader value);
    [CompilerGeneratedAttribute]
protected static IDataFramePartReader get_PayloadDataReader();
    [CompilerGeneratedAttribute]
private static void set_PayloadDataReader(IDataFramePartReader value);
}
internal class WebSocket4Net.Protocol.FramePartReader.ExtendedLenghtReader : DataFramePartReader {
    public virtual int Process(int lastLength, WebSocketDataFrame frame, IDataFramePartReader& nextPartReader);
}
internal class WebSocket4Net.Protocol.FramePartReader.FixPartReader : DataFramePartReader {
    public virtual int Process(int lastLength, WebSocketDataFrame frame, IDataFramePartReader& nextPartReader);
}
internal interface WebSocket4Net.Protocol.FramePartReader.IDataFramePartReader {
    public abstract virtual int Process(int lastLength, WebSocketDataFrame frame, IDataFramePartReader& nextPartReader);
}
internal class WebSocket4Net.Protocol.FramePartReader.MaskKeyReader : DataFramePartReader {
    public virtual int Process(int lastLength, WebSocketDataFrame frame, IDataFramePartReader& nextPartReader);
}
internal class WebSocket4Net.Protocol.FramePartReader.PayloadDataReader : DataFramePartReader {
    public virtual int Process(int lastLength, WebSocketDataFrame frame, IDataFramePartReader& nextPartReader);
}
internal class WebSocket4Net.Protocol.HandshakeReader : ReaderBase {
    private static string m_BadRequestPrefix;
    protected static string BadRequestCode;
    protected static Byte[] HeaderTerminator;
    private SearchMarkState`1<byte> m_HeadSeachState;
    [CompilerGeneratedAttribute]
private static WebSocketCommandInfo <DefaultHandshakeCommandInfo>k__BackingField;
    protected static WebSocketCommandInfo DefaultHandshakeCommandInfo { get; private set; }
    private static HandshakeReader();
    public HandshakeReader(WebSocket websocket);
    [CompilerGeneratedAttribute]
protected static WebSocketCommandInfo get_DefaultHandshakeCommandInfo();
    [CompilerGeneratedAttribute]
private static void set_DefaultHandshakeCommandInfo(WebSocketCommandInfo value);
    public virtual WebSocketCommandInfo GetCommandInfo(Byte[] readBuffer, int offset, int length, Int32& left);
}
public interface WebSocket4Net.Protocol.ICloseStatusCode {
    public short ExtensionNotMatch { get; }
    public short GoingAway { get; }
    public short InvalidUTF8 { get; }
    public short NormalClosure { get; }
    public short NotAcceptableData { get; }
    public short ProtocolError { get; }
    public short TLSHandshakeFailure { get; }
    public short TooLargeFrame { get; }
    public short UnexpectedCondition { get; }
    public short ViolatePolicy { get; }
    public short NoStatusCode { get; }
    public abstract virtual short get_ExtensionNotMatch();
    public abstract virtual short get_GoingAway();
    public abstract virtual short get_InvalidUTF8();
    public abstract virtual short get_NormalClosure();
    public abstract virtual short get_NotAcceptableData();
    public abstract virtual short get_ProtocolError();
    public abstract virtual short get_TLSHandshakeFailure();
    public abstract virtual short get_TooLargeFrame();
    public abstract virtual short get_UnexpectedCondition();
    public abstract virtual short get_ViolatePolicy();
    public abstract virtual short get_NoStatusCode();
}
public interface WebSocket4Net.Protocol.IProtocolProcessor {
    public bool SupportBinary { get; }
    public bool SupportPingPong { get; }
    public ICloseStatusCode CloseStatusCode { get; }
    public WebSocketVersion Version { get; }
    public abstract virtual void SendHandshake(WebSocket websocket);
    public abstract virtual bool VerifyHandshake(WebSocket websocket, WebSocketCommandInfo handshakeInfo, String& description);
    public abstract virtual ReaderBase CreateHandshakeReader(WebSocket websocket);
    public abstract virtual void SendMessage(WebSocket websocket, string message);
    public abstract virtual void SendData(WebSocket websocket, Byte[] data, int offset, int length);
    public abstract virtual void SendData(WebSocket websocket, IList`1<ArraySegment`1<byte>> segments);
    public abstract virtual void SendCloseHandshake(WebSocket websocket, int statusCode, string closeReason);
    public abstract virtual void SendPing(WebSocket websocket, string ping);
    public abstract virtual void SendPong(WebSocket websocket, string pong);
    public abstract virtual bool get_SupportBinary();
    public abstract virtual bool get_SupportPingPong();
    public abstract virtual ICloseStatusCode get_CloseStatusCode();
    public abstract virtual WebSocketVersion get_Version();
}
internal abstract class WebSocket4Net.Protocol.ProtocolProcessorBase : object {
    protected static string HeaderItemFormat;
    [CompilerGeneratedAttribute]
private ICloseStatusCode <CloseStatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private WebSocketVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionTag>k__BackingField;
    private static Char[] s_SpaceSpliter;
    public bool SupportBinary { get; }
    public bool SupportPingPong { get; }
    public ICloseStatusCode CloseStatusCode { get; private set; }
    public WebSocketVersion Version { get; private set; }
    protected string VersionTag { get; private set; }
    public ProtocolProcessorBase(WebSocketVersion version, ICloseStatusCode closeStatusCode);
    private static ProtocolProcessorBase();
    public abstract virtual void SendHandshake(WebSocket websocket);
    public abstract virtual ReaderBase CreateHandshakeReader(WebSocket websocket);
    public abstract virtual bool VerifyHandshake(WebSocket websocket, WebSocketCommandInfo handshakeInfo, String& description);
    public abstract virtual void SendMessage(WebSocket websocket, string message);
    public abstract virtual void SendCloseHandshake(WebSocket websocket, int statusCode, string closeReason);
    public abstract virtual void SendPing(WebSocket websocket, string ping);
    public abstract virtual void SendPong(WebSocket websocket, string pong);
    public abstract virtual void SendData(WebSocket websocket, Byte[] data, int offset, int length);
    public abstract virtual void SendData(WebSocket websocket, IList`1<ArraySegment`1<byte>> segments);
    public abstract virtual bool get_SupportBinary();
    public abstract virtual bool get_SupportPingPong();
    [CompilerGeneratedAttribute]
public sealed virtual ICloseStatusCode get_CloseStatusCode();
    [CompilerGeneratedAttribute]
private void set_CloseStatusCode(ICloseStatusCode value);
    [CompilerGeneratedAttribute]
public sealed virtual WebSocketVersion get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(WebSocketVersion value);
    [CompilerGeneratedAttribute]
protected string get_VersionTag();
    [CompilerGeneratedAttribute]
private void set_VersionTag(string value);
    protected virtual bool ValidateVerbLine(string verbLine);
}
internal class WebSocket4Net.Protocol.ProtocolProcessorFactory : object {
    private IProtocolProcessor[] m_OrderedProcessors;
    public ProtocolProcessorFactory(IProtocolProcessor[] processors);
    public IProtocolProcessor GetProcessorByVersion(WebSocketVersion version);
    public IProtocolProcessor GetPreferedProcessorFromAvialable(Int32[] versions);
}
public abstract class WebSocket4Net.Protocol.ReaderBase : object {
    [CompilerGeneratedAttribute]
private WebSocket <WebSocket>k__BackingField;
    private ArraySegmentList m_BufferSegments;
    [CompilerGeneratedAttribute]
private IClientCommandReader`1<WebSocketCommandInfo> <NextCommandReader>k__BackingField;
    protected WebSocket WebSocket { get; private set; }
    protected ArraySegmentList BufferSegments { get; }
    public IClientCommandReader`1<WebSocketCommandInfo> NextCommandReader { get; internal set; }
    public ReaderBase(WebSocket websocket);
    public ReaderBase(ReaderBase previousCommandReader);
    [CompilerGeneratedAttribute]
protected WebSocket get_WebSocket();
    [CompilerGeneratedAttribute]
private void set_WebSocket(WebSocket value);
    protected ArraySegmentList get_BufferSegments();
    public abstract virtual WebSocketCommandInfo GetCommandInfo(Byte[] readBuffer, int offset, int length, Int32& left);
    [CompilerGeneratedAttribute]
public sealed virtual IClientCommandReader`1<WebSocketCommandInfo> get_NextCommandReader();
    [CompilerGeneratedAttribute]
internal void set_NextCommandReader(IClientCommandReader`1<WebSocketCommandInfo> value);
    protected void AddArraySegment(Byte[] buffer, int offset, int length);
    protected void ClearBufferSegments();
}
internal class WebSocket4Net.Protocol.Rfc6455Processor : DraftHybi10Processor {
}
public class WebSocket4Net.Protocol.WebSocketDataFrame : object {
    private ArraySegmentList m_InnerData;
    private long m_ActualPayloadLength;
    [CompilerGeneratedAttribute]
private Byte[] <MaskKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ExtensionData>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <ApplicationData>k__BackingField;
    public ArraySegmentList InnerData { get; }
    public bool IsControlFrame { get; }
    public bool FIN { get; }
    public bool RSV1 { get; }
    public bool RSV2 { get; }
    public bool RSV3 { get; }
    public sbyte OpCode { get; }
    public bool HasMask { get; }
    public sbyte PayloadLenght { get; }
    public long ActualPayloadLength { get; }
    public Byte[] MaskKey { get; public set; }
    public Byte[] ExtensionData { get; public set; }
    public Byte[] ApplicationData { get; public set; }
    public int Length { get; }
    public WebSocketDataFrame(ArraySegmentList data);
    public ArraySegmentList get_InnerData();
    public bool get_IsControlFrame();
    public bool get_FIN();
    public bool get_RSV1();
    public bool get_RSV2();
    public bool get_RSV3();
    public sbyte get_OpCode();
    public bool get_HasMask();
    public sbyte get_PayloadLenght();
    public long get_ActualPayloadLength();
    [CompilerGeneratedAttribute]
public Byte[] get_MaskKey();
    [CompilerGeneratedAttribute]
public void set_MaskKey(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_ExtensionData();
    [CompilerGeneratedAttribute]
public void set_ExtensionData(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_ApplicationData();
    [CompilerGeneratedAttribute]
public void set_ApplicationData(Byte[] value);
    public int get_Length();
    public void Clear();
}
public class WebSocket4Net.WebSocket : object {
    private TaskCompletionSource`1<bool> m_OpenTaskSrc;
    private TaskCompletionSource`1<bool> m_CloseTaskSrc;
    [CompilerGeneratedAttribute]
private TcpClientSession <Client>k__BackingField;
    private EndPoint m_RemoteEndPoint;
    [CompilerGeneratedAttribute]
private WebSocketVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastActiveTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableAutoSendPing>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AutoSendPingInterval>k__BackingField;
    protected static string UserAgentKey;
    [CompilerGeneratedAttribute]
private IProtocolProcessor <ProtocolProcessor>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <TargetUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubProtocol>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyValuePair`2<string, string>> <Cookies>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<KeyValuePair`2<string, string>> <CustomHeaderItems>k__BackingField;
    public static int DefaultReceiveBufferSize;
    private int m_StateCode;
    [CompilerGeneratedAttribute]
private bool <Handshaked>k__BackingField;
    [CompilerGeneratedAttribute]
private IProxyConnector <Proxy>k__BackingField;
    private EndPoint m_HttpConnectProxy;
    [CompilerGeneratedAttribute]
private IClientCommandReader`1<WebSocketCommandInfo> <CommandReader>k__BackingField;
    private Dictionary`2<string, ICommand`2<WebSocket, WebSocketCommandInfo>> m_CommandDict;
    private static ProtocolProcessorFactory m_ProtocolProcessorFactory;
    [CompilerGeneratedAttribute]
private bool <NotSpecifiedVersion>k__BackingField;
    private Timer m_WebSocketTimer;
    [CompilerGeneratedAttribute]
private string <LastPongResponse>k__BackingField;
    private string m_LastPingRequest;
    private static string m_UriScheme;
    private static string m_UriPrefix;
    private static string m_SecureUriScheme;
    private static int m_SecurePort;
    private static string m_SecureUriPrefix;
    [CompilerGeneratedAttribute]
private string <HandshakeHost>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Origin>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoDelay>k__BackingField;
    private SecurityOption m_Security;
    private bool m_Disposed;
    private EventHandler m_Opened;
    private EventHandler`1<MessageReceivedEventArgs> m_MessageReceived;
    private EventHandler`1<DataReceivedEventArgs> m_DataReceived;
    private static string m_NotOpenSendingMessage;
    private ClosedEventArgs m_ClosedArgs;
    private EventHandler m_Closed;
    private EventHandler`1<ErrorEventArgs> m_Error;
    private static List`1<KeyValuePair`2<string, string>> EmptyCookies;
    private SslProtocols m_SecureProtocols;
    internal TcpClientSession Client { get; private set; }
    public WebSocketVersion Version { get; private set; }
    public DateTime LastActiveTime { get; internal set; }
    public bool EnableAutoSendPing { get; public set; }
    public int AutoSendPingInterval { get; public set; }
    internal IProtocolProcessor ProtocolProcessor { get; private set; }
    public bool SupportBinary { get; }
    internal Uri TargetUri { get; private set; }
    internal string SubProtocol { get; private set; }
    internal IDictionary`2<string, object> Items { get; private set; }
    internal List`1<KeyValuePair`2<string, string>> Cookies { get; private set; }
    internal List`1<KeyValuePair`2<string, string>> CustomHeaderItems { get; private set; }
    internal int StateCode { get; }
    public WebSocketState State { get; }
    public bool Handshaked { get; private set; }
    public IProxyConnector Proxy { get; public set; }
    internal EndPoint HttpConnectProxy { get; }
    protected IClientCommandReader`1<WebSocketCommandInfo> CommandReader { get; private set; }
    internal bool NotSpecifiedVersion { get; private set; }
    internal string LastPongResponse { get; internal set; }
    internal string HandshakeHost { get; private set; }
    internal string Origin { get; private set; }
    public bool NoDelay { get; public set; }
    public EndPoint LocalEndPoint { get; public set; }
    public SecurityOption Security { get; }
    public int ReceiveBufferSize { get; public set; }
    private static WebSocket();
    public WebSocket(string uri, string subProtocol, WebSocketVersion version);
    public WebSocket(string uri, string subProtocol, List`1<KeyValuePair`2<string, string>> cookies, List`1<KeyValuePair`2<string, string>> customHeaderItems, string userAgent, string origin, WebSocketVersion version, EndPoint httpConnectProxy, SslProtocols sslProtocols, int receiveBufferSize);
    [AsyncStateMachineAttribute("WebSocket4Net.WebSocket/<OpenAsync>d__2")]
public Task`1<bool> OpenAsync();
    [AsyncStateMachineAttribute("WebSocket4Net.WebSocket/<CloseAsync>d__3")]
public Task`1<bool> CloseAsync();
    private void FinishOpenTask();
    private void FinishCloseTask();
    [CompilerGeneratedAttribute]
internal TcpClientSession get_Client();
    [CompilerGeneratedAttribute]
private void set_Client(TcpClientSession value);
    [CompilerGeneratedAttribute]
public WebSocketVersion get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(WebSocketVersion value);
    [CompilerGeneratedAttribute]
public DateTime get_LastActiveTime();
    [CompilerGeneratedAttribute]
internal void set_LastActiveTime(DateTime value);
    [CompilerGeneratedAttribute]
public bool get_EnableAutoSendPing();
    [CompilerGeneratedAttribute]
public void set_EnableAutoSendPing(bool value);
    [CompilerGeneratedAttribute]
public int get_AutoSendPingInterval();
    [CompilerGeneratedAttribute]
public void set_AutoSendPingInterval(int value);
    [CompilerGeneratedAttribute]
internal IProtocolProcessor get_ProtocolProcessor();
    [CompilerGeneratedAttribute]
private void set_ProtocolProcessor(IProtocolProcessor value);
    public bool get_SupportBinary();
    [CompilerGeneratedAttribute]
internal Uri get_TargetUri();
    [CompilerGeneratedAttribute]
private void set_TargetUri(Uri value);
    [CompilerGeneratedAttribute]
internal string get_SubProtocol();
    [CompilerGeneratedAttribute]
private void set_SubProtocol(string value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, object> get_Items();
    [CompilerGeneratedAttribute]
private void set_Items(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
internal List`1<KeyValuePair`2<string, string>> get_Cookies();
    [CompilerGeneratedAttribute]
private void set_Cookies(List`1<KeyValuePair`2<string, string>> value);
    [CompilerGeneratedAttribute]
internal List`1<KeyValuePair`2<string, string>> get_CustomHeaderItems();
    [CompilerGeneratedAttribute]
private void set_CustomHeaderItems(List`1<KeyValuePair`2<string, string>> value);
    internal int get_StateCode();
    public WebSocketState get_State();
    [CompilerGeneratedAttribute]
public bool get_Handshaked();
    [CompilerGeneratedAttribute]
private void set_Handshaked(bool value);
    [CompilerGeneratedAttribute]
public IProxyConnector get_Proxy();
    [CompilerGeneratedAttribute]
public void set_Proxy(IProxyConnector value);
    internal EndPoint get_HttpConnectProxy();
    [CompilerGeneratedAttribute]
protected IClientCommandReader`1<WebSocketCommandInfo> get_CommandReader();
    [CompilerGeneratedAttribute]
private void set_CommandReader(IClientCommandReader`1<WebSocketCommandInfo> value);
    [CompilerGeneratedAttribute]
internal bool get_NotSpecifiedVersion();
    [CompilerGeneratedAttribute]
private void set_NotSpecifiedVersion(bool value);
    [CompilerGeneratedAttribute]
internal string get_LastPongResponse();
    [CompilerGeneratedAttribute]
internal void set_LastPongResponse(string value);
    [CompilerGeneratedAttribute]
internal string get_HandshakeHost();
    [CompilerGeneratedAttribute]
private void set_HandshakeHost(string value);
    [CompilerGeneratedAttribute]
internal string get_Origin();
    [CompilerGeneratedAttribute]
private void set_Origin(string value);
    [CompilerGeneratedAttribute]
public bool get_NoDelay();
    [CompilerGeneratedAttribute]
public void set_NoDelay(bool value);
    public EndPoint get_LocalEndPoint();
    public void set_LocalEndPoint(EndPoint value);
    public SecurityOption get_Security();
    private EndPoint ResolveUri(string uri, int defaultPort, Int32& port);
    private TcpClientSession CreateClient(string uri);
    private TcpClientSession CreateSecureClient(string uri);
    private void Initialize(string uri, string subProtocol, List`1<KeyValuePair`2<string, string>> cookies, List`1<KeyValuePair`2<string, string>> customHeaderItems, string userAgent, string origin, WebSocketVersion version, EndPoint httpConnectProxy, int receiveBufferSize);
    private void client_DataReceived(object sender, DataEventArgs e);
    private void OnInternalError();
    private void client_Error(object sender, ErrorEventArgs e);
    private void OnInternalClosed();
    private void client_Closed(object sender, EventArgs e);
    private void client_Connected(object sender, EventArgs e);
    internal bool GetAvailableProcessor(Int32[] availableVersions);
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public void Open();
    private static IProtocolProcessor GetProtocolProcessor(WebSocketVersion version);
    private void OnConnected();
    protected internal virtual void OnHandshaked();
    private void OnInternalOpened();
    private void OnPingTimerCallback(object state);
    public void add_Opened(EventHandler value);
    public void remove_Opened(EventHandler value);
    public void add_MessageReceived(EventHandler`1<MessageReceivedEventArgs> value);
    public void remove_MessageReceived(EventHandler`1<MessageReceivedEventArgs> value);
    internal void FireMessageReceived(string message);
    public void add_DataReceived(EventHandler`1<DataReceivedEventArgs> value);
    public void remove_DataReceived(EventHandler`1<DataReceivedEventArgs> value);
    internal void FireDataReceived(Byte[] data);
    private bool EnsureWebSocketOpen();
    public void Send(string message);
    public void Send(Byte[] data, int offset, int length);
    public void Send(IList`1<ArraySegment`1<byte>> segments);
    private void OnClosed();
    public void Close();
    public void Close(string reason);
    public void Close(int statusCode, string reason);
    private void CheckCloseHandshake(object state);
    internal void CloseWithoutHandshake();
    protected void ExecuteCommand(WebSocketCommandInfo commandInfo);
    private void OnDataReceived(Byte[] data, int offset, int length);
    internal void FireError(Exception error);
    public void add_Closed(EventHandler value);
    public void remove_Closed(EventHandler value);
    private void ClearTimer();
    private void FireClosed();
    public void add_Error(EventHandler`1<ErrorEventArgs> value);
    public void remove_Error(EventHandler`1<ErrorEventArgs> value);
    private void OnError(ErrorEventArgs e);
    private void OnError(Exception e);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    private TcpClientSession CreateSecureTcpSession();
}
public class WebSocket4Net.WebSocketCommandInfo : object {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private short <CloseStatusCode>k__BackingField;
    public string Key { get; public set; }
    public Byte[] Data { get; public set; }
    public string Text { get; public set; }
    public short CloseStatusCode { get; private set; }
    public WebSocketCommandInfo(string key);
    public WebSocketCommandInfo(string key, string text);
    public WebSocketCommandInfo(IList`1<WebSocketDataFrame> frames);
    public WebSocketCommandInfo(WebSocketDataFrame frame);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(Byte[] value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public short get_CloseStatusCode();
    [CompilerGeneratedAttribute]
private void set_CloseStatusCode(short value);
}
public class WebSocket4Net.WebSocketContext : object {
}
public enum WebSocket4Net.WebSocketState : Enum {
    public int value__;
    public static WebSocketState None;
    public static WebSocketState Connecting;
    public static WebSocketState Open;
    public static WebSocketState Closing;
    public static WebSocketState Closed;
}
internal static class WebSocket4Net.WebSocketStateConst : object {
    public static int None;
    public static int Connecting;
    public static int Open;
    public static int Closing;
    public static int Closed;
}
public enum WebSocket4Net.WebSocketVersion : Enum {
    public int value__;
    public static WebSocketVersion None;
    public static WebSocketVersion DraftHybi00;
    public static WebSocketVersion DraftHybi10;
    public static WebSocketVersion Rfc6455;
}
