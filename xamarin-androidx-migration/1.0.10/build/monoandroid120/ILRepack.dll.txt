internal class Confuser.Renamer.BAML.AssemblyInfoRecord : SizedBamlRecord {
    [CompilerGeneratedAttribute]
private ushort <AssemblyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyFullName>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort AssemblyId { get; public set; }
    public string AssemblyFullName { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_AssemblyId();
    [CompilerGeneratedAttribute]
public void set_AssemblyId(ushort value);
    [CompilerGeneratedAttribute]
public string get_AssemblyFullName();
    [CompilerGeneratedAttribute]
public void set_AssemblyFullName(string value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.AttributeInfoRecord : SizedBamlRecord {
    [CompilerGeneratedAttribute]
private ushort <AttributeId>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <OwnerTypeId>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <AttributeUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort AttributeId { get; public set; }
    public ushort OwnerTypeId { get; public set; }
    public byte AttributeUsage { get; public set; }
    public string Name { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_AttributeId();
    [CompilerGeneratedAttribute]
public void set_AttributeId(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_OwnerTypeId();
    [CompilerGeneratedAttribute]
public void set_OwnerTypeId(ushort value);
    [CompilerGeneratedAttribute]
public byte get_AttributeUsage();
    [CompilerGeneratedAttribute]
public void set_AttributeUsage(byte value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.BamlBinaryReader : BinaryReader {
    public BamlBinaryReader(Stream stream);
    public int ReadEncodedInt();
}
internal class Confuser.Renamer.BAML.BamlBinaryWriter : BinaryWriter {
    public BamlBinaryWriter(Stream stream);
    public void WriteEncodedInt(int val);
}
internal class Confuser.Renamer.BAML.BamlDocument : List`1<BamlRecord> {
    [CompilerGeneratedAttribute]
private string <DocumentName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Signature>k__BackingField;
    [CompilerGeneratedAttribute]
private BamlVersion <ReaderVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private BamlVersion <UpdaterVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private BamlVersion <WriterVersion>k__BackingField;
    public string DocumentName { get; public set; }
    public string Signature { get; public set; }
    public BamlVersion ReaderVersion { get; public set; }
    public BamlVersion UpdaterVersion { get; public set; }
    public BamlVersion WriterVersion { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DocumentName();
    [CompilerGeneratedAttribute]
public void set_DocumentName(string value);
    [CompilerGeneratedAttribute]
public string get_Signature();
    [CompilerGeneratedAttribute]
public void set_Signature(string value);
    [CompilerGeneratedAttribute]
public BamlVersion get_ReaderVersion();
    [CompilerGeneratedAttribute]
public void set_ReaderVersion(BamlVersion value);
    [CompilerGeneratedAttribute]
public BamlVersion get_UpdaterVersion();
    [CompilerGeneratedAttribute]
public void set_UpdaterVersion(BamlVersion value);
    [CompilerGeneratedAttribute]
public BamlVersion get_WriterVersion();
    [CompilerGeneratedAttribute]
public void set_WriterVersion(BamlVersion value);
}
internal class Confuser.Renamer.BAML.BamlReader : object {
    public static BamlDocument ReadDocument(Stream str);
}
internal abstract class Confuser.Renamer.BAML.BamlRecord : object {
    [CompilerGeneratedAttribute]
private long <Position>k__BackingField;
    public BamlRecordType Type { get; }
    public long Position { get; internal set; }
    public abstract virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public long get_Position();
    [CompilerGeneratedAttribute]
internal void set_Position(long value);
    public abstract virtual void Read(BamlBinaryReader reader);
    public abstract virtual void Write(BamlBinaryWriter writer);
}
internal enum Confuser.Renamer.BAML.BamlRecordType : Enum {
    public byte value__;
    public static BamlRecordType ClrEvent;
    public static BamlRecordType Comment;
    public static BamlRecordType AssemblyInfo;
    public static BamlRecordType AttributeInfo;
    public static BamlRecordType ConstructorParametersStart;
    public static BamlRecordType ConstructorParametersEnd;
    public static BamlRecordType ConstructorParameterType;
    public static BamlRecordType ConnectionId;
    public static BamlRecordType ContentProperty;
    public static BamlRecordType DefAttribute;
    public static BamlRecordType DefAttributeKeyString;
    public static BamlRecordType DefAttributeKeyType;
    public static BamlRecordType DeferableContentStart;
    public static BamlRecordType DefTag;
    public static BamlRecordType DocumentEnd;
    public static BamlRecordType DocumentStart;
    public static BamlRecordType ElementEnd;
    public static BamlRecordType ElementStart;
    public static BamlRecordType EndAttributes;
    public static BamlRecordType KeyElementEnd;
    public static BamlRecordType KeyElementStart;
    public static BamlRecordType LastRecordType;
    public static BamlRecordType LineNumberAndPosition;
    public static BamlRecordType LinePosition;
    public static BamlRecordType LiteralContent;
    public static BamlRecordType NamedElementStart;
    public static BamlRecordType OptimizedStaticResource;
    public static BamlRecordType PIMapping;
    public static BamlRecordType PresentationOptionsAttribute;
    public static BamlRecordType ProcessingInstruction;
    public static BamlRecordType Property;
    public static BamlRecordType PropertyArrayEnd;
    public static BamlRecordType PropertyArrayStart;
    public static BamlRecordType PropertyComplexEnd;
    public static BamlRecordType PropertyComplexStart;
    public static BamlRecordType PropertyCustom;
    public static BamlRecordType PropertyDictionaryEnd;
    public static BamlRecordType PropertyDictionaryStart;
    public static BamlRecordType PropertyListEnd;
    public static BamlRecordType PropertyListStart;
    public static BamlRecordType PropertyStringReference;
    public static BamlRecordType PropertyTypeReference;
    public static BamlRecordType PropertyWithConverter;
    public static BamlRecordType PropertyWithExtension;
    public static BamlRecordType PropertyWithStaticResourceId;
    public static BamlRecordType RoutedEvent;
    public static BamlRecordType StaticResourceEnd;
    public static BamlRecordType StaticResourceId;
    public static BamlRecordType StaticResourceStart;
    public static BamlRecordType StringInfo;
    public static BamlRecordType Text;
    public static BamlRecordType TextWithConverter;
    public static BamlRecordType TextWithId;
    public static BamlRecordType TypeInfo;
    public static BamlRecordType TypeSerializerInfo;
    public static BamlRecordType XmlAttribute;
    public static BamlRecordType XmlnsProperty;
}
internal class Confuser.Renamer.BAML.BamlWriter : object {
    public static void WriteDocument(BamlDocument doc, Stream str);
}
internal class Confuser.Renamer.BAML.ConnectionIdRecord : BamlRecord {
    [CompilerGeneratedAttribute]
private UInt32 <ConnectionId>k__BackingField;
    public BamlRecordType Type { get; }
    public UInt32 ConnectionId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public UInt32 get_ConnectionId();
    [CompilerGeneratedAttribute]
public void set_ConnectionId(UInt32 value);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.ConstructorParametersEndRecord : BamlRecord {
    public BamlRecordType Type { get; }
    public virtual BamlRecordType get_Type();
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.ConstructorParametersStartRecord : BamlRecord {
    public BamlRecordType Type { get; }
    public virtual BamlRecordType get_Type();
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.ConstructorParameterTypeRecord : BamlRecord {
    [CompilerGeneratedAttribute]
private ushort <TypeId>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort TypeId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_TypeId();
    [CompilerGeneratedAttribute]
public void set_TypeId(ushort value);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.ContentPropertyRecord : BamlRecord {
    [CompilerGeneratedAttribute]
private ushort <AttributeId>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort AttributeId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_AttributeId();
    [CompilerGeneratedAttribute]
public void set_AttributeId(ushort value);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.DefAttributeKeyStringRecord : SizedBamlRecord {
    internal UInt32 pos;
    [CompilerGeneratedAttribute]
private ushort <ValueId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Shared>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SharedSet>k__BackingField;
    [CompilerGeneratedAttribute]
private BamlRecord <Record>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort ValueId { get; public set; }
    public bool Shared { get; public set; }
    public bool SharedSet { get; public set; }
    public BamlRecord Record { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_ValueId();
    [CompilerGeneratedAttribute]
public void set_ValueId(ushort value);
    [CompilerGeneratedAttribute]
public bool get_Shared();
    [CompilerGeneratedAttribute]
public void set_Shared(bool value);
    [CompilerGeneratedAttribute]
public bool get_SharedSet();
    [CompilerGeneratedAttribute]
public void set_SharedSet(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual BamlRecord get_Record();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Record(BamlRecord value);
    public sealed virtual void ReadDefer(BamlDocument doc, int index, Func`2<long, BamlRecord> resolve);
    public sealed virtual void WriteDefer(BamlDocument doc, int index, BinaryWriter wtr);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
    private static void NavigateTree(BamlDocument doc, BamlRecordType start, BamlRecordType end, Int32& index);
}
internal class Confuser.Renamer.BAML.DefAttributeKeyTypeRecord : ElementStartRecord {
    internal UInt32 pos;
    [CompilerGeneratedAttribute]
private bool <Shared>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SharedSet>k__BackingField;
    [CompilerGeneratedAttribute]
private BamlRecord <Record>k__BackingField;
    public BamlRecordType Type { get; }
    public bool Shared { get; public set; }
    public bool SharedSet { get; public set; }
    public BamlRecord Record { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public bool get_Shared();
    [CompilerGeneratedAttribute]
public void set_Shared(bool value);
    [CompilerGeneratedAttribute]
public bool get_SharedSet();
    [CompilerGeneratedAttribute]
public void set_SharedSet(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual BamlRecord get_Record();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Record(BamlRecord value);
    public sealed virtual void ReadDefer(BamlDocument doc, int index, Func`2<long, BamlRecord> resolve);
    public sealed virtual void WriteDefer(BamlDocument doc, int index, BinaryWriter wtr);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
    private static void NavigateTree(BamlDocument doc, BamlRecordType start, BamlRecordType end, Int32& index);
}
internal class Confuser.Renamer.BAML.DefAttributeRecord : SizedBamlRecord {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NameId>k__BackingField;
    public BamlRecordType Type { get; }
    public string Value { get; public set; }
    public ushort NameId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public ushort get_NameId();
    [CompilerGeneratedAttribute]
public void set_NameId(ushort value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.DeferableContentStartRecord : BamlRecord {
    private long pos;
    internal UInt32 size;
    [CompilerGeneratedAttribute]
private BamlRecord <Record>k__BackingField;
    public BamlRecordType Type { get; }
    public BamlRecord Record { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual BamlRecord get_Record();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Record(BamlRecord value);
    public sealed virtual void ReadDefer(BamlDocument doc, int index, Func`2<long, BamlRecord> resolve);
    public sealed virtual void WriteDefer(BamlDocument doc, int index, BinaryWriter wtr);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.DocumentEndRecord : BamlRecord {
    public BamlRecordType Type { get; }
    public virtual BamlRecordType get_Type();
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.DocumentStartRecord : BamlRecord {
    [CompilerGeneratedAttribute]
private bool <LoadAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <MaxAsyncRecords>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DebugBaml>k__BackingField;
    public BamlRecordType Type { get; }
    public bool LoadAsync { get; public set; }
    public UInt32 MaxAsyncRecords { get; public set; }
    public bool DebugBaml { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public bool get_LoadAsync();
    [CompilerGeneratedAttribute]
public void set_LoadAsync(bool value);
    [CompilerGeneratedAttribute]
public UInt32 get_MaxAsyncRecords();
    [CompilerGeneratedAttribute]
public void set_MaxAsyncRecords(UInt32 value);
    [CompilerGeneratedAttribute]
public bool get_DebugBaml();
    [CompilerGeneratedAttribute]
public void set_DebugBaml(bool value);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.ElementEndRecord : BamlRecord {
    public BamlRecordType Type { get; }
    public virtual BamlRecordType get_Type();
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.ElementStartRecord : BamlRecord {
    [CompilerGeneratedAttribute]
private ushort <TypeId>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <Flags>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort TypeId { get; public set; }
    public byte Flags { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_TypeId();
    [CompilerGeneratedAttribute]
public void set_TypeId(ushort value);
    [CompilerGeneratedAttribute]
public byte get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(byte value);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal interface Confuser.Renamer.BAML.IBamlDeferRecord {
    public BamlRecord Record { get; public set; }
    public abstract virtual BamlRecord get_Record();
    public abstract virtual void set_Record(BamlRecord value);
    public abstract virtual void ReadDefer(BamlDocument doc, int index, Func`2<long, BamlRecord> resolve);
    public abstract virtual void WriteDefer(BamlDocument doc, int index, BinaryWriter wtr);
}
internal class Confuser.Renamer.BAML.KeyElementEndRecord : BamlRecord {
    public BamlRecordType Type { get; }
    public virtual BamlRecordType get_Type();
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.KeyElementStartRecord : DefAttributeKeyTypeRecord {
    public BamlRecordType Type { get; }
    public virtual BamlRecordType get_Type();
}
internal class Confuser.Renamer.BAML.LineNumberAndPositionRecord : BamlRecord {
    [CompilerGeneratedAttribute]
private UInt32 <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <LinePosition>k__BackingField;
    public BamlRecordType Type { get; }
    public UInt32 LineNumber { get; public set; }
    public UInt32 LinePosition { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public UInt32 get_LineNumber();
    [CompilerGeneratedAttribute]
public void set_LineNumber(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_LinePosition();
    [CompilerGeneratedAttribute]
public void set_LinePosition(UInt32 value);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.LinePositionRecord : BamlRecord {
    [CompilerGeneratedAttribute]
private UInt32 <LinePosition>k__BackingField;
    public BamlRecordType Type { get; }
    public UInt32 LinePosition { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public UInt32 get_LinePosition();
    [CompilerGeneratedAttribute]
public void set_LinePosition(UInt32 value);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.LiteralContentRecord : SizedBamlRecord {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Reserved0>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Reserved1>k__BackingField;
    public BamlRecordType Type { get; }
    public string Value { get; public set; }
    public UInt32 Reserved0 { get; public set; }
    public UInt32 Reserved1 { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public UInt32 get_Reserved0();
    [CompilerGeneratedAttribute]
public void set_Reserved0(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Reserved1();
    [CompilerGeneratedAttribute]
public void set_Reserved1(UInt32 value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.NamedElementStartRecord : ElementStartRecord {
    [CompilerGeneratedAttribute]
private string <RuntimeName>k__BackingField;
    public BamlRecordType Type { get; }
    public string RuntimeName { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public string get_RuntimeName();
    [CompilerGeneratedAttribute]
public void set_RuntimeName(string value);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.OptimizedStaticResourceRecord : BamlRecord {
    [CompilerGeneratedAttribute]
private byte <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ValueId>k__BackingField;
    public BamlRecordType Type { get; }
    public byte Flags { get; public set; }
    public ushort ValueId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public byte get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(byte value);
    [CompilerGeneratedAttribute]
public ushort get_ValueId();
    [CompilerGeneratedAttribute]
public void set_ValueId(ushort value);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.PIMappingRecord : SizedBamlRecord {
    [CompilerGeneratedAttribute]
private string <XmlNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClrNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <AssemblyId>k__BackingField;
    public BamlRecordType Type { get; }
    public string XmlNamespace { get; public set; }
    public string ClrNamespace { get; public set; }
    public ushort AssemblyId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public string get_XmlNamespace();
    [CompilerGeneratedAttribute]
public void set_XmlNamespace(string value);
    [CompilerGeneratedAttribute]
public string get_ClrNamespace();
    [CompilerGeneratedAttribute]
public void set_ClrNamespace(string value);
    [CompilerGeneratedAttribute]
public ushort get_AssemblyId();
    [CompilerGeneratedAttribute]
public void set_AssemblyId(ushort value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.PresentationOptionsAttributeRecord : SizedBamlRecord {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NameId>k__BackingField;
    public BamlRecordType Type { get; }
    public string Value { get; public set; }
    public ushort NameId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public ushort get_NameId();
    [CompilerGeneratedAttribute]
public void set_NameId(ushort value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.PropertyArrayEndRecord : BamlRecord {
    public BamlRecordType Type { get; }
    public virtual BamlRecordType get_Type();
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.PropertyArrayStartRecord : PropertyComplexStartRecord {
    public BamlRecordType Type { get; }
    public virtual BamlRecordType get_Type();
}
internal class Confuser.Renamer.BAML.PropertyComplexEndRecord : BamlRecord {
    public BamlRecordType Type { get; }
    public virtual BamlRecordType get_Type();
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.PropertyComplexStartRecord : BamlRecord {
    [CompilerGeneratedAttribute]
private ushort <AttributeId>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort AttributeId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_AttributeId();
    [CompilerGeneratedAttribute]
public void set_AttributeId(ushort value);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.PropertyCustomRecord : SizedBamlRecord {
    [CompilerGeneratedAttribute]
private ushort <AttributeId>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <SerializerTypeId>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort AttributeId { get; public set; }
    public ushort SerializerTypeId { get; public set; }
    public Byte[] Data { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_AttributeId();
    [CompilerGeneratedAttribute]
public void set_AttributeId(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_SerializerTypeId();
    [CompilerGeneratedAttribute]
public void set_SerializerTypeId(ushort value);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(Byte[] value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.PropertyDictionaryEndRecord : BamlRecord {
    public BamlRecordType Type { get; }
    public virtual BamlRecordType get_Type();
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.PropertyDictionaryStartRecord : PropertyComplexStartRecord {
    public BamlRecordType Type { get; }
    public virtual BamlRecordType get_Type();
}
internal class Confuser.Renamer.BAML.PropertyListEndRecord : BamlRecord {
    public BamlRecordType Type { get; }
    public virtual BamlRecordType get_Type();
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.PropertyListStartRecord : PropertyComplexStartRecord {
    public BamlRecordType Type { get; }
    public virtual BamlRecordType get_Type();
}
internal class Confuser.Renamer.BAML.PropertyRecord : SizedBamlRecord {
    [CompilerGeneratedAttribute]
private ushort <AttributeId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort AttributeId { get; public set; }
    public string Value { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_AttributeId();
    [CompilerGeneratedAttribute]
public void set_AttributeId(ushort value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.PropertyStringReferenceRecord : PropertyComplexStartRecord {
    [CompilerGeneratedAttribute]
private ushort <StringId>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort StringId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_StringId();
    [CompilerGeneratedAttribute]
public void set_StringId(ushort value);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.PropertyTypeReferenceRecord : PropertyComplexStartRecord {
    [CompilerGeneratedAttribute]
private ushort <TypeId>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort TypeId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_TypeId();
    [CompilerGeneratedAttribute]
public void set_TypeId(ushort value);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.PropertyWithConverterRecord : PropertyRecord {
    [CompilerGeneratedAttribute]
private ushort <ConverterTypeId>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort ConverterTypeId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_ConverterTypeId();
    [CompilerGeneratedAttribute]
public void set_ConverterTypeId(ushort value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.PropertyWithExtensionRecord : BamlRecord {
    [CompilerGeneratedAttribute]
private ushort <AttributeId>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <ValueId>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort AttributeId { get; public set; }
    public ushort Flags { get; public set; }
    public ushort ValueId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_AttributeId();
    [CompilerGeneratedAttribute]
public void set_AttributeId(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_ValueId();
    [CompilerGeneratedAttribute]
public void set_ValueId(ushort value);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.PropertyWithStaticResourceIdRecord : StaticResourceIdRecord {
    [CompilerGeneratedAttribute]
private ushort <AttributeId>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort AttributeId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_AttributeId();
    [CompilerGeneratedAttribute]
public void set_AttributeId(ushort value);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.RoutedEventRecord : SizedBamlRecord {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <AttributeId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Reserved1>k__BackingField;
    public BamlRecordType Type { get; }
    public string Value { get; public set; }
    public ushort AttributeId { get; public set; }
    public UInt32 Reserved1 { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public ushort get_AttributeId();
    [CompilerGeneratedAttribute]
public void set_AttributeId(ushort value);
    [CompilerGeneratedAttribute]
public UInt32 get_Reserved1();
    [CompilerGeneratedAttribute]
public void set_Reserved1(UInt32 value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal abstract class Confuser.Renamer.BAML.SizedBamlRecord : BamlRecord {
    public virtual void Read(BamlBinaryReader reader);
    private int SizeofEncodedInt(int val);
    public virtual void Write(BamlBinaryWriter writer);
    protected abstract virtual void ReadData(BamlBinaryReader reader, int size);
    protected abstract virtual void WriteData(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.StaticResourceEndRecord : BamlRecord {
    public BamlRecordType Type { get; }
    public virtual BamlRecordType get_Type();
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.StaticResourceIdRecord : BamlRecord {
    [CompilerGeneratedAttribute]
private ushort <StaticResourceId>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort StaticResourceId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_StaticResourceId();
    [CompilerGeneratedAttribute]
public void set_StaticResourceId(ushort value);
    public virtual void Read(BamlBinaryReader reader);
    public virtual void Write(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.StaticResourceStartRecord : ElementStartRecord {
    public BamlRecordType Type { get; }
    public virtual BamlRecordType get_Type();
}
internal class Confuser.Renamer.BAML.StringInfoRecord : SizedBamlRecord {
    [CompilerGeneratedAttribute]
private ushort <StringId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort StringId { get; public set; }
    public string Value { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_StringId();
    [CompilerGeneratedAttribute]
public void set_StringId(ushort value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.TextRecord : SizedBamlRecord {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public BamlRecordType Type { get; }
    public string Value { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.TextWithConverterRecord : TextRecord {
    [CompilerGeneratedAttribute]
private ushort <ConverterTypeId>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort ConverterTypeId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_ConverterTypeId();
    [CompilerGeneratedAttribute]
public void set_ConverterTypeId(ushort value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.TextWithIdRecord : TextRecord {
    [CompilerGeneratedAttribute]
private ushort <ValueId>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort ValueId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_ValueId();
    [CompilerGeneratedAttribute]
public void set_ValueId(ushort value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.TypeInfoRecord : SizedBamlRecord {
    [CompilerGeneratedAttribute]
private ushort <TypeId>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <AssemblyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeFullName>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort TypeId { get; public set; }
    public ushort AssemblyId { get; public set; }
    public string TypeFullName { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_TypeId();
    [CompilerGeneratedAttribute]
public void set_TypeId(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_AssemblyId();
    [CompilerGeneratedAttribute]
public void set_AssemblyId(ushort value);
    [CompilerGeneratedAttribute]
public string get_TypeFullName();
    [CompilerGeneratedAttribute]
public void set_TypeFullName(string value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.TypeSerializerInfoRecord : TypeInfoRecord {
    [CompilerGeneratedAttribute]
private ushort <SerializerTypeId>k__BackingField;
    public BamlRecordType Type { get; }
    public ushort SerializerTypeId { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public ushort get_SerializerTypeId();
    [CompilerGeneratedAttribute]
public void set_SerializerTypeId(ushort value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal class Confuser.Renamer.BAML.XmlnsPropertyRecord : SizedBamlRecord {
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <XmlNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt16[] <AssemblyIds>k__BackingField;
    public BamlRecordType Type { get; }
    public string Prefix { get; public set; }
    public string XmlNamespace { get; public set; }
    public UInt16[] AssemblyIds { get; public set; }
    public virtual BamlRecordType get_Type();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public void set_Prefix(string value);
    [CompilerGeneratedAttribute]
public string get_XmlNamespace();
    [CompilerGeneratedAttribute]
public void set_XmlNamespace(string value);
    [CompilerGeneratedAttribute]
public UInt16[] get_AssemblyIds();
    [CompilerGeneratedAttribute]
public void set_AssemblyIds(UInt16[] value);
    protected virtual void ReadData(BamlBinaryReader reader, int size);
    protected virtual void WriteData(BamlBinaryWriter writer);
}
internal static class Consts : object {
    public static string MonoVersion;
    public static string MonoCompany;
    public static string MonoProduct;
    public static string MonoCopyright;
    public static string FxVersion;
    public static string FxFileVersion;
    public static string VsVersion;
    public static string VsFileVersion;
    public static string AssemblyI18N;
    public static string AssemblyMicrosoft_VisualStudio;
    public static string AssemblyMicrosoft_VisualStudio_Web;
    public static string AssemblyMicrosoft_VSDesigner;
    public static string AssemblyMono_Http;
    public static string AssemblyMono_Posix;
    public static string AssemblyMono_Security;
    public static string AssemblyMono_Messaging_RabbitMQ;
    public static string AssemblyCorlib;
    public static string AssemblySystem;
    public static string AssemblySystem_Data;
    public static string AssemblySystem_Design;
    public static string AssemblySystem_DirectoryServices;
    public static string AssemblySystem_Drawing;
    public static string AssemblySystem_Drawing_Design;
    public static string AssemblySystem_Messaging;
    public static string AssemblySystem_Security;
    public static string AssemblySystem_ServiceProcess;
    public static string AssemblySystem_Web;
    public static string AssemblySystem_Windows_Forms;
    public static string AssemblySystem_2_0;
    public static string AssemblySystemCore_3_5;
    public static string AssemblySystem_Core;
    public static string WindowsBase_3_0;
    public static string AssemblyWindowsBase;
    public static string AssemblyPresentationCore_3_5;
    public static string AssemblyPresentationFramework_3_5;
}
internal class Fasterflect.ArrayElementGetter : MulticastDelegate {
    public ArrayElementGetter(object object, IntPtr method);
    public virtual object Invoke(object array, int index);
    public virtual IAsyncResult BeginInvoke(object array, int index, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class Fasterflect.ArrayElementSetter : MulticastDelegate {
    public ArrayElementSetter(object object, IntPtr method);
    public virtual void Invoke(object array, int index, object value);
    public virtual IAsyncResult BeginInvoke(object array, int index, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class Fasterflect.ArrayExtensions : object {
    [ExtensionAttribute]
public static object SetElement(object array, long index, object value);
    [ExtensionAttribute]
public static object GetElement(object array, long index);
    [ExtensionAttribute]
public static ArrayElementSetter DelegateForSetElement(Type arrayType);
    [ExtensionAttribute]
public static ArrayElementGetter DelegateForGetElement(Type arrayType);
}
[ExtensionAttribute]
internal static class Fasterflect.AssemblyExtensions : object {
    [ExtensionAttribute]
public static IList`1<Type> Types(Assembly assembly, String[] names);
    [ExtensionAttribute]
public static IList`1<Type> Types(Assembly assembly, Flags bindingFlags, String[] names);
    [ExtensionAttribute]
public static IList`1<Type> TypesImplementing(Assembly assembly);
    [ExtensionAttribute]
public static IList`1<Type> TypesWith(Assembly assembly, Type attributeType);
    [ExtensionAttribute]
public static IList`1<Type> TypesWith(Assembly assembly);
    [CompilerGeneratedAttribute]
private static bool <TypesImplementing>b__6(Type t);
}
[ExtensionAttribute]
internal static class Fasterflect.AttributeExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2`2<MemberInfo, IList`1<Attribute>>, bool> CS$<>9__CachedAnonymousMethodDelegate12;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType2`2<MemberInfo, IList`1<Attribute>>, <>f__AnonymousType3`2<MemberInfo, List`1<Attribute>>> CS$<>9__CachedAnonymousMethodDelegate13;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType3`2<MemberInfo, List`1<Attribute>>, MemberInfo> CS$<>9__CachedAnonymousMethodDelegate14;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType3`2<MemberInfo, List`1<Attribute>>, List`1<Attribute>> CS$<>9__CachedAnonymousMethodDelegate15;
    [ExtensionAttribute]
public static Attribute Attribute(ICustomAttributeProvider provider);
    [ExtensionAttribute]
public static Attribute Attribute(ICustomAttributeProvider provider, Type attributeType);
    [ExtensionAttribute]
public static T Attribute(ICustomAttributeProvider provider);
    [ExtensionAttribute]
public static T Attribute(Enum provider);
    [ExtensionAttribute]
public static Attribute Attribute(Enum provider, Type attributeType);
    [ExtensionAttribute]
public static IList`1<Attribute> Attributes(ICustomAttributeProvider provider, Type[] attributeTypes);
    [ExtensionAttribute]
public static IList`1<T> Attributes(ICustomAttributeProvider provider);
    [ExtensionAttribute]
public static IList`1<T> Attributes(Enum provider);
    [ExtensionAttribute]
public static IList`1<Attribute> Attributes(Enum provider, Type[] attributeTypes);
    [ExtensionAttribute]
public static bool HasAttribute(ICustomAttributeProvider provider, Type attributeType);
    [ExtensionAttribute]
public static bool HasAttribute(ICustomAttributeProvider provider);
    [ExtensionAttribute]
public static bool HasAnyAttribute(ICustomAttributeProvider provider, Type[] attributeTypes);
    [ExtensionAttribute]
public static bool HasAllAttributes(ICustomAttributeProvider provider, Type[] attributeTypes);
    [ExtensionAttribute]
public static IList`1<MemberInfo> MembersWith(Type type, MemberTypes memberTypes, Type[] attributeTypes);
    [ExtensionAttribute]
public static IList`1<MemberInfo> MembersWith(Type type, MemberTypes memberTypes, Flags bindingFlags);
    [ExtensionAttribute]
public static IList`1<MemberInfo> MembersWith(Type type, MemberTypes memberTypes, Flags bindingFlags, Type[] attributeTypes);
    [ExtensionAttribute]
public static IList`1<MemberInfo> FieldsAndPropertiesWith(Type type, Type[] attributeTypes);
    [ExtensionAttribute]
public static IList`1<MemberInfo> FieldsAndPropertiesWith(Type type, Flags bindingFlags, Type[] attributeTypes);
    [ExtensionAttribute]
public static IList`1<FieldInfo> FieldsWith(Type type, Flags bindingFlags, Type[] attributeTypes);
    [ExtensionAttribute]
public static IList`1<PropertyInfo> PropertiesWith(Type type, Flags bindingFlags, Type[] attributeTypes);
    [ExtensionAttribute]
public static IList`1<MethodInfo> MethodsWith(Type type, Flags bindingFlags, Type[] attributeTypes);
    [ExtensionAttribute]
public static IList`1<ConstructorInfo> ConstructorsWith(Type type, Flags bindingFlags, Type[] attributeTypes);
    [ExtensionAttribute]
public static IDictionary`2<MemberInfo, List`1<Attribute>> MembersAndAttributes(Type type, MemberTypes memberTypes, Type[] attributeTypes);
    [ExtensionAttribute]
public static IDictionary`2<MemberInfo, List`1<Attribute>> MembersAndAttributes(Type type, MemberTypes memberTypes, Flags bindingFlags, Type[] attributeTypes);
    [CompilerGeneratedAttribute]
private static bool <MembersAndAttributes>b__e(<>f__AnonymousType2`2<MemberInfo, IList`1<Attribute>> <>h__TransparentIdentifierc);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType3`2<MemberInfo, List`1<Attribute>> <MembersAndAttributes>b__f(<>f__AnonymousType2`2<MemberInfo, IList`1<Attribute>> <>h__TransparentIdentifierc);
    [CompilerGeneratedAttribute]
private static MemberInfo <MembersAndAttributes>b__10(<>f__AnonymousType3`2<MemberInfo, List`1<Attribute>> m);
    [CompilerGeneratedAttribute]
private static List`1<Attribute> <MembersAndAttributes>b__11(<>f__AnonymousType3`2<MemberInfo, List`1<Attribute>> m);
}
[DebuggerStepThroughAttribute]
[DefaultMemberAttribute("Item")]
internal class Fasterflect.Caching.Cache`2 : object {
    private IDictionary`2<TKey, object> entries;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<TKey, object>, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<TKey, object>, TKey> CS$<>9__CachedAnonymousMethodDelegate4;
    public int Count { get; }
    public TValue Item { get; public set; }
    unknown TValue Item {public set; }
    public Cache`2(IEqualityComparer`1<TKey> equalityComparer);
    public int get_Count();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
    public void set_Item(TKey key, CacheStrategy strategy, TValue value);
    public void Insert(TKey key, TValue value);
    public void Insert(TKey key, TValue value, CacheStrategy strategy);
    public TValue Get(TKey key);
    public bool Remove(TKey key);
    public void Clear();
    private int ClearCollected();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private static bool <ClearCollected>b__0(KeyValuePair`2<TKey, object> kvp);
    [CompilerGeneratedAttribute]
private static TKey <ClearCollected>b__1(KeyValuePair`2<TKey, object> kvp);
    [CompilerGeneratedAttribute]
private void <ClearCollected>b__2(TKey k);
}
internal enum Fasterflect.Caching.CacheStrategy : Enum {
    public int value__;
    public static CacheStrategy None;
    public static CacheStrategy Temporary;
    public static CacheStrategy Permanent;
}
[ExtensionAttribute]
internal static class Fasterflect.CloneExtensions : object {
    [ExtensionAttribute]
public static T DeepClone(T source);
    [ExtensionAttribute]
private static T DeepClone(T source, Dictionary`2<object, object> map);
    [ExtensionAttribute]
private static T CloneObject(T source, Dictionary`2<object, object> map);
    [ExtensionAttribute]
private static T CloneArray(T source, Dictionary`2<object, object> map);
    private static object CloneField(FieldInfo field, object source, Dictionary`2<object, object> map);
    [ExtensionAttribute]
private static bool ShouldClone(object obj);
    [ExtensionAttribute]
private static bool IsCalculated(FieldInfo field, Type ownerType);
}
internal static class Fasterflect.Constants : object {
    public static string IndexerSetterName;
    public static string IndexerGetterName;
    public static string ArraySetterName;
    public static string ArrayGetterName;
    public static Type ObjectType;
    public static Type IntType;
    public static Type StructType;
    public static Type VoidType;
    public static Type[] ArrayOfObjectType;
    public static Object[] EmptyObjectArray;
    public static String[] EmptyStringArray;
    public static PropertyInfo[] EmptyPropertyInfoArray;
    private static Constants();
}
[ExtensionAttribute]
internal static class Fasterflect.ConstructorExtensions : object {
    [ExtensionAttribute]
public static object CreateInstance(Type type, Object[] parameters);
    [ExtensionAttribute]
public static object CreateInstance(Type type, Type[] parameterTypes, Object[] parameters);
    [ExtensionAttribute]
public static object CreateInstance(Type type, Flags bindingFlags, Object[] parameters);
    [ExtensionAttribute]
public static object CreateInstance(Type type, Type[] parameterTypes, Flags bindingFlags, Object[] parameters);
    [ExtensionAttribute]
public static ConstructorInvoker DelegateForCreateInstance(Type type, Type[] parameterTypes);
    [ExtensionAttribute]
public static ConstructorInvoker DelegateForCreateInstance(Type type, Flags bindingFlags, Type[] parameterTypes);
    [ExtensionAttribute]
public static IList`1<T> CreateInstances(Assembly assembly);
    [ExtensionAttribute]
public static ConstructorInfo Constructor(Type type, Type[] parameterTypes);
    [ExtensionAttribute]
public static ConstructorInfo Constructor(Type type, Flags bindingFlags, Type[] parameterTypes);
    [ExtensionAttribute]
public static IList`1<ConstructorInfo> Constructors(Type type);
    [ExtensionAttribute]
public static IList`1<ConstructorInfo> Constructors(Type type, Flags bindingFlags);
    [CompilerGeneratedAttribute]
private static bool <CreateInstances>b__0(Type type);
    [CompilerGeneratedAttribute]
private static T <CreateInstances>b__1(Type type);
}
[ExtensionAttribute]
internal static class Fasterflect.ConstructorInfoExtensions : object {
    [ExtensionAttribute]
public static object CreateInstance(ConstructorInfo ctorInfo, Object[] parameters);
    [ExtensionAttribute]
public static ConstructorInvoker DelegateForCreateInstance(ConstructorInfo ctorInfo);
}
internal class Fasterflect.ConstructorInvoker : MulticastDelegate {
    public ConstructorInvoker(object object, IntPtr method);
    public virtual object Invoke(Object[] parameters);
    public virtual IAsyncResult BeginInvoke(Object[] parameters, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class Fasterflect.DynamicBuilder : DynamicObject {
    private Dictionary`2<string, object> members;
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
}
[ExtensionAttribute]
internal static class Fasterflect.DynamicHandler : object {
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, ParameterExpression> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterExpression, UnaryExpression> CS$<>9__CachedAnonymousMethodDelegate3;
    [ExtensionAttribute]
public static object InvokeDelegate(Type targetType, string delegateName, Object[] parameters);
    [ExtensionAttribute]
public static object InvokeDelegate(object target, string delegateName, Object[] parameters);
    [ExtensionAttribute]
public static Type AddHandler(Type targetType, string fieldName, Func`2<Object[], object> func);
    [ExtensionAttribute]
public static Type AddHandler(object target, string fieldName, Func`2<Object[], object> func);
    [ExtensionAttribute]
public static Type AssignHandler(Type targetType, string fieldName, Func`2<Object[], object> func);
    [ExtensionAttribute]
public static Type AssignHandler(object target, string fieldName, Func`2<Object[], object> func);
    private static Type InternalAddHandler(Type targetType, string fieldName, Func`2<Object[], object> func, object target, bool assignHandler);
    [ExtensionAttribute]
public static Delegate BuildDynamicHandler(Type delegateType, Func`2<Object[], object> func);
    [CompilerGeneratedAttribute]
private static ParameterExpression <BuildDynamicHandler>b__0(ParameterInfo parm);
    [CompilerGeneratedAttribute]
private static UnaryExpression <BuildDynamicHandler>b__1(ParameterExpression parm);
}
internal class Fasterflect.DynamicWrapper : DynamicObject {
    private object target;
    [CompilerGeneratedAttribute]
private static Func`2<MemberInfo, string> CS$<>9__CachedAnonymousMethodDelegate1;
    public DynamicWrapper(object target);
    public DynamicWrapper(ValueType& target);
    public virtual bool TrySetMember(SetMemberBinder binder, object value);
    public virtual bool TryGetMember(GetMemberBinder binder, Object& result);
    public virtual bool TryInvokeMember(InvokeMemberBinder binder, Object[] args, Object& result);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    [CompilerGeneratedAttribute]
private static string <GetDynamicMemberNames>b__0(MemberInfo m);
}
internal class Fasterflect.Emitter.ArrayGetEmitter : BaseEmitter {
    public ArrayGetEmitter(Type targetType);
    protected internal virtual DynamicMethod CreateDynamicMethod();
    protected internal virtual Delegate CreateDelegate();
}
internal class Fasterflect.Emitter.ArraySetEmitter : BaseEmitter {
    public ArraySetEmitter(Type targetType);
    protected internal virtual DynamicMethod CreateDynamicMethod();
    protected internal virtual Delegate CreateDelegate();
}
internal abstract class Fasterflect.Emitter.BaseEmitter : object {
    private static Cache`2<CallInfo, Delegate> cache;
    protected static MethodInfo StructGetMethod;
    protected static MethodInfo StructSetMethod;
    protected CallInfo CallInfo;
    protected DynamicMethod Method;
    protected EmitHelper Generator;
    protected BaseEmitter(CallInfo callInfo);
    private static BaseEmitter();
    internal Delegate GetDelegate();
    protected internal abstract virtual DynamicMethod CreateDynamicMethod();
    protected internal abstract virtual Delegate CreateDelegate();
    protected internal static DynamicMethod CreateDynamicMethod(string name, Type targetType, Type returnType, Type[] paramTypes);
    protected void LoadInnerStructToLocal(byte localPosition);
    protected void StoreLocalToInnerStruct(byte localPosition);
    protected void StoreLocalToInnerStruct(byte argPosition, byte localPosition);
}
[DebuggerStepThroughAttribute]
internal class Fasterflect.Emitter.CallInfo : object {
    [CompilerGeneratedAttribute]
private Type <TargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private Flags <BindingFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <ParamTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <GenericTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatic>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberInfo <MemberInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<Type, bool> CS$<>9__CachedAnonymousMethodDelegate1;
    public Type TargetType { get; private set; }
    public Flags BindingFlags { get; internal set; }
    public MemberTypes MemberTypes { get; public set; }
    public Type[] ParamTypes { get; internal set; }
    public Type[] GenericTypes { get; private set; }
    public string Name { get; private set; }
    public bool IsReadOperation { get; public set; }
    public bool IsStatic { get; internal set; }
    public MemberInfo MemberInfo { get; internal set; }
    public bool ShouldHandleInnerStruct { get; }
    public bool IsTargetTypeStruct { get; }
    public bool HasNoParam { get; }
    public bool IsGeneric { get; }
    public bool HasRefParam { get; }
    public CallInfo(Type targetType, Type[] genericTypes, Flags bindingFlags, MemberTypes memberTypes, string name, Type[] parameterTypes, MemberInfo memberInfo, bool isReadOperation);
    [CompilerGeneratedAttribute]
public Type get_TargetType();
    [CompilerGeneratedAttribute]
private void set_TargetType(Type value);
    [CompilerGeneratedAttribute]
public Flags get_BindingFlags();
    [CompilerGeneratedAttribute]
internal void set_BindingFlags(Flags value);
    [CompilerGeneratedAttribute]
public MemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public void set_MemberTypes(MemberTypes value);
    [CompilerGeneratedAttribute]
public Type[] get_ParamTypes();
    [CompilerGeneratedAttribute]
internal void set_ParamTypes(Type[] value);
    [CompilerGeneratedAttribute]
public Type[] get_GenericTypes();
    [CompilerGeneratedAttribute]
private void set_GenericTypes(Type[] value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOperation();
    [CompilerGeneratedAttribute]
public void set_IsReadOperation(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsStatic();
    [CompilerGeneratedAttribute]
internal void set_IsStatic(bool value);
    [CompilerGeneratedAttribute]
public MemberInfo get_MemberInfo();
    [CompilerGeneratedAttribute]
internal void set_MemberInfo(MemberInfo value);
    public bool get_ShouldHandleInnerStruct();
    public bool get_IsTargetTypeStruct();
    public bool get_HasNoParam();
    public bool get_IsGeneric();
    public bool get_HasRefParam();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
private static bool <get_HasRefParam>b__0(Type t);
}
internal class Fasterflect.Emitter.CtorInvocationEmitter : InvocationEmitter {
    public CtorInvocationEmitter(ConstructorInfo ctorInfo, Flags bindingFlags);
    public CtorInvocationEmitter(Type targetType, Flags bindingFlags, Type[] paramTypes);
    private CtorInvocationEmitter(Type targetType, Flags flags, Type[] parameterTypes, ConstructorInfo ctorInfo);
    protected internal virtual DynamicMethod CreateDynamicMethod();
    protected internal virtual Delegate CreateDelegate();
}
internal class Fasterflect.Emitter.EmitHelper : object {
    private ILGenerator _ilGenerator;
    public ILGenerator ILGenerator { get; }
    public EmitHelper add { get; }
    public EmitHelper add_ovf { get; }
    public EmitHelper add_ovf_un { get; }
    public EmitHelper and { get; }
    public EmitHelper arglist { get; }
    public EmitHelper break { get; }
    public EmitHelper ceq { get; }
    public EmitHelper cgt { get; }
    public EmitHelper cgt_un { get; }
    public EmitHelper ckfinite { get; }
    public EmitHelper clt { get; }
    public EmitHelper clt_un { get; }
    public EmitHelper conv_i { get; }
    public EmitHelper conv_i1 { get; }
    public EmitHelper conv_i2 { get; }
    public EmitHelper conv_i4 { get; }
    public EmitHelper conv_i8 { get; }
    public EmitHelper conv_ovf_i { get; }
    public EmitHelper conv_ovf_i1 { get; }
    public EmitHelper conv_ovf_i1_un { get; }
    public EmitHelper conv_ovf_i2 { get; }
    public EmitHelper conv_ovf_i2_un { get; }
    public EmitHelper conv_ovf_i4 { get; }
    public EmitHelper conv_ovf_i4_un { get; }
    public EmitHelper conv_ovf_i8 { get; }
    public EmitHelper conv_ovf_i8_un { get; }
    public EmitHelper conv_ovf_i_un { get; }
    public EmitHelper conv_ovf_u { get; }
    public EmitHelper conv_ovf_u1 { get; }
    public EmitHelper conv_ovf_u1_un { get; }
    public EmitHelper conv_ovf_u2 { get; }
    public EmitHelper conv_ovf_u2_un { get; }
    public EmitHelper conv_ovf_u4 { get; }
    public EmitHelper conv_ovf_u4_un { get; }
    public EmitHelper conv_ovf_u8 { get; }
    public EmitHelper conv_ovf_u8_un { get; }
    public EmitHelper conv_ovf_u_un { get; }
    public EmitHelper conv_r4 { get; }
    public EmitHelper conv_r8 { get; }
    public EmitHelper conv_r_un { get; }
    public EmitHelper conv_u { get; }
    public EmitHelper conv_u1 { get; }
    public EmitHelper conv_u2 { get; }
    public EmitHelper conv_u4 { get; }
    public EmitHelper conv_u8 { get; }
    public EmitHelper cpblk { get; }
    public EmitHelper div { get; }
    public EmitHelper div_un { get; }
    public EmitHelper dup { get; }
    public EmitHelper endfilter { get; }
    public EmitHelper endfinally { get; }
    public EmitHelper initblk { get; }
    public EmitHelper ldarg_0 { get; }
    public EmitHelper ldarg_1 { get; }
    public EmitHelper ldarg_2 { get; }
    public EmitHelper ldarg_3 { get; }
    public EmitHelper ldc_i4_0 { get; }
    public EmitHelper ldc_i4_1 { get; }
    public EmitHelper ldc_i4_2 { get; }
    public EmitHelper ldc_i4_3 { get; }
    public EmitHelper ldc_i4_4 { get; }
    public EmitHelper ldc_i4_5 { get; }
    public EmitHelper ldc_i4_6 { get; }
    public EmitHelper ldc_i4_7 { get; }
    public EmitHelper ldc_i4_8 { get; }
    public EmitHelper ldc_i4_m1 { get; }
    public EmitHelper ldelem_i { get; }
    public EmitHelper ldelem_i1 { get; }
    public EmitHelper ldelem_i2 { get; }
    public EmitHelper ldelem_i4 { get; }
    public EmitHelper ldelem_i8 { get; }
    public EmitHelper ldelem_r4 { get; }
    public EmitHelper ldelem_r8 { get; }
    public EmitHelper ldelem_ref { get; }
    public EmitHelper ldelem_u1 { get; }
    public EmitHelper ldelem_u2 { get; }
    public EmitHelper ldelem_u4 { get; }
    public EmitHelper ldind_i { get; }
    public EmitHelper ldind_i1 { get; }
    public EmitHelper ldind_i2 { get; }
    public EmitHelper ldind_i4 { get; }
    public EmitHelper ldind_i8 { get; }
    public EmitHelper ldind_r4 { get; }
    public EmitHelper ldind_r8 { get; }
    public EmitHelper ldind_ref { get; }
    public EmitHelper ldind_u1 { get; }
    public EmitHelper ldind_u2 { get; }
    public EmitHelper ldind_u4 { get; }
    public EmitHelper ldlen { get; }
    public EmitHelper ldloc_0 { get; }
    public EmitHelper ldloc_1 { get; }
    public EmitHelper ldloc_2 { get; }
    public EmitHelper ldloc_3 { get; }
    public EmitHelper ldnull { get; }
    public EmitHelper localloc { get; }
    public EmitHelper mul { get; }
    public EmitHelper mul_ovf { get; }
    public EmitHelper mul_ovf_un { get; }
    public EmitHelper neg { get; }
    public EmitHelper nop { get; }
    public EmitHelper not { get; }
    public EmitHelper or { get; }
    public EmitHelper pop { get; }
    public EmitHelper readonly { get; }
    public EmitHelper refanytype { get; }
    public EmitHelper rem { get; }
    public EmitHelper rem_un { get; }
    public EmitHelper rethrow { get; }
    public EmitHelper shl { get; }
    public EmitHelper shr { get; }
    public EmitHelper shr_un { get; }
    public EmitHelper stelem_i { get; }
    public EmitHelper stelem_i1 { get; }
    public EmitHelper stelem_i2 { get; }
    public EmitHelper stelem_i4 { get; }
    public EmitHelper stelem_i8 { get; }
    public EmitHelper stelem_r4 { get; }
    public EmitHelper stelem_r8 { get; }
    public EmitHelper stelem_ref { get; }
    public EmitHelper stind_i { get; }
    public EmitHelper stind_i1 { get; }
    public EmitHelper stind_i2 { get; }
    public EmitHelper stind_i4 { get; }
    public EmitHelper stind_i8 { get; }
    public EmitHelper stind_r4 { get; }
    public EmitHelper stind_r8 { get; }
    public EmitHelper stind_ref { get; }
    public EmitHelper stloc_0 { get; }
    public EmitHelper stloc_1 { get; }
    public EmitHelper stloc_2 { get; }
    public EmitHelper stloc_3 { get; }
    public EmitHelper sub { get; }
    public EmitHelper sub_ovf { get; }
    public EmitHelper sub_ovf_un { get; }
    public EmitHelper tailcall { get; }
    public EmitHelper throw { get; }
    public EmitHelper volatile { get; }
    public EmitHelper xor { get; }
    public EmitHelper(ILGenerator ilGenerator);
    public ILGenerator get_ILGenerator();
    public static ILGenerator op_Implicit(EmitHelper emitHelper);
    public EmitHelper BeginCatchBlock(Type exceptionType);
    public EmitHelper BeginExceptFilterBlock();
    public Label BeginExceptionBlock();
    public EmitHelper BeginFaultBlock();
    public EmitHelper BeginFinallyBlock();
    public EmitHelper BeginScope();
    public LocalBuilder DeclareLocal(Type localType);
    public LocalBuilder DeclareLocal(Type localType, bool pinned);
    public Label DefineLabel();
    public EmitHelper EndExceptionBlock();
    public EmitHelper EndScope();
    public EmitHelper MarkLabel(Label loc);
    public EmitHelper MarkSequencePoint(ISymbolDocumentWriter document, int startLine, int startColumn, int endLine, int endColumn);
    public EmitHelper ThrowException(Type exceptionType);
    public EmitHelper UsingNamespace(string namespaceName);
    public EmitHelper ldelem(Type type);
    public EmitHelper stelem(Type type);
    public EmitHelper call(bool isStatic, MethodInfo methodInfo);
    public EmitHelper ldfld(bool isStatic, FieldInfo fieldInfo);
    public EmitHelper stfld(bool isStatic, FieldInfo fieldInfo);
    public EmitHelper get_add();
    public EmitHelper get_add_ovf();
    public EmitHelper get_add_ovf_un();
    public EmitHelper get_and();
    public EmitHelper get_arglist();
    public EmitHelper beq(Label label);
    public EmitHelper beq_s(Label label);
    public EmitHelper bge(Label label);
    public EmitHelper bge_s(Label label);
    public EmitHelper bge_un(Label label);
    public EmitHelper bge_un_s(Label label);
    public EmitHelper bgt(Label label);
    public EmitHelper bgt_s(Label label);
    public EmitHelper bgt_un(Label label);
    public EmitHelper bgt_un_s(Label label);
    public EmitHelper ble(Label label);
    public EmitHelper ble_s(Label label);
    public EmitHelper ble_un(Label label);
    public EmitHelper ble_un_s(Label label);
    public EmitHelper blt(Label label);
    public EmitHelper blt_s(Label label);
    public EmitHelper blt_un(Label label);
    public EmitHelper blt_un_s(Label label);
    public EmitHelper bne_un(Label label);
    public EmitHelper bne_un_s(Label label);
    public EmitHelper box(Type type);
    public EmitHelper boxIfValueType(Type type);
    public EmitHelper br(Label label);
    public EmitHelper get_break();
    public EmitHelper brfalse(Label label);
    public EmitHelper brfalse_s(Label label);
    public EmitHelper brtrue(Label label);
    public EmitHelper brtrue_s(Label label);
    public EmitHelper br_s(Label label);
    public EmitHelper call(MethodInfo methodInfo);
    public EmitHelper call(ConstructorInfo constructorInfo);
    public EmitHelper call(MethodInfo methodInfo, Type[] optionalParameterTypes);
    public EmitHelper call(Type type, string methodName, Type[] optionalParameterTypes);
    public EmitHelper call(Type type, string methodName, BindingFlags bindingFlags, Type[] optionalParameterTypes);
    public EmitHelper calli(CallingConvention unmanagedCallConv, Type returnType, Type[] parameterTypes);
    public EmitHelper calli(CallingConventions callingConvention, Type returnType, Type[] parameterTypes, Type[] optionalParameterTypes);
    public EmitHelper callvirt(MethodInfo methodInfo);
    public EmitHelper callvirt(MethodInfo methodInfo, Type[] optionalParameterTypes);
    public EmitHelper callvirt(Type type, string methodName, Type[] optionalParameterTypes);
    public EmitHelper callvirt(Type type, string methodName, BindingFlags bindingFlags, Type[] optionalParameterTypes);
    public EmitHelper callvirt(Type type, string methodName, BindingFlags bindingFlags);
    public EmitHelper castclass(Type type);
    public EmitHelper castType(Type type);
    public EmitHelper get_ceq();
    public EmitHelper get_cgt();
    public EmitHelper get_cgt_un();
    public EmitHelper constrained(Type type);
    public EmitHelper get_ckfinite();
    public EmitHelper get_clt();
    public EmitHelper get_clt_un();
    public EmitHelper get_conv_i();
    public EmitHelper get_conv_i1();
    public EmitHelper get_conv_i2();
    public EmitHelper get_conv_i4();
    public EmitHelper get_conv_i8();
    public EmitHelper conv(Type type);
    public EmitHelper get_conv_ovf_i();
    public EmitHelper get_conv_ovf_i1();
    public EmitHelper get_conv_ovf_i1_un();
    public EmitHelper get_conv_ovf_i2();
    public EmitHelper get_conv_ovf_i2_un();
    public EmitHelper get_conv_ovf_i4();
    public EmitHelper get_conv_ovf_i4_un();
    public EmitHelper get_conv_ovf_i8();
    public EmitHelper get_conv_ovf_i8_un();
    public EmitHelper get_conv_ovf_i_un();
    public EmitHelper get_conv_ovf_u();
    public EmitHelper get_conv_ovf_u1();
    public EmitHelper get_conv_ovf_u1_un();
    public EmitHelper get_conv_ovf_u2();
    public EmitHelper get_conv_ovf_u2_un();
    public EmitHelper get_conv_ovf_u4();
    public EmitHelper get_conv_ovf_u4_un();
    public EmitHelper get_conv_ovf_u8();
    public EmitHelper get_conv_ovf_u8_un();
    public EmitHelper get_conv_ovf_u_un();
    public EmitHelper get_conv_r4();
    public EmitHelper get_conv_r8();
    public EmitHelper get_conv_r_un();
    public EmitHelper get_conv_u();
    public EmitHelper get_conv_u1();
    public EmitHelper get_conv_u2();
    public EmitHelper get_conv_u4();
    public EmitHelper get_conv_u8();
    public EmitHelper get_cpblk();
    public EmitHelper cpobj(Type type);
    public EmitHelper get_div();
    public EmitHelper get_div_un();
    public EmitHelper get_dup();
    public EmitHelper get_endfilter();
    public EmitHelper get_endfinally();
    public EmitHelper get_initblk();
    public EmitHelper initobj(Type type);
    public EmitHelper isinst(Type type);
    public EmitHelper jmp(MethodInfo methodInfo);
    public EmitHelper ldarg(short index);
    public EmitHelper ldarg(int index);
    public EmitHelper ldarga(short index);
    public EmitHelper ldarga_s(byte index);
    public EmitHelper ldarga(int index);
    public EmitHelper get_ldarg_0();
    public EmitHelper get_ldarg_1();
    public EmitHelper get_ldarg_2();
    public EmitHelper get_ldarg_3();
    public EmitHelper ldarg_s(byte index);
    public EmitHelper ldc_bool(bool b);
    public EmitHelper ldc_i4(int num);
    public EmitHelper get_ldc_i4_0();
    public EmitHelper get_ldc_i4_1();
    public EmitHelper get_ldc_i4_2();
    public EmitHelper get_ldc_i4_3();
    public EmitHelper get_ldc_i4_4();
    public EmitHelper get_ldc_i4_5();
    public EmitHelper get_ldc_i4_6();
    public EmitHelper get_ldc_i4_7();
    public EmitHelper get_ldc_i4_8();
    public EmitHelper get_ldc_i4_m1();
    public EmitHelper ldc_i4_(int num);
    public EmitHelper ldc_i4_s(sbyte num);
    public EmitHelper ldc_i8(long num);
    public EmitHelper ldc_r4(float num);
    public EmitHelper ldc_r8(double num);
    public EmitHelper ldelema(Type type);
    public EmitHelper get_ldelem_i();
    public EmitHelper get_ldelem_i1();
    public EmitHelper get_ldelem_i2();
    public EmitHelper get_ldelem_i4();
    public EmitHelper get_ldelem_i8();
    public EmitHelper get_ldelem_r4();
    public EmitHelper get_ldelem_r8();
    public EmitHelper get_ldelem_ref();
    public EmitHelper get_ldelem_u1();
    public EmitHelper get_ldelem_u2();
    public EmitHelper get_ldelem_u4();
    public EmitHelper ldfld(FieldInfo fieldInfo);
    public EmitHelper ldflda(FieldInfo fieldInfo);
    public EmitHelper ldftn(MethodInfo methodInfo);
    public EmitHelper get_ldind_i();
    public EmitHelper get_ldind_i1();
    public EmitHelper get_ldind_i2();
    public EmitHelper get_ldind_i4();
    public EmitHelper get_ldind_i8();
    public EmitHelper get_ldind_r4();
    public EmitHelper get_ldind_r8();
    public EmitHelper get_ldind_ref();
    public EmitHelper get_ldind_u1();
    public EmitHelper get_ldind_u2();
    public EmitHelper get_ldind_u4();
    public EmitHelper ldind(Type type);
    public EmitHelper get_ldlen();
    public EmitHelper ldloc(short index);
    public EmitHelper ldloc(LocalBuilder localBuilder);
    public EmitHelper ldloca(short index);
    public EmitHelper ldloca_s(byte index);
    public EmitHelper ldloca(LocalBuilder local);
    public EmitHelper get_ldloc_0();
    public EmitHelper get_ldloc_1();
    public EmitHelper get_ldloc_2();
    public EmitHelper get_ldloc_3();
    public EmitHelper ldloc_s(byte index);
    public EmitHelper get_ldnull();
    public EmitHelper ldobj(Type type);
    public EmitHelper ldsfld(FieldInfo fieldInfo);
    public EmitHelper ldsflda(FieldInfo fieldInfo);
    public EmitHelper ldstrEx(string str);
    public EmitHelper ldstr(string str);
    public EmitHelper ldtoken(MethodInfo methodInfo);
    public EmitHelper ldtoken(FieldInfo fieldInfo);
    public EmitHelper ldtoken(Type type);
    public EmitHelper ldvirtftn(MethodInfo methodInfo);
    public EmitHelper leave(Label label);
    public EmitHelper leave_s(Label label);
    public EmitHelper get_localloc();
    public EmitHelper mkrefany(Type type);
    public EmitHelper get_mul();
    public EmitHelper get_mul_ovf();
    public EmitHelper get_mul_ovf_un();
    public EmitHelper get_neg();
    public EmitHelper newarr(Type type);
    public EmitHelper newobj(ConstructorInfo constructorInfo);
    public EmitHelper newobj(Type type, Type[] parameters);
    public EmitHelper get_nop();
    public EmitHelper get_not();
    public EmitHelper get_or();
    public EmitHelper get_pop();
    public EmitHelper get_readonly();
    public EmitHelper get_refanytype();
    public EmitHelper refanyval(Type type);
    public EmitHelper get_rem();
    public EmitHelper get_rem_un();
    public EmitHelper ret();
    public EmitHelper get_rethrow();
    public EmitHelper get_shl();
    public EmitHelper get_shr();
    public EmitHelper get_shr_un();
    public EmitHelper sizeof(Type type);
    public EmitHelper starg(short index);
    public EmitHelper starg_s(byte index);
    public EmitHelper starg(int index);
    public EmitHelper get_stelem_i();
    public EmitHelper get_stelem_i1();
    public EmitHelper get_stelem_i2();
    public EmitHelper get_stelem_i4();
    public EmitHelper get_stelem_i8();
    public EmitHelper get_stelem_r4();
    public EmitHelper get_stelem_r8();
    public EmitHelper get_stelem_ref();
    public EmitHelper stfld(FieldInfo fieldInfo);
    public EmitHelper get_stind_i();
    public EmitHelper get_stind_i1();
    public EmitHelper get_stind_i2();
    public EmitHelper get_stind_i4();
    public EmitHelper get_stind_i8();
    public EmitHelper get_stind_r4();
    public EmitHelper get_stind_r8();
    public EmitHelper get_stind_ref();
    public EmitHelper stind(Type type);
    public EmitHelper stloc(LocalBuilder local);
    public EmitHelper stloc(short index);
    public EmitHelper get_stloc_0();
    public EmitHelper get_stloc_1();
    public EmitHelper get_stloc_2();
    public EmitHelper get_stloc_3();
    public EmitHelper stloc_s(LocalBuilder local);
    public EmitHelper stloc_s(byte index);
    public EmitHelper stobj(Type type);
    public EmitHelper stsfld(FieldInfo fieldInfo);
    public EmitHelper get_sub();
    public EmitHelper get_sub_ovf();
    public EmitHelper get_sub_ovf_un();
    public EmitHelper switch(Label[] labels);
    public EmitHelper get_tailcall();
    public EmitHelper get_throw();
    public EmitHelper unaligned(Label label);
    public EmitHelper unaligned(long addr);
    public EmitHelper unbox(Type type);
    public EmitHelper unbox_any(Type type);
    public EmitHelper unboxIfValueType(Type type);
    public EmitHelper get_volatile();
    public EmitHelper get_xor();
    public void end();
    public EmitHelper LoadInitValue(Type type);
    public bool LoadWellKnownValue(object o);
    public EmitHelper Init(LocalBuilder localBuilder);
    public EmitHelper LoadType(Type type);
    public EmitHelper LoadField(FieldInfo fieldInfo);
    public EmitHelper CastFromObject(Type type);
    public void AddMaxStackSize(int size);
    private static Exception CreateNoSuchMethodException(Type type, string methodName);
    private static Exception CreateNotExpectedTypeException(Type type);
}
internal abstract class Fasterflect.Emitter.InvocationEmitter : BaseEmitter {
    protected InvocationEmitter(CallInfo callInfo);
    protected byte CreateLocalsForByRefParams(byte paramArrayIndex, MethodBase invocationInfo);
    protected void AssignByRefParamsToArray(int paramArrayIndex);
    protected void PushParamsOrLocalsToStack(int paramArrayIndex);
}
internal class Fasterflect.Emitter.LookupUtils : object {
    public static ConstructorInfo GetConstructor(CallInfo callInfo);
    public static MethodInfo GetMethod(CallInfo callInfo);
    public static MemberInfo GetMember(CallInfo callInfo);
    public static FieldInfo GetField(CallInfo callInfo);
    public static PropertyInfo GetProperty(CallInfo callInfo);
    public static MethodInfo GetPropertyGetMethod(PropertyInfo propInfo, CallInfo callInfo);
    public static MethodInfo GetPropertySetMethod(PropertyInfo propInfo, CallInfo callInfo);
    private static MethodInfo GetPropertyMethod(string infoPrefix, string propertyMethod, CallInfo callInfo);
}
[DebuggerStepThroughAttribute]
internal class Fasterflect.Emitter.MapCallInfo : CallInfo {
    [CompilerGeneratedAttribute]
private Type <SourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberTypes <SourceMemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberTypes <TargetMemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Names>k__BackingField;
    public Type SourceType { get; private set; }
    public MemberTypes SourceMemberTypes { get; private set; }
    public MemberTypes TargetMemberTypes { get; private set; }
    public String[] Names { get; private set; }
    public MapCallInfo(Type targetType, Type[] genericTypes, Flags bindingFlags, MemberTypes memberTypes, string name, Type[] parameterTypes, MemberInfo memberInfo, bool isReadOperation, Type sourceType, MemberTypes sourceMemberTypes, MemberTypes targetMemberTypes, String[] names);
    [CompilerGeneratedAttribute]
public Type get_SourceType();
    [CompilerGeneratedAttribute]
private void set_SourceType(Type value);
    [CompilerGeneratedAttribute]
public MemberTypes get_SourceMemberTypes();
    [CompilerGeneratedAttribute]
private void set_SourceMemberTypes(MemberTypes value);
    [CompilerGeneratedAttribute]
public MemberTypes get_TargetMemberTypes();
    [CompilerGeneratedAttribute]
private void set_TargetMemberTypes(MemberTypes value);
    [CompilerGeneratedAttribute]
public String[] get_Names();
    [CompilerGeneratedAttribute]
private void set_Names(String[] value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Fasterflect.Emitter.MapEmitter : BaseEmitter {
    private Type sourceType;
    private MemberTypes sourceMemberTypes;
    private MemberTypes targetMemberTypes;
    private String[] names;
    [CompilerGeneratedAttribute]
private static Func`3<MemberInfo, MemberInfo, <>f__AnonymousType0`2<MemberInfo, MemberInfo>> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType0`2<MemberInfo, MemberInfo>, <>f__AnonymousType1`2<MemberInfo, MemberInfo>> CS$<>9__CachedAnonymousMethodDelegate8;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1`2<MemberInfo, MemberInfo>, MemberInfo> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType1`2<MemberInfo, MemberInfo>, MemberInfo> CS$<>9__CachedAnonymousMethodDelegatea;
    public MapEmitter(Type sourceType, Type targetType, MemberTypes sourceMemberTypes, MemberTypes targetMemberTypes, Flags bindingFlags, String[] names);
    protected internal virtual DynamicMethod CreateDynamicMethod();
    protected internal virtual Delegate CreateDelegate();
    private void GenerateGetMemberValue(MemberInfo member);
    private void GenerateSetMemberValue(MemberInfo member);
    private IEnumerable`1<KeyValuePair`2<MemberInfo, MemberInfo>> GetMatchingMembers();
    [CompilerGeneratedAttribute]
private IEnumerable`1<MemberInfo> <GetMatchingMembers>b__1(MemberInfo s);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType0`2<MemberInfo, MemberInfo> <GetMatchingMembers>b__2(MemberInfo s, MemberInfo t);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType1`2<MemberInfo, MemberInfo> <GetMatchingMembers>b__4(<>f__AnonymousType0`2<MemberInfo, MemberInfo> <>h__TransparentIdentifier0);
    [CompilerGeneratedAttribute]
private static MemberInfo <GetMatchingMembers>b__5(<>f__AnonymousType1`2<MemberInfo, MemberInfo> k);
    [CompilerGeneratedAttribute]
private static MemberInfo <GetMatchingMembers>b__6(<>f__AnonymousType1`2<MemberInfo, MemberInfo> v);
}
internal class Fasterflect.Emitter.MemberGetEmitter : BaseEmitter {
    public MemberGetEmitter(MemberInfo memberInfo, Flags bindingFlags);
    public MemberGetEmitter(Type targetType, Flags bindingFlags, MemberTypes memberType, string fieldOrPropertyName);
    private MemberGetEmitter(Type targetType, Flags bindingFlags, MemberTypes memberType, string fieldOrPropertyName, MemberInfo memberInfo);
    internal MemberGetEmitter(CallInfo callInfo);
    protected internal virtual DynamicMethod CreateDynamicMethod();
    protected internal virtual Delegate CreateDelegate();
}
internal class Fasterflect.Emitter.MemberSetEmitter : BaseEmitter {
    public MemberSetEmitter(MemberInfo memberInfo, Flags bindingFlags);
    public MemberSetEmitter(Type targetType, Flags bindingFlags, MemberTypes memberType, string fieldOrProperty);
    private MemberSetEmitter(Type targetType, Flags bindingFlags, MemberTypes memberType, string fieldOrProperty, MemberInfo memberInfo);
    internal MemberSetEmitter(CallInfo callInfo);
    protected internal virtual DynamicMethod CreateDynamicMethod();
    protected internal virtual Delegate CreateDelegate();
}
internal class Fasterflect.Emitter.MethodInvocationEmitter : InvocationEmitter {
    public MethodInvocationEmitter(MethodInfo methodInfo, Flags bindingFlags);
    public MethodInvocationEmitter(Type targetType, Flags bindingFlags, string name, Type[] parameterTypes);
    private MethodInvocationEmitter(Type targetType, Flags bindingFlags, string name, Type[] parameterTypes, MemberInfo methodInfo);
    public MethodInvocationEmitter(CallInfo callInfo);
    protected internal virtual DynamicMethod CreateDynamicMethod();
    protected internal virtual Delegate CreateDelegate();
    private void GenerateInvocation(MethodInfo methodInfo, byte paramArrayIndex, byte structLocalPosition);
}
internal class Fasterflect.Emitter.ValueTypeHolder : object {
    [CompilerGeneratedAttribute]
private ValueType <Value>k__BackingField;
    public ValueType Value { get; public set; }
    public ValueTypeHolder(object value);
    [CompilerGeneratedAttribute]
public ValueType get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(ValueType value);
}
[ExtensionAttribute]
internal static class Fasterflect.FieldExtensions : object {
    [ExtensionAttribute]
public static object SetFieldValue(object obj, string name, object value);
    [ExtensionAttribute]
public static object GetFieldValue(object obj, string name);
    [ExtensionAttribute]
public static object SetFieldValue(object obj, string name, object value, Flags bindingFlags);
    [ExtensionAttribute]
public static object GetFieldValue(object obj, string name, Flags bindingFlags);
    [ExtensionAttribute]
public static MemberSetter DelegateForSetFieldValue(Type type, string name);
    [ExtensionAttribute]
public static MemberGetter DelegateForGetFieldValue(Type type, string name);
    [ExtensionAttribute]
public static MemberSetter DelegateForSetFieldValue(Type type, string name, Flags bindingFlags);
    [ExtensionAttribute]
public static MemberGetter DelegateForGetFieldValue(Type type, string name, Flags bindingFlags);
    [ExtensionAttribute]
public static FieldInfo Field(Type type, string name);
    [ExtensionAttribute]
public static FieldInfo Field(Type type, string name, Flags bindingFlags);
    [ExtensionAttribute]
public static IList`1<FieldInfo> Fields(Type type, String[] names);
    [ExtensionAttribute]
public static IList`1<FieldInfo> Fields(Type type, Flags bindingFlags, String[] names);
    private static IList`1<FieldInfo> GetFields(Type type, Flags bindingFlags);
    [ExtensionAttribute]
public static object TryGetFieldValue(object obj, string name);
    [ExtensionAttribute]
public static object TryGetFieldValue(object obj, string name, Flags bindingFlags);
    [ExtensionAttribute]
public static bool TrySetFieldValue(object obj, string name, object value);
    [ExtensionAttribute]
public static bool TrySetFieldValue(object obj, string name, object value, Flags bindingFlags);
}
[ExtensionAttribute]
internal static class Fasterflect.FieldInfoExtensions : object {
    [ExtensionAttribute]
public static void Set(FieldInfo fieldInfo, object value);
    [ExtensionAttribute]
public static void Set(FieldInfo fieldInfo, object obj, object value);
    [ExtensionAttribute]
public static object Get(FieldInfo fieldInfo);
    [ExtensionAttribute]
public static object Get(FieldInfo fieldInfo, object obj);
    [ExtensionAttribute]
public static MemberSetter DelegateForSetFieldValue(FieldInfo fieldInfo);
    [ExtensionAttribute]
public static MemberGetter DelegateForGetFieldValue(FieldInfo fieldInfo);
}
internal class Fasterflect.Flags : ValueType {
    private long flags;
    private static Dictionary`2<Flags, string> flagNames;
    public static Flags None;
    public static Flags IgnoreCase;
    public static Flags DeclaredOnly;
    public static Flags ExactBinding;
    public static Flags Public;
    public static Flags NonPublic;
    public static Flags Instance;
    public static Flags Static;
    public static Flags PartialNameMatch;
    public static Flags TrimExplicitlyImplemented;
    public static Flags ExcludeExplicitlyImplemented;
    public static Flags ExcludeBackingMembers;
    public static Flags IgnoreParameterModifiers;
    public static Flags ExcludeHiddenMembers;
    public static Flags AnyVisibility;
    public static Flags InstancePublic;
    public static Flags InstancePrivate;
    public static Flags InstanceAnyVisibility;
    public static Flags StaticPublic;
    public static Flags StaticPrivate;
    public static Flags StaticAnyVisibility;
    public static Flags InstancePublicDeclaredOnly;
    public static Flags InstancePrivateDeclaredOnly;
    public static Flags InstanceAnyDeclaredOnly;
    public static Flags StaticPublicDeclaredOnly;
    public static Flags StaticPrivateDeclaredOnly;
    public static Flags StaticAnyDeclaredOnly;
    public static Flags StaticInstanceAnyVisibility;
    public static Flags Default;
    public static Flags AllMembers;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<Flags, string>, string> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<string, string> CS$<>9__CachedAnonymousMethodDelegate5;
    private Flags(long flags);
    private static Flags();
    public bool IsSet(BindingFlags mask);
    public bool IsSet(Flags mask);
    public bool IsAnySet(BindingFlags mask);
    public bool IsAnySet(Flags mask);
    public bool IsNotSet(BindingFlags mask);
    public bool IsNotSet(Flags mask);
    public static Flags SetIf(Flags flags, Flags mask, bool condition);
    public static Flags SetOnlyIf(Flags flags, Flags mask, bool condition);
    public static Flags ClearIf(Flags flags, Flags mask, bool condition);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static Flags op_Subtraction(Flags f1, Flags f2);
    public static Flags op_BitwiseOr(Flags f1, Flags f2);
    public static Flags op_BitwiseAnd(Flags f1, Flags f2);
    public static bool op_Equality(Flags f1, Flags f2);
    public static bool op_Inequality(Flags f1, Flags f2);
    public static Flags op_Implicit(BindingFlags m);
    public static Flags op_Explicit(long m);
    public static BindingFlags op_Implicit(Flags m);
    public static long op_Implicit(Flags m);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private static string <ToString>b__1(KeyValuePair`2<Flags, string> kvp);
    [CompilerGeneratedAttribute]
private static string <ToString>b__2(string n);
}
[FlagsAttribute]
internal enum Fasterflect.FormatOptions : Enum {
    public int value__;
    public static FormatOptions None;
    public static FormatOptions AddHeader;
    public static FormatOptions NewLineAfterElement;
    public static FormatOptions Indent;
    public static FormatOptions UseSpaces;
    public static FormatOptions Default;
}
[ExtensionAttribute]
internal static class Fasterflect.MapExtensions : object {
    [ExtensionAttribute]
public static void Map(object source, object target, String[] names);
    [ExtensionAttribute]
public static void Map(object source, object target, Flags bindingFlags, String[] names);
    [ExtensionAttribute]
public static void Map(object source, object target, MemberTypes sourceTypes, MemberTypes targetTypes, Flags bindingFlags, String[] names);
    [ExtensionAttribute]
public static ObjectMapper DelegateForMap(Type sourceType, Type targetType, String[] names);
    [ExtensionAttribute]
public static ObjectMapper DelegateForMap(Type sourceType, Type targetType, Flags bindingFlags, String[] names);
    [ExtensionAttribute]
public static ObjectMapper DelegateForMap(Type sourceType, Type targetType, MemberTypes sourceTypes, MemberTypes targetTypes, Flags bindingFlags, String[] names);
    [ExtensionAttribute]
public static void MapFields(object source, object target, String[] names);
    [ExtensionAttribute]
public static void MapProperties(object source, object target, String[] names);
    [ExtensionAttribute]
public static void MapFieldsToProperties(object source, object target, String[] names);
    [ExtensionAttribute]
public static void MapPropertiesToFields(object source, object target, String[] names);
}
[ExtensionAttribute]
internal static class Fasterflect.MemberExtensions : object {
    [ExtensionAttribute]
public static MemberInfo Member(Type type, string name);
    [ExtensionAttribute]
public static MemberInfo Member(Type type, string name, Flags bindingFlags);
    [ExtensionAttribute]
public static IList`1<MemberInfo> FieldsAndProperties(Type type);
    [ExtensionAttribute]
public static IList`1<MemberInfo> FieldsAndProperties(Type type, Flags bindingFlags);
    [ExtensionAttribute]
public static IList`1<MemberInfo> Members(Type type);
    [ExtensionAttribute]
public static IList`1<MemberInfo> Members(Type type, Flags bindingFlags);
    [ExtensionAttribute]
public static IList`1<MemberInfo> Members(Type type, MemberTypes memberTypes, String[] names);
    [ExtensionAttribute]
public static IList`1<MemberInfo> Members(Type type, MemberTypes memberTypes, Flags bindingFlags, String[] names);
    private static IList`1<MemberInfo> GetMembers(Type type, MemberTypes memberTypes, Flags bindingFlags);
    [ExtensionAttribute]
public static object TryGetValue(object obj, string name);
    [ExtensionAttribute]
public static object TryGetValue(object obj, string name, Flags bindingFlags);
    [ExtensionAttribute]
public static bool TrySetValue(object obj, string name, object value);
    [ExtensionAttribute]
public static bool TrySetValue(object obj, string name, object value, Flags bindingFlags);
}
[ExtensionAttribute]
internal static class Fasterflect.MemberFilter : object {
    [ExtensionAttribute]
public static bool IsReservedName(string name);
    [ExtensionAttribute]
public static string TrimExplicitlyImplementedName(string name);
    [ExtensionAttribute]
public static IList`1<T> Filter(IList`1<T> members, Flags bindingFlags, String[] names);
    [ExtensionAttribute]
public static IList`1<T> Filter(IList`1<T> methods, Type[] genericTypes);
    [ExtensionAttribute]
public static IList`1<T> Filter(IList`1<T> methods, Flags bindingFlags, Type[] paramTypes);
    [ExtensionAttribute]
public static IList`1<T> Filter(IList`1<T> members, Flags bindingFlags, MemberTypes memberTypes);
    [ExtensionAttribute]
public static IList`1<T> Filter(IList`1<T> members, Flags bindingFlags);
    [ExtensionAttribute]
private static bool ContainsOverride(IList`1<T> candidates, MethodInfo method);
    [CompilerGeneratedAttribute]
private static bool <Filter>b__1(T m);
    [CompilerGeneratedAttribute]
private static Type <ContainsOverride>b__9(ParameterInfo p);
    [CompilerGeneratedAttribute]
private static Type <ContainsOverride>b__a(ParameterInfo p);
}
internal class Fasterflect.MemberGetter : MulticastDelegate {
    public MemberGetter(object object, IntPtr method);
    public virtual object Invoke(object obj);
    public virtual IAsyncResult BeginInvoke(object obj, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class Fasterflect.MemberInfoExtensions : object {
    [ExtensionAttribute]
public static object Get(MemberInfo memberInfo);
    [ExtensionAttribute]
public static void Set(MemberInfo memberInfo, object value);
    [ExtensionAttribute]
public static object Get(MemberInfo memberInfo, object obj);
    [ExtensionAttribute]
public static void Set(MemberInfo memberInfo, object obj, object value);
    [ExtensionAttribute]
public static Type Type(MemberInfo member);
    [ExtensionAttribute]
public static bool IsReadable(MemberInfo member);
    [ExtensionAttribute]
public static bool IsWritable(MemberInfo member);
    [ExtensionAttribute]
public static bool IsInvokable(MemberInfo member);
    [ExtensionAttribute]
public static bool IsStatic(MemberInfo member);
    [ExtensionAttribute]
public static bool IsInstance(MemberInfo member);
    [ExtensionAttribute]
public static bool HasName(MemberInfo member, string name);
}
internal class Fasterflect.MemberSetter : MulticastDelegate {
    public MemberSetter(object object, IntPtr method);
    public virtual void Invoke(object obj, object value);
    public virtual IAsyncResult BeginInvoke(object obj, object value, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
internal static class Fasterflect.MethodExtensions : object {
    [ExtensionAttribute]
public static object CallMethod(object obj, string name, Object[] parameters);
    [ExtensionAttribute]
public static object CallMethod(object obj, Type[] genericTypes, string name, Object[] parameters);
    [ExtensionAttribute]
public static object CallMethod(object obj, string name, Type[] parameterTypes, Object[] parameters);
    [ExtensionAttribute]
public static object CallMethod(object obj, Type[] genericTypes, string name, Type[] parameterTypes, Object[] parameters);
    [ExtensionAttribute]
public static object CallMethod(object obj, string name, Flags bindingFlags, Object[] parameters);
    [ExtensionAttribute]
public static object CallMethod(object obj, Type[] genericTypes, string name, Flags bindingFlags, Object[] parameters);
    [ExtensionAttribute]
public static object CallMethod(object obj, string name, Type[] parameterTypes, Flags bindingFlags, Object[] parameters);
    [ExtensionAttribute]
public static object CallMethod(object obj, Type[] genericTypes, string name, Type[] parameterTypes, Flags bindingFlags, Object[] parameters);
    [ExtensionAttribute]
public static MethodInvoker DelegateForCallMethod(Type type, string name, Type[] parameterTypes);
    [ExtensionAttribute]
public static MethodInvoker DelegateForCallMethod(Type type, Type[] genericTypes, string name, Type[] parameterTypes);
    [ExtensionAttribute]
public static MethodInvoker DelegateForCallMethod(Type type, string name, Flags bindingFlags, Type[] parameterTypes);
    [ExtensionAttribute]
public static MethodInvoker DelegateForCallMethod(Type type, Type[] genericTypes, string name, Flags bindingFlags, Type[] parameterTypes);
    [ExtensionAttribute]
public static MethodInfo Method(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo Method(Type type, Type[] genericTypes, string name);
    [ExtensionAttribute]
public static MethodInfo Method(Type type, string name, Type[] parameterTypes);
    [ExtensionAttribute]
public static MethodInfo Method(Type type, Type[] genericTypes, string name, Type[] parameterTypes);
    [ExtensionAttribute]
public static MethodInfo Method(Type type, string name, Flags bindingFlags);
    [ExtensionAttribute]
public static MethodInfo Method(Type type, Type[] genericTypes, string name, Flags bindingFlags);
    [ExtensionAttribute]
public static MethodInfo Method(Type type, string name, Type[] parameterTypes, Flags bindingFlags);
    [ExtensionAttribute]
public static MethodInfo Method(Type type, Type[] genericTypes, string name, Type[] parameterTypes, Flags bindingFlags);
    [ExtensionAttribute]
internal static MethodInfo MakeGeneric(MethodInfo methodInfo, Type[] genericTypes);
    [ExtensionAttribute]
public static IList`1<MethodInfo> Methods(Type type, String[] names);
    [ExtensionAttribute]
public static IList`1<MethodInfo> Methods(Type type, Flags bindingFlags, String[] names);
    [ExtensionAttribute]
public static IList`1<MethodInfo> Methods(Type type, Type[] parameterTypes, String[] names);
    [ExtensionAttribute]
public static IList`1<MethodInfo> Methods(Type type, Type[] parameterTypes, Flags bindingFlags, String[] names);
    [ExtensionAttribute]
public static IList`1<MethodInfo> Methods(Type type, Type[] genericTypes, Type[] parameterTypes, Flags bindingFlags, String[] names);
    private static IList`1<MethodInfo> GetMethods(Type type, Flags bindingFlags);
}
[ExtensionAttribute]
internal static class Fasterflect.MethodInfoExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, Type> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, Type> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<ParameterInfo, Type> CS$<>9__CachedAnonymousMethodDelegate5;
    [ExtensionAttribute]
public static object Call(MethodInfo methodInfo, Object[] parameters);
    [ExtensionAttribute]
public static object Call(MethodInfo methodInfo, object obj, Object[] parameters);
    [ExtensionAttribute]
public static MethodInvoker DelegateForCallMethod(MethodInfo methodInfo);
    [ExtensionAttribute]
public static IList`1<ParameterInfo> Parameters(MethodBase method);
    [ExtensionAttribute]
public static bool HasParameterSignature(MethodBase method, Type[] parameters);
    [ExtensionAttribute]
public static bool HasParameterSignature(MethodBase method, ParameterInfo[] parameters);
    [CompilerGeneratedAttribute]
private static Type <HasParameterSignature>b__0(ParameterInfo p);
    [CompilerGeneratedAttribute]
private static Type <HasParameterSignature>b__2(ParameterInfo p);
    [CompilerGeneratedAttribute]
private static Type <HasParameterSignature>b__3(ParameterInfo p);
}
internal class Fasterflect.MethodInvoker : MulticastDelegate {
    public MethodInvoker(object object, IntPtr method);
    public virtual object Invoke(object obj, Object[] parameters);
    public virtual IAsyncResult BeginInvoke(object obj, Object[] parameters, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class Fasterflect.ObjectMapper : MulticastDelegate {
    public ObjectMapper(object object, IntPtr method);
    public virtual void Invoke(object source, object target);
    public virtual IAsyncResult BeginInvoke(object source, object target, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Fasterflect.ParameterConverter : MulticastDelegate {
    public ParameterConverter(object object, IntPtr method);
    public virtual bool Invoke(Type parameterType, object target, Object& value);
    public virtual IAsyncResult BeginInvoke(Type parameterType, object target, Object& value, AsyncCallback callback, object object);
    public virtual bool EndInvoke(Object& value, IAsyncResult result);
}
[ExtensionAttribute]
internal static class Fasterflect.ParameterInfoExtensions : object {
    [ExtensionAttribute]
public static bool IsNullable(ParameterInfo parameter);
    [ExtensionAttribute]
public static bool HasName(ParameterInfo parameter, string name);
    [ExtensionAttribute]
public static bool HasDefaultValue(ParameterInfo parameter);
    [ExtensionAttribute]
public static object DefaultValue(ParameterInfo parameter);
}
internal class Fasterflect.Probing.ConstructorMap : MethodMap {
    private ConstructorInvoker invoker;
    public ConstructorMap(ConstructorInfo constructor, String[] paramNames, Type[] parameterTypes, Object[] sampleParamValues, bool mustUseAllParameters);
    private void UpdateMembers(object target, Object[] row);
    public virtual object Invoke(Object[] row);
    internal virtual void InitializeInvoker();
}
internal static class Fasterflect.Probing.MapFactory : object {
    private static Cache`2<int, MethodMap> mapCache;
    private static MapFactory();
    public static MethodMap PrepareInvoke(Type type, String[] paramNames, Type[] parameterTypes, Object[] sampleParamValues);
    internal static MethodMap DetermineBestConstructorMatch(Type type, String[] paramNames, Type[] parameterTypes, Object[] sampleParamValues);
    internal static MethodMap DetermineBestMethodMatch(IEnumerable`1<MethodBase> methods, bool mustUseAllParameters, String[] paramNames, Type[] parameterTypes, Object[] sampleParamValues);
    private static MethodMap DetermineBestMatch(IEnumerable`1<MethodBase> methods, bool mustUseAllParameters, String[] paramNames, Type[] parameterTypes, Object[] sampleParamValues);
    private static MethodMap CreateMap(MethodBase method, String[] paramNames, Type[] parameterTypes, Object[] sampleParamValues, bool mustUseAllParameters);
}
internal class Fasterflect.Probing.MethodDispatcher : object {
    private List`1<MethodBase> methodPool;
    public void AddMethod(MethodInfo method);
    public object Invoke(object obj, bool mustUseAllParameters, object sample);
    public object Invoke(object obj, bool mustUseAllParameters, Dictionary`2<string, object> parameters);
}
internal class Fasterflect.Probing.MethodMap : object {
    private bool mustUseAllParameters;
    protected long cost;
    protected bool isPerfectMatch;
    protected bool isValid;
    protected MemberInfo[] members;
    protected MethodBase method;
    protected BitArray methodParameterUsageMask;
    protected String[] paramNames;
    protected Type[] paramTypes;
    protected BitArray parameterDefaultValueMask;
    protected IDictionary`2<string, object> parameterDefaultValues;
    protected Int32[] parameterOrderMap;
    protected Int32[] parameterOrderMapReverse;
    protected BitArray parameterReflectionMask;
    protected BitArray parameterTypeConvertMask;
    protected BitArray parameterUnusedMask;
    protected long parameterUsageCount;
    protected BitArray parameterUsageMask;
    protected IList`1<ParameterInfo> parameters;
    protected int requiredFoundCount;
    protected int requiredParameterCount;
    protected Type type;
    private MethodInvoker invoker;
    public IDictionary`2<string, object> ParameterDefaultValues { get; public set; }
    public int ParameterCount { get; }
    public int RequiredParameterCount { get; }
    public long Cost { get; }
    public bool IsValid { get; }
    public bool IsPerfectMatch { get; }
    public MethodMap(MethodBase method, String[] paramNames, Type[] paramTypes, Object[] sampleParamValues, bool mustUseAllParameters);
    private void InitializeBitArrays(int length);
    private void InitializeMethodMap(Object[] sampleParamValues);
    private bool IsConvertible(Type sourceType, Type targetType, object sampleValue);
    private void SaveDefaultValue(string parameterName, object parameterValue);
    private bool HasExternalDefaultValue(ParameterInfo parameter);
    private object GetExternalDefaultValue(ParameterInfo parameter);
    protected Object[] PrepareParameters(Object[] row);
    public virtual object Invoke(Object[] row);
    public virtual object Invoke(object target, Object[] row);
    internal Type[] GetParamTypes();
    protected bool AnySet(BitArray bits);
    protected bool AllUnset(BitArray bits);
    protected bool AllSet(BitArray bits);
    public IDictionary`2<string, object> get_ParameterDefaultValues();
    public void set_ParameterDefaultValues(IDictionary`2<string, object> value);
    public int get_ParameterCount();
    public int get_RequiredParameterCount();
    public virtual long get_Cost();
    public bool get_IsValid();
    public bool get_IsPerfectMatch();
    internal virtual void InitializeInvoker();
}
internal class Fasterflect.Probing.SourceInfo : object {
    private Boolean[] paramKinds;
    private String[] paramNames;
    private Type[] paramTypes;
    private MemberGetter[] paramValueReaders;
    private Type type;
    public Type Type { get; }
    public String[] ParamNames { get; }
    public Type[] ParamTypes { get; }
    public Boolean[] ParamKinds { get; }
    public MemberGetter[] ParamValueReaders { get; }
    public SourceInfo(Type type);
    public SourceInfo(Type type, String[] names, Type[] types);
    public Type get_Type();
    public String[] get_ParamNames();
    public Type[] get_ParamTypes();
    public Boolean[] get_ParamKinds();
    public MemberGetter[] get_ParamValueReaders();
    public Object[] GetParameterValues(object source);
    internal MemberGetter GetReader(string memberName);
    private void InitializeParameterValueReaders();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal void ExtractParameterInfo(Type type);
}
internal static class Fasterflect.Probing.TypeConverter : object {
    public static object Get(Type targetType, XmlNode node);
    public static object Get(Type targetType, XAttribute attribute);
    public static object Get(Type targetType, XElement element);
    public static object Get(Type targetType, string value);
    public static object Get(Type targetType, object value);
    public static object ConvertTypes(Type targetType, Type sourceType, object value);
    private static object ConvertEnums(Type targetType, Type sourceType, object value);
    public static Guid StringToGuid(string guid);
    public static string GuidToBinaryString(Guid guid);
    private static object ConvertGuids(Type targetType, Type sourceType, object sourceObj);
}
[ExtensionAttribute]
internal static class Fasterflect.PropertyExtensions : object {
    [ExtensionAttribute]
public static object SetPropertyValue(object obj, string name, object value);
    [ExtensionAttribute]
public static object GetPropertyValue(object obj, string name);
    [ExtensionAttribute]
public static object SetPropertyValue(object obj, string name, object value, Flags bindingFlags);
    [ExtensionAttribute]
public static object GetPropertyValue(object obj, string name, Flags bindingFlags);
    [ExtensionAttribute]
public static object SetPropertyValue(object obj, Expression`1<Func`1<object>> memberExpression, object value);
    [ExtensionAttribute]
public static object GetPropertyValue(object obj, Expression`1<Func`1<object>> memberExpression);
    [ExtensionAttribute]
public static MemberSetter DelegateForSetPropertyValue(Type type, string name);
    [ExtensionAttribute]
public static MemberGetter DelegateForGetPropertyValue(Type type, string name);
    [ExtensionAttribute]
public static MemberSetter DelegateForSetPropertyValue(Type type, string name, Flags bindingFlags);
    [ExtensionAttribute]
public static MemberGetter DelegateForGetPropertyValue(Type type, string name, Flags bindingFlags);
    [ExtensionAttribute]
public static object SetIndexer(object obj, Object[] parameters);
    [ExtensionAttribute]
public static object SetIndexer(object obj, Type[] parameterTypes, Object[] parameters);
    [ExtensionAttribute]
public static object GetIndexer(object obj, Object[] parameters);
    [ExtensionAttribute]
public static object GetIndexer(object obj, Type[] parameterTypes, Object[] parameters);
    [ExtensionAttribute]
public static object SetIndexer(object obj, Flags bindingFlags, Object[] parameters);
    [ExtensionAttribute]
public static object SetIndexer(object obj, Type[] parameterTypes, Flags bindingFlags, Object[] parameters);
    [ExtensionAttribute]
public static object GetIndexer(object obj, Flags bindingFlags, Object[] parameters);
    [ExtensionAttribute]
public static object GetIndexer(object obj, Type[] parameterTypes, Flags bindingFlags, Object[] parameters);
    [ExtensionAttribute]
public static MethodInvoker DelegateForSetIndexer(Type type, Type[] parameterTypes);
    [ExtensionAttribute]
public static MethodInvoker DelegateForGetIndexer(Type type, Type[] parameterTypes);
    [ExtensionAttribute]
public static MethodInvoker DelegateForSetIndexer(Type type, Flags bindingFlags, Type[] parameterTypes);
    [ExtensionAttribute]
public static MethodInvoker DelegateForGetIndexer(Type type, Flags bindingFlags, Type[] parameterTypes);
    [ExtensionAttribute]
public static PropertyInfo Property(Type type, string name);
    [ExtensionAttribute]
public static PropertyInfo Property(Type type, string name, Flags bindingFlags);
    [ExtensionAttribute]
public static IList`1<PropertyInfo> Properties(Type type, String[] names);
    [ExtensionAttribute]
public static IList`1<PropertyInfo> Properties(Type type, Flags bindingFlags, String[] names);
    private static IList`1<PropertyInfo> GetProperties(Type type, Flags bindingFlags);
    [ExtensionAttribute]
public static object TryGetPropertyValue(object obj, string name);
    [ExtensionAttribute]
public static object TryGetPropertyValue(object obj, string name, Flags bindingFlags);
    [ExtensionAttribute]
public static bool TrySetPropertyValue(object obj, string name, object value);
    [ExtensionAttribute]
public static bool TrySetPropertyValue(object obj, string name, object value, Flags bindingFlags);
}
[ExtensionAttribute]
internal static class Fasterflect.PropertyInfoExtensions : object {
    [ExtensionAttribute]
public static void Set(PropertyInfo propInfo, object value);
    [ExtensionAttribute]
public static void Set(PropertyInfo propInfo, object obj, object value);
    [ExtensionAttribute]
public static object Get(PropertyInfo propInfo);
    [ExtensionAttribute]
public static object Get(PropertyInfo propInfo, object obj);
    [ExtensionAttribute]
public static MemberSetter DelegateForSetPropertyValue(PropertyInfo propInfo);
    [ExtensionAttribute]
public static MemberSetter DelegateForSetPropertyValue(PropertyInfo propInfo, Flags bindingFlags);
    [ExtensionAttribute]
public static MemberGetter DelegateForGetPropertyValue(PropertyInfo propInfo);
    [ExtensionAttribute]
public static MemberGetter DelegateForGetPropertyValue(PropertyInfo propInfo, Flags bindingFlags);
}
[ExtensionAttribute]
internal static class Fasterflect.TryCallMethodExtensions : object {
    [ExtensionAttribute]
public static object TryCallMethod(object obj, string methodName, bool mustUseAllParameters, object sample);
    [ExtensionAttribute]
public static object TryCallMethod(object obj, string methodName, bool mustUseAllParameters, IDictionary`2<string, object> parameters);
    [ExtensionAttribute]
public static object TryCallMethod(object obj, string methodName, bool mustUseAllParameters, String[] parameterNames, Type[] parameterTypes, Object[] parameterValues);
}
[ExtensionAttribute]
internal static class Fasterflect.TryCreateInstanceExtensions : object {
    private static Cache`2<Type, SourceInfo> sourceInfoCache;
    private static TryCreateInstanceExtensions();
    [ExtensionAttribute]
public static object TryCreateInstance(Type type, object sample);
    [ExtensionAttribute]
public static object TryCreateInstance(Type type, IDictionary`2<string, object> parameters);
    [ExtensionAttribute]
public static object TryCreateInstance(Type type, String[] parameterNames, Object[] parameterValues);
    [ExtensionAttribute]
public static object TryCreateInstance(Type type, String[] parameterNames, Type[] parameterTypes, Object[] parameterValues);
}
[ExtensionAttribute]
internal static class Fasterflect.TryInvokeWithValuesExtensions : object {
    [CompilerGeneratedAttribute]
private static Func`2<object, string> CS$<>9__CachedAnonymousMethodDelegate1;
    [CompilerGeneratedAttribute]
private static Func`2<object, string> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<MethodBase, <>f__AnonymousType4`2<MethodBase, ParameterInfo[]>> CS$<>9__CachedAnonymousMethodDelegatec;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType4`2<MethodBase, ParameterInfo[]>, int> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType4`2<MethodBase, ParameterInfo[]>, MethodBase> CS$<>9__CachedAnonymousMethodDelegatee;
    [ExtensionAttribute]
public static object TryCreateInstanceWithValues(Type type, Object[] parameterValues);
    [ExtensionAttribute]
public static object TryCreateInstanceWithValues(Type type, ParameterConverter converter, BindingFlags flags, Object[] parameterValues);
    [ExtensionAttribute]
public static object TryCallMethodWithValues(object obj, string methodName, Object[] parameterValues);
    [ExtensionAttribute]
public static object TryCallMethodWithValues(object obj, ParameterConverter converter, string methodName, BindingFlags flags, Object[] parameterValues);
    [ExtensionAttribute]
public static object TryCallMethodWithValues(object obj, ParameterConverter converter, string methodName, Type[] genericTypes, BindingFlags flags, Object[] parameterValues);
    public static object TryCall(ParameterConverter converter, IEnumerable`1<MethodBase> methodBases, object obj, Object[] parameterValues);
    private static IEnumerable`1<MethodBase> GetCandidates(Object[] parameterValues, IEnumerable`1<MethodBase> methodBases);
    private static bool StandardConvert(Type targetType, object owner, Object& value);
    private static bool IsParams(ParameterInfo param);
    [CompilerGeneratedAttribute]
private static string <TryCreateInstanceWithValues>b__0(object v);
    [CompilerGeneratedAttribute]
private static string <TryCallMethodWithValues>b__3(object v);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType4`2<MethodBase, ParameterInfo[]> <GetCandidates>b__8(MethodBase methodBase);
    [CompilerGeneratedAttribute]
private static int <GetCandidates>b__a(<>f__AnonymousType4`2<MethodBase, ParameterInfo[]> <>h__TransparentIdentifier7);
    [CompilerGeneratedAttribute]
private static MethodBase <GetCandidates>b__b(<>f__AnonymousType4`2<MethodBase, ParameterInfo[]> <>h__TransparentIdentifier7);
}
[ExtensionAttribute]
internal static class Fasterflect.TypeExtensions : object {
    private static List`1<Byte[]> tokens;
    [CompilerGeneratedAttribute]
private static Func`2<Type, bool> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<Type, Type> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<Type, string> CS$<>9__CachedAnonymousMethodDelegate8;
    private static TypeExtensions();
    [ExtensionAttribute]
public static bool Implements(Type type);
    [ExtensionAttribute]
public static bool Implements(Type type, Type interfaceType);
    [ExtensionAttribute]
public static bool Inherits(Type type);
    [ExtensionAttribute]
public static bool Inherits(Type type, Type baseType);
    [ExtensionAttribute]
public static bool InheritsOrImplements(Type type);
    [ExtensionAttribute]
public static bool InheritsOrImplements(Type type, Type baseType);
    [ExtensionAttribute]
public static bool IsFrameworkType(Type type);
    [ExtensionAttribute]
public static string Name(Type type);
    private static string GetCSharpTypeName(string typeName);
    [CompilerGeneratedAttribute]
private static bool <Implements>b__0(Type t);
    [CompilerGeneratedAttribute]
private static Type <Implements>b__1(Type t);
    [CompilerGeneratedAttribute]
private static string <Name>b__7(Type t);
}
[DebuggerStepThroughAttribute]
[ExtensionAttribute]
internal static class Fasterflect.Utils : object {
    [ExtensionAttribute]
public static Type GetTypeAdjusted(object obj);
    [ExtensionAttribute]
public static Type[] ToTypeArray(ParameterInfo[] parameters);
    [ExtensionAttribute]
public static Type[] ToTypeArray(Object[] objects);
    [ExtensionAttribute]
public static void ForEach(IEnumerable`1<T> source, Action`1<T> action);
}
[ExtensionAttribute]
internal static class Fasterflect.ValueTypeExtensions : object {
    [ExtensionAttribute]
public static object WrapIfValueType(object obj);
    [ExtensionAttribute]
public static object UnwrapIfWrapped(object obj);
    [ExtensionAttribute]
public static bool IsWrapped(object obj);
}
[ExtensionAttribute]
internal static class Fasterflect.XmlTransformerExtensions : object {
    [ExtensionAttribute]
public static string ToXml(object obj);
    [ExtensionAttribute]
public static string ToXml(object obj, FormatOptions options);
    private static string ToXml(object obj, string header, string afterElementDecoration, string indentDecoration, string currentIndent);
    private static string Indent(string indent, string currentIndent);
    private static string Unindent(string indent, string currentIndent);
}
internal class ILRepacking.Application : object {
    [STAThreadAttribute]
private static int Main(String[] args);
    private static void Usage();
    private static void Exit(int exitCode);
}
internal class ILRepacking.BinaryArray : ObjectWithId {
    public int Rank;
    public List`1<int> Lengths;
    public List`1<int> LowerBounds;
    [CompilerGeneratedAttribute]
private Nullable`1<BinaryTypeEnumeration> <BinaryType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PrimitiveTypeEnumeration> <PrimitiveType>k__BackingField;
    [CompilerGeneratedAttribute]
private ClassTypeInfo <TypeInfo>k__BackingField;
    public SerialObject RelevantObject { get; public set; }
    public Nullable`1<BinaryTypeEnumeration> BinaryType { get; public set; }
    public Nullable`1<PrimitiveTypeEnumeration> PrimitiveType { get; public set; }
    public ClassTypeInfo TypeInfo { get; public set; }
    private int Slots { get; }
    internal BinaryArray(BinaryTypeEnumeration type);
    internal BinaryArray ReadStruct(SerReader analyzer);
    public BinaryArray ReadLengths(SerReader analyzer);
    public BinaryArray ReadObjectId(SerReader analyzer);
    public BinaryArray ReadValues(SerReader analyzer);
    public sealed virtual SerialObject get_RelevantObject();
    public sealed virtual void set_RelevantObject(SerialObject value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<BinaryTypeEnumeration> get_BinaryType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BinaryType(Nullable`1<BinaryTypeEnumeration> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<PrimitiveTypeEnumeration> get_PrimitiveType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PrimitiveType(Nullable`1<PrimitiveTypeEnumeration> value);
    [CompilerGeneratedAttribute]
public sealed virtual ClassTypeInfo get_TypeInfo();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TypeInfo(ClassTypeInfo value);
    private int get_Slots();
    public BinaryArray ReadPrimitiveType(SerReader analyzer);
}
internal enum ILRepacking.BinaryArrayTypeEnumeration : Enum {
    public int value__;
    public static BinaryArrayTypeEnumeration Single;
    public static BinaryArrayTypeEnumeration Jagged;
    public static BinaryArrayTypeEnumeration Rectangular;
    public static BinaryArrayTypeEnumeration SingleOffset;
    public static BinaryArrayTypeEnumeration JaggedOffset;
    public static BinaryArrayTypeEnumeration RectangularOffset;
}
internal class ILRepacking.BinaryLibrary : object {
    public int LibraryID;
    public string Name;
}
internal enum ILRepacking.BinaryTypeEnumeration : Enum {
    public int value__;
    public static BinaryTypeEnumeration Primitive;
    public static BinaryTypeEnumeration String;
    public static BinaryTypeEnumeration Object;
    public static BinaryTypeEnumeration SystemClass;
    public static BinaryTypeEnumeration Class;
    public static BinaryTypeEnumeration ObjectArray;
    public static BinaryTypeEnumeration StringArray;
    public static BinaryTypeEnumeration PrimitiveArray;
}
internal class ILRepacking.ClassInfo : ObjectWithId {
    public string Name;
    public List`1<MemberInfo> Members;
    public int ReferenceCount;
    internal ClassInfo ReadMembers(SerReader analyzer);
    internal ClassInfo ReadTypeInfo(SerReader analyzer);
    public ClassInfo ReadValues(SerReader analyzer);
    public ClassInfo ReadLibraryId(SerReader analyzer);
    public ClassInfo ReadObjectId(SerReader analyzer);
}
internal class ILRepacking.ClassTypeInfo : object {
    public string TypeName;
    public Nullable`1<int> LibraryID;
}
public class ILRepacking.CommandLine : object {
    private List`1<string> parameters;
    public String[] OtherAguments { get; }
    public int OptionsCount { get; }
    public bool HasNoOptions { get; }
    public CommandLine(IEnumerable`1<string> args);
    public sealed virtual String[] get_OtherAguments();
    public sealed virtual bool Modifier(string modifier);
    public sealed virtual string Option(string name);
    public sealed virtual bool HasOption(string name);
    public sealed virtual String[] Options(string name);
    public sealed virtual bool OptionBoolean(string name, bool def);
    public int get_OptionsCount();
    public sealed virtual bool get_HasNoOptions();
    private static string OptionFinder(string option, string param);
}
internal static class ILRepacking.ConfigMerger : object {
    internal static void Process(ILRepack repack);
}
internal static class ILRepacking.DocumentationMerger : object {
    internal static void Process(ILRepack repack);
}
internal class ILRepacking.FileWrapper : object {
    public sealed virtual bool Exists(string path);
    public sealed virtual String[] ReadAllLines(string path);
}
internal interface ILRepacking.ICommandLine {
    public String[] OtherAguments { get; }
    public bool HasNoOptions { get; }
    public abstract virtual String[] get_OtherAguments();
    public abstract virtual bool Modifier(string modifier);
    public abstract virtual string Option(string name);
    public abstract virtual bool HasOption(string name);
    public abstract virtual String[] Options(string name);
    public abstract virtual bool OptionBoolean(string name, bool def);
    public abstract virtual bool get_HasNoOptions();
}
internal interface ILRepacking.IFile {
    public abstract virtual bool Exists(string path);
    public abstract virtual String[] ReadAllLines(string path);
}
internal class ILRepacking.IKVMLineIndexer : object {
    private IRepackContext repack;
    private bool enabled;
    private LineNumberWriter lineNumberWriter;
    private string fileName;
    private TypeReference sourceFileAttributeTypeReference;
    private TypeReference lineNumberTableAttributeTypeReference;
    private MethodReference lineNumberTableAttributeConstructor1;
    private MethodReference lineNumberTableAttributeConstructor2;
    private MethodReference sourceFileAttributeConstructor;
    protected ModuleDefinition TargetAssemblyMainModule { get; }
    public IKVMLineIndexer(IRepackContext ilRepack, bool doLineIndexing);
    protected ModuleDefinition get_TargetAssemblyMainModule();
    public void Reset();
    public void PreMethodBodyRepack(MethodBody body, MethodDefinition parent);
    public void ProcessMethodBodyInstruction(Instruction instr);
    public void PostMethodBodyRepack(MethodDefinition parent);
    public void PostRepackReferences();
    [CompilerGeneratedAttribute]
private CustomAttributeArgument <PostMethodBodyRepack>b__15_0(byte b);
}
public interface ILRepacking.ILogger {
    public bool ShouldLogVerbose { get; public set; }
    public abstract virtual bool get_ShouldLogVerbose();
    public abstract virtual void set_ShouldLogVerbose(bool value);
    public abstract virtual void Log(object str);
    public abstract virtual void Error(string msg);
    public abstract virtual void Warn(string msg);
    public abstract virtual void Info(string msg);
    public abstract virtual void Verbose(string msg);
    public abstract virtual void DuplicateIgnored(string ignoredType, object ignoredObject);
}
public class ILRepacking.ILRepack : object {
    internal RepackOptions Options;
    internal ILogger Logger;
    [CompilerGeneratedAttribute]
private IList`1<string> <MergedAssemblyFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PrimaryAssemblyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<AssemblyDefinition> <OtherAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<AssemblyDefinition> <MergedAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyDefinition <TargetAssemblyDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyDefinition <PrimaryAssemblyDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private RepackAssemblyResolver <GlobalAssemblyResolver>k__BackingField;
    private IKVMLineIndexer _lineIndexer;
    private ReflectionHelper _reflectionHelper;
    private PlatformFixer _platformFixer;
    private MappingHandler _mappingHandler;
    private static Regex TypeRegex;
    private Dictionary`2<AssemblyDefinition, int> _aspOffsets;
    private RepackImporter _repackImporter;
    internal IList`1<string> MergedAssemblyFiles { get; internal set; }
    internal string PrimaryAssemblyFile { get; internal set; }
    public IList`1<AssemblyDefinition> OtherAssemblies { get; private set; }
    public IList`1<AssemblyDefinition> MergedAssemblies { get; private set; }
    public AssemblyDefinition TargetAssemblyDefinition { get; private set; }
    public AssemblyDefinition PrimaryAssemblyDefinition { get; private set; }
    public RepackAssemblyResolver GlobalAssemblyResolver { get; }
    public ModuleDefinition TargetAssemblyMainModule { get; }
    public ModuleDefinition PrimaryAssemblyMainModule { get; }
    private IKVMLineIndexer ILRepacking.IRepackContext.LineIndexer { get; }
    private ReflectionHelper ILRepacking.IRepackContext.ReflectionHelper { get; }
    private PlatformFixer ILRepacking.IRepackContext.PlatformFixer { get; }
    private MappingHandler ILRepacking.IRepackContext.MappingHandler { get; }
    public ILRepack(RepackOptions options);
    public ILRepack(RepackOptions options, ILogger logger);
    private static ILRepack();
    [CompilerGeneratedAttribute]
internal IList`1<string> get_MergedAssemblyFiles();
    [CompilerGeneratedAttribute]
internal void set_MergedAssemblyFiles(IList`1<string> value);
    [CompilerGeneratedAttribute]
internal string get_PrimaryAssemblyFile();
    [CompilerGeneratedAttribute]
internal void set_PrimaryAssemblyFile(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<AssemblyDefinition> get_OtherAssemblies();
    [CompilerGeneratedAttribute]
private void set_OtherAssemblies(IList`1<AssemblyDefinition> value);
    [CompilerGeneratedAttribute]
public sealed virtual IList`1<AssemblyDefinition> get_MergedAssemblies();
    [CompilerGeneratedAttribute]
private void set_MergedAssemblies(IList`1<AssemblyDefinition> value);
    [CompilerGeneratedAttribute]
public sealed virtual AssemblyDefinition get_TargetAssemblyDefinition();
    [CompilerGeneratedAttribute]
private void set_TargetAssemblyDefinition(AssemblyDefinition value);
    [CompilerGeneratedAttribute]
public sealed virtual AssemblyDefinition get_PrimaryAssemblyDefinition();
    [CompilerGeneratedAttribute]
private void set_PrimaryAssemblyDefinition(AssemblyDefinition value);
    [CompilerGeneratedAttribute]
public sealed virtual RepackAssemblyResolver get_GlobalAssemblyResolver();
    public sealed virtual ModuleDefinition get_TargetAssemblyMainModule();
    public sealed virtual ModuleDefinition get_PrimaryAssemblyMainModule();
    private sealed virtual override IKVMLineIndexer ILRepacking.IRepackContext.get_LineIndexer();
    private sealed virtual override ReflectionHelper ILRepacking.IRepackContext.get_ReflectionHelper();
    private sealed virtual override PlatformFixer ILRepacking.IRepackContext.get_PlatformFixer();
    private sealed virtual override MappingHandler ILRepacking.IRepackContext.get_MappingHandler();
    private void ReadInputAssemblies();
    private AssemblyDefinitionContainer ReadInputAssembly(string assembly, bool isPrimary);
    private sealed virtual override IMetadataScope ILRepacking.IRepackContext.MergeScope(IMetadataScope scope);
    private TargetRuntime ParseTargetPlatform();
    private string ResolveTargetPlatformDirectory(string version);
    public static IEnumerable`1<AssemblyName> GetRepackAssemblyNames(Type typeInRepackedAssembly);
    public static AssemblyName GetRepackAssemblyName(IEnumerable`1<AssemblyName> repackAssemblyNames, string repackedAssemblyName, Type fallbackType);
    private void PrintRepackHeader();
    public void Repack();
    private ISourceServerDataRepackStep GetSourceServerDataStep(bool isUnixEnvironment);
    private void ResolveSearchDirectories();
    private ResourceDirectory MergeWin32Resources(ResourceDirectory primary);
    private void MergeDirectory(List`1<ResourceEntry> parents, ResourceDirectory ret, AssemblyDefinition ass, ResourceDirectory directory);
    private void MergeEntry(List`1<ResourceEntry> parents, ResourceEntry exist, AssemblyDefinition ass, ResourceEntry entry);
    private static bool IsAspResourceEntry(List`1<ResourceEntry> parents, ResourceEntry exist);
    private static bool IsVersionInfoResource(List`1<ResourceEntry> parents, ResourceEntry exist);
    private sealed virtual override string ILRepacking.IRepackContext.FixStr(string content);
    private sealed virtual override string ILRepacking.IRepackContext.FixReferenceInIkvmAttribute(string content);
    private string FixStr(string content, bool javaAttribute);
    private sealed virtual override string ILRepacking.IRepackContext.FixTypeName(string assemblyName, string typeName);
    private sealed virtual override string ILRepacking.IRepackContext.FixAssemblyName(string assemblyName);
    private AssemblyNameDefinition Clone(AssemblyNameDefinition assemblyName);
    private sealed virtual override TypeDefinition ILRepacking.IRepackContext.GetMergedTypeFromTypeRef(TypeReference reference);
    private sealed virtual override TypeReference ILRepacking.IRepackContext.GetExportedTypeFromTypeRef(TypeReference type);
}
internal interface ILRepacking.IRepackContext {
    public RepackAssemblyResolver GlobalAssemblyResolver { get; }
    public IList`1<AssemblyDefinition> MergedAssemblies { get; }
    public ModuleDefinition TargetAssemblyMainModule { get; }
    public PlatformFixer PlatformFixer { get; }
    public ReflectionHelper ReflectionHelper { get; }
    public MappingHandler MappingHandler { get; }
    public IKVMLineIndexer LineIndexer { get; }
    public AssemblyDefinition TargetAssemblyDefinition { get; }
    public IList`1<AssemblyDefinition> OtherAssemblies { get; }
    public AssemblyDefinition PrimaryAssemblyDefinition { get; }
    public ModuleDefinition PrimaryAssemblyMainModule { get; }
    public abstract virtual RepackAssemblyResolver get_GlobalAssemblyResolver();
    public abstract virtual IList`1<AssemblyDefinition> get_MergedAssemblies();
    public abstract virtual ModuleDefinition get_TargetAssemblyMainModule();
    public abstract virtual PlatformFixer get_PlatformFixer();
    public abstract virtual ReflectionHelper get_ReflectionHelper();
    public abstract virtual MappingHandler get_MappingHandler();
    public abstract virtual IKVMLineIndexer get_LineIndexer();
    public abstract virtual AssemblyDefinition get_TargetAssemblyDefinition();
    public abstract virtual IList`1<AssemblyDefinition> get_OtherAssemblies();
    public abstract virtual AssemblyDefinition get_PrimaryAssemblyDefinition();
    public abstract virtual ModuleDefinition get_PrimaryAssemblyMainModule();
    public abstract virtual TypeDefinition GetMergedTypeFromTypeRef(TypeReference type);
    public abstract virtual TypeReference GetExportedTypeFromTypeRef(TypeReference type);
    public abstract virtual IMetadataScope MergeScope(IMetadataScope name);
    public abstract virtual string FixTypeName(string assemblyName, string typeName);
    public abstract virtual string FixAssemblyName(string assemblyName);
    public abstract virtual string FixStr(string content);
    public abstract virtual string FixReferenceInIkvmAttribute(string content);
}
internal interface ILRepacking.IRepackCopier {
    public abstract virtual CustomAttribute Copy(CustomAttribute ca, IGenericParameterProvider context);
    public abstract virtual CustomAttributeArgument Copy(CustomAttributeArgument arg, IGenericParameterProvider context);
    public abstract virtual CustomAttributeNamedArgument Copy(CustomAttributeNamedArgument namedArg, IGenericParameterProvider context);
    public abstract virtual void CopySecurityDeclarations(Collection`1<SecurityDeclaration> input, Collection`1<SecurityDeclaration> output, IGenericParameterProvider context);
    public abstract virtual void CopyGenericParameters(Collection`1<GenericParameter> input, Collection`1<GenericParameter> output, IGenericParameterProvider nt);
    public abstract virtual void CopyCustomAttributes(Collection`1<CustomAttribute> input, Collection`1<CustomAttribute> output, IGenericParameterProvider context);
    public abstract virtual void CopyCustomAttributes(Collection`1<CustomAttribute> input, Collection`1<CustomAttribute> output, bool allowMultiple, IGenericParameterProvider context);
    public abstract virtual void CopyTypeReferences(Collection`1<TypeReference> input, Collection`1<TypeReference> output, IGenericParameterProvider context);
}
internal interface ILRepacking.IRepackImporter {
    public abstract virtual TypeReference Import(TypeReference reference, IGenericParameterProvider context);
    public abstract virtual FieldReference Import(FieldReference reference, IGenericParameterProvider context);
    public abstract virtual MethodReference Import(MethodReference reference);
    public abstract virtual MethodReference Import(MethodReference reference, IGenericParameterProvider context);
    public abstract virtual TypeDefinition Import(TypeDefinition type, Collection`1<TypeDefinition> col, bool internalize);
    public abstract virtual void Import(ExportedType type, Collection`1<ExportedType> col, ModuleDefinition module);
}
internal class ILRepacking.LineNumberWriter : object {
    private MemoryStream stream;
    private int prevILOffset;
    private int prevLineNum;
    private int count;
    public int Count { get; }
    public int LineNo { get; }
    public LineNumberWriter(int estimatedCount);
    public void AddMapping(int ilOffset, int linenumber);
    public int get_Count();
    public int get_LineNo();
    public Byte[] ToArray();
    private void WritePackedInteger(int val);
}
internal class ILRepacking.MappingHandler : object {
    private IDictionary`2<Pair, TypeDefinition> mappings;
    private IDictionary`2<Pair, TypeReference> exportMappings;
    internal TypeDefinition GetRemappedType(TypeReference r);
    internal void StoreRemappedType(TypeDefinition orig, TypeDefinition renamed);
    internal void StoreExportedType(IMetadataScope scope, string fullName, TypeReference exportedTo);
    private static Pair GetTypeKey(TypeReference reference);
    private static Pair GetTypeKey(IMetadataScope scope, string fullName);
    internal static string GetScopeName(IMetadataScope scope);
    internal static string GetScopeFullName(IMetadataScope scope);
    private TypeReference GetRootReference(TypeReference type);
    public TypeReference GetExportedRemappedType(TypeReference type);
    internal T GetOrigTypeScope(TypeDefinition nt);
}
internal class ILRepacking.MemberInfo : object {
    public string Name;
    [CompilerGeneratedAttribute]
private SerialObject <RelevantObject>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<BinaryTypeEnumeration> <BinaryType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<PrimitiveTypeEnumeration> <PrimitiveType>k__BackingField;
    [CompilerGeneratedAttribute]
private ClassTypeInfo <TypeInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ValueRefID>k__BackingField;
    public SerialObject RelevantObject { get; public set; }
    public Nullable`1<BinaryTypeEnumeration> BinaryType { get; public set; }
    public Nullable`1<PrimitiveTypeEnumeration> PrimitiveType { get; public set; }
    public ClassTypeInfo TypeInfo { get; public set; }
    public object Value { get; public set; }
    public object ValueRefID { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual SerialObject get_RelevantObject();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RelevantObject(SerialObject value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<BinaryTypeEnumeration> get_BinaryType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_BinaryType(Nullable`1<BinaryTypeEnumeration> value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<PrimitiveTypeEnumeration> get_PrimitiveType();
    [CompilerGeneratedAttribute]
public sealed virtual void set_PrimitiveType(Nullable`1<PrimitiveTypeEnumeration> value);
    [CompilerGeneratedAttribute]
public sealed virtual ClassTypeInfo get_TypeInfo();
    [CompilerGeneratedAttribute]
public sealed virtual void set_TypeInfo(ClassTypeInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Value(object value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_ValueRefID();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ValueRefID(object value);
}
internal class ILRepacking.MethodMatcher : object {
    public static MethodDefinition MapVirtualMethodToDeepestBase(MethodDefinition method);
    private static MethodDefinition GetBaseMethodInTypeHierarchy(MethodDefinition method);
    private static MethodDefinition TryMatchMethod(TypeDefinition type, MethodDefinition method);
    private static bool MethodMatch(MethodDefinition candidate, MethodDefinition method);
    private static bool TypeMatch(IModifierType a, IModifierType b);
    private static bool TypeMatch(TypeSpecification a, TypeSpecification b);
    private static bool TypeMatch(GenericInstanceType a, GenericInstanceType b);
    private static bool TypeMatch(TypeReference a, TypeReference b);
    private static TypeDefinition GetBaseType(TypeDefinition type);
}
[ExtensionAttribute]
internal static class ILRepacking.Mixins.AssemblyNameReferenceCollectionMixins : object {
    [ExtensionAttribute]
public static AssemblyNameReference AddUniquely(Collection`1<AssemblyNameReference> this, AssemblyNameReference add);
    private static bool Equals(Byte[] a, Byte[] b);
    private static bool Equals(T a, T b);
    private static bool Equals(AssemblyNameReference a, AssemblyNameReference b);
}
internal class ILRepacking.ObjectString : ObjectWithId {
    public string String;
    public ObjectString ReadObjectId(SerReader analyzer);
    public ObjectString ReadString(SerReader analyzer);
}
internal class ILRepacking.ObjectWithId : object {
    [CompilerGeneratedAttribute]
private int <ObjectID>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <ParentObjectID>k__BackingField;
    public int ObjectID { get; public set; }
    public Nullable`1<long> ParentObjectID { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual int get_ObjectID();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ObjectID(int value);
    [CompilerGeneratedAttribute]
public sealed virtual Nullable`1<long> get_ParentObjectID();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ParentObjectID(Nullable`1<long> value);
    public ObjectWithId ReadObjectId(SerReader analyzer);
}
internal class ILRepacking.PermissionsetHelper : object {
    private static TypeReference GetTypeRef(string nameSpace, string name, string assemblyName, ModuleDefinition targetModule);
    public static bool IsXmlPermissionSet(SecurityDeclaration xmlDeclaration);
    public static SecurityDeclaration Permission2XmlSet(SecurityDeclaration declaration, ModuleDefinition targetModule);
    public static SecurityDeclaration Xml2PermissionSet(SecurityDeclaration xmlDeclaration, ModuleDefinition targetModule);
}
internal class ILRepacking.PlatformFixer : object {
    private IRepackContext repack;
    private TargetRuntime sourceRuntime;
    private TargetRuntime targetRuntime;
    private string targetPlatformDirectory;
    private Hashtable platformAssemblies;
    public PlatformFixer(IRepackContext repack, TargetRuntime runtime);
    public void ParseTargetPlatformDirectory(TargetRuntime runtime, string platformDirectory);
    private AssemblyDefinition TryGetPlatformAssembly(AssemblyNameReference sourceAssemblyName);
    public IMetadataScope FixPlatformVersion(AssemblyNameReference assyName);
    private IMetadataScope GetFixedPlatformVersion(AssemblyNameReference assyName);
    public void FixPlatformVersion(TypeReference reference);
    private void FixPlatformVersionOnMethodSpecification(MethodReference method);
    public void FixPlatformVersion(MethodReference reference);
    public void FixPlatformVersion(FieldReference reference);
    private void FixPlatformVersion(ParameterDefinition pd);
    private void FixPlatformVersion(GenericParameter gp);
    private void FixPlatformVersion(CustomAttribute ca);
    private void FixPlatformVersion(CustomAttributeArgument caa);
    private void FixPlatformVersion(CustomAttributeNamedArgument cana);
}
internal enum ILRepacking.PrimitiveTypeEnumeration : Enum {
    public int value__;
    public static PrimitiveTypeEnumeration Boolean;
    public static PrimitiveTypeEnumeration Byte;
    public static PrimitiveTypeEnumeration Char;
    public static PrimitiveTypeEnumeration Decimal;
    public static PrimitiveTypeEnumeration Double;
    public static PrimitiveTypeEnumeration Int16;
    public static PrimitiveTypeEnumeration Int32;
    public static PrimitiveTypeEnumeration Int64;
    public static PrimitiveTypeEnumeration SByte;
    public static PrimitiveTypeEnumeration Single;
    public static PrimitiveTypeEnumeration TimeSpan;
    public static PrimitiveTypeEnumeration DateTime;
    public static PrimitiveTypeEnumeration UInt16;
    public static PrimitiveTypeEnumeration UInt32;
    public static PrimitiveTypeEnumeration UInt64;
    public static PrimitiveTypeEnumeration Null;
    public static PrimitiveTypeEnumeration String;
}
internal enum ILRepacking.RecordTypeEnumeration : Enum {
    public int value__;
    public static RecordTypeEnumeration SerializedStreamHeader;
    public static RecordTypeEnumeration ClassWithID;
    public static RecordTypeEnumeration SystemClassWithMembers;
    public static RecordTypeEnumeration ClassWithMembers;
    public static RecordTypeEnumeration SystemClassWithMembersAndTypes;
    public static RecordTypeEnumeration ClassWithMembersAndTypes;
    public static RecordTypeEnumeration BinaryObjectString;
    public static RecordTypeEnumeration BinaryArray;
    public static RecordTypeEnumeration MemberPrimitiveTyped;
    public static RecordTypeEnumeration MemberReference;
    public static RecordTypeEnumeration ObjectNull;
    public static RecordTypeEnumeration MessageEnd;
    public static RecordTypeEnumeration BinaryLibrary;
    public static RecordTypeEnumeration ObjectNullMultiple256;
    public static RecordTypeEnumeration ObjectNullMultiple;
    public static RecordTypeEnumeration ArraySinglePrimitive;
    public static RecordTypeEnumeration ArraySingleObject;
    public static RecordTypeEnumeration ArraySingleString;
    public static RecordTypeEnumeration MethodCall;
    public static RecordTypeEnumeration MethodReturn;
}
internal class ILRepacking.ReferenceFixator : object {
    private ILogger _logger;
    private IRepackContext _repackContext;
    private string targetAssemblyPublicKeyBlobString;
    private HashSet`1<GenericParameter> fixedGenericParameters;
    private bool renameIkvmAttributeReference;
    public ReferenceFixator(ILogger logger, IRepackContext repackContext);
    private ModuleReference Fix(ModuleReference moduleRef);
    private FieldReference Fix(FieldReference field);
    private TypeReference Fix(TypeReference type);
    internal void FixMethodVisibility(TypeDefinition type);
    internal void FixReferences(TypeDefinition type);
    private void FixReferences(FieldDefinition field);
    private void FixReferences(VariableDefinition var);
    private CustomAttributeArgument Fix(CustomAttributeArgument arg);
    private object FixCustomAttributeValue(object obj);
    private CustomAttributeNamedArgument Fix(CustomAttributeNamedArgument namedArg);
    private void FixReferences(Collection`1<CustomAttributeArgument> args);
    private void FixReferences(Collection`1<CustomAttributeNamedArgument> namedArgs);
    internal void FixReferences(Collection`1<SecurityDeclaration> securitydeclarations);
    private void FixReferences(MethodDefinition meth);
    private void FixReferences(MethodBody body);
    private void FixReferences(Instruction instr);
    internal void FixReferences(Collection`1<ExportedType> exportedTypes);
    internal void FixReferences(Collection`1<CustomAttribute> attributes);
    private bool IsAnnotation(TypeDefinition typeAttribute);
    private void FixReferences(Collection`1<TypeReference> refs);
    private void FixReferences(Collection`1<ParameterDefinition> parameters);
    private void FixReferences(Collection`1<GenericParameter> parameters);
    private void FixReferences(EventDefinition definition);
    private void FixReferences(PropertyDefinition definition);
    private void FixReferences(ParameterDefinition definition);
    private void FixReferences(GenericParameter definition);
    private GenericInstanceMethod Fix(GenericInstanceMethod method);
    internal MethodReference Fix(MethodReference method);
    private void FixReferences(Collection`1<MethodReference> parameters);
    private TypeSpecification Fix(TypeSpecification type);
    private void Fix(MethodDefinition base, MethodDefinition over);
    public void FixOverridenMethodDef(MethodDefinition meth);
    [CompilerGeneratedAttribute]
private CustomAttributeArgument <FixCustomAttributeValue>b__14_0(CustomAttributeArgument a);
}
internal class ILRepacking.ReflectionHelper : object {
    private IRepackContext _repack;
    internal ReflectionHelper(IRepackContext repack);
    internal MethodDefinition FindMethodDefinitionInType(TypeDefinition type, MethodReference method);
    internal bool AreSame(IList`1<ParameterDefinition> a, IList`1<ParameterDefinition> b);
    internal bool AreSame(TypeSpecification a, TypeSpecification b);
    internal bool AreSame(ArrayType a, ArrayType b);
    internal bool AreSame(IModifierType a, IModifierType b);
    internal bool AreSame(GenericInstanceType a, GenericInstanceType b);
    internal bool AreSame(GenericParameter a, GenericParameter b);
    internal bool AreSame(TypeReference a, TypeReference b);
    internal bool AreSame(Collection`1<CustomAttributeArgument> a, Collection`1<CustomAttributeArgument> b);
    internal bool AreSame(CustomAttributeArgument a, CustomAttributeArgument b);
    internal bool AreSame(Collection`1<CustomAttributeNamedArgument> a, Collection`1<CustomAttributeNamedArgument> b);
}
public class ILRepacking.RepackAssemblyResolver : DefaultAssemblyResolver {
    public void RegisterAssemblies(IList`1<AssemblyDefinition> mergedAssemblies);
}
internal class ILRepacking.RepackImporter : object {
    private ILogger _logger;
    private IRepackContext _repackContext;
    private RepackOptions _options;
    private Dictionary`2<AssemblyDefinition, int> _aspOffsets;
    public RepackImporter(ILogger logger, RepackOptions options, IRepackContext repackContext, Dictionary`2<AssemblyDefinition, int> aspOffsets);
    public sealed virtual void Import(ExportedType type, Collection`1<ExportedType> col, ModuleDefinition module);
    public sealed virtual TypeReference Import(TypeReference reference, IGenericParameterProvider context);
    public sealed virtual FieldReference Import(FieldReference reference, IGenericParameterProvider context);
    public sealed virtual MethodReference Import(MethodReference reference);
    public sealed virtual MethodReference Import(MethodReference reference, IGenericParameterProvider context);
    public sealed virtual TypeDefinition Import(TypeDefinition type, Collection`1<TypeDefinition> col, bool internalize);
    private static bool IsModuleTag(TypeDefinition nt);
    private string GenerateName(TypeDefinition typeDefinition);
    private bool ShouldDrop(TMember member);
    private void CloneTo(FieldDefinition field, TypeDefinition nt);
    private void CloneTo(ParameterDefinition param, MethodDefinition context, Collection`1<ParameterDefinition> col);
    private void CloneTo(EventDefinition evt, TypeDefinition nt, Collection`1<EventDefinition> col);
    private void CloneTo(PropertyDefinition prop, TypeDefinition nt, Collection`1<PropertyDefinition> col);
    private void CloneTo(MethodDefinition meth, TypeDefinition type, bool typeJustCreated);
    private void CloneTo(MethodBody body, MethodDefinition parent);
    private TypeDefinition CreateType(TypeDefinition type, Collection`1<TypeDefinition> col, bool internalize, string rename);
    private MethodDefinition FindMethodInNewType(TypeDefinition nt, MethodDefinition methodDefinition);
    private void FixAspNetOffset(Collection`1<Instruction> instructions, MethodReference operand, MethodDefinition parent);
    private static bool IsIndexer(PropertyDefinition prop);
    private static IList`1<ParameterDefinition> ExtractIndexerParameters(PropertyDefinition prop);
    private static Instruction GetInstruction(MethodBody oldBody, MethodBody newBody, Instruction i);
    private bool DuplicateTypeAllowed(TypeDefinition type);
    public sealed virtual void CopySecurityDeclarations(Collection`1<SecurityDeclaration> input, Collection`1<SecurityDeclaration> output, IGenericParameterProvider context);
    private static void Copy(Collection`1<T> input, Collection`1<T> output, Action`2<T, T> action);
    public sealed virtual void CopyGenericParameters(Collection`1<GenericParameter> input, Collection`1<GenericParameter> output, IGenericParameterProvider nt);
    public sealed virtual void CopyCustomAttributes(Collection`1<CustomAttribute> input, Collection`1<CustomAttribute> output, IGenericParameterProvider context);
    public sealed virtual CustomAttribute Copy(CustomAttribute ca, IGenericParameterProvider context);
    public sealed virtual void CopyCustomAttributes(Collection`1<CustomAttribute> input, Collection`1<CustomAttribute> output, bool allowMultiple, IGenericParameterProvider context);
    private bool CustomAttributeTypeAllowsMultiple(TypeReference type);
    public sealed virtual void CopyTypeReferences(Collection`1<TypeReference> input, Collection`1<TypeReference> output, IGenericParameterProvider context);
    public sealed virtual CustomAttributeArgument Copy(CustomAttributeArgument arg, IGenericParameterProvider context);
    public sealed virtual CustomAttributeNamedArgument Copy(CustomAttributeNamedArgument namedArg, IGenericParameterProvider context);
    private object ImportCustomAttributeValue(object obj, IGenericParameterProvider context);
    [CompilerGeneratedAttribute]
private bool <ShouldDrop>b__13_0(CustomAttribute attr);
}
internal class ILRepacking.RepackLogger : object {
    private string _outputFile;
    private StreamWriter _writer;
    [CompilerGeneratedAttribute]
private bool <ShouldLogVerbose>k__BackingField;
    public bool ShouldLogVerbose { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ShouldLogVerbose();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ShouldLogVerbose(bool value);
    public sealed virtual void Log(object str);
    public bool Open(string file);
    public void Close();
    public sealed virtual void Error(string msg);
    public sealed virtual void Warn(string msg);
    public sealed virtual void Info(string msg);
    public sealed virtual void Verbose(string msg);
    public sealed virtual void DuplicateIgnored(string ignoredType, object ignoredObject);
}
public class ILRepacking.RepackOptions : object {
    [CompilerGeneratedAttribute]
private bool <AllowDuplicateResources>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowMultipleAssemblyLevelAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowWildCards>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowZeroPeKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AttributeFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Closed>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CopyAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DebugInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DelaySign>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FileAlignment>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <InputAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Internalize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Parallel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PauseBeforeExit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Log>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LogFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFile>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PublicKeyTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StrongNameLost>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Kind> <TargetKind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetPlatformVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <SearchDirectories>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnionMerge>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <XmlDocumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogVerbose>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoRepackRes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepOtherVersionReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LineIndexation>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepackDropAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenameInternalized>k__BackingField;
    private Hashtable allowedDuplicateTypes;
    private List`1<string> allowedDuplicateNameSpaces;
    private List`1<Regex> excludeInternalizeMatches;
    private ICommandLine cmd;
    private IFile file;
    private string excludeFile;
    public bool AllowDuplicateResources { get; public set; }
    public bool AllowMultipleAssemblyLevelAttributes { get; public set; }
    public bool AllowWildCards { get; public set; }
    public bool AllowZeroPeKind { get; public set; }
    public string AttributeFile { get; public set; }
    public bool Closed { get; public set; }
    public bool CopyAttributes { get; public set; }
    public bool DebugInfo { get; public set; }
    public bool DelaySign { get; public set; }
    public string ExcludeFile { get; public set; }
    public int FileAlignment { get; public set; }
    public String[] InputAssemblies { get; public set; }
    public bool Internalize { get; public set; }
    public string KeyFile { get; public set; }
    public string KeyContainer { get; public set; }
    public bool Parallel { get; public set; }
    public bool PauseBeforeExit { get; public set; }
    public bool Log { get; public set; }
    public string LogFile { get; public set; }
    public string OutputFile { get; public set; }
    public bool PublicKeyTokens { get; public set; }
    public bool StrongNameLost { get; public set; }
    public Nullable`1<Kind> TargetKind { get; public set; }
    public string TargetPlatformDirectory { get; public set; }
    public string TargetPlatformVersion { get; public set; }
    public IEnumerable`1<string> SearchDirectories { get; public set; }
    public bool UnionMerge { get; public set; }
    public Version Version { get; public set; }
    public bool XmlDocumentation { get; public set; }
    public bool LogVerbose { get; public set; }
    public bool NoRepackRes { get; public set; }
    public bool KeepOtherVersionReferences { get; public set; }
    public bool LineIndexation { get; public set; }
    public List`1<Regex> ExcludeInternalizeMatches { get; }
    public Hashtable AllowedDuplicateTypes { get; }
    public List`1<string> AllowedDuplicateNameSpaces { get; }
    public string RepackDropAttribute { get; public set; }
    public bool RenameInternalized { get; public set; }
    internal bool ShouldShowUsage { get; }
    public RepackOptions(IEnumerable`1<string> ilRepackArguments);
    public RepackOptions(CommandLine commandLine);
    internal RepackOptions(ICommandLine commandLine, IFile file);
    [CompilerGeneratedAttribute]
public bool get_AllowDuplicateResources();
    [CompilerGeneratedAttribute]
public void set_AllowDuplicateResources(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowMultipleAssemblyLevelAttributes();
    [CompilerGeneratedAttribute]
public void set_AllowMultipleAssemblyLevelAttributes(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowWildCards();
    [CompilerGeneratedAttribute]
public void set_AllowWildCards(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowZeroPeKind();
    [CompilerGeneratedAttribute]
public void set_AllowZeroPeKind(bool value);
    [CompilerGeneratedAttribute]
public string get_AttributeFile();
    [CompilerGeneratedAttribute]
public void set_AttributeFile(string value);
    [CompilerGeneratedAttribute]
public bool get_Closed();
    [CompilerGeneratedAttribute]
public void set_Closed(bool value);
    [CompilerGeneratedAttribute]
public bool get_CopyAttributes();
    [CompilerGeneratedAttribute]
public void set_CopyAttributes(bool value);
    [CompilerGeneratedAttribute]
public bool get_DebugInfo();
    [CompilerGeneratedAttribute]
public void set_DebugInfo(bool value);
    [CompilerGeneratedAttribute]
public bool get_DelaySign();
    [CompilerGeneratedAttribute]
public void set_DelaySign(bool value);
    public string get_ExcludeFile();
    public void set_ExcludeFile(string value);
    [CompilerGeneratedAttribute]
public int get_FileAlignment();
    [CompilerGeneratedAttribute]
public void set_FileAlignment(int value);
    [CompilerGeneratedAttribute]
public String[] get_InputAssemblies();
    [CompilerGeneratedAttribute]
public void set_InputAssemblies(String[] value);
    [CompilerGeneratedAttribute]
public bool get_Internalize();
    [CompilerGeneratedAttribute]
public void set_Internalize(bool value);
    [CompilerGeneratedAttribute]
public string get_KeyFile();
    [CompilerGeneratedAttribute]
public void set_KeyFile(string value);
    [CompilerGeneratedAttribute]
public string get_KeyContainer();
    [CompilerGeneratedAttribute]
public void set_KeyContainer(string value);
    [CompilerGeneratedAttribute]
public bool get_Parallel();
    [CompilerGeneratedAttribute]
public void set_Parallel(bool value);
    [CompilerGeneratedAttribute]
public bool get_PauseBeforeExit();
    [CompilerGeneratedAttribute]
public void set_PauseBeforeExit(bool value);
    [CompilerGeneratedAttribute]
public bool get_Log();
    [CompilerGeneratedAttribute]
public void set_Log(bool value);
    [CompilerGeneratedAttribute]
public string get_LogFile();
    [CompilerGeneratedAttribute]
public void set_LogFile(string value);
    [CompilerGeneratedAttribute]
public string get_OutputFile();
    [CompilerGeneratedAttribute]
public void set_OutputFile(string value);
    [CompilerGeneratedAttribute]
public bool get_PublicKeyTokens();
    [CompilerGeneratedAttribute]
public void set_PublicKeyTokens(bool value);
    [CompilerGeneratedAttribute]
public bool get_StrongNameLost();
    [CompilerGeneratedAttribute]
public void set_StrongNameLost(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<Kind> get_TargetKind();
    [CompilerGeneratedAttribute]
public void set_TargetKind(Nullable`1<Kind> value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformDirectory();
    [CompilerGeneratedAttribute]
public void set_TargetPlatformDirectory(string value);
    [CompilerGeneratedAttribute]
public string get_TargetPlatformVersion();
    [CompilerGeneratedAttribute]
public void set_TargetPlatformVersion(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_SearchDirectories();
    [CompilerGeneratedAttribute]
public void set_SearchDirectories(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_UnionMerge();
    [CompilerGeneratedAttribute]
public void set_UnionMerge(bool value);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(Version value);
    [CompilerGeneratedAttribute]
public bool get_XmlDocumentation();
    [CompilerGeneratedAttribute]
public void set_XmlDocumentation(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogVerbose();
    [CompilerGeneratedAttribute]
public void set_LogVerbose(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoRepackRes();
    [CompilerGeneratedAttribute]
public void set_NoRepackRes(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeepOtherVersionReferences();
    [CompilerGeneratedAttribute]
public void set_KeepOtherVersionReferences(bool value);
    [CompilerGeneratedAttribute]
public bool get_LineIndexation();
    [CompilerGeneratedAttribute]
public void set_LineIndexation(bool value);
    public List`1<Regex> get_ExcludeInternalizeMatches();
    public Hashtable get_AllowedDuplicateTypes();
    public List`1<string> get_AllowedDuplicateNameSpaces();
    [CompilerGeneratedAttribute]
public string get_RepackDropAttribute();
    [CompilerGeneratedAttribute]
public void set_RepackDropAttribute(string value);
    [CompilerGeneratedAttribute]
public bool get_RenameInternalized();
    [CompilerGeneratedAttribute]
public void set_RenameInternalized(bool value);
    private void AllowDuplicateType(string typeName);
    internal bool get_ShouldShowUsage();
    private void Parse();
    internal void Validate();
    public IList`1<string> ResolveFiles();
    private IEnumerable`1<string> ResolveFile(string s);
    public string ToCommandLine();
}
internal class ILRepacking.Res : object {
    public string name;
    public string type;
    public Byte[] data;
    internal int typeCode;
    internal int dataPos;
    public bool IsBamlStream { get; }
    public bool IsString { get; }
    public Res(string name, string type, Byte[] data, int typeCode, int dataPos);
    public bool get_IsBamlStream();
    public bool get_IsString();
}
internal enum ILRepacking.ResourceTypeCode : Enum {
    public int value__;
    public static ResourceTypeCode Null;
    public static ResourceTypeCode String;
    public static ResourceTypeCode Boolean;
    public static ResourceTypeCode Char;
    public static ResourceTypeCode Byte;
    public static ResourceTypeCode SByte;
    public static ResourceTypeCode Int16;
    public static ResourceTypeCode UInt16;
    public static ResourceTypeCode Int32;
    public static ResourceTypeCode UInt32;
    public static ResourceTypeCode Int64;
    public static ResourceTypeCode UInt64;
    public static ResourceTypeCode Single;
    public static ResourceTypeCode Double;
    public static ResourceTypeCode Decimal;
    public static ResourceTypeCode DateTime;
    public static ResourceTypeCode LastPrimitive;
    public static ResourceTypeCode TimeSpan;
    public static ResourceTypeCode ByteArray;
    public static ResourceTypeCode Stream;
    public static ResourceTypeCode StartOfUserTypes;
}
internal class ILRepacking.ResReader : object {
    private BinaryReader _store;
    private long _nameSectionOffset;
    private long _dataSectionOffset;
    private int _numResources;
    private BinaryFormatter _bf;
    private int _version;
    private Int32[] _nameHashes;
    private Int32[] _namePositions;
    private Int32[] _typeNamePositions;
    public ResReader(Stream stream);
    public void Close();
    private sealed virtual override void System.IDisposable.Dispose();
    private void Dispose(bool disposing);
    private void SkipInt32();
    private void SkipString();
    private int GetNamePosition(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<Res> GetEnumerator();
    public object GetObject(Res res);
    private object GetObject_V2(Res res);
    private object GetObject_V1(Res res);
    internal IEnumerator`1<Res> GetResources();
    internal int Read7BitEncodedInt();
    private string TypeNameFromTypeIndex(int typeIndex);
    private string TypeNameFromTypeCode(int typeCode);
}
internal interface ILRepacking.SerialObject {
    public int ObjectID { get; public set; }
    public Nullable`1<long> ParentObjectID { get; public set; }
    public abstract virtual int get_ObjectID();
    public abstract virtual void set_ObjectID(int value);
    public abstract virtual Nullable`1<long> get_ParentObjectID();
    public abstract virtual void set_ParentObjectID(Nullable`1<long> value);
}
internal class ILRepacking.SerReader : object {
    private IRepackContext _repackContext;
    internal Dictionary`2<int, SerialObject> SerialObjectsFound;
    internal Dictionary`2<int, BinaryLibrary> LibrariesFound;
    internal BinaryReader reader;
    private BinaryWriter writer;
    private bool endRecordReached;
    private int PendingNullCounter;
    private long pos;
    private long start;
    private long end;
    public SerReader(IRepackContext repackContext, Stream inputStream, Stream outputStream);
    public void TransferMarked();
    public string ReadMarkString();
    public void FixTypeName(string assemblyName, string typeName);
    public string ReadAssemblyName();
    public string ReadAndFixString();
    public void Stream();
    internal Nullable`1<int> ParseRecord(SerialObject parentObject);
}
internal class ILRepacking.Steps.AttributesRepackStep : object {
    private ILogger _logger;
    private IRepackContext _repackContext;
    private IRepackCopier _repackCopier;
    private RepackOptions _options;
    public AttributesRepackStep(ILogger logger, IRepackContext repackContext, IRepackCopier repackCopier, RepackOptions options);
    public sealed virtual void Perform();
    private void CleanupAttributes();
    private void RemoveAttributes();
    private void CleanupAttributes(string type, Func`2<CustomAttribute, bool> extra);
    private bool RemoveAttributes(Func`2<CustomAttribute, bool> predicate);
    private bool RemoveAttributes(string attrTypeName, Func`2<CustomAttribute, bool> predicate);
    [CompilerGeneratedAttribute]
private bool <RemoveAttributes>b__7_0(CustomAttribute ca);
    [CompilerGeneratedAttribute]
private bool <RemoveAttributes>b__7_1(CustomAttribute ca);
}
internal interface ILRepacking.Steps.IRepackStep {
    public abstract virtual void Perform();
}
internal class ILRepacking.Steps.ReferencesFixStep : object {
    private ILogger _logger;
    private IRepackContext _repackContext;
    private IRepackImporter _repackImporter;
    private RepackOptions _options;
    public ReferencesFixStep(ILogger logger, IRepackContext repackContext, IRepackImporter repackImporter, RepackOptions options);
    public sealed virtual void Perform();
}
internal class ILRepacking.Steps.ReferencesRepackStep : object {
    private ILogger _logger;
    private IRepackContext _repackContext;
    public ReferencesRepackStep(ILogger logger, IRepackContext repackContext);
    public sealed virtual void Perform();
}
internal class ILRepacking.Steps.ResourceProcessing.BamlGenerator : object {
    private static int ResourceDictionaryTypeId;
    private static string ComponentString;
    private static BamlVersion BamlVersion;
    private ILogger _logger;
    private Collection`1<AssemblyNameReference> _targetAssemblyReferences;
    private string _mainAssemblyName;
    public BamlGenerator(ILogger logger, Collection`1<AssemblyNameReference> targetAssemblyReferences, AssemblyDefinition mainAssembly);
    private static BamlGenerator();
    public BamlDocument GenerateThemesGenericXaml(IEnumerable`1<string> importedFiles);
    public void AddMergedDictionaries(BamlDocument document, IEnumerable`1<string> importedFiles);
    private void AddAssemblyInfos(BamlDocument document);
    private static void AdjustAttributeIds(BamlDocument document, ushort offset);
    private static IEnumerable`1<BamlRecord> GetMergedDictionariesAttributes();
    private void HandleMergedDictionary(BamlDocument document, IEnumerable`1<string> importedFiles, AttributeInfoRecord mergedDictionariesRecord);
    private static string GetFileNameFromPropertyRecord(PropertyWithConverterRecord record);
    private static bool IsMergedDictionaryAttribute(BamlRecord record);
    private static bool IsResourceDictionaryElementStart(BamlRecord record);
    private string GetPackUri(string file);
    private List`1<BamlRecord> GetDictionariesList(IEnumerable`1<string> importedFiles);
    private List`1<BamlRecord> GetImportRecords(IEnumerable`1<string> importedFiles);
}
internal class ILRepacking.Steps.ResourceProcessing.BamlResourcePatcher : object {
    private AssemblyDefinition _mainAssembly;
    private IList`1<AssemblyDefinition> _otherAssemblies;
    public BamlResourcePatcher(IRepackContext repackContext);
    public sealed virtual bool Process(Res resource, AssemblyDefinition containingAssembly, EmbeddedResource embeddedResource, ResReader resourceReader, ResourceWriter resourceWriter);
    private Byte[] GetProcessedResource(Res resource, AssemblyDefinition containingAssembly);
    private void ProcessRecord(PropertyWithConverterRecord record, AssemblyDefinition containingAssembly);
    private void ProcessRecord(TextWithConverterRecord record, AssemblyDefinition containingAssembly);
    private void ProcessRecord(AssemblyInfoRecord record, AssemblyDefinition containingAssembly);
    private void ProcessRecord(XmlnsPropertyRecord record, AssemblyDefinition containingAssembly);
    private void ProcessRecord(TypeInfoRecord record, AssemblyDefinition containingAssembly);
    private void ProcessRecord(BamlRecord record, AssemblyDefinition containingAssembly);
    public string RemoveTypeAssemblyInformation(string fullTypeName);
}
internal class ILRepacking.Steps.ResourceProcessing.BamlStreamCollector : object {
    private static string GenericThemesBamlName;
    private ILogger _logger;
    private AssemblyDefinition _primaryAssemblyDefinition;
    private BamlGenerator _bamlGenerator;
    private IDictionary`2<Res, AssemblyDefinition> _bamlStreams;
    public bool HasBamlStreams { get; }
    public BamlStreamCollector(ILogger logger, IRepackContext repackContext);
    public bool get_HasBamlStreams();
    public sealed virtual bool Process(Res resource, AssemblyDefinition containingAssembly, EmbeddedResource embeddedResource, ResReader resourceReader, ResourceWriter resourceWriter);
    public sealed virtual void Process(EmbeddedResource embeddedResource, ResourceWriter resourceWriter);
    private void WriteCollectedBamlStreams(ResourceWriter resourceWriter);
    private void PatchGenericThemesBaml(ResourceWriter resourceWriter);
    private void PatchExistingGenericThemesXaml(ResourceWriter resourceWriter, BamlDocument bamlDocument, IEnumerable`1<string> genericThemeResources);
    private void AddNewGenericThemesXaml(ResourceWriter resourceWriter, IEnumerable`1<string> genericThemeResources);
    private string GetResourceName(Res resource, AssemblyDefinition assembly);
    private static bool TryGetPreserializedData(ResourceWriter resourceWriter, string resourceName, Byte[]& preserializedData);
    private static void SetPreserializedData(ResourceWriter resourceWriter, string resourceName, Byte[] data);
    [CompilerGeneratedAttribute]
private string <PatchGenericThemesBaml>b__11_1(KeyValuePair`2<Res, AssemblyDefinition> e);
}
internal class ILRepacking.Steps.ResourceProcessing.BamlUtils : object {
    public static Byte[] ToResourceBytes(BamlDocument document);
    public static BamlDocument FromResourceBytes(Byte[] rawResourceData);
}
internal class ILRepacking.Steps.ResourceProcessing.GenericResourceProcessor : object {
    private IRepackContext _repackContext;
    public GenericResourceProcessor(IRepackContext repackContext);
    public sealed virtual bool Process(Res resource, AssemblyDefinition containingAssembly, EmbeddedResource embeddedResource, ResReader resourceReader, ResourceWriter resourceWriter);
}
internal interface ILRepacking.Steps.ResourceProcessing.IEmbeddedResourceProcessor {
    public abstract virtual void Process(EmbeddedResource embeddedResource, ResourceWriter resourceWriter);
}
internal interface ILRepacking.Steps.ResourceProcessing.IResProcessor {
    public abstract virtual bool Process(Res resource, AssemblyDefinition containingAssembly, EmbeddedResource embeddedResource, ResReader resourceReader, ResourceWriter resourceWriter);
}
internal class ILRepacking.Steps.ResourceProcessing.StringResourceProcessor : object {
    private IRepackContext _repackContext;
    public StringResourceProcessor(IRepackContext repackContext);
    public sealed virtual bool Process(Res resource, AssemblyDefinition containingAssembly, EmbeddedResource embeddedResource, ResReader resourceReader, ResourceWriter resourceWriter);
}
internal class ILRepacking.Steps.ResourcesRepackStep : object {
    internal static string ILRepackListResourceName;
    private ILogger _logger;
    private IRepackContext _repackContext;
    private RepackOptions _options;
    private ModuleDefinition _targetAssemblyMainModule;
    public ResourcesRepackStep(ILogger logger, IRepackContext repackContext, RepackOptions options);
    public sealed virtual void Perform();
    private void CreateNewBamlResourceIfNeeded(bool areCollectedStreamsWritten, BamlStreamCollector bamlStreamCollector);
    private static Dictionary`2<string, List`1<int>> MergeIkvmExports(Dictionary`2<string, List`1<int>> currentExports, Dictionary`2<string, List`1<int>> extraExports);
    private static Dictionary`2<string, List`1<int>> GetIkvmExportsListsFromResource(EmbeddedResource extra);
    private static EmbeddedResource GenerateIkvmExports(Dictionary`2<string, List`1<int>> lists);
    private Resource FixResxResource(AssemblyDefinition containingAssembly, EmbeddedResource er, List`1<IResProcessor> resourcePrcessors, IEmbeddedResourceProcessor embeddedResourceProcessor);
    private static String[] GetRepackListFromResource(EmbeddedResource resource);
    private static EmbeddedResource GenerateRepackListResource(List`1<string> repackList);
}
internal class ILRepacking.Steps.SigningStep : object {
    private IRepackContext _repackContext;
    private RepackOptions _repackOptions;
    [CompilerGeneratedAttribute]
private StrongNameKeyPair <KeyPair>k__BackingField;
    public StrongNameKeyPair KeyPair { get; private set; }
    public SigningStep(IRepackContext repackContext, RepackOptions repackOptions);
    [CompilerGeneratedAttribute]
public StrongNameKeyPair get_KeyPair();
    [CompilerGeneratedAttribute]
private void set_KeyPair(StrongNameKeyPair value);
    public sealed virtual void Perform();
}
internal class ILRepacking.Steps.SourceServerData.HttpSourceServerDescriptor : object {
    private static string InitSection;
    private static string VariablesSection;
    private static string SourceFilesSection;
    private static string EndSection;
    private static string VersionKey;
    private static string VersionControlKey;
    private static string TargetKey;
    private static Regex VariablesRegex;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VersionControl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceFileDescriptor[] <SourceFiles>k__BackingField;
    public int Version { get; }
    public string VersionControl { get; }
    public string Target { get; }
    public SourceFileDescriptor[] SourceFiles { get; }
    public HttpSourceServerDescriptor(int version, string versionControl, string target, SourceFileDescriptor[] sourceFiles);
    private static HttpSourceServerDescriptor();
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public string get_VersionControl();
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public SourceFileDescriptor[] get_SourceFiles();
    public static bool TryParse(string rawSrcSrv, HttpSourceServerDescriptor& descriptor);
    public virtual string ToString();
    private IEnumerable`1<string> GetRawLines();
    public HttpSourceServerDescriptor MergeWith(IEnumerable`1<HttpSourceServerDescriptor> others);
    private static string VarName(int n);
    [CompilerGeneratedAttribute]
private bool <MergeWith>b__24_0(HttpSourceServerDescriptor descriptor);
}
internal interface ILRepacking.Steps.SourceServerData.ISourceServerDataRepackStep {
    public abstract virtual void Write();
}
internal class ILRepacking.Steps.SourceServerData.NullSourceServerStep : object {
    private ILogger _logger;
    public NullSourceServerStep(ILogger logger);
    public sealed virtual void Perform();
    public sealed virtual void Write();
    public sealed virtual void Dispose();
}
internal class ILRepacking.Steps.SourceServerData.PdbStr : object {
    private string _pdbStrPath;
    public string Read(string pdb);
    public void Write(string pdb, string srcsrv);
    private string Execute(string arguments);
    public sealed virtual void Dispose();
    private void SafeDeleteFile(string filePath);
    protected virtual override void Finalize();
}
internal class ILRepacking.Steps.SourceServerData.SourceFileDescriptor : object {
    private static Regex Regex;
    [CompilerGeneratedAttribute]
private String[] <Variables>k__BackingField;
    public String[] Variables { get; }
    public SourceFileDescriptor(string path, string variable2);
    public SourceFileDescriptor(IEnumerable`1<string> variables);
    private static SourceFileDescriptor();
    [CompilerGeneratedAttribute]
public String[] get_Variables();
    public static SourceFileDescriptor Parse(string raw);
    public virtual string ToString();
}
internal class ILRepacking.Steps.SourceServerData.SourceServerDataRepackStep : object {
    private string _targetPdbFile;
    private IEnumerable`1<string> _assemblyFiles;
    private string _srcSrv;
    private PdbStr _pdbStr;
    public SourceServerDataRepackStep(string targetFile, IEnumerable`1<string> assemblyFiles);
    public sealed virtual void Perform();
    public sealed virtual void Write();
    public sealed virtual void Dispose();
    private static string PdbPath(string assemblyFile);
}
[ExtensionAttribute]
internal static class ILRepacking.Steps.SourceServerData.StringMixins : object {
    [ExtensionAttribute]
public static IEnumerable`1<string> GetLines(string s);
}
internal class ILRepacking.Steps.TypesRepackStep : object {
    private ILogger _logger;
    private IRepackContext _repackContext;
    private IRepackImporter _repackImporter;
    private RepackOptions _repackOptions;
    private List`1<TypeDefinition> _allTypes;
    public TypesRepackStep(ILogger logger, IRepackContext repackContext, IRepackImporter repackImporter, RepackOptions repackOptions);
    public sealed virtual void Perform();
    private void RepackTypes();
    private bool SkipExportedType(ExportedType type);
    private void RepackExportedTypes();
    private bool ShouldInternalize(string typeFullName);
    private TypeReference CreateReference(ExportedType type);
}
internal class ILRepacking.Steps.XamlResourcePathPatcherStep : object {
    private ILogger _logger;
    private IRepackContext _repackContext;
    private static Regex VersionRegex;
    public XamlResourcePathPatcherStep(ILogger logger, IRepackContext repackContext);
    private static XamlResourcePathPatcherStep();
    public sealed virtual void Perform();
    private void PatchWpfToolkitVersionResourceDictionary(TypeDefinition type);
    private void PatchIComponentConnector(TypeDefinition type);
    private void PatchWpfToolkitEndInitMethod(MethodDefinition method);
    private void PatchMethod(MethodDefinition method);
    internal static string PatchPath(string path, AssemblyDefinition primaryAssembly, AssemblyDefinition sourceAssembly, IList`1<AssemblyDefinition> otherAssemblies);
    private static bool TryPatchPath(string path, AssemblyDefinition primaryAssembly, AssemblyDefinition referenceAssembly, String& patchedPath);
    private static string GetAssemblyPath(AssemblyDefinition sourceAssembly);
}
internal static class ILRepacking.TypeHelper : object {
    internal static void GetTypeAdditionalInfo(TypeHoldingThing typeHolder, SerReader analyzer);
    internal static void GetTypeValue(TypeHoldingThing typeHolder, ValueHoldingThing valueHolder, SerReader analyzer);
}
internal interface ILRepacking.TypeHoldingThing {
    public SerialObject RelevantObject { get; public set; }
    public Nullable`1<BinaryTypeEnumeration> BinaryType { get; public set; }
    public Nullable`1<PrimitiveTypeEnumeration> PrimitiveType { get; public set; }
    public ClassTypeInfo TypeInfo { get; public set; }
    public abstract virtual SerialObject get_RelevantObject();
    public abstract virtual void set_RelevantObject(SerialObject value);
    public abstract virtual Nullable`1<BinaryTypeEnumeration> get_BinaryType();
    public abstract virtual void set_BinaryType(Nullable`1<BinaryTypeEnumeration> value);
    public abstract virtual Nullable`1<PrimitiveTypeEnumeration> get_PrimitiveType();
    public abstract virtual void set_PrimitiveType(Nullable`1<PrimitiveTypeEnumeration> value);
    public abstract virtual ClassTypeInfo get_TypeInfo();
    public abstract virtual void set_TypeInfo(ClassTypeInfo value);
}
internal interface ILRepacking.ValueHoldingThing {
    public object Value { get; public set; }
    public object ValueRefID { get; public set; }
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
    public abstract virtual object get_ValueRefID();
    public abstract virtual void set_ValueRefID(object value);
}
internal class Locale : object {
    public static string GetText(string msg);
    public static string GetText(string fmt, Object[] args);
}
[AttributeUsageAttribute("4380")]
internal class MapAttribute : Attribute {
    private string nativeType;
    private string suppressFlags;
    public string NativeType { get; }
    public string SuppressFlags { get; public set; }
    public MapAttribute(string nativeType);
    public string get_NativeType();
    public string get_SuppressFlags();
    public void set_SuppressFlags(string value);
}
internal interface Microsoft.Cci.ILocalScope {
    public UInt32 Offset { get; }
    public UInt32 Length { get; }
    public abstract virtual UInt32 get_Offset();
    public abstract virtual UInt32 get_Length();
}
internal interface Microsoft.Cci.IName {
    public int UniqueKey { get; }
    public int UniqueKeyIgnoringCase { get; }
    public string Value { get; }
    public abstract virtual int get_UniqueKey();
    public abstract virtual int get_UniqueKeyIgnoringCase();
    public abstract virtual string get_Value();
}
internal interface Microsoft.Cci.INamespaceScope {
    public IEnumerable`1<IUsedNamespace> UsedNamespaces { get; }
    public abstract virtual IEnumerable`1<IUsedNamespace> get_UsedNamespaces();
}
internal interface Microsoft.Cci.IUsedNamespace {
    public IName Alias { get; }
    public IName NamespaceName { get; }
    public abstract virtual IName get_Alias();
    public abstract virtual IName get_NamespaceName();
}
internal class Microsoft.Cci.Pdb.AlignSym : ValueType {
}
internal class Microsoft.Cci.Pdb.AnnotationSym : ValueType {
    internal UInt32 off;
    internal ushort seg;
    internal ushort csz;
    internal String[] rgsz;
}
internal class Microsoft.Cci.Pdb.AttrManyRegSym : ValueType {
    internal UInt32 typind;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal byte count;
    internal Byte[] reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.AttrManyRegSym2 : ValueType {
    internal UInt32 typind;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal ushort count;
    internal UInt16[] reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.AttrRegRel : ValueType {
    internal UInt32 off;
    internal UInt32 typind;
    internal ushort reg;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal string name;
}
internal class Microsoft.Cci.Pdb.AttrRegSym : ValueType {
    internal UInt32 typind;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal ushort reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.AttrSlotSym : ValueType {
    internal UInt32 index;
    internal UInt32 typind;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal string name;
}
internal class Microsoft.Cci.Pdb.BitAccess : object {
    private Byte[] buffer;
    private int offset;
    internal Byte[] Buffer { get; }
    internal int Position { get; internal set; }
    internal BitAccess(int capacity);
    internal Byte[] get_Buffer();
    internal void FillBuffer(Stream stream, int capacity);
    internal void Append(Stream stream, int count);
    internal int get_Position();
    internal void set_Position(int value);
    internal void MinCapacity(int capacity);
    internal void Align(int alignment);
    internal void ReadInt16(Int16& value);
    internal void ReadInt8(SByte& value);
    internal void ReadInt32(Int32& value);
    internal void ReadInt64(Int64& value);
    internal void ReadUInt16(UInt16& value);
    internal void ReadUInt8(Byte& value);
    internal void ReadUInt32(UInt32& value);
    internal void ReadUInt64(UInt64& value);
    internal void ReadInt32(Int32[] values);
    internal void ReadUInt32(UInt32[] values);
    internal void ReadBytes(Byte[] bytes);
    internal float ReadFloat();
    internal double ReadDouble();
    internal decimal ReadDecimal();
    internal void ReadBString(String& value);
    internal string ReadBString(int len);
    internal void ReadCString(String& value);
    internal void SkipCString(String& value);
    internal void ReadGuid(Guid& guid);
    internal string ReadString();
}
internal class Microsoft.Cci.Pdb.BitSet : ValueType {
    private int size;
    private UInt32[] words;
    internal bool IsEmpty { get; }
    internal BitSet(BitAccess bits);
    internal bool IsSet(int index);
    private static UInt32 GetBit(int index);
    internal bool get_IsEmpty();
}
internal class Microsoft.Cci.Pdb.BlockSym32 : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 len;
    internal UInt32 off;
    internal ushort seg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.BpRelSym32 : ValueType {
    internal int off;
    internal UInt32 typind;
    internal string name;
}
internal class Microsoft.Cci.Pdb.CallsiteInfo : ValueType {
    internal int off;
    internal ushort ect;
    internal ushort pad0;
    internal UInt32 typind;
}
internal class Microsoft.Cci.Pdb.CFlagSym : ValueType {
    internal byte machine;
    internal byte language;
    internal ushort flags;
    internal string ver;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CFLAGSYM_FLAGS : Enum {
    public ushort value__;
    public static CFLAGSYM_FLAGS pcode;
    public static CFLAGSYM_FLAGS floatprec;
    public static CFLAGSYM_FLAGS floatpkg;
    public static CFLAGSYM_FLAGS ambdata;
    public static CFLAGSYM_FLAGS ambcode;
    public static CFLAGSYM_FLAGS mode32;
}
internal class Microsoft.Cci.Pdb.CoffGroupSym : ValueType {
    internal UInt32 cb;
    internal UInt32 characteristics;
    internal UInt32 off;
    internal ushort seg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.CompileSym : ValueType {
    internal UInt32 flags;
    internal ushort machine;
    internal ushort verFEMajor;
    internal ushort verFEMinor;
    internal ushort verFEBuild;
    internal ushort verMajor;
    internal ushort verMinor;
    internal ushort verBuild;
    internal string verSt;
    internal String[] verArgs;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.COMPILESYM_FLAGS : Enum {
    public UInt32 value__;
    public static COMPILESYM_FLAGS iLanguage;
    public static COMPILESYM_FLAGS fEC;
    public static COMPILESYM_FLAGS fNoDbgInfo;
    public static COMPILESYM_FLAGS fLTCG;
    public static COMPILESYM_FLAGS fNoDataAlign;
    public static COMPILESYM_FLAGS fManagedPresent;
    public static COMPILESYM_FLAGS fSecurityChecks;
    public static COMPILESYM_FLAGS fHotPatch;
    public static COMPILESYM_FLAGS fCVTCIL;
    public static COMPILESYM_FLAGS fMSILModule;
}
internal class Microsoft.Cci.Pdb.ConstSym : ValueType {
    internal UInt32 typind;
    internal ushort value;
    internal string name;
}
internal enum Microsoft.Cci.Pdb.CV_CFL_CODE : Enum {
    public int value__;
    public static CV_CFL_CODE CV_CFL_CNEAR;
    public static CV_CFL_CODE CV_CFL_CFAR;
    public static CV_CFL_CODE CV_CFL_CHUGE;
}
internal enum Microsoft.Cci.Pdb.CV_CFL_DATA : Enum {
    public int value__;
    public static CV_CFL_DATA CV_CFL_DNEAR;
    public static CV_CFL_DATA CV_CFL_DFAR;
    public static CV_CFL_DATA CV_CFL_DHUGE;
}
internal enum Microsoft.Cci.Pdb.CV_CFL_FPKG : Enum {
    public int value__;
    public static CV_CFL_FPKG CV_CFL_NDP;
    public static CV_CFL_FPKG CV_CFL_EMU;
    public static CV_CFL_FPKG CV_CFL_ALT;
}
internal class Microsoft.Cci.Pdb.CV_Column : ValueType {
    internal ushort offColumnStart;
    internal ushort offColumnEnd;
}
internal enum Microsoft.Cci.Pdb.CV_cookietype : Enum {
    public int value__;
    public static CV_cookietype CV_COOKIETYPE_COPY;
    public static CV_cookietype CV_COOKIETYPE_XOR_SP;
    public static CV_cookietype CV_COOKIETYPE_XOR_BP;
    public static CV_cookietype CV_COOKIETYPE_XOR_R13;
}
internal enum Microsoft.Cci.Pdb.CV_DISCARDED : Enum {
    public UInt32 value__;
    public static CV_DISCARDED CV_DISCARDED_UNKNOWN;
    public static CV_DISCARDED CV_DISCARDED_NOT_SELECTED;
    public static CV_DISCARDED CV_DISCARDED_NOT_REFERENCED;
}
internal class Microsoft.Cci.Pdb.CV_EXPROCFLAGS : ValueType {
    internal byte flags;
    internal byte reserved;
}
internal enum Microsoft.Cci.Pdb.CV_FILE_CHECKSUM_TYPE : Enum {
    public byte value__;
    public static CV_FILE_CHECKSUM_TYPE None;
    public static CV_FILE_CHECKSUM_TYPE MD5;
}
internal class Microsoft.Cci.Pdb.CV_FileCheckSum : ValueType {
    internal UInt32 name;
    internal byte len;
    internal byte type;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_fldattr : Enum {
    public int value__;
    public static CV_fldattr access;
    public static CV_fldattr mprop;
    public static CV_fldattr pseudo;
    public static CV_fldattr noinherit;
    public static CV_fldattr noconstruct;
    public static CV_fldattr compgenx;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_GENERIC_FLAG : Enum {
    public ushort value__;
    public static CV_GENERIC_FLAG cstyle;
    public static CV_GENERIC_FLAG rsclean;
}
internal enum Microsoft.Cci.Pdb.CV_GENERIC_STYLE : Enum {
    public int value__;
    public static CV_GENERIC_STYLE CV_GENERIC_VOID;
    public static CV_GENERIC_STYLE CV_GENERIC_REG;
    public static CV_GENERIC_STYLE CV_GENERIC_ICAN;
    public static CV_GENERIC_STYLE CV_GENERIC_ICAF;
    public static CV_GENERIC_STYLE CV_GENERIC_IRAN;
    public static CV_GENERIC_STYLE CV_GENERIC_IRAF;
    public static CV_GENERIC_STYLE CV_GENERIC_UNUSED;
}
internal enum Microsoft.Cci.Pdb.CV_int : Enum {
    public int value__;
    public static CV_int CV_RI_CHAR;
    public static CV_int CV_RI_INT1;
    public static CV_int CV_RI_WCHAR;
    public static CV_int CV_RI_UINT1;
    public static CV_int CV_RI_INT2;
    public static CV_int CV_RI_UINT2;
    public static CV_int CV_RI_INT4;
    public static CV_int CV_RI_UINT4;
    public static CV_int CV_RI_INT8;
    public static CV_int CV_RI_UINT8;
    public static CV_int CV_RI_INT16;
    public static CV_int CV_RI_UINT16;
}
internal enum Microsoft.Cci.Pdb.CV_integral : Enum {
    public int value__;
    public static CV_integral CV_IN_1BYTE;
    public static CV_integral CV_IN_2BYTE;
    public static CV_integral CV_IN_4BYTE;
    public static CV_integral CV_IN_8BYTE;
    public static CV_integral CV_IN_16BYTE;
}
internal enum Microsoft.Cci.Pdb.CV_LABEL_TYPE : Enum {
    public int value__;
    public static CV_LABEL_TYPE CV_LABEL_NEAR;
    public static CV_LABEL_TYPE CV_LABEL_FAR;
}
internal class Microsoft.Cci.Pdb.CV_Line : ValueType {
    internal UInt32 offset;
    internal UInt32 flags;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_Line_Flags : Enum {
    public UInt32 value__;
    public static CV_Line_Flags linenumStart;
    public static CV_Line_Flags deltaLineEnd;
    public static CV_Line_Flags fStatement;
}
internal enum Microsoft.Cci.Pdb.CV_LINE_SUBSECTION_FLAGS : Enum {
    public ushort value__;
    public static CV_LINE_SUBSECTION_FLAGS CV_LINES_HAVE_COLUMNS;
}
internal class Microsoft.Cci.Pdb.CV_LineSection : ValueType {
    internal UInt32 off;
    internal ushort sec;
    internal ushort flags;
    internal UInt32 cod;
}
internal class Microsoft.Cci.Pdb.CV_lvar_addr_range : ValueType {
    internal UInt32 offStart;
    internal ushort isectStart;
    internal UInt32 cbRange;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_LVARFLAGS : Enum {
    public ushort value__;
    public static CV_LVARFLAGS fIsParam;
    public static CV_LVARFLAGS fAddrTaken;
    public static CV_LVARFLAGS fCompGenx;
    public static CV_LVARFLAGS fIsAggregate;
    public static CV_LVARFLAGS fIsAggregated;
    public static CV_LVARFLAGS fIsAliased;
    public static CV_LVARFLAGS fIsAlias;
}
internal enum Microsoft.Cci.Pdb.CV_methodprop : Enum {
    public int value__;
    public static CV_methodprop CV_MTvanilla;
    public static CV_methodprop CV_MTvirtual;
    public static CV_methodprop CV_MTstatic;
    public static CV_methodprop CV_MTfriend;
    public static CV_methodprop CV_MTintro;
    public static CV_methodprop CV_MTpurevirt;
    public static CV_methodprop CV_MTpureintro;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_modifier : Enum {
    public ushort value__;
    public static CV_modifier MOD_const;
    public static CV_modifier MOD_volatile;
    public static CV_modifier MOD_unaligned;
}
internal class Microsoft.Cci.Pdb.CV_PDMR32_NVVFCN : ValueType {
    internal int mdisp;
}
internal class Microsoft.Cci.Pdb.CV_PDMR32_VBASE : ValueType {
    internal int mdisp;
    internal int pdisp;
    internal int vdisp;
}
internal class Microsoft.Cci.Pdb.CV_PMFR32_NVMA : ValueType {
    internal UInt32 off;
    internal int disp;
}
internal class Microsoft.Cci.Pdb.CV_PMFR32_NVSA : ValueType {
    internal UInt32 off;
}
internal class Microsoft.Cci.Pdb.CV_PMFR32_VBASE : ValueType {
    internal UInt32 off;
    internal int mdisp;
    internal int pdisp;
    internal int vdisp;
}
internal enum Microsoft.Cci.Pdb.CV_pmtype : Enum {
    public int value__;
    public static CV_pmtype CV_PMTYPE_Undef;
    public static CV_pmtype CV_PMTYPE_D_Single;
    public static CV_pmtype CV_PMTYPE_D_Multiple;
    public static CV_pmtype CV_PMTYPE_D_Virtual;
    public static CV_pmtype CV_PMTYPE_D_General;
    public static CV_pmtype CV_PMTYPE_F_Single;
    public static CV_pmtype CV_PMTYPE_F_Multiple;
    public static CV_pmtype CV_PMTYPE_F_Virtual;
    public static CV_pmtype CV_PMTYPE_F_General;
}
internal class Microsoft.Cci.Pdb.CV_PRIMITIVE_TYPE : ValueType {
    private static UInt32 CV_MMASK;
    private static UInt32 CV_TMASK;
    private static UInt32 CV_SMASK;
    private static int CV_MSHIFT;
    private static int CV_TSHIFT;
    private static int CV_SSHIFT;
    private static UInt32 CV_FIRST_NONPRIM;
}
internal enum Microsoft.Cci.Pdb.CV_prmode : Enum {
    public int value__;
    public static CV_prmode CV_TM_DIRECT;
    public static CV_prmode CV_TM_NPTR32;
    public static CV_prmode CV_TM_NPTR64;
    public static CV_prmode CV_TM_NPTR128;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_PROCFLAGS : Enum {
    public byte value__;
    public static CV_PROCFLAGS CV_PFLAG_NOFPO;
    public static CV_PROCFLAGS CV_PFLAG_INT;
    public static CV_PROCFLAGS CV_PFLAG_FAR;
    public static CV_PROCFLAGS CV_PFLAG_NEVER;
    public static CV_PROCFLAGS CV_PFLAG_NOTREACHED;
    public static CV_PROCFLAGS CV_PFLAG_CUST_CALL;
    public static CV_PROCFLAGS CV_PFLAG_NOINLINE;
    public static CV_PROCFLAGS CV_PFLAG_OPTDBGINFO;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_prop : Enum {
    public ushort value__;
    public static CV_prop packed;
    public static CV_prop ctor;
    public static CV_prop ovlops;
    public static CV_prop isnested;
    public static CV_prop cnested;
    public static CV_prop opassign;
    public static CV_prop opcast;
    public static CV_prop fwdref;
    public static CV_prop scoped;
}
internal enum Microsoft.Cci.Pdb.CV_ptrmode : Enum {
    public int value__;
    public static CV_ptrmode CV_PTR_MODE_PTR;
    public static CV_ptrmode CV_PTR_MODE_REF;
    public static CV_ptrmode CV_PTR_MODE_PMEM;
    public static CV_ptrmode CV_PTR_MODE_PMFUNC;
    public static CV_ptrmode CV_PTR_MODE_RESERVED;
}
internal enum Microsoft.Cci.Pdb.CV_ptrtype : Enum {
    public int value__;
    public static CV_ptrtype CV_PTR_BASE_SEG;
    public static CV_ptrtype CV_PTR_BASE_VAL;
    public static CV_ptrtype CV_PTR_BASE_SEGVAL;
    public static CV_ptrtype CV_PTR_BASE_ADDR;
    public static CV_ptrtype CV_PTR_BASE_SEGADDR;
    public static CV_ptrtype CV_PTR_BASE_TYPE;
    public static CV_ptrtype CV_PTR_BASE_SELF;
    public static CV_ptrtype CV_PTR_NEAR32;
    public static CV_ptrtype CV_PTR_64;
    public static CV_ptrtype CV_PTR_UNUSEDPTR;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_PUBSYMFLAGS : Enum {
    public UInt32 value__;
    public static CV_PUBSYMFLAGS fNone;
    public static CV_PUBSYMFLAGS fCode;
    public static CV_PUBSYMFLAGS fFunction;
    public static CV_PUBSYMFLAGS fManaged;
    public static CV_PUBSYMFLAGS fMSIL;
}
internal enum Microsoft.Cci.Pdb.CV_real : Enum {
    public int value__;
    public static CV_real CV_RC_REAL32;
    public static CV_real CV_RC_REAL64;
    public static CV_real CV_RC_REAL80;
    public static CV_real CV_RC_REAL128;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.CV_SEPCODEFLAGS : Enum {
    public UInt32 value__;
    public static CV_SEPCODEFLAGS fIsLexicalScope;
    public static CV_SEPCODEFLAGS fReturnsToParent;
}
internal enum Microsoft.Cci.Pdb.CV_SIGNATURE : Enum {
    public int value__;
    public static CV_SIGNATURE C6;
    public static CV_SIGNATURE C7;
    public static CV_SIGNATURE C11;
    public static CV_SIGNATURE C13;
    public static CV_SIGNATURE RESERVERD;
}
internal class Microsoft.Cci.Pdb.CV_SourceFile : ValueType {
    internal UInt32 index;
    internal UInt32 count;
    internal UInt32 linsiz;
}
internal enum Microsoft.Cci.Pdb.CV_special : Enum {
    public int value__;
    public static CV_special CV_SP_NOTYPE;
    public static CV_special CV_SP_ABS;
    public static CV_special CV_SP_SEGMENT;
    public static CV_special CV_SP_VOID;
    public static CV_special CV_SP_CURRENCY;
    public static CV_special CV_SP_NBASICSTR;
    public static CV_special CV_SP_FBASICSTR;
    public static CV_special CV_SP_NOTTRANS;
    public static CV_special CV_SP_HRESULT;
}
internal enum Microsoft.Cci.Pdb.CV_special2 : Enum {
    public int value__;
    public static CV_special2 CV_S2_BIT;
    public static CV_special2 CV_S2_PASCHAR;
}
internal enum Microsoft.Cci.Pdb.CV_type : Enum {
    public int value__;
    public static CV_type CV_SPECIAL;
    public static CV_type CV_SIGNED;
    public static CV_type CV_UNSIGNED;
    public static CV_type CV_BOOLEAN;
    public static CV_type CV_REAL;
    public static CV_type CV_COMPLEX;
    public static CV_type CV_SPECIAL2;
    public static CV_type CV_INT;
    public static CV_type CV_CVRESERVED;
}
internal enum Microsoft.Cci.Pdb.CV_VTS_desc : Enum {
    public int value__;
    public static CV_VTS_desc CV_VTS_near;
    public static CV_VTS_desc CV_VTS_far;
    public static CV_VTS_desc CV_VTS_thin;
    public static CV_VTS_desc CV_VTS_outer;
    public static CV_VTS_desc CV_VTS_meta;
    public static CV_VTS_desc CV_VTS_near32;
    public static CV_VTS_desc CV_VTS_far32;
    public static CV_VTS_desc CV_VTS_unused;
}
internal class Microsoft.Cci.Pdb.DatasSym32 : ValueType {
    internal UInt32 typind;
    internal UInt32 off;
    internal ushort seg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.DataStream : object {
    internal int contentSize;
    internal Int32[] pages;
    internal int Length { get; }
    internal DataStream(int contentSize, BitAccess bits, int count);
    internal void Read(PdbReader reader, BitAccess bits);
    internal void Read(PdbReader reader, int position, Byte[] bytes, int offset, int data);
    internal int get_Length();
}
internal class Microsoft.Cci.Pdb.DbiDbgHdr : ValueType {
    internal ushort snFPO;
    internal ushort snException;
    internal ushort snFixup;
    internal ushort snOmapToSrc;
    internal ushort snOmapFromSrc;
    internal ushort snSectionHdr;
    internal ushort snTokenRidMap;
    internal ushort snXdata;
    internal ushort snPdata;
    internal ushort snNewFPO;
    internal ushort snSectionHdrOrig;
    internal DbiDbgHdr(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.DbiHeader : ValueType {
    internal int sig;
    internal int ver;
    internal int age;
    internal short gssymStream;
    internal ushort vers;
    internal short pssymStream;
    internal ushort pdbver;
    internal short symrecStream;
    internal ushort pdbver2;
    internal int gpmodiSize;
    internal int secconSize;
    internal int secmapSize;
    internal int filinfSize;
    internal int tsmapSize;
    internal int mfcIndex;
    internal int dbghdrSize;
    internal int ecinfoSize;
    internal ushort flags;
    internal ushort machine;
    internal int reserved;
    internal DbiHeader(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.DbiModuleInfo : object {
    internal int opened;
    internal ushort flags;
    internal short stream;
    internal int cbSyms;
    internal int cbOldLines;
    internal int cbLines;
    internal short files;
    internal short pad1;
    internal UInt32 offsets;
    internal int niSource;
    internal int niCompiler;
    internal string moduleName;
    internal string objectName;
    internal DbiModuleInfo(BitAccess bits, bool readStrings);
}
internal class Microsoft.Cci.Pdb.DbiSecCon : ValueType {
    internal short section;
    internal short pad1;
    internal int offset;
    internal int size;
    internal UInt32 flags;
    internal short module;
    internal short pad2;
    internal UInt32 dataCrc;
    internal UInt32 relocCrc;
    internal DbiSecCon(BitAccess bits);
}
internal enum Microsoft.Cci.Pdb.DEBUG_S_SUBSECTION : Enum {
    public int value__;
    public static DEBUG_S_SUBSECTION SYMBOLS;
    public static DEBUG_S_SUBSECTION LINES;
    public static DEBUG_S_SUBSECTION STRINGTABLE;
    public static DEBUG_S_SUBSECTION FILECHKSMS;
    public static DEBUG_S_SUBSECTION FRAMEDATA;
}
internal enum Microsoft.Cci.Pdb.DEBUG_S_SUBSECTION_TYPE : Enum {
    public UInt32 value__;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_IGNORE;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_SYMBOLS;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_LINES;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_STRINGTABLE;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_FILECHKSMS;
    public static DEBUG_S_SUBSECTION_TYPE DEBUG_S_FRAMEDATA;
}
internal class Microsoft.Cci.Pdb.DefRangeSym : ValueType {
    internal UInt32 id;
    internal UInt32 program;
    internal CV_lvar_addr_range range;
}
internal class Microsoft.Cci.Pdb.DefRangeSym2 : ValueType {
    internal UInt32 id;
    internal UInt32 program;
    internal ushort count;
    internal CV_lvar_addr_range[] range;
}
internal class Microsoft.Cci.Pdb.DiscardedSym : ValueType {
    internal CV_DISCARDED iscarded;
    internal UInt32 fileid;
    internal UInt32 linenum;
    internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.EndArgSym : ValueType {
}
internal class Microsoft.Cci.Pdb.EntryThisSym : ValueType {
    internal byte thissym;
}
internal class Microsoft.Cci.Pdb.ExportSym : ValueType {
    internal ushort ordinal;
    internal ushort flags;
    internal string name;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.EXPORTSYM_FLAGS : Enum {
    public ushort value__;
    public static EXPORTSYM_FLAGS fConstant;
    public static EXPORTSYM_FLAGS fData;
    public static EXPORTSYM_FLAGS fPrivate;
    public static EXPORTSYM_FLAGS fNoName;
    public static EXPORTSYM_FLAGS fOrdinal;
    public static EXPORTSYM_FLAGS fForwarder;
}
internal class Microsoft.Cci.Pdb.FLOAT10 : ValueType {
    internal byte Data_0;
    internal byte Data_1;
    internal byte Data_2;
    internal byte Data_3;
    internal byte Data_4;
    internal byte Data_5;
    internal byte Data_6;
    internal byte Data_7;
    internal byte Data_8;
    internal byte Data_9;
}
internal class Microsoft.Cci.Pdb.FrameCookie : ValueType {
    internal int off;
    internal ushort reg;
    internal int cookietype;
    internal byte flags;
}
internal class Microsoft.Cci.Pdb.FrameData : ValueType {
    internal UInt32 ulRvaStart;
    internal UInt32 cbBlock;
    internal UInt32 cbLocals;
    internal UInt32 cbParams;
    internal UInt32 cbStkMax;
    internal UInt32 frameFunc;
    internal ushort cbProlog;
    internal ushort cbSavedRegs;
    internal UInt32 flags;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.FRAMEDATA_FLAGS : Enum {
    public UInt32 value__;
    public static FRAMEDATA_FLAGS fHasSEH;
    public static FRAMEDATA_FLAGS fHasEH;
    public static FRAMEDATA_FLAGS fIsFunctionStart;
}
internal class Microsoft.Cci.Pdb.FrameProcSym : ValueType {
    internal UInt32 cbFrame;
    internal UInt32 cbPad;
    internal UInt32 offPad;
    internal UInt32 cbSaveRegs;
    internal UInt32 offExHdlr;
    internal ushort secExHdlr;
    internal UInt32 flags;
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.FRAMEPROCSYM_FLAGS : Enum {
    public UInt32 value__;
    public static FRAMEPROCSYM_FLAGS fHasAlloca;
    public static FRAMEPROCSYM_FLAGS fHasSetJmp;
    public static FRAMEPROCSYM_FLAGS fHasLongJmp;
    public static FRAMEPROCSYM_FLAGS fHasInlAsm;
    public static FRAMEPROCSYM_FLAGS fHasEH;
    public static FRAMEPROCSYM_FLAGS fInlSpec;
    public static FRAMEPROCSYM_FLAGS fHasSEH;
    public static FRAMEPROCSYM_FLAGS fNaked;
    public static FRAMEPROCSYM_FLAGS fSecurityChecks;
    public static FRAMEPROCSYM_FLAGS fAsyncEH;
    public static FRAMEPROCSYM_FLAGS fGSNoStackOrdering;
    public static FRAMEPROCSYM_FLAGS fWasInlined;
}
internal class Microsoft.Cci.Pdb.FrameRelSym : ValueType {
    internal int off;
    internal UInt32 typind;
    internal UInt32 offCod;
    internal ushort segCod;
    internal ushort flags;
    internal string name;
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.Cci.Pdb.IntHashTable : object {
    private static Int32[] primes;
    private bucket[] buckets;
    private int count;
    private int occupancy;
    private int loadsize;
    private int loadFactorPerc;
    private int version;
    internal object Item { get; }
    internal IntHashTable(int capacity, int loadFactorPerc);
    private static IntHashTable();
    private static int GetPrime(int minSize);
    private static UInt32 InitHash(int key, int hashsize, UInt32& seed, UInt32& incr);
    internal void Add(int key, object value);
    internal object get_Item(int key);
    private void expand();
    private void rehash();
    private void rehash(int newsize);
    private void Insert(int key, object nvalue, bool add);
    private void putEntry(bucket[] newBuckets, int key, object nvalue, int hashcode);
}
internal class Microsoft.Cci.Pdb.LabelSym32 : ValueType {
    internal UInt32 off;
    internal ushort seg;
    internal byte flags;
    internal string name;
}
internal enum Microsoft.Cci.Pdb.LEAF : Enum {
    public int value__;
    public static LEAF LF_VTSHAPE;
    public static LEAF LF_COBOL1;
    public static LEAF LF_LABEL;
    public static LEAF LF_NULL;
    public static LEAF LF_NOTTRAN;
    public static LEAF LF_ENDPRECOMP;
    public static LEAF LF_TYPESERVER_ST;
    public static LEAF LF_LIST;
    public static LEAF LF_REFSYM;
    public static LEAF LF_ENUMERATE_ST;
    public static LEAF LF_TI16_MAX;
    public static LEAF LF_MODIFIER;
    public static LEAF LF_POINTER;
    public static LEAF LF_ARRAY_ST;
    public static LEAF LF_CLASS_ST;
    public static LEAF LF_STRUCTURE_ST;
    public static LEAF LF_UNION_ST;
    public static LEAF LF_ENUM_ST;
    public static LEAF LF_PROCEDURE;
    public static LEAF LF_MFUNCTION;
    public static LEAF LF_COBOL0;
    public static LEAF LF_BARRAY;
    public static LEAF LF_DIMARRAY_ST;
    public static LEAF LF_VFTPATH;
    public static LEAF LF_PRECOMP_ST;
    public static LEAF LF_OEM;
    public static LEAF LF_ALIAS_ST;
    public static LEAF LF_OEM2;
    public static LEAF LF_SKIP;
    public static LEAF LF_ARGLIST;
    public static LEAF LF_DEFARG_ST;
    public static LEAF LF_FIELDLIST;
    public static LEAF LF_DERIVED;
    public static LEAF LF_BITFIELD;
    public static LEAF LF_METHODLIST;
    public static LEAF LF_DIMCONU;
    public static LEAF LF_DIMCONLU;
    public static LEAF LF_DIMVARU;
    public static LEAF LF_DIMVARLU;
    public static LEAF LF_BCLASS;
    public static LEAF LF_VBCLASS;
    public static LEAF LF_IVBCLASS;
    public static LEAF LF_FRIENDFCN_ST;
    public static LEAF LF_INDEX;
    public static LEAF LF_MEMBER_ST;
    public static LEAF LF_STMEMBER_ST;
    public static LEAF LF_METHOD_ST;
    public static LEAF LF_NESTTYPE_ST;
    public static LEAF LF_VFUNCTAB;
    public static LEAF LF_FRIENDCLS;
    public static LEAF LF_ONEMETHOD_ST;
    public static LEAF LF_VFUNCOFF;
    public static LEAF LF_NESTTYPEEX_ST;
    public static LEAF LF_MEMBERMODIFY_ST;
    public static LEAF LF_MANAGED_ST;
    public static LEAF LF_ST_MAX;
    public static LEAF LF_TYPESERVER;
    public static LEAF LF_ENUMERATE;
    public static LEAF LF_ARRAY;
    public static LEAF LF_CLASS;
    public static LEAF LF_STRUCTURE;
    public static LEAF LF_UNION;
    public static LEAF LF_ENUM;
    public static LEAF LF_DIMARRAY;
    public static LEAF LF_PRECOMP;
    public static LEAF LF_ALIAS;
    public static LEAF LF_DEFARG;
    public static LEAF LF_FRIENDFCN;
    public static LEAF LF_MEMBER;
    public static LEAF LF_STMEMBER;
    public static LEAF LF_METHOD;
    public static LEAF LF_NESTTYPE;
    public static LEAF LF_ONEMETHOD;
    public static LEAF LF_NESTTYPEEX;
    public static LEAF LF_MEMBERMODIFY;
    public static LEAF LF_MANAGED;
    public static LEAF LF_TYPESERVER2;
    public static LEAF LF_NUMERIC;
    public static LEAF LF_CHAR;
    public static LEAF LF_SHORT;
    public static LEAF LF_USHORT;
    public static LEAF LF_LONG;
    public static LEAF LF_ULONG;
    public static LEAF LF_REAL32;
    public static LEAF LF_REAL64;
    public static LEAF LF_REAL80;
    public static LEAF LF_REAL128;
    public static LEAF LF_QUADWORD;
    public static LEAF LF_UQUADWORD;
    public static LEAF LF_COMPLEX32;
    public static LEAF LF_COMPLEX64;
    public static LEAF LF_COMPLEX80;
    public static LEAF LF_COMPLEX128;
    public static LEAF LF_VARSTRING;
    public static LEAF LF_OCTWORD;
    public static LEAF LF_UOCTWORD;
    public static LEAF LF_DECIMAL;
    public static LEAF LF_DATE;
    public static LEAF LF_UTF8STRING;
    public static LEAF LF_PAD0;
    public static LEAF LF_PAD1;
    public static LEAF LF_PAD2;
    public static LEAF LF_PAD3;
    public static LEAF LF_PAD4;
    public static LEAF LF_PAD5;
    public static LEAF LF_PAD6;
    public static LEAF LF_PAD7;
    public static LEAF LF_PAD8;
    public static LEAF LF_PAD9;
    public static LEAF LF_PAD10;
    public static LEAF LF_PAD11;
    public static LEAF LF_PAD12;
    public static LEAF LF_PAD13;
    public static LEAF LF_PAD14;
    public static LEAF LF_PAD15;
}
internal class Microsoft.Cci.Pdb.LeafAlias : ValueType {
    internal UInt32 utype;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafArgList : ValueType {
    internal UInt32 count;
    internal UInt32[] arg;
}
internal class Microsoft.Cci.Pdb.LeafArray : ValueType {
    internal UInt32 elemtype;
    internal UInt32 idxtype;
    internal Byte[] data;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafBArray : ValueType {
    internal UInt32 utype;
}
internal class Microsoft.Cci.Pdb.LeafBClass : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal Byte[] offset;
}
internal class Microsoft.Cci.Pdb.LeafBitfield : ValueType {
    internal UInt32 type;
    internal byte length;
    internal byte position;
}
internal class Microsoft.Cci.Pdb.LeafChar : ValueType {
    internal sbyte val;
}
internal class Microsoft.Cci.Pdb.LeafClass : ValueType {
    internal ushort count;
    internal ushort property;
    internal UInt32 field;
    internal UInt32 derived;
    internal UInt32 vshape;
    internal Byte[] data;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafCmplx128 : ValueType {
    internal ulong val0_real;
    internal ulong val1_real;
    internal ulong val0_imag;
    internal ulong val1_imag;
}
internal class Microsoft.Cci.Pdb.LeafCmplx32 : ValueType {
    internal float val_real;
    internal float val_imag;
}
internal class Microsoft.Cci.Pdb.LeafCmplx64 : ValueType {
    internal double val_real;
    internal double val_imag;
}
internal class Microsoft.Cci.Pdb.LeafCmplx80 : ValueType {
    internal FLOAT10 val_real;
    internal FLOAT10 val_imag;
}
internal class Microsoft.Cci.Pdb.LeafCobol0 : ValueType {
    internal UInt32 type;
    internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.LeafCobol1 : ValueType {
    internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.LeafDefArg : ValueType {
    internal UInt32 type;
    internal Byte[] expr;
}
internal class Microsoft.Cci.Pdb.LeafDerived : ValueType {
    internal UInt32 count;
    internal UInt32[] drvdcls;
}
internal class Microsoft.Cci.Pdb.LeafDimArray : ValueType {
    internal UInt32 utype;
    internal UInt32 diminfo;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafDimCon : ValueType {
    internal UInt32 typ;
    internal ushort rank;
    internal Byte[] dim;
}
internal class Microsoft.Cci.Pdb.LeafDimVar : ValueType {
    internal UInt32 rank;
    internal UInt32 typ;
    internal UInt32[] dim;
}
internal class Microsoft.Cci.Pdb.LeafEndPreComp : ValueType {
    internal UInt32 signature;
}
internal class Microsoft.Cci.Pdb.LeafEnum : ValueType {
    internal ushort count;
    internal ushort property;
    internal UInt32 utype;
    internal UInt32 field;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafEnumerate : ValueType {
    internal ushort attr;
    internal Byte[] value;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafFieldList : ValueType {
    internal Char[] data;
}
internal class Microsoft.Cci.Pdb.LeafFriendCls : ValueType {
    internal ushort pad0;
    internal UInt32 index;
}
internal class Microsoft.Cci.Pdb.LeafFriendFcn : ValueType {
    internal ushort pad0;
    internal UInt32 index;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafIndex : ValueType {
    internal ushort pad0;
    internal UInt32 index;
}
internal class Microsoft.Cci.Pdb.LeafLabel : ValueType {
    internal ushort mode;
}
internal class Microsoft.Cci.Pdb.LeafList : ValueType {
    internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.LeafLong : ValueType {
    internal int val;
}
internal class Microsoft.Cci.Pdb.LeafManaged : ValueType {
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafMember : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal Byte[] offset;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafMemberModify : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafMethod : ValueType {
    internal ushort count;
    internal UInt32 mList;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafMethodList : ValueType {
    internal Byte[] mList;
}
internal class Microsoft.Cci.Pdb.LeafMFunc : ValueType {
    internal UInt32 rvtype;
    internal UInt32 classtype;
    internal UInt32 thistype;
    internal byte calltype;
    internal byte reserved;
    internal ushort parmcount;
    internal UInt32 arglist;
    internal int thisadjust;
}
internal class Microsoft.Cci.Pdb.LeafModifier : ValueType {
    internal UInt32 type;
    internal CV_modifier attr;
}
internal class Microsoft.Cci.Pdb.LeafNestType : ValueType {
    internal ushort pad0;
    internal UInt32 index;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafNestTypeEx : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafOct : ValueType {
    internal ulong val0;
    internal ulong val1;
}
internal class Microsoft.Cci.Pdb.LeafOEM : ValueType {
    internal ushort cvOEM;
    internal ushort recOEM;
    internal UInt32 count;
    internal UInt32[] index;
}
internal class Microsoft.Cci.Pdb.LeafOEM2 : ValueType {
    internal Guid idOem;
    internal UInt32 count;
    internal UInt32[] index;
}
internal class Microsoft.Cci.Pdb.LeafOneMethod : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal UInt32[] vbaseoff;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafPad : ValueType {
    internal byte leaf;
}
internal class Microsoft.Cci.Pdb.LeafPointer : ValueType {
}
[FlagsAttribute]
internal enum Microsoft.Cci.Pdb.LeafPointerAttr : Enum {
    public UInt32 value__;
    public static LeafPointerAttr ptrtype;
    public static LeafPointerAttr ptrmode;
    public static LeafPointerAttr isflat32;
    public static LeafPointerAttr isvolatile;
    public static LeafPointerAttr isconst;
    public static LeafPointerAttr isunaligned;
    public static LeafPointerAttr isrestrict;
}
internal class Microsoft.Cci.Pdb.LeafPreComp : ValueType {
    internal UInt32 start;
    internal UInt32 count;
    internal UInt32 signature;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafProc : ValueType {
    internal UInt32 rvtype;
    internal byte calltype;
    internal byte reserved;
    internal ushort parmcount;
    internal UInt32 arglist;
}
internal class Microsoft.Cci.Pdb.LeafQuad : ValueType {
    internal long val;
}
internal class Microsoft.Cci.Pdb.LeafReal128 : ValueType {
    internal ulong val0;
    internal ulong val1;
}
internal class Microsoft.Cci.Pdb.LeafReal32 : ValueType {
    internal float val;
}
internal class Microsoft.Cci.Pdb.LeafReal64 : ValueType {
    internal double val;
}
internal class Microsoft.Cci.Pdb.LeafReal80 : ValueType {
    internal FLOAT10 val;
}
internal class Microsoft.Cci.Pdb.LeafRefSym : ValueType {
    internal Byte[] Sym;
}
internal class Microsoft.Cci.Pdb.LeafShort : ValueType {
    internal short val;
}
internal class Microsoft.Cci.Pdb.LeafSkip : ValueType {
    internal UInt32 type;
    internal Byte[] data;
}
internal class Microsoft.Cci.Pdb.LeafSTMember : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafTypeServer : ValueType {
    internal UInt32 signature;
    internal UInt32 age;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafTypeServer2 : ValueType {
    internal Guid sig70;
    internal UInt32 age;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafULong : ValueType {
    internal UInt32 val;
}
internal class Microsoft.Cci.Pdb.LeafUnion : ValueType {
    internal ushort count;
    internal ushort property;
    internal UInt32 field;
    internal Byte[] data;
    internal string name;
}
internal class Microsoft.Cci.Pdb.LeafUOct : ValueType {
    internal ulong val0;
    internal ulong val1;
}
internal class Microsoft.Cci.Pdb.LeafUQuad : ValueType {
    internal ulong val;
}
internal class Microsoft.Cci.Pdb.LeafUShort : ValueType {
    internal ushort val;
}
internal class Microsoft.Cci.Pdb.LeafVarString : ValueType {
    internal ushort len;
    internal Byte[] value;
}
internal class Microsoft.Cci.Pdb.LeafVBClass : ValueType {
    internal ushort attr;
    internal UInt32 index;
    internal UInt32 vbptr;
    internal Byte[] vbpoff;
}
internal class Microsoft.Cci.Pdb.LeafVFTPath : ValueType {
    internal UInt32 count;
    internal UInt32[] bases;
}
internal class Microsoft.Cci.Pdb.LeafVFuncOff : ValueType {
    internal ushort pad0;
    internal UInt32 type;
    internal int offset;
}
internal class Microsoft.Cci.Pdb.LeafVFuncTab : ValueType {
    internal ushort pad0;
    internal UInt32 type;
}
internal class Microsoft.Cci.Pdb.LeafVTShape : ValueType {
    internal ushort count;
    internal Byte[] desc;
}
internal class Microsoft.Cci.Pdb.LocalSym : ValueType {
    internal UInt32 id;
    internal UInt32 typind;
    internal ushort flags;
    internal UInt32 idParent;
    internal UInt32 offParent;
    internal UInt32 expr;
    internal UInt32 pad0;
    internal UInt32 pad1;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ManProcSym : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 len;
    internal UInt32 dbgStart;
    internal UInt32 dbgEnd;
    internal UInt32 token;
    internal UInt32 off;
    internal ushort seg;
    internal byte flags;
    internal ushort retReg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ManProcSymMips : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 len;
    internal UInt32 dbgStart;
    internal UInt32 dbgEnd;
    internal UInt32 regSave;
    internal UInt32 fpSave;
    internal UInt32 intOff;
    internal UInt32 fpOff;
    internal UInt32 token;
    internal UInt32 off;
    internal ushort seg;
    internal byte retReg;
    internal byte frameReg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ManyRegSym : ValueType {
    internal UInt32 typind;
    internal byte count;
    internal Byte[] reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ManyRegSym2 : ValueType {
    internal UInt32 typind;
    internal ushort count;
    internal UInt16[] reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ManyTypRef : ValueType {
    internal UInt32 typind;
}
internal class Microsoft.Cci.Pdb.mlMethod : ValueType {
    internal ushort attr;
    internal ushort pad0;
    internal UInt32 index;
    internal UInt32[] vbaseoff;
}
internal class Microsoft.Cci.Pdb.MsfDirectory : object {
    internal DataStream[] streams;
    internal MsfDirectory(PdbReader reader, PdbFileHeader head, BitAccess bits);
}
internal class Microsoft.Cci.Pdb.ObjNameSym : ValueType {
    internal UInt32 signature;
    internal string name;
}
internal enum Microsoft.Cci.Pdb.OEM_ID : Enum {
    public int value__;
    public static OEM_ID OEM_MS_FORTRAN90;
    public static OEM_ID OEM_ODI;
    public static OEM_ID OEM_THOMSON_SOFTWARE;
    public static OEM_ID OEM_ODI_REC_BASELIST;
}
internal class Microsoft.Cci.Pdb.OemSymbol : ValueType {
    internal Guid idOem;
    internal UInt32 typind;
    internal Byte[] rgl;
}
internal class Microsoft.Cci.Pdb.PdbConstant : object {
    internal string name;
    internal UInt32 token;
    internal object value;
    internal PdbConstant(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbDebugException : IOException {
    internal PdbDebugException(string format, Object[] args);
}
internal class Microsoft.Cci.Pdb.PdbException : IOException {
    internal PdbException(string format, Object[] args);
}
internal class Microsoft.Cci.Pdb.PdbFile : object {
    private static void LoadGuidStream(BitAccess bits, Guid& doctype, Guid& language, Guid& vendor);
    private static Dictionary`2<string, int> LoadNameIndex(BitAccess bits, Int32& age, Guid& guid);
    private static IntHashTable LoadNameStream(BitAccess bits);
    private static int FindFunction(PdbFunction[] funcs, ushort sec, UInt32 off);
    private static void LoadManagedLines(PdbFunction[] funcs, IntHashTable names, BitAccess bits, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, UInt32 limit);
    private static void LoadFuncsFromDbiModule(BitAccess bits, DbiModuleInfo info, IntHashTable names, ArrayList funcList, bool readStrings, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader);
    private static void LoadDbiStream(BitAccess bits, DbiModuleInfo[]& modules, DbiDbgHdr& header, bool readStrings);
    internal static PdbFunction[] LoadFunctions(Stream read, Dictionary`2& tokenToSourceMapping, String& sourceServerData, Int32& age, Guid& guid);
    private static void LoadTokenToSourceInfo(BitAccess bits, DbiModuleInfo module, IntHashTable names, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader, Dictionary`2<UInt32, PdbTokenLine> tokenToSourceMapping);
    private static IntHashTable ReadSourceFileInfo(BitAccess bits, UInt32 limit, IntHashTable names, MsfDirectory dir, Dictionary`2<string, int> nameIndex, PdbReader reader);
}
internal class Microsoft.Cci.Pdb.PdbFileHeader : object {
    internal Byte[] magic;
    internal int pageSize;
    internal int freePageMap;
    internal int pagesUsed;
    internal int directorySize;
    internal int zero;
    internal Int32[] directoryRoot;
    internal PdbFileHeader(Stream reader, BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbFunction : object {
    internal static Guid msilMetaData;
    internal static IComparer byAddress;
    internal static IComparer byAddressAndToken;
    internal UInt32 token;
    internal UInt32 slotToken;
    internal UInt32 tokenOfMethodWhoseUsingInfoAppliesToThisMethod;
    internal UInt32 segment;
    internal UInt32 address;
    internal PdbScope[] scopes;
    internal PdbSlot[] slots;
    internal PdbConstant[] constants;
    internal String[] usedNamespaces;
    internal PdbLines[] lines;
    internal UInt16[] usingCounts;
    internal IEnumerable`1<INamespaceScope> namespaceScopes;
    internal string iteratorClass;
    internal List`1<ILocalScope> iteratorScopes;
    internal PdbSynchronizationInformation synchronizationInformation;
    internal PdbFunction(ManProcSym proc, BitAccess bits);
    private static PdbFunction();
    private static string StripNamespace(string module);
    internal static PdbFunction[] LoadManagedFunctions(BitAccess bits, UInt32 limit, bool readStrings);
    internal static void CountScopesAndSlots(BitAccess bits, UInt32 limit, Int32& constants, Int32& scopes, Int32& slots, Int32& usedNamespaces);
    private void ReadCustomMetadata(BitAccess bits);
    private void ReadForwardIterator(BitAccess bits);
    private void ReadIteratorLocals(BitAccess bits);
    private void ReadForwardInfo(BitAccess bits);
    private void ReadUsingInfo(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbLine : ValueType {
    internal UInt32 offset;
    internal UInt32 lineBegin;
    internal UInt32 lineEnd;
    internal ushort colBegin;
    internal ushort colEnd;
    internal PdbLine(UInt32 offset, UInt32 lineBegin, ushort colBegin, UInt32 lineEnd, ushort colEnd);
}
internal class Microsoft.Cci.Pdb.PdbLines : object {
    internal PdbSource file;
    internal PdbLine[] lines;
    internal PdbLines(PdbSource file, UInt32 count);
}
internal class Microsoft.Cci.Pdb.PdbReader : object {
    internal int pageSize;
    internal Stream reader;
    internal PdbReader(Stream reader, int pageSize);
    internal void Seek(int page, int offset);
    internal void Read(Byte[] bytes, int offset, int count);
    internal int PagesFromSize(int size);
}
internal class Microsoft.Cci.Pdb.PdbScope : object {
    internal PdbConstant[] constants;
    internal PdbSlot[] slots;
    internal PdbScope[] scopes;
    internal String[] usedNamespaces;
    internal UInt32 address;
    internal UInt32 offset;
    internal UInt32 length;
    internal PdbScope(UInt32 address, UInt32 length, PdbSlot[] slots, PdbConstant[] constants, String[] usedNamespaces);
    internal PdbScope(UInt32 funcOffset, BlockSym32 block, BitAccess bits, UInt32& typind);
}
internal class Microsoft.Cci.Pdb.PdbSlot : object {
    internal UInt32 slot;
    internal UInt32 typeToken;
    internal string name;
    internal ushort flags;
    internal PdbSlot(BitAccess bits);
}
internal class Microsoft.Cci.Pdb.PdbSource : object {
    internal string name;
    internal Guid doctype;
    internal Guid language;
    internal Guid vendor;
    internal PdbSource(string name, Guid doctype, Guid language, Guid vendor);
}
internal class Microsoft.Cci.Pdb.PdbSynchronizationInformation : object {
    internal UInt32 kickoffMethodToken;
    internal UInt32 generatedCatchHandlerIlOffset;
    internal PdbSynchronizationPoint[] synchronizationPoints;
    public UInt32 GeneratedCatchHandlerOffset { get; }
    internal PdbSynchronizationInformation(BitAccess bits);
    public UInt32 get_GeneratedCatchHandlerOffset();
}
internal class Microsoft.Cci.Pdb.PdbSynchronizationPoint : object {
    internal UInt32 synchronizeOffset;
    internal UInt32 continuationMethodToken;
    internal UInt32 continuationOffset;
    public UInt32 SynchronizeOffset { get; }
    public UInt32 ContinuationOffset { get; }
    internal PdbSynchronizationPoint(BitAccess bits);
    public UInt32 get_SynchronizeOffset();
    public UInt32 get_ContinuationOffset();
}
internal class Microsoft.Cci.Pdb.PdbTokenLine : object {
    internal UInt32 token;
    internal UInt32 file_id;
    internal UInt32 line;
    internal UInt32 column;
    internal UInt32 endLine;
    internal UInt32 endColumn;
    internal PdbSource sourceFile;
    internal PdbTokenLine nextLine;
    internal PdbTokenLine(UInt32 token, UInt32 file_id, UInt32 line, UInt32 column, UInt32 endLine, UInt32 endColumn);
}
internal class Microsoft.Cci.Pdb.ProcSym32 : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 len;
    internal UInt32 dbgStart;
    internal UInt32 dbgEnd;
    internal UInt32 typind;
    internal UInt32 off;
    internal ushort seg;
    internal byte flags;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ProcSymIa64 : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 len;
    internal UInt32 dbgStart;
    internal UInt32 dbgEnd;
    internal UInt32 typind;
    internal UInt32 off;
    internal ushort seg;
    internal ushort retReg;
    internal byte flags;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ProcSymMips : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 len;
    internal UInt32 dbgStart;
    internal UInt32 dbgEnd;
    internal UInt32 regSave;
    internal UInt32 fpSave;
    internal UInt32 intOff;
    internal UInt32 fpOff;
    internal UInt32 typind;
    internal UInt32 off;
    internal ushort seg;
    internal byte retReg;
    internal byte frameReg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.PubSym32 : ValueType {
    internal UInt32 flags;
    internal UInt32 off;
    internal ushort seg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.RefSym : ValueType {
    internal UInt32 sumName;
    internal UInt32 ibSym;
    internal ushort imod;
    internal ushort usFill;
}
internal class Microsoft.Cci.Pdb.RefSym2 : ValueType {
    internal UInt32 sumName;
    internal UInt32 ibSym;
    internal ushort imod;
    internal string name;
}
internal class Microsoft.Cci.Pdb.RegRel32 : ValueType {
    internal UInt32 off;
    internal UInt32 typind;
    internal ushort reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.RegSym : ValueType {
    internal UInt32 typind;
    internal ushort reg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ReturnSym : ValueType {
    internal CV_GENERIC_FLAG flags;
    internal byte style;
}
internal class Microsoft.Cci.Pdb.SearchSym : ValueType {
    internal UInt32 startsym;
    internal ushort seg;
}
internal class Microsoft.Cci.Pdb.SectionSym : ValueType {
    internal ushort isec;
    internal byte align;
    internal byte bReserved;
    internal UInt32 rva;
    internal UInt32 cb;
    internal UInt32 characteristics;
    internal string name;
}
internal class Microsoft.Cci.Pdb.SepCodSym : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 length;
    internal UInt32 scf;
    internal UInt32 off;
    internal UInt32 offParent;
    internal ushort sec;
    internal ushort secParent;
}
internal class Microsoft.Cci.Pdb.Slink32 : ValueType {
    internal UInt32 framesize;
    internal int off;
    internal ushort reg;
}
internal class Microsoft.Cci.Pdb.SlotSym32 : ValueType {
    internal UInt32 index;
    internal UInt32 typind;
    internal string name;
}
internal enum Microsoft.Cci.Pdb.SYM : Enum {
    public int value__;
    public static SYM S_END;
    public static SYM S_OEM;
    public static SYM S_REGISTER_ST;
    public static SYM S_CONSTANT_ST;
    public static SYM S_UDT_ST;
    public static SYM S_COBOLUDT_ST;
    public static SYM S_MANYREG_ST;
    public static SYM S_BPREL32_ST;
    public static SYM S_LDATA32_ST;
    public static SYM S_GDATA32_ST;
    public static SYM S_PUB32_ST;
    public static SYM S_LPROC32_ST;
    public static SYM S_GPROC32_ST;
    public static SYM S_VFTABLE32;
    public static SYM S_REGREL32_ST;
    public static SYM S_LTHREAD32_ST;
    public static SYM S_GTHREAD32_ST;
    public static SYM S_LPROCMIPS_ST;
    public static SYM S_GPROCMIPS_ST;
    public static SYM S_FRAMEPROC;
    public static SYM S_COMPILE2_ST;
    public static SYM S_MANYREG2_ST;
    public static SYM S_LPROCIA64_ST;
    public static SYM S_GPROCIA64_ST;
    public static SYM S_LOCALSLOT_ST;
    public static SYM S_PARAMSLOT_ST;
    public static SYM S_ANNOTATION;
    public static SYM S_GMANPROC_ST;
    public static SYM S_LMANPROC_ST;
    public static SYM S_RESERVED1;
    public static SYM S_RESERVED2;
    public static SYM S_RESERVED3;
    public static SYM S_RESERVED4;
    public static SYM S_LMANDATA_ST;
    public static SYM S_GMANDATA_ST;
    public static SYM S_MANFRAMEREL_ST;
    public static SYM S_MANREGISTER_ST;
    public static SYM S_MANSLOT_ST;
    public static SYM S_MANMANYREG_ST;
    public static SYM S_MANREGREL_ST;
    public static SYM S_MANMANYREG2_ST;
    public static SYM S_MANTYPREF;
    public static SYM S_UNAMESPACE_ST;
    public static SYM S_ST_MAX;
    public static SYM S_OBJNAME;
    public static SYM S_THUNK32;
    public static SYM S_BLOCK32;
    public static SYM S_WITH32;
    public static SYM S_LABEL32;
    public static SYM S_REGISTER;
    public static SYM S_CONSTANT;
    public static SYM S_UDT;
    public static SYM S_COBOLUDT;
    public static SYM S_MANYREG;
    public static SYM S_BPREL32;
    public static SYM S_LDATA32;
    public static SYM S_GDATA32;
    public static SYM S_PUB32;
    public static SYM S_LPROC32;
    public static SYM S_GPROC32;
    public static SYM S_REGREL32;
    public static SYM S_LTHREAD32;
    public static SYM S_GTHREAD32;
    public static SYM S_LPROCMIPS;
    public static SYM S_GPROCMIPS;
    public static SYM S_COMPILE2;
    public static SYM S_MANYREG2;
    public static SYM S_LPROCIA64;
    public static SYM S_GPROCIA64;
    public static SYM S_LOCALSLOT;
    public static SYM S_SLOT;
    public static SYM S_PARAMSLOT;
    public static SYM S_LMANDATA;
    public static SYM S_GMANDATA;
    public static SYM S_MANFRAMEREL;
    public static SYM S_MANREGISTER;
    public static SYM S_MANSLOT;
    public static SYM S_MANMANYREG;
    public static SYM S_MANREGREL;
    public static SYM S_MANMANYREG2;
    public static SYM S_UNAMESPACE;
    public static SYM S_PROCREF;
    public static SYM S_DATAREF;
    public static SYM S_LPROCREF;
    public static SYM S_ANNOTATIONREF;
    public static SYM S_TOKENREF;
    public static SYM S_GMANPROC;
    public static SYM S_LMANPROC;
    public static SYM S_TRAMPOLINE;
    public static SYM S_MANCONSTANT;
    public static SYM S_ATTR_FRAMEREL;
    public static SYM S_ATTR_REGISTER;
    public static SYM S_ATTR_REGREL;
    public static SYM S_ATTR_MANYREG;
    public static SYM S_SEPCODE;
    public static SYM S_LOCAL;
    public static SYM S_DEFRANGE;
    public static SYM S_DEFRANGE2;
    public static SYM S_SECTION;
    public static SYM S_COFFGROUP;
    public static SYM S_EXPORT;
    public static SYM S_CALLSITEINFO;
    public static SYM S_FRAMECOOKIE;
    public static SYM S_DISCARDED;
    public static SYM S_RECTYPE_MAX;
    public static SYM S_RECTYPE_LAST;
}
internal class Microsoft.Cci.Pdb.SYMTYPE : ValueType {
    internal ushort reclen;
    internal ushort rectyp;
}
internal class Microsoft.Cci.Pdb.ThreadSym32 : ValueType {
    internal UInt32 typind;
    internal UInt32 off;
    internal ushort seg;
    internal string name;
}
internal class Microsoft.Cci.Pdb.ThunkSym32 : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 next;
    internal UInt32 off;
    internal ushort seg;
    internal ushort len;
    internal byte ord;
    internal string name;
    internal Byte[] variant;
}
internal enum Microsoft.Cci.Pdb.TRAMP : Enum {
    public int value__;
    public static TRAMP trampIncremental;
    public static TRAMP trampBranchIsland;
}
internal class Microsoft.Cci.Pdb.TrampolineSym : ValueType {
    internal ushort trampType;
    internal ushort cbThunk;
    internal UInt32 offThunk;
    internal UInt32 offTarget;
    internal ushort sectThunk;
    internal ushort sectTarget;
}
internal enum Microsoft.Cci.Pdb.TYPE_ENUM : Enum {
    public int value__;
    public static TYPE_ENUM T_NOTYPE;
    public static TYPE_ENUM T_ABS;
    public static TYPE_ENUM T_SEGMENT;
    public static TYPE_ENUM T_VOID;
    public static TYPE_ENUM T_HRESULT;
    public static TYPE_ENUM T_32PHRESULT;
    public static TYPE_ENUM T_64PHRESULT;
    public static TYPE_ENUM T_PVOID;
    public static TYPE_ENUM T_PFVOID;
    public static TYPE_ENUM T_PHVOID;
    public static TYPE_ENUM T_32PVOID;
    public static TYPE_ENUM T_64PVOID;
    public static TYPE_ENUM T_CURRENCY;
    public static TYPE_ENUM T_NOTTRANS;
    public static TYPE_ENUM T_BIT;
    public static TYPE_ENUM T_PASCHAR;
    public static TYPE_ENUM T_CHAR;
    public static TYPE_ENUM T_32PCHAR;
    public static TYPE_ENUM T_64PCHAR;
    public static TYPE_ENUM T_UCHAR;
    public static TYPE_ENUM T_32PUCHAR;
    public static TYPE_ENUM T_64PUCHAR;
    public static TYPE_ENUM T_RCHAR;
    public static TYPE_ENUM T_32PRCHAR;
    public static TYPE_ENUM T_64PRCHAR;
    public static TYPE_ENUM T_WCHAR;
    public static TYPE_ENUM T_32PWCHAR;
    public static TYPE_ENUM T_64PWCHAR;
    public static TYPE_ENUM T_INT1;
    public static TYPE_ENUM T_32PINT1;
    public static TYPE_ENUM T_64PINT1;
    public static TYPE_ENUM T_UINT1;
    public static TYPE_ENUM T_32PUINT1;
    public static TYPE_ENUM T_64PUINT1;
    public static TYPE_ENUM T_SHORT;
    public static TYPE_ENUM T_32PSHORT;
    public static TYPE_ENUM T_64PSHORT;
    public static TYPE_ENUM T_USHORT;
    public static TYPE_ENUM T_32PUSHORT;
    public static TYPE_ENUM T_64PUSHORT;
    public static TYPE_ENUM T_INT2;
    public static TYPE_ENUM T_32PINT2;
    public static TYPE_ENUM T_64PINT2;
    public static TYPE_ENUM T_UINT2;
    public static TYPE_ENUM T_32PUINT2;
    public static TYPE_ENUM T_64PUINT2;
    public static TYPE_ENUM T_LONG;
    public static TYPE_ENUM T_ULONG;
    public static TYPE_ENUM T_32PLONG;
    public static TYPE_ENUM T_32PULONG;
    public static TYPE_ENUM T_64PLONG;
    public static TYPE_ENUM T_64PULONG;
    public static TYPE_ENUM T_INT4;
    public static TYPE_ENUM T_32PINT4;
    public static TYPE_ENUM T_64PINT4;
    public static TYPE_ENUM T_UINT4;
    public static TYPE_ENUM T_32PUINT4;
    public static TYPE_ENUM T_64PUINT4;
    public static TYPE_ENUM T_QUAD;
    public static TYPE_ENUM T_32PQUAD;
    public static TYPE_ENUM T_64PQUAD;
    public static TYPE_ENUM T_UQUAD;
    public static TYPE_ENUM T_32PUQUAD;
    public static TYPE_ENUM T_64PUQUAD;
    public static TYPE_ENUM T_INT8;
    public static TYPE_ENUM T_32PINT8;
    public static TYPE_ENUM T_64PINT8;
    public static TYPE_ENUM T_UINT8;
    public static TYPE_ENUM T_32PUINT8;
    public static TYPE_ENUM T_64PUINT8;
    public static TYPE_ENUM T_OCT;
    public static TYPE_ENUM T_32POCT;
    public static TYPE_ENUM T_64POCT;
    public static TYPE_ENUM T_UOCT;
    public static TYPE_ENUM T_32PUOCT;
    public static TYPE_ENUM T_64PUOCT;
    public static TYPE_ENUM T_INT16;
    public static TYPE_ENUM T_32PINT16;
    public static TYPE_ENUM T_64PINT16;
    public static TYPE_ENUM T_UINT16;
    public static TYPE_ENUM T_32PUINT16;
    public static TYPE_ENUM T_64PUINT16;
    public static TYPE_ENUM T_REAL32;
    public static TYPE_ENUM T_32PREAL32;
    public static TYPE_ENUM T_64PREAL32;
    public static TYPE_ENUM T_REAL64;
    public static TYPE_ENUM T_32PREAL64;
    public static TYPE_ENUM T_64PREAL64;
    public static TYPE_ENUM T_REAL80;
    public static TYPE_ENUM T_32PREAL80;
    public static TYPE_ENUM T_64PREAL80;
    public static TYPE_ENUM T_REAL128;
    public static TYPE_ENUM T_32PREAL128;
    public static TYPE_ENUM T_64PREAL128;
    public static TYPE_ENUM T_CPLX32;
    public static TYPE_ENUM T_32PCPLX32;
    public static TYPE_ENUM T_64PCPLX32;
    public static TYPE_ENUM T_CPLX64;
    public static TYPE_ENUM T_32PCPLX64;
    public static TYPE_ENUM T_64PCPLX64;
    public static TYPE_ENUM T_CPLX80;
    public static TYPE_ENUM T_32PCPLX80;
    public static TYPE_ENUM T_64PCPLX80;
    public static TYPE_ENUM T_CPLX128;
    public static TYPE_ENUM T_32PCPLX128;
    public static TYPE_ENUM T_64PCPLX128;
    public static TYPE_ENUM T_BOOL08;
    public static TYPE_ENUM T_32PBOOL08;
    public static TYPE_ENUM T_64PBOOL08;
    public static TYPE_ENUM T_BOOL16;
    public static TYPE_ENUM T_32PBOOL16;
    public static TYPE_ENUM T_64PBOOL16;
    public static TYPE_ENUM T_BOOL32;
    public static TYPE_ENUM T_32PBOOL32;
    public static TYPE_ENUM T_64PBOOL32;
    public static TYPE_ENUM T_BOOL64;
    public static TYPE_ENUM T_32PBOOL64;
    public static TYPE_ENUM T_64PBOOL64;
}
internal class Microsoft.Cci.Pdb.TYPTYPE : ValueType {
    internal ushort len;
    internal ushort leaf;
}
internal class Microsoft.Cci.Pdb.UdtSym : ValueType {
    internal UInt32 typind;
    internal string name;
}
internal class Microsoft.Cci.Pdb.UnamespaceSym : ValueType {
    internal string name;
}
internal class Microsoft.Cci.Pdb.VpathSym32 : ValueType {
    internal UInt32 root;
    internal UInt32 path;
    internal UInt32 off;
    internal ushort seg;
}
internal class Microsoft.Cci.Pdb.WithSym32 : ValueType {
    internal UInt32 parent;
    internal UInt32 end;
    internal UInt32 len;
    internal UInt32 off;
    internal ushort seg;
    internal string expr;
}
internal class Microsoft.Cci.Pdb.XFixupData : ValueType {
    internal ushort wType;
    internal ushort wExtra;
    internal UInt32 rva;
    internal UInt32 rvaTarget;
}
internal class Microsoft.Cci.PdbIteratorScope : object {
    private UInt32 offset;
    private UInt32 length;
    public UInt32 Offset { get; }
    public UInt32 Length { get; }
    internal PdbIteratorScope(UInt32 offset, UInt32 length);
    public sealed virtual UInt32 get_Offset();
    public sealed virtual UInt32 get_Length();
}
internal class Mono.Cecil.ArrayDimension : ValueType {
    private Nullable`1<int> lower_bound;
    private Nullable`1<int> upper_bound;
    public Nullable`1<int> LowerBound { get; public set; }
    public Nullable`1<int> UpperBound { get; public set; }
    public bool IsSized { get; }
    public ArrayDimension(Nullable`1<int> lowerBound, Nullable`1<int> upperBound);
    public Nullable`1<int> get_LowerBound();
    public void set_LowerBound(Nullable`1<int> value);
    public Nullable`1<int> get_UpperBound();
    public void set_UpperBound(Nullable`1<int> value);
    public bool get_IsSized();
    public virtual string ToString();
}
internal class Mono.Cecil.ArrayMarshalInfo : MarshalInfo {
    internal NativeType element_type;
    internal int size_parameter_index;
    internal int size;
    internal int size_parameter_multiplier;
    public NativeType ElementType { get; public set; }
    public int SizeParameterIndex { get; public set; }
    public int Size { get; public set; }
    public int SizeParameterMultiplier { get; public set; }
    public NativeType get_ElementType();
    public void set_ElementType(NativeType value);
    public int get_SizeParameterIndex();
    public void set_SizeParameterIndex(int value);
    public int get_Size();
    public void set_Size(int value);
    public int get_SizeParameterMultiplier();
    public void set_SizeParameterMultiplier(int value);
}
internal class Mono.Cecil.ArrayType : TypeSpecification {
    private Collection`1<ArrayDimension> dimensions;
    public Collection`1<ArrayDimension> Dimensions { get; }
    public int Rank { get; }
    public bool IsVector { get; }
    public bool IsValueType { get; public set; }
    public string Name { get; }
    public string FullName { get; }
    private string Suffix { get; }
    public bool IsArray { get; }
    public ArrayType(TypeReference type);
    public ArrayType(TypeReference type, int rank);
    public Collection`1<ArrayDimension> get_Dimensions();
    public int get_Rank();
    public bool get_IsVector();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsArray();
}
[FlagsAttribute]
internal enum Mono.Cecil.AssemblyAttributes : Enum {
    public UInt32 value__;
    public static AssemblyAttributes PublicKey;
    public static AssemblyAttributes SideBySideCompatible;
    public static AssemblyAttributes Retargetable;
    public static AssemblyAttributes WindowsRuntime;
    public static AssemblyAttributes DisableJITCompileOptimizer;
    public static AssemblyAttributes EnableJITCompileTracking;
}
internal class Mono.Cecil.AssemblyDefinition : object {
    private AssemblyNameDefinition name;
    internal ModuleDefinition main_module;
    private Collection`1<ModuleDefinition> modules;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<SecurityDeclaration> security_declarations;
    public AssemblyNameDefinition Name { get; public set; }
    public string FullName { get; }
    public MetadataToken MetadataToken { get; public set; }
    public Collection`1<ModuleDefinition> Modules { get; }
    public ModuleDefinition MainModule { get; }
    public MethodDefinition EntryPoint { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasSecurityDeclarations { get; }
    public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public AssemblyNameDefinition get_Name();
    public void set_Name(AssemblyNameDefinition value);
    public string get_FullName();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public Collection`1<ModuleDefinition> get_Modules();
    public ModuleDefinition get_MainModule();
    public MethodDefinition get_EntryPoint();
    public void set_EntryPoint(MethodDefinition value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_HasSecurityDeclarations();
    public sealed virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
    public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleKind kind);
    public static AssemblyDefinition CreateAssembly(AssemblyNameDefinition assemblyName, string moduleName, ModuleParameters parameters);
    public static AssemblyDefinition ReadAssembly(string fileName);
    public static AssemblyDefinition ReadAssembly(string fileName, ReaderParameters parameters);
    public static AssemblyDefinition ReadAssembly(Stream stream);
    public static AssemblyDefinition ReadAssembly(Stream stream, ReaderParameters parameters);
    private static AssemblyDefinition ReadAssembly(ModuleDefinition module);
    public void Write(string fileName);
    public void Write(Stream stream);
    public void Write(string fileName, WriterParameters parameters);
    public void Write(Stream stream, WriterParameters parameters);
    public virtual string ToString();
}
internal enum Mono.Cecil.AssemblyHashAlgorithm : Enum {
    public UInt32 value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm Reserved;
    public static AssemblyHashAlgorithm SHA1;
}
internal class Mono.Cecil.AssemblyLinkedResource : Resource {
    private AssemblyNameReference reference;
    public AssemblyNameReference Assembly { get; public set; }
    public ResourceType ResourceType { get; }
    public AssemblyLinkedResource(string name, ManifestResourceAttributes flags);
    public AssemblyLinkedResource(string name, ManifestResourceAttributes flags, AssemblyNameReference reference);
    public AssemblyNameReference get_Assembly();
    public void set_Assembly(AssemblyNameReference value);
    public virtual ResourceType get_ResourceType();
}
internal class Mono.Cecil.AssemblyNameDefinition : AssemblyNameReference {
    public Byte[] Hash { get; }
    public AssemblyNameDefinition(string name, Version version);
    public virtual Byte[] get_Hash();
}
internal class Mono.Cecil.AssemblyNameReference : object {
    private string name;
    private string culture;
    private Version version;
    private UInt32 attributes;
    private Byte[] public_key;
    private Byte[] public_key_token;
    private AssemblyHashAlgorithm hash_algorithm;
    private Byte[] hash;
    internal MetadataToken token;
    private string full_name;
    public string Name { get; public set; }
    public string Culture { get; public set; }
    public Version Version { get; public set; }
    public AssemblyAttributes Attributes { get; public set; }
    public bool HasPublicKey { get; public set; }
    public bool IsSideBySideCompatible { get; public set; }
    public bool IsRetargetable { get; public set; }
    public bool IsWindowsRuntime { get; public set; }
    public Byte[] PublicKey { get; public set; }
    public Byte[] PublicKeyToken { get; public set; }
    public MetadataScopeType MetadataScopeType { get; }
    public string FullName { get; }
    public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    public Byte[] Hash { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    public AssemblyNameReference(string name, Version version);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public string get_Culture();
    public void set_Culture(string value);
    public Version get_Version();
    public void set_Version(Version value);
    public AssemblyAttributes get_Attributes();
    public void set_Attributes(AssemblyAttributes value);
    public bool get_HasPublicKey();
    public void set_HasPublicKey(bool value);
    public bool get_IsSideBySideCompatible();
    public void set_IsSideBySideCompatible(bool value);
    public bool get_IsRetargetable();
    public void set_IsRetargetable(bool value);
    public bool get_IsWindowsRuntime();
    public void set_IsWindowsRuntime(bool value);
    public Byte[] get_PublicKey();
    public void set_PublicKey(Byte[] value);
    public Byte[] get_PublicKeyToken();
    public void set_PublicKeyToken(Byte[] value);
    private Byte[] HashPublicKey();
    public virtual MetadataScopeType get_MetadataScopeType();
    public string get_FullName();
    public static AssemblyNameReference Parse(string fullName);
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public virtual Byte[] get_Hash();
    public virtual void set_Hash(Byte[] value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
}
internal class Mono.Cecil.AssemblyRefTable : MetadataTable`1<Row`9<ushort, ushort, ushort, ushort, AssemblyAttributes, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.AssemblyResolutionException : FileNotFoundException {
    private AssemblyNameReference reference;
    public AssemblyNameReference AssemblyReference { get; }
    public AssemblyResolutionException(AssemblyNameReference reference);
    protected AssemblyResolutionException(SerializationInfo info, StreamingContext context);
    public AssemblyNameReference get_AssemblyReference();
}
internal class Mono.Cecil.AssemblyResolveEventArgs : EventArgs {
    private AssemblyNameReference reference;
    public AssemblyNameReference AssemblyReference { get; }
    public AssemblyResolveEventArgs(AssemblyNameReference reference);
    public AssemblyNameReference get_AssemblyReference();
}
internal class Mono.Cecil.AssemblyResolveEventHandler : MulticastDelegate {
    public AssemblyResolveEventHandler(object object, IntPtr method);
    public virtual AssemblyDefinition Invoke(object sender, AssemblyNameReference reference);
    public virtual IAsyncResult BeginInvoke(object sender, AssemblyNameReference reference, AsyncCallback callback, object object);
    public virtual AssemblyDefinition EndInvoke(IAsyncResult result);
}
internal class Mono.Cecil.AssemblyTable : OneRowTable`1<Row`9<AssemblyHashAlgorithm, ushort, ushort, ushort, ushort, AssemblyAttributes, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal abstract class Mono.Cecil.BaseAssemblyResolver : object {
    private static bool on_mono;
    private Collection`1<string> directories;
    private Collection`1<string> gac_paths;
    [CompilerGeneratedAttribute]
private AssemblyResolveEventHandler ResolveFailure;
    private static BaseAssemblyResolver();
    public void AddSearchDirectory(string directory);
    public void RemoveSearchDirectory(string directory);
    public String[] GetSearchDirectories();
    public virtual AssemblyDefinition Resolve(string fullName);
    public virtual AssemblyDefinition Resolve(string fullName, ReaderParameters parameters);
    [CompilerGeneratedAttribute]
public void add_ResolveFailure(AssemblyResolveEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_ResolveFailure(AssemblyResolveEventHandler value);
    private AssemblyDefinition GetAssembly(string file, ReaderParameters parameters);
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
    private AssemblyDefinition SearchDirectory(AssemblyNameReference name, IEnumerable`1<string> directories, ReaderParameters parameters);
    private static bool IsZero(Version version);
    private AssemblyDefinition GetCorlib(AssemblyNameReference reference, ReaderParameters parameters);
    private static Collection`1<string> GetGacPaths();
    private static Collection`1<string> GetDefaultMonoGacPaths();
    private static string GetCurrentMonoGac();
    private AssemblyDefinition GetAssemblyInGac(AssemblyNameReference reference, ReaderParameters parameters);
    private AssemblyDefinition GetAssemblyInMonoGac(AssemblyNameReference reference, ReaderParameters parameters);
    private AssemblyDefinition GetAssemblyInNetGac(AssemblyNameReference reference, ReaderParameters parameters);
    private static string GetAssemblyFile(AssemblyNameReference reference, string prefix, string gac);
}
internal class Mono.Cecil.ByReferenceType : TypeSpecification {
    public string Name { get; }
    public string FullName { get; }
    public bool IsValueType { get; public set; }
    public bool IsByReference { get; }
    public ByReferenceType(TypeReference type);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsByReference();
}
internal class Mono.Cecil.CallSite : object {
    private MethodReference signature;
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public ModuleDefinition Module { get; }
    public IMetadataScope Scope { get; }
    public MetadataToken MetadataToken { get; public set; }
    public string FullName { get; }
    public CallSite(TypeReference returnType);
    public sealed virtual bool get_HasThis();
    public sealed virtual void set_HasThis(bool value);
    public sealed virtual bool get_ExplicitThis();
    public sealed virtual void set_ExplicitThis(bool value);
    public sealed virtual MethodCallingConvention get_CallingConvention();
    public sealed virtual void set_CallingConvention(MethodCallingConvention value);
    public sealed virtual bool get_HasParameters();
    public sealed virtual Collection`1<ParameterDefinition> get_Parameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public sealed virtual MethodReturnType get_MethodReturnType();
    public string get_Name();
    public void set_Name(string value);
    public string get_Namespace();
    public void set_Namespace(string value);
    public ModuleDefinition get_Module();
    public IMetadataScope get_Scope();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public string get_FullName();
    public virtual string ToString();
}
internal enum Mono.Cecil.Cil.Code : Enum {
    public int value__;
    public static Code Nop;
    public static Code Break;
    public static Code Ldarg_0;
    public static Code Ldarg_1;
    public static Code Ldarg_2;
    public static Code Ldarg_3;
    public static Code Ldloc_0;
    public static Code Ldloc_1;
    public static Code Ldloc_2;
    public static Code Ldloc_3;
    public static Code Stloc_0;
    public static Code Stloc_1;
    public static Code Stloc_2;
    public static Code Stloc_3;
    public static Code Ldarg_S;
    public static Code Ldarga_S;
    public static Code Starg_S;
    public static Code Ldloc_S;
    public static Code Ldloca_S;
    public static Code Stloc_S;
    public static Code Ldnull;
    public static Code Ldc_I4_M1;
    public static Code Ldc_I4_0;
    public static Code Ldc_I4_1;
    public static Code Ldc_I4_2;
    public static Code Ldc_I4_3;
    public static Code Ldc_I4_4;
    public static Code Ldc_I4_5;
    public static Code Ldc_I4_6;
    public static Code Ldc_I4_7;
    public static Code Ldc_I4_8;
    public static Code Ldc_I4_S;
    public static Code Ldc_I4;
    public static Code Ldc_I8;
    public static Code Ldc_R4;
    public static Code Ldc_R8;
    public static Code Dup;
    public static Code Pop;
    public static Code Jmp;
    public static Code Call;
    public static Code Calli;
    public static Code Ret;
    public static Code Br_S;
    public static Code Brfalse_S;
    public static Code Brtrue_S;
    public static Code Beq_S;
    public static Code Bge_S;
    public static Code Bgt_S;
    public static Code Ble_S;
    public static Code Blt_S;
    public static Code Bne_Un_S;
    public static Code Bge_Un_S;
    public static Code Bgt_Un_S;
    public static Code Ble_Un_S;
    public static Code Blt_Un_S;
    public static Code Br;
    public static Code Brfalse;
    public static Code Brtrue;
    public static Code Beq;
    public static Code Bge;
    public static Code Bgt;
    public static Code Ble;
    public static Code Blt;
    public static Code Bne_Un;
    public static Code Bge_Un;
    public static Code Bgt_Un;
    public static Code Ble_Un;
    public static Code Blt_Un;
    public static Code Switch;
    public static Code Ldind_I1;
    public static Code Ldind_U1;
    public static Code Ldind_I2;
    public static Code Ldind_U2;
    public static Code Ldind_I4;
    public static Code Ldind_U4;
    public static Code Ldind_I8;
    public static Code Ldind_I;
    public static Code Ldind_R4;
    public static Code Ldind_R8;
    public static Code Ldind_Ref;
    public static Code Stind_Ref;
    public static Code Stind_I1;
    public static Code Stind_I2;
    public static Code Stind_I4;
    public static Code Stind_I8;
    public static Code Stind_R4;
    public static Code Stind_R8;
    public static Code Add;
    public static Code Sub;
    public static Code Mul;
    public static Code Div;
    public static Code Div_Un;
    public static Code Rem;
    public static Code Rem_Un;
    public static Code And;
    public static Code Or;
    public static Code Xor;
    public static Code Shl;
    public static Code Shr;
    public static Code Shr_Un;
    public static Code Neg;
    public static Code Not;
    public static Code Conv_I1;
    public static Code Conv_I2;
    public static Code Conv_I4;
    public static Code Conv_I8;
    public static Code Conv_R4;
    public static Code Conv_R8;
    public static Code Conv_U4;
    public static Code Conv_U8;
    public static Code Callvirt;
    public static Code Cpobj;
    public static Code Ldobj;
    public static Code Ldstr;
    public static Code Newobj;
    public static Code Castclass;
    public static Code Isinst;
    public static Code Conv_R_Un;
    public static Code Unbox;
    public static Code Throw;
    public static Code Ldfld;
    public static Code Ldflda;
    public static Code Stfld;
    public static Code Ldsfld;
    public static Code Ldsflda;
    public static Code Stsfld;
    public static Code Stobj;
    public static Code Conv_Ovf_I1_Un;
    public static Code Conv_Ovf_I2_Un;
    public static Code Conv_Ovf_I4_Un;
    public static Code Conv_Ovf_I8_Un;
    public static Code Conv_Ovf_U1_Un;
    public static Code Conv_Ovf_U2_Un;
    public static Code Conv_Ovf_U4_Un;
    public static Code Conv_Ovf_U8_Un;
    public static Code Conv_Ovf_I_Un;
    public static Code Conv_Ovf_U_Un;
    public static Code Box;
    public static Code Newarr;
    public static Code Ldlen;
    public static Code Ldelema;
    public static Code Ldelem_I1;
    public static Code Ldelem_U1;
    public static Code Ldelem_I2;
    public static Code Ldelem_U2;
    public static Code Ldelem_I4;
    public static Code Ldelem_U4;
    public static Code Ldelem_I8;
    public static Code Ldelem_I;
    public static Code Ldelem_R4;
    public static Code Ldelem_R8;
    public static Code Ldelem_Ref;
    public static Code Stelem_I;
    public static Code Stelem_I1;
    public static Code Stelem_I2;
    public static Code Stelem_I4;
    public static Code Stelem_I8;
    public static Code Stelem_R4;
    public static Code Stelem_R8;
    public static Code Stelem_Ref;
    public static Code Ldelem_Any;
    public static Code Stelem_Any;
    public static Code Unbox_Any;
    public static Code Conv_Ovf_I1;
    public static Code Conv_Ovf_U1;
    public static Code Conv_Ovf_I2;
    public static Code Conv_Ovf_U2;
    public static Code Conv_Ovf_I4;
    public static Code Conv_Ovf_U4;
    public static Code Conv_Ovf_I8;
    public static Code Conv_Ovf_U8;
    public static Code Refanyval;
    public static Code Ckfinite;
    public static Code Mkrefany;
    public static Code Ldtoken;
    public static Code Conv_U2;
    public static Code Conv_U1;
    public static Code Conv_I;
    public static Code Conv_Ovf_I;
    public static Code Conv_Ovf_U;
    public static Code Add_Ovf;
    public static Code Add_Ovf_Un;
    public static Code Mul_Ovf;
    public static Code Mul_Ovf_Un;
    public static Code Sub_Ovf;
    public static Code Sub_Ovf_Un;
    public static Code Endfinally;
    public static Code Leave;
    public static Code Leave_S;
    public static Code Stind_I;
    public static Code Conv_U;
    public static Code Arglist;
    public static Code Ceq;
    public static Code Cgt;
    public static Code Cgt_Un;
    public static Code Clt;
    public static Code Clt_Un;
    public static Code Ldftn;
    public static Code Ldvirtftn;
    public static Code Ldarg;
    public static Code Ldarga;
    public static Code Starg;
    public static Code Ldloc;
    public static Code Ldloca;
    public static Code Stloc;
    public static Code Localloc;
    public static Code Endfilter;
    public static Code Unaligned;
    public static Code Volatile;
    public static Code Tail;
    public static Code Initobj;
    public static Code Constrained;
    public static Code Cpblk;
    public static Code Initblk;
    public static Code No;
    public static Code Rethrow;
    public static Code Sizeof;
    public static Code Refanytype;
    public static Code Readonly;
}
internal class Mono.Cecil.Cil.CodeReader : ByteBuffer {
    internal MetadataReader reader;
    private int start;
    private Section code_section;
    private MethodDefinition method;
    private MethodBody body;
    private int Offset { get; }
    public CodeReader(Section section, MetadataReader reader);
    private int get_Offset();
    public MethodBody ReadMethodBody(MethodDefinition method);
    public void MoveTo(int rva);
    private bool IsInSection(int rva);
    private void ReadMethodBody();
    private void ReadFatMethod();
    public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token);
    private void ReadCode();
    private OpCode ReadOpCode();
    private object ReadOperand(Instruction instruction);
    public string GetString(MetadataToken token);
    public ParameterDefinition GetParameter(int index);
    public VariableDefinition GetVariable(int index);
    public CallSite GetCallSite(MetadataToken token);
    private void ResolveBranches(Collection`1<Instruction> instructions);
    private Instruction GetInstruction(int offset);
    private static Instruction GetInstruction(Collection`1<Instruction> instructions, int offset);
    private void ReadSection();
    private void ReadSmallSection();
    private void ReadFatSection();
    private void ReadExceptionHandlers(int count, Func`1<int> read_entry, Func`1<int> read_length);
    private void ReadExceptionHandlerSpecific(ExceptionHandler handler);
    private void Align(int align);
    public MetadataToken ReadToken();
    public ByteBuffer PatchRawMethodBody(MethodDefinition method, CodeWriter writer, MethodSymbols& symbols);
    private void PatchRawFatMethod(ByteBuffer buffer, MethodSymbols symbols, CodeWriter writer, MetadataToken& local_var_token);
    private static MetadataToken GetOriginalToken(MetadataBuilder metadata, MethodDefinition method);
    private void PatchRawCode(ByteBuffer buffer, int code_size, CodeWriter writer);
    private void PatchRawSection(ByteBuffer buffer, MetadataBuilder metadata);
    private void PatchRawSmallSection(ByteBuffer buffer, MetadataBuilder metadata);
    private void PatchRawFatSection(ByteBuffer buffer, MetadataBuilder metadata);
    private void PatchRawExceptionHandlers(ByteBuffer buffer, MetadataBuilder metadata, int count, bool fat_entry);
    [CompilerGeneratedAttribute]
private int <ReadSmallSection>b__25_0();
    [CompilerGeneratedAttribute]
private int <ReadSmallSection>b__25_1();
}
internal class Mono.Cecil.Cil.CodeWriter : ByteBuffer {
    private UInt32 code_base;
    internal MetadataBuilder metadata;
    private Dictionary`2<UInt32, MetadataToken> standalone_signatures;
    private UInt32 current;
    private MethodBody body;
    public CodeWriter(MetadataBuilder metadata);
    public UInt32 WriteMethodBody(MethodDefinition method);
    private static bool IsEmptyMethodBody(MethodBody body);
    private static bool IsUnresolved(MethodDefinition method);
    private void WriteUnresolvedMethodBody(MethodDefinition method);
    private static MetadataToken GetLocalVarToken(ByteBuffer buffer, MethodSymbols symbols);
    private void WriteResolvedMethodBody(MethodDefinition method);
    private void WriteFatHeader();
    private void WriteInstructions();
    private void WriteOpCode(OpCode opcode);
    private void WriteOperand(Instruction instruction);
    private int GetTargetOffset(Instruction instruction);
    private UInt32 GetUserStringIndex(string string);
    private static int GetVariableIndex(VariableDefinition variable);
    private int GetParameterIndex(ParameterDefinition parameter);
    private bool RequiresFatHeader();
    private void ComputeHeader();
    private void ComputeExceptionHandlerStackSize(Dictionary`2& stack_sizes);
    private static void AddExceptionStackSize(Instruction handler_start, Dictionary`2& stack_sizes);
    private static void ComputeStackSize(Instruction instruction, Dictionary`2& stack_sizes, Int32& stack_size, Int32& max_stack);
    private static void CopyBranchStackSize(Instruction instruction, Dictionary`2& stack_sizes, int stack_size);
    private static void CopyBranchStackSize(Dictionary`2& stack_sizes, Instruction target, int stack_size);
    private static void ComputeStackSize(Instruction instruction, Int32& stack_size);
    private static void ComputeStackDelta(Instruction instruction, Int32& stack_size);
    private static void ComputePopDelta(StackBehaviour pop_behavior, Int32& stack_size);
    private static void ComputePushDelta(StackBehaviour push_behaviour, Int32& stack_size);
    private void WriteExceptionHandlers();
    private static bool RequiresFatSection(Collection`1<ExceptionHandler> handlers);
    private static bool IsFatRange(Instruction start, Instruction end);
    private void WriteSmallSection(Collection`1<ExceptionHandler> handlers);
    private void WriteFatSection(Collection`1<ExceptionHandler> handlers);
    private void WriteExceptionHandlers(Collection`1<ExceptionHandler> handlers, Action`1<int> write_entry, Action`1<int> write_length);
    private void WriteExceptionHandlerSpecific(ExceptionHandler handler);
    public MetadataToken GetStandAloneSignature(Collection`1<VariableDefinition> variables);
    public MetadataToken GetStandAloneSignature(CallSite call_site);
    private MetadataToken GetStandAloneSignatureToken(UInt32 signature);
    private UInt32 BeginMethod();
    private void WriteMetadataToken(MetadataToken token);
    private void Align(int align);
    private void EndMethod();
    [CompilerGeneratedAttribute]
private void <WriteSmallSection>b__34_0(int i);
    [CompilerGeneratedAttribute]
private void <WriteSmallSection>b__34_1(int i);
}
internal class Mono.Cecil.Cil.Document : object {
    private string url;
    private byte type;
    private byte hash_algorithm;
    private byte language;
    private byte language_vendor;
    private Byte[] hash;
    public string Url { get; public set; }
    public DocumentType Type { get; public set; }
    public DocumentHashAlgorithm HashAlgorithm { get; public set; }
    public DocumentLanguage Language { get; public set; }
    public DocumentLanguageVendor LanguageVendor { get; public set; }
    public Byte[] Hash { get; public set; }
    public Document(string url);
    public string get_Url();
    public void set_Url(string value);
    public DocumentType get_Type();
    public void set_Type(DocumentType value);
    public DocumentHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(DocumentHashAlgorithm value);
    public DocumentLanguage get_Language();
    public void set_Language(DocumentLanguage value);
    public DocumentLanguageVendor get_LanguageVendor();
    public void set_LanguageVendor(DocumentLanguageVendor value);
    public Byte[] get_Hash();
    public void set_Hash(Byte[] value);
}
internal enum Mono.Cecil.Cil.DocumentHashAlgorithm : Enum {
    public int value__;
    public static DocumentHashAlgorithm None;
    public static DocumentHashAlgorithm MD5;
    public static DocumentHashAlgorithm SHA1;
}
internal enum Mono.Cecil.Cil.DocumentLanguage : Enum {
    public int value__;
    public static DocumentLanguage Other;
    public static DocumentLanguage C;
    public static DocumentLanguage Cpp;
    public static DocumentLanguage CSharp;
    public static DocumentLanguage Basic;
    public static DocumentLanguage Java;
    public static DocumentLanguage Cobol;
    public static DocumentLanguage Pascal;
    public static DocumentLanguage Cil;
    public static DocumentLanguage JScript;
    public static DocumentLanguage Smc;
    public static DocumentLanguage MCpp;
    public static DocumentLanguage FSharp;
}
internal enum Mono.Cecil.Cil.DocumentLanguageVendor : Enum {
    public int value__;
    public static DocumentLanguageVendor Other;
    public static DocumentLanguageVendor Microsoft;
}
internal enum Mono.Cecil.Cil.DocumentType : Enum {
    public int value__;
    public static DocumentType Other;
    public static DocumentType Text;
}
internal class Mono.Cecil.Cil.ExceptionHandler : object {
    private Instruction try_start;
    private Instruction try_end;
    private Instruction filter_start;
    private Instruction handler_start;
    private Instruction handler_end;
    private TypeReference catch_type;
    private ExceptionHandlerType handler_type;
    public Instruction TryStart { get; public set; }
    public Instruction TryEnd { get; public set; }
    public Instruction FilterStart { get; public set; }
    public Instruction HandlerStart { get; public set; }
    public Instruction HandlerEnd { get; public set; }
    public TypeReference CatchType { get; public set; }
    public ExceptionHandlerType HandlerType { get; public set; }
    public ExceptionHandler(ExceptionHandlerType handlerType);
    public Instruction get_TryStart();
    public void set_TryStart(Instruction value);
    public Instruction get_TryEnd();
    public void set_TryEnd(Instruction value);
    public Instruction get_FilterStart();
    public void set_FilterStart(Instruction value);
    public Instruction get_HandlerStart();
    public void set_HandlerStart(Instruction value);
    public Instruction get_HandlerEnd();
    public void set_HandlerEnd(Instruction value);
    public TypeReference get_CatchType();
    public void set_CatchType(TypeReference value);
    public ExceptionHandlerType get_HandlerType();
    public void set_HandlerType(ExceptionHandlerType value);
}
internal enum Mono.Cecil.Cil.ExceptionHandlerType : Enum {
    public int value__;
    public static ExceptionHandlerType Catch;
    public static ExceptionHandlerType Filter;
    public static ExceptionHandlerType Finally;
    public static ExceptionHandlerType Fault;
}
internal enum Mono.Cecil.Cil.FlowControl : Enum {
    public int value__;
    public static FlowControl Branch;
    public static FlowControl Break;
    public static FlowControl Call;
    public static FlowControl Cond_Branch;
    public static FlowControl Meta;
    public static FlowControl Next;
    public static FlowControl Phi;
    public static FlowControl Return;
    public static FlowControl Throw;
}
internal class Mono.Cecil.Cil.ILProcessor : object {
    private MethodBody body;
    private Collection`1<Instruction> instructions;
    public MethodBody Body { get; }
    internal ILProcessor(MethodBody body);
    public MethodBody get_Body();
    public Instruction Create(OpCode opcode);
    public Instruction Create(OpCode opcode, TypeReference type);
    public Instruction Create(OpCode opcode, CallSite site);
    public Instruction Create(OpCode opcode, MethodReference method);
    public Instruction Create(OpCode opcode, FieldReference field);
    public Instruction Create(OpCode opcode, string value);
    public Instruction Create(OpCode opcode, sbyte value);
    public Instruction Create(OpCode opcode, byte value);
    public Instruction Create(OpCode opcode, int value);
    public Instruction Create(OpCode opcode, long value);
    public Instruction Create(OpCode opcode, float value);
    public Instruction Create(OpCode opcode, double value);
    public Instruction Create(OpCode opcode, Instruction target);
    public Instruction Create(OpCode opcode, Instruction[] targets);
    public Instruction Create(OpCode opcode, VariableDefinition variable);
    public Instruction Create(OpCode opcode, ParameterDefinition parameter);
    public void Emit(OpCode opcode);
    public void Emit(OpCode opcode, TypeReference type);
    public void Emit(OpCode opcode, MethodReference method);
    public void Emit(OpCode opcode, CallSite site);
    public void Emit(OpCode opcode, FieldReference field);
    public void Emit(OpCode opcode, string value);
    public void Emit(OpCode opcode, byte value);
    public void Emit(OpCode opcode, sbyte value);
    public void Emit(OpCode opcode, int value);
    public void Emit(OpCode opcode, long value);
    public void Emit(OpCode opcode, float value);
    public void Emit(OpCode opcode, double value);
    public void Emit(OpCode opcode, Instruction target);
    public void Emit(OpCode opcode, Instruction[] targets);
    public void Emit(OpCode opcode, VariableDefinition variable);
    public void Emit(OpCode opcode, ParameterDefinition parameter);
    public void InsertBefore(Instruction target, Instruction instruction);
    public void InsertAfter(Instruction target, Instruction instruction);
    public void Append(Instruction instruction);
    public void Replace(Instruction target, Instruction instruction);
    public void Remove(Instruction instruction);
}
internal class Mono.Cecil.Cil.ImageDebugDirectory : ValueType {
    public int Characteristics;
    public int TimeDateStamp;
    public short MajorVersion;
    public short MinorVersion;
    public int Type;
    public int SizeOfData;
    public int AddressOfRawData;
    public int PointerToRawData;
}
internal class Mono.Cecil.Cil.Instruction : object {
    internal int offset;
    internal OpCode opcode;
    internal object operand;
    internal Instruction previous;
    internal Instruction next;
    private SequencePoint sequence_point;
    public int Offset { get; public set; }
    public OpCode OpCode { get; public set; }
    public object Operand { get; public set; }
    public Instruction Previous { get; public set; }
    public Instruction Next { get; public set; }
    public SequencePoint SequencePoint { get; public set; }
    internal Instruction(int offset, OpCode opCode);
    internal Instruction(OpCode opcode, object operand);
    public int get_Offset();
    public void set_Offset(int value);
    public OpCode get_OpCode();
    public void set_OpCode(OpCode value);
    public object get_Operand();
    public void set_Operand(object value);
    public Instruction get_Previous();
    public void set_Previous(Instruction value);
    public Instruction get_Next();
    public void set_Next(Instruction value);
    public SequencePoint get_SequencePoint();
    public void set_SequencePoint(SequencePoint value);
    public int GetSize();
    public virtual string ToString();
    private static void AppendLabel(StringBuilder builder, Instruction instruction);
    public static Instruction Create(OpCode opcode);
    public static Instruction Create(OpCode opcode, TypeReference type);
    public static Instruction Create(OpCode opcode, CallSite site);
    public static Instruction Create(OpCode opcode, MethodReference method);
    public static Instruction Create(OpCode opcode, FieldReference field);
    public static Instruction Create(OpCode opcode, string value);
    public static Instruction Create(OpCode opcode, sbyte value);
    public static Instruction Create(OpCode opcode, byte value);
    public static Instruction Create(OpCode opcode, int value);
    public static Instruction Create(OpCode opcode, long value);
    public static Instruction Create(OpCode opcode, float value);
    public static Instruction Create(OpCode opcode, double value);
    public static Instruction Create(OpCode opcode, Instruction target);
    public static Instruction Create(OpCode opcode, Instruction[] targets);
    public static Instruction Create(OpCode opcode, VariableDefinition variable);
    public static Instruction Create(OpCode opcode, ParameterDefinition parameter);
}
internal class Mono.Cecil.Cil.InstructionCollection : Collection`1<Instruction> {
    internal InstructionCollection(int capacity);
    protected virtual void OnAdd(Instruction item, int index);
    protected virtual void OnInsert(Instruction item, int index);
    protected virtual void OnSet(Instruction item, int index);
    protected virtual void OnRemove(Instruction item, int index);
}
internal class Mono.Cecil.Cil.InstructionMapper : MulticastDelegate {
    public InstructionMapper(object object, IntPtr method);
    public virtual Instruction Invoke(int offset);
    public virtual IAsyncResult BeginInvoke(int offset, AsyncCallback callback, object object);
    public virtual Instruction EndInvoke(IAsyncResult result);
}
internal class Mono.Cecil.Cil.InstructionSymbol : ValueType {
    public int Offset;
    public SequencePoint SequencePoint;
    public InstructionSymbol(int offset, SequencePoint sequencePoint);
}
internal interface Mono.Cecil.Cil.ISymbolReader {
    public abstract virtual bool ProcessDebugHeader(ImageDebugDirectory directory, Byte[] header);
    public abstract virtual void Read(MethodBody body, InstructionMapper mapper);
    public abstract virtual void Read(MethodSymbols symbols);
}
internal interface Mono.Cecil.Cil.ISymbolReaderProvider {
    public abstract virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public abstract virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
internal interface Mono.Cecil.Cil.ISymbolWriter {
    public abstract virtual bool GetDebugHeader(ImageDebugDirectory& directory, Byte[]& header);
    public abstract virtual void Write(MethodBody body);
    public abstract virtual void Write(MethodSymbols symbols);
}
internal interface Mono.Cecil.Cil.ISymbolWriterProvider {
    public abstract virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public abstract virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
internal interface Mono.Cecil.Cil.IVariableDefinitionProvider {
    public bool HasVariables { get; }
    public Collection`1<VariableDefinition> Variables { get; }
    public abstract virtual bool get_HasVariables();
    public abstract virtual Collection`1<VariableDefinition> get_Variables();
}
internal class Mono.Cecil.Cil.MethodBody : object {
    internal MethodDefinition method;
    internal ParameterDefinition this_parameter;
    internal int max_stack_size;
    internal int code_size;
    internal bool init_locals;
    internal MetadataToken local_var_token;
    internal Collection`1<Instruction> instructions;
    internal Collection`1<ExceptionHandler> exceptions;
    internal Collection`1<VariableDefinition> variables;
    private Scope scope;
    public MethodDefinition Method { get; }
    public int MaxStackSize { get; public set; }
    public int CodeSize { get; }
    public bool InitLocals { get; public set; }
    public MetadataToken LocalVarToken { get; public set; }
    public Collection`1<Instruction> Instructions { get; }
    public bool HasExceptionHandlers { get; }
    public Collection`1<ExceptionHandler> ExceptionHandlers { get; }
    public bool HasVariables { get; }
    public Collection`1<VariableDefinition> Variables { get; }
    public Scope Scope { get; public set; }
    public ParameterDefinition ThisParameter { get; }
    public MethodBody(MethodDefinition method);
    public MethodDefinition get_Method();
    public int get_MaxStackSize();
    public void set_MaxStackSize(int value);
    public int get_CodeSize();
    public bool get_InitLocals();
    public void set_InitLocals(bool value);
    public MetadataToken get_LocalVarToken();
    public void set_LocalVarToken(MetadataToken value);
    public Collection`1<Instruction> get_Instructions();
    public bool get_HasExceptionHandlers();
    public Collection`1<ExceptionHandler> get_ExceptionHandlers();
    public sealed virtual bool get_HasVariables();
    public sealed virtual Collection`1<VariableDefinition> get_Variables();
    public Scope get_Scope();
    public void set_Scope(Scope value);
    public ParameterDefinition get_ThisParameter();
    private static ParameterDefinition CreateThisParameter(MethodDefinition method);
    public ILProcessor GetILProcessor();
}
internal class Mono.Cecil.Cil.MethodSymbols : object {
    internal int code_size;
    internal string method_name;
    internal MetadataToken method_token;
    internal MetadataToken local_var_token;
    internal Collection`1<VariableDefinition> variables;
    internal Collection`1<InstructionSymbol> instructions;
    public bool HasVariables { get; }
    public Collection`1<VariableDefinition> Variables { get; }
    public Collection`1<InstructionSymbol> Instructions { get; }
    public int CodeSize { get; }
    public string MethodName { get; }
    public MetadataToken MethodToken { get; }
    public MetadataToken LocalVarToken { get; }
    internal MethodSymbols(string methodName);
    public MethodSymbols(MetadataToken methodToken);
    public bool get_HasVariables();
    public Collection`1<VariableDefinition> get_Variables();
    public Collection`1<InstructionSymbol> get_Instructions();
    public int get_CodeSize();
    public string get_MethodName();
    public MetadataToken get_MethodToken();
    public MetadataToken get_LocalVarToken();
}
internal class Mono.Cecil.Cil.OpCode : ValueType {
    private byte op1;
    private byte op2;
    private byte code;
    private byte flow_control;
    private byte opcode_type;
    private byte operand_type;
    private byte stack_behavior_pop;
    private byte stack_behavior_push;
    public string Name { get; }
    public int Size { get; }
    public byte Op1 { get; }
    public byte Op2 { get; }
    public short Value { get; }
    public Code Code { get; }
    public FlowControl FlowControl { get; }
    public OpCodeType OpCodeType { get; }
    public OperandType OperandType { get; }
    public StackBehaviour StackBehaviourPop { get; }
    public StackBehaviour StackBehaviourPush { get; }
    internal OpCode(int x, int y);
    public string get_Name();
    public int get_Size();
    public byte get_Op1();
    public byte get_Op2();
    public short get_Value();
    public Code get_Code();
    public FlowControl get_FlowControl();
    public OpCodeType get_OpCodeType();
    public OperandType get_OperandType();
    public StackBehaviour get_StackBehaviourPop();
    public StackBehaviour get_StackBehaviourPush();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OpCode opcode);
    public static bool op_Equality(OpCode one, OpCode other);
    public static bool op_Inequality(OpCode one, OpCode other);
    public virtual string ToString();
}
internal static class Mono.Cecil.Cil.OpCodeNames : object {
    internal static String[] names;
    private static OpCodeNames();
}
internal static class Mono.Cecil.Cil.OpCodes : object {
    internal static OpCode[] OneByteOpCode;
    internal static OpCode[] TwoBytesOpCode;
    public static OpCode Nop;
    public static OpCode Break;
    public static OpCode Ldarg_0;
    public static OpCode Ldarg_1;
    public static OpCode Ldarg_2;
    public static OpCode Ldarg_3;
    public static OpCode Ldloc_0;
    public static OpCode Ldloc_1;
    public static OpCode Ldloc_2;
    public static OpCode Ldloc_3;
    public static OpCode Stloc_0;
    public static OpCode Stloc_1;
    public static OpCode Stloc_2;
    public static OpCode Stloc_3;
    public static OpCode Ldarg_S;
    public static OpCode Ldarga_S;
    public static OpCode Starg_S;
    public static OpCode Ldloc_S;
    public static OpCode Ldloca_S;
    public static OpCode Stloc_S;
    public static OpCode Ldnull;
    public static OpCode Ldc_I4_M1;
    public static OpCode Ldc_I4_0;
    public static OpCode Ldc_I4_1;
    public static OpCode Ldc_I4_2;
    public static OpCode Ldc_I4_3;
    public static OpCode Ldc_I4_4;
    public static OpCode Ldc_I4_5;
    public static OpCode Ldc_I4_6;
    public static OpCode Ldc_I4_7;
    public static OpCode Ldc_I4_8;
    public static OpCode Ldc_I4_S;
    public static OpCode Ldc_I4;
    public static OpCode Ldc_I8;
    public static OpCode Ldc_R4;
    public static OpCode Ldc_R8;
    public static OpCode Dup;
    public static OpCode Pop;
    public static OpCode Jmp;
    public static OpCode Call;
    public static OpCode Calli;
    public static OpCode Ret;
    public static OpCode Br_S;
    public static OpCode Brfalse_S;
    public static OpCode Brtrue_S;
    public static OpCode Beq_S;
    public static OpCode Bge_S;
    public static OpCode Bgt_S;
    public static OpCode Ble_S;
    public static OpCode Blt_S;
    public static OpCode Bne_Un_S;
    public static OpCode Bge_Un_S;
    public static OpCode Bgt_Un_S;
    public static OpCode Ble_Un_S;
    public static OpCode Blt_Un_S;
    public static OpCode Br;
    public static OpCode Brfalse;
    public static OpCode Brtrue;
    public static OpCode Beq;
    public static OpCode Bge;
    public static OpCode Bgt;
    public static OpCode Ble;
    public static OpCode Blt;
    public static OpCode Bne_Un;
    public static OpCode Bge_Un;
    public static OpCode Bgt_Un;
    public static OpCode Ble_Un;
    public static OpCode Blt_Un;
    public static OpCode Switch;
    public static OpCode Ldind_I1;
    public static OpCode Ldind_U1;
    public static OpCode Ldind_I2;
    public static OpCode Ldind_U2;
    public static OpCode Ldind_I4;
    public static OpCode Ldind_U4;
    public static OpCode Ldind_I8;
    public static OpCode Ldind_I;
    public static OpCode Ldind_R4;
    public static OpCode Ldind_R8;
    public static OpCode Ldind_Ref;
    public static OpCode Stind_Ref;
    public static OpCode Stind_I1;
    public static OpCode Stind_I2;
    public static OpCode Stind_I4;
    public static OpCode Stind_I8;
    public static OpCode Stind_R4;
    public static OpCode Stind_R8;
    public static OpCode Add;
    public static OpCode Sub;
    public static OpCode Mul;
    public static OpCode Div;
    public static OpCode Div_Un;
    public static OpCode Rem;
    public static OpCode Rem_Un;
    public static OpCode And;
    public static OpCode Or;
    public static OpCode Xor;
    public static OpCode Shl;
    public static OpCode Shr;
    public static OpCode Shr_Un;
    public static OpCode Neg;
    public static OpCode Not;
    public static OpCode Conv_I1;
    public static OpCode Conv_I2;
    public static OpCode Conv_I4;
    public static OpCode Conv_I8;
    public static OpCode Conv_R4;
    public static OpCode Conv_R8;
    public static OpCode Conv_U4;
    public static OpCode Conv_U8;
    public static OpCode Callvirt;
    public static OpCode Cpobj;
    public static OpCode Ldobj;
    public static OpCode Ldstr;
    public static OpCode Newobj;
    public static OpCode Castclass;
    public static OpCode Isinst;
    public static OpCode Conv_R_Un;
    public static OpCode Unbox;
    public static OpCode Throw;
    public static OpCode Ldfld;
    public static OpCode Ldflda;
    public static OpCode Stfld;
    public static OpCode Ldsfld;
    public static OpCode Ldsflda;
    public static OpCode Stsfld;
    public static OpCode Stobj;
    public static OpCode Conv_Ovf_I1_Un;
    public static OpCode Conv_Ovf_I2_Un;
    public static OpCode Conv_Ovf_I4_Un;
    public static OpCode Conv_Ovf_I8_Un;
    public static OpCode Conv_Ovf_U1_Un;
    public static OpCode Conv_Ovf_U2_Un;
    public static OpCode Conv_Ovf_U4_Un;
    public static OpCode Conv_Ovf_U8_Un;
    public static OpCode Conv_Ovf_I_Un;
    public static OpCode Conv_Ovf_U_Un;
    public static OpCode Box;
    public static OpCode Newarr;
    public static OpCode Ldlen;
    public static OpCode Ldelema;
    public static OpCode Ldelem_I1;
    public static OpCode Ldelem_U1;
    public static OpCode Ldelem_I2;
    public static OpCode Ldelem_U2;
    public static OpCode Ldelem_I4;
    public static OpCode Ldelem_U4;
    public static OpCode Ldelem_I8;
    public static OpCode Ldelem_I;
    public static OpCode Ldelem_R4;
    public static OpCode Ldelem_R8;
    public static OpCode Ldelem_Ref;
    public static OpCode Stelem_I;
    public static OpCode Stelem_I1;
    public static OpCode Stelem_I2;
    public static OpCode Stelem_I4;
    public static OpCode Stelem_I8;
    public static OpCode Stelem_R4;
    public static OpCode Stelem_R8;
    public static OpCode Stelem_Ref;
    public static OpCode Ldelem_Any;
    public static OpCode Stelem_Any;
    public static OpCode Unbox_Any;
    public static OpCode Conv_Ovf_I1;
    public static OpCode Conv_Ovf_U1;
    public static OpCode Conv_Ovf_I2;
    public static OpCode Conv_Ovf_U2;
    public static OpCode Conv_Ovf_I4;
    public static OpCode Conv_Ovf_U4;
    public static OpCode Conv_Ovf_I8;
    public static OpCode Conv_Ovf_U8;
    public static OpCode Refanyval;
    public static OpCode Ckfinite;
    public static OpCode Mkrefany;
    public static OpCode Ldtoken;
    public static OpCode Conv_U2;
    public static OpCode Conv_U1;
    public static OpCode Conv_I;
    public static OpCode Conv_Ovf_I;
    public static OpCode Conv_Ovf_U;
    public static OpCode Add_Ovf;
    public static OpCode Add_Ovf_Un;
    public static OpCode Mul_Ovf;
    public static OpCode Mul_Ovf_Un;
    public static OpCode Sub_Ovf;
    public static OpCode Sub_Ovf_Un;
    public static OpCode Endfinally;
    public static OpCode Leave;
    public static OpCode Leave_S;
    public static OpCode Stind_I;
    public static OpCode Conv_U;
    public static OpCode Arglist;
    public static OpCode Ceq;
    public static OpCode Cgt;
    public static OpCode Cgt_Un;
    public static OpCode Clt;
    public static OpCode Clt_Un;
    public static OpCode Ldftn;
    public static OpCode Ldvirtftn;
    public static OpCode Ldarg;
    public static OpCode Ldarga;
    public static OpCode Starg;
    public static OpCode Ldloc;
    public static OpCode Ldloca;
    public static OpCode Stloc;
    public static OpCode Localloc;
    public static OpCode Endfilter;
    public static OpCode Unaligned;
    public static OpCode Volatile;
    public static OpCode Tail;
    public static OpCode Initobj;
    public static OpCode Constrained;
    public static OpCode Cpblk;
    public static OpCode Initblk;
    public static OpCode No;
    public static OpCode Rethrow;
    public static OpCode Sizeof;
    public static OpCode Refanytype;
    public static OpCode Readonly;
    private static OpCodes();
}
internal enum Mono.Cecil.Cil.OpCodeType : Enum {
    public int value__;
    public static OpCodeType Annotation;
    public static OpCodeType Macro;
    public static OpCodeType Nternal;
    public static OpCodeType Objmodel;
    public static OpCodeType Prefix;
    public static OpCodeType Primitive;
}
internal enum Mono.Cecil.Cil.OperandType : Enum {
    public int value__;
    public static OperandType InlineBrTarget;
    public static OperandType InlineField;
    public static OperandType InlineI;
    public static OperandType InlineI8;
    public static OperandType InlineMethod;
    public static OperandType InlineNone;
    public static OperandType InlinePhi;
    public static OperandType InlineR;
    public static OperandType InlineSig;
    public static OperandType InlineString;
    public static OperandType InlineSwitch;
    public static OperandType InlineTok;
    public static OperandType InlineType;
    public static OperandType InlineVar;
    public static OperandType InlineArg;
    public static OperandType ShortInlineBrTarget;
    public static OperandType ShortInlineI;
    public static OperandType ShortInlineR;
    public static OperandType ShortInlineVar;
    public static OperandType ShortInlineArg;
}
internal class Mono.Cecil.Cil.Scope : object {
    private Instruction start;
    private Instruction end;
    private Collection`1<Scope> scopes;
    private Collection`1<VariableDefinition> variables;
    public Instruction Start { get; public set; }
    public Instruction End { get; public set; }
    public bool HasScopes { get; }
    public Collection`1<Scope> Scopes { get; }
    public bool HasVariables { get; }
    public Collection`1<VariableDefinition> Variables { get; }
    public Instruction get_Start();
    public void set_Start(Instruction value);
    public Instruction get_End();
    public void set_End(Instruction value);
    public bool get_HasScopes();
    public Collection`1<Scope> get_Scopes();
    public sealed virtual bool get_HasVariables();
    public sealed virtual Collection`1<VariableDefinition> get_Variables();
}
internal class Mono.Cecil.Cil.SequencePoint : object {
    private Document document;
    private int start_line;
    private int start_column;
    private int end_line;
    private int end_column;
    public int StartLine { get; public set; }
    public int StartColumn { get; public set; }
    public int EndLine { get; public set; }
    public int EndColumn { get; public set; }
    public Document Document { get; public set; }
    public SequencePoint(Document document);
    public int get_StartLine();
    public void set_StartLine(int value);
    public int get_StartColumn();
    public void set_StartColumn(int value);
    public int get_EndLine();
    public void set_EndLine(int value);
    public int get_EndColumn();
    public void set_EndColumn(int value);
    public Document get_Document();
    public void set_Document(Document value);
}
internal enum Mono.Cecil.Cil.StackBehaviour : Enum {
    public int value__;
    public static StackBehaviour Pop0;
    public static StackBehaviour Pop1;
    public static StackBehaviour Pop1_pop1;
    public static StackBehaviour Popi;
    public static StackBehaviour Popi_pop1;
    public static StackBehaviour Popi_popi;
    public static StackBehaviour Popi_popi8;
    public static StackBehaviour Popi_popi_popi;
    public static StackBehaviour Popi_popr4;
    public static StackBehaviour Popi_popr8;
    public static StackBehaviour Popref;
    public static StackBehaviour Popref_pop1;
    public static StackBehaviour Popref_popi;
    public static StackBehaviour Popref_popi_popi;
    public static StackBehaviour Popref_popi_popi8;
    public static StackBehaviour Popref_popi_popr4;
    public static StackBehaviour Popref_popi_popr8;
    public static StackBehaviour Popref_popi_popref;
    public static StackBehaviour PopAll;
    public static StackBehaviour Push0;
    public static StackBehaviour Push1;
    public static StackBehaviour Push1_push1;
    public static StackBehaviour Pushi;
    public static StackBehaviour Pushi8;
    public static StackBehaviour Pushr4;
    public static StackBehaviour Pushr8;
    public static StackBehaviour Pushref;
    public static StackBehaviour Varpop;
    public static StackBehaviour Varpush;
}
internal static class Mono.Cecil.Cil.SymbolProvider : object {
    private static string symbol_kind;
    private static ISymbolReaderProvider reader_provider;
    private static ISymbolWriterProvider writer_provider;
    private static SymbolProvider();
    private static AssemblyName GetPlatformSymbolAssemblyName();
    private static Type GetPlatformType(string fullname);
    public static ISymbolReaderProvider GetPlatformReaderProvider();
    private static string GetProviderTypeName(string name);
    public static ISymbolWriterProvider GetPlatformWriterProvider();
}
internal class Mono.Cecil.Cil.VariableDefinition : VariableReference {
    public bool IsPinned { get; }
    public VariableDefinition(TypeReference variableType);
    public VariableDefinition(string name, TypeReference variableType);
    public bool get_IsPinned();
    public virtual VariableDefinition Resolve();
}
internal class Mono.Cecil.Cil.VariableDefinitionCollection : Collection`1<VariableDefinition> {
    internal VariableDefinitionCollection(int capacity);
    protected virtual void OnAdd(VariableDefinition item, int index);
    protected virtual void OnInsert(VariableDefinition item, int index);
    protected virtual void OnSet(VariableDefinition item, int index);
    protected virtual void OnRemove(VariableDefinition item, int index);
}
internal abstract class Mono.Cecil.Cil.VariableReference : object {
    private string name;
    internal int index;
    protected TypeReference variable_type;
    public string Name { get; public set; }
    public TypeReference VariableType { get; public set; }
    public int Index { get; }
    internal VariableReference(TypeReference variable_type);
    internal VariableReference(string name, TypeReference variable_type);
    public string get_Name();
    public void set_Name(string value);
    public TypeReference get_VariableType();
    public void set_VariableType(TypeReference value);
    public int get_Index();
    public abstract virtual VariableDefinition Resolve();
    public virtual string ToString();
}
internal class Mono.Cecil.ClassLayoutTable : SortedTable`1<Row`3<ushort, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<ushort, UInt32, UInt32> x, Row`3<ushort, UInt32, UInt32> y);
}
internal class Mono.Cecil.ConstantTable : SortedTable`1<Row`3<ElementType, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<ElementType, UInt32, UInt32> x, Row`3<ElementType, UInt32, UInt32> y);
}
internal static class Mono.Cecil.CryptoService : object {
    public static void StrongName(Stream stream, ImageWriter writer, StrongNameKeyPair key_pair);
    private static void PatchStrongName(Stream stream, int strong_name_pointer, Byte[] strong_name);
    private static Byte[] CreateStrongName(StrongNameKeyPair key_pair, Byte[] hash);
    private static Byte[] HashStream(Stream stream, ImageWriter writer, Int32& strong_name_pointer);
    private static void CopyStreamChunk(Stream stream, Stream dest_stream, Byte[] buffer, int length);
    public static Byte[] ComputeHash(string file);
}
internal class Mono.Cecil.CustomAttribute : object {
    internal UInt32 signature;
    internal bool resolved;
    private MethodReference constructor;
    private Byte[] blob;
    internal Collection`1<CustomAttributeArgument> arguments;
    internal Collection`1<CustomAttributeNamedArgument> fields;
    internal Collection`1<CustomAttributeNamedArgument> properties;
    public MethodReference Constructor { get; public set; }
    public TypeReference AttributeType { get; }
    public bool IsResolved { get; }
    public bool HasConstructorArguments { get; }
    public Collection`1<CustomAttributeArgument> ConstructorArguments { get; }
    public bool HasFields { get; }
    public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    public bool HasProperties { get; }
    public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    internal bool HasImage { get; }
    internal ModuleDefinition Module { get; }
    internal CustomAttribute(UInt32 signature, MethodReference constructor);
    public CustomAttribute(MethodReference constructor);
    public CustomAttribute(MethodReference constructor, Byte[] blob);
    public MethodReference get_Constructor();
    public void set_Constructor(MethodReference value);
    public sealed virtual TypeReference get_AttributeType();
    public bool get_IsResolved();
    public bool get_HasConstructorArguments();
    public Collection`1<CustomAttributeArgument> get_ConstructorArguments();
    public sealed virtual bool get_HasFields();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public sealed virtual bool get_HasProperties();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
    internal bool get_HasImage();
    internal ModuleDefinition get_Module();
    public Byte[] GetBlob();
    private void Resolve();
    [CompilerGeneratedAttribute]
private CustomAttribute <Resolve>b__34_0(CustomAttribute attribute, MetadataReader reader);
}
internal class Mono.Cecil.CustomAttributeArgument : ValueType {
    private TypeReference type;
    private object value;
    public TypeReference Type { get; }
    public object Value { get; }
    public CustomAttributeArgument(TypeReference type, object value);
    public TypeReference get_Type();
    public object get_Value();
}
internal class Mono.Cecil.CustomAttributeNamedArgument : ValueType {
    private string name;
    private CustomAttributeArgument argument;
    public string Name { get; }
    public CustomAttributeArgument Argument { get; }
    public CustomAttributeNamedArgument(string name, CustomAttributeArgument argument);
    public string get_Name();
    public CustomAttributeArgument get_Argument();
}
internal class Mono.Cecil.CustomAttributeTable : SortedTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y);
}
internal class Mono.Cecil.CustomMarshalInfo : MarshalInfo {
    internal Guid guid;
    internal string unmanaged_type;
    internal TypeReference managed_type;
    internal string cookie;
    public Guid Guid { get; public set; }
    public string UnmanagedType { get; public set; }
    public TypeReference ManagedType { get; public set; }
    public string Cookie { get; public set; }
    public Guid get_Guid();
    public void set_Guid(Guid value);
    public string get_UnmanagedType();
    public void set_UnmanagedType(string value);
    public TypeReference get_ManagedType();
    public void set_ManagedType(TypeReference value);
    public string get_Cookie();
    public void set_Cookie(string value);
}
internal class Mono.Cecil.DeclSecurityTable : SortedTable`1<Row`3<SecurityAction, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<SecurityAction, UInt32, UInt32> x, Row`3<SecurityAction, UInt32, UInt32> y);
}
internal class Mono.Cecil.DefaultAssemblyResolver : BaseAssemblyResolver {
    private IDictionary`2<string, AssemblyDefinition> cache;
    public virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    protected void RegisterAssembly(AssemblyDefinition assembly);
}
internal class Mono.Cecil.DeferredModuleReader : ModuleReader {
    public DeferredModuleReader(Image image);
    protected virtual void ReadModule();
    [CompilerGeneratedAttribute]
private ModuleDefinition <ReadModule>b__1_0(ModuleDefinition module, MetadataReader reader);
}
internal class Mono.Cecil.EmbeddedResource : Resource {
    private MetadataReader reader;
    private Nullable`1<UInt32> offset;
    private Byte[] data;
    private Stream stream;
    public ResourceType ResourceType { get; }
    public EmbeddedResource(string name, ManifestResourceAttributes attributes, Byte[] data);
    public EmbeddedResource(string name, ManifestResourceAttributes attributes, Stream stream);
    internal EmbeddedResource(string name, ManifestResourceAttributes attributes, UInt32 offset, MetadataReader reader);
    public virtual ResourceType get_ResourceType();
    public Stream GetResourceStream();
    public Byte[] GetResourceData();
    private static Byte[] ReadStream(Stream stream);
}
[FlagsAttribute]
internal enum Mono.Cecil.EventAttributes : Enum {
    public ushort value__;
    public static EventAttributes None;
    public static EventAttributes SpecialName;
    public static EventAttributes RTSpecialName;
}
internal class Mono.Cecil.EventDefinition : EventReference {
    private ushort attributes;
    private Collection`1<CustomAttribute> custom_attributes;
    internal MethodDefinition add_method;
    internal MethodDefinition invoke_method;
    internal MethodDefinition remove_method;
    internal Collection`1<MethodDefinition> other_methods;
    public EventAttributes Attributes { get; public set; }
    public MethodDefinition AddMethod { get; public set; }
    public MethodDefinition InvokeMethod { get; public set; }
    public MethodDefinition RemoveMethod { get; public set; }
    public bool HasOtherMethods { get; }
    public Collection`1<MethodDefinition> OtherMethods { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool IsSpecialName { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public bool IsDefinition { get; }
    public EventDefinition(string name, EventAttributes attributes, TypeReference eventType);
    public EventAttributes get_Attributes();
    public void set_Attributes(EventAttributes value);
    public MethodDefinition get_AddMethod();
    public void set_AddMethod(MethodDefinition value);
    public MethodDefinition get_InvokeMethod();
    public void set_InvokeMethod(MethodDefinition value);
    public MethodDefinition get_RemoveMethod();
    public void set_RemoveMethod(MethodDefinition value);
    public bool get_HasOtherMethods();
    public Collection`1<MethodDefinition> get_OtherMethods();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual bool get_IsDefinition();
    private void InitializeMethods();
    public virtual EventDefinition Resolve();
}
internal class Mono.Cecil.EventMapTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal abstract class Mono.Cecil.EventReference : MemberReference {
    private TypeReference event_type;
    public TypeReference EventType { get; public set; }
    public string FullName { get; }
    protected EventReference(string name, TypeReference eventType);
    public TypeReference get_EventType();
    public void set_EventType(TypeReference value);
    public virtual string get_FullName();
    public abstract virtual EventDefinition Resolve();
}
internal class Mono.Cecil.EventTable : MetadataTable`1<Row`3<EventAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.ExportedType : object {
    private string namespace;
    private string name;
    private UInt32 attributes;
    private IMetadataScope scope;
    private ModuleDefinition module;
    private int identifier;
    private ExportedType declaring_type;
    internal MetadataToken token;
    public string Namespace { get; public set; }
    public string Name { get; public set; }
    public TypeAttributes Attributes { get; public set; }
    public IMetadataScope Scope { get; }
    public ExportedType DeclaringType { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    public int Identifier { get; public set; }
    public bool IsNotPublic { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsNestedPublic { get; public set; }
    public bool IsNestedPrivate { get; public set; }
    public bool IsNestedFamily { get; public set; }
    public bool IsNestedAssembly { get; public set; }
    public bool IsNestedFamilyAndAssembly { get; public set; }
    public bool IsNestedFamilyOrAssembly { get; public set; }
    public bool IsAutoLayout { get; public set; }
    public bool IsSequentialLayout { get; public set; }
    public bool IsExplicitLayout { get; public set; }
    public bool IsClass { get; public set; }
    public bool IsInterface { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsSealed { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsImport { get; public set; }
    public bool IsSerializable { get; public set; }
    public bool IsAnsiClass { get; public set; }
    public bool IsUnicodeClass { get; public set; }
    public bool IsAutoClass { get; public set; }
    public bool IsBeforeFieldInit { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasSecurity { get; public set; }
    public bool IsForwarder { get; public set; }
    public string FullName { get; }
    public ExportedType(string namespace, string name, ModuleDefinition module, IMetadataScope scope);
    public string get_Namespace();
    public void set_Namespace(string value);
    public string get_Name();
    public void set_Name(string value);
    public TypeAttributes get_Attributes();
    public void set_Attributes(TypeAttributes value);
    public IMetadataScope get_Scope();
    public ExportedType get_DeclaringType();
    public void set_DeclaringType(ExportedType value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public int get_Identifier();
    public void set_Identifier(int value);
    public bool get_IsNotPublic();
    public void set_IsNotPublic(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsNestedPublic();
    public void set_IsNestedPublic(bool value);
    public bool get_IsNestedPrivate();
    public void set_IsNestedPrivate(bool value);
    public bool get_IsNestedFamily();
    public void set_IsNestedFamily(bool value);
    public bool get_IsNestedAssembly();
    public void set_IsNestedAssembly(bool value);
    public bool get_IsNestedFamilyAndAssembly();
    public void set_IsNestedFamilyAndAssembly(bool value);
    public bool get_IsNestedFamilyOrAssembly();
    public void set_IsNestedFamilyOrAssembly(bool value);
    public bool get_IsAutoLayout();
    public void set_IsAutoLayout(bool value);
    public bool get_IsSequentialLayout();
    public void set_IsSequentialLayout(bool value);
    public bool get_IsExplicitLayout();
    public void set_IsExplicitLayout(bool value);
    public bool get_IsClass();
    public void set_IsClass(bool value);
    public bool get_IsInterface();
    public void set_IsInterface(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public bool get_IsSealed();
    public void set_IsSealed(bool value);
    public bool get_IsSpecialName();
    public void set_IsSpecialName(bool value);
    public bool get_IsImport();
    public void set_IsImport(bool value);
    public bool get_IsSerializable();
    public void set_IsSerializable(bool value);
    public bool get_IsAnsiClass();
    public void set_IsAnsiClass(bool value);
    public bool get_IsUnicodeClass();
    public void set_IsUnicodeClass(bool value);
    public bool get_IsAutoClass();
    public void set_IsAutoClass(bool value);
    public bool get_IsBeforeFieldInit();
    public void set_IsBeforeFieldInit(bool value);
    public bool get_IsRuntimeSpecialName();
    public void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsForwarder();
    public void set_IsForwarder(bool value);
    public string get_FullName();
    public virtual string ToString();
    public TypeDefinition Resolve();
    internal TypeReference CreateReference();
}
internal class Mono.Cecil.ExportedTypeTable : MetadataTable`1<Row`5<TypeAttributes, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
[FlagsAttribute]
internal enum Mono.Cecil.FieldAttributes : Enum {
    public ushort value__;
    public static FieldAttributes FieldAccessMask;
    public static FieldAttributes CompilerControlled;
    public static FieldAttributes Private;
    public static FieldAttributes FamANDAssem;
    public static FieldAttributes Assembly;
    public static FieldAttributes Family;
    public static FieldAttributes FamORAssem;
    public static FieldAttributes Public;
    public static FieldAttributes Static;
    public static FieldAttributes InitOnly;
    public static FieldAttributes Literal;
    public static FieldAttributes NotSerialized;
    public static FieldAttributes SpecialName;
    public static FieldAttributes PInvokeImpl;
    public static FieldAttributes RTSpecialName;
    public static FieldAttributes HasFieldMarshal;
    public static FieldAttributes HasDefault;
    public static FieldAttributes HasFieldRVA;
}
internal class Mono.Cecil.FieldDefinition : FieldReference {
    private ushort attributes;
    private Collection`1<CustomAttribute> custom_attributes;
    private int offset;
    internal int rva;
    private Byte[] initial_value;
    private object constant;
    private MarshalInfo marshal_info;
    public bool HasLayoutInfo { get; }
    public int Offset { get; public set; }
    public int RVA { get; }
    public Byte[] InitialValue { get; public set; }
    public FieldAttributes Attributes { get; public set; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasMarshalInfo { get; }
    public MarshalInfo MarshalInfo { get; public set; }
    public bool IsCompilerControlled { get; public set; }
    public bool IsPrivate { get; public set; }
    public bool IsFamilyAndAssembly { get; public set; }
    public bool IsAssembly { get; public set; }
    public bool IsFamily { get; public set; }
    public bool IsFamilyOrAssembly { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsInitOnly { get; public set; }
    public bool IsLiteral { get; public set; }
    public bool IsNotSerialized { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsPInvokeImpl { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasDefault { get; public set; }
    public bool IsDefinition { get; }
    public TypeDefinition DeclaringType { get; public set; }
    public FieldDefinition(string name, FieldAttributes attributes, TypeReference fieldType);
    private void ResolveLayout();
    public bool get_HasLayoutInfo();
    public int get_Offset();
    public void set_Offset(int value);
    private void ResolveRVA();
    public int get_RVA();
    public Byte[] get_InitialValue();
    public void set_InitialValue(Byte[] value);
    public FieldAttributes get_Attributes();
    public void set_Attributes(FieldAttributes value);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_HasMarshalInfo();
    public sealed virtual MarshalInfo get_MarshalInfo();
    public sealed virtual void set_MarshalInfo(MarshalInfo value);
    public bool get_IsCompilerControlled();
    public void set_IsCompilerControlled(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
    public bool get_IsFamilyAndAssembly();
    public void set_IsFamilyAndAssembly(bool value);
    public bool get_IsAssembly();
    public void set_IsAssembly(bool value);
    public bool get_IsFamily();
    public void set_IsFamily(bool value);
    public bool get_IsFamilyOrAssembly();
    public void set_IsFamilyOrAssembly(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsStatic();
    public void set_IsStatic(bool value);
    public bool get_IsInitOnly();
    public void set_IsInitOnly(bool value);
    public bool get_IsLiteral();
    public void set_IsLiteral(bool value);
    public bool get_IsNotSerialized();
    public void set_IsNotSerialized(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsPInvokeImpl();
    public void set_IsPInvokeImpl(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public virtual bool get_IsDefinition();
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual FieldDefinition Resolve();
}
internal class Mono.Cecil.FieldLayoutTable : SortedTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal class Mono.Cecil.FieldMarshalTable : SortedTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal class Mono.Cecil.FieldReference : MemberReference {
    private TypeReference field_type;
    public TypeReference FieldType { get; public set; }
    public string FullName { get; }
    public bool ContainsGenericParameter { get; }
    public FieldReference(string name, TypeReference fieldType);
    public FieldReference(string name, TypeReference fieldType, TypeReference declaringType);
    public TypeReference get_FieldType();
    public void set_FieldType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_ContainsGenericParameter();
    public virtual FieldDefinition Resolve();
}
internal class Mono.Cecil.FieldRVATable : SortedTable`1<Row`2<UInt32, UInt32>> {
    internal int position;
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal class Mono.Cecil.FieldTable : MetadataTable`1<Row`3<FieldAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal enum Mono.Cecil.FileAttributes : Enum {
    public UInt32 value__;
    public static FileAttributes ContainsMetaData;
    public static FileAttributes ContainsNoMetaData;
}
internal class Mono.Cecil.FileTable : MetadataTable`1<Row`3<FileAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.FixedArrayMarshalInfo : MarshalInfo {
    internal NativeType element_type;
    internal int size;
    public NativeType ElementType { get; public set; }
    public int Size { get; public set; }
    public NativeType get_ElementType();
    public void set_ElementType(NativeType value);
    public int get_Size();
    public void set_Size(int value);
}
internal class Mono.Cecil.FixedSysStringMarshalInfo : MarshalInfo {
    internal int size;
    public int Size { get; public set; }
    public int get_Size();
    public void set_Size(int value);
}
internal class Mono.Cecil.FunctionPointerType : TypeSpecification {
    private MethodReference function;
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public ModuleDefinition Module { get; }
    public IMetadataScope Scope { get; public set; }
    public bool IsFunctionPointer { get; }
    public bool ContainsGenericParameter { get; }
    public string FullName { get; }
    public sealed virtual bool get_HasThis();
    public sealed virtual void set_HasThis(bool value);
    public sealed virtual bool get_ExplicitThis();
    public sealed virtual void set_ExplicitThis(bool value);
    public sealed virtual MethodCallingConvention get_CallingConvention();
    public sealed virtual void set_CallingConvention(MethodCallingConvention value);
    public sealed virtual bool get_HasParameters();
    public sealed virtual Collection`1<ParameterDefinition> get_Parameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public sealed virtual MethodReturnType get_MethodReturnType();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual ModuleDefinition get_Module();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual bool get_IsFunctionPointer();
    public virtual bool get_ContainsGenericParameter();
    public virtual string get_FullName();
    public virtual TypeDefinition Resolve();
    public virtual TypeReference GetElementType();
}
internal class Mono.Cecil.GenericInstanceMethod : MethodSpecification {
    private Collection`1<TypeReference> arguments;
    public bool HasGenericArguments { get; }
    public Collection`1<TypeReference> GenericArguments { get; }
    public bool IsGenericInstance { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Method { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    public bool ContainsGenericParameter { get; }
    public string FullName { get; }
    public GenericInstanceMethod(MethodReference method);
    public sealed virtual bool get_HasGenericArguments();
    public sealed virtual Collection`1<TypeReference> get_GenericArguments();
    public virtual bool get_IsGenericInstance();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
    public virtual bool get_ContainsGenericParameter();
    public virtual string get_FullName();
}
internal class Mono.Cecil.GenericInstanceType : TypeSpecification {
    private Collection`1<TypeReference> arguments;
    public bool HasGenericArguments { get; }
    public Collection`1<TypeReference> GenericArguments { get; }
    public TypeReference DeclaringType { get; public set; }
    public string FullName { get; }
    public bool IsGenericInstance { get; }
    public bool ContainsGenericParameter { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    public GenericInstanceType(TypeReference type);
    public sealed virtual bool get_HasGenericArguments();
    public sealed virtual Collection`1<TypeReference> get_GenericArguments();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_ContainsGenericParameter();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
}
internal class Mono.Cecil.GenericParamConstraintTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.GenericParameter : TypeReference {
    internal int position;
    internal GenericParameterType type;
    internal IGenericParameterProvider owner;
    private ushort attributes;
    private Collection`1<TypeReference> constraints;
    private Collection`1<CustomAttribute> custom_attributes;
    public GenericParameterAttributes Attributes { get; public set; }
    public int Position { get; }
    public GenericParameterType Type { get; }
    public IGenericParameterProvider Owner { get; }
    public bool HasConstraints { get; }
    public Collection`1<TypeReference> Constraints { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public IMetadataScope Scope { get; public set; }
    public TypeReference DeclaringType { get; public set; }
    public MethodReference DeclaringMethod { get; }
    public ModuleDefinition Module { get; }
    public string Name { get; }
    public string Namespace { get; public set; }
    public string FullName { get; }
    public bool IsGenericParameter { get; }
    public bool ContainsGenericParameter { get; }
    public MetadataType MetadataType { get; }
    public bool IsNonVariant { get; public set; }
    public bool IsCovariant { get; public set; }
    public bool IsContravariant { get; public set; }
    public bool HasReferenceTypeConstraint { get; public set; }
    public bool HasNotNullableValueTypeConstraint { get; public set; }
    public bool HasDefaultConstructorConstraint { get; public set; }
    public GenericParameter(IGenericParameterProvider owner);
    public GenericParameter(string name, IGenericParameterProvider owner);
    internal GenericParameter(int position, GenericParameterType type, ModuleDefinition module);
    public GenericParameterAttributes get_Attributes();
    public void set_Attributes(GenericParameterAttributes value);
    public int get_Position();
    public GenericParameterType get_Type();
    public IGenericParameterProvider get_Owner();
    public bool get_HasConstraints();
    public Collection`1<TypeReference> get_Constraints();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public MethodReference get_DeclaringMethod();
    public virtual ModuleDefinition get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_ContainsGenericParameter();
    public virtual MetadataType get_MetadataType();
    public bool get_IsNonVariant();
    public void set_IsNonVariant(bool value);
    public bool get_IsCovariant();
    public void set_IsCovariant(bool value);
    public bool get_IsContravariant();
    public void set_IsContravariant(bool value);
    public bool get_HasReferenceTypeConstraint();
    public void set_HasReferenceTypeConstraint(bool value);
    public bool get_HasNotNullableValueTypeConstraint();
    public void set_HasNotNullableValueTypeConstraint(bool value);
    public bool get_HasDefaultConstructorConstraint();
    public void set_HasDefaultConstructorConstraint(bool value);
    private static ElementType ConvertGenericParameterType(GenericParameterType type);
    public virtual TypeDefinition Resolve();
}
[FlagsAttribute]
internal enum Mono.Cecil.GenericParameterAttributes : Enum {
    public ushort value__;
    public static GenericParameterAttributes VarianceMask;
    public static GenericParameterAttributes NonVariant;
    public static GenericParameterAttributes Covariant;
    public static GenericParameterAttributes Contravariant;
    public static GenericParameterAttributes SpecialConstraintMask;
    public static GenericParameterAttributes ReferenceTypeConstraint;
    public static GenericParameterAttributes NotNullableValueTypeConstraint;
    public static GenericParameterAttributes DefaultConstructorConstraint;
}
internal class Mono.Cecil.GenericParameterCollection : Collection`1<GenericParameter> {
    private IGenericParameterProvider owner;
    internal GenericParameterCollection(IGenericParameterProvider owner);
    internal GenericParameterCollection(IGenericParameterProvider owner, int capacity);
    protected virtual void OnAdd(GenericParameter item, int index);
    protected virtual void OnInsert(GenericParameter item, int index);
    protected virtual void OnSet(GenericParameter item, int index);
    private void UpdateGenericParameter(GenericParameter item, int index);
    protected virtual void OnRemove(GenericParameter item, int index);
}
internal enum Mono.Cecil.GenericParameterType : Enum {
    public int value__;
    public static GenericParameterType Type;
    public static GenericParameterType Method;
}
internal class Mono.Cecil.GenericParamTable : MetadataTable`1<Row`4<ushort, GenericParameterAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal interface Mono.Cecil.IAssemblyResolver {
    public abstract virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    public abstract virtual AssemblyDefinition Resolve(AssemblyNameReference name, ReaderParameters parameters);
    public abstract virtual AssemblyDefinition Resolve(string fullName);
    public abstract virtual AssemblyDefinition Resolve(string fullName, ReaderParameters parameters);
}
internal interface Mono.Cecil.IConstantProvider {
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public abstract virtual bool get_HasConstant();
    public abstract virtual void set_HasConstant(bool value);
    public abstract virtual object get_Constant();
    public abstract virtual void set_Constant(object value);
}
internal interface Mono.Cecil.ICustomAttribute {
    public TypeReference AttributeType { get; }
    public bool HasFields { get; }
    public bool HasProperties { get; }
    public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    public abstract virtual TypeReference get_AttributeType();
    public abstract virtual bool get_HasFields();
    public abstract virtual bool get_HasProperties();
    public abstract virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public abstract virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
}
internal interface Mono.Cecil.ICustomAttributeProvider {
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasCustomAttributes { get; }
    public abstract virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public abstract virtual bool get_HasCustomAttributes();
}
internal interface Mono.Cecil.IGenericContext {
    public bool IsDefinition { get; }
    public IGenericParameterProvider Type { get; }
    public IGenericParameterProvider Method { get; }
    public abstract virtual bool get_IsDefinition();
    public abstract virtual IGenericParameterProvider get_Type();
    public abstract virtual IGenericParameterProvider get_Method();
}
internal interface Mono.Cecil.IGenericInstance {
    public bool HasGenericArguments { get; }
    public Collection`1<TypeReference> GenericArguments { get; }
    public abstract virtual bool get_HasGenericArguments();
    public abstract virtual Collection`1<TypeReference> get_GenericArguments();
}
internal interface Mono.Cecil.IGenericParameterProvider {
    public bool HasGenericParameters { get; }
    public bool IsDefinition { get; }
    public ModuleDefinition Module { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public GenericParameterType GenericParameterType { get; }
    public abstract virtual bool get_HasGenericParameters();
    public abstract virtual bool get_IsDefinition();
    public abstract virtual ModuleDefinition get_Module();
    public abstract virtual Collection`1<GenericParameter> get_GenericParameters();
    public abstract virtual GenericParameterType get_GenericParameterType();
}
internal interface Mono.Cecil.IMarshalInfoProvider {
    public bool HasMarshalInfo { get; }
    public MarshalInfo MarshalInfo { get; public set; }
    public abstract virtual bool get_HasMarshalInfo();
    public abstract virtual MarshalInfo get_MarshalInfo();
    public abstract virtual void set_MarshalInfo(MarshalInfo value);
}
internal interface Mono.Cecil.IMemberDefinition {
    public string Name { get; public set; }
    public string FullName { get; }
    public bool IsSpecialName { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
    public abstract virtual string get_FullName();
    public abstract virtual bool get_IsSpecialName();
    public abstract virtual void set_IsSpecialName(bool value);
    public abstract virtual bool get_IsRuntimeSpecialName();
    public abstract virtual void set_IsRuntimeSpecialName(bool value);
    public abstract virtual TypeDefinition get_DeclaringType();
    public abstract virtual void set_DeclaringType(TypeDefinition value);
}
internal interface Mono.Cecil.IMetadataImporter {
    public abstract virtual TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);
    public abstract virtual FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);
    public abstract virtual MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
}
internal interface Mono.Cecil.IMetadataImporterProvider {
    public abstract virtual IMetadataImporter GetMetadataImporter(ModuleDefinition module);
}
internal interface Mono.Cecil.IMetadataResolver {
    public abstract virtual TypeDefinition Resolve(TypeReference type);
    public abstract virtual FieldDefinition Resolve(FieldReference field);
    public abstract virtual MethodDefinition Resolve(MethodReference method);
}
internal interface Mono.Cecil.IMetadataScope {
    public MetadataScopeType MetadataScopeType { get; }
    public string Name { get; public set; }
    public abstract virtual MetadataScopeType get_MetadataScopeType();
    public abstract virtual string get_Name();
    public abstract virtual void set_Name(string value);
}
internal interface Mono.Cecil.IMetadataTokenProvider {
    public MetadataToken MetadataToken { get; public set; }
    public abstract virtual MetadataToken get_MetadataToken();
    public abstract virtual void set_MetadataToken(MetadataToken value);
}
internal interface Mono.Cecil.IMethodSignature {
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; }
    public abstract virtual bool get_HasThis();
    public abstract virtual void set_HasThis(bool value);
    public abstract virtual bool get_ExplicitThis();
    public abstract virtual void set_ExplicitThis(bool value);
    public abstract virtual MethodCallingConvention get_CallingConvention();
    public abstract virtual void set_CallingConvention(MethodCallingConvention value);
    public abstract virtual bool get_HasParameters();
    public abstract virtual Collection`1<ParameterDefinition> get_Parameters();
    public abstract virtual TypeReference get_ReturnType();
    public abstract virtual void set_ReturnType(TypeReference value);
    public abstract virtual MethodReturnType get_MethodReturnType();
}
internal class Mono.Cecil.ImmediateModuleReader : ModuleReader {
    public ImmediateModuleReader(Image image);
    protected virtual void ReadModule();
    public static void ReadModule(ModuleDefinition module);
    private static void ReadTypes(Collection`1<TypeDefinition> types);
    private static void ReadType(TypeDefinition type);
    private static void ReadGenericParameters(IGenericParameterProvider provider);
    private static void ReadSecurityDeclarations(ISecurityDeclarationProvider provider);
    private static void ReadCustomAttributes(ICustomAttributeProvider provider);
    private static void ReadFields(TypeDefinition type);
    private static void ReadMethods(TypeDefinition type);
    private static void ReadParameters(MethodDefinition method);
    private static void ReadProperties(TypeDefinition type);
    private static void ReadEvents(TypeDefinition type);
    private static void Read(object collection);
    [CompilerGeneratedAttribute]
private ModuleDefinition <ReadModule>b__1_0(ModuleDefinition module, MetadataReader reader);
}
internal interface Mono.Cecil.IModifierType {
    public TypeReference ModifierType { get; }
    public TypeReference ElementType { get; }
    public abstract virtual TypeReference get_ModifierType();
    public abstract virtual TypeReference get_ElementType();
}
internal class Mono.Cecil.ImplMapTable : SortedTable`1<Row`4<PInvokeAttributes, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`4<PInvokeAttributes, UInt32, UInt32, UInt32> x, Row`4<PInvokeAttributes, UInt32, UInt32, UInt32> y);
}
internal class Mono.Cecil.ImportGenericContext : ValueType {
    private Collection`1<IGenericParameterProvider> stack;
    public bool IsEmpty { get; }
    public ImportGenericContext(IGenericParameterProvider provider);
    public bool get_IsEmpty();
    public void Push(IGenericParameterProvider provider);
    public void Pop();
    public TypeReference MethodParameter(string declTypeFullName, string method, int position);
    public TypeReference TypeParameter(string type, int position);
    private static TypeReference GenericTypeFor(IGenericParameterProvider context);
    public static ImportGenericContext For(IGenericParameterProvider context);
}
internal class Mono.Cecil.InterfaceImplTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal interface Mono.Cecil.IReflectionImporter {
    public abstract virtual TypeReference ImportReference(Type type, IGenericParameterProvider context);
    public abstract virtual FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);
    public abstract virtual MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
}
internal interface Mono.Cecil.IReflectionImporterProvider {
    public abstract virtual IReflectionImporter GetReflectionImporter(ModuleDefinition module);
}
internal interface Mono.Cecil.ISecurityDeclarationProvider {
    public bool HasSecurityDeclarations { get; }
    public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public abstract virtual bool get_HasSecurityDeclarations();
    public abstract virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
}
internal class Mono.Cecil.LinkedResource : Resource {
    internal Byte[] hash;
    private string file;
    public Byte[] Hash { get; }
    public string File { get; public set; }
    public ResourceType ResourceType { get; }
    public LinkedResource(string name, ManifestResourceAttributes flags);
    public LinkedResource(string name, ManifestResourceAttributes flags, string file);
    public Byte[] get_Hash();
    public string get_File();
    public void set_File(string value);
    public virtual ResourceType get_ResourceType();
}
[FlagsAttribute]
internal enum Mono.Cecil.ManifestResourceAttributes : Enum {
    public UInt32 value__;
    public static ManifestResourceAttributes VisibilityMask;
    public static ManifestResourceAttributes Public;
    public static ManifestResourceAttributes Private;
}
internal class Mono.Cecil.ManifestResourceTable : MetadataTable`1<Row`4<UInt32, ManifestResourceAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.MarshalInfo : object {
    internal NativeType native;
    public NativeType NativeType { get; public set; }
    public MarshalInfo(NativeType native);
    public NativeType get_NativeType();
    public void set_NativeType(NativeType value);
}
internal class Mono.Cecil.Mdb.MdbReader : object {
    private ModuleDefinition module;
    private MonoSymbolFile symbol_file;
    private Dictionary`2<string, Document> documents;
    public MdbReader(ModuleDefinition module, MonoSymbolFile symFile);
    public sealed virtual bool ProcessDebugHeader(ImageDebugDirectory directory, Byte[] header);
    public sealed virtual void Read(MethodBody body, InstructionMapper mapper);
    private static void ReadLocalVariables(MethodEntry entry, MethodBody body, Scope[] scopes);
    private void ReadLineNumbers(MethodEntry entry, InstructionMapper mapper);
    private Document GetDocument(SourceFileEntry file);
    private static Scope[] ReadScopes(MethodEntry entry, MethodBody body, InstructionMapper mapper);
    private static bool AddScope(Scope provider, Scope scope);
    public sealed virtual void Read(MethodSymbols symbols);
    private void ReadLineNumbers(MethodEntry entry, MethodSymbols symbols);
    private static void ReadLocalVariables(MethodEntry entry, MethodSymbols symbols);
    private static SequencePoint LineToSequencePoint(LineNumberEntry line, MethodEntry entry, Document document);
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Mdb.MdbReaderProvider : object {
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Mdb.MdbWriter : object {
    private Guid mvid;
    private MonoSymbolWriter writer;
    private Dictionary`2<string, SourceFile> source_files;
    private static Byte[] empty_header;
    public MdbWriter(Guid mvid, string assembly);
    private static MdbWriter();
    private static Collection`1<Instruction> GetInstructions(MethodBody body);
    private SourceFile GetSourceFile(Document document);
    private void Populate(Collection`1<Instruction> instructions, Int32[] offsets, Int32[] startRows, Int32[] endRows, Int32[] startCols, Int32[] endCols, SourceFile& file);
    public sealed virtual void Write(MethodBody body);
    private void WriteScope(Scope scope, bool root);
    public sealed virtual bool GetDebugHeader(ImageDebugDirectory& directory, Byte[]& header);
    private void AddVariables(IList`1<VariableDefinition> variables);
    public sealed virtual void Write(MethodSymbols symbols);
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Mdb.MdbWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Mdb.MethodEntryExtensions : object {
    [ExtensionAttribute]
public static bool HasColumnInfo(MethodEntry entry);
    [ExtensionAttribute]
public static bool HasEndInfo(MethodEntry entry);
}
internal class Mono.Cecil.MemberDefinitionCollection`1 : Collection`1<T> {
    private TypeDefinition container;
    internal MemberDefinitionCollection`1(TypeDefinition container);
    internal MemberDefinitionCollection`1(TypeDefinition container, int capacity);
    protected virtual void OnAdd(T item, int index);
    protected sealed virtual void OnSet(T item, int index);
    protected sealed virtual void OnInsert(T item, int index);
    protected sealed virtual void OnRemove(T item, int index);
    protected sealed virtual void OnClear();
    private void Attach(T element);
    private static void Detach(T element);
}
internal abstract class Mono.Cecil.MemberReference : object {
    private string name;
    private TypeReference declaring_type;
    internal MetadataToken token;
    public string Name { get; public set; }
    public string FullName { get; }
    public TypeReference DeclaringType { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    internal bool HasImage { get; }
    public ModuleDefinition Module { get; }
    public bool IsDefinition { get; }
    public bool ContainsGenericParameter { get; }
    internal MemberReference(string name);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public abstract virtual string get_FullName();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    internal bool get_HasImage();
    public virtual ModuleDefinition get_Module();
    public virtual bool get_IsDefinition();
    public virtual bool get_ContainsGenericParameter();
    internal string MemberFullName();
    public virtual string ToString();
}
internal class Mono.Cecil.MemberRefTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.Metadata.BlobHeap : Heap {
    public BlobHeap(Section section, UInt32 start, UInt32 size);
    public Byte[] Read(UInt32 index);
}
internal class Mono.Cecil.Metadata.BlobHeapBuffer : HeapBuffer {
    private Dictionary`2<ByteBuffer, UInt32> blobs;
    public bool IsEmpty { get; }
    public virtual bool get_IsEmpty();
    public UInt32 GetBlobIndex(ByteBuffer blob);
    private void WriteBlob(ByteBuffer blob);
}
internal enum Mono.Cecil.Metadata.CodedIndex : Enum {
    public int value__;
    public static CodedIndex TypeDefOrRef;
    public static CodedIndex HasConstant;
    public static CodedIndex HasCustomAttribute;
    public static CodedIndex HasFieldMarshal;
    public static CodedIndex HasDeclSecurity;
    public static CodedIndex MemberRefParent;
    public static CodedIndex HasSemantics;
    public static CodedIndex MethodDefOrRef;
    public static CodedIndex MemberForwarded;
    public static CodedIndex Implementation;
    public static CodedIndex CustomAttributeType;
    public static CodedIndex ResolutionScope;
    public static CodedIndex TypeOrMethodDef;
}
internal class Mono.Cecil.Metadata.DataBuffer : ByteBuffer {
    public UInt32 AddData(Byte[] data);
}
internal enum Mono.Cecil.Metadata.ElementType : Enum {
    public byte value__;
    public static ElementType None;
    public static ElementType Void;
    public static ElementType Boolean;
    public static ElementType Char;
    public static ElementType I1;
    public static ElementType U1;
    public static ElementType I2;
    public static ElementType U2;
    public static ElementType I4;
    public static ElementType U4;
    public static ElementType I8;
    public static ElementType U8;
    public static ElementType R4;
    public static ElementType R8;
    public static ElementType String;
    public static ElementType Ptr;
    public static ElementType ByRef;
    public static ElementType ValueType;
    public static ElementType Class;
    public static ElementType Var;
    public static ElementType Array;
    public static ElementType GenericInst;
    public static ElementType TypedByRef;
    public static ElementType I;
    public static ElementType U;
    public static ElementType FnPtr;
    public static ElementType Object;
    public static ElementType SzArray;
    public static ElementType MVar;
    public static ElementType CModReqD;
    public static ElementType CModOpt;
    public static ElementType Internal;
    public static ElementType Modifier;
    public static ElementType Sentinel;
    public static ElementType Pinned;
    public static ElementType Type;
    public static ElementType Boxed;
    public static ElementType Enum;
}
internal class Mono.Cecil.Metadata.GuidHeap : Heap {
    public GuidHeap(Section section, UInt32 start, UInt32 size);
    public Guid Read(UInt32 index);
}
internal abstract class Mono.Cecil.Metadata.Heap : object {
    public int IndexSize;
    public Section Section;
    public UInt32 Offset;
    public UInt32 Size;
    protected Heap(Section section, UInt32 offset, UInt32 size);
}
internal abstract class Mono.Cecil.Metadata.HeapBuffer : ByteBuffer {
    public bool IsLarge { get; }
    public bool IsEmpty { get; }
    protected HeapBuffer(int length);
    public bool get_IsLarge();
    public abstract virtual bool get_IsEmpty();
}
internal class Mono.Cecil.Metadata.ResourceBuffer : ByteBuffer {
    public UInt32 AddResource(Byte[] resource);
}
internal class Mono.Cecil.Metadata.Row`2 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    public Row`2(T1 col1, T2 col2);
}
internal class Mono.Cecil.Metadata.Row`3 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    public Row`3(T1 col1, T2 col2, T3 col3);
}
internal class Mono.Cecil.Metadata.Row`4 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    public Row`4(T1 col1, T2 col2, T3 col3, T4 col4);
}
internal class Mono.Cecil.Metadata.Row`5 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    internal T5 Col5;
    public Row`5(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5);
}
internal class Mono.Cecil.Metadata.Row`6 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    internal T5 Col5;
    internal T6 Col6;
    public Row`6(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6);
}
internal class Mono.Cecil.Metadata.Row`9 : ValueType {
    internal T1 Col1;
    internal T2 Col2;
    internal T3 Col3;
    internal T4 Col4;
    internal T5 Col5;
    internal T6 Col6;
    internal T7 Col7;
    internal T8 Col8;
    internal T9 Col9;
    public Row`9(T1 col1, T2 col2, T3 col3, T4 col4, T5 col5, T6 col6, T7 col7, T8 col8, T9 col9);
}
internal class Mono.Cecil.Metadata.RowEqualityComparer : object {
    public sealed virtual bool Equals(Row`2<string, string> x, Row`2<string, string> y);
    public sealed virtual int GetHashCode(Row`2<string, string> obj);
    public sealed virtual bool Equals(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
    public sealed virtual int GetHashCode(Row`2<UInt32, UInt32> obj);
    public sealed virtual bool Equals(Row`3<UInt32, UInt32, UInt32> x, Row`3<UInt32, UInt32, UInt32> y);
    public sealed virtual int GetHashCode(Row`3<UInt32, UInt32, UInt32> obj);
}
internal class Mono.Cecil.Metadata.StringHeap : Heap {
    private Dictionary`2<UInt32, string> strings;
    public StringHeap(Section section, UInt32 start, UInt32 size);
    public string Read(UInt32 index);
    protected virtual string ReadStringAt(UInt32 index);
}
internal class Mono.Cecil.Metadata.StringHeapBuffer : HeapBuffer {
    private Dictionary`2<string, UInt32> strings;
    public bool IsEmpty { get; }
    public sealed virtual bool get_IsEmpty();
    public UInt32 GetStringIndex(string string);
    protected virtual void WriteString(string string);
}
internal enum Mono.Cecil.Metadata.Table : Enum {
    public byte value__;
    public static Table Module;
    public static Table TypeRef;
    public static Table TypeDef;
    public static Table FieldPtr;
    public static Table Field;
    public static Table MethodPtr;
    public static Table Method;
    public static Table ParamPtr;
    public static Table Param;
    public static Table InterfaceImpl;
    public static Table MemberRef;
    public static Table Constant;
    public static Table CustomAttribute;
    public static Table FieldMarshal;
    public static Table DeclSecurity;
    public static Table ClassLayout;
    public static Table FieldLayout;
    public static Table StandAloneSig;
    public static Table EventMap;
    public static Table EventPtr;
    public static Table Event;
    public static Table PropertyMap;
    public static Table PropertyPtr;
    public static Table Property;
    public static Table MethodSemantics;
    public static Table MethodImpl;
    public static Table ModuleRef;
    public static Table TypeSpec;
    public static Table ImplMap;
    public static Table FieldRVA;
    public static Table EncLog;
    public static Table EncMap;
    public static Table Assembly;
    public static Table AssemblyProcessor;
    public static Table AssemblyOS;
    public static Table AssemblyRef;
    public static Table AssemblyRefProcessor;
    public static Table AssemblyRefOS;
    public static Table File;
    public static Table ExportedType;
    public static Table ManifestResource;
    public static Table NestedClass;
    public static Table GenericParam;
    public static Table MethodSpec;
    public static Table GenericParamConstraint;
}
[DefaultMemberAttribute("Item")]
internal class Mono.Cecil.Metadata.TableHeap : Heap {
    public long Valid;
    public long Sorted;
    public static int TableCount;
    public TableInformation[] Tables;
    public TableInformation Item { get; }
    public TableHeap(Section section, UInt32 start, UInt32 size);
    public TableInformation get_Item(Table table);
    public bool HasTable(Table table);
}
internal class Mono.Cecil.Metadata.TableHeapBuffer : HeapBuffer {
    private ModuleDefinition module;
    private MetadataBuilder metadata;
    internal MetadataTable[] tables;
    private bool large_string;
    private bool large_blob;
    private Int32[] coded_index_sizes;
    private Func`2<Table, int> counter;
    public bool IsEmpty { get; }
    public TableHeapBuffer(ModuleDefinition module, MetadataBuilder metadata);
    public virtual bool get_IsEmpty();
    private int GetTableLength(Table table);
    public TTable GetTable(Table table);
    public void WriteBySize(UInt32 value, int size);
    public void WriteBySize(UInt32 value, bool large);
    public void WriteString(UInt32 string);
    public void WriteBlob(UInt32 blob);
    public void WriteRID(UInt32 rid, Table table);
    private int GetCodedIndexSize(CodedIndex coded_index);
    public void WriteCodedRID(UInt32 rid, CodedIndex coded_index);
    public void WriteTableHeap();
    private void WriteRowCount();
    private void WriteTables();
    private ulong GetValid();
    private byte GetHeapSizes();
    private byte GetTableHeapVersion();
    public void FixupData(UInt32 data_rva);
}
internal class Mono.Cecil.Metadata.TableInformation : ValueType {
    public UInt32 Offset;
    public UInt32 Length;
    public UInt32 RowSize;
}
internal class Mono.Cecil.Metadata.UserStringHeap : StringHeap {
    public UserStringHeap(Section section, UInt32 start, UInt32 size);
    protected virtual string ReadStringAt(UInt32 index);
}
internal class Mono.Cecil.Metadata.UserStringHeapBuffer : StringHeapBuffer {
    protected virtual void WriteString(string string);
}
internal class Mono.Cecil.MetadataBuilder : object {
    internal ModuleDefinition module;
    internal ISymbolWriterProvider symbol_writer_provider;
    internal ISymbolWriter symbol_writer;
    internal TextMap text_map;
    internal string fq_name;
    private Dictionary`2<Row`3<UInt32, UInt32, UInt32>, MetadataToken> type_ref_map;
    private Dictionary`2<UInt32, MetadataToken> type_spec_map;
    private Dictionary`2<Row`3<UInt32, UInt32, UInt32>, MetadataToken> member_ref_map;
    private Dictionary`2<Row`2<UInt32, UInt32>, MetadataToken> method_spec_map;
    private Collection`1<GenericParameter> generic_parameters;
    private Dictionary`2<MetadataToken, MetadataToken> method_def_map;
    internal CodeWriter code;
    internal DataBuffer data;
    internal ResourceBuffer resources;
    internal StringHeapBuffer string_heap;
    internal UserStringHeapBuffer user_string_heap;
    internal BlobHeapBuffer blob_heap;
    internal TableHeapBuffer table_heap;
    internal MetadataToken entry_point;
    private UInt32 type_rid;
    private UInt32 field_rid;
    private UInt32 method_rid;
    private UInt32 param_rid;
    private UInt32 property_rid;
    private UInt32 event_rid;
    private TypeRefTable type_ref_table;
    private TypeDefTable type_def_table;
    private FieldTable field_table;
    private MethodTable method_table;
    private ParamTable param_table;
    private InterfaceImplTable iface_impl_table;
    private MemberRefTable member_ref_table;
    private ConstantTable constant_table;
    private CustomAttributeTable custom_attribute_table;
    private DeclSecurityTable declsec_table;
    private StandAloneSigTable standalone_sig_table;
    private EventMapTable event_map_table;
    private EventTable event_table;
    private PropertyMapTable property_map_table;
    private PropertyTable property_table;
    private TypeSpecTable typespec_table;
    private MethodSpecTable method_spec_table;
    internal bool write_symbols;
    public MetadataBuilder(ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider, ISymbolWriter symbol_writer);
    private TextMap CreateTextMap();
    private TTable GetTable(Table table);
    private UInt32 GetStringIndex(string string);
    private UInt32 GetBlobIndex(ByteBuffer blob);
    private UInt32 GetBlobIndex(Byte[] blob);
    public void BuildMetadata();
    private void BuildModule();
    private void BuildAssembly();
    private void BuildModules();
    private string GetModuleFileName(string name);
    private void AddAssemblyReferences();
    private void AddModuleReferences();
    private void AddResources();
    private UInt32 AddLinkedResource(LinkedResource resource);
    private UInt32 AddEmbeddedResource(EmbeddedResource resource);
    private void AddExportedTypes();
    private MetadataToken GetExportedTypeScope(ExportedType exported_type);
    private void BuildTypes();
    private void AttachTokens();
    private void AttachTypeDefToken(TypeDefinition type);
    private void AttachNestedTypesDefToken(TypeDefinition type);
    private void AttachFieldsDefToken(TypeDefinition type);
    private void AttachMethodsDefToken(TypeDefinition type);
    public bool TryGetOriginalMethodToken(MetadataToken new_token, MetadataToken& original);
    private MetadataToken GetTypeToken(TypeReference type);
    private MetadataToken GetTypeSpecToken(TypeReference type);
    private MetadataToken AddTypeSpecification(TypeReference type, UInt32 row);
    private MetadataToken GetTypeRefToken(TypeReference type);
    private Row`3<UInt32, UInt32, UInt32> CreateTypeRefRow(TypeReference type);
    private MetadataToken GetScopeToken(TypeReference type);
    private static UInt32 MakeCodedRID(IMetadataTokenProvider provider, CodedIndex index);
    private static UInt32 MakeCodedRID(MetadataToken token, CodedIndex index);
    private MetadataToken AddTypeReference(TypeReference type, Row`3<UInt32, UInt32, UInt32> row);
    private void AddTypeDefs();
    private void AddType(TypeDefinition type);
    private void AddGenericParameters(IGenericParameterProvider owner);
    private void AddGenericParameters();
    private void AddConstraints(GenericParameter generic_parameter, GenericParamConstraintTable table);
    private void AddInterfaces(TypeDefinition type);
    private void AddLayoutInfo(TypeDefinition type);
    private void AddNestedTypes(TypeDefinition type);
    private void AddFields(TypeDefinition type);
    private void AddField(FieldDefinition field);
    private void AddFieldRVA(FieldDefinition field);
    private void AddFieldLayout(FieldDefinition field);
    private void AddMethods(TypeDefinition type);
    private void AddMethod(MethodDefinition method);
    private void AddParameters(MethodDefinition method);
    private void AddPInvokeInfo(MethodDefinition method);
    private void AddOverrides(MethodDefinition method);
    private static bool RequiresParameterRow(ParameterDefinition parameter);
    private void AddParameter(ushort sequence, ParameterDefinition parameter, ParamTable table);
    private void AddMarshalInfo(IMarshalInfoProvider owner);
    private void AddProperties(TypeDefinition type);
    private void AddProperty(PropertyDefinition property);
    private void AddOtherSemantic(IMetadataTokenProvider owner, Collection`1<MethodDefinition> others);
    private void AddEvents(TypeDefinition type);
    private void AddEvent(EventDefinition event);
    private void AddSemantic(MethodSemanticsAttributes semantics, IMetadataTokenProvider provider, MethodDefinition method);
    private void AddConstant(IConstantProvider owner, TypeReference type);
    private static ElementType GetConstantType(TypeReference constant_type, object constant);
    private static ElementType GetConstantType(Type type);
    private void AddCustomAttributes(ICustomAttributeProvider owner);
    private void AddSecurityDeclarations(ISecurityDeclarationProvider owner);
    private MetadataToken GetMemberRefToken(MemberReference member);
    private Row`3<UInt32, UInt32, UInt32> CreateMemberRefRow(MemberReference member);
    private void AddMemberReference(MemberReference member, Row`3<UInt32, UInt32, UInt32> row);
    private MetadataToken GetMethodSpecToken(MethodSpecification method_spec);
    private void AddMethodSpecification(MethodSpecification method_spec, Row`2<UInt32, UInt32> row);
    private Row`2<UInt32, UInt32> CreateMethodSpecRow(MethodSpecification method_spec);
    private SignatureWriter CreateSignatureWriter();
    private SignatureWriter GetMethodSpecSignature(MethodSpecification method_spec);
    public UInt32 AddStandAloneSignature(UInt32 signature);
    public UInt32 GetLocalVariableBlobIndex(Collection`1<VariableDefinition> variables);
    public UInt32 GetCallSiteBlobIndex(CallSite call_site);
    private SignatureWriter GetVariablesSignature(Collection`1<VariableDefinition> variables);
    private SignatureWriter GetFieldSignature(FieldReference field);
    private SignatureWriter GetMethodSignature(IMethodSignature method);
    private SignatureWriter GetMemberRefSignature(MemberReference member);
    private SignatureWriter GetPropertySignature(PropertyDefinition property);
    private SignatureWriter GetTypeSpecSignature(TypeReference type);
    private SignatureWriter GetConstantSignature(ElementType type, object value);
    private SignatureWriter GetCustomAttributeSignature(CustomAttribute attribute);
    private SignatureWriter GetSecurityDeclarationSignature(SecurityDeclaration declaration);
    private SignatureWriter GetMarshalInfoSignature(IMarshalInfoProvider owner);
    private static Exception CreateForeignMemberException(MemberReference member);
    public MetadataToken LookupToken(IMetadataTokenProvider provider);
}
internal class Mono.Cecil.MetadataImporter : object {
    private Dictionary`2<TypeRefKey, TypeReference> cache;
    private ModuleDefinition module;
    public MetadataImporter(ModuleDefinition module);
    private TypeReference ImportType(TypeReference type, ImportGenericContext context);
    private IMetadataScope ImportScope(IMetadataScope scope);
    private AssemblyNameReference ImportAssemblyName(AssemblyNameReference name);
    private static void ImportGenericParameters(IGenericParameterProvider imported, IGenericParameterProvider original);
    private TypeReference ImportTypeSpecification(TypeReference type, ImportGenericContext context);
    private FieldReference ImportField(FieldReference field, ImportGenericContext context);
    private MethodReference ImportMethod(MethodReference method, ImportGenericContext context);
    private MethodSpecification ImportMethodSpecification(MethodReference method, ImportGenericContext context);
    public virtual TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);
    public virtual FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);
    public virtual MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
}
internal class Mono.Cecil.MetadataReader : ByteBuffer {
    internal Image image;
    internal ModuleDefinition module;
    internal MetadataSystem metadata;
    internal IGenericContext context;
    internal CodeReader code;
    private UInt32 Position { get; private set; }
    public MetadataReader(ModuleDefinition module);
    private UInt32 get_Position();
    private void set_Position(UInt32 value);
    private int GetCodedIndexSize(CodedIndex index);
    private UInt32 ReadByIndexSize(int size);
    private Byte[] ReadBlob();
    private Byte[] ReadBlob(UInt32 signature);
    private UInt32 ReadBlobIndex();
    private string ReadString();
    private UInt32 ReadStringIndex();
    private UInt32 ReadTableIndex(Table table);
    private MetadataToken ReadMetadataToken(CodedIndex index);
    private int MoveTo(Table table);
    private bool MoveTo(Table table, UInt32 row);
    public AssemblyNameDefinition ReadAssemblyNameDefinition();
    public ModuleDefinition Populate(ModuleDefinition module);
    private void InitializeAssemblyReferences();
    public Collection`1<AssemblyNameReference> ReadAssemblyReferences();
    public MethodDefinition ReadEntryPoint();
    public Collection`1<ModuleDefinition> ReadModules();
    private string GetModuleFileName(string name);
    private void InitializeModuleReferences();
    public Collection`1<ModuleReference> ReadModuleReferences();
    public bool HasFileResource();
    public Collection`1<Resource> ReadResources();
    private Row`3<FileAttributes, string, UInt32> ReadFileRecord(UInt32 rid);
    public MemoryStream GetManagedResourceStream(UInt32 offset);
    private void PopulateVersionAndFlags(AssemblyNameReference name);
    private void PopulateNameAndCulture(AssemblyNameReference name);
    public TypeDefinitionCollection ReadTypes();
    private void CompleteTypes();
    private void InitializeTypeDefinitions();
    private static bool IsNested(TypeAttributes attributes);
    public bool HasNestedTypes(TypeDefinition type);
    public Collection`1<TypeDefinition> ReadNestedTypes(TypeDefinition type);
    private void InitializeNestedTypes();
    private void AddNestedMapping(UInt32 declaring, UInt32 nested);
    private static TValue[] AddMapping(Dictionary`2<TKey, TValue[]> cache, TKey key, TValue value);
    private TypeDefinition ReadType(UInt32 rid);
    private TypeDefinition GetNestedTypeDeclaringType(TypeDefinition type);
    private Range ReadFieldsRange(UInt32 type_index);
    private Range ReadMethodsRange(UInt32 type_index);
    private Range ReadListRange(UInt32 current_index, Table current, Table target);
    public Row`2<short, int> ReadTypeLayout(TypeDefinition type);
    private void InitializeTypeLayouts();
    public TypeReference GetTypeDefOrRef(MetadataToken token);
    public TypeDefinition GetTypeDefinition(UInt32 rid);
    private TypeDefinition ReadTypeDefinition(UInt32 rid);
    private void InitializeTypeReferences();
    public TypeReference GetTypeReference(string scope, string full_name);
    private TypeReference GetTypeReference(UInt32 rid);
    private TypeReference ReadTypeReference(UInt32 rid);
    private IMetadataScope GetTypeReferenceScope(MetadataToken scope);
    public IEnumerable`1<TypeReference> GetTypeReferences();
    private TypeReference GetTypeSpecification(UInt32 rid);
    private SignatureReader ReadSignature(UInt32 signature);
    public bool HasInterfaces(TypeDefinition type);
    public Collection`1<TypeReference> ReadInterfaces(TypeDefinition type);
    private void InitializeInterfaces();
    private void AddInterfaceMapping(UInt32 type, MetadataToken interface);
    public Collection`1<FieldDefinition> ReadFields(TypeDefinition type);
    private void ReadField(UInt32 field_rid, Collection`1<FieldDefinition> fields);
    private void InitializeFields();
    private TypeReference ReadFieldType(UInt32 signature);
    public int ReadFieldRVA(FieldDefinition field);
    private Byte[] GetFieldInitializeValue(int size, UInt32 rva);
    private static int GetFieldTypeSize(TypeReference type);
    private void InitializeFieldRVAs();
    public int ReadFieldLayout(FieldDefinition field);
    private void InitializeFieldLayouts();
    public bool HasEvents(TypeDefinition type);
    public Collection`1<EventDefinition> ReadEvents(TypeDefinition type);
    private void ReadEvent(UInt32 event_rid, Collection`1<EventDefinition> events);
    private void InitializeEvents();
    private Range ReadEventsRange(UInt32 rid);
    public bool HasProperties(TypeDefinition type);
    public Collection`1<PropertyDefinition> ReadProperties(TypeDefinition type);
    private void ReadProperty(UInt32 property_rid, Collection`1<PropertyDefinition> properties);
    private void InitializeProperties();
    private Range ReadPropertiesRange(UInt32 rid);
    private MethodSemanticsAttributes ReadMethodSemantics(MethodDefinition method);
    private static EventDefinition GetEvent(TypeDefinition type, MetadataToken token);
    private static PropertyDefinition GetProperty(TypeDefinition type, MetadataToken token);
    private static TMember GetMember(Collection`1<TMember> members, MetadataToken token);
    private void InitializeMethodSemantics();
    public PropertyDefinition ReadMethods(PropertyDefinition property);
    public EventDefinition ReadMethods(EventDefinition event);
    public MethodSemanticsAttributes ReadAllSemantics(MethodDefinition method);
    private void ReadAllSemantics(TypeDefinition type);
    private Range ReadParametersRange(UInt32 method_rid);
    public Collection`1<MethodDefinition> ReadMethods(TypeDefinition type);
    private void ReadPointers(Table ptr, Table table, Range range, Collection`1<TMember> members, Action`2<UInt32, Collection`1<TMember>> reader);
    private static bool IsDeleted(IMemberDefinition member);
    private void InitializeMethods();
    private void ReadMethod(UInt32 method_rid, Collection`1<MethodDefinition> methods);
    private void ReadParameters(MethodDefinition method, Range param_range);
    private void ReadParameterPointers(MethodDefinition method, Range range);
    private void ReadParameter(UInt32 param_rid, MethodDefinition method);
    private void ReadMethodSignature(UInt32 signature, IMethodSignature method);
    public PInvokeInfo ReadPInvokeInfo(MethodDefinition method);
    private void InitializePInvokes();
    public bool HasGenericParameters(IGenericParameterProvider provider);
    public Collection`1<GenericParameter> ReadGenericParameters(IGenericParameterProvider provider);
    private void ReadGenericParametersRange(Range range, IGenericParameterProvider provider, GenericParameterCollection generic_parameters);
    private void InitializeGenericParameters();
    private Dictionary`2<MetadataToken, Range[]> InitializeRanges(Table table, Func`1<MetadataToken> get_next);
    private static void AddRange(Dictionary`2<MetadataToken, Range[]> ranges, MetadataToken owner, Range range);
    public bool HasGenericConstraints(GenericParameter generic_parameter);
    public Collection`1<TypeReference> ReadGenericConstraints(GenericParameter generic_parameter);
    private void InitializeGenericConstraints();
    private void AddGenericConstraintMapping(UInt32 generic_parameter, MetadataToken constraint);
    public bool HasOverrides(MethodDefinition method);
    public Collection`1<MethodReference> ReadOverrides(MethodDefinition method);
    private void InitializeOverrides();
    private void AddOverrideMapping(UInt32 method_rid, MetadataToken override);
    public MethodBody ReadMethodBody(MethodDefinition method);
    public CallSite ReadCallSite(MetadataToken token);
    public VariableDefinitionCollection ReadVariables(MetadataToken local_var_token);
    public IMetadataTokenProvider LookupToken(MetadataToken token);
    public FieldDefinition GetFieldDefinition(UInt32 rid);
    private FieldDefinition LookupField(UInt32 rid);
    public MethodDefinition GetMethodDefinition(UInt32 rid);
    private MethodDefinition LookupMethod(UInt32 rid);
    private MethodSpecification GetMethodSpecification(UInt32 rid);
    private MethodSpecification ReadMethodSpecSignature(UInt32 signature, MethodReference method);
    private MemberReference GetMemberReference(UInt32 rid);
    private MemberReference ReadMemberReference(UInt32 rid);
    private MemberReference ReadTypeMemberReference(MetadataToken type, string name, UInt32 signature);
    private MemberReference ReadMemberReferenceSignature(UInt32 signature, TypeReference declaring_type);
    private MemberReference ReadMethodMemberReference(MetadataToken token, string name, UInt32 signature);
    private void InitializeMemberReferences();
    public IEnumerable`1<MemberReference> GetMemberReferences();
    private void InitializeConstants();
    public object ReadConstant(IConstantProvider owner);
    private static string ReadConstantString(Byte[] blob);
    private object ReadConstantPrimitive(ElementType type, UInt32 signature);
    private void InitializeCustomAttributes();
    public bool HasCustomAttributes(ICustomAttributeProvider owner);
    public Collection`1<CustomAttribute> ReadCustomAttributes(ICustomAttributeProvider owner);
    private void ReadCustomAttributeRange(Range range, Collection`1<CustomAttribute> custom_attributes);
    private static int RangesSize(Range[] ranges);
    public Byte[] ReadCustomAttributeBlob(UInt32 signature);
    public void ReadCustomAttributeSignature(CustomAttribute attribute);
    private void InitializeMarshalInfos();
    public bool HasMarshalInfo(IMarshalInfoProvider owner);
    public MarshalInfo ReadMarshalInfo(IMarshalInfoProvider owner);
    private void InitializeSecurityDeclarations();
    public bool HasSecurityDeclarations(ISecurityDeclarationProvider owner);
    public Collection`1<SecurityDeclaration> ReadSecurityDeclarations(ISecurityDeclarationProvider owner);
    private void ReadSecurityDeclarationRange(Range range, Collection`1<SecurityDeclaration> security_declarations);
    public Byte[] ReadSecurityDeclarationBlob(UInt32 signature);
    public void ReadSecurityDeclarationSignature(SecurityDeclaration declaration);
    private void ReadXmlSecurityDeclaration(UInt32 signature, SecurityDeclaration declaration);
    public Collection`1<ExportedType> ReadExportedTypes();
    private IMetadataScope GetExportedTypeScope(MetadataToken token);
    private ModuleReference GetModuleReferenceFromFile(MetadataToken token);
    private static void InitializeCollection(object o);
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeGenericParameters>b__110_0();
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeCustomAttributes>b__142_0();
    [CompilerGeneratedAttribute]
private MetadataToken <InitializeSecurityDeclarations>b__152_0();
}
internal class Mono.Cecil.MetadataResolver : object {
    private IAssemblyResolver assembly_resolver;
    public IAssemblyResolver AssemblyResolver { get; }
    public MetadataResolver(IAssemblyResolver assemblyResolver);
    public IAssemblyResolver get_AssemblyResolver();
    public virtual TypeDefinition Resolve(TypeReference type);
    private static TypeDefinition GetType(ModuleDefinition module, TypeReference reference);
    private static TypeDefinition GetTypeDefinition(ModuleDefinition module, TypeReference type);
    public virtual FieldDefinition Resolve(FieldReference field);
    private FieldDefinition GetField(TypeDefinition type, FieldReference reference);
    private static FieldDefinition GetField(Collection`1<FieldDefinition> fields, FieldReference reference);
    public virtual MethodDefinition Resolve(MethodReference method);
    private MethodDefinition GetMethod(TypeDefinition type, MethodReference reference);
    public static MethodDefinition GetMethod(Collection`1<MethodDefinition> methods, MethodReference reference);
    internal static bool AreSame(MethodReference a, MethodReference b);
    private static bool AreSame(Collection`1<ParameterDefinition> a, Collection`1<ParameterDefinition> b);
    private static bool AreSame(TypeSpecification a, TypeSpecification b);
    private static bool AreSame(ArrayType a, ArrayType b);
    private static bool AreSame(IModifierType a, IModifierType b);
    private static bool AreSame(GenericInstanceType a, GenericInstanceType b);
    private static bool AreSame(GenericParameter a, GenericParameter b);
    private static bool AreSame(TypeReference a, TypeReference b);
}
internal enum Mono.Cecil.MetadataScopeType : Enum {
    public int value__;
    public static MetadataScopeType AssemblyNameReference;
    public static MetadataScopeType ModuleReference;
    public static MetadataScopeType ModuleDefinition;
}
internal class Mono.Cecil.MetadataSystem : object {
    internal AssemblyNameReference[] AssemblyReferences;
    internal ModuleReference[] ModuleReferences;
    internal TypeDefinition[] Types;
    internal TypeReference[] TypeReferences;
    internal bool HasSystemObject;
    internal FieldDefinition[] Fields;
    internal MethodDefinition[] Methods;
    internal MemberReference[] MemberReferences;
    internal Dictionary`2<UInt32, UInt32[]> NestedTypes;
    internal Dictionary`2<UInt32, UInt32> ReverseNestedTypes;
    internal Dictionary`2<UInt32, MetadataToken[]> Interfaces;
    internal Dictionary`2<UInt32, Row`2<ushort, UInt32>> ClassLayouts;
    internal Dictionary`2<UInt32, UInt32> FieldLayouts;
    internal Dictionary`2<UInt32, UInt32> FieldRVAs;
    internal Dictionary`2<MetadataToken, UInt32> FieldMarshals;
    internal Dictionary`2<MetadataToken, Row`2<ElementType, UInt32>> Constants;
    internal Dictionary`2<UInt32, MetadataToken[]> Overrides;
    internal Dictionary`2<MetadataToken, Range[]> CustomAttributes;
    internal Dictionary`2<MetadataToken, Range[]> SecurityDeclarations;
    internal Dictionary`2<UInt32, Range> Events;
    internal Dictionary`2<UInt32, Range> Properties;
    internal Dictionary`2<UInt32, Row`2<MethodSemanticsAttributes, MetadataToken>> Semantics;
    internal Dictionary`2<UInt32, Row`3<PInvokeAttributes, UInt32, UInt32>> PInvokes;
    internal Dictionary`2<MetadataToken, Range[]> GenericParameters;
    internal Dictionary`2<UInt32, MetadataToken[]> GenericConstraints;
    private static Dictionary`2<string, Row`2<ElementType, bool>> primitive_value_types;
    private static void InitializePrimitives();
    public static void TryProcessPrimitiveTypeReference(TypeReference type);
    public static bool TryGetPrimitiveElementType(TypeDefinition type, ElementType& etype);
    private static bool TryGetPrimitiveData(TypeReference type, Row`2& primitive_data);
    public void Clear();
    public TypeDefinition GetTypeDefinition(UInt32 rid);
    public void AddTypeDefinition(TypeDefinition type);
    public TypeReference GetTypeReference(UInt32 rid);
    public void AddTypeReference(TypeReference type);
    public FieldDefinition GetFieldDefinition(UInt32 rid);
    public void AddFieldDefinition(FieldDefinition field);
    public MethodDefinition GetMethodDefinition(UInt32 rid);
    public void AddMethodDefinition(MethodDefinition method);
    public MemberReference GetMemberReference(UInt32 rid);
    public void AddMemberReference(MemberReference member);
    public bool TryGetNestedTypeMapping(TypeDefinition type, UInt32[]& mapping);
    public void SetNestedTypeMapping(UInt32 type_rid, UInt32[] mapping);
    public void RemoveNestedTypeMapping(TypeDefinition type);
    public bool TryGetReverseNestedTypeMapping(TypeDefinition type, UInt32& declaring);
    public void SetReverseNestedTypeMapping(UInt32 nested, UInt32 declaring);
    public void RemoveReverseNestedTypeMapping(TypeDefinition type);
    public bool TryGetInterfaceMapping(TypeDefinition type, MetadataToken[]& mapping);
    public void SetInterfaceMapping(UInt32 type_rid, MetadataToken[] mapping);
    public void RemoveInterfaceMapping(TypeDefinition type);
    public void AddPropertiesRange(UInt32 type_rid, Range range);
    public bool TryGetPropertiesRange(TypeDefinition type, Range& range);
    public void RemovePropertiesRange(TypeDefinition type);
    public void AddEventsRange(UInt32 type_rid, Range range);
    public bool TryGetEventsRange(TypeDefinition type, Range& range);
    public void RemoveEventsRange(TypeDefinition type);
    public bool TryGetGenericParameterRanges(IGenericParameterProvider owner, Range[]& ranges);
    public void RemoveGenericParameterRange(IGenericParameterProvider owner);
    public bool TryGetCustomAttributeRanges(ICustomAttributeProvider owner, Range[]& ranges);
    public void RemoveCustomAttributeRange(ICustomAttributeProvider owner);
    public bool TryGetSecurityDeclarationRanges(ISecurityDeclarationProvider owner, Range[]& ranges);
    public void RemoveSecurityDeclarationRange(ISecurityDeclarationProvider owner);
    public bool TryGetGenericConstraintMapping(GenericParameter generic_parameter, MetadataToken[]& mapping);
    public void SetGenericConstraintMapping(UInt32 gp_rid, MetadataToken[] mapping);
    public void RemoveGenericConstraintMapping(GenericParameter generic_parameter);
    public bool TryGetOverrideMapping(MethodDefinition method, MetadataToken[]& mapping);
    public void SetOverrideMapping(UInt32 rid, MetadataToken[] mapping);
    public void RemoveOverrideMapping(MethodDefinition method);
    public TypeDefinition GetFieldDeclaringType(UInt32 field_rid);
    public TypeDefinition GetMethodDeclaringType(UInt32 method_rid);
    private static TypeDefinition BinaryRangeSearch(TypeDefinition[] types, UInt32 rid, bool field);
}
internal abstract class Mono.Cecil.MetadataTable : object {
    public int Length { get; }
    public bool IsLarge { get; }
    public abstract virtual int get_Length();
    public bool get_IsLarge();
    public abstract virtual void Write(TableHeapBuffer buffer);
    public abstract virtual void Sort();
}
internal abstract class Mono.Cecil.MetadataTable`1 : MetadataTable {
    internal TRow[] rows;
    internal int length;
    public int Length { get; }
    public sealed virtual int get_Length();
    public int AddRow(TRow row);
    private void Grow();
    public virtual void Sort();
}
internal class Mono.Cecil.MetadataToken : ValueType {
    private UInt32 token;
    public static MetadataToken Zero;
    public UInt32 RID { get; }
    public TokenType TokenType { get; }
    public MetadataToken(UInt32 token);
    public MetadataToken(TokenType type);
    public MetadataToken(TokenType type, UInt32 rid);
    public MetadataToken(TokenType type, int rid);
    private static MetadataToken();
    public UInt32 get_RID();
    public TokenType get_TokenType();
    public int ToInt32();
    public UInt32 ToUInt32();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MetadataToken other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(MetadataToken one, MetadataToken other);
    public static bool op_Inequality(MetadataToken one, MetadataToken other);
    public virtual string ToString();
}
internal enum Mono.Cecil.MetadataType : Enum {
    public byte value__;
    public static MetadataType Void;
    public static MetadataType Boolean;
    public static MetadataType Char;
    public static MetadataType SByte;
    public static MetadataType Byte;
    public static MetadataType Int16;
    public static MetadataType UInt16;
    public static MetadataType Int32;
    public static MetadataType UInt32;
    public static MetadataType Int64;
    public static MetadataType UInt64;
    public static MetadataType Single;
    public static MetadataType Double;
    public static MetadataType String;
    public static MetadataType Pointer;
    public static MetadataType ByReference;
    public static MetadataType ValueType;
    public static MetadataType Class;
    public static MetadataType Var;
    public static MetadataType Array;
    public static MetadataType GenericInstance;
    public static MetadataType TypedByReference;
    public static MetadataType IntPtr;
    public static MetadataType UIntPtr;
    public static MetadataType FunctionPointer;
    public static MetadataType Object;
    public static MetadataType MVar;
    public static MetadataType RequiredModifier;
    public static MetadataType OptionalModifier;
    public static MetadataType Sentinel;
    public static MetadataType Pinned;
}
[FlagsAttribute]
internal enum Mono.Cecil.MethodAttributes : Enum {
    public ushort value__;
    public static MethodAttributes MemberAccessMask;
    public static MethodAttributes CompilerControlled;
    public static MethodAttributes Private;
    public static MethodAttributes FamANDAssem;
    public static MethodAttributes Assembly;
    public static MethodAttributes Family;
    public static MethodAttributes FamORAssem;
    public static MethodAttributes Public;
    public static MethodAttributes Static;
    public static MethodAttributes Final;
    public static MethodAttributes Virtual;
    public static MethodAttributes HideBySig;
    public static MethodAttributes VtableLayoutMask;
    public static MethodAttributes ReuseSlot;
    public static MethodAttributes NewSlot;
    public static MethodAttributes CheckAccessOnOverride;
    public static MethodAttributes Abstract;
    public static MethodAttributes SpecialName;
    public static MethodAttributes PInvokeImpl;
    public static MethodAttributes UnmanagedExport;
    public static MethodAttributes RTSpecialName;
    public static MethodAttributes HasSecurity;
    public static MethodAttributes RequireSecObject;
}
internal enum Mono.Cecil.MethodCallingConvention : Enum {
    public byte value__;
    public static MethodCallingConvention Default;
    public static MethodCallingConvention C;
    public static MethodCallingConvention StdCall;
    public static MethodCallingConvention ThisCall;
    public static MethodCallingConvention FastCall;
    public static MethodCallingConvention VarArg;
    public static MethodCallingConvention Generic;
}
internal class Mono.Cecil.MethodDefinition : MethodReference {
    private ushort attributes;
    private ushort impl_attributes;
    internal Boolean modreq(System.Runtime.CompilerServices.IsVolatile) sem_attrs_ready;
    internal MethodSemanticsAttributes sem_attrs;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<SecurityDeclaration> security_declarations;
    internal UInt32 rva;
    internal PInvokeInfo pinvoke;
    private Collection`1<MethodReference> overrides;
    internal MethodBody body;
    public MethodAttributes Attributes { get; public set; }
    public MethodImplAttributes ImplAttributes { get; public set; }
    public MethodSemanticsAttributes SemanticsAttributes { get; public set; }
    public bool HasSecurityDeclarations { get; }
    public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public int RVA { get; }
    public bool HasBody { get; }
    public MethodBody Body { get; public set; }
    public bool HasPInvokeInfo { get; }
    public PInvokeInfo PInvokeInfo { get; public set; }
    public bool HasOverrides { get; }
    public Collection`1<MethodReference> Overrides { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public bool IsCompilerControlled { get; public set; }
    public bool IsPrivate { get; public set; }
    public bool IsFamilyAndAssembly { get; public set; }
    public bool IsAssembly { get; public set; }
    public bool IsFamily { get; public set; }
    public bool IsFamilyOrAssembly { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsStatic { get; public set; }
    public bool IsFinal { get; public set; }
    public bool IsVirtual { get; public set; }
    public bool IsHideBySig { get; public set; }
    public bool IsReuseSlot { get; public set; }
    public bool IsNewSlot { get; public set; }
    public bool IsCheckAccessOnOverride { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsPInvokeImpl { get; public set; }
    public bool IsUnmanagedExport { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasSecurity { get; public set; }
    public bool IsIL { get; public set; }
    public bool IsNative { get; public set; }
    public bool IsRuntime { get; public set; }
    public bool IsUnmanaged { get; public set; }
    public bool IsManaged { get; public set; }
    public bool IsForwardRef { get; public set; }
    public bool IsPreserveSig { get; public set; }
    public bool IsInternalCall { get; public set; }
    public bool IsSynchronized { get; public set; }
    public bool NoInlining { get; public set; }
    public bool NoOptimization { get; public set; }
    public bool IsSetter { get; public set; }
    public bool IsGetter { get; public set; }
    public bool IsOther { get; public set; }
    public bool IsAddOn { get; public set; }
    public bool IsRemoveOn { get; public set; }
    public bool IsFire { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public bool IsConstructor { get; }
    public bool IsDefinition { get; }
    public MethodDefinition(string name, MethodAttributes attributes, TypeReference returnType);
    public MethodAttributes get_Attributes();
    public void set_Attributes(MethodAttributes value);
    public MethodImplAttributes get_ImplAttributes();
    public void set_ImplAttributes(MethodImplAttributes value);
    public MethodSemanticsAttributes get_SemanticsAttributes();
    public void set_SemanticsAttributes(MethodSemanticsAttributes value);
    internal void ReadSemantics();
    public sealed virtual bool get_HasSecurityDeclarations();
    public sealed virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public int get_RVA();
    public bool get_HasBody();
    public MethodBody get_Body();
    public void set_Body(MethodBody value);
    public bool get_HasPInvokeInfo();
    public PInvokeInfo get_PInvokeInfo();
    public void set_PInvokeInfo(PInvokeInfo value);
    public bool get_HasOverrides();
    public Collection`1<MethodReference> get_Overrides();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public bool get_IsCompilerControlled();
    public void set_IsCompilerControlled(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
    public bool get_IsFamilyAndAssembly();
    public void set_IsFamilyAndAssembly(bool value);
    public bool get_IsAssembly();
    public void set_IsAssembly(bool value);
    public bool get_IsFamily();
    public void set_IsFamily(bool value);
    public bool get_IsFamilyOrAssembly();
    public void set_IsFamilyOrAssembly(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsStatic();
    public void set_IsStatic(bool value);
    public bool get_IsFinal();
    public void set_IsFinal(bool value);
    public bool get_IsVirtual();
    public void set_IsVirtual(bool value);
    public bool get_IsHideBySig();
    public void set_IsHideBySig(bool value);
    public bool get_IsReuseSlot();
    public void set_IsReuseSlot(bool value);
    public bool get_IsNewSlot();
    public void set_IsNewSlot(bool value);
    public bool get_IsCheckAccessOnOverride();
    public void set_IsCheckAccessOnOverride(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsPInvokeImpl();
    public void set_IsPInvokeImpl(bool value);
    public bool get_IsUnmanagedExport();
    public void set_IsUnmanagedExport(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsIL();
    public void set_IsIL(bool value);
    public bool get_IsNative();
    public void set_IsNative(bool value);
    public bool get_IsRuntime();
    public void set_IsRuntime(bool value);
    public bool get_IsUnmanaged();
    public void set_IsUnmanaged(bool value);
    public bool get_IsManaged();
    public void set_IsManaged(bool value);
    public bool get_IsForwardRef();
    public void set_IsForwardRef(bool value);
    public bool get_IsPreserveSig();
    public void set_IsPreserveSig(bool value);
    public bool get_IsInternalCall();
    public void set_IsInternalCall(bool value);
    public bool get_IsSynchronized();
    public void set_IsSynchronized(bool value);
    public bool get_NoInlining();
    public void set_NoInlining(bool value);
    public bool get_NoOptimization();
    public void set_NoOptimization(bool value);
    public bool get_IsSetter();
    public void set_IsSetter(bool value);
    public bool get_IsGetter();
    public void set_IsGetter(bool value);
    public bool get_IsOther();
    public void set_IsOther(bool value);
    public bool get_IsAddOn();
    public void set_IsAddOn(bool value);
    public bool get_IsRemoveOn();
    public void set_IsRemoveOn(bool value);
    public bool get_IsFire();
    public void set_IsFire(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public bool get_IsConstructor();
    public virtual bool get_IsDefinition();
    public virtual MethodDefinition Resolve();
}
[FlagsAttribute]
internal enum Mono.Cecil.MethodImplAttributes : Enum {
    public ushort value__;
    public static MethodImplAttributes CodeTypeMask;
    public static MethodImplAttributes IL;
    public static MethodImplAttributes Native;
    public static MethodImplAttributes OPTIL;
    public static MethodImplAttributes Runtime;
    public static MethodImplAttributes ManagedMask;
    public static MethodImplAttributes Unmanaged;
    public static MethodImplAttributes Managed;
    public static MethodImplAttributes ForwardRef;
    public static MethodImplAttributes PreserveSig;
    public static MethodImplAttributes InternalCall;
    public static MethodImplAttributes Synchronized;
    public static MethodImplAttributes NoOptimization;
    public static MethodImplAttributes NoInlining;
}
internal class Mono.Cecil.MethodImplTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.MethodReference : MemberReference {
    internal ParameterDefinitionCollection parameters;
    private MethodReturnType return_type;
    private bool has_this;
    private bool explicit_this;
    private MethodCallingConvention calling_convention;
    internal Collection`1<GenericParameter> generic_parameters;
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Method { get; }
    private GenericParameterType Mono.Cecil.IGenericParameterProvider.GenericParameterType { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public TypeReference ReturnType { get; public set; }
    public MethodReturnType MethodReturnType { get; public set; }
    public string FullName { get; }
    public bool IsGenericInstance { get; }
    public bool ContainsGenericParameter { get; }
    public MethodReference(string name, TypeReference returnType);
    public MethodReference(string name, TypeReference returnType, TypeReference declaringType);
    public virtual bool get_HasThis();
    public virtual void set_HasThis(bool value);
    public virtual bool get_ExplicitThis();
    public virtual void set_ExplicitThis(bool value);
    public virtual MethodCallingConvention get_CallingConvention();
    public virtual void set_CallingConvention(MethodCallingConvention value);
    public virtual bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method();
    private sealed virtual override GenericParameterType Mono.Cecil.IGenericParameterProvider.get_GenericParameterType();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public sealed virtual TypeReference get_ReturnType();
    public sealed virtual void set_ReturnType(TypeReference value);
    public virtual MethodReturnType get_MethodReturnType();
    public virtual void set_MethodReturnType(MethodReturnType value);
    public virtual string get_FullName();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_ContainsGenericParameter();
    public virtual MethodReference GetElementMethod();
    public virtual MethodDefinition Resolve();
}
internal class Mono.Cecil.MethodReturnType : object {
    internal IMethodSignature method;
    internal ParameterDefinition parameter;
    private TypeReference return_type;
    public IMethodSignature Method { get; }
    public TypeReference ReturnType { get; public set; }
    internal ParameterDefinition Parameter { get; }
    public MetadataToken MetadataToken { get; public set; }
    public ParameterAttributes Attributes { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasDefault { get; public set; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool HasFieldMarshal { get; public set; }
    public bool HasMarshalInfo { get; }
    public MarshalInfo MarshalInfo { get; public set; }
    public MethodReturnType(IMethodSignature method);
    public IMethodSignature get_Method();
    public TypeReference get_ReturnType();
    public void set_ReturnType(TypeReference value);
    internal ParameterDefinition get_Parameter();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public ParameterAttributes get_Attributes();
    public void set_Attributes(ParameterAttributes value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public bool get_HasFieldMarshal();
    public void set_HasFieldMarshal(bool value);
    public sealed virtual bool get_HasMarshalInfo();
    public sealed virtual MarshalInfo get_MarshalInfo();
    public sealed virtual void set_MarshalInfo(MarshalInfo value);
}
[FlagsAttribute]
internal enum Mono.Cecil.MethodSemanticsAttributes : Enum {
    public ushort value__;
    public static MethodSemanticsAttributes None;
    public static MethodSemanticsAttributes Setter;
    public static MethodSemanticsAttributes Getter;
    public static MethodSemanticsAttributes Other;
    public static MethodSemanticsAttributes AddOn;
    public static MethodSemanticsAttributes RemoveOn;
    public static MethodSemanticsAttributes Fire;
}
internal class Mono.Cecil.MethodSemanticsTable : SortedTable`1<Row`3<MethodSemanticsAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`3<MethodSemanticsAttributes, UInt32, UInt32> x, Row`3<MethodSemanticsAttributes, UInt32, UInt32> y);
}
internal abstract class Mono.Cecil.MethodSpecification : MethodReference {
    private MethodReference method;
    public MethodReference ElementMethod { get; }
    public string Name { get; public set; }
    public MethodCallingConvention CallingConvention { get; public set; }
    public bool HasThis { get; public set; }
    public bool ExplicitThis { get; public set; }
    public MethodReturnType MethodReturnType { get; public set; }
    public TypeReference DeclaringType { get; public set; }
    public ModuleDefinition Module { get; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public bool ContainsGenericParameter { get; }
    internal MethodSpecification(MethodReference method);
    public MethodReference get_ElementMethod();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual MethodCallingConvention get_CallingConvention();
    public virtual void set_CallingConvention(MethodCallingConvention value);
    public virtual bool get_HasThis();
    public virtual void set_HasThis(bool value);
    public virtual bool get_ExplicitThis();
    public virtual void set_ExplicitThis(bool value);
    public virtual MethodReturnType get_MethodReturnType();
    public virtual void set_MethodReturnType(MethodReturnType value);
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual ModuleDefinition get_Module();
    public virtual bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    public virtual bool get_ContainsGenericParameter();
    public sealed virtual MethodReference GetElementMethod();
}
internal class Mono.Cecil.MethodSpecTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.MethodTable : MetadataTable`1<Row`6<UInt32, MethodImplAttributes, MethodAttributes, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Mixin : object {
    public static Version ZeroVersion;
    internal static object NoValue;
    internal static object NotResolved;
    public static int NotResolvedMarker;
    public static int NoDataMarker;
    private static Mixin();
    [ExtensionAttribute]
public static UInt32 ReadCompressedUInt32(Byte[] data, Int32& position);
    [ExtensionAttribute]
public static MetadataToken GetMetadataToken(CodedIndex self, UInt32 data);
    [ExtensionAttribute]
public static UInt32 CompressMetadataToken(CodedIndex self, MetadataToken token);
    [ExtensionAttribute]
public static int GetSize(CodedIndex self, Func`2<Table, int> counter);
    public static Version CheckVersion(Version version);
    public static void CheckModule(ModuleDefinition module);
    [ExtensionAttribute]
public static bool TryGetAssemblyNameReference(ModuleDefinition module, AssemblyNameReference name_reference, AssemblyNameReference& assembly_reference);
    private static bool Equals(Byte[] a, Byte[] b);
    private static bool Equals(T a, T b);
    private static bool Equals(AssemblyNameReference a, AssemblyNameReference b);
    [ExtensionAttribute]
public static bool GetHasSecurityDeclarations(ISecurityDeclarationProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<SecurityDeclaration> GetSecurityDeclarations(ISecurityDeclarationProvider self, Collection`1& variable, ModuleDefinition module);
    public static void CheckName(string name);
    [ExtensionAttribute]
public static void ResolveConstant(IConstantProvider self, Object& constant, ModuleDefinition module);
    [ExtensionAttribute]
public static bool GetHasCustomAttributes(ICustomAttributeProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<CustomAttribute> GetCustomAttributes(ICustomAttributeProvider self, Collection`1& variable, ModuleDefinition module);
    [ExtensionAttribute]
public static bool ContainsGenericParameter(IGenericInstance self);
    [ExtensionAttribute]
public static void GenericInstanceFullName(IGenericInstance self, StringBuilder builder);
    [ExtensionAttribute]
public static bool GetHasGenericParameters(IGenericParameterProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static Collection`1<GenericParameter> GetGenericParameters(IGenericParameterProvider self, Collection`1& collection, ModuleDefinition module);
    [ExtensionAttribute]
public static bool GetHasMarshalInfo(IMarshalInfoProvider self, ModuleDefinition module);
    [ExtensionAttribute]
public static MarshalInfo GetMarshalInfo(IMarshalInfoProvider self, MarshalInfo& variable, ModuleDefinition module);
    public static void CheckModifier(TypeReference modifierType, TypeReference type);
    [ExtensionAttribute]
public static bool HasImplicitThis(IMethodSignature self);
    [ExtensionAttribute]
public static void MethodSignatureFullName(IMethodSignature self, StringBuilder builder);
    [ExtensionAttribute]
public static bool GetAttributes(UInt32 self, UInt32 attributes);
    [ExtensionAttribute]
public static UInt32 SetAttributes(UInt32 self, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static bool GetMaskedAttributes(UInt32 self, UInt32 mask, UInt32 attributes);
    [ExtensionAttribute]
public static UInt32 SetMaskedAttributes(UInt32 self, UInt32 mask, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static bool GetAttributes(ushort self, ushort attributes);
    [ExtensionAttribute]
public static ushort SetAttributes(ushort self, ushort attributes, bool value);
    [ExtensionAttribute]
public static bool GetMaskedAttributes(ushort self, ushort mask, UInt32 attributes);
    [ExtensionAttribute]
public static ushort SetMaskedAttributes(ushort self, ushort mask, UInt32 attributes, bool value);
    [ExtensionAttribute]
public static ParameterDefinition GetParameter(MethodBody self, int index);
    [ExtensionAttribute]
public static VariableDefinition GetVariable(MethodBody self, int index);
    [ExtensionAttribute]
public static bool GetSemantics(MethodDefinition self, MethodSemanticsAttributes semantics);
    [ExtensionAttribute]
public static void SetSemantics(MethodDefinition self, MethodSemanticsAttributes semantics, bool value);
    [ExtensionAttribute]
public static bool IsVarArg(IMethodSignature self);
    [ExtensionAttribute]
public static int GetSentinelPosition(IMethodSignature self);
    public static void CheckStream(object stream);
    public static void CheckType(object type);
    public static void CheckField(object field);
    public static void CheckMethod(object method);
    public static void CheckParameters(object parameters);
    [ExtensionAttribute]
public static bool HasImage(ModuleDefinition self);
    [ExtensionAttribute]
public static bool IsCoreLibrary(ModuleDefinition module);
    [ExtensionAttribute]
public static string GetFullyQualifiedName(Stream self);
    [ExtensionAttribute]
public static TargetRuntime ParseRuntime(string self);
    [ExtensionAttribute]
public static string RuntimeVersionString(TargetRuntime runtime);
    [ExtensionAttribute]
public static TypeReference GetEnumUnderlyingType(TypeDefinition self);
    [ExtensionAttribute]
public static TypeDefinition GetNestedType(TypeDefinition self, string fullname);
    [ExtensionAttribute]
public static bool IsPrimitive(ElementType self);
    [ExtensionAttribute]
public static string TypeFullName(TypeReference self);
    [ExtensionAttribute]
public static bool IsTypeOf(TypeReference self, string namespace, string name);
    [ExtensionAttribute]
public static bool IsTypeSpecification(TypeReference type);
    [ExtensionAttribute]
public static TypeDefinition CheckedResolve(TypeReference self);
    public static void CheckType(TypeReference type);
    [ExtensionAttribute]
public static RSA CreateRSA(StrongNameKeyPair key_pair);
    private static bool TryGetKeyContainer(ISerializable key_pair, Byte[]& key, String& key_container);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(T[] self);
    [ExtensionAttribute]
public static bool IsNullOrEmpty(Collection`1<T> self);
    [ExtensionAttribute]
public static T[] Resize(T[] self, int length);
}
[FlagsAttribute]
internal enum Mono.Cecil.ModuleAttributes : Enum {
    public int value__;
    public static ModuleAttributes ILOnly;
    public static ModuleAttributes Required32Bit;
    public static ModuleAttributes StrongNameSigned;
    public static ModuleAttributes Preferred32Bit;
}
[FlagsAttribute]
internal enum Mono.Cecil.ModuleCharacteristics : Enum {
    public int value__;
    public static ModuleCharacteristics HighEntropyVA;
    public static ModuleCharacteristics DynamicBase;
    public static ModuleCharacteristics NoSEH;
    public static ModuleCharacteristics NXCompat;
    public static ModuleCharacteristics AppContainer;
    public static ModuleCharacteristics TerminalServerAware;
}
internal class Mono.Cecil.ModuleDefinition : ModuleReference {
    internal Image Image;
    internal MetadataSystem MetadataSystem;
    internal ReadingMode ReadingMode;
    internal ISymbolReaderProvider SymbolReaderProvider;
    internal ISymbolReader symbol_reader;
    internal IAssemblyResolver assembly_resolver;
    internal IMetadataResolver metadata_resolver;
    internal TypeSystem type_system;
    private MetadataReader reader;
    private string fq_name;
    internal string runtime_version;
    internal ModuleKind kind;
    private TargetRuntime runtime;
    private TargetArchitecture architecture;
    private ModuleAttributes attributes;
    private ModuleCharacteristics characteristics;
    private Guid mvid;
    internal AssemblyDefinition assembly;
    private MethodDefinition entry_point;
    internal IReflectionImporter reflection_importer;
    internal IMetadataImporter metadata_importer;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<AssemblyNameReference> references;
    private Collection`1<ModuleReference> modules;
    private Collection`1<Resource> resources;
    private Collection`1<ExportedType> exported_types;
    private TypeDefinitionCollection types;
    private ResourceDirectory win32ResourceDirectory;
    internal Byte[] Win32Resources;
    internal UInt32 Win32RVA;
    private object module_lock;
    public bool IsMain { get; }
    public ModuleKind Kind { get; public set; }
    public TargetRuntime Runtime { get; public set; }
    public string RuntimeVersion { get; public set; }
    public TargetArchitecture Architecture { get; public set; }
    public ModuleAttributes Attributes { get; public set; }
    public ModuleCharacteristics Characteristics { get; public set; }
    public string FullyQualifiedName { get; }
    public Guid Mvid { get; public set; }
    internal bool HasImage { get; }
    public bool HasSymbols { get; }
    public ISymbolReader SymbolReader { get; }
    public MetadataScopeType MetadataScopeType { get; }
    public AssemblyDefinition Assembly { get; }
    internal IReflectionImporter ReflectionImporter { get; }
    internal IMetadataImporter MetadataImporter { get; }
    public IAssemblyResolver AssemblyResolver { get; }
    public IMetadataResolver MetadataResolver { get; }
    public TypeSystem TypeSystem { get; }
    public bool HasAssemblyReferences { get; }
    public Collection`1<AssemblyNameReference> AssemblyReferences { get; }
    public bool HasModuleReferences { get; }
    public Collection`1<ModuleReference> ModuleReferences { get; }
    public bool HasResources { get; }
    public Collection`1<Resource> Resources { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasTypes { get; }
    public Collection`1<TypeDefinition> Types { get; }
    public bool HasExportedTypes { get; }
    public Collection`1<ExportedType> ExportedTypes { get; }
    public MethodDefinition EntryPoint { get; public set; }
    internal object SyncRoot { get; }
    public bool HasDebugHeader { get; }
    public ResourceDirectory Win32ResourceDirectory { get; public set; }
    internal ModuleDefinition(Image image);
    public bool get_IsMain();
    public ModuleKind get_Kind();
    public void set_Kind(ModuleKind value);
    public TargetRuntime get_Runtime();
    public void set_Runtime(TargetRuntime value);
    public string get_RuntimeVersion();
    public void set_RuntimeVersion(string value);
    public TargetArchitecture get_Architecture();
    public void set_Architecture(TargetArchitecture value);
    public ModuleAttributes get_Attributes();
    public void set_Attributes(ModuleAttributes value);
    public ModuleCharacteristics get_Characteristics();
    public void set_Characteristics(ModuleCharacteristics value);
    public string get_FullyQualifiedName();
    public Guid get_Mvid();
    public void set_Mvid(Guid value);
    internal bool get_HasImage();
    public bool get_HasSymbols();
    public ISymbolReader get_SymbolReader();
    public virtual MetadataScopeType get_MetadataScopeType();
    public AssemblyDefinition get_Assembly();
    internal IReflectionImporter get_ReflectionImporter();
    internal IMetadataImporter get_MetadataImporter();
    public IAssemblyResolver get_AssemblyResolver();
    public IMetadataResolver get_MetadataResolver();
    public TypeSystem get_TypeSystem();
    public bool get_HasAssemblyReferences();
    public Collection`1<AssemblyNameReference> get_AssemblyReferences();
    public bool get_HasModuleReferences();
    public Collection`1<ModuleReference> get_ModuleReferences();
    public bool get_HasResources();
    public Collection`1<Resource> get_Resources();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public bool get_HasTypes();
    public Collection`1<TypeDefinition> get_Types();
    public bool get_HasExportedTypes();
    public Collection`1<ExportedType> get_ExportedTypes();
    public MethodDefinition get_EntryPoint();
    public void set_EntryPoint(MethodDefinition value);
    public bool HasTypeReference(string fullName);
    public bool HasTypeReference(string scope, string fullName);
    public bool TryGetTypeReference(string fullName, TypeReference& type);
    public bool TryGetTypeReference(string scope, string fullName, TypeReference& type);
    private TypeReference GetTypeReference(string scope, string fullname);
    public IEnumerable`1<TypeReference> GetTypeReferences();
    public IEnumerable`1<MemberReference> GetMemberReferences();
    public TypeReference GetType(string fullName, bool runtimeName);
    public TypeDefinition GetType(string fullName);
    public TypeDefinition GetType(string namespace, string name);
    public IEnumerable`1<TypeDefinition> GetTypes();
    private static IEnumerable`1<TypeDefinition> GetTypes(Collection`1<TypeDefinition> types);
    private static void CheckFullName(string fullName);
    private TypeDefinition GetNestedType(string fullname);
    internal FieldDefinition Resolve(FieldReference field);
    internal MethodDefinition Resolve(MethodReference method);
    internal TypeDefinition Resolve(TypeReference type);
    private static void CheckContext(IGenericParameterProvider context, ModuleDefinition module);
    [ObsoleteAttribute("Use ImportReference", "False")]
public TypeReference Import(Type type);
    public TypeReference ImportReference(Type type);
    [ObsoleteAttribute("Use ImportReference", "False")]
public TypeReference Import(Type type, IGenericParameterProvider context);
    public TypeReference ImportReference(Type type, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public FieldReference Import(FieldInfo field);
    [ObsoleteAttribute("Use ImportReference", "False")]
public FieldReference Import(FieldInfo field, IGenericParameterProvider context);
    public FieldReference ImportReference(FieldInfo field);
    public FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public MethodReference Import(MethodBase method);
    [ObsoleteAttribute("Use ImportReference", "False")]
public MethodReference Import(MethodBase method, IGenericParameterProvider context);
    public MethodReference ImportReference(MethodBase method);
    public MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public TypeReference Import(TypeReference type);
    [ObsoleteAttribute("Use ImportReference", "False")]
public TypeReference Import(TypeReference type, IGenericParameterProvider context);
    public TypeReference ImportReference(TypeReference type);
    public TypeReference ImportReference(TypeReference type, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public FieldReference Import(FieldReference field);
    [ObsoleteAttribute("Use ImportReference", "False")]
public FieldReference Import(FieldReference field, IGenericParameterProvider context);
    public FieldReference ImportReference(FieldReference field);
    public FieldReference ImportReference(FieldReference field, IGenericParameterProvider context);
    [ObsoleteAttribute("Use ImportReference", "False")]
public MethodReference Import(MethodReference method);
    [ObsoleteAttribute("Use ImportReference", "False")]
public MethodReference Import(MethodReference method, IGenericParameterProvider context);
    public MethodReference ImportReference(MethodReference method);
    public MethodReference ImportReference(MethodReference method, IGenericParameterProvider context);
    public void ImportWin32Resources(ModuleDefinition source);
    public IMetadataTokenProvider LookupToken(int token);
    public IMetadataTokenProvider LookupToken(MetadataToken token);
    internal object get_SyncRoot();
    internal TRet Read(TItem item, Func`3<TItem, MetadataReader, TRet> read);
    internal TRet Read(TRet& variable, TItem item, Func`3<TItem, MetadataReader, TRet> read);
    public bool get_HasDebugHeader();
    public ResourceDirectory get_Win32ResourceDirectory();
    public void set_Win32ResourceDirectory(ResourceDirectory value);
    public ImageDebugDirectory GetDebugHeader(Byte[]& header);
    private void ProcessDebugHeader();
    public static ModuleDefinition CreateModule(string name, ModuleKind kind);
    public static ModuleDefinition CreateModule(string name, ModuleParameters parameters);
    private static AssemblyNameDefinition CreateAssemblyName(string name);
    public void ReadSymbols();
    public void ReadSymbols(ISymbolReader reader);
    public static ModuleDefinition ReadModule(string fileName);
    public static ModuleDefinition ReadModule(Stream stream);
    public static ModuleDefinition ReadModule(string fileName, ReaderParameters parameters);
    public static ModuleDefinition ReadModule(Stream stream, ReaderParameters parameters);
    private static Stream GetFileStream(string fileName, FileMode mode, FileAccess access, FileShare share);
    public void Write(string fileName);
    public void Write(Stream stream);
    public void Write(string fileName, WriterParameters parameters);
    public void Write(Stream stream, WriterParameters parameters);
}
internal enum Mono.Cecil.ModuleKind : Enum {
    public int value__;
    public static ModuleKind Dll;
    public static ModuleKind Console;
    public static ModuleKind Windows;
    public static ModuleKind NetModule;
}
internal class Mono.Cecil.ModuleParameters : object {
    private ModuleKind kind;
    private TargetRuntime runtime;
    private TargetArchitecture architecture;
    private IAssemblyResolver assembly_resolver;
    private IMetadataResolver metadata_resolver;
    private IMetadataImporterProvider metadata_importer_provider;
    private IReflectionImporterProvider reflection_importer_provider;
    public ModuleKind Kind { get; public set; }
    public TargetRuntime Runtime { get; public set; }
    public TargetArchitecture Architecture { get; public set; }
    public IAssemblyResolver AssemblyResolver { get; public set; }
    public IMetadataResolver MetadataResolver { get; public set; }
    public IMetadataImporterProvider MetadataImporterProvider { get; public set; }
    public IReflectionImporterProvider ReflectionImporterProvider { get; public set; }
    public ModuleKind get_Kind();
    public void set_Kind(ModuleKind value);
    public TargetRuntime get_Runtime();
    public void set_Runtime(TargetRuntime value);
    public TargetArchitecture get_Architecture();
    public void set_Architecture(TargetArchitecture value);
    public IAssemblyResolver get_AssemblyResolver();
    public void set_AssemblyResolver(IAssemblyResolver value);
    public IMetadataResolver get_MetadataResolver();
    public void set_MetadataResolver(IMetadataResolver value);
    public IMetadataImporterProvider get_MetadataImporterProvider();
    public void set_MetadataImporterProvider(IMetadataImporterProvider value);
    public IReflectionImporterProvider get_ReflectionImporterProvider();
    public void set_ReflectionImporterProvider(IReflectionImporterProvider value);
    private static TargetRuntime GetCurrentRuntime();
}
internal abstract class Mono.Cecil.ModuleReader : object {
    protected Image image;
    protected ModuleDefinition module;
    protected ModuleReader(Image image, ReadingMode mode);
    protected abstract virtual void ReadModule();
    protected void ReadModuleManifest(MetadataReader reader);
    private void ReadAssembly(MetadataReader reader);
    public static ModuleDefinition CreateModuleFrom(Image image, ReaderParameters parameters);
    private static void ReadSymbols(ModuleDefinition module, ReaderParameters parameters);
    private static ModuleReader CreateModuleReader(Image image, ReadingMode mode);
}
internal class Mono.Cecil.ModuleReference : object {
    private string name;
    internal MetadataToken token;
    public string Name { get; public set; }
    public MetadataScopeType MetadataScopeType { get; }
    public MetadataToken MetadataToken { get; public set; }
    public ModuleReference(string name);
    public sealed virtual string get_Name();
    public sealed virtual void set_Name(string value);
    public virtual MetadataScopeType get_MetadataScopeType();
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
}
internal class Mono.Cecil.ModuleRefTable : MetadataTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.ModuleTable : OneRowTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal static class Mono.Cecil.ModuleWriter : object {
    public static void WriteModuleTo(ModuleDefinition module, Stream stream, WriterParameters parameters);
    private static void BuildMetadata(ModuleDefinition module, MetadataBuilder metadata);
    private static ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fq_name, ISymbolWriterProvider symbol_writer_provider);
}
internal enum Mono.Cecil.NativeType : Enum {
    public int value__;
    public static NativeType None;
    public static NativeType Boolean;
    public static NativeType I1;
    public static NativeType U1;
    public static NativeType I2;
    public static NativeType U2;
    public static NativeType I4;
    public static NativeType U4;
    public static NativeType I8;
    public static NativeType U8;
    public static NativeType R4;
    public static NativeType R8;
    public static NativeType LPStr;
    public static NativeType Int;
    public static NativeType UInt;
    public static NativeType Func;
    public static NativeType Array;
    public static NativeType Currency;
    public static NativeType BStr;
    public static NativeType LPWStr;
    public static NativeType LPTStr;
    public static NativeType FixedSysString;
    public static NativeType IUnknown;
    public static NativeType IDispatch;
    public static NativeType Struct;
    public static NativeType IntF;
    public static NativeType SafeArray;
    public static NativeType FixedArray;
    public static NativeType ByValStr;
    public static NativeType ANSIBStr;
    public static NativeType TBStr;
    public static NativeType VariantBool;
    public static NativeType ASAny;
    public static NativeType LPStruct;
    public static NativeType CustomMarshaler;
    public static NativeType Error;
    public static NativeType Max;
}
internal class Mono.Cecil.NestedClassTable : SortedTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
    public virtual int Compare(Row`2<UInt32, UInt32> x, Row`2<UInt32, UInt32> y);
}
internal abstract class Mono.Cecil.OneRowTable`1 : MetadataTable {
    internal TRow row;
    public int Length { get; }
    public sealed virtual int get_Length();
    public sealed virtual void Sort();
}
internal class Mono.Cecil.OptionalModifierType : TypeSpecification {
    private TypeReference modifier_type;
    public TypeReference ModifierType { get; public set; }
    public string Name { get; }
    public string FullName { get; }
    private string Suffix { get; }
    public bool IsValueType { get; public set; }
    public bool IsOptionalModifier { get; }
    public bool ContainsGenericParameter { get; }
    public OptionalModifierType(TypeReference modifierType, TypeReference type);
    public sealed virtual TypeReference get_ModifierType();
    public void set_ModifierType(TypeReference value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsOptionalModifier();
    public virtual bool get_ContainsGenericParameter();
}
[FlagsAttribute]
internal enum Mono.Cecil.ParameterAttributes : Enum {
    public ushort value__;
    public static ParameterAttributes None;
    public static ParameterAttributes In;
    public static ParameterAttributes Out;
    public static ParameterAttributes Lcid;
    public static ParameterAttributes Retval;
    public static ParameterAttributes Optional;
    public static ParameterAttributes HasDefault;
    public static ParameterAttributes HasFieldMarshal;
    public static ParameterAttributes Unused;
}
internal class Mono.Cecil.ParameterDefinition : ParameterReference {
    private ushort attributes;
    internal IMethodSignature method;
    private object constant;
    private Collection`1<CustomAttribute> custom_attributes;
    private MarshalInfo marshal_info;
    public ParameterAttributes Attributes { get; public set; }
    public IMethodSignature Method { get; }
    public int Sequence { get; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasMarshalInfo { get; }
    public MarshalInfo MarshalInfo { get; public set; }
    public bool IsIn { get; public set; }
    public bool IsOut { get; public set; }
    public bool IsLcid { get; public set; }
    public bool IsReturnValue { get; public set; }
    public bool IsOptional { get; public set; }
    public bool HasDefault { get; public set; }
    public bool HasFieldMarshal { get; public set; }
    internal ParameterDefinition(TypeReference parameterType, IMethodSignature method);
    public ParameterDefinition(TypeReference parameterType);
    public ParameterDefinition(string name, ParameterAttributes attributes, TypeReference parameterType);
    public ParameterAttributes get_Attributes();
    public void set_Attributes(ParameterAttributes value);
    public IMethodSignature get_Method();
    public int get_Sequence();
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public sealed virtual bool get_HasMarshalInfo();
    public sealed virtual MarshalInfo get_MarshalInfo();
    public sealed virtual void set_MarshalInfo(MarshalInfo value);
    public bool get_IsIn();
    public void set_IsIn(bool value);
    public bool get_IsOut();
    public void set_IsOut(bool value);
    public bool get_IsLcid();
    public void set_IsLcid(bool value);
    public bool get_IsReturnValue();
    public void set_IsReturnValue(bool value);
    public bool get_IsOptional();
    public void set_IsOptional(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public bool get_HasFieldMarshal();
    public void set_HasFieldMarshal(bool value);
    public virtual ParameterDefinition Resolve();
}
internal class Mono.Cecil.ParameterDefinitionCollection : Collection`1<ParameterDefinition> {
    private IMethodSignature method;
    internal ParameterDefinitionCollection(IMethodSignature method);
    internal ParameterDefinitionCollection(IMethodSignature method, int capacity);
    protected virtual void OnAdd(ParameterDefinition item, int index);
    protected virtual void OnInsert(ParameterDefinition item, int index);
    protected virtual void OnSet(ParameterDefinition item, int index);
    protected virtual void OnRemove(ParameterDefinition item, int index);
}
internal abstract class Mono.Cecil.ParameterReference : object {
    private string name;
    internal int index;
    protected TypeReference parameter_type;
    internal MetadataToken token;
    public string Name { get; public set; }
    public int Index { get; }
    public TypeReference ParameterType { get; public set; }
    public MetadataToken MetadataToken { get; public set; }
    internal ParameterReference(string name, TypeReference parameterType);
    public string get_Name();
    public void set_Name(string value);
    public int get_Index();
    public TypeReference get_ParameterType();
    public void set_ParameterType(TypeReference value);
    public sealed virtual MetadataToken get_MetadataToken();
    public sealed virtual void set_MetadataToken(MetadataToken value);
    public virtual string ToString();
    public abstract virtual ParameterDefinition Resolve();
}
internal class Mono.Cecil.ParamTable : MetadataTable`1<Row`3<ParameterAttributes, ushort, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
[ExtensionAttribute]
internal static class Mono.Cecil.Pdb.GuidMapping : object {
    private static Dictionary`2<Guid, DocumentLanguage> guid_language;
    private static Dictionary`2<DocumentLanguage, Guid> language_guid;
    private static Guid type_text;
    private static Guid hash_md5;
    private static Guid hash_sha1;
    private static Guid vendor_ms;
    private static GuidMapping();
    private static void AddMapping(DocumentLanguage language, Guid guid);
    [ExtensionAttribute]
public static DocumentType ToType(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuid(DocumentType type);
    [ExtensionAttribute]
public static DocumentHashAlgorithm ToHashAlgorithm(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuid(DocumentHashAlgorithm hash_algo);
    [ExtensionAttribute]
public static DocumentLanguage ToLanguage(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuid(DocumentLanguage language);
    [ExtensionAttribute]
public static DocumentLanguageVendor ToVendor(Guid guid);
    [ExtensionAttribute]
public static Guid ToGuid(DocumentLanguageVendor vendor);
}
[GuidAttribute("BA3FEE4C-ECB9-4e41-83B7-183FA41CD859")]
[InterfaceTypeAttribute("1")]
internal interface Mono.Cecil.Pdb.IMetaDataEmit {
    public abstract virtual void SetModuleProps(string szName);
    public abstract virtual void Save(string szFile, UInt32 dwSaveFlags);
    public abstract virtual void SaveToStream(IntPtr pIStream, UInt32 dwSaveFlags);
    public abstract virtual UInt32 GetSaveSize(UInt32 fSave);
    public abstract virtual UInt32 DefineTypeDef(IntPtr szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements);
    public abstract virtual UInt32 DefineNestedType(IntPtr szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements, UInt32 tdEncloser);
    public abstract virtual void SetHandler(object pUnk);
    public abstract virtual UInt32 DefineMethod(UInt32 td, IntPtr zName, UInt32 dwMethodFlags, IntPtr pvSigBlob, UInt32 cbSigBlob, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public abstract virtual void DefineMethodImpl(UInt32 td, UInt32 tkBody, UInt32 tkDecl);
    public abstract virtual UInt32 DefineTypeRefByName(UInt32 tkResolutionScope, IntPtr szName);
    public abstract virtual UInt32 DefineImportType(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 tdImport, IntPtr pAssemEmit);
    public abstract virtual UInt32 DefineMemberRef(UInt32 tkImport, string szName, IntPtr pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 DefineImportMember(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 mbMember, IntPtr pAssemEmit, UInt32 tkParent);
    public abstract virtual UInt32 DefineEvent(UInt32 td, string szEvent, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, IntPtr rmdOtherMethods);
    public abstract virtual void SetClassLayout(UInt32 td, UInt32 dwPackSize, IntPtr rFieldOffsets, UInt32 ulClassSize);
    public abstract virtual void DeleteClassLayout(UInt32 td);
    public abstract virtual void SetFieldMarshal(UInt32 tk, IntPtr pvNativeType, UInt32 cbNativeType);
    public abstract virtual void DeleteFieldMarshal(UInt32 tk);
    public abstract virtual UInt32 DefinePermissionSet(UInt32 tk, UInt32 dwAction, IntPtr pvPermission, UInt32 cbPermission);
    public abstract virtual void SetRVA(UInt32 md, UInt32 ulRVA);
    public abstract virtual UInt32 GetTokenFromSig(IntPtr pvSig, UInt32 cbSig);
    public abstract virtual UInt32 DefineModuleRef(string szName);
    public abstract virtual void SetParent(UInt32 mr, UInt32 tk);
    public abstract virtual UInt32 GetTokenFromTypeSpec(IntPtr pvSig, UInt32 cbSig);
    public abstract virtual void SaveToMemory(IntPtr pbData, UInt32 cbData);
    public abstract virtual UInt32 DefineUserString(string szString, UInt32 cchString);
    public abstract virtual void DeleteToken(UInt32 tkObj);
    public abstract virtual void SetMethodProps(UInt32 md, UInt32 dwMethodFlags, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public abstract virtual void SetTypeDefProps(UInt32 td, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements);
    public abstract virtual void SetEventProps(UInt32 ev, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, IntPtr rmdOtherMethods);
    public abstract virtual UInt32 SetPermissionSetProps(UInt32 tk, UInt32 dwAction, IntPtr pvPermission, UInt32 cbPermission);
    public abstract virtual void DefinePinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    public abstract virtual void SetPinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    public abstract virtual void DeletePinvokeMap(UInt32 tk);
    public abstract virtual UInt32 DefineCustomAttribute(UInt32 tkObj, UInt32 tkType, IntPtr pCustomAttribute, UInt32 cbCustomAttribute);
    public abstract virtual void SetCustomAttributeValue(UInt32 pcv, IntPtr pCustomAttribute, UInt32 cbCustomAttribute);
    public abstract virtual UInt32 DefineField(UInt32 td, string szName, UInt32 dwFieldFlags, IntPtr pvSigBlob, UInt32 cbSigBlob, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public abstract virtual UInt32 DefineProperty(UInt32 td, string szProperty, UInt32 dwPropFlags, IntPtr pvSig, UInt32 cbSig, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, IntPtr rmdOtherMethods);
    public abstract virtual UInt32 DefineParam(UInt32 md, UInt32 ulParamSeq, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public abstract virtual void SetFieldProps(UInt32 fd, UInt32 dwFieldFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public abstract virtual void SetPropertyProps(UInt32 pr, UInt32 dwPropFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, IntPtr rmdOtherMethods);
    public abstract virtual void SetParamProps(UInt32 pd, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public abstract virtual UInt32 DefineSecurityAttributeSet(UInt32 tkObj, IntPtr rSecAttrs, UInt32 cSecAttrs);
    public abstract virtual void ApplyEditAndContinue(object pImport);
    public abstract virtual UInt32 TranslateSigWithScope(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport import, IntPtr pbSigBlob, UInt32 cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, IntPtr pvTranslatedSig, UInt32 cbTranslatedSigMax);
    public abstract virtual void SetMethodImplFlags(UInt32 md, UInt32 dwImplFlags);
    public abstract virtual void SetFieldRVA(UInt32 fd, UInt32 ulRVA);
    public abstract virtual void Merge(IMetaDataImport pImport, IntPtr pHostMapToken, object pHandler);
    public abstract virtual void MergeEnd();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("7DAC8207-D3AE-4c75-9B67-92801A497D44")]
internal interface Mono.Cecil.Pdb.IMetaDataImport {
    public abstract virtual void CloseEnum(UInt32 hEnum);
    public abstract virtual UInt32 CountEnum(UInt32 hEnum);
    public abstract virtual void ResetEnum(UInt32 hEnum, UInt32 ulPos);
    public abstract virtual UInt32 EnumTypeDefs(UInt32& phEnum, UInt32[] rTypeDefs, UInt32 cMax);
    public abstract virtual UInt32 EnumInterfaceImpls(UInt32& phEnum, UInt32 td, UInt32[] rImpls, UInt32 cMax);
    public abstract virtual UInt32 EnumTypeRefs(UInt32& phEnum, UInt32[] rTypeRefs, UInt32 cMax);
    public abstract virtual UInt32 FindTypeDefByName(string szTypeDef, UInt32 tkEnclosingClass);
    public abstract virtual Guid GetScopeProps(StringBuilder szName, UInt32 cchName, UInt32& pchName);
    public abstract virtual UInt32 GetModuleFromScope();
    public abstract virtual UInt32 GetTypeDefProps(UInt32 td, IntPtr szTypeDef, UInt32 cchTypeDef, UInt32& pchTypeDef, IntPtr pdwTypeDefFlags);
    public abstract virtual UInt32 GetInterfaceImplProps(UInt32 iiImpl, UInt32& pClass);
    public abstract virtual UInt32 GetTypeRefProps(UInt32 tr, UInt32& ptkResolutionScope, StringBuilder szName, UInt32 cchName);
    public abstract virtual UInt32 ResolveTypeRef(UInt32 tr, Guid& riid, Object& ppIScope);
    public abstract virtual UInt32 EnumMembers(UInt32& phEnum, UInt32 cl, UInt32[] rMembers, UInt32 cMax);
    public abstract virtual UInt32 EnumMembersWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMembers, UInt32 cMax);
    public abstract virtual UInt32 EnumMethods(UInt32& phEnum, UInt32 cl, IntPtr rMethods, UInt32 cMax);
    public abstract virtual UInt32 EnumMethodsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMethods, UInt32 cMax);
    public abstract virtual UInt32 EnumFields(UInt32& phEnum, UInt32 cl, IntPtr rFields, UInt32 cMax);
    public abstract virtual UInt32 EnumFieldsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rFields, UInt32 cMax);
    public abstract virtual UInt32 EnumParams(UInt32& phEnum, UInt32 mb, UInt32[] rParams, UInt32 cMax);
    public abstract virtual UInt32 EnumMemberRefs(UInt32& phEnum, UInt32 tkParent, UInt32[] rMemberRefs, UInt32 cMax);
    public abstract virtual UInt32 EnumMethodImpls(UInt32& phEnum, UInt32 td, UInt32[] rMethodBody, UInt32[] rMethodDecl, UInt32 cMax);
    public abstract virtual UInt32 EnumPermissionSets(UInt32& phEnum, UInt32 tk, UInt32 dwActions, UInt32[] rPermission, UInt32 cMax);
    public abstract virtual UInt32 FindMember(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 FindMethod(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 FindField(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 FindMemberRef(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public abstract virtual UInt32 GetMethodProps(UInt32 mb, UInt32& pClass, IntPtr szMethod, UInt32 cchMethod, UInt32& pchMethod, IntPtr pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, IntPtr pulCodeRVA);
    public abstract virtual UInt32 GetMemberRefProps(UInt32 mr, UInt32& ptk, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, IntPtr& ppvSigBlob);
    public abstract virtual UInt32 EnumProperties(UInt32& phEnum, UInt32 td, IntPtr rProperties, UInt32 cMax);
    public abstract virtual UInt32 EnumEvents(UInt32& phEnum, UInt32 td, IntPtr rEvents, UInt32 cMax);
    public abstract virtual UInt32 GetEventProps(UInt32 ev, UInt32& pClass, StringBuilder szEvent, UInt32 cchEvent, UInt32& pchEvent, UInt32& pdwEventFlags, UInt32& ptkEventType, UInt32& pmdAddOn, UInt32& pmdRemoveOn, UInt32& pmdFire, UInt32[] rmdOtherMethod, UInt32 cMax);
    public abstract virtual UInt32 EnumMethodSemantics(UInt32& phEnum, UInt32 mb, UInt32[] rEventProp, UInt32 cMax);
    public abstract virtual UInt32 GetMethodSemantics(UInt32 mb, UInt32 tkEventProp);
    public abstract virtual UInt32 GetClassLayout(UInt32 td, UInt32& pdwPackSize, IntPtr rFieldOffset, UInt32 cMax, UInt32& pcFieldOffset);
    public abstract virtual UInt32 GetFieldMarshal(UInt32 tk, IntPtr& ppvNativeType);
    public abstract virtual UInt32 GetRVA(UInt32 tk, UInt32& pulCodeRVA);
    public abstract virtual UInt32 GetPermissionSetProps(UInt32 pm, UInt32& pdwAction, IntPtr& ppvPermission);
    public abstract virtual UInt32 GetSigFromToken(UInt32 mdSig, IntPtr& ppvSig);
    public abstract virtual UInt32 GetModuleRefProps(UInt32 mur, StringBuilder szName, UInt32 cchName);
    public abstract virtual UInt32 EnumModuleRefs(UInt32& phEnum, UInt32[] rModuleRefs, UInt32 cmax);
    public abstract virtual UInt32 GetTypeSpecFromToken(UInt32 typespec, IntPtr& ppvSig);
    public abstract virtual UInt32 GetNameFromToken(UInt32 tk);
    public abstract virtual UInt32 EnumUnresolvedMethods(UInt32& phEnum, UInt32[] rMethods, UInt32 cMax);
    public abstract virtual UInt32 GetUserString(UInt32 stk, StringBuilder szString, UInt32 cchString);
    public abstract virtual UInt32 GetPinvokeMap(UInt32 tk, UInt32& pdwMappingFlags, StringBuilder szImportName, UInt32 cchImportName, UInt32& pchImportName);
    public abstract virtual UInt32 EnumSignatures(UInt32& phEnum, UInt32[] rSignatures, UInt32 cmax);
    public abstract virtual UInt32 EnumTypeSpecs(UInt32& phEnum, UInt32[] rTypeSpecs, UInt32 cmax);
    public abstract virtual UInt32 EnumUserStrings(UInt32& phEnum, UInt32[] rStrings, UInt32 cmax);
    public abstract virtual int GetParamForMethodIndex(UInt32 md, UInt32 ulParamSeq, UInt32& pParam);
    public abstract virtual UInt32 EnumCustomAttributes(UInt32& phEnum, UInt32 tk, UInt32 tkType, UInt32[] rCustomAttributes, UInt32 cMax);
    public abstract virtual UInt32 GetCustomAttributeProps(UInt32 cv, UInt32& ptkObj, UInt32& ptkType, IntPtr& ppBlob);
    public abstract virtual UInt32 FindTypeRef(UInt32 tkResolutionScope, string szName);
    public abstract virtual UInt32 GetMemberProps(UInt32 mb, UInt32& pClass, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, UInt32& pdwAttr, IntPtr& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pulCodeRVA, UInt32& pdwImplFlags, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public abstract virtual UInt32 GetFieldProps(UInt32 mb, UInt32& pClass, StringBuilder szField, UInt32 cchField, UInt32& pchField, UInt32& pdwAttr, IntPtr& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public abstract virtual UInt32 GetPropertyProps(UInt32 prop, UInt32& pClass, StringBuilder szProperty, UInt32 cchProperty, UInt32& pchProperty, UInt32& pdwPropFlags, IntPtr& ppvSig, UInt32& pbSig, UInt32& pdwCPlusTypeFlag, IntPtr& ppDefaultValue, UInt32& pcchDefaultValue, UInt32& pmdSetter, UInt32& pmdGetter, UInt32[] rmdOtherMethod, UInt32 cMax);
    public abstract virtual UInt32 GetParamProps(UInt32 tk, UInt32& pmd, UInt32& pulSequence, StringBuilder szName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public abstract virtual UInt32 GetCustomAttributeByName(UInt32 tkObj, string szName, IntPtr& ppData);
    public abstract virtual bool IsValidToken(UInt32 tk);
    public abstract virtual UInt32 GetNestedClassProps(UInt32 tdNestedClass);
    public abstract virtual UInt32 GetNativeCallConvFromSig(IntPtr pvSig, UInt32 cbSig);
    public abstract virtual int IsGlobal(UInt32 pd);
}
[GuidAttribute("B01FAFEB-C450-3A4D-BEEC-B4CEEC01E006")]
[InterfaceTypeAttribute("1")]
internal interface Mono.Cecil.Pdb.ISymUnmanagedDocumentWriter {
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("0B97726E-9E6D-4f05-9A26-424022093CAA")]
internal interface Mono.Cecil.Pdb.ISymUnmanagedWriter2 {
    public abstract virtual void DefineDocument(string url, Guid& langauge, Guid& languageVendor, Guid& documentType, ISymUnmanagedDocumentWriter& pRetVal);
    public abstract virtual void SetUserEntryPoint(SymbolToken method);
    public abstract virtual void OpenMethod(SymbolToken method);
    public abstract virtual void CloseMethod();
    public abstract virtual void OpenScope(int startOffset, Int32& pRetVal);
    public abstract virtual void CloseScope(int endOffset);
    public abstract virtual void SetScopeRange_Placeholder();
    public abstract virtual void DefineLocalVariable_Placeholder();
    public abstract virtual void DefineParameter_Placeholder();
    public abstract virtual void DefineField_Placeholder();
    public abstract virtual void DefineGlobalVariable_Placeholder();
    public abstract virtual void Close();
    public abstract virtual void SetSymAttribute_Placeholder();
    public abstract virtual void OpenNamespace(string name);
    public abstract virtual void CloseNamespace();
    public abstract virtual void UsingNamespace(string fullName);
    public abstract virtual void SetMethodSourceRange_Placeholder();
    public abstract virtual void Initialize(object emitter, string filename, IStream pIStream, bool fFullBuild);
    public abstract virtual void GetDebugInfo(ImageDebugDirectory& pIDD, int cData, Int32& pcData, Byte[] data);
    public abstract virtual void DefineSequencePoints(ISymUnmanagedDocumentWriter document, int spCount, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public abstract virtual void RemapToken_Placeholder();
    public abstract virtual void Initialize2_Placeholder();
    public abstract virtual void DefineConstant_Placeholder();
    public abstract virtual void Abort_Placeholder();
    public abstract virtual void DefineLocalVariable2(string name, int attributes, SymbolToken sigToken, int addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);
}
internal class Mono.Cecil.Pdb.ModuleMetadata : object {
    private ModuleDefinition module;
    private Dictionary`2<UInt32, TypeDefinition> types;
    private Dictionary`2<UInt32, MethodDefinition> methods;
    public ModuleMetadata(ModuleDefinition module);
    private bool TryGetType(UInt32 token, TypeDefinition& type);
    private bool TryGetMethod(UInt32 token, MethodDefinition& method);
    private void InitializeMetadata(ModuleDefinition module);
    private void InitializeMethods(TypeDefinition type);
    public sealed virtual void SetModuleProps(string szName);
    public sealed virtual void Save(string szFile, UInt32 dwSaveFlags);
    public sealed virtual void SaveToStream(IntPtr pIStream, UInt32 dwSaveFlags);
    public sealed virtual UInt32 GetSaveSize(UInt32 fSave);
    public sealed virtual UInt32 DefineTypeDef(IntPtr szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements);
    public sealed virtual UInt32 DefineNestedType(IntPtr szTypeDef, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements, UInt32 tdEncloser);
    public sealed virtual void SetHandler(object pUnk);
    public sealed virtual UInt32 DefineMethod(UInt32 td, IntPtr zName, UInt32 dwMethodFlags, IntPtr pvSigBlob, UInt32 cbSigBlob, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public sealed virtual void DefineMethodImpl(UInt32 td, UInt32 tkBody, UInt32 tkDecl);
    public sealed virtual UInt32 DefineTypeRefByName(UInt32 tkResolutionScope, IntPtr szName);
    public sealed virtual UInt32 DefineImportType(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 tdImport, IntPtr pAssemEmit);
    public sealed virtual UInt32 DefineMemberRef(UInt32 tkImport, string szName, IntPtr pvSigBlob, UInt32 cbSigBlob);
    public sealed virtual UInt32 DefineImportMember(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport pImport, UInt32 mbMember, IntPtr pAssemEmit, UInt32 tkParent);
    public sealed virtual UInt32 DefineEvent(UInt32 td, string szEvent, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, IntPtr rmdOtherMethods);
    public sealed virtual void SetClassLayout(UInt32 td, UInt32 dwPackSize, IntPtr rFieldOffsets, UInt32 ulClassSize);
    public sealed virtual void DeleteClassLayout(UInt32 td);
    public sealed virtual void SetFieldMarshal(UInt32 tk, IntPtr pvNativeType, UInt32 cbNativeType);
    public sealed virtual void DeleteFieldMarshal(UInt32 tk);
    public sealed virtual UInt32 DefinePermissionSet(UInt32 tk, UInt32 dwAction, IntPtr pvPermission, UInt32 cbPermission);
    public sealed virtual void SetRVA(UInt32 md, UInt32 ulRVA);
    public sealed virtual UInt32 GetTokenFromSig(IntPtr pvSig, UInt32 cbSig);
    public sealed virtual UInt32 DefineModuleRef(string szName);
    public sealed virtual void SetParent(UInt32 mr, UInt32 tk);
    public sealed virtual UInt32 GetTokenFromTypeSpec(IntPtr pvSig, UInt32 cbSig);
    public sealed virtual void SaveToMemory(IntPtr pbData, UInt32 cbData);
    public sealed virtual UInt32 DefineUserString(string szString, UInt32 cchString);
    public sealed virtual void DeleteToken(UInt32 tkObj);
    public sealed virtual void SetMethodProps(UInt32 md, UInt32 dwMethodFlags, UInt32 ulCodeRVA, UInt32 dwImplFlags);
    public sealed virtual void SetTypeDefProps(UInt32 td, UInt32 dwTypeDefFlags, UInt32 tkExtends, IntPtr rtkImplements);
    public sealed virtual void SetEventProps(UInt32 ev, UInt32 dwEventFlags, UInt32 tkEventType, UInt32 mdAddOn, UInt32 mdRemoveOn, UInt32 mdFire, IntPtr rmdOtherMethods);
    public sealed virtual UInt32 SetPermissionSetProps(UInt32 tk, UInt32 dwAction, IntPtr pvPermission, UInt32 cbPermission);
    public sealed virtual void DefinePinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    public sealed virtual void SetPinvokeMap(UInt32 tk, UInt32 dwMappingFlags, string szImportName, UInt32 mrImportDLL);
    public sealed virtual void DeletePinvokeMap(UInt32 tk);
    public sealed virtual UInt32 DefineCustomAttribute(UInt32 tkObj, UInt32 tkType, IntPtr pCustomAttribute, UInt32 cbCustomAttribute);
    public sealed virtual void SetCustomAttributeValue(UInt32 pcv, IntPtr pCustomAttribute, UInt32 cbCustomAttribute);
    public sealed virtual UInt32 DefineField(UInt32 td, string szName, UInt32 dwFieldFlags, IntPtr pvSigBlob, UInt32 cbSigBlob, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public sealed virtual UInt32 DefineProperty(UInt32 td, string szProperty, UInt32 dwPropFlags, IntPtr pvSig, UInt32 cbSig, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, IntPtr rmdOtherMethods);
    public sealed virtual UInt32 DefineParam(UInt32 md, UInt32 ulParamSeq, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public sealed virtual void SetFieldProps(UInt32 fd, UInt32 dwFieldFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public sealed virtual void SetPropertyProps(UInt32 pr, UInt32 dwPropFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue, UInt32 mdSetter, UInt32 mdGetter, IntPtr rmdOtherMethods);
    public sealed virtual void SetParamProps(UInt32 pd, string szName, UInt32 dwParamFlags, UInt32 dwCPlusTypeFlag, IntPtr pValue, UInt32 cchValue);
    public sealed virtual UInt32 DefineSecurityAttributeSet(UInt32 tkObj, IntPtr rSecAttrs, UInt32 cSecAttrs);
    public sealed virtual void ApplyEditAndContinue(object pImport);
    public sealed virtual UInt32 TranslateSigWithScope(IntPtr pAssemImport, IntPtr pbHashValue, UInt32 cbHashValue, IMetaDataImport import, IntPtr pbSigBlob, UInt32 cbSigBlob, IntPtr pAssemEmit, IMetaDataEmit emit, IntPtr pvTranslatedSig, UInt32 cbTranslatedSigMax);
    public sealed virtual void SetMethodImplFlags(UInt32 md, UInt32 dwImplFlags);
    public sealed virtual void SetFieldRVA(UInt32 fd, UInt32 ulRVA);
    public sealed virtual void Merge(IMetaDataImport pImport, IntPtr pHostMapToken, object pHandler);
    public sealed virtual void MergeEnd();
    public sealed virtual void CloseEnum(UInt32 hEnum);
    public sealed virtual UInt32 CountEnum(UInt32 hEnum);
    public sealed virtual void ResetEnum(UInt32 hEnum, UInt32 ulPos);
    public sealed virtual UInt32 EnumTypeDefs(UInt32& phEnum, UInt32[] rTypeDefs, UInt32 cMax);
    public sealed virtual UInt32 EnumInterfaceImpls(UInt32& phEnum, UInt32 td, UInt32[] rImpls, UInt32 cMax);
    public sealed virtual UInt32 EnumTypeRefs(UInt32& phEnum, UInt32[] rTypeRefs, UInt32 cMax);
    public sealed virtual UInt32 FindTypeDefByName(string szTypeDef, UInt32 tkEnclosingClass);
    public sealed virtual Guid GetScopeProps(StringBuilder szName, UInt32 cchName, UInt32& pchName);
    public sealed virtual UInt32 GetModuleFromScope();
    public sealed virtual UInt32 GetTypeDefProps(UInt32 td, IntPtr szTypeDef, UInt32 cchTypeDef, UInt32& pchTypeDef, IntPtr pdwTypeDefFlags);
    private static void WriteIntPtr(IntPtr ptr, UInt32 value);
    private static void WriteString(string str, IntPtr buffer, UInt32 bufferSize, UInt32& chars);
    public sealed virtual UInt32 GetInterfaceImplProps(UInt32 iiImpl, UInt32& pClass);
    public sealed virtual UInt32 GetTypeRefProps(UInt32 tr, UInt32& ptkResolutionScope, StringBuilder szName, UInt32 cchName);
    public sealed virtual UInt32 ResolveTypeRef(UInt32 tr, Guid& riid, Object& ppIScope);
    public sealed virtual UInt32 EnumMembers(UInt32& phEnum, UInt32 cl, UInt32[] rMembers, UInt32 cMax);
    public sealed virtual UInt32 EnumMembersWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMembers, UInt32 cMax);
    public sealed virtual UInt32 EnumMethods(UInt32& phEnum, UInt32 cl, IntPtr rMethods, UInt32 cMax);
    public sealed virtual UInt32 EnumMethodsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rMethods, UInt32 cMax);
    public sealed virtual UInt32 EnumFields(UInt32& phEnum, UInt32 cl, IntPtr rFields, UInt32 cMax);
    public sealed virtual UInt32 EnumFieldsWithName(UInt32& phEnum, UInt32 cl, string szName, UInt32[] rFields, UInt32 cMax);
    public sealed virtual UInt32 EnumParams(UInt32& phEnum, UInt32 mb, UInt32[] rParams, UInt32 cMax);
    public sealed virtual UInt32 EnumMemberRefs(UInt32& phEnum, UInt32 tkParent, UInt32[] rMemberRefs, UInt32 cMax);
    public sealed virtual UInt32 EnumMethodImpls(UInt32& phEnum, UInt32 td, UInt32[] rMethodBody, UInt32[] rMethodDecl, UInt32 cMax);
    public sealed virtual UInt32 EnumPermissionSets(UInt32& phEnum, UInt32 tk, UInt32 dwActions, UInt32[] rPermission, UInt32 cMax);
    public sealed virtual UInt32 FindMember(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public sealed virtual UInt32 FindMethod(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public sealed virtual UInt32 FindField(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public sealed virtual UInt32 FindMemberRef(UInt32 td, string szName, Byte[] pvSigBlob, UInt32 cbSigBlob);
    public sealed virtual UInt32 GetMethodProps(UInt32 mb, UInt32& pClass, IntPtr szMethod, UInt32 cchMethod, UInt32& pchMethod, IntPtr pdwAttr, IntPtr ppvSigBlob, IntPtr pcbSigBlob, IntPtr pulCodeRVA);
    public sealed virtual UInt32 GetMemberRefProps(UInt32 mr, UInt32& ptk, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, IntPtr& ppvSigBlob);
    public sealed virtual UInt32 EnumProperties(UInt32& phEnum, UInt32 td, IntPtr rProperties, UInt32 cMax);
    public sealed virtual UInt32 EnumEvents(UInt32& phEnum, UInt32 td, IntPtr rEvents, UInt32 cMax);
    public sealed virtual UInt32 GetEventProps(UInt32 ev, UInt32& pClass, StringBuilder szEvent, UInt32 cchEvent, UInt32& pchEvent, UInt32& pdwEventFlags, UInt32& ptkEventType, UInt32& pmdAddOn, UInt32& pmdRemoveOn, UInt32& pmdFire, UInt32[] rmdOtherMethod, UInt32 cMax);
    public sealed virtual UInt32 EnumMethodSemantics(UInt32& phEnum, UInt32 mb, UInt32[] rEventProp, UInt32 cMax);
    public sealed virtual UInt32 GetMethodSemantics(UInt32 mb, UInt32 tkEventProp);
    public sealed virtual UInt32 GetClassLayout(UInt32 td, UInt32& pdwPackSize, IntPtr rFieldOffset, UInt32 cMax, UInt32& pcFieldOffset);
    public sealed virtual UInt32 GetFieldMarshal(UInt32 tk, IntPtr& ppvNativeType);
    public sealed virtual UInt32 GetRVA(UInt32 tk, UInt32& pulCodeRVA);
    public sealed virtual UInt32 GetPermissionSetProps(UInt32 pm, UInt32& pdwAction, IntPtr& ppvPermission);
    public sealed virtual UInt32 GetSigFromToken(UInt32 mdSig, IntPtr& ppvSig);
    public sealed virtual UInt32 GetModuleRefProps(UInt32 mur, StringBuilder szName, UInt32 cchName);
    public sealed virtual UInt32 EnumModuleRefs(UInt32& phEnum, UInt32[] rModuleRefs, UInt32 cmax);
    public sealed virtual UInt32 GetTypeSpecFromToken(UInt32 typespec, IntPtr& ppvSig);
    public sealed virtual UInt32 GetNameFromToken(UInt32 tk);
    public sealed virtual UInt32 EnumUnresolvedMethods(UInt32& phEnum, UInt32[] rMethods, UInt32 cMax);
    public sealed virtual UInt32 GetUserString(UInt32 stk, StringBuilder szString, UInt32 cchString);
    public sealed virtual UInt32 GetPinvokeMap(UInt32 tk, UInt32& pdwMappingFlags, StringBuilder szImportName, UInt32 cchImportName, UInt32& pchImportName);
    public sealed virtual UInt32 EnumSignatures(UInt32& phEnum, UInt32[] rSignatures, UInt32 cmax);
    public sealed virtual UInt32 EnumTypeSpecs(UInt32& phEnum, UInt32[] rTypeSpecs, UInt32 cmax);
    public sealed virtual UInt32 EnumUserStrings(UInt32& phEnum, UInt32[] rStrings, UInt32 cmax);
    public sealed virtual int GetParamForMethodIndex(UInt32 md, UInt32 ulParamSeq, UInt32& pParam);
    public sealed virtual UInt32 EnumCustomAttributes(UInt32& phEnum, UInt32 tk, UInt32 tkType, UInt32[] rCustomAttributes, UInt32 cMax);
    public sealed virtual UInt32 GetCustomAttributeProps(UInt32 cv, UInt32& ptkObj, UInt32& ptkType, IntPtr& ppBlob);
    public sealed virtual UInt32 FindTypeRef(UInt32 tkResolutionScope, string szName);
    public sealed virtual UInt32 GetMemberProps(UInt32 mb, UInt32& pClass, StringBuilder szMember, UInt32 cchMember, UInt32& pchMember, UInt32& pdwAttr, IntPtr& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pulCodeRVA, UInt32& pdwImplFlags, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public sealed virtual UInt32 GetFieldProps(UInt32 mb, UInt32& pClass, StringBuilder szField, UInt32 cchField, UInt32& pchField, UInt32& pdwAttr, IntPtr& ppvSigBlob, UInt32& pcbSigBlob, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public sealed virtual UInt32 GetPropertyProps(UInt32 prop, UInt32& pClass, StringBuilder szProperty, UInt32 cchProperty, UInt32& pchProperty, UInt32& pdwPropFlags, IntPtr& ppvSig, UInt32& pbSig, UInt32& pdwCPlusTypeFlag, IntPtr& ppDefaultValue, UInt32& pcchDefaultValue, UInt32& pmdSetter, UInt32& pmdGetter, UInt32[] rmdOtherMethod, UInt32 cMax);
    public sealed virtual UInt32 GetParamProps(UInt32 tk, UInt32& pmd, UInt32& pulSequence, StringBuilder szName, UInt32 cchName, UInt32& pchName, UInt32& pdwAttr, UInt32& pdwCPlusTypeFlag, IntPtr& ppValue);
    public sealed virtual UInt32 GetCustomAttributeByName(UInt32 tkObj, string szName, IntPtr& ppData);
    public sealed virtual bool IsValidToken(UInt32 tk);
    public sealed virtual UInt32 GetNestedClassProps(UInt32 tdNestedClass);
    public sealed virtual UInt32 GetNativeCallConvFromSig(IntPtr pvSig, UInt32 cbSig);
    public sealed virtual int IsGlobal(UInt32 pd);
}
internal class Mono.Cecil.Pdb.PdbHelper : object {
    public static SymWriter CreateWriter(ModuleDefinition module, string pdb);
    public static string GetPdbFileName(string assemblyFileName);
}
internal class Mono.Cecil.Pdb.PdbReader : object {
    private int age;
    private Guid guid;
    private Stream pdb_file;
    private Dictionary`2<string, Document> documents;
    private Dictionary`2<UInt32, PdbFunction> functions;
    internal PdbReader(Stream file);
    public sealed virtual bool ProcessDebugHeader(ImageDebugDirectory directory, Byte[] header);
    private static int ReadInt32(Byte[] bytes, int start);
    private bool PopulateFunctions();
    public sealed virtual void Read(MethodBody body, InstructionMapper mapper);
    private static void ReadScopeAndLocals(PdbScope[] scopes, Scope parent, MethodBody body, InstructionMapper mapper);
    private static void CreateRootScope(MethodBody body);
    private static void ReadScopeAndLocals(PdbScope scope, Scope parent, MethodBody body, InstructionMapper mapper);
    private void ReadSequencePoints(PdbFunction function, InstructionMapper mapper);
    private void ReadLines(PdbLines lines, InstructionMapper mapper);
    private static void ReadLine(PdbLine line, Document document, InstructionMapper mapper);
    private Document GetDocument(PdbSource source);
    public sealed virtual void Read(MethodSymbols symbols);
    private void ReadLocals(PdbScope[] scopes, MethodSymbols symbols);
    private void ReadLocals(PdbScope scope, MethodSymbols symbols);
    private void ReadSequencePoints(PdbFunction function, MethodSymbols symbols);
    private void ReadLines(PdbLines lines, MethodSymbols symbols);
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Pdb.PdbReaderProvider : object {
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolReader GetSymbolReader(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Pdb.PdbWriter : object {
    private ModuleDefinition module;
    private SymWriter writer;
    private Dictionary`2<string, SymDocumentWriter> documents;
    internal PdbWriter(ModuleDefinition module, SymWriter writer);
    public sealed virtual bool GetDebugHeader(ImageDebugDirectory& directory, Byte[]& header);
    public sealed virtual void Write(MethodBody body);
    private Collection`1<Instruction> CollectInstructions(MethodBody body);
    private void DefineVariables(MethodBody body, int start_offset, int end_offset);
    private void DefineSequencePoints(Collection`1<Instruction> instructions);
    private void CreateLocalVariable(VariableDefinition variable, SymbolToken local_var_token, int start_offset, int end_offset);
    private SymDocumentWriter GetDocument(Document document);
    public sealed virtual void Write(MethodSymbols symbols);
    private void DefineSequencePoints(MethodSymbols symbols);
    private void DefineVariables(MethodSymbols symbols, int start_offset, int end_offset);
    public sealed virtual void Dispose();
}
internal class Mono.Cecil.Pdb.PdbWriterProvider : object {
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, string fileName);
    public sealed virtual ISymbolWriter GetSymbolWriter(ModuleDefinition module, Stream symbolStream);
}
internal class Mono.Cecil.Pdb.SymDocumentWriter : object {
    private ISymUnmanagedDocumentWriter m_unmanagedDocumentWriter;
    public SymDocumentWriter(ISymUnmanagedDocumentWriter unmanagedDocumentWriter);
    public ISymUnmanagedDocumentWriter GetUnmanaged();
}
internal class Mono.Cecil.Pdb.SymWriter : object {
    private static Guid s_symUnmangedWriterIID;
    private static Guid s_CorSymWriter_SxS_ClassID;
    private ISymUnmanagedWriter2 m_writer;
    private Collection`1<ISymUnmanagedDocumentWriter> documents;
    private static SymWriter();
    private static int CoCreateInstance(Guid& rclsid, object pUnkOuter, UInt32 dwClsContext, Guid& riid, Object& ppv);
    public Byte[] GetDebugInfo(ImageDebugDirectory& idd);
    public void DefineLocalVariable2(string name, FieldAttributes attributes, SymbolToken sigToken, SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);
    public void Close();
    public void CloseMethod();
    public void CloseNamespace();
    public void CloseScope(int endOffset);
    public SymDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    public void DefineParameter(string name, ParameterAttributes attributes, int sequence, SymAddressKind addrKind, int addr1, int addr2, int addr3);
    public void DefineSequencePoints(SymDocumentWriter document, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public void Initialize(object emitter, string filename, bool fFullBuild);
    public void SetUserEntryPoint(SymbolToken method);
    public void OpenMethod(SymbolToken method);
    public void OpenNamespace(string name);
    public int OpenScope(int startOffset);
    public void UsingNamespace(string fullName);
}
internal class Mono.Cecil.PE.BinaryStreamReader : BinaryReader {
    public BinaryStreamReader(Stream stream);
    protected void Advance(int bytes);
    protected DataDirectory ReadDataDirectory();
}
internal class Mono.Cecil.PE.BinaryStreamWriter : BinaryWriter {
    public BinaryStreamWriter(Stream stream);
    public void WriteByte(byte value);
    public void WriteUInt16(ushort value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteInt32(int value);
    public void WriteUInt64(ulong value);
    public void WriteBytes(Byte[] bytes);
    public void WriteDataDirectory(DataDirectory directory);
    public void WriteBuffer(ByteBuffer buffer);
    protected void Advance(int bytes);
}
internal class Mono.Cecil.PE.ByteBuffer : object {
    internal Byte[] buffer;
    internal int length;
    internal int position;
    public ByteBuffer(int length);
    public ByteBuffer(Byte[] buffer);
    public void Reset(Byte[] buffer);
    public void Advance(int length);
    public byte ReadByte();
    public sbyte ReadSByte();
    public Byte[] ReadBytes(int length);
    public ushort ReadUInt16();
    public short ReadInt16();
    public UInt32 ReadUInt32();
    public int ReadInt32();
    public ulong ReadUInt64();
    public long ReadInt64();
    public UInt32 ReadCompressedUInt32();
    public int ReadCompressedInt32();
    public float ReadSingle();
    public double ReadDouble();
    public void WriteByte(byte value);
    public void WriteSByte(sbyte value);
    public void WriteUInt16(ushort value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteInt32(int value);
    public void WriteUInt64(ulong value);
    public void WriteInt64(long value);
    public void WriteCompressedUInt32(UInt32 value);
    public void WriteCompressedInt32(int value);
    public void WriteBytes(Byte[] bytes);
    public void WriteBytes(int length);
    public void WriteBytes(ByteBuffer buffer);
    public void WriteSingle(float value);
    public void WriteDouble(double value);
    private void Grow(int desired);
    public void Align(int alignment);
}
internal class Mono.Cecil.PE.ByteBufferEqualityComparer : object {
    public sealed virtual bool Equals(ByteBuffer x, ByteBuffer y);
    public sealed virtual int GetHashCode(ByteBuffer buffer);
}
internal class Mono.Cecil.PE.DataDirectory : ValueType {
    public UInt32 VirtualAddress;
    public UInt32 Size;
    public bool IsZero { get; }
    public DataDirectory(UInt32 rva, UInt32 size);
    public bool get_IsZero();
}
internal class Mono.Cecil.PE.EntryComparer : object {
    internal static EntryComparer INSTANCE;
    private static EntryComparer();
    public sealed virtual int Compare(ResourceEntry x, ResourceEntry y);
}
internal class Mono.Cecil.PE.Image : object {
    public ModuleKind Kind;
    public string RuntimeVersion;
    public TargetArchitecture Architecture;
    public ModuleCharacteristics Characteristics;
    public string FileName;
    public Section[] Sections;
    public Section MetadataSection;
    public UInt32 EntryPointToken;
    public ModuleAttributes Attributes;
    public DataDirectory Debug;
    public DataDirectory Resources;
    public DataDirectory StrongName;
    public StringHeap StringHeap;
    public BlobHeap BlobHeap;
    public UserStringHeap UserStringHeap;
    public GuidHeap GuidHeap;
    public TableHeap TableHeap;
    private Int32[] coded_index_sizes;
    private Func`2<Table, int> counter;
    public bool HasTable(Table table);
    public int GetTableLength(Table table);
    public int GetTableIndexSize(Table table);
    public int GetCodedIndexSize(CodedIndex coded_index);
    public UInt32 ResolveVirtualAddress(UInt32 rva);
    public UInt32 ResolveVirtualAddressInSection(UInt32 rva, Section section);
    public Section GetSection(string name);
    public Section GetSectionAtVirtualAddress(UInt32 rva);
    public ImageDebugDirectory GetDebugHeader(Byte[]& header);
}
internal class Mono.Cecil.PE.ImageReader : BinaryStreamReader {
    private Image image;
    private DataDirectory cli;
    private DataDirectory metadata;
    public ImageReader(Stream stream);
    private void MoveTo(DataDirectory directory);
    private void MoveTo(UInt32 position);
    private void ReadImage();
    private TargetArchitecture ReadArchitecture();
    private static ModuleKind GetModuleKind(ushort characteristics, ushort subsystem);
    private void ReadOptionalHeaders(UInt16& subsystem, UInt16& dll_characteristics);
    private string ReadAlignedString(int length);
    private string ReadZeroTerminatedString(int length);
    private void ReadSections(ushort count);
    private void ReadSectionData(Section section);
    private void ReadCLIHeader();
    private void ReadMetadata();
    private void ReadMetadataStream(Section section);
    private void ReadTableHeap();
    private static void SetIndexSize(Heap heap, UInt32 sizes, byte flag);
    private int GetTableIndexSize(Table table);
    private int GetCodedIndexSize(CodedIndex index);
    private void ComputeTableInformations();
    public static Image ReadImageFrom(Stream stream);
}
internal class Mono.Cecil.PE.ImageWriter : BinaryStreamWriter {
    private ModuleDefinition module;
    private MetadataBuilder metadata;
    private TextMap text_map;
    private ImageDebugDirectory debug_directory;
    private Byte[] debug_data;
    private UInt32 win32_rva;
    private ByteBuffer win32_resources;
    private ResourceDirectory win32_resources_directory;
    private static UInt32 pe_header_size;
    private static UInt32 section_header_size;
    private static UInt32 file_alignment;
    private static UInt32 section_alignment;
    private static ulong image_base;
    internal static UInt32 text_rva;
    private bool pe64;
    private bool has_reloc;
    private UInt32 time_stamp;
    internal Section text;
    internal Section rsrc;
    internal Section reloc;
    private ushort sections;
    private ImageWriter(ModuleDefinition module, MetadataBuilder metadata, Stream stream);
    private void GetDebugHeader();
    private void GetWin32Resources();
    private Section GetImageResourceSection();
    public static ImageWriter CreateWriter(ModuleDefinition module, MetadataBuilder metadata, Stream stream);
    private void BuildSections();
    private Section CreateSection(string name, UInt32 size, Section previous);
    private void SetSectionSize(Section ret, UInt32 size);
    private Section CreateSection(string name, Section previous);
    private static UInt32 Align(UInt32 value, UInt32 align);
    private void WriteDOSHeader();
    private ushort SizeOfOptionalHeader();
    private void WritePEFileHeader();
    private ushort GetMachine();
    private Section LastSection();
    private void WriteOptionalHeaders();
    private void WriteZeroDataDirectory();
    private ushort GetSubSystem();
    private void WriteSectionHeaders();
    private void WriteSection(Section section, UInt32 characteristics);
    private void MoveTo(UInt32 pointer);
    private void MoveToRVA(Section section, UInt32 rva);
    private void MoveToRVA(TextSegment segment);
    private void WriteRVA(UInt32 rva);
    private void PrepareSection(Section section);
    private void WriteText();
    private UInt32 GetMetadataLength();
    private void WriteMetadataHeader();
    private ushort GetStreamCount();
    private void WriteStreamHeader(UInt32& offset, TextSegment heap, string name);
    private static Byte[] GetZeroTerminatedString(string string);
    private static Byte[] GetSimpleString(string string);
    private static Byte[] GetString(string string, int length);
    private void WriteMetadata();
    private void WriteHeap(TextSegment heap, HeapBuffer buffer);
    private void WriteGuidHeap();
    private void WriteDebugDirectory();
    private void WriteImportDirectory();
    private Byte[] GetRuntimeMain();
    private void WriteStartupStub();
    private void WriteRsrc();
    private void WriteReloc();
    public void WriteImage();
    private TextMap BuildTextMap();
    private UInt32 GetStartupStubLength();
    private int GetMetadataHeaderLength();
    private int GetStrongNameLength();
    public DataDirectory GetStrongNameSignatureDirectory();
    public UInt32 GetHeaderSize();
    private void PatchWin32Resources(ByteBuffer resources);
    private void PatchResourceDirectoryTable(ByteBuffer resources);
    private void PatchResourceDirectoryEntry(ByteBuffer resources);
    private void PatchResourceDataEntry(ByteBuffer resources);
    private static int GetDirectoryLength(ResourceDirectory dir);
    private static int GetDirectoryLength(ResourceEntry entry);
    private void WriteWin32ResourcesDirectory(ResourceDirectory directory);
    private void WriteResourceDataEntries(ResourceDirectory directory, Int32& offset);
    private void WriteData(ResourceDirectory directory);
    private void Write(ResourceDirectory directory, int writeDepth, int currentDepth, Int32& offset, Dictionary`2<string, int> strings, Int32& stringTableOffset, ByteBuffer stringTable);
    private void WriteEntry(ResourceEntry entry, Int32& offset, Dictionary`2<string, int> strings, Int32& stringTableOffset, ByteBuffer stringTable);
    private void WriteNameOrOrdinal(ResourceEntry entry, Dictionary`2<string, int> strings, Int32& stringTableOffset, ByteBuffer stringTable);
}
internal class Mono.Cecil.PE.ResourceDirectory : object {
    private Collection`1<ResourceEntry> _entries;
    [CompilerGeneratedAttribute]
private ushort <NumNameEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <NumIdEntries>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MinVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ushort <MajorVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Characteristics>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <TimeDateStamp>k__BackingField;
    public Collection`1<ResourceEntry> Entries { get; }
    public ushort NumNameEntries { get; public set; }
    public ushort NumIdEntries { get; public set; }
    public ushort MinVersion { get; public set; }
    public ushort MajorVersion { get; public set; }
    public UInt32 Characteristics { get; public set; }
    public UInt32 TimeDateStamp { get; public set; }
    public Collection`1<ResourceEntry> get_Entries();
    public ushort SortEntries();
    [CompilerGeneratedAttribute]
public ushort get_NumNameEntries();
    [CompilerGeneratedAttribute]
public void set_NumNameEntries(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_NumIdEntries();
    [CompilerGeneratedAttribute]
public void set_NumIdEntries(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_MinVersion();
    [CompilerGeneratedAttribute]
public void set_MinVersion(ushort value);
    [CompilerGeneratedAttribute]
public ushort get_MajorVersion();
    [CompilerGeneratedAttribute]
public void set_MajorVersion(ushort value);
    [CompilerGeneratedAttribute]
public UInt32 get_Characteristics();
    [CompilerGeneratedAttribute]
public void set_Characteristics(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_TimeDateStamp();
    [CompilerGeneratedAttribute]
public void set_TimeDateStamp(UInt32 value);
}
internal class Mono.Cecil.PE.ResourceEntry : object {
    [CompilerGeneratedAttribute]
private UInt32 <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ResourceDirectory <Directory>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <CodePage>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Reserved>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Data>k__BackingField;
    public UInt32 Id { get; public set; }
    public string Name { get; public set; }
    public ResourceDirectory Directory { get; public set; }
    public UInt32 CodePage { get; public set; }
    public UInt32 Reserved { get; public set; }
    public Byte[] Data { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(UInt32 value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public ResourceDirectory get_Directory();
    [CompilerGeneratedAttribute]
public void set_Directory(ResourceDirectory value);
    [CompilerGeneratedAttribute]
public UInt32 get_CodePage();
    [CompilerGeneratedAttribute]
public void set_CodePage(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_Reserved();
    [CompilerGeneratedAttribute]
public void set_Reserved(UInt32 value);
    [CompilerGeneratedAttribute]
public Byte[] get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(Byte[] value);
}
internal class Mono.Cecil.PE.RsrcReader : object {
    internal static ResourceDirectory ReadResourceDirectory(Byte[] b, UInt32 baseAddress);
    private static ResourceDirectory ReadResourceDirectory(BinaryReader dr, UInt32 baseAddress);
    private static ResourceEntry ReadResourceEntry(BinaryReader dr, UInt32 baseAddress);
    private static ResourceDirectory ReadResourceDirectoryTable(BinaryReader dr);
}
internal class Mono.Cecil.PE.Section : object {
    public string Name;
    public UInt32 VirtualAddress;
    public UInt32 VirtualSize;
    public UInt32 SizeOfRawData;
    public UInt32 PointerToRawData;
    public Byte[] Data;
}
internal class Mono.Cecil.PE.TextMap : object {
    private Range[] map;
    public void AddMap(TextSegment segment, int length);
    public void AddMap(TextSegment segment, int length, int align);
    public void AddMap(TextSegment segment, Range range);
    public Range GetRange(TextSegment segment);
    public DataDirectory GetDataDirectory(TextSegment segment);
    public UInt32 GetRVA(TextSegment segment);
    public UInt32 GetNextRVA(TextSegment segment);
    public int GetLength(TextSegment segment);
    private UInt32 GetStart(TextSegment segment);
    private UInt32 ComputeStart(int index);
    public UInt32 GetLength();
}
internal enum Mono.Cecil.PE.TextSegment : Enum {
    public int value__;
    public static TextSegment ImportAddressTable;
    public static TextSegment CLIHeader;
    public static TextSegment Code;
    public static TextSegment Resources;
    public static TextSegment Data;
    public static TextSegment StrongNameSignature;
    public static TextSegment MetadataHeader;
    public static TextSegment TableHeap;
    public static TextSegment StringHeap;
    public static TextSegment UserStringHeap;
    public static TextSegment GuidHeap;
    public static TextSegment BlobHeap;
    public static TextSegment DebugDirectory;
    public static TextSegment ImportDirectory;
    public static TextSegment ImportHintNameTable;
    public static TextSegment StartupStub;
}
internal class Mono.Cecil.PinnedType : TypeSpecification {
    public bool IsValueType { get; public set; }
    public bool IsPinned { get; }
    public PinnedType(TypeReference type);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsPinned();
}
[FlagsAttribute]
internal enum Mono.Cecil.PInvokeAttributes : Enum {
    public ushort value__;
    public static PInvokeAttributes NoMangle;
    public static PInvokeAttributes CharSetMask;
    public static PInvokeAttributes CharSetNotSpec;
    public static PInvokeAttributes CharSetAnsi;
    public static PInvokeAttributes CharSetUnicode;
    public static PInvokeAttributes CharSetAuto;
    public static PInvokeAttributes SupportsLastError;
    public static PInvokeAttributes CallConvMask;
    public static PInvokeAttributes CallConvWinapi;
    public static PInvokeAttributes CallConvCdecl;
    public static PInvokeAttributes CallConvStdCall;
    public static PInvokeAttributes CallConvThiscall;
    public static PInvokeAttributes CallConvFastcall;
    public static PInvokeAttributes BestFitMask;
    public static PInvokeAttributes BestFitEnabled;
    public static PInvokeAttributes BestFitDisabled;
    public static PInvokeAttributes ThrowOnUnmappableCharMask;
    public static PInvokeAttributes ThrowOnUnmappableCharEnabled;
    public static PInvokeAttributes ThrowOnUnmappableCharDisabled;
}
internal class Mono.Cecil.PInvokeInfo : object {
    private ushort attributes;
    private string entry_point;
    private ModuleReference module;
    public PInvokeAttributes Attributes { get; public set; }
    public string EntryPoint { get; public set; }
    public ModuleReference Module { get; public set; }
    public bool IsNoMangle { get; public set; }
    public bool IsCharSetNotSpec { get; public set; }
    public bool IsCharSetAnsi { get; public set; }
    public bool IsCharSetUnicode { get; public set; }
    public bool IsCharSetAuto { get; public set; }
    public bool SupportsLastError { get; public set; }
    public bool IsCallConvWinapi { get; public set; }
    public bool IsCallConvCdecl { get; public set; }
    public bool IsCallConvStdCall { get; public set; }
    public bool IsCallConvThiscall { get; public set; }
    public bool IsCallConvFastcall { get; public set; }
    public bool IsBestFitEnabled { get; public set; }
    public bool IsBestFitDisabled { get; public set; }
    public bool IsThrowOnUnmappableCharEnabled { get; public set; }
    public bool IsThrowOnUnmappableCharDisabled { get; public set; }
    public PInvokeInfo(PInvokeAttributes attributes, string entryPoint, ModuleReference module);
    public PInvokeAttributes get_Attributes();
    public void set_Attributes(PInvokeAttributes value);
    public string get_EntryPoint();
    public void set_EntryPoint(string value);
    public ModuleReference get_Module();
    public void set_Module(ModuleReference value);
    public bool get_IsNoMangle();
    public void set_IsNoMangle(bool value);
    public bool get_IsCharSetNotSpec();
    public void set_IsCharSetNotSpec(bool value);
    public bool get_IsCharSetAnsi();
    public void set_IsCharSetAnsi(bool value);
    public bool get_IsCharSetUnicode();
    public void set_IsCharSetUnicode(bool value);
    public bool get_IsCharSetAuto();
    public void set_IsCharSetAuto(bool value);
    public bool get_SupportsLastError();
    public void set_SupportsLastError(bool value);
    public bool get_IsCallConvWinapi();
    public void set_IsCallConvWinapi(bool value);
    public bool get_IsCallConvCdecl();
    public void set_IsCallConvCdecl(bool value);
    public bool get_IsCallConvStdCall();
    public void set_IsCallConvStdCall(bool value);
    public bool get_IsCallConvThiscall();
    public void set_IsCallConvThiscall(bool value);
    public bool get_IsCallConvFastcall();
    public void set_IsCallConvFastcall(bool value);
    public bool get_IsBestFitEnabled();
    public void set_IsBestFitEnabled(bool value);
    public bool get_IsBestFitDisabled();
    public void set_IsBestFitDisabled(bool value);
    public bool get_IsThrowOnUnmappableCharEnabled();
    public void set_IsThrowOnUnmappableCharEnabled(bool value);
    public bool get_IsThrowOnUnmappableCharDisabled();
    public void set_IsThrowOnUnmappableCharDisabled(bool value);
}
internal class Mono.Cecil.PointerType : TypeSpecification {
    public string Name { get; }
    public string FullName { get; }
    public bool IsValueType { get; public set; }
    public bool IsPointer { get; }
    public PointerType(TypeReference type);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsPointer();
}
[FlagsAttribute]
internal enum Mono.Cecil.PropertyAttributes : Enum {
    public ushort value__;
    public static PropertyAttributes None;
    public static PropertyAttributes SpecialName;
    public static PropertyAttributes RTSpecialName;
    public static PropertyAttributes HasDefault;
    public static PropertyAttributes Unused;
}
internal class Mono.Cecil.PropertyDefinition : PropertyReference {
    private Nullable`1<bool> has_this;
    private ushort attributes;
    private Collection`1<CustomAttribute> custom_attributes;
    internal MethodDefinition get_method;
    internal MethodDefinition set_method;
    internal Collection`1<MethodDefinition> other_methods;
    private object constant;
    public PropertyAttributes Attributes { get; public set; }
    public bool HasThis { get; public set; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public MethodDefinition GetMethod { get; public set; }
    public MethodDefinition SetMethod { get; public set; }
    public bool HasOtherMethods { get; }
    public Collection`1<MethodDefinition> OtherMethods { get; }
    public bool HasParameters { get; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    public bool HasConstant { get; public set; }
    public object Constant { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasDefault { get; public set; }
    public TypeDefinition DeclaringType { get; public set; }
    public bool IsDefinition { get; }
    public string FullName { get; }
    public PropertyDefinition(string name, PropertyAttributes attributes, TypeReference propertyType);
    public PropertyAttributes get_Attributes();
    public void set_Attributes(PropertyAttributes value);
    public bool get_HasThis();
    public void set_HasThis(bool value);
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public MethodDefinition get_GetMethod();
    public void set_GetMethod(MethodDefinition value);
    public MethodDefinition get_SetMethod();
    public void set_SetMethod(MethodDefinition value);
    public bool get_HasOtherMethods();
    public Collection`1<MethodDefinition> get_OtherMethods();
    public bool get_HasParameters();
    public virtual Collection`1<ParameterDefinition> get_Parameters();
    private static Collection`1<ParameterDefinition> MirrorParameters(MethodDefinition method, int bound);
    public sealed virtual bool get_HasConstant();
    public sealed virtual void set_HasConstant(bool value);
    public sealed virtual object get_Constant();
    public sealed virtual void set_Constant(object value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasDefault();
    public void set_HasDefault(bool value);
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual bool get_IsDefinition();
    public virtual string get_FullName();
    private void InitializeMethods();
    public virtual PropertyDefinition Resolve();
}
internal class Mono.Cecil.PropertyMapTable : MetadataTable`1<Row`2<UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal abstract class Mono.Cecil.PropertyReference : MemberReference {
    private TypeReference property_type;
    public TypeReference PropertyType { get; public set; }
    public Collection`1<ParameterDefinition> Parameters { get; }
    internal PropertyReference(string name, TypeReference propertyType);
    public TypeReference get_PropertyType();
    public void set_PropertyType(TypeReference value);
    public abstract virtual Collection`1<ParameterDefinition> get_Parameters();
    public abstract virtual PropertyDefinition Resolve();
}
internal class Mono.Cecil.PropertyTable : MetadataTable`1<Row`3<PropertyAttributes, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.Range : ValueType {
    public UInt32 Start;
    public UInt32 Length;
    public Range(UInt32 index, UInt32 length);
}
internal class Mono.Cecil.ReaderParameters : object {
    private ReadingMode reading_mode;
    internal IAssemblyResolver assembly_resolver;
    internal IMetadataResolver metadata_resolver;
    internal IMetadataImporterProvider metadata_importer_provider;
    internal IReflectionImporterProvider reflection_importer_provider;
    private Stream symbol_stream;
    private ISymbolReaderProvider symbol_reader_provider;
    private bool read_symbols;
    public ReadingMode ReadingMode { get; public set; }
    public IAssemblyResolver AssemblyResolver { get; public set; }
    public IMetadataResolver MetadataResolver { get; public set; }
    public IMetadataImporterProvider MetadataImporterProvider { get; public set; }
    public IReflectionImporterProvider ReflectionImporterProvider { get; public set; }
    public Stream SymbolStream { get; public set; }
    public ISymbolReaderProvider SymbolReaderProvider { get; public set; }
    public bool ReadSymbols { get; public set; }
    public ReaderParameters(ReadingMode readingMode);
    public ReadingMode get_ReadingMode();
    public void set_ReadingMode(ReadingMode value);
    public IAssemblyResolver get_AssemblyResolver();
    public void set_AssemblyResolver(IAssemblyResolver value);
    public IMetadataResolver get_MetadataResolver();
    public void set_MetadataResolver(IMetadataResolver value);
    public IMetadataImporterProvider get_MetadataImporterProvider();
    public void set_MetadataImporterProvider(IMetadataImporterProvider value);
    public IReflectionImporterProvider get_ReflectionImporterProvider();
    public void set_ReflectionImporterProvider(IReflectionImporterProvider value);
    public Stream get_SymbolStream();
    public void set_SymbolStream(Stream value);
    public ISymbolReaderProvider get_SymbolReaderProvider();
    public void set_SymbolReaderProvider(ISymbolReaderProvider value);
    public bool get_ReadSymbols();
    public void set_ReadSymbols(bool value);
}
internal enum Mono.Cecil.ReadingMode : Enum {
    public int value__;
    public static ReadingMode Immediate;
    public static ReadingMode Deferred;
}
internal class Mono.Cecil.ReflectionImporter : object {
    private ModuleDefinition module;
    private static Dictionary`2<Type, ElementType> type_etype_mapping;
    public ReflectionImporter(ModuleDefinition module);
    private static ReflectionImporter();
    private TypeReference ImportType(Type type, ImportGenericContext context);
    private TypeReference ImportType(Type type, ImportGenericContext context, ImportGenericKind import_kind);
    private static bool ImportOpenGenericType(Type type, ImportGenericKind import_kind);
    private static bool ImportOpenGenericMethod(MethodBase method, ImportGenericKind import_kind);
    private static bool IsNestedType(Type type);
    private TypeReference ImportTypeSpecification(Type type, ImportGenericContext context);
    private static TypeReference ImportGenericParameter(Type type, ImportGenericContext context);
    private static string NormalizedFullName(Type type);
    private TypeReference ImportGenericInstance(Type type, ImportGenericContext context);
    private static bool IsTypeSpecification(Type type);
    private static bool IsGenericInstance(Type type);
    private static ElementType ImportElementType(Type type);
    private AssemblyNameReference ImportScope(Assembly assembly);
    private bool TryGetAssemblyNameReference(AssemblyName name, AssemblyNameReference& assembly_reference);
    private FieldReference ImportField(FieldInfo field, ImportGenericContext context);
    private static FieldInfo ResolveFieldDefinition(FieldInfo field);
    private MethodReference ImportMethod(MethodBase method, ImportGenericContext context, ImportGenericKind import_kind);
    private static void ImportGenericParameters(IGenericParameterProvider provider, Type[] arguments);
    private static bool IsMethodSpecification(MethodBase method);
    private MethodReference ImportMethodSpecification(MethodBase method, ImportGenericContext context);
    private static bool HasCallingConvention(MethodBase method, CallingConventions conventions);
    public virtual TypeReference ImportReference(Type type, IGenericParameterProvider context);
    public virtual FieldReference ImportReference(FieldInfo field, IGenericParameterProvider context);
    public virtual MethodReference ImportReference(MethodBase method, IGenericParameterProvider context);
}
internal class Mono.Cecil.RequiredModifierType : TypeSpecification {
    private TypeReference modifier_type;
    public TypeReference ModifierType { get; public set; }
    public string Name { get; }
    public string FullName { get; }
    private string Suffix { get; }
    public bool IsValueType { get; public set; }
    public bool IsRequiredModifier { get; }
    public bool ContainsGenericParameter { get; }
    public RequiredModifierType(TypeReference modifierType, TypeReference type);
    public sealed virtual TypeReference get_ModifierType();
    public void set_ModifierType(TypeReference value);
    public virtual string get_Name();
    public virtual string get_FullName();
    private string get_Suffix();
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsRequiredModifier();
    public virtual bool get_ContainsGenericParameter();
}
internal class Mono.Cecil.ResolutionException : Exception {
    private MemberReference member;
    public MemberReference Member { get; }
    public IMetadataScope Scope { get; }
    public ResolutionException(MemberReference member);
    protected ResolutionException(SerializationInfo info, StreamingContext context);
    public MemberReference get_Member();
    public IMetadataScope get_Scope();
}
internal abstract class Mono.Cecil.Resource : object {
    private string name;
    private UInt32 attributes;
    public string Name { get; public set; }
    public ManifestResourceAttributes Attributes { get; public set; }
    public ResourceType ResourceType { get; }
    public bool IsPublic { get; public set; }
    public bool IsPrivate { get; public set; }
    internal Resource(string name, ManifestResourceAttributes attributes);
    public string get_Name();
    public void set_Name(string value);
    public ManifestResourceAttributes get_Attributes();
    public void set_Attributes(ManifestResourceAttributes value);
    public abstract virtual ResourceType get_ResourceType();
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsPrivate();
    public void set_IsPrivate(bool value);
}
internal enum Mono.Cecil.ResourceType : Enum {
    public int value__;
    public static ResourceType Linked;
    public static ResourceType Embedded;
    public static ResourceType AssemblyLinked;
}
internal class Mono.Cecil.SafeArrayMarshalInfo : MarshalInfo {
    internal VariantType element_type;
    public VariantType ElementType { get; public set; }
    public VariantType get_ElementType();
    public void set_ElementType(VariantType value);
}
internal enum Mono.Cecil.SecurityAction : Enum {
    public ushort value__;
    public static SecurityAction Request;
    public static SecurityAction Demand;
    public static SecurityAction Assert;
    public static SecurityAction Deny;
    public static SecurityAction PermitOnly;
    public static SecurityAction LinkDemand;
    public static SecurityAction InheritDemand;
    public static SecurityAction RequestMinimum;
    public static SecurityAction RequestOptional;
    public static SecurityAction RequestRefuse;
    public static SecurityAction PreJitGrant;
    public static SecurityAction PreJitDeny;
    public static SecurityAction NonCasDemand;
    public static SecurityAction NonCasLinkDemand;
    public static SecurityAction NonCasInheritance;
}
internal class Mono.Cecil.SecurityAttribute : object {
    private TypeReference attribute_type;
    internal Collection`1<CustomAttributeNamedArgument> fields;
    internal Collection`1<CustomAttributeNamedArgument> properties;
    public TypeReference AttributeType { get; public set; }
    public bool HasFields { get; }
    public Collection`1<CustomAttributeNamedArgument> Fields { get; }
    public bool HasProperties { get; }
    public Collection`1<CustomAttributeNamedArgument> Properties { get; }
    public SecurityAttribute(TypeReference attributeType);
    public sealed virtual TypeReference get_AttributeType();
    public void set_AttributeType(TypeReference value);
    public sealed virtual bool get_HasFields();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Fields();
    public sealed virtual bool get_HasProperties();
    public sealed virtual Collection`1<CustomAttributeNamedArgument> get_Properties();
}
internal class Mono.Cecil.SecurityDeclaration : object {
    internal UInt32 signature;
    private Byte[] blob;
    private ModuleDefinition module;
    internal bool resolved;
    private SecurityAction action;
    internal Collection`1<SecurityAttribute> security_attributes;
    public SecurityAction Action { get; public set; }
    public bool HasSecurityAttributes { get; }
    public Collection`1<SecurityAttribute> SecurityAttributes { get; }
    internal bool HasImage { get; }
    internal SecurityDeclaration(SecurityAction action, UInt32 signature, ModuleDefinition module);
    public SecurityDeclaration(SecurityAction action);
    public SecurityDeclaration(SecurityAction action, Byte[] blob);
    public SecurityAction get_Action();
    public void set_Action(SecurityAction value);
    public bool get_HasSecurityAttributes();
    public Collection`1<SecurityAttribute> get_SecurityAttributes();
    internal bool get_HasImage();
    public Byte[] GetBlob();
    private void Resolve();
    [CompilerGeneratedAttribute]
private SecurityDeclaration <Resolve>b__19_0(SecurityDeclaration declaration, MetadataReader reader);
}
internal class Mono.Cecil.SentinelType : TypeSpecification {
    public bool IsValueType { get; public set; }
    public bool IsSentinel { get; }
    public SentinelType(TypeReference type);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual bool get_IsSentinel();
}
internal class Mono.Cecil.SignatureReader : ByteBuffer {
    private MetadataReader reader;
    private UInt32 start;
    private UInt32 sig_length;
    private TypeSystem TypeSystem { get; }
    public SignatureReader(UInt32 blob, MetadataReader reader);
    private TypeSystem get_TypeSystem();
    private void MoveToBlob(UInt32 blob);
    private MetadataToken ReadTypeTokenSignature();
    private GenericParameter GetGenericParameter(GenericParameterType type, UInt32 var);
    private GenericParameter GetUnboundGenericParameter(GenericParameterType type, int index);
    private static void CheckGenericContext(IGenericParameterProvider owner, int index);
    public void ReadGenericInstanceSignature(IGenericParameterProvider provider, IGenericInstance instance);
    private ArrayType ReadArrayTypeSignature();
    private TypeReference GetTypeDefOrRef(MetadataToken token);
    public TypeReference ReadTypeSignature();
    private TypeReference ReadTypeSignature(ElementType etype);
    public void ReadMethodSignature(IMethodSignature method);
    public object ReadConstantSignature(ElementType type);
    public void ReadCustomAttributeConstructorArguments(CustomAttribute attribute, Collection`1<ParameterDefinition> parameters);
    private CustomAttributeArgument ReadCustomAttributeFixedArgument(TypeReference type);
    public void ReadCustomAttributeNamedArguments(ushort count, Collection`1& fields, Collection`1& properties);
    private void ReadCustomAttributeNamedArgument(Collection`1& fields, Collection`1& properties);
    private static Collection`1<CustomAttributeNamedArgument> GetCustomAttributeNamedArgumentCollection(Collection`1& collection);
    private CustomAttributeArgument ReadCustomAttributeFixedArrayArgument(ArrayType type);
    private CustomAttributeArgument ReadCustomAttributeElement(TypeReference type);
    private object ReadCustomAttributeElementValue(TypeReference type);
    private object ReadPrimitiveValue(ElementType type);
    private TypeReference GetPrimitiveType(ElementType etype);
    private TypeReference ReadCustomAttributeFieldOrPropType();
    public TypeReference ReadTypeReference();
    private object ReadCustomAttributeEnum(TypeReference enum_type);
    public SecurityAttribute ReadSecurityAttribute();
    public MarshalInfo ReadMarshalInfo();
    private NativeType ReadNativeType();
    private VariantType ReadVariantType();
    private string ReadUTF8String();
    public bool CanReadMore();
}
internal class Mono.Cecil.SignatureWriter : ByteBuffer {
    private MetadataBuilder metadata;
    public SignatureWriter(MetadataBuilder metadata);
    public void WriteElementType(ElementType element_type);
    public void WriteUTF8String(string string);
    public void WriteMethodSignature(IMethodSignature method);
    private UInt32 MakeTypeDefOrRefCodedRID(TypeReference type);
    public void WriteTypeSignature(TypeReference type);
    private void WriteArrayTypeSignature(ArrayType array);
    public void WriteGenericInstanceSignature(IGenericInstance instance);
    private void WriteModifierSignature(ElementType element_type, IModifierType type);
    private bool TryWriteElementType(TypeReference type);
    public void WriteConstantString(string value);
    public void WriteConstantPrimitive(object value);
    public void WriteCustomAttributeConstructorArguments(CustomAttribute attribute);
    private void WriteCustomAttributeFixedArgument(TypeReference type, CustomAttributeArgument argument);
    private void WriteCustomAttributeFixedArrayArgument(ArrayType type, CustomAttributeArgument argument);
    private void WriteCustomAttributeElement(TypeReference type, CustomAttributeArgument argument);
    private void WriteCustomAttributeValue(TypeReference type, object value);
    private void WritePrimitiveValue(object value);
    private void WriteCustomAttributeEnumValue(TypeReference enum_type, object value);
    private void WriteCustomAttributeFieldOrPropType(TypeReference type);
    public void WriteCustomAttributeNamedArguments(CustomAttribute attribute);
    private static int GetNamedArgumentCount(ICustomAttribute attribute);
    private void WriteICustomAttributeNamedArguments(ICustomAttribute attribute);
    private void WriteCustomAttributeNamedArguments(byte kind, Collection`1<CustomAttributeNamedArgument> named_arguments);
    private void WriteCustomAttributeNamedArgument(byte kind, CustomAttributeNamedArgument named_argument);
    private void WriteSecurityAttribute(SecurityAttribute attribute);
    public void WriteSecurityDeclaration(SecurityDeclaration declaration);
    public void WriteXmlSecurityDeclaration(SecurityDeclaration declaration);
    private static string GetXmlSecurityDeclaration(SecurityDeclaration declaration);
    private void WriteTypeReference(TypeReference type);
    public void WriteMarshalInfo(MarshalInfo marshal_info);
    private void WriteNativeType(NativeType native);
    private void WriteVariantType(VariantType variant);
}
internal abstract class Mono.Cecil.SortedTable`1 : MetadataTable`1<TRow> {
    public sealed virtual void Sort();
    protected int Compare(UInt32 x, UInt32 y);
    public abstract virtual int Compare(TRow x, TRow y);
}
internal class Mono.Cecil.StandAloneSigTable : MetadataTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal enum Mono.Cecil.TargetArchitecture : Enum {
    public int value__;
    public static TargetArchitecture I386;
    public static TargetArchitecture AMD64;
    public static TargetArchitecture IA64;
    public static TargetArchitecture ARMv7;
}
internal enum Mono.Cecil.TargetRuntime : Enum {
    public int value__;
    public static TargetRuntime Net_1_0;
    public static TargetRuntime Net_1_1;
    public static TargetRuntime Net_2_0;
    public static TargetRuntime Net_4_0;
}
internal enum Mono.Cecil.TokenType : Enum {
    public UInt32 value__;
    public static TokenType Module;
    public static TokenType TypeRef;
    public static TokenType TypeDef;
    public static TokenType Field;
    public static TokenType Method;
    public static TokenType Param;
    public static TokenType InterfaceImpl;
    public static TokenType MemberRef;
    public static TokenType CustomAttribute;
    public static TokenType Permission;
    public static TokenType Signature;
    public static TokenType Event;
    public static TokenType Property;
    public static TokenType ModuleRef;
    public static TokenType TypeSpec;
    public static TokenType Assembly;
    public static TokenType AssemblyRef;
    public static TokenType File;
    public static TokenType ExportedType;
    public static TokenType ManifestResource;
    public static TokenType GenericParam;
    public static TokenType MethodSpec;
    public static TokenType String;
}
[FlagsAttribute]
internal enum Mono.Cecil.TypeAttributes : Enum {
    public UInt32 value__;
    public static TypeAttributes VisibilityMask;
    public static TypeAttributes NotPublic;
    public static TypeAttributes Public;
    public static TypeAttributes NestedPublic;
    public static TypeAttributes NestedPrivate;
    public static TypeAttributes NestedFamily;
    public static TypeAttributes NestedAssembly;
    public static TypeAttributes NestedFamANDAssem;
    public static TypeAttributes NestedFamORAssem;
    public static TypeAttributes LayoutMask;
    public static TypeAttributes AutoLayout;
    public static TypeAttributes SequentialLayout;
    public static TypeAttributes ExplicitLayout;
    public static TypeAttributes ClassSemanticMask;
    public static TypeAttributes Class;
    public static TypeAttributes Interface;
    public static TypeAttributes Abstract;
    public static TypeAttributes Sealed;
    public static TypeAttributes SpecialName;
    public static TypeAttributes Import;
    public static TypeAttributes Serializable;
    public static TypeAttributes WindowsRuntime;
    public static TypeAttributes StringFormatMask;
    public static TypeAttributes AnsiClass;
    public static TypeAttributes UnicodeClass;
    public static TypeAttributes AutoClass;
    public static TypeAttributes BeforeFieldInit;
    public static TypeAttributes RTSpecialName;
    public static TypeAttributes HasSecurity;
    public static TypeAttributes Forwarder;
}
internal class Mono.Cecil.TypeDefinition : TypeReference {
    private UInt32 attributes;
    private TypeReference base_type;
    internal Range fields_range;
    internal Range methods_range;
    private short packing_size;
    private int class_size;
    private Collection`1<TypeReference> interfaces;
    private Collection`1<TypeDefinition> nested_types;
    private Collection`1<MethodDefinition> methods;
    private Collection`1<FieldDefinition> fields;
    private Collection`1<EventDefinition> events;
    private Collection`1<PropertyDefinition> properties;
    private Collection`1<CustomAttribute> custom_attributes;
    private Collection`1<SecurityDeclaration> security_declarations;
    public TypeAttributes Attributes { get; public set; }
    public TypeReference BaseType { get; public set; }
    public bool HasLayoutInfo { get; }
    public short PackingSize { get; public set; }
    public int ClassSize { get; public set; }
    public bool HasInterfaces { get; }
    public Collection`1<TypeReference> Interfaces { get; }
    public bool HasNestedTypes { get; }
    public Collection`1<TypeDefinition> NestedTypes { get; }
    public bool HasMethods { get; }
    public Collection`1<MethodDefinition> Methods { get; }
    public bool HasFields { get; }
    public Collection`1<FieldDefinition> Fields { get; }
    public bool HasEvents { get; }
    public Collection`1<EventDefinition> Events { get; }
    public bool HasProperties { get; }
    public Collection`1<PropertyDefinition> Properties { get; }
    public bool HasSecurityDeclarations { get; }
    public Collection`1<SecurityDeclaration> SecurityDeclarations { get; }
    public bool HasCustomAttributes { get; }
    public Collection`1<CustomAttribute> CustomAttributes { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public bool IsNotPublic { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsNestedPublic { get; public set; }
    public bool IsNestedPrivate { get; public set; }
    public bool IsNestedFamily { get; public set; }
    public bool IsNestedAssembly { get; public set; }
    public bool IsNestedFamilyAndAssembly { get; public set; }
    public bool IsNestedFamilyOrAssembly { get; public set; }
    public bool IsAutoLayout { get; public set; }
    public bool IsSequentialLayout { get; public set; }
    public bool IsExplicitLayout { get; public set; }
    public bool IsClass { get; public set; }
    public bool IsInterface { get; public set; }
    public bool IsAbstract { get; public set; }
    public bool IsSealed { get; public set; }
    public bool IsSpecialName { get; public set; }
    public bool IsImport { get; public set; }
    public bool IsSerializable { get; public set; }
    public bool IsWindowsRuntime { get; public set; }
    public bool IsAnsiClass { get; public set; }
    public bool IsUnicodeClass { get; public set; }
    public bool IsAutoClass { get; public set; }
    public bool IsBeforeFieldInit { get; public set; }
    public bool IsRuntimeSpecialName { get; public set; }
    public bool HasSecurity { get; public set; }
    public bool IsEnum { get; }
    public bool IsValueType { get; }
    public bool IsPrimitive { get; }
    public MetadataType MetadataType { get; }
    public bool IsDefinition { get; }
    public TypeDefinition DeclaringType { get; public set; }
    public TypeDefinition(string namespace, string name, TypeAttributes attributes);
    public TypeDefinition(string namespace, string name, TypeAttributes attributes, TypeReference baseType);
    public TypeAttributes get_Attributes();
    public void set_Attributes(TypeAttributes value);
    public TypeReference get_BaseType();
    public void set_BaseType(TypeReference value);
    private void ResolveLayout();
    public bool get_HasLayoutInfo();
    public short get_PackingSize();
    public void set_PackingSize(short value);
    public int get_ClassSize();
    public void set_ClassSize(int value);
    public bool get_HasInterfaces();
    public Collection`1<TypeReference> get_Interfaces();
    public bool get_HasNestedTypes();
    public Collection`1<TypeDefinition> get_NestedTypes();
    public bool get_HasMethods();
    public Collection`1<MethodDefinition> get_Methods();
    public bool get_HasFields();
    public Collection`1<FieldDefinition> get_Fields();
    public bool get_HasEvents();
    public Collection`1<EventDefinition> get_Events();
    public bool get_HasProperties();
    public Collection`1<PropertyDefinition> get_Properties();
    public sealed virtual bool get_HasSecurityDeclarations();
    public sealed virtual Collection`1<SecurityDeclaration> get_SecurityDeclarations();
    public sealed virtual bool get_HasCustomAttributes();
    public sealed virtual Collection`1<CustomAttribute> get_CustomAttributes();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public bool get_IsNotPublic();
    public void set_IsNotPublic(bool value);
    public bool get_IsPublic();
    public void set_IsPublic(bool value);
    public bool get_IsNestedPublic();
    public void set_IsNestedPublic(bool value);
    public bool get_IsNestedPrivate();
    public void set_IsNestedPrivate(bool value);
    public bool get_IsNestedFamily();
    public void set_IsNestedFamily(bool value);
    public bool get_IsNestedAssembly();
    public void set_IsNestedAssembly(bool value);
    public bool get_IsNestedFamilyAndAssembly();
    public void set_IsNestedFamilyAndAssembly(bool value);
    public bool get_IsNestedFamilyOrAssembly();
    public void set_IsNestedFamilyOrAssembly(bool value);
    public bool get_IsAutoLayout();
    public void set_IsAutoLayout(bool value);
    public bool get_IsSequentialLayout();
    public void set_IsSequentialLayout(bool value);
    public bool get_IsExplicitLayout();
    public void set_IsExplicitLayout(bool value);
    public bool get_IsClass();
    public void set_IsClass(bool value);
    public bool get_IsInterface();
    public void set_IsInterface(bool value);
    public bool get_IsAbstract();
    public void set_IsAbstract(bool value);
    public bool get_IsSealed();
    public void set_IsSealed(bool value);
    public sealed virtual bool get_IsSpecialName();
    public sealed virtual void set_IsSpecialName(bool value);
    public bool get_IsImport();
    public void set_IsImport(bool value);
    public bool get_IsSerializable();
    public void set_IsSerializable(bool value);
    public bool get_IsWindowsRuntime();
    public void set_IsWindowsRuntime(bool value);
    public bool get_IsAnsiClass();
    public void set_IsAnsiClass(bool value);
    public bool get_IsUnicodeClass();
    public void set_IsUnicodeClass(bool value);
    public bool get_IsAutoClass();
    public void set_IsAutoClass(bool value);
    public bool get_IsBeforeFieldInit();
    public void set_IsBeforeFieldInit(bool value);
    public sealed virtual bool get_IsRuntimeSpecialName();
    public sealed virtual void set_IsRuntimeSpecialName(bool value);
    public bool get_HasSecurity();
    public void set_HasSecurity(bool value);
    public bool get_IsEnum();
    public virtual bool get_IsValueType();
    public virtual bool get_IsPrimitive();
    public virtual MetadataType get_MetadataType();
    public virtual bool get_IsDefinition();
    public sealed virtual TypeDefinition get_DeclaringType();
    public sealed virtual void set_DeclaringType(TypeDefinition value);
    public virtual TypeDefinition Resolve();
}
internal class Mono.Cecil.TypeDefinitionCollection : Collection`1<TypeDefinition> {
    private ModuleDefinition container;
    private Dictionary`2<Row`2<string, string>, TypeDefinition> name_cache;
    internal TypeDefinitionCollection(ModuleDefinition container);
    internal TypeDefinitionCollection(ModuleDefinition container, int capacity);
    protected virtual void OnAdd(TypeDefinition item, int index);
    protected virtual void OnSet(TypeDefinition item, int index);
    protected virtual void OnInsert(TypeDefinition item, int index);
    protected virtual void OnRemove(TypeDefinition item, int index);
    protected virtual void OnClear();
    private void Attach(TypeDefinition type);
    private void Detach(TypeDefinition type);
    public TypeDefinition GetType(string fullname);
    public TypeDefinition GetType(string namespace, string name);
}
internal class Mono.Cecil.TypeDefTable : MetadataTable`1<Row`6<TypeAttributes, UInt32, UInt32, UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal class Mono.Cecil.TypeParser : object {
    private string fullname;
    private int length;
    private int position;
    private TypeParser(string fullname);
    private Type ParseType(bool fq_name);
    private static bool TryGetArity(Type type);
    private static bool TryGetArity(string name, Int32& arity);
    private static bool ParseInt32(string value, Int32& result);
    private static void TryAddArity(string name, Int32& arity);
    private string ParsePart();
    private static bool IsDelimiter(char chr);
    private void TryParseWhiteSpace();
    private String[] ParseNestedNames();
    private bool TryParse(char chr);
    private static void Add(T[]& array, T item);
    private Int32[] ParseSpecs();
    private Type[] ParseGenericArguments(int arity);
    private string ParseAssemblyName();
    public static TypeReference ParseType(ModuleDefinition module, string fullname);
    private static TypeReference GetTypeReference(ModuleDefinition module, Type type_info);
    private static TypeReference CreateSpecs(TypeReference type, Type type_info);
    private static TypeReference TryCreateGenericInstanceType(TypeReference type, Type type_info);
    public static void SplitFullName(string fullname, String& namespace, String& name);
    private static TypeReference CreateReference(Type type_info, ModuleDefinition module, IMetadataScope scope);
    private static void AdjustGenericParameters(TypeReference type);
    private static IMetadataScope GetMetadataScope(ModuleDefinition module, Type type_info);
    private static bool TryGetDefinition(ModuleDefinition module, Type type_info, TypeReference& type);
    private static bool TryCurrentModule(ModuleDefinition module, Type type_info);
    public static string ToParseable(TypeReference type);
    private static void AppendNamePart(string part, StringBuilder name);
    private static void AppendType(TypeReference type, StringBuilder name, bool fq_name, bool top_level);
    private static string GetScopeFullName(TypeReference type);
    private static void AppendTypeSpecification(TypeSpecification type, StringBuilder name);
    private static bool RequiresFullyQualifiedName(TypeReference type, bool top_level);
}
internal class Mono.Cecil.TypeReference : MemberReference {
    private string namespace;
    private bool value_type;
    internal IMetadataScope scope;
    internal ModuleDefinition module;
    internal ElementType etype;
    private string fullname;
    protected Collection`1<GenericParameter> generic_parameters;
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public bool IsValueType { get; public set; }
    public ModuleDefinition Module { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Type { get; }
    private IGenericParameterProvider Mono.Cecil.IGenericContext.Method { get; }
    private GenericParameterType Mono.Cecil.IGenericParameterProvider.GenericParameterType { get; }
    public bool HasGenericParameters { get; }
    public Collection`1<GenericParameter> GenericParameters { get; }
    public IMetadataScope Scope { get; public set; }
    public bool IsNested { get; }
    public TypeReference DeclaringType { get; public set; }
    public string FullName { get; }
    public bool IsByReference { get; }
    public bool IsPointer { get; }
    public bool IsSentinel { get; }
    public bool IsArray { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericInstance { get; }
    public bool IsRequiredModifier { get; }
    public bool IsOptionalModifier { get; }
    public bool IsPinned { get; }
    public bool IsFunctionPointer { get; }
    public bool IsPrimitive { get; }
    public MetadataType MetadataType { get; }
    protected TypeReference(string namespace, string name);
    public TypeReference(string namespace, string name, ModuleDefinition module, IMetadataScope scope);
    public TypeReference(string namespace, string name, ModuleDefinition module, IMetadataScope scope, bool valueType);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual bool get_IsValueType();
    public virtual void set_IsValueType(bool value);
    public virtual ModuleDefinition get_Module();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Type();
    private sealed virtual override IGenericParameterProvider Mono.Cecil.IGenericContext.get_Method();
    private sealed virtual override GenericParameterType Mono.Cecil.IGenericParameterProvider.get_GenericParameterType();
    public virtual bool get_HasGenericParameters();
    public virtual Collection`1<GenericParameter> get_GenericParameters();
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public bool get_IsNested();
    public virtual TypeReference get_DeclaringType();
    public virtual void set_DeclaringType(TypeReference value);
    public virtual string get_FullName();
    public virtual bool get_IsByReference();
    public virtual bool get_IsPointer();
    public virtual bool get_IsSentinel();
    public virtual bool get_IsArray();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericInstance();
    public virtual bool get_IsRequiredModifier();
    public virtual bool get_IsOptionalModifier();
    public virtual bool get_IsPinned();
    public virtual bool get_IsFunctionPointer();
    public virtual bool get_IsPrimitive();
    public virtual MetadataType get_MetadataType();
    public virtual TypeReference GetElementType();
    public virtual TypeDefinition Resolve();
}
internal class Mono.Cecil.TypeRefTable : MetadataTable`1<Row`3<UInt32, UInt32, UInt32>> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal abstract class Mono.Cecil.TypeSpecification : TypeReference {
    private TypeReference element_type;
    public TypeReference ElementType { get; }
    public string Name { get; public set; }
    public string Namespace { get; public set; }
    public IMetadataScope Scope { get; public set; }
    public ModuleDefinition Module { get; }
    public string FullName { get; }
    public bool ContainsGenericParameter { get; }
    public MetadataType MetadataType { get; }
    internal TypeSpecification(TypeReference type);
    public sealed virtual TypeReference get_ElementType();
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual string get_Namespace();
    public virtual void set_Namespace(string value);
    public virtual IMetadataScope get_Scope();
    public virtual void set_Scope(IMetadataScope value);
    public virtual ModuleDefinition get_Module();
    public virtual string get_FullName();
    public virtual bool get_ContainsGenericParameter();
    public virtual MetadataType get_MetadataType();
    public virtual TypeReference GetElementType();
}
internal class Mono.Cecil.TypeSpecTable : MetadataTable`1<UInt32> {
    public virtual void Write(TableHeapBuffer buffer);
}
internal abstract class Mono.Cecil.TypeSystem : object {
    private ModuleDefinition module;
    private TypeReference type_object;
    private TypeReference type_void;
    private TypeReference type_bool;
    private TypeReference type_char;
    private TypeReference type_sbyte;
    private TypeReference type_byte;
    private TypeReference type_int16;
    private TypeReference type_uint16;
    private TypeReference type_int32;
    private TypeReference type_uint32;
    private TypeReference type_int64;
    private TypeReference type_uint64;
    private TypeReference type_single;
    private TypeReference type_double;
    private TypeReference type_intptr;
    private TypeReference type_uintptr;
    private TypeReference type_string;
    private TypeReference type_typedref;
    [ObsoleteAttribute("Use CoreLibrary")]
public IMetadataScope Corlib { get; }
    public IMetadataScope CoreLibrary { get; }
    public TypeReference Object { get; }
    public TypeReference Void { get; }
    public TypeReference Boolean { get; }
    public TypeReference Char { get; }
    public TypeReference SByte { get; }
    public TypeReference Byte { get; }
    public TypeReference Int16 { get; }
    public TypeReference UInt16 { get; }
    public TypeReference Int32 { get; }
    public TypeReference UInt32 { get; }
    public TypeReference Int64 { get; }
    public TypeReference UInt64 { get; }
    public TypeReference Single { get; }
    public TypeReference Double { get; }
    public TypeReference IntPtr { get; }
    public TypeReference UIntPtr { get; }
    public TypeReference String { get; }
    public TypeReference TypedReference { get; }
    private TypeSystem(ModuleDefinition module);
    internal static TypeSystem CreateTypeSystem(ModuleDefinition module);
    internal abstract virtual TypeReference LookupType(string namespace, string name);
    private TypeReference LookupSystemType(TypeReference& reference, string name, ElementType element_type);
    private TypeReference LookupSystemValueType(TypeReference& typeRef, string name, ElementType element_type);
    public IMetadataScope get_Corlib();
    public IMetadataScope get_CoreLibrary();
    public TypeReference get_Object();
    public TypeReference get_Void();
    public TypeReference get_Boolean();
    public TypeReference get_Char();
    public TypeReference get_SByte();
    public TypeReference get_Byte();
    public TypeReference get_Int16();
    public TypeReference get_UInt16();
    public TypeReference get_Int32();
    public TypeReference get_UInt32();
    public TypeReference get_Int64();
    public TypeReference get_UInt64();
    public TypeReference get_Single();
    public TypeReference get_Double();
    public TypeReference get_IntPtr();
    public TypeReference get_UIntPtr();
    public TypeReference get_String();
    public TypeReference get_TypedReference();
}
internal enum Mono.Cecil.VariantType : Enum {
    public int value__;
    public static VariantType None;
    public static VariantType I2;
    public static VariantType I4;
    public static VariantType R4;
    public static VariantType R8;
    public static VariantType CY;
    public static VariantType Date;
    public static VariantType BStr;
    public static VariantType Dispatch;
    public static VariantType Error;
    public static VariantType Bool;
    public static VariantType Variant;
    public static VariantType Unknown;
    public static VariantType Decimal;
    public static VariantType I1;
    public static VariantType UI1;
    public static VariantType UI2;
    public static VariantType UI4;
    public static VariantType Int;
    public static VariantType UInt;
}
internal class Mono.Cecil.WriterParameters : object {
    private Stream symbol_stream;
    private ISymbolWriterProvider symbol_writer_provider;
    private bool write_symbols;
    private StrongNameKeyPair key_pair;
    public Stream SymbolStream { get; public set; }
    public ISymbolWriterProvider SymbolWriterProvider { get; public set; }
    public bool WriteSymbols { get; public set; }
    public StrongNameKeyPair StrongNameKeyPair { get; public set; }
    public Stream get_SymbolStream();
    public void set_SymbolStream(Stream value);
    public ISymbolWriterProvider get_SymbolWriterProvider();
    public void set_SymbolWriterProvider(ISymbolWriterProvider value);
    public bool get_WriteSymbols();
    public void set_WriteSymbols(bool value);
    public StrongNameKeyPair get_StrongNameKeyPair();
    public void set_StrongNameKeyPair(StrongNameKeyPair value);
}
[DefaultMemberAttribute("Item")]
internal class Mono.Collections.Generic.Collection`1 : object {
    internal T[] items;
    internal int size;
    private int version;
    public int Count { get; }
    public T Item { get; public set; }
    public int Capacity { get; public set; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private int System.Collections.ICollection.Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public Collection`1(int capacity);
    public Collection`1(ICollection`1<T> items);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public int get_Capacity();
    public void set_Capacity(int value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual void Add(T item);
    public void SetCapacity(int capacity);
    public sealed virtual bool Contains(T item);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool Remove(T item);
    public sealed virtual void Clear();
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public T[] ToArray();
    private void CheckIndex(int index);
    private void Shift(int start, int delta);
    protected virtual void OnAdd(T item, int index);
    protected virtual void OnInsert(T item, int index);
    protected virtual void OnSet(T item, int index);
    protected virtual void OnRemove(T item, int index);
    protected virtual void OnClear();
    internal virtual void Grow(int desired);
    protected void Resize(int new_size);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    public void Sort(IComparer`1<T> cmp);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
internal class Mono.Collections.Generic.ReadOnlyCollection`1 : Collection`1<T> {
    private static ReadOnlyCollection`1<T> empty;
    public static ReadOnlyCollection`1<T> Empty { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    public ReadOnlyCollection`1(T[] array);
    public ReadOnlyCollection`1(Collection`1<T> collection);
    public static ReadOnlyCollection`1<T> get_Empty();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private void Initialize(T[] items, int size);
    internal virtual void Grow(int desired);
    protected virtual void OnAdd(T item, int index);
    protected virtual void OnClear();
    protected virtual void OnInsert(T item, int index);
    protected virtual void OnRemove(T item, int index);
    protected virtual void OnSet(T item, int index);
}
internal class Mono.CompilerServices.SymbolWriter.AnonymousScopeEntry : object {
    public int ID;
    private List`1<CapturedVariable> captured_vars;
    private List`1<CapturedScope> captured_scopes;
    public CapturedVariable[] CapturedVariables { get; }
    public CapturedScope[] CapturedScopes { get; }
    public AnonymousScopeEntry(int id);
    internal AnonymousScopeEntry(MyBinaryReader reader);
    internal void AddCapturedVariable(string name, string captured_name, CapturedKind kind);
    public CapturedVariable[] get_CapturedVariables();
    internal void AddCapturedScope(int scope, string captured_name);
    public CapturedScope[] get_CapturedScopes();
    internal void Write(MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.CapturedScope : ValueType {
    public int Scope;
    public string CapturedName;
    public CapturedScope(int scope, string captured_name);
    internal CapturedScope(MyBinaryReader reader);
    internal void Write(MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.CapturedVariable : ValueType {
    public string Name;
    public string CapturedName;
    public CapturedKind Kind;
    public CapturedVariable(string name, string captured_name, CapturedKind kind);
    internal CapturedVariable(MyBinaryReader reader);
    internal void Write(MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.CodeBlockEntry : object {
    public int Index;
    public int Parent;
    public Type BlockType;
    public int StartOffset;
    public int EndOffset;
    public CodeBlockEntry(int index, int parent, Type type, int start_offset);
    internal CodeBlockEntry(int index, MyBinaryReader reader);
    public void Close(int end_offset);
    internal void Write(MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.CompileUnitEntry : object {
    public int Index;
    private int DataOffset;
    private MonoSymbolFile file;
    private SourceFileEntry source;
    private List`1<SourceFileEntry> include_files;
    private List`1<NamespaceEntry> namespaces;
    private bool creating;
    public static int Size { get; }
    private CompileUnitEntry Mono.CompilerServices.SymbolWriter.ICompileUnit.Entry { get; }
    public SourceFileEntry SourceFile { get; }
    public NamespaceEntry[] Namespaces { get; }
    public SourceFileEntry[] IncludeFiles { get; }
    public CompileUnitEntry(MonoSymbolFile file, SourceFileEntry source);
    internal CompileUnitEntry(MonoSymbolFile file, MyBinaryReader reader);
    public static int get_Size();
    private sealed virtual override CompileUnitEntry Mono.CompilerServices.SymbolWriter.ICompileUnit.get_Entry();
    public void AddFile(SourceFileEntry file);
    public SourceFileEntry get_SourceFile();
    public int DefineNamespace(string name, String[] using_clauses, int parent);
    internal void WriteData(MyBinaryWriter bw);
    internal void Write(BinaryWriter bw);
    public void ReadAll();
    private void ReadData();
    public NamespaceEntry[] get_Namespaces();
    public SourceFileEntry[] get_IncludeFiles();
}
internal interface Mono.CompilerServices.SymbolWriter.ICompileUnit {
    public CompileUnitEntry Entry { get; }
    public abstract virtual CompileUnitEntry get_Entry();
}
internal interface Mono.CompilerServices.SymbolWriter.IMethodDef {
    public string Name { get; }
    public int Token { get; }
    public abstract virtual string get_Name();
    public abstract virtual int get_Token();
}
internal interface Mono.CompilerServices.SymbolWriter.ISourceFile {
    public SourceFileEntry Entry { get; }
    public abstract virtual SourceFileEntry get_Entry();
}
internal class Mono.CompilerServices.SymbolWriter.LineNumberEntry : object {
    public int Row;
    public int Column;
    public int EndRow;
    public int EndColumn;
    public int File;
    public int Offset;
    public bool IsHidden;
    public static LineNumberEntry Null;
    public LineNumberEntry(int file, int row, int column, int offset);
    public LineNumberEntry(int file, int row, int offset);
    public LineNumberEntry(int file, int row, int column, int offset, bool is_hidden);
    public LineNumberEntry(int file, int row, int column, int end_row, int end_column, int offset, bool is_hidden);
    private static LineNumberEntry();
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.LineNumberTable : object {
    protected LineNumberEntry[] _line_numbers;
    public int LineBase;
    public int LineRange;
    public byte OpcodeBase;
    public int MaxAddressIncrement;
    public static int Default_LineBase;
    public static int Default_LineRange;
    public static byte Default_OpcodeBase;
    public static byte DW_LNS_copy;
    public static byte DW_LNS_advance_pc;
    public static byte DW_LNS_advance_line;
    public static byte DW_LNS_set_file;
    public static byte DW_LNS_const_add_pc;
    public static byte DW_LNE_end_sequence;
    public static byte DW_LNE_MONO_negate_is_hidden;
    internal static byte DW_LNE_MONO__extensions_start;
    internal static byte DW_LNE_MONO__extensions_end;
    public LineNumberEntry[] LineNumbers { get; }
    protected LineNumberTable(MonoSymbolFile file);
    internal LineNumberTable(MonoSymbolFile file, LineNumberEntry[] lines);
    public LineNumberEntry[] get_LineNumbers();
    internal void Write(MonoSymbolFile file, MyBinaryWriter bw, bool hasColumnsInfo, bool hasEndInfo);
    internal static LineNumberTable Read(MonoSymbolFile file, MyBinaryReader br, bool readColumnsInfo, bool readEndInfo);
    private void DoRead(MonoSymbolFile file, MyBinaryReader br, bool includesColumns, bool includesEnds);
    public bool GetMethodBounds(LineNumberEntry& start, LineNumberEntry& end);
}
internal class Mono.CompilerServices.SymbolWriter.LocalVariableEntry : ValueType {
    public int Index;
    public string Name;
    public int BlockIndex;
    public LocalVariableEntry(int index, string name, int block);
    internal LocalVariableEntry(MonoSymbolFile file, MyBinaryReader reader);
    internal void Write(MonoSymbolFile file, MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.MethodEntry : object {
    public int CompileUnitIndex;
    public int Token;
    public int NamespaceID;
    private int DataOffset;
    private int LocalVariableTableOffset;
    private int LineNumberTableOffset;
    private int CodeBlockTableOffset;
    private int ScopeVariableTableOffset;
    private int RealNameOffset;
    private Flags flags;
    private int index;
    public CompileUnitEntry CompileUnit;
    private LocalVariableEntry[] locals;
    private CodeBlockEntry[] code_blocks;
    private ScopeVariable[] scope_vars;
    private LineNumberTable lnt;
    private string real_name;
    public MonoSymbolFile SymbolFile;
    public static int Size;
    public Flags MethodFlags { get; }
    public int Index { get; public set; }
    internal MethodEntry(MonoSymbolFile file, MyBinaryReader reader, int index);
    internal MethodEntry(MonoSymbolFile file, CompileUnitEntry comp_unit, int token, ScopeVariable[] scope_vars, LocalVariableEntry[] locals, LineNumberEntry[] lines, CodeBlockEntry[] code_blocks, string real_name, Flags flags, int namespace_id);
    public Flags get_MethodFlags();
    public int get_Index();
    public void set_Index(int value);
    private static void CheckLineNumberTable(LineNumberEntry[] line_numbers);
    internal void Write(MyBinaryWriter bw);
    internal void WriteData(MonoSymbolFile file, MyBinaryWriter bw);
    public void ReadAll();
    public LineNumberTable GetLineNumberTable();
    public LocalVariableEntry[] GetLocals();
    public CodeBlockEntry[] GetCodeBlocks();
    public ScopeVariable[] GetScopeVariables();
    public string GetRealName();
    public sealed virtual int CompareTo(object obj);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.MonoSymbolFile : object {
    private List`1<MethodEntry> methods;
    private List`1<SourceFileEntry> sources;
    private List`1<CompileUnitEntry> comp_units;
    private Dictionary`2<int, AnonymousScopeEntry> anonymous_scopes;
    private OffsetTable ot;
    private int last_type_index;
    private int last_method_index;
    private int last_namespace_index;
    public int MajorVersion;
    public int MinorVersion;
    public int NumLineNumbers;
    private MyBinaryReader reader;
    private Dictionary`2<int, SourceFileEntry> source_file_hash;
    private Dictionary`2<int, CompileUnitEntry> compile_unit_hash;
    private List`1<MethodEntry> method_list;
    private Dictionary`2<int, MethodEntry> method_token_hash;
    private Dictionary`2<string, int> source_name_hash;
    private Guid guid;
    internal int LineNumberCount;
    internal int LocalCount;
    internal int StringSize;
    internal int LineNumberSize;
    internal int ExtendedLineNumberSize;
    public int CompileUnitCount { get; }
    public int SourceCount { get; }
    public int MethodCount { get; }
    public int TypeCount { get; }
    public int AnonymousScopeCount { get; }
    public int NamespaceCount { get; }
    public Guid Guid { get; }
    public OffsetTable OffsetTable { get; }
    public SourceFileEntry[] Sources { get; }
    public CompileUnitEntry[] CompileUnits { get; }
    public MethodEntry[] Methods { get; }
    internal MyBinaryReader BinaryReader { get; }
    private MonoSymbolFile(Stream stream);
    public int AddSource(SourceFileEntry source);
    public int AddCompileUnit(CompileUnitEntry entry);
    public void AddMethod(MethodEntry entry);
    public MethodEntry DefineMethod(CompileUnitEntry comp_unit, int token, ScopeVariable[] scope_vars, LocalVariableEntry[] locals, LineNumberEntry[] lines, CodeBlockEntry[] code_blocks, string real_name, Flags flags, int namespace_id);
    internal void DefineAnonymousScope(int id);
    internal void DefineCapturedVariable(int scope_id, string name, string captured_name, CapturedKind kind);
    internal void DefineCapturedScope(int scope_id, int id, string captured_name);
    internal int GetNextTypeIndex();
    internal int GetNextMethodIndex();
    internal int GetNextNamespaceIndex();
    private void Write(MyBinaryWriter bw, Guid guid);
    public void CreateSymbolFile(Guid guid, FileStream fs);
    public static MonoSymbolFile ReadSymbolFile(Assembly assembly);
    public static MonoSymbolFile ReadSymbolFile(string mdbFilename);
    public static MonoSymbolFile ReadSymbolFile(string mdbFilename, Guid assemblyGuid);
    public static MonoSymbolFile ReadSymbolFile(Stream stream);
    public int get_CompileUnitCount();
    public int get_SourceCount();
    public int get_MethodCount();
    public int get_TypeCount();
    public int get_AnonymousScopeCount();
    public int get_NamespaceCount();
    public Guid get_Guid();
    public OffsetTable get_OffsetTable();
    public SourceFileEntry GetSourceFile(int index);
    public SourceFileEntry[] get_Sources();
    public CompileUnitEntry GetCompileUnit(int index);
    public CompileUnitEntry[] get_CompileUnits();
    private void read_methods();
    public MethodEntry GetMethodByToken(int token);
    public MethodEntry GetMethod(int index);
    public MethodEntry[] get_Methods();
    public int FindSource(string file_name);
    public AnonymousScopeEntry GetAnonymousScope(int id);
    internal MyBinaryReader get_BinaryReader();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal class Mono.CompilerServices.SymbolWriter.MonoSymbolFileException : Exception {
    public MonoSymbolFileException(string message, Object[] args);
    public MonoSymbolFileException(string message, Exception innerException);
}
internal class Mono.CompilerServices.SymbolWriter.MonoSymbolWriter : object {
    private List`1<SourceMethodBuilder> methods;
    private List`1<SourceFileEntry> sources;
    private List`1<CompileUnitEntry> comp_units;
    protected MonoSymbolFile file;
    private string filename;
    private SourceMethodBuilder current_method;
    private Stack`1<SourceMethodBuilder> current_method_stack;
    public MonoSymbolFile SymbolFile { get; }
    public MonoSymbolWriter(string filename);
    public MonoSymbolFile get_SymbolFile();
    public void CloseNamespace();
    public void DefineLocalVariable(int index, string name);
    public void DefineCapturedLocal(int scope_id, string name, string captured_name);
    public void DefineCapturedParameter(int scope_id, string name, string captured_name);
    public void DefineCapturedThis(int scope_id, string captured_name);
    public void DefineCapturedScope(int scope_id, int id, string captured_name);
    public void DefineScopeVariable(int scope, int index);
    public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, bool is_hidden);
    public SourceMethodBuilder OpenMethod(ICompileUnit file, int ns_id, IMethodDef method);
    public void CloseMethod();
    public SourceFileEntry DefineDocument(string url);
    public SourceFileEntry DefineDocument(string url, Byte[] guid, Byte[] checksum);
    public CompileUnitEntry DefineCompilationUnit(SourceFileEntry source);
    public int DefineNamespace(string name, CompileUnitEntry unit, String[] using_clauses, int parent);
    public int OpenScope(int start_offset);
    public void CloseScope(int end_offset);
    public void OpenCompilerGeneratedBlock(int start_offset);
    public void CloseCompilerGeneratedBlock(int end_offset);
    public void StartIteratorBody(int start_offset);
    public void EndIteratorBody(int end_offset);
    public void StartIteratorDispatcher(int start_offset);
    public void EndIteratorDispatcher(int end_offset);
    public void DefineAnonymousScope(int id);
    public void WriteSymbolFile(Guid guid);
}
internal class Mono.CompilerServices.SymbolWriter.MyBinaryReader : BinaryReader {
    public MyBinaryReader(Stream stream);
    public int ReadLeb128();
    public string ReadString(int offset);
}
internal class Mono.CompilerServices.SymbolWriter.MyBinaryWriter : BinaryWriter {
    public MyBinaryWriter(Stream stream);
    public void WriteLeb128(int value);
}
internal class Mono.CompilerServices.SymbolWriter.NamespaceEntry : ValueType {
    public string Name;
    public int Index;
    public int Parent;
    public String[] UsingClauses;
    public NamespaceEntry(string name, int index, String[] using_clauses, int parent);
    internal NamespaceEntry(MonoSymbolFile file, MyBinaryReader reader);
    internal void Write(MonoSymbolFile file, MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.NamespaceInfo : object {
    public string Name;
    public int NamespaceID;
    public ArrayList UsingClauses;
}
internal class Mono.CompilerServices.SymbolWriter.OffsetTable : object {
    public static int MajorVersion;
    public static int MinorVersion;
    public static long Magic;
    public int TotalFileSize;
    public int DataSectionOffset;
    public int DataSectionSize;
    public int CompileUnitCount;
    public int CompileUnitTableOffset;
    public int CompileUnitTableSize;
    public int SourceCount;
    public int SourceTableOffset;
    public int SourceTableSize;
    public int MethodCount;
    public int MethodTableOffset;
    public int MethodTableSize;
    public int TypeCount;
    public int AnonymousScopeCount;
    public int AnonymousScopeTableOffset;
    public int AnonymousScopeTableSize;
    public Flags FileFlags;
    public int LineNumberTable_LineBase;
    public int LineNumberTable_LineRange;
    public int LineNumberTable_OpcodeBase;
    internal OffsetTable(BinaryReader reader, int major_version, int minor_version);
    internal void Write(BinaryWriter bw, int major_version, int minor_version);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.ScopeVariable : ValueType {
    public int Scope;
    public int Index;
    public ScopeVariable(int scope, int index);
    internal ScopeVariable(MyBinaryReader reader);
    internal void Write(MyBinaryWriter bw);
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.SourceFileEntry : object {
    public int Index;
    private int DataOffset;
    private MonoSymbolFile file;
    private string file_name;
    private Byte[] guid;
    private Byte[] hash;
    private bool creating;
    private bool auto_generated;
    public static int Size { get; }
    public Byte[] Checksum { get; }
    public string FileName { get; public set; }
    public bool AutoGenerated { get; }
    public SourceFileEntry(MonoSymbolFile file, string file_name);
    public SourceFileEntry(MonoSymbolFile file, string file_name, Byte[] guid, Byte[] checksum);
    internal SourceFileEntry(MonoSymbolFile file, MyBinaryReader reader);
    public static int get_Size();
    public Byte[] get_Checksum();
    internal void WriteData(MyBinaryWriter bw);
    internal void Write(BinaryWriter bw);
    public string get_FileName();
    public void set_FileName(string value);
    public bool get_AutoGenerated();
    public void SetAutoGenerated();
    public bool CheckChecksum();
    public virtual string ToString();
}
internal class Mono.CompilerServices.SymbolWriter.SourceMethodBuilder : object {
    private List`1<LocalVariableEntry> _locals;
    private List`1<CodeBlockEntry> _blocks;
    private List`1<ScopeVariable> _scope_vars;
    private Stack`1<CodeBlockEntry> _block_stack;
    private List`1<LineNumberEntry> method_lines;
    private ICompileUnit _comp_unit;
    private int ns_id;
    private IMethodDef method;
    public CodeBlockEntry[] Blocks { get; }
    public CodeBlockEntry CurrentBlock { get; }
    public LocalVariableEntry[] Locals { get; }
    public ICompileUnit SourceFile { get; }
    public ScopeVariable[] ScopeVariables { get; }
    public SourceMethodBuilder(ICompileUnit comp_unit);
    public SourceMethodBuilder(ICompileUnit comp_unit, int ns_id, IMethodDef method);
    public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, bool is_hidden);
    public void MarkSequencePoint(int offset, SourceFileEntry file, int line, int column, int end_line, int end_column, bool is_hidden);
    public void StartBlock(Type type, int start_offset);
    public void EndBlock(int end_offset);
    public CodeBlockEntry[] get_Blocks();
    public CodeBlockEntry get_CurrentBlock();
    public LocalVariableEntry[] get_Locals();
    public ICompileUnit get_SourceFile();
    public void AddLocal(int index, string name);
    public ScopeVariable[] get_ScopeVariables();
    public void AddScopeVariable(int scope, int index);
    public void DefineMethod(MonoSymbolFile file);
    public void DefineMethod(MonoSymbolFile file, int token);
}
internal class Mono.CompilerServices.SymbolWriter.SourceMethodImpl : object {
    private string name;
    private int token;
    private int namespaceID;
    public string Name { get; }
    public int NamespaceID { get; }
    public int Token { get; }
    public SourceMethodImpl(string name, int token, int namespaceID);
    public sealed virtual string get_Name();
    public int get_NamespaceID();
    public sealed virtual int get_Token();
}
internal class Mono.CompilerServices.SymbolWriter.SymbolDocumentWriterImpl : object {
    private CompileUnitEntry comp_unit;
    private SourceFileEntry Mono.CompilerServices.SymbolWriter.ISourceFile.Entry { get; }
    public CompileUnitEntry Entry { get; }
    public SymbolDocumentWriterImpl(CompileUnitEntry comp_unit);
    public sealed virtual void SetCheckSum(Guid algorithmId, Byte[] checkSum);
    public sealed virtual void SetSource(Byte[] source);
    private sealed virtual override SourceFileEntry Mono.CompilerServices.SymbolWriter.ISourceFile.get_Entry();
    public sealed virtual CompileUnitEntry get_Entry();
}
internal class Mono.CompilerServices.SymbolWriter.SymbolWriterImpl : object {
    private MonoSymbolWriter msw;
    private int nextLocalIndex;
    private int currentToken;
    private string methodName;
    private Stack namespaceStack;
    private bool methodOpened;
    private Hashtable documents;
    private Guid guid;
    public SymbolWriterImpl(Guid guid);
    public sealed virtual void Close();
    public sealed virtual void CloseMethod();
    public sealed virtual void CloseNamespace();
    public sealed virtual void CloseScope(int endOffset);
    public sealed virtual ISymbolDocumentWriter DefineDocument(string url, Guid language, Guid languageVendor, Guid documentType);
    public sealed virtual void DefineField(SymbolToken parent, string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3);
    public sealed virtual void DefineGlobalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3);
    public sealed virtual void DefineLocalVariable(string name, FieldAttributes attributes, Byte[] signature, SymAddressKind addrKind, int addr1, int addr2, int addr3, int startOffset, int endOffset);
    public sealed virtual void DefineParameter(string name, ParameterAttributes attributes, int sequence, SymAddressKind addrKind, int addr1, int addr2, int addr3);
    public sealed virtual void DefineSequencePoints(ISymbolDocumentWriter document, Int32[] offsets, Int32[] lines, Int32[] columns, Int32[] endLines, Int32[] endColumns);
    public sealed virtual void Initialize(IntPtr emitter, string filename, bool fFullBuild);
    public sealed virtual void OpenMethod(SymbolToken method);
    public sealed virtual void OpenNamespace(string name);
    public sealed virtual int OpenScope(int startOffset);
    public sealed virtual void SetMethodSourceRange(ISymbolDocumentWriter startDoc, int startLine, int startColumn, ISymbolDocumentWriter endDoc, int endLine, int endColumn);
    public sealed virtual void SetScopeRange(int scopeID, int startOffset, int endOffset);
    public sealed virtual void SetSymAttribute(SymbolToken parent, string name, Byte[] data);
    public sealed virtual void SetUnderlyingWriter(IntPtr underlyingWriter);
    public sealed virtual void SetUserEntryPoint(SymbolToken entryMethod);
    public sealed virtual void UsingNamespace(string fullName);
    private int GetCurrentNamespace(ISymbolDocumentWriter doc);
}
internal static class Mono.Empty`1 : object {
    public static T[] Array;
    private static Empty`1();
}
[FlagsAttribute]
[ObsoleteAttribute("Use Mono.Unix.Native.AccessModes")]
[CLSCompliantAttribute("False")]
internal enum Mono.Posix.AccessMode : Enum {
    public int value__;
    public static AccessMode R_OK;
    public static AccessMode W_OK;
    public static AccessMode X_OK;
    public static AccessMode F_OK;
}
[ObsoleteAttribute("Use Mono.Unix.Catalog")]
internal class Mono.Posix.Catalog : object {
    private static IntPtr bindtextdomain(IntPtr domainname, IntPtr dirname);
    private static IntPtr bind_textdomain_codeset(IntPtr domainname, IntPtr codeset);
    private static IntPtr textdomain(IntPtr domainname);
    public static void Init(string package, string localedir);
    private static IntPtr gettext(IntPtr instring);
    public static string GetString(string s);
    private static IntPtr ngettext(IntPtr singular, IntPtr plural, int n);
    public static string GetPluralString(string s, string p, int n);
}
[ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions")]
[FlagsAttribute]
[CLSCompliantAttribute("False")]
internal enum Mono.Posix.FileMode : Enum {
    public int value__;
    public static FileMode S_ISUID;
    public static FileMode S_ISGID;
    public static FileMode S_ISVTX;
    public static FileMode S_IRUSR;
    public static FileMode S_IWUSR;
    public static FileMode S_IXUSR;
    public static FileMode S_IRGRP;
    public static FileMode S_IWGRP;
    public static FileMode S_IXGRP;
    public static FileMode S_IROTH;
    public static FileMode S_IWOTH;
    public static FileMode S_IXOTH;
}
[CLSCompliantAttribute("False")]
[ObsoleteAttribute("Use Mono.Unix.Native.OpenFlags")]
[FlagsAttribute]
internal enum Mono.Posix.OpenFlags : Enum {
    public int value__;
    public static OpenFlags O_RDONLY;
    public static OpenFlags O_WRONLY;
    public static OpenFlags O_RDWR;
    public static OpenFlags O_CREAT;
    public static OpenFlags O_EXCL;
    public static OpenFlags O_NOCTTY;
    public static OpenFlags O_TRUNC;
    public static OpenFlags O_APPEND;
    public static OpenFlags O_NONBLOCK;
    public static OpenFlags O_SYNC;
}
[ObsoleteAttribute("Use Mono.Unix.PeerCred")]
internal class Mono.Posix.PeerCred : object {
    private static int so_peercred;
    private PeerCredData data;
    public int ProcessID { get; }
    public int UserID { get; }
    public int GroupID { get; }
    public PeerCred(Socket sock);
    public int get_ProcessID();
    public int get_UserID();
    public int get_GroupID();
}
internal class Mono.Posix.PeerCredData : ValueType {
    public int pid;
    public int uid;
    public int gid;
}
[ObsoleteAttribute("Use Mono.Unix.Native.Signum")]
[CLSCompliantAttribute("False")]
internal enum Mono.Posix.Signals : Enum {
    public int value__;
    public static Signals SIGHUP;
    public static Signals SIGINT;
    public static Signals SIGQUIT;
    public static Signals SIGILL;
    public static Signals SIGTRAP;
    public static Signals SIGABRT;
    public static Signals SIGBUS;
    public static Signals SIGFPE;
    public static Signals SIGKILL;
    public static Signals SIGUSR1;
    public static Signals SIGSEGV;
    public static Signals SIGUSR2;
    public static Signals SIGPIPE;
    public static Signals SIGALRM;
    public static Signals SIGTERM;
    public static Signals SIGCHLD;
    public static Signals SIGCONT;
    public static Signals SIGSTOP;
    public static Signals SIGTSTP;
    public static Signals SIGTTIN;
    public static Signals SIGTTOU;
    public static Signals SIGURG;
    public static Signals SIGXCPU;
    public static Signals SIGXFSZ;
    public static Signals SIGVTALRM;
    public static Signals SIGPROF;
    public static Signals SIGWINCH;
    public static Signals SIGIO;
    public static Signals SIGSYS;
}
[ObsoleteAttribute("Use Mono.Unix.Native.Stat")]
internal class Mono.Posix.Stat : ValueType {
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_dev")]
public int Device;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_ino")]
public int INode;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_mode")]
public StatMode Mode;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_nlink")]
public int NLinks;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_uid")]
public int Uid;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_gid")]
public int Gid;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_rdev")]
public long DeviceType;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_size")]
public long Size;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_blksize")]
public long BlockSize;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_blocks")]
public long Blocks;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_atime")]
public DateTime ATime;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_mtime")]
public DateTime MTime;
    [ObsoleteAttribute("Use Mono.Unix.Native.Stat.st_ctime")]
public DateTime CTime;
    [ObsoleteAttribute("Use Mono.Unix.Native.NativeConvert.LocalUnixEpoch")]
public static DateTime UnixEpoch;
    internal Stat(int device, int inode, int mode, int nlinks, int uid, int gid, int rdev, long size, long blksize, long blocks, long atime, long mtime, long ctime);
    private static Stat();
    [ObsoleteAttribute("Use Mono.Unix.Native.NativeConvert.ToDateTime")]
public static DateTime UnixToDateTime(long unix);
}
[ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions")]
[FlagsAttribute]
internal enum Mono.Posix.StatMode : Enum {
    public int value__;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IFSOCK")]
public static StatMode Socket;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IFLNK")]
public static StatMode SymLink;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IFREG")]
public static StatMode Regular;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IFBLK")]
public static StatMode BlockDevice;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IFDIR")]
public static StatMode Directory;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IFCHR")]
public static StatMode CharDevice;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IFIFO")]
public static StatMode FIFO;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_ISUID")]
public static StatMode SUid;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_ISGID")]
public static StatMode SGid;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_ISVTX")]
public static StatMode Sticky;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IRUSR")]
public static StatMode OwnerRead;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IWUSR")]
public static StatMode OwnerWrite;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IXUSR")]
public static StatMode OwnerExecute;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IRGRP")]
public static StatMode GroupRead;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IWGRP")]
public static StatMode GroupWrite;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IXGRP")]
public static StatMode GroupExecute;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IROTH")]
public static StatMode OthersRead;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IWOTH")]
public static StatMode OthersWrite;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IXOTH")]
public static StatMode OthersExecute;
}
[ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions")]
internal enum Mono.Posix.StatModeMasks : Enum {
    public int value__;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_IFMT")]
public static StatModeMasks TypeMask;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_RWXU")]
public static StatModeMasks OwnerMask;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_RWXG")]
public static StatModeMasks GroupMask;
    [ObsoleteAttribute("Use Mono.Unix.Native.FilePermissions.S_RWXO")]
public static StatModeMasks OthersMask;
}
[CLSCompliantAttribute("False")]
[ObsoleteAttribute("Use Mono.Unix.Native.Syscall.")]
internal class Mono.Posix.Syscall : object {
    public static int exit(int status);
    public static int fork();
    public static IntPtr read(int fileDescriptor, Void* buf, IntPtr count);
    public static IntPtr write(int fileDescriptor, Void* buf, IntPtr count);
    internal static int syscall_open(string pathname, int flags, int mode);
    internal static int map_Mono_Posix_OpenFlags(OpenFlags flags);
    internal static int map_Mono_Posix_FileMode(FileMode mode);
    public static int open(string pathname, OpenFlags flags);
    public static int open(string pathname, OpenFlags flags, FileMode mode);
    public static int close(int fileDescriptor);
    internal static int syscall_waitpid(int pid, Int32* status, int options);
    internal static int map_Mono_Posix_WaitOptions(WaitOptions wait_options);
    public static int waitpid(int pid, Int32& status, WaitOptions options);
    public static int waitpid(int pid, WaitOptions options);
    public static int WIFEXITED(int status);
    public static int WEXITSTATUS(int status);
    public static int WIFSIGNALED(int status);
    public static int WTERMSIG(int status);
    public static int WIFSTOPPED(int status);
    public static int WSTOPSIG(int status);
    internal static int syscall_creat(string pathname, int flags);
    public static int creat(string pathname, FileMode flags);
    public static int link(string oldPath, string newPath);
    public static int unlink(string path);
    public static int symlink(string oldpath, string newpath);
    public static int chdir(string path);
    internal static int syscall_chmod(string path, int mode);
    public static int chmod(string path, FileMode mode);
    public static int chown(string path, int owner, int group);
    public static int lchown(string path, int owner, int group);
    public static int lseek(int fileDescriptor, int offset, int whence);
    public static int getpid();
    public static int setuid(int uid);
    public static int getuid();
    public static UInt32 alarm(UInt32 seconds);
    public static int pause();
    internal static int syscall_access(string pathname, int mode);
    internal static int map_Mono_Posix_AccessMode(AccessMode mode);
    public static int access(string pathname, AccessMode mode);
    public static int nice(int increment);
    public static void sync();
    public static void kill(int pid, int sig);
    public static int rename(string oldPath, string newPath);
    internal static int syscall_mkdir(string pathname, int mode);
    public static int mkdir(string pathname, FileMode mode);
    public static int rmdir(string path);
    public static int dup(int fileDescriptor);
    public static int setgid(int gid);
    public static int getgid();
    public static int signal(int signum, sighandler_t handler);
    public static int geteuid();
    public static int getegid();
    public static int setpgid(int pid, int pgid);
    public static int umask(int umask);
    public static int chroot(string path);
    public static int dup2(int oldFileDescriptor, int newFileDescriptor);
    public static int getppid();
    public static int getpgrp();
    public static int setsid();
    public static int setreuid(int ruid, int euid);
    public static int setregid(int rgid, int egid);
    private static string helper_Mono_Posix_GetUserName(int uid);
    private static string helper_Mono_Posix_GetGroupName(int gid);
    public static string getusername(int uid);
    public static string getgroupname(int gid);
    private static int syscall_gethostname(Byte[] p, int len);
    public static string GetHostName();
    [CLSCompliantAttribute("False")]
public static string gethostname();
    private static int syscall_isatty(int desc);
    public static bool isatty(int desc);
    internal static int helper_Mono_Posix_Stat(string filename, bool dereference, Int32& device, Int32& inode, Int32& mode, Int32& nlinks, Int32& uid, Int32& gid, Int32& rdev, Int64& size, Int64& blksize, Int64& blocks, Int64& atime, Int64& mtime, Int64& ctime);
    private static int stat2(string filename, bool dereference, Stat& stat);
    public static int stat(string filename, Stat& stat);
    public static int lstat(string filename, Stat& stat);
    private static int readlink(string path, Byte[] buffer, int buflen);
    public static string readlink(string path);
    private static IntPtr _strerror(int errnum);
    public static string strerror(int errnum);
    public static IntPtr opendir(string path);
    public static int closedir(IntPtr dir);
    public static string readdir(IntPtr dir);
}
[ObsoleteAttribute("Use Mono.Unix.UnixEndPoint")]
internal class Mono.Posix.UnixEndPoint : EndPoint {
    private string filename;
    public string Filename { get; public set; }
    public AddressFamily AddressFamily { get; }
    public UnixEndPoint(string filename);
    public string get_Filename();
    public void set_Filename(string value);
    public virtual AddressFamily get_AddressFamily();
    public virtual EndPoint Create(SocketAddress socketAddress);
    public virtual SocketAddress Serialize();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
[CLSCompliantAttribute("False")]
[FlagsAttribute]
[ObsoleteAttribute("Use Mono.Unix.Native.WaitOptions")]
internal enum Mono.Posix.WaitOptions : Enum {
    public int value__;
    public static WaitOptions WNOHANG;
    public static WaitOptions WUNTRACED;
}
internal class Mono.Remoting.Channels.Unix.ClientConnection : object {
    private Socket _client;
    private UnixServerTransportSink _sink;
    private Stream _stream;
    private UnixServerChannel _serverChannel;
    private Byte[] _buffer;
    public Socket Client { get; }
    public Byte[] Buffer { get; }
    public bool IsLocal { get; }
    public ClientConnection(UnixServerChannel serverChannel, Socket client, UnixServerTransportSink sink);
    public Socket get_Client();
    public Byte[] get_Buffer();
    public void ProcessMessages();
    public bool get_IsLocal();
}
internal class Mono.Remoting.Channels.Unix.HostConnectionPool : object {
    private ArrayList _pool;
    private int _activeConnections;
    private string _path;
    public HostConnectionPool(string path);
    public UnixConnection GetConnection();
    private UnixConnection CreateConnection();
    public void ReleaseConnection(UnixConnection entry);
    private void CancelConnection(UnixConnection entry);
    public void PurgeConnections();
}
internal enum Mono.Remoting.Channels.Unix.MessageStatus : Enum {
    public int value__;
    public static MessageStatus MethodMessage;
    public static MessageStatus CancelSignal;
    public static MessageStatus Unknown;
}
internal class Mono.Remoting.Channels.Unix.MethodCallHeaderHandler : object {
    private string _uri;
    public MethodCallHeaderHandler(string uri);
    public object HandleHeaders(Header[] headers);
}
internal class Mono.Remoting.Channels.Unix.ReusableUnixClient : UnixClient {
    public bool IsAlive { get; }
    public ReusableUnixClient(string path);
    public bool get_IsAlive();
}
internal class Mono.Remoting.Channels.Unix.SimpleBinder : SerializationBinder {
    public static SimpleBinder Instance;
    private static SimpleBinder();
    public virtual Type BindToType(string assemblyName, string typeName);
}
internal class Mono.Remoting.Channels.Unix.UnixBinaryClientFormatterSink : object {
    private UnixBinaryCore _binaryCore;
    private IClientChannelSink _nextInChain;
    internal UnixBinaryCore BinaryCore { get; internal set; }
    public IClientChannelSink NextChannelSink { get; }
    public IMessageSink NextSink { get; }
    public IDictionary Properties { get; }
    public UnixBinaryClientFormatterSink(IClientChannelSink nextSink);
    internal UnixBinaryCore get_BinaryCore();
    internal void set_BinaryCore(UnixBinaryCore value);
    public sealed virtual IClientChannelSink get_NextChannelSink();
    public sealed virtual IMessageSink get_NextSink();
    public sealed virtual IDictionary get_Properties();
    public sealed virtual void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg, ITransportHeaders headers, Stream stream);
    public sealed virtual void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, object state, ITransportHeaders headers, Stream stream);
    public sealed virtual Stream GetRequestStream(IMessage msg, ITransportHeaders headers);
    public sealed virtual void ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, ITransportHeaders& responseHeaders, Stream& responseStream);
    public sealed virtual IMessageCtrl AsyncProcessMessage(IMessage msg, IMessageSink replySink);
    public sealed virtual IMessage SyncProcessMessage(IMessage msg);
}
internal class Mono.Remoting.Channels.Unix.UnixBinaryClientFormatterSinkProvider : object {
    private IClientChannelSinkProvider next;
    private UnixBinaryCore _binaryCore;
    private static String[] allowedProperties;
    public IClientChannelSinkProvider Next { get; public set; }
    public UnixBinaryClientFormatterSinkProvider(IDictionary properties, ICollection providerData);
    private static UnixBinaryClientFormatterSinkProvider();
    public sealed virtual IClientChannelSinkProvider get_Next();
    public sealed virtual void set_Next(IClientChannelSinkProvider value);
    public sealed virtual IClientChannelSink CreateSink(IChannelSender channel, string url, object remoteChannelData);
}
internal class Mono.Remoting.Channels.Unix.UnixBinaryCore : object {
    private BinaryFormatter _serializationFormatter;
    private BinaryFormatter _deserializationFormatter;
    private bool _includeVersions;
    private bool _strictBinding;
    private IDictionary _properties;
    public static UnixBinaryCore DefaultInstance;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, int> <>f__switch$map0;
    public BinaryFormatter Serializer { get; }
    public BinaryFormatter Deserializer { get; }
    public IDictionary Properties { get; }
    public UnixBinaryCore(object owner, IDictionary properties, String[] allowedProperties);
    private static UnixBinaryCore();
    public void Init();
    public BinaryFormatter get_Serializer();
    public BinaryFormatter get_Deserializer();
    public IDictionary get_Properties();
}
internal class Mono.Remoting.Channels.Unix.UnixBinaryServerFormatterSink : object {
    private UnixBinaryCore _binaryCore;
    private IServerChannelSink next_sink;
    private IChannelReceiver receiver;
    internal UnixBinaryCore BinaryCore { get; internal set; }
    public IServerChannelSink NextChannelSink { get; }
    public IDictionary Properties { get; }
    public UnixBinaryServerFormatterSink(IServerChannelSink nextSink, IChannelReceiver receiver);
    internal UnixBinaryCore get_BinaryCore();
    internal void set_BinaryCore(UnixBinaryCore value);
    public sealed virtual IServerChannelSink get_NextChannelSink();
    public sealed virtual IDictionary get_Properties();
    public sealed virtual void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage message, ITransportHeaders headers, Stream stream);
    public sealed virtual Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers);
    public sealed virtual ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, IMessage& responseMsg, ITransportHeaders& responseHeaders, Stream& responseStream);
}
internal class Mono.Remoting.Channels.Unix.UnixBinaryServerFormatterSinkProvider : object {
    private IServerChannelSinkProvider next;
    private UnixBinaryCore _binaryCore;
    internal static String[] AllowedProperties;
    public IServerChannelSinkProvider Next { get; public set; }
    public UnixBinaryServerFormatterSinkProvider(IDictionary properties, ICollection providerData);
    private static UnixBinaryServerFormatterSinkProvider();
    public sealed virtual IServerChannelSinkProvider get_Next();
    public sealed virtual void set_Next(IServerChannelSinkProvider value);
    public sealed virtual IServerChannelSink CreateSink(IChannelReceiver channel);
    public sealed virtual void GetChannelData(IChannelDataStore channelData);
}
internal class Mono.Remoting.Channels.Unix.UnixChannel : object {
    private UnixClientChannel _clientChannel;
    private UnixServerChannel _serverChannel;
    private string _name;
    private int _priority;
    public string ChannelName { get; }
    public int ChannelPriority { get; }
    public object ChannelData { get; }
    public UnixChannel(string path);
    public UnixChannel(IDictionary properties, IClientChannelSinkProvider clientSinkProvider, IServerChannelSinkProvider serverSinkProvider);
    private void Init(IDictionary properties, IClientChannelSinkProvider clientSink, IServerChannelSinkProvider serverSink);
    public sealed virtual IMessageSink CreateMessageSink(string url, object remoteChannelData, String& objectURI);
    public sealed virtual string get_ChannelName();
    public sealed virtual int get_ChannelPriority();
    public sealed virtual void StartListening(object data);
    public sealed virtual void StopListening(object data);
    public sealed virtual String[] GetUrlsForUri(string uri);
    public sealed virtual object get_ChannelData();
    public sealed virtual string Parse(string url, String& objectURI);
    internal static string ParseUnixURL(string url, String& objectURI);
}
internal class Mono.Remoting.Channels.Unix.UnixClientChannel : object {
    private int priority;
    private string name;
    private IClientChannelSinkProvider _sinkProvider;
    public string ChannelName { get; }
    public int ChannelPriority { get; }
    public UnixClientChannel(IDictionary properties, IClientChannelSinkProvider sinkProvider);
    public UnixClientChannel(string name, IClientChannelSinkProvider sinkProvider);
    public sealed virtual string get_ChannelName();
    public sealed virtual int get_ChannelPriority();
    public sealed virtual IMessageSink CreateMessageSink(string url, object remoteChannelData, String& objectURI);
    public sealed virtual string Parse(string url, String& objectURI);
}
internal class Mono.Remoting.Channels.Unix.UnixClientTransportSink : object {
    private string _path;
    public IDictionary Properties { get; }
    public IClientChannelSink NextChannelSink { get; }
    public UnixClientTransportSink(string url);
    public sealed virtual IDictionary get_Properties();
    public sealed virtual IClientChannelSink get_NextChannelSink();
    public sealed virtual void AsyncProcessRequest(IClientChannelSinkStack sinkStack, IMessage msg, ITransportHeaders headers, Stream requestStream);
    private void ReadAsyncUnixMessage(object data);
    public sealed virtual void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, object state, ITransportHeaders headers, Stream stream);
    public sealed virtual Stream GetRequestStream(IMessage msg, ITransportHeaders headers);
    public sealed virtual void ProcessMessage(IMessage msg, ITransportHeaders requestHeaders, Stream requestStream, ITransportHeaders& responseHeaders, Stream& responseStream);
    [CompilerGeneratedAttribute]
private void <AsyncProcessRequest>m__0(object data);
}
internal class Mono.Remoting.Channels.Unix.UnixClientTransportSinkProvider : object {
    public IClientChannelSinkProvider Next { get; public set; }
    public sealed virtual IClientChannelSinkProvider get_Next();
    public sealed virtual void set_Next(IClientChannelSinkProvider value);
    public sealed virtual IClientChannelSink CreateSink(IChannelSender channel, string url, object remoteChannelData);
}
internal class Mono.Remoting.Channels.Unix.UnixConnection : object {
    private DateTime _controlTime;
    private Stream _stream;
    private ReusableUnixClient _client;
    private HostConnectionPool _pool;
    private Byte[] _buffer;
    public Stream Stream { get; }
    public DateTime ControlTime { get; public set; }
    public bool IsAlive { get; }
    public Byte[] Buffer { get; }
    public UnixConnection(HostConnectionPool pool, ReusableUnixClient client);
    public Stream get_Stream();
    public DateTime get_ControlTime();
    public void set_ControlTime(DateTime value);
    public bool get_IsAlive();
    public Byte[] get_Buffer();
    public void Release();
    public void Close();
}
internal class Mono.Remoting.Channels.Unix.UnixConnectionPool : object {
    private static Hashtable _pools;
    private static int _maxOpenConnections;
    private static int _keepAliveSeconds;
    private static Thread _poolThread;
    public static int MaxOpenConnections { get; public set; }
    public static int KeepAliveSeconds { get; public set; }
    private static UnixConnectionPool();
    public static void Shutdown();
    public static int get_MaxOpenConnections();
    public static void set_MaxOpenConnections(int value);
    public static int get_KeepAliveSeconds();
    public static void set_KeepAliveSeconds(int value);
    public static UnixConnection GetConnection(string path);
    private static void ConnectionCollector();
}
internal class Mono.Remoting.Channels.Unix.UnixMessageIO : object {
    private static Byte[][] _msgHeaders;
    public static int DefaultStreamBufferSize;
    private static Byte[] msgUriTransportKey;
    private static Byte[] msgContentTypeTransportKey;
    private static Byte[] msgDefaultTransportKey;
    private static Byte[] msgHeaderTerminator;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, int> <>f__switch$map1;
    private static UnixMessageIO();
    public static MessageStatus ReceiveMessageStatus(Stream networkStream, Byte[] buffer);
    private static bool StreamRead(Stream networkStream, Byte[] buffer, int count);
    public static void SendMessageStream(Stream networkStream, Stream data, ITransportHeaders requestHeaders, Byte[] buffer);
    private static void SendHeaders(Stream networkStream, ITransportHeaders requestHeaders, Byte[] buffer);
    public static ITransportHeaders ReceiveHeaders(Stream networkStream, Byte[] buffer);
    public static Stream ReceiveMessageStream(Stream networkStream, ITransportHeaders& headers, Byte[] buffer);
    private static void SendString(Stream networkStream, string str, Byte[] buffer);
    private static string ReceiveString(Stream networkStream, Byte[] buffer);
}
internal class Mono.Remoting.Channels.Unix.UnixServerChannel : object {
    private string path;
    private string name;
    private int priority;
    private bool supressChannelData;
    private Thread server_thread;
    private UnixListener listener;
    private UnixServerTransportSink sink;
    private ChannelDataStore channel_data;
    private int _maxConcurrentConnections;
    private ArrayList _activeConnections;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, int> <>f__switch$map2;
    public object ChannelData { get; }
    public string ChannelName { get; }
    public int ChannelPriority { get; }
    public UnixServerChannel(string path);
    public UnixServerChannel(IDictionary properties, IServerChannelSinkProvider serverSinkProvider);
    public UnixServerChannel(string name, string path, IServerChannelSinkProvider serverSinkProvider);
    public UnixServerChannel(string name, string path);
    private void Init(IServerChannelSinkProvider serverSinkProvider);
    public sealed virtual object get_ChannelData();
    public sealed virtual string get_ChannelName();
    public sealed virtual int get_ChannelPriority();
    public string GetChannelUri();
    public sealed virtual String[] GetUrlsForUri(string uri);
    public sealed virtual string Parse(string url, String& objectURI);
    private void WaitForConnections();
    internal void CreateListenerConnection(Socket client);
    internal void ReleaseConnection(Thread thread);
    public sealed virtual void StartListening(object data);
    public sealed virtual void StopListening(object data);
}
internal class Mono.Remoting.Channels.Unix.UnixServerTransportSink : object {
    private IServerChannelSink next_sink;
    public IServerChannelSink NextChannelSink { get; }
    public IDictionary Properties { get; }
    public UnixServerTransportSink(IServerChannelSink next);
    public sealed virtual IServerChannelSink get_NextChannelSink();
    public sealed virtual IDictionary get_Properties();
    public sealed virtual void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers, Stream responseStream);
    public sealed virtual Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack, object state, IMessage msg, ITransportHeaders headers);
    public sealed virtual ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack, IMessage requestMsg, ITransportHeaders requestHeaders, Stream requestStream, IMessage& responseMsg, ITransportHeaders& responseHeaders, Stream& responseStream);
    internal void InternalProcessMessage(ClientConnection connection, Stream stream);
}
internal static class Mono.Security.Cryptography.CryptoConvert : object {
    private static int ToInt32LE(Byte[] bytes, int offset);
    private static UInt32 ToUInt32LE(Byte[] bytes, int offset);
    private static Byte[] Trim(Byte[] array);
    private static RSA FromCapiPrivateKeyBlob(Byte[] blob, int offset);
    private static RSA FromCapiPublicKeyBlob(Byte[] blob, int offset);
    public static RSA FromCapiKeyBlob(Byte[] blob);
    public static RSA FromCapiKeyBlob(Byte[] blob, int offset);
}
internal class Mono.Unix.AbstractUnixEndPoint : EndPoint {
    private string path;
    public string Path { get; public set; }
    public AddressFamily AddressFamily { get; }
    public AbstractUnixEndPoint(string path);
    public string get_Path();
    public void set_Path(string value);
    public virtual AddressFamily get_AddressFamily();
    public virtual EndPoint Create(SocketAddress socketAddress);
    public virtual SocketAddress Serialize();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
internal class Mono.Unix.Catalog : object {
    private static IntPtr bindtextdomain(IntPtr domainname, IntPtr dirname);
    private static IntPtr bind_textdomain_codeset(IntPtr domainname, IntPtr codeset);
    private static IntPtr textdomain(IntPtr domainname);
    public static void Init(string package, string localedir);
    private static void MarshalStrings(string s1, IntPtr& p1, string s2, IntPtr& p2, string s3, IntPtr& p3);
    private static IntPtr gettext(IntPtr instring);
    public static string GetString(string s);
    private static IntPtr ngettext(IntPtr singular, IntPtr plural, int n);
    public static string GetPluralString(string s, string p, int n);
}
internal class Mono.Unix.ErrorMarshal : object {
    internal static ErrorTranslator Translate;
    private static ErrorMarshal();
    private static string strerror(Errno errno);
    private static string strerror_r(Errno errno);
}
internal enum Mono.Unix.FileAccessPattern : Enum {
    public int value__;
    public static FileAccessPattern Normal;
    public static FileAccessPattern Sequential;
    public static FileAccessPattern Random;
    public static FileAccessPattern NoReuse;
    public static FileAccessPattern PreLoad;
    public static FileAccessPattern FlushCache;
}
[FlagsAttribute]
internal enum Mono.Unix.FileAccessPermissions : Enum {
    public int value__;
    public static FileAccessPermissions UserReadWriteExecute;
    public static FileAccessPermissions UserRead;
    public static FileAccessPermissions UserWrite;
    public static FileAccessPermissions UserExecute;
    public static FileAccessPermissions GroupReadWriteExecute;
    public static FileAccessPermissions GroupRead;
    public static FileAccessPermissions GroupWrite;
    public static FileAccessPermissions GroupExecute;
    public static FileAccessPermissions OtherReadWriteExecute;
    public static FileAccessPermissions OtherRead;
    public static FileAccessPermissions OtherWrite;
    public static FileAccessPermissions OtherExecute;
    public static FileAccessPermissions DefaultPermissions;
    public static FileAccessPermissions AllPermissions;
}
internal class Mono.Unix.FileHandleOperations : object {
    public static void AdviseFileAccessPattern(int fd, FileAccessPattern pattern, long offset, long len);
    public static void AdviseFileAccessPattern(int fd, FileAccessPattern pattern);
    public static void AdviseFileAccessPattern(FileStream file, FileAccessPattern pattern, long offset, long len);
    public static void AdviseFileAccessPattern(FileStream file, FileAccessPattern pattern);
    public static void AdviseFileAccessPattern(UnixStream stream, FileAccessPattern pattern, long offset, long len);
    public static void AdviseFileAccessPattern(UnixStream stream, FileAccessPattern pattern);
}
[FlagsAttribute]
internal enum Mono.Unix.FileSpecialAttributes : Enum {
    public int value__;
    public static FileSpecialAttributes SetUserId;
    public static FileSpecialAttributes SetGroupId;
    public static FileSpecialAttributes Sticky;
}
internal enum Mono.Unix.FileTypes : Enum {
    public int value__;
    public static FileTypes Directory;
    public static FileTypes CharacterDevice;
    public static FileTypes BlockDevice;
    public static FileTypes RegularFile;
    public static FileTypes Fifo;
    public static FileTypes SymbolicLink;
    public static FileTypes Socket;
}
[FlagsAttribute]
[MapAttribute]
[CLSCompliantAttribute("False")]
internal enum Mono.Unix.Native.AccessModes : Enum {
    public int value__;
    public static AccessModes R_OK;
    public static AccessModes W_OK;
    public static AccessModes X_OK;
    public static AccessModes F_OK;
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.blkcnt_tAttribute : MapAttribute {
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.blksize_tAttribute : MapAttribute {
}
internal class Mono.Unix.Native.CdeclFunction : object {
    private string library;
    private string method;
    private Type returnType;
    private AssemblyName assemblyName;
    private AssemblyBuilder assemblyBuilder;
    private ModuleBuilder moduleBuilder;
    private Hashtable overloads;
    public CdeclFunction(string library, string method);
    public CdeclFunction(string library, string method, Type returnType);
    public object Invoke(Object[] parameters);
    private MethodInfo CreateMethod(Type[] parameterTypes);
    private TypeBuilder CreateType(string typeName);
    private static Type GetMarshalType(Type t);
    private string GetTypeName(Type[] parameterTypes);
    private static Type[] GetParameterTypes(Object[] parameters);
}
[MapAttribute]
[CLSCompliantAttribute("False")]
internal enum Mono.Unix.Native.ConfstrName : Enum {
    public int value__;
    public static ConfstrName _CS_PATH;
    public static ConfstrName _CS_V6_WIDTH_RESTRICTED_ENVS;
    public static ConfstrName _CS_GNU_LIBC_VERSION;
    public static ConfstrName _CS_GNU_LIBPTHREAD_VERSION;
    public static ConfstrName _CS_LFS_CFLAGS;
    public static ConfstrName _CS_LFS_LDFLAGS;
    public static ConfstrName _CS_LFS_LIBS;
    public static ConfstrName _CS_LFS_LINTFLAGS;
    public static ConfstrName _CS_LFS64_CFLAGS;
    public static ConfstrName _CS_LFS64_LDFLAGS;
    public static ConfstrName _CS_LFS64_LIBS;
    public static ConfstrName _CS_LFS64_LINTFLAGS;
    public static ConfstrName _CS_XBS5_ILP32_OFF32_CFLAGS;
    public static ConfstrName _CS_XBS5_ILP32_OFF32_LDFLAGS;
    public static ConfstrName _CS_XBS5_ILP32_OFF32_LIBS;
    public static ConfstrName _CS_XBS5_ILP32_OFF32_LINTFLAGS;
    public static ConfstrName _CS_XBS5_ILP32_OFFBIG_CFLAGS;
    public static ConfstrName _CS_XBS5_ILP32_OFFBIG_LDFLAGS;
    public static ConfstrName _CS_XBS5_ILP32_OFFBIG_LIBS;
    public static ConfstrName _CS_XBS5_ILP32_OFFBIG_LINTFLAGS;
    public static ConfstrName _CS_XBS5_LP64_OFF64_CFLAGS;
    public static ConfstrName _CS_XBS5_LP64_OFF64_LDFLAGS;
    public static ConfstrName _CS_XBS5_LP64_OFF64_LIBS;
    public static ConfstrName _CS_XBS5_LP64_OFF64_LINTFLAGS;
    public static ConfstrName _CS_XBS5_LPBIG_OFFBIG_CFLAGS;
    public static ConfstrName _CS_XBS5_LPBIG_OFFBIG_LDFLAGS;
    public static ConfstrName _CS_XBS5_LPBIG_OFFBIG_LIBS;
    public static ConfstrName _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS;
    public static ConfstrName _CS_POSIX_V6_ILP32_OFF32_CFLAGS;
    public static ConfstrName _CS_POSIX_V6_ILP32_OFF32_LDFLAGS;
    public static ConfstrName _CS_POSIX_V6_ILP32_OFF32_LIBS;
    public static ConfstrName _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS;
    public static ConfstrName _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS;
    public static ConfstrName _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS;
    public static ConfstrName _CS_POSIX_V6_ILP32_OFFBIG_LIBS;
    public static ConfstrName _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS;
    public static ConfstrName _CS_POSIX_V6_LP64_OFF64_CFLAGS;
    public static ConfstrName _CS_POSIX_V6_LP64_OFF64_LDFLAGS;
    public static ConfstrName _CS_POSIX_V6_LP64_OFF64_LIBS;
    public static ConfstrName _CS_POSIX_V6_LP64_OFF64_LINTFLAGS;
    public static ConfstrName _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS;
    public static ConfstrName _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS;
    public static ConfstrName _CS_POSIX_V6_LPBIG_OFFBIG_LIBS;
    public static ConfstrName _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS;
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.dev_tAttribute : MapAttribute {
}
[MapAttribute]
[CLSCompliantAttribute("False")]
[FlagsAttribute]
internal enum Mono.Unix.Native.DirectoryNotifyFlags : Enum {
    public int value__;
    public static DirectoryNotifyFlags DN_ACCESS;
    public static DirectoryNotifyFlags DN_MODIFY;
    public static DirectoryNotifyFlags DN_CREATE;
    public static DirectoryNotifyFlags DN_DELETE;
    public static DirectoryNotifyFlags DN_RENAME;
    public static DirectoryNotifyFlags DN_ATTRIB;
    public static DirectoryNotifyFlags DN_MULTISHOT;
}
internal class Mono.Unix.Native.Dirent : object {
    [CLSCompliantAttribute("False")]
public ulong d_ino;
    public long d_off;
    [CLSCompliantAttribute("False")]
public ushort d_reclen;
    public byte d_type;
    public string d_name;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Dirent value);
    public virtual string ToString();
    public static bool op_Equality(Dirent lhs, Dirent rhs);
    public static bool op_Inequality(Dirent lhs, Dirent rhs);
}
[CLSCompliantAttribute("False")]
internal class Mono.Unix.Native.EpollEvent : ValueType {
    public EpollEvents events;
    public int fd;
    public IntPtr ptr;
    public UInt32 u32;
    public ulong u64;
}
[FlagsAttribute]
[CLSCompliantAttribute("False")]
[MapAttribute]
internal enum Mono.Unix.Native.EpollEvents : Enum {
    public UInt32 value__;
    public static EpollEvents EPOLLIN;
    public static EpollEvents EPOLLPRI;
    public static EpollEvents EPOLLOUT;
    public static EpollEvents EPOLLRDNORM;
    public static EpollEvents EPOLLRDBAND;
    public static EpollEvents EPOLLWRNORM;
    public static EpollEvents EPOLLWRBAND;
    public static EpollEvents EPOLLMSG;
    public static EpollEvents EPOLLERR;
    public static EpollEvents EPOLLHUP;
    public static EpollEvents EPOLLRDHUP;
    public static EpollEvents EPOLLONESHOT;
    public static EpollEvents EPOLLET;
}
[MapAttribute]
[FlagsAttribute]
internal enum Mono.Unix.Native.EpollFlags : Enum {
    public int value__;
    public static EpollFlags EPOLL_CLOEXEC;
    public static EpollFlags EPOLL_NONBLOCK;
}
internal enum Mono.Unix.Native.EpollOp : Enum {
    public int value__;
    public static EpollOp EPOLL_CTL_ADD;
    public static EpollOp EPOLL_CTL_DEL;
    public static EpollOp EPOLL_CTL_MOD;
}
[MapAttribute]
internal enum Mono.Unix.Native.Errno : Enum {
    public int value__;
    public static Errno EPERM;
    public static Errno ENOENT;
    public static Errno ESRCH;
    public static Errno EINTR;
    public static Errno EIO;
    public static Errno ENXIO;
    public static Errno E2BIG;
    public static Errno ENOEXEC;
    public static Errno EBADF;
    public static Errno ECHILD;
    public static Errno EAGAIN;
    public static Errno ENOMEM;
    public static Errno EACCES;
    public static Errno EFAULT;
    public static Errno ENOTBLK;
    public static Errno EBUSY;
    public static Errno EEXIST;
    public static Errno EXDEV;
    public static Errno ENODEV;
    public static Errno ENOTDIR;
    public static Errno EISDIR;
    public static Errno EINVAL;
    public static Errno ENFILE;
    public static Errno EMFILE;
    public static Errno ENOTTY;
    public static Errno ETXTBSY;
    public static Errno EFBIG;
    public static Errno ENOSPC;
    public static Errno ESPIPE;
    public static Errno EROFS;
    public static Errno EMLINK;
    public static Errno EPIPE;
    public static Errno EDOM;
    public static Errno ERANGE;
    public static Errno EDEADLK;
    public static Errno ENAMETOOLONG;
    public static Errno ENOLCK;
    public static Errno ENOSYS;
    public static Errno ENOTEMPTY;
    public static Errno ELOOP;
    public static Errno EWOULDBLOCK;
    public static Errno ENOMSG;
    public static Errno EIDRM;
    public static Errno ECHRNG;
    public static Errno EL2NSYNC;
    public static Errno EL3HLT;
    public static Errno EL3RST;
    public static Errno ELNRNG;
    public static Errno EUNATCH;
    public static Errno ENOCSI;
    public static Errno EL2HLT;
    public static Errno EBADE;
    public static Errno EBADR;
    public static Errno EXFULL;
    public static Errno ENOANO;
    public static Errno EBADRQC;
    public static Errno EBADSLT;
    public static Errno EDEADLOCK;
    public static Errno EBFONT;
    public static Errno ENOSTR;
    public static Errno ENODATA;
    public static Errno ETIME;
    public static Errno ENOSR;
    public static Errno ENONET;
    public static Errno ENOPKG;
    public static Errno EREMOTE;
    public static Errno ENOLINK;
    public static Errno EADV;
    public static Errno ESRMNT;
    public static Errno ECOMM;
    public static Errno EPROTO;
    public static Errno EMULTIHOP;
    public static Errno EDOTDOT;
    public static Errno EBADMSG;
    public static Errno EOVERFLOW;
    public static Errno ENOTUNIQ;
    public static Errno EBADFD;
    public static Errno EREMCHG;
    public static Errno ELIBACC;
    public static Errno ELIBBAD;
    public static Errno ELIBSCN;
    public static Errno ELIBMAX;
    public static Errno ELIBEXEC;
    public static Errno EILSEQ;
    public static Errno ERESTART;
    public static Errno ESTRPIPE;
    public static Errno EUSERS;
    public static Errno ENOTSOCK;
    public static Errno EDESTADDRREQ;
    public static Errno EMSGSIZE;
    public static Errno EPROTOTYPE;
    public static Errno ENOPROTOOPT;
    public static Errno EPROTONOSUPPORT;
    public static Errno ESOCKTNOSUPPORT;
    public static Errno EOPNOTSUPP;
    public static Errno EPFNOSUPPORT;
    public static Errno EAFNOSUPPORT;
    public static Errno EADDRINUSE;
    public static Errno EADDRNOTAVAIL;
    public static Errno ENETDOWN;
    public static Errno ENETUNREACH;
    public static Errno ENETRESET;
    public static Errno ECONNABORTED;
    public static Errno ECONNRESET;
    public static Errno ENOBUFS;
    public static Errno EISCONN;
    public static Errno ENOTCONN;
    public static Errno ESHUTDOWN;
    public static Errno ETOOMANYREFS;
    public static Errno ETIMEDOUT;
    public static Errno ECONNREFUSED;
    public static Errno EHOSTDOWN;
    public static Errno EHOSTUNREACH;
    public static Errno EALREADY;
    public static Errno EINPROGRESS;
    public static Errno ESTALE;
    public static Errno EUCLEAN;
    public static Errno ENOTNAM;
    public static Errno ENAVAIL;
    public static Errno EISNAM;
    public static Errno EREMOTEIO;
    public static Errno EDQUOT;
    public static Errno ENOMEDIUM;
    public static Errno EMEDIUMTYPE;
}
[MapAttribute]
[CLSCompliantAttribute("False")]
internal enum Mono.Unix.Native.FcntlCommand : Enum {
    public int value__;
    public static FcntlCommand F_DUPFD;
    public static FcntlCommand F_GETFD;
    public static FcntlCommand F_SETFD;
    public static FcntlCommand F_GETFL;
    public static FcntlCommand F_SETFL;
    public static FcntlCommand F_GETLK;
    public static FcntlCommand F_SETLK;
    public static FcntlCommand F_SETLKW;
    public static FcntlCommand F_SETOWN;
    public static FcntlCommand F_GETOWN;
    public static FcntlCommand F_SETSIG;
    public static FcntlCommand F_GETSIG;
    public static FcntlCommand F_SETLEASE;
    public static FcntlCommand F_GETLEASE;
    public static FcntlCommand F_NOTIFY;
}
internal class Mono.Unix.Native.FileNameMarshaler : object {
    private static FileNameMarshaler Instance;
    private static FileNameMarshaler();
    public static ICustomMarshaler GetInstance(string s);
    public sealed virtual void CleanUpManagedData(object o);
    public sealed virtual void CleanUpNativeData(IntPtr pNativeData);
    public sealed virtual int GetNativeDataSize();
    public sealed virtual IntPtr MarshalManagedToNative(object obj);
    public sealed virtual object MarshalNativeToManaged(IntPtr pNativeData);
}
[FlagsAttribute]
[CLSCompliantAttribute("False")]
[MapAttribute]
internal enum Mono.Unix.Native.FilePermissions : Enum {
    public UInt32 value__;
    public static FilePermissions S_ISUID;
    public static FilePermissions S_ISGID;
    public static FilePermissions S_ISVTX;
    public static FilePermissions S_IRUSR;
    public static FilePermissions S_IWUSR;
    public static FilePermissions S_IXUSR;
    public static FilePermissions S_IRGRP;
    public static FilePermissions S_IWGRP;
    public static FilePermissions S_IXGRP;
    public static FilePermissions S_IROTH;
    public static FilePermissions S_IWOTH;
    public static FilePermissions S_IXOTH;
    public static FilePermissions S_IRWXG;
    public static FilePermissions S_IRWXU;
    public static FilePermissions S_IRWXO;
    public static FilePermissions ACCESSPERMS;
    public static FilePermissions ALLPERMS;
    public static FilePermissions DEFFILEMODE;
    public static FilePermissions S_IFMT;
    [MapAttribute]
public static FilePermissions S_IFDIR;
    [MapAttribute]
public static FilePermissions S_IFCHR;
    [MapAttribute]
public static FilePermissions S_IFBLK;
    [MapAttribute]
public static FilePermissions S_IFREG;
    [MapAttribute]
public static FilePermissions S_IFIFO;
    [MapAttribute]
public static FilePermissions S_IFLNK;
    [MapAttribute]
public static FilePermissions S_IFSOCK;
}
internal class Mono.Unix.Native.FilePosition : MarshalByRefObject {
    private static int FilePositionDumpSize;
    private HandleRef pos;
    internal HandleRef Handle { get; }
    private static FilePosition();
    internal HandleRef get_Handle();
    public sealed virtual void Dispose();
    private void Cleanup();
    public virtual string ToString();
    private string GetDump();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(FilePosition value);
    public virtual int GetHashCode();
    protected virtual void Finalize();
    public static bool op_Equality(FilePosition lhs, FilePosition rhs);
    public static bool op_Inequality(FilePosition lhs, FilePosition rhs);
}
[MapAttribute("struct flock")]
internal class Mono.Unix.Native.Flock : ValueType {
    [CLSCompliantAttribute("False")]
public LockType l_type;
    [CLSCompliantAttribute("False")]
public SeekFlags l_whence;
    [off_tAttribute]
public long l_start;
    [off_tAttribute]
public long l_len;
    [pid_tAttribute]
public int l_pid;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Flock value);
    public static bool op_Equality(Flock lhs, Flock rhs);
    public static bool op_Inequality(Flock lhs, Flock rhs);
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.fsblkcnt_tAttribute : MapAttribute {
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.fsfilcnt_tAttribute : MapAttribute {
}
internal class Mono.Unix.Native.Fstab : object {
    public string fs_spec;
    public string fs_file;
    public string fs_vfstype;
    public string fs_mntops;
    public string fs_type;
    public int fs_freq;
    public int fs_passno;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Fstab value);
    public virtual string ToString();
    public static bool op_Equality(Fstab lhs, Fstab rhs);
    public static bool op_Inequality(Fstab lhs, Fstab rhs);
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.gid_tAttribute : MapAttribute {
}
internal class Mono.Unix.Native.Group : object {
    public string gr_name;
    public string gr_passwd;
    [CLSCompliantAttribute("False")]
public UInt32 gr_gid;
    public String[] gr_mem;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Group value);
    public virtual string ToString();
    private static void GetMembers(StringBuilder sb, String[] members);
    public static bool op_Equality(Group lhs, Group rhs);
    public static bool op_Inequality(Group lhs, Group rhs);
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.ino_tAttribute : MapAttribute {
}
[CLSCompliantAttribute("False")]
[MapAttribute]
internal enum Mono.Unix.Native.LockfCommand : Enum {
    public int value__;
    public static LockfCommand F_ULOCK;
    public static LockfCommand F_LOCK;
    public static LockfCommand F_TLOCK;
    public static LockfCommand F_TEST;
}
[MapAttribute]
[CLSCompliantAttribute("False")]
internal enum Mono.Unix.Native.LockType : Enum {
    public short value__;
    public static LockType F_RDLCK;
    public static LockType F_WRLCK;
    public static LockType F_UNLCK;
}
[MapAttribute]
[CLSCompliantAttribute("False")]
[FlagsAttribute]
internal enum Mono.Unix.Native.MlockallFlags : Enum {
    public int value__;
    public static MlockallFlags MCL_CURRENT;
    public static MlockallFlags MCL_FUTURE;
}
[FlagsAttribute]
[MapAttribute]
[CLSCompliantAttribute("False")]
internal enum Mono.Unix.Native.MmapFlags : Enum {
    public int value__;
    public static MmapFlags MAP_SHARED;
    public static MmapFlags MAP_PRIVATE;
    public static MmapFlags MAP_TYPE;
    public static MmapFlags MAP_FIXED;
    public static MmapFlags MAP_FILE;
    public static MmapFlags MAP_ANONYMOUS;
    public static MmapFlags MAP_ANON;
    public static MmapFlags MAP_GROWSDOWN;
    public static MmapFlags MAP_DENYWRITE;
    public static MmapFlags MAP_EXECUTABLE;
    public static MmapFlags MAP_LOCKED;
    public static MmapFlags MAP_NORESERVE;
    public static MmapFlags MAP_POPULATE;
    public static MmapFlags MAP_NONBLOCK;
}
[MapAttribute]
[FlagsAttribute]
[CLSCompliantAttribute("False")]
internal enum Mono.Unix.Native.MmapProts : Enum {
    public int value__;
    public static MmapProts PROT_READ;
    public static MmapProts PROT_WRITE;
    public static MmapProts PROT_EXEC;
    public static MmapProts PROT_NONE;
    public static MmapProts PROT_GROWSDOWN;
    public static MmapProts PROT_GROWSUP;
}
[CLSCompliantAttribute("False")]
[MapAttribute]
[FlagsAttribute]
internal enum Mono.Unix.Native.MountFlags : Enum {
    public ulong value__;
    public static MountFlags ST_RDONLY;
    public static MountFlags ST_NOSUID;
    public static MountFlags ST_NODEV;
    public static MountFlags ST_NOEXEC;
    public static MountFlags ST_SYNCHRONOUS;
    public static MountFlags ST_REMOUNT;
    public static MountFlags ST_MANDLOCK;
    public static MountFlags ST_WRITE;
    public static MountFlags ST_APPEND;
    public static MountFlags ST_IMMUTABLE;
    public static MountFlags ST_NOATIME;
    public static MountFlags ST_NODIRATIME;
    public static MountFlags ST_BIND;
}
[FlagsAttribute]
[MapAttribute]
[CLSCompliantAttribute("False")]
internal enum Mono.Unix.Native.MremapFlags : Enum {
    public ulong value__;
    public static MremapFlags MREMAP_MAYMOVE;
}
[CLSCompliantAttribute("False")]
[MapAttribute]
[FlagsAttribute]
internal enum Mono.Unix.Native.MsyncFlags : Enum {
    public int value__;
    public static MsyncFlags MS_ASYNC;
    public static MsyncFlags MS_SYNC;
    public static MsyncFlags MS_INVALIDATE;
}
[CLSCompliantAttribute("False")]
internal class Mono.Unix.Native.NativeConvert : object {
    private static string LIB;
    public static DateTime LocalUnixEpoch;
    public static TimeSpan LocalUtcOffset;
    private static String[][] fopen_modes;
    private static NativeConvert();
    private static int FromRealTimeSignum(int offset, Int32& rval);
    public static int FromRealTimeSignum(RealTimeSignum sig);
    public static RealTimeSignum ToRealTimeSignum(int offset);
    public static FilePermissions FromOctalPermissionString(string value);
    public static string ToOctalPermissionString(FilePermissions value);
    public static FilePermissions FromUnixPermissionString(string value);
    private static FilePermissions GetUnixPermissionDevice(char value);
    private static FilePermissions GetUnixPermissionGroup(char read, FilePermissions readb, char write, FilePermissions writeb, char exec, FilePermissions execb, char xboth, char xbitonly, FilePermissions xbit);
    public static string ToUnixPermissionString(FilePermissions value);
    private static void SetUnixPermissionGroup(FilePermissions value, Char[] access, int index, FilePermissions read, FilePermissions write, FilePermissions exec, char both, char setonly, FilePermissions setxbit);
    private static char GetSymbolicMode(FilePermissions value, FilePermissions xbit, char both, char setonly, FilePermissions setxbit);
    public static DateTime ToDateTime(long time);
    public static long FromDateTime(DateTime time);
    public static DateTime FromTimeT(long time);
    public static long ToTimeT(DateTime time);
    public static OpenFlags ToOpenFlags(FileMode mode, FileAccess access);
    public static string ToFopenMode(FileAccess access);
    public static string ToFopenMode(FileMode mode);
    public static string ToFopenMode(FileMode mode, FileAccess access);
    private static int FromStatvfs(Statvfs& source, IntPtr destination);
    public static bool TryCopy(Statvfs& source, IntPtr destination);
    private static int ToStatvfs(IntPtr source, Statvfs& destination);
    public static bool TryCopy(IntPtr source, Statvfs& destination);
    private static void ThrowArgumentException(object value);
    private static int FromAccessModes(AccessModes value, Int32& rval);
    public static bool TryFromAccessModes(AccessModes value, Int32& rval);
    public static int FromAccessModes(AccessModes value);
    private static int ToAccessModes(int value, AccessModes& rval);
    public static bool TryToAccessModes(int value, AccessModes& rval);
    public static AccessModes ToAccessModes(int value);
    private static int FromConfstrName(ConfstrName value, Int32& rval);
    public static bool TryFromConfstrName(ConfstrName value, Int32& rval);
    public static int FromConfstrName(ConfstrName value);
    private static int ToConfstrName(int value, ConfstrName& rval);
    public static bool TryToConfstrName(int value, ConfstrName& rval);
    public static ConfstrName ToConfstrName(int value);
    private static int FromDirectoryNotifyFlags(DirectoryNotifyFlags value, Int32& rval);
    public static bool TryFromDirectoryNotifyFlags(DirectoryNotifyFlags value, Int32& rval);
    public static int FromDirectoryNotifyFlags(DirectoryNotifyFlags value);
    private static int ToDirectoryNotifyFlags(int value, DirectoryNotifyFlags& rval);
    public static bool TryToDirectoryNotifyFlags(int value, DirectoryNotifyFlags& rval);
    public static DirectoryNotifyFlags ToDirectoryNotifyFlags(int value);
    private static int FromEpollEvents(EpollEvents value, UInt32& rval);
    public static bool TryFromEpollEvents(EpollEvents value, UInt32& rval);
    public static UInt32 FromEpollEvents(EpollEvents value);
    private static int ToEpollEvents(UInt32 value, EpollEvents& rval);
    public static bool TryToEpollEvents(UInt32 value, EpollEvents& rval);
    public static EpollEvents ToEpollEvents(UInt32 value);
    private static int FromEpollFlags(EpollFlags value, Int32& rval);
    public static bool TryFromEpollFlags(EpollFlags value, Int32& rval);
    public static int FromEpollFlags(EpollFlags value);
    private static int ToEpollFlags(int value, EpollFlags& rval);
    public static bool TryToEpollFlags(int value, EpollFlags& rval);
    public static EpollFlags ToEpollFlags(int value);
    private static int FromErrno(Errno value, Int32& rval);
    public static bool TryFromErrno(Errno value, Int32& rval);
    public static int FromErrno(Errno value);
    private static int ToErrno(int value, Errno& rval);
    public static bool TryToErrno(int value, Errno& rval);
    public static Errno ToErrno(int value);
    private static int FromFcntlCommand(FcntlCommand value, Int32& rval);
    public static bool TryFromFcntlCommand(FcntlCommand value, Int32& rval);
    public static int FromFcntlCommand(FcntlCommand value);
    private static int ToFcntlCommand(int value, FcntlCommand& rval);
    public static bool TryToFcntlCommand(int value, FcntlCommand& rval);
    public static FcntlCommand ToFcntlCommand(int value);
    private static int FromFilePermissions(FilePermissions value, UInt32& rval);
    public static bool TryFromFilePermissions(FilePermissions value, UInt32& rval);
    public static UInt32 FromFilePermissions(FilePermissions value);
    private static int ToFilePermissions(UInt32 value, FilePermissions& rval);
    public static bool TryToFilePermissions(UInt32 value, FilePermissions& rval);
    public static FilePermissions ToFilePermissions(UInt32 value);
    private static int FromFlock(Flock& source, IntPtr destination);
    public static bool TryCopy(Flock& source, IntPtr destination);
    private static int ToFlock(IntPtr source, Flock& destination);
    public static bool TryCopy(IntPtr source, Flock& destination);
    private static int FromLockType(LockType value, Int16& rval);
    public static bool TryFromLockType(LockType value, Int16& rval);
    public static short FromLockType(LockType value);
    private static int ToLockType(short value, LockType& rval);
    public static bool TryToLockType(short value, LockType& rval);
    public static LockType ToLockType(short value);
    private static int FromLockfCommand(LockfCommand value, Int32& rval);
    public static bool TryFromLockfCommand(LockfCommand value, Int32& rval);
    public static int FromLockfCommand(LockfCommand value);
    private static int ToLockfCommand(int value, LockfCommand& rval);
    public static bool TryToLockfCommand(int value, LockfCommand& rval);
    public static LockfCommand ToLockfCommand(int value);
    private static int FromMlockallFlags(MlockallFlags value, Int32& rval);
    public static bool TryFromMlockallFlags(MlockallFlags value, Int32& rval);
    public static int FromMlockallFlags(MlockallFlags value);
    private static int ToMlockallFlags(int value, MlockallFlags& rval);
    public static bool TryToMlockallFlags(int value, MlockallFlags& rval);
    public static MlockallFlags ToMlockallFlags(int value);
    private static int FromMmapFlags(MmapFlags value, Int32& rval);
    public static bool TryFromMmapFlags(MmapFlags value, Int32& rval);
    public static int FromMmapFlags(MmapFlags value);
    private static int ToMmapFlags(int value, MmapFlags& rval);
    public static bool TryToMmapFlags(int value, MmapFlags& rval);
    public static MmapFlags ToMmapFlags(int value);
    private static int FromMmapProts(MmapProts value, Int32& rval);
    public static bool TryFromMmapProts(MmapProts value, Int32& rval);
    public static int FromMmapProts(MmapProts value);
    private static int ToMmapProts(int value, MmapProts& rval);
    public static bool TryToMmapProts(int value, MmapProts& rval);
    public static MmapProts ToMmapProts(int value);
    private static int FromMountFlags(MountFlags value, UInt64& rval);
    public static bool TryFromMountFlags(MountFlags value, UInt64& rval);
    public static ulong FromMountFlags(MountFlags value);
    private static int ToMountFlags(ulong value, MountFlags& rval);
    public static bool TryToMountFlags(ulong value, MountFlags& rval);
    public static MountFlags ToMountFlags(ulong value);
    private static int FromMremapFlags(MremapFlags value, UInt64& rval);
    public static bool TryFromMremapFlags(MremapFlags value, UInt64& rval);
    public static ulong FromMremapFlags(MremapFlags value);
    private static int ToMremapFlags(ulong value, MremapFlags& rval);
    public static bool TryToMremapFlags(ulong value, MremapFlags& rval);
    public static MremapFlags ToMremapFlags(ulong value);
    private static int FromMsyncFlags(MsyncFlags value, Int32& rval);
    public static bool TryFromMsyncFlags(MsyncFlags value, Int32& rval);
    public static int FromMsyncFlags(MsyncFlags value);
    private static int ToMsyncFlags(int value, MsyncFlags& rval);
    public static bool TryToMsyncFlags(int value, MsyncFlags& rval);
    public static MsyncFlags ToMsyncFlags(int value);
    private static int FromOpenFlags(OpenFlags value, Int32& rval);
    public static bool TryFromOpenFlags(OpenFlags value, Int32& rval);
    public static int FromOpenFlags(OpenFlags value);
    private static int ToOpenFlags(int value, OpenFlags& rval);
    public static bool TryToOpenFlags(int value, OpenFlags& rval);
    public static OpenFlags ToOpenFlags(int value);
    private static int FromPathconfName(PathconfName value, Int32& rval);
    public static bool TryFromPathconfName(PathconfName value, Int32& rval);
    public static int FromPathconfName(PathconfName value);
    private static int ToPathconfName(int value, PathconfName& rval);
    public static bool TryToPathconfName(int value, PathconfName& rval);
    public static PathconfName ToPathconfName(int value);
    private static int FromPollEvents(PollEvents value, Int16& rval);
    public static bool TryFromPollEvents(PollEvents value, Int16& rval);
    public static short FromPollEvents(PollEvents value);
    private static int ToPollEvents(short value, PollEvents& rval);
    public static bool TryToPollEvents(short value, PollEvents& rval);
    public static PollEvents ToPollEvents(short value);
    private static int FromPollfd(Pollfd& source, IntPtr destination);
    public static bool TryCopy(Pollfd& source, IntPtr destination);
    private static int ToPollfd(IntPtr source, Pollfd& destination);
    public static bool TryCopy(IntPtr source, Pollfd& destination);
    private static int FromPosixFadviseAdvice(PosixFadviseAdvice value, Int32& rval);
    public static bool TryFromPosixFadviseAdvice(PosixFadviseAdvice value, Int32& rval);
    public static int FromPosixFadviseAdvice(PosixFadviseAdvice value);
    private static int ToPosixFadviseAdvice(int value, PosixFadviseAdvice& rval);
    public static bool TryToPosixFadviseAdvice(int value, PosixFadviseAdvice& rval);
    public static PosixFadviseAdvice ToPosixFadviseAdvice(int value);
    private static int FromPosixMadviseAdvice(PosixMadviseAdvice value, Int32& rval);
    public static bool TryFromPosixMadviseAdvice(PosixMadviseAdvice value, Int32& rval);
    public static int FromPosixMadviseAdvice(PosixMadviseAdvice value);
    private static int ToPosixMadviseAdvice(int value, PosixMadviseAdvice& rval);
    public static bool TryToPosixMadviseAdvice(int value, PosixMadviseAdvice& rval);
    public static PosixMadviseAdvice ToPosixMadviseAdvice(int value);
    private static int FromSeekFlags(SeekFlags value, Int16& rval);
    public static bool TryFromSeekFlags(SeekFlags value, Int16& rval);
    public static short FromSeekFlags(SeekFlags value);
    private static int ToSeekFlags(short value, SeekFlags& rval);
    public static bool TryToSeekFlags(short value, SeekFlags& rval);
    public static SeekFlags ToSeekFlags(short value);
    private static int FromSignum(Signum value, Int32& rval);
    public static bool TryFromSignum(Signum value, Int32& rval);
    public static int FromSignum(Signum value);
    private static int ToSignum(int value, Signum& rval);
    public static bool TryToSignum(int value, Signum& rval);
    public static Signum ToSignum(int value);
    private static int FromStat(Stat& source, IntPtr destination);
    public static bool TryCopy(Stat& source, IntPtr destination);
    private static int ToStat(IntPtr source, Stat& destination);
    public static bool TryCopy(IntPtr source, Stat& destination);
    private static int FromSysconfName(SysconfName value, Int32& rval);
    public static bool TryFromSysconfName(SysconfName value, Int32& rval);
    public static int FromSysconfName(SysconfName value);
    private static int ToSysconfName(int value, SysconfName& rval);
    public static bool TryToSysconfName(int value, SysconfName& rval);
    public static SysconfName ToSysconfName(int value);
    private static int FromSyslogFacility(SyslogFacility value, Int32& rval);
    public static bool TryFromSyslogFacility(SyslogFacility value, Int32& rval);
    public static int FromSyslogFacility(SyslogFacility value);
    private static int ToSyslogFacility(int value, SyslogFacility& rval);
    public static bool TryToSyslogFacility(int value, SyslogFacility& rval);
    public static SyslogFacility ToSyslogFacility(int value);
    private static int FromSyslogLevel(SyslogLevel value, Int32& rval);
    public static bool TryFromSyslogLevel(SyslogLevel value, Int32& rval);
    public static int FromSyslogLevel(SyslogLevel value);
    private static int ToSyslogLevel(int value, SyslogLevel& rval);
    public static bool TryToSyslogLevel(int value, SyslogLevel& rval);
    public static SyslogLevel ToSyslogLevel(int value);
    private static int FromSyslogOptions(SyslogOptions value, Int32& rval);
    public static bool TryFromSyslogOptions(SyslogOptions value, Int32& rval);
    public static int FromSyslogOptions(SyslogOptions value);
    private static int ToSyslogOptions(int value, SyslogOptions& rval);
    public static bool TryToSyslogOptions(int value, SyslogOptions& rval);
    public static SyslogOptions ToSyslogOptions(int value);
    private static int FromTimespec(Timespec& source, IntPtr destination);
    public static bool TryCopy(Timespec& source, IntPtr destination);
    private static int ToTimespec(IntPtr source, Timespec& destination);
    public static bool TryCopy(IntPtr source, Timespec& destination);
    private static int FromTimeval(Timeval& source, IntPtr destination);
    public static bool TryCopy(Timeval& source, IntPtr destination);
    private static int ToTimeval(IntPtr source, Timeval& destination);
    public static bool TryCopy(IntPtr source, Timeval& destination);
    private static int FromTimezone(Timezone& source, IntPtr destination);
    public static bool TryCopy(Timezone& source, IntPtr destination);
    private static int ToTimezone(IntPtr source, Timezone& destination);
    public static bool TryCopy(IntPtr source, Timezone& destination);
    private static int FromUtimbuf(Utimbuf& source, IntPtr destination);
    public static bool TryCopy(Utimbuf& source, IntPtr destination);
    private static int ToUtimbuf(IntPtr source, Utimbuf& destination);
    public static bool TryCopy(IntPtr source, Utimbuf& destination);
    private static int FromWaitOptions(WaitOptions value, Int32& rval);
    public static bool TryFromWaitOptions(WaitOptions value, Int32& rval);
    public static int FromWaitOptions(WaitOptions value);
    private static int ToWaitOptions(int value, WaitOptions& rval);
    public static bool TryToWaitOptions(int value, WaitOptions& rval);
    public static WaitOptions ToWaitOptions(int value);
    private static int FromXattrFlags(XattrFlags value, Int32& rval);
    public static bool TryFromXattrFlags(XattrFlags value, Int32& rval);
    public static int FromXattrFlags(XattrFlags value);
    private static int ToXattrFlags(int value, XattrFlags& rval);
    public static bool TryToXattrFlags(int value, XattrFlags& rval);
    public static XattrFlags ToXattrFlags(int value);
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.nlink_tAttribute : MapAttribute {
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.off_tAttribute : MapAttribute {
}
[MapAttribute]
[FlagsAttribute]
[CLSCompliantAttribute("False")]
internal enum Mono.Unix.Native.OpenFlags : Enum {
    public int value__;
    public static OpenFlags O_RDONLY;
    public static OpenFlags O_WRONLY;
    public static OpenFlags O_RDWR;
    public static OpenFlags O_CREAT;
    public static OpenFlags O_EXCL;
    public static OpenFlags O_NOCTTY;
    public static OpenFlags O_TRUNC;
    public static OpenFlags O_APPEND;
    public static OpenFlags O_NONBLOCK;
    public static OpenFlags O_SYNC;
    public static OpenFlags O_NOFOLLOW;
    public static OpenFlags O_DIRECTORY;
    public static OpenFlags O_DIRECT;
    public static OpenFlags O_ASYNC;
    public static OpenFlags O_LARGEFILE;
}
internal class Mono.Unix.Native.Passwd : object {
    public string pw_name;
    public string pw_passwd;
    [CLSCompliantAttribute("False")]
public UInt32 pw_uid;
    [CLSCompliantAttribute("False")]
public UInt32 pw_gid;
    public string pw_gecos;
    public string pw_dir;
    public string pw_shell;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Passwd value);
    public virtual string ToString();
    public static bool op_Equality(Passwd lhs, Passwd rhs);
    public static bool op_Inequality(Passwd lhs, Passwd rhs);
}
[MapAttribute]
[CLSCompliantAttribute("False")]
internal enum Mono.Unix.Native.PathconfName : Enum {
    public int value__;
    public static PathconfName _PC_LINK_MAX;
    public static PathconfName _PC_MAX_CANON;
    public static PathconfName _PC_MAX_INPUT;
    public static PathconfName _PC_NAME_MAX;
    public static PathconfName _PC_PATH_MAX;
    public static PathconfName _PC_PIPE_BUF;
    public static PathconfName _PC_CHOWN_RESTRICTED;
    public static PathconfName _PC_NO_TRUNC;
    public static PathconfName _PC_VDISABLE;
    public static PathconfName _PC_SYNC_IO;
    public static PathconfName _PC_ASYNC_IO;
    public static PathconfName _PC_PRIO_IO;
    public static PathconfName _PC_SOCK_MAXBUF;
    public static PathconfName _PC_FILESIZEBITS;
    public static PathconfName _PC_REC_INCR_XFER_SIZE;
    public static PathconfName _PC_REC_MAX_XFER_SIZE;
    public static PathconfName _PC_REC_MIN_XFER_SIZE;
    public static PathconfName _PC_REC_XFER_ALIGN;
    public static PathconfName _PC_ALLOC_SIZE_MIN;
    public static PathconfName _PC_SYMLINK_MAX;
    public static PathconfName _PC_2_SYMLINKS;
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.pid_tAttribute : MapAttribute {
}
[FlagsAttribute]
[MapAttribute]
internal enum Mono.Unix.Native.PollEvents : Enum {
    public short value__;
    public static PollEvents POLLIN;
    public static PollEvents POLLPRI;
    public static PollEvents POLLOUT;
    public static PollEvents POLLERR;
    public static PollEvents POLLHUP;
    public static PollEvents POLLNVAL;
    public static PollEvents POLLRDNORM;
    public static PollEvents POLLRDBAND;
    public static PollEvents POLLWRNORM;
    public static PollEvents POLLWRBAND;
}
[MapAttribute("struct pollfd")]
internal class Mono.Unix.Native.Pollfd : ValueType {
    public int fd;
    [CLSCompliantAttribute("False")]
public PollEvents events;
    [CLSCompliantAttribute("False")]
public PollEvents revents;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Pollfd value);
    public static bool op_Equality(Pollfd lhs, Pollfd rhs);
    public static bool op_Inequality(Pollfd lhs, Pollfd rhs);
}
[CLSCompliantAttribute("False")]
[MapAttribute]
internal enum Mono.Unix.Native.PosixFadviseAdvice : Enum {
    public int value__;
    public static PosixFadviseAdvice POSIX_FADV_NORMAL;
    public static PosixFadviseAdvice POSIX_FADV_RANDOM;
    public static PosixFadviseAdvice POSIX_FADV_SEQUENTIAL;
    public static PosixFadviseAdvice POSIX_FADV_WILLNEED;
    public static PosixFadviseAdvice POSIX_FADV_DONTNEED;
    public static PosixFadviseAdvice POSIX_FADV_NOREUSE;
}
[CLSCompliantAttribute("False")]
[MapAttribute]
internal enum Mono.Unix.Native.PosixMadviseAdvice : Enum {
    public int value__;
    public static PosixMadviseAdvice POSIX_MADV_NORMAL;
    public static PosixMadviseAdvice POSIX_MADV_RANDOM;
    public static PosixMadviseAdvice POSIX_MADV_SEQUENTIAL;
    public static PosixMadviseAdvice POSIX_MADV_WILLNEED;
    public static PosixMadviseAdvice POSIX_MADV_DONTNEED;
}
internal class Mono.Unix.Native.RealTimeSignum : ValueType {
    private int rt_offset;
    private static int MaxOffset;
    public static RealTimeSignum MinValue;
    public static RealTimeSignum MaxValue;
    public int Offset { get; }
    public RealTimeSignum(int offset);
    private static RealTimeSignum();
    public int get_Offset();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RealTimeSignum value);
    public static bool op_Equality(RealTimeSignum lhs, RealTimeSignum rhs);
    public static bool op_Inequality(RealTimeSignum lhs, RealTimeSignum rhs);
}
[CLSCompliantAttribute("False")]
[MapAttribute]
internal enum Mono.Unix.Native.SeekFlags : Enum {
    public short value__;
    public static SeekFlags SEEK_SET;
    public static SeekFlags SEEK_CUR;
    public static SeekFlags SEEK_END;
    public static SeekFlags L_SET;
    public static SeekFlags L_INCR;
    public static SeekFlags L_XTND;
}
internal enum Mono.Unix.Native.SignalAction : Enum {
    public int value__;
    public static SignalAction Default;
    public static SignalAction Ignore;
    public static SignalAction Error;
}
internal class Mono.Unix.Native.SignalHandler : MulticastDelegate {
    public SignalHandler(object object, IntPtr method);
    public virtual void Invoke(int signal);
    public virtual IAsyncResult BeginInvoke(int signal, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[MapAttribute]
internal enum Mono.Unix.Native.Signum : Enum {
    public int value__;
    public static Signum SIGHUP;
    public static Signum SIGINT;
    public static Signum SIGQUIT;
    public static Signum SIGILL;
    public static Signum SIGTRAP;
    public static Signum SIGABRT;
    public static Signum SIGIOT;
    public static Signum SIGBUS;
    public static Signum SIGFPE;
    public static Signum SIGKILL;
    public static Signum SIGUSR1;
    public static Signum SIGSEGV;
    public static Signum SIGUSR2;
    public static Signum SIGPIPE;
    public static Signum SIGALRM;
    public static Signum SIGTERM;
    public static Signum SIGSTKFLT;
    public static Signum SIGCLD;
    public static Signum SIGCHLD;
    public static Signum SIGCONT;
    public static Signum SIGSTOP;
    public static Signum SIGTSTP;
    public static Signum SIGTTIN;
    public static Signum SIGTTOU;
    public static Signum SIGURG;
    public static Signum SIGXCPU;
    public static Signum SIGXFSZ;
    public static Signum SIGVTALRM;
    public static Signum SIGPROF;
    public static Signum SIGWINCH;
    public static Signum SIGPOLL;
    public static Signum SIGIO;
    public static Signum SIGPWR;
    public static Signum SIGSYS;
    public static Signum SIGUNUSED;
}
[MapAttribute("struct stat")]
internal class Mono.Unix.Native.Stat : ValueType {
    [CLSCompliantAttribute("False")]
[dev_tAttribute]
public ulong st_dev;
    [CLSCompliantAttribute("False")]
[ino_tAttribute]
public ulong st_ino;
    [CLSCompliantAttribute("False")]
public FilePermissions st_mode;
    private UInt32 _padding_;
    [nlink_tAttribute]
[CLSCompliantAttribute("False")]
public ulong st_nlink;
    [CLSCompliantAttribute("False")]
[uid_tAttribute]
public UInt32 st_uid;
    [gid_tAttribute]
[CLSCompliantAttribute("False")]
public UInt32 st_gid;
    [CLSCompliantAttribute("False")]
[dev_tAttribute]
public ulong st_rdev;
    [off_tAttribute]
public long st_size;
    [blksize_tAttribute]
public long st_blksize;
    [blkcnt_tAttribute]
public long st_blocks;
    [time_tAttribute]
public long st_atime;
    [time_tAttribute]
public long st_mtime;
    [time_tAttribute]
public long st_ctime;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Stat value);
    public static bool op_Equality(Stat lhs, Stat rhs);
    public static bool op_Inequality(Stat lhs, Stat rhs);
}
[MapAttribute]
[CLSCompliantAttribute("False")]
internal class Mono.Unix.Native.Statvfs : ValueType {
    public ulong f_bsize;
    public ulong f_frsize;
    [fsblkcnt_tAttribute]
public ulong f_blocks;
    [fsblkcnt_tAttribute]
public ulong f_bfree;
    [fsblkcnt_tAttribute]
public ulong f_bavail;
    [fsfilcnt_tAttribute]
public ulong f_files;
    [fsfilcnt_tAttribute]
public ulong f_ffree;
    [fsfilcnt_tAttribute]
public ulong f_favail;
    public ulong f_fsid;
    public MountFlags f_flag;
    public ulong f_namemax;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Statvfs value);
    public static bool op_Equality(Statvfs lhs, Statvfs rhs);
    public static bool op_Inequality(Statvfs lhs, Statvfs rhs);
}
internal class Mono.Unix.Native.Stdlib : object {
    internal static string LIBC;
    internal static string MPH;
    private static IntPtr _SIG_DFL;
    private static IntPtr _SIG_ERR;
    private static IntPtr _SIG_IGN;
    [CLSCompliantAttribute("False")]
public static SignalHandler SIG_DFL;
    [CLSCompliantAttribute("False")]
public static SignalHandler SIG_ERR;
    [CLSCompliantAttribute("False")]
public static SignalHandler SIG_IGN;
    private static SignalHandler[] registered_signals;
    [CLSCompliantAttribute("False")]
public static int _IOFBF;
    [CLSCompliantAttribute("False")]
public static int _IOLBF;
    [CLSCompliantAttribute("False")]
public static int _IONBF;
    [CLSCompliantAttribute("False")]
public static int BUFSIZ;
    [CLSCompliantAttribute("False")]
public static int EOF;
    [CLSCompliantAttribute("False")]
public static int FOPEN_MAX;
    [CLSCompliantAttribute("False")]
public static int FILENAME_MAX;
    [CLSCompliantAttribute("False")]
public static int L_tmpnam;
    public static IntPtr stderr;
    public static IntPtr stdin;
    public static IntPtr stdout;
    [CLSCompliantAttribute("False")]
public static int TMP_MAX;
    private static object tmpnam_lock;
    [CLSCompliantAttribute("False")]
public static int EXIT_FAILURE;
    [CLSCompliantAttribute("False")]
public static int EXIT_SUCCESS;
    [CLSCompliantAttribute("False")]
public static int MB_CUR_MAX;
    [CLSCompliantAttribute("False")]
public static int RAND_MAX;
    private static object strerror_lock;
    private static Stdlib();
    public static Errno GetLastError();
    private static void SetLastError(int error);
    protected static void SetLastError(Errno error);
    internal static void InvokeSignalHandler(int signum, IntPtr handler);
    private static IntPtr GetDefaultSignal();
    private static IntPtr GetErrorSignal();
    private static IntPtr GetIgnoreSignal();
    private static void _ErrorHandler(int signum);
    private static void _DefaultHandler(int signum);
    private static void _IgnoreHandler(int signum);
    private static IntPtr sys_signal(int signum, SignalHandler handler);
    private static IntPtr sys_signal(int signum, IntPtr handler);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("This is not safe; use Mono.Unix.UnixSignal for signal delivery or SetSignalAction()")]
public static SignalHandler signal(Signum signum, SignalHandler handler);
    private static SignalHandler TranslateHandler(IntPtr handler);
    public static int SetSignalAction(Signum signal, SignalAction action);
    public static int SetSignalAction(RealTimeSignum rts, SignalAction action);
    private static int SetSignalAction(int signum, SignalAction action);
    private static int sys_raise(int sig);
    [CLSCompliantAttribute("False")]
public static int raise(Signum sig);
    public static int raise(RealTimeSignum rts);
    private static int GetFullyBuffered();
    private static int GetLineBuffered();
    private static int GetNonBuffered();
    private static int GetBufferSize();
    internal static IntPtr CreateFilePosition();
    internal static int DumpFilePosition(StringBuilder buf, HandleRef handle, int len);
    private static int GetEOF();
    private static int GetFilenameMax();
    private static int GetFopenMax();
    private static int GetTmpnamLength();
    private static IntPtr GetStandardInput();
    private static IntPtr GetStandardOutput();
    private static IntPtr GetStandardError();
    private static int GetTmpMax();
    public static int remove(string filename);
    public static int rename(string oldpath, string newpath);
    public static IntPtr tmpfile();
    private static IntPtr sys_tmpnam(StringBuilder s);
    [ObsoleteAttribute("Syscall.mkstemp() should be preferred.")]
public static string tmpnam(StringBuilder s);
    [ObsoleteAttribute("Syscall.mkstemp() should be preferred.")]
public static string tmpnam();
    public static int fclose(IntPtr stream);
    public static int fflush(IntPtr stream);
    public static IntPtr fopen(string path, string mode);
    public static IntPtr freopen(string path, string mode, IntPtr stream);
    public static int setbuf(IntPtr stream, IntPtr buf);
    [CLSCompliantAttribute("False")]
public static int setbuf(IntPtr stream, Byte* buf);
    [CLSCompliantAttribute("False")]
public static int setvbuf(IntPtr stream, IntPtr buf, int mode, ulong size);
    [CLSCompliantAttribute("False")]
public static int setvbuf(IntPtr stream, Byte* buf, int mode, ulong size);
    private static int sys_fprintf(IntPtr stream, string format, string message);
    public static int fprintf(IntPtr stream, string message);
    [ObsoleteAttribute("Not necessarily portable due to cdecl restrictions.
Use fprintf (IntPtr, string) instead.")]
public static int fprintf(IntPtr stream, string format, Object[] parameters);
    private static int sys_printf(string format, string message);
    public static int printf(string message);
    [ObsoleteAttribute("Not necessarily portable due to cdecl restrictions.
Use printf (string) instead.")]
public static int printf(string format, Object[] parameters);
    private static int sys_snprintf(StringBuilder s, ulong n, string format, string message);
    [CLSCompliantAttribute("False")]
public static int snprintf(StringBuilder s, ulong n, string message);
    public static int snprintf(StringBuilder s, string message);
    [ObsoleteAttribute("Not necessarily portable due to cdecl restrictions.
Use snprintf (StringBuilder, string) instead.")]
[CLSCompliantAttribute("False")]
public static int snprintf(StringBuilder s, ulong n, string format, Object[] parameters);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("Not necessarily portable due to cdecl restrictions.
Use snprintf (StringBuilder, string) instead.")]
public static int snprintf(StringBuilder s, string format, Object[] parameters);
    public static int fgetc(IntPtr stream);
    private static IntPtr sys_fgets(StringBuilder sb, int size, IntPtr stream);
    public static StringBuilder fgets(StringBuilder sb, int size, IntPtr stream);
    public static StringBuilder fgets(StringBuilder sb, IntPtr stream);
    public static int fputc(int c, IntPtr stream);
    public static int fputs(string s, IntPtr stream);
    public static int getc(IntPtr stream);
    public static int getchar();
    public static int putc(int c, IntPtr stream);
    public static int putchar(int c);
    public static int puts(string s);
    public static int ungetc(int c, IntPtr stream);
    [CLSCompliantAttribute("False")]
public static ulong fread(IntPtr ptr, ulong size, ulong nmemb, IntPtr stream);
    [CLSCompliantAttribute("False")]
public static ulong fread(Void* ptr, ulong size, ulong nmemb, IntPtr stream);
    private static ulong sys_fread(Byte[] ptr, ulong size, ulong nmemb, IntPtr stream);
    [CLSCompliantAttribute("False")]
public static ulong fread(Byte[] ptr, ulong size, ulong nmemb, IntPtr stream);
    [CLSCompliantAttribute("False")]
public static ulong fread(Byte[] ptr, IntPtr stream);
    [CLSCompliantAttribute("False")]
public static ulong fwrite(IntPtr ptr, ulong size, ulong nmemb, IntPtr stream);
    [CLSCompliantAttribute("False")]
public static ulong fwrite(Void* ptr, ulong size, ulong nmemb, IntPtr stream);
    private static ulong sys_fwrite(Byte[] ptr, ulong size, ulong nmemb, IntPtr stream);
    [CLSCompliantAttribute("False")]
public static ulong fwrite(Byte[] ptr, ulong size, ulong nmemb, IntPtr stream);
    [CLSCompliantAttribute("False")]
public static ulong fwrite(Byte[] ptr, IntPtr stream);
    private static int sys_fgetpos(IntPtr stream, HandleRef pos);
    public static int fgetpos(IntPtr stream, FilePosition pos);
    private static int sys_fseek(IntPtr stream, long offset, int origin);
    [CLSCompliantAttribute("False")]
public static int fseek(IntPtr stream, long offset, SeekFlags origin);
    private static int sys_fsetpos(IntPtr stream, HandleRef pos);
    public static int fsetpos(IntPtr stream, FilePosition pos);
    public static long ftell(IntPtr stream);
    public static int rewind(IntPtr stream);
    public static int clearerr(IntPtr stream);
    public static int feof(IntPtr stream);
    public static int ferror(IntPtr stream);
    private static int perror(string s, int err);
    public static int perror(string s);
    private static int GetExitFailure();
    private static int GetExitSuccess();
    private static int GetMbCurMax();
    private static int GetRandMax();
    public static int rand();
    [CLSCompliantAttribute("False")]
public static void srand(UInt32 seed);
    [CLSCompliantAttribute("False")]
public static IntPtr calloc(ulong nmemb, ulong size);
    public static void free(IntPtr ptr);
    [CLSCompliantAttribute("False")]
public static IntPtr malloc(ulong size);
    [CLSCompliantAttribute("False")]
public static IntPtr realloc(IntPtr ptr, ulong size);
    public static void abort();
    public static void exit(int status);
    [CLSCompliantAttribute("False")]
public static void _Exit(int status);
    private static IntPtr sys_getenv(string name);
    public static string getenv(string name);
    [CLSCompliantAttribute("False")]
public static int system(string string);
    private static IntPtr sys_strerror(int errnum);
    [CLSCompliantAttribute("False")]
public static string strerror(Errno errnum);
    [CLSCompliantAttribute("False")]
public static ulong strlen(IntPtr s);
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.suseconds_tAttribute : MapAttribute {
}
[CLSCompliantAttribute("False")]
internal class Mono.Unix.Native.Syscall : Stdlib {
    internal static string LIBC;
    internal static object readdir_lock;
    internal static object fstab_lock;
    internal static object grp_lock;
    internal static object pwd_lock;
    private static object signal_lock;
    public static int L_ctermid;
    public static int L_cuserid;
    internal static object getlogin_lock;
    public static IntPtr MAP_FAILED;
    private static object tty_lock;
    internal static object usershell_lock;
    private static Syscall();
    public static int setxattr(string path, string name, Byte[] value, ulong size, XattrFlags flags);
    public static int setxattr(string path, string name, Byte[] value, ulong size);
    public static int setxattr(string path, string name, Byte[] value, XattrFlags flags);
    public static int setxattr(string path, string name, Byte[] value);
    public static int lsetxattr(string path, string name, Byte[] value, ulong size, XattrFlags flags);
    public static int lsetxattr(string path, string name, Byte[] value, ulong size);
    public static int lsetxattr(string path, string name, Byte[] value, XattrFlags flags);
    public static int lsetxattr(string path, string name, Byte[] value);
    public static int fsetxattr(int fd, string name, Byte[] value, ulong size, XattrFlags flags);
    public static int fsetxattr(int fd, string name, Byte[] value, ulong size);
    public static int fsetxattr(int fd, string name, Byte[] value, XattrFlags flags);
    public static int fsetxattr(int fd, string name, Byte[] value);
    public static long getxattr(string path, string name, Byte[] value, ulong size);
    public static long getxattr(string path, string name, Byte[] value);
    public static long getxattr(string path, string name, Byte[]& value);
    public static long lgetxattr(string path, string name, Byte[] value, ulong size);
    public static long lgetxattr(string path, string name, Byte[] value);
    public static long lgetxattr(string path, string name, Byte[]& value);
    public static long fgetxattr(int fd, string name, Byte[] value, ulong size);
    public static long fgetxattr(int fd, string name, Byte[] value);
    public static long fgetxattr(int fd, string name, Byte[]& value);
    public static long listxattr(string path, Byte[] list, ulong size);
    public static long listxattr(string path, Encoding encoding, String[]& values);
    public static long listxattr(string path, String[]& values);
    private static void GetValues(Byte[] list, Encoding encoding, String[]& values);
    public static long llistxattr(string path, Byte[] list, ulong size);
    public static long llistxattr(string path, Encoding encoding, String[]& values);
    public static long llistxattr(string path, String[]& values);
    public static long flistxattr(int fd, Byte[] list, ulong size);
    public static long flistxattr(int fd, Encoding encoding, String[]& values);
    public static long flistxattr(int fd, String[]& values);
    public static int removexattr(string path, string name);
    public static int lremovexattr(string path, string name);
    public static int fremovexattr(int fd, string name);
    public static IntPtr opendir(string name);
    public static int closedir(IntPtr dir);
    public static int seekdir(IntPtr dir, long offset);
    public static long telldir(IntPtr dir);
    public static int rewinddir(IntPtr dir);
    private static void CopyDirent(Dirent to, _Dirent& from);
    private static int sys_readdir(IntPtr dir, _Dirent& dentry);
    public static Dirent readdir(IntPtr dir);
    private static int sys_readdir_r(IntPtr dirp, _Dirent& entry, IntPtr& result);
    public static int readdir_r(IntPtr dirp, Dirent entry, IntPtr& result);
    public static int dirfd(IntPtr dir);
    public static int fcntl(int fd, FcntlCommand cmd);
    public static int fcntl(int fd, FcntlCommand cmd, long arg);
    public static int fcntl(int fd, FcntlCommand cmd, DirectoryNotifyFlags arg);
    public static int fcntl(int fd, FcntlCommand cmd, Flock& lock);
    public static int open(string pathname, OpenFlags flags);
    public static int open(string pathname, OpenFlags flags, FilePermissions mode);
    public static int creat(string pathname, FilePermissions mode);
    public static int posix_fadvise(int fd, long offset, long len, PosixFadviseAdvice advice);
    public static int posix_fallocate(int fd, long offset, ulong len);
    private static void CopyFstab(Fstab to, _Fstab& from);
    private static int sys_endfsent();
    public static int endfsent();
    private static int sys_getfsent(_Fstab& fs);
    public static Fstab getfsent();
    private static int sys_getfsfile(string mount_point, _Fstab& fs);
    public static Fstab getfsfile(string mount_point);
    private static int sys_getfsspec(string special_file, _Fstab& fs);
    public static Fstab getfsspec(string special_file);
    private static int sys_setfsent();
    public static int setfsent();
    public static int setgroups(ulong size, UInt32[] list);
    public static int setgroups(UInt32[] list);
    private static void CopyGroup(Group to, _Group& from);
    private static int sys_getgrnam(string name, _Group& group);
    public static Group getgrnam(string name);
    private static int sys_getgrgid(UInt32 uid, _Group& group);
    public static Group getgrgid(UInt32 uid);
    private static int sys_getgrnam_r(string name, _Group& grbuf, IntPtr& grbufp);
    public static int getgrnam_r(string name, Group grbuf, Group& grbufp);
    private static int sys_getgrgid_r(UInt32 uid, _Group& grbuf, IntPtr& grbufp);
    public static int getgrgid_r(UInt32 uid, Group grbuf, Group& grbufp);
    private static int sys_getgrent(_Group& grbuf);
    public static Group getgrent();
    private static int sys_setgrent();
    public static int setgrent();
    private static int sys_endgrent();
    public static int endgrent();
    private static int sys_fgetgrent(IntPtr stream, _Group& grbuf);
    public static Group fgetgrent(IntPtr stream);
    private static void CopyPasswd(Passwd to, _Passwd& from);
    private static int sys_getpwnam(string name, _Passwd& passwd);
    public static Passwd getpwnam(string name);
    private static int sys_getpwuid(UInt32 uid, _Passwd& passwd);
    public static Passwd getpwuid(UInt32 uid);
    private static int sys_getpwnam_r(string name, _Passwd& pwbuf, IntPtr& pwbufp);
    public static int getpwnam_r(string name, Passwd pwbuf, Passwd& pwbufp);
    private static int sys_getpwuid_r(UInt32 uid, _Passwd& pwbuf, IntPtr& pwbufp);
    public static int getpwuid_r(UInt32 uid, Passwd pwbuf, Passwd& pwbufp);
    private static int sys_getpwent(_Passwd& pwbuf);
    public static Passwd getpwent();
    private static int sys_setpwent();
    public static int setpwent();
    private static int sys_endpwent();
    public static int endpwent();
    private static int sys_fgetpwent(IntPtr stream, _Passwd& pwbuf);
    public static Passwd fgetpwent(IntPtr stream);
    private static int psignal(int sig, string s);
    public static int psignal(Signum sig, string s);
    private static int sys_kill(int pid, int sig);
    public static int kill(int pid, Signum sig);
    private static IntPtr sys_strsignal(int sig);
    public static string strsignal(Signum sig);
    private static int _L_ctermid();
    private static int _L_cuserid();
    private static IntPtr sys_cuserid(StringBuilder string);
    [ObsoleteAttribute(""Nobody knows precisely what cuserid() does... DO NOT USE cuserid().
`string' must hold L_cuserid characters.  Use getlogin_r instead.")]
public static string cuserid(StringBuilder string);
    public static int mkstemp(StringBuilder template);
    public static int ttyslot();
    [ObsoleteAttribute("This is insecure and should not be used", "True")]
public static int setkey(string key);
    private static int sys_strerror_r(int errnum, StringBuilder buf, ulong n);
    public static int strerror_r(Errno errnum, StringBuilder buf, ulong n);
    public static int strerror_r(Errno errnum, StringBuilder buf);
    public static int epoll_create(int size);
    public static int epoll_create(EpollFlags flags);
    public static int epoll_ctl(int epfd, EpollOp op, int fd, EpollEvents events);
    public static int epoll_wait(int epfd, EpollEvent[] events, int max_events, int timeout);
    private static int sys_epoll_create(int size);
    private static int sys_epoll_create1(EpollFlags flags);
    private static int sys_epoll_ctl(int epfd, EpollOp op, int fd, EpollEvent& ee);
    private static int sys_epoll_wait(int epfd, EpollEvent[] ee, int maxevents, int timeout);
    public static int posix_madvise(IntPtr addr, ulong len, PosixMadviseAdvice advice);
    public static IntPtr mmap(IntPtr start, ulong length, MmapProts prot, MmapFlags flags, int fd, long offset);
    public static int munmap(IntPtr start, ulong length);
    public static int mprotect(IntPtr start, ulong len, MmapProts prot);
    public static int msync(IntPtr start, ulong len, MsyncFlags flags);
    public static int mlock(IntPtr start, ulong len);
    public static int munlock(IntPtr start, ulong len);
    private static int sys_mlockall(int flags);
    public static int mlockall(MlockallFlags flags);
    public static int munlockall();
    public static IntPtr mremap(IntPtr old_address, ulong old_size, ulong new_size, MremapFlags flags);
    public static int mincore(IntPtr start, ulong length, Byte[] vec);
    public static int remap_file_pages(IntPtr start, ulong size, MmapProts prot, long pgoff, MmapFlags flags);
    private static int sys_poll(_pollfd[] ufds, UInt32 nfds, int timeout);
    public static int poll(Pollfd[] fds, UInt32 nfds, int timeout);
    public static int poll(Pollfd[] fds, int timeout);
    public static long sendfile(int out_fd, int in_fd, Int64& offset, ulong count);
    public static int stat(string file_name, Stat& buf);
    public static int fstat(int filedes, Stat& buf);
    public static int lstat(string file_name, Stat& buf);
    private static int sys_chmod(string path, UInt32 mode);
    public static int chmod(string path, FilePermissions mode);
    private static int sys_fchmod(int filedes, UInt32 mode);
    public static int fchmod(int filedes, FilePermissions mode);
    private static UInt32 sys_umask(UInt32 mask);
    public static FilePermissions umask(FilePermissions mask);
    private static int sys_mkdir(string oldpath, UInt32 mode);
    public static int mkdir(string oldpath, FilePermissions mode);
    public static int mknod(string pathname, FilePermissions mode, ulong dev);
    private static int sys_mkfifo(string pathname, UInt32 mode);
    public static int mkfifo(string pathname, FilePermissions mode);
    public static int statvfs(string path, Statvfs& buf);
    public static int fstatvfs(int fd, Statvfs& buf);
    public static int gettimeofday(Timeval& tv, Timezone& tz);
    private static int gettimeofday(Timeval& tv, IntPtr ignore);
    public static int gettimeofday(Timeval& tv);
    private static int gettimeofday(IntPtr ignore, Timezone& tz);
    public static int gettimeofday(Timezone& tz);
    public static int settimeofday(Timeval& tv, Timezone& tz);
    private static int settimeofday(Timeval& tv, IntPtr ignore);
    public static int settimeofday(Timeval& tv);
    private static int sys_utimes(string filename, Timeval[] tvp);
    public static int utimes(string filename, Timeval[] tvp);
    private static int sys_lutimes(string filename, Timeval[] tvp);
    public static int lutimes(string filename, Timeval[] tvp);
    private static int sys_futimes(int fd, Timeval[] tvp);
    public static int futimes(int fd, Timeval[] tvp);
    private static void CopyUtsname(Utsname& to, _Utsname& from);
    private static int sys_uname(_Utsname& buf);
    public static int uname(Utsname& buf);
    public static int wait(Int32& status);
    private static int waitpid(int pid, Int32& status, int options);
    public static int waitpid(int pid, Int32& status, WaitOptions options);
    private static int _WIFEXITED(int status);
    public static bool WIFEXITED(int status);
    public static int WEXITSTATUS(int status);
    private static int _WIFSIGNALED(int status);
    public static bool WIFSIGNALED(int status);
    private static int _WTERMSIG(int status);
    public static Signum WTERMSIG(int status);
    private static int _WIFSTOPPED(int status);
    public static bool WIFSTOPPED(int status);
    private static int _WSTOPSIG(int status);
    public static Signum WSTOPSIG(int status);
    private static int sys_openlog(IntPtr ident, int option, int facility);
    public static int openlog(IntPtr ident, SyslogOptions option, SyslogFacility defaultFacility);
    private static int sys_syslog(int priority, string message);
    public static int syslog(SyslogFacility facility, SyslogLevel level, string message);
    public static int syslog(SyslogLevel level, string message);
    private static string GetSyslogMessage(string message);
    [ObsoleteAttribute("Not necessarily portable due to cdecl restrictions.
Use syslog(SyslogFacility, SyslogLevel, string) instead.")]
public static int syslog(SyslogFacility facility, SyslogLevel level, string format, Object[] parameters);
    [ObsoleteAttribute("Not necessarily portable due to cdecl restrictions.
Use syslog(SyslogLevel, string) instead.")]
public static int syslog(SyslogLevel level, string format, Object[] parameters);
    public static int closelog();
    private static int sys_setlogmask(int mask);
    public static int setlogmask(SyslogLevel mask);
    public static int nanosleep(Timespec& req, Timespec& rem);
    public static int stime(Int64& t);
    public static long time(Int64& t);
    private static int sys_access(string pathname, int mode);
    public static int access(string pathname, AccessModes mode);
    private static long sys_lseek(int fd, long offset, int whence);
    public static long lseek(int fd, long offset, SeekFlags whence);
    public static int close(int fd);
    public static long read(int fd, IntPtr buf, ulong count);
    public static long read(int fd, Void* buf, ulong count);
    public static long write(int fd, IntPtr buf, ulong count);
    public static long write(int fd, Void* buf, ulong count);
    public static long pread(int fd, IntPtr buf, ulong count, long offset);
    public static long pread(int fd, Void* buf, ulong count, long offset);
    public static long pwrite(int fd, IntPtr buf, ulong count, long offset);
    public static long pwrite(int fd, Void* buf, ulong count, long offset);
    public static int pipe(Int32& reading, Int32& writing);
    public static int pipe(Int32[] filedes);
    public static UInt32 alarm(UInt32 seconds);
    public static UInt32 sleep(UInt32 seconds);
    public static UInt32 ualarm(UInt32 usecs, UInt32 interval);
    public static int pause();
    public static int chown(string path, UInt32 owner, UInt32 group);
    public static int fchown(int fd, UInt32 owner, UInt32 group);
    public static int lchown(string path, UInt32 owner, UInt32 group);
    public static int chdir(string path);
    public static int fchdir(int fd);
    public static IntPtr getcwd(StringBuilder buf, ulong size);
    public static StringBuilder getcwd(StringBuilder buf);
    public static int dup(int fd);
    public static int dup2(int fd, int fd2);
    public static int execve(string path, String[] argv, String[] envp);
    public static int fexecve(int fd, String[] argv, String[] envp);
    public static int execv(string path, String[] argv);
    public static int execvp(string path, String[] argv);
    public static int nice(int inc);
    [CLSCompliantAttribute("False")]
public static int _exit(int status);
    public static long fpathconf(int filedes, PathconfName name, Errno defaultError);
    public static long fpathconf(int filedes, PathconfName name);
    public static long pathconf(string path, PathconfName name, Errno defaultError);
    public static long pathconf(string path, PathconfName name);
    public static long sysconf(SysconfName name, Errno defaultError);
    public static long sysconf(SysconfName name);
    public static ulong confstr(ConfstrName name, StringBuilder buf, ulong len);
    public static int getpid();
    public static int getppid();
    public static int setpgid(int pid, int pgid);
    public static int getpgid(int pid);
    public static int setpgrp();
    public static int getpgrp();
    public static int setsid();
    public static int getsid(int pid);
    public static UInt32 getuid();
    public static UInt32 geteuid();
    public static UInt32 getgid();
    public static UInt32 getegid();
    public static int getgroups(int size, UInt32[] list);
    public static int getgroups(UInt32[] list);
    public static int setuid(UInt32 uid);
    public static int setreuid(UInt32 ruid, UInt32 euid);
    public static int setregid(UInt32 rgid, UInt32 egid);
    public static int seteuid(UInt32 euid);
    public static int setegid(UInt32 uid);
    public static int setgid(UInt32 gid);
    public static int getresuid(UInt32& ruid, UInt32& euid, UInt32& suid);
    public static int getresgid(UInt32& rgid, UInt32& egid, UInt32& sgid);
    public static int setresuid(UInt32 ruid, UInt32 euid, UInt32 suid);
    public static int setresgid(UInt32 rgid, UInt32 egid, UInt32 sgid);
    private static IntPtr sys_ttyname(int fd);
    public static string ttyname(int fd);
    public static int ttyname_r(int fd, StringBuilder buf, ulong buflen);
    public static int ttyname_r(int fd, StringBuilder buf);
    private static int sys_isatty(int fd);
    public static bool isatty(int fd);
    public static int link(string oldpath, string newpath);
    public static int symlink(string oldpath, string newpath);
    public static int readlink(string path, StringBuilder buf, ulong bufsiz);
    public static int readlink(string path, StringBuilder buf);
    public static int unlink(string pathname);
    public static int rmdir(string pathname);
    public static int tcgetpgrp(int fd);
    public static int tcsetpgrp(int fd, int pgrp);
    private static IntPtr sys_getlogin();
    public static string getlogin();
    public static int getlogin_r(StringBuilder name, ulong bufsize);
    public static int getlogin_r(StringBuilder name);
    public static int setlogin(string name);
    public static int gethostname(StringBuilder name, ulong len);
    public static int gethostname(StringBuilder name);
    public static int sethostname(string name, ulong len);
    public static int sethostname(string name);
    public static long gethostid();
    public static int sethostid(long hostid);
    public static int getdomainname(StringBuilder name, ulong len);
    public static int getdomainname(StringBuilder name);
    public static int setdomainname(string name, ulong len);
    public static int setdomainname(string name);
    public static int vhangup();
    public static int revoke(string file);
    public static int acct(string filename);
    private static IntPtr sys_getusershell();
    public static string getusershell();
    private static int sys_setusershell();
    public static int setusershell();
    private static int sys_endusershell();
    public static int endusershell();
    public static int chroot(string path);
    public static int fsync(int fd);
    public static int fdatasync(int fd);
    public static int sync();
    [ObsoleteAttribute("Dropped in POSIX 1003.1-2001.  Use Syscall.sysconf (SysconfName._SC_PAGESIZE).")]
public static int getpagesize();
    public static int truncate(string path, long length);
    public static int ftruncate(int fd, long length);
    public static int getdtablesize();
    public static int brk(IntPtr end_data_segment);
    public static IntPtr sbrk(IntPtr increment);
    public static int lockf(int fd, LockfCommand cmd, long len);
    [ObsoleteAttribute("This is insecure and should not be used", "True")]
public static string crypt(string key, string salt);
    [ObsoleteAttribute("This is insecure and should not be used", "True")]
public static int encrypt(Byte[] block, bool decode);
    public static int swab(IntPtr from, IntPtr to, long n);
    public static void swab(Void* from, Void* to, long n);
    private static int sys_utime(string filename, Utimbuf& buf, int use_buf);
    public static int utime(string filename, Utimbuf& buf);
    public static int utime(string filename);
}
[MapAttribute]
[CLSCompliantAttribute("False")]
internal enum Mono.Unix.Native.SysconfName : Enum {
    public int value__;
    public static SysconfName _SC_ARG_MAX;
    public static SysconfName _SC_CHILD_MAX;
    public static SysconfName _SC_CLK_TCK;
    public static SysconfName _SC_NGROUPS_MAX;
    public static SysconfName _SC_OPEN_MAX;
    public static SysconfName _SC_STREAM_MAX;
    public static SysconfName _SC_TZNAME_MAX;
    public static SysconfName _SC_JOB_CONTROL;
    public static SysconfName _SC_SAVED_IDS;
    public static SysconfName _SC_REALTIME_SIGNALS;
    public static SysconfName _SC_PRIORITY_SCHEDULING;
    public static SysconfName _SC_TIMERS;
    public static SysconfName _SC_ASYNCHRONOUS_IO;
    public static SysconfName _SC_PRIORITIZED_IO;
    public static SysconfName _SC_SYNCHRONIZED_IO;
    public static SysconfName _SC_FSYNC;
    public static SysconfName _SC_MAPPED_FILES;
    public static SysconfName _SC_MEMLOCK;
    public static SysconfName _SC_MEMLOCK_RANGE;
    public static SysconfName _SC_MEMORY_PROTECTION;
    public static SysconfName _SC_MESSAGE_PASSING;
    public static SysconfName _SC_SEMAPHORES;
    public static SysconfName _SC_SHARED_MEMORY_OBJECTS;
    public static SysconfName _SC_AIO_LISTIO_MAX;
    public static SysconfName _SC_AIO_MAX;
    public static SysconfName _SC_AIO_PRIO_DELTA_MAX;
    public static SysconfName _SC_DELAYTIMER_MAX;
    public static SysconfName _SC_MQ_OPEN_MAX;
    public static SysconfName _SC_MQ_PRIO_MAX;
    public static SysconfName _SC_VERSION;
    public static SysconfName _SC_PAGESIZE;
    public static SysconfName _SC_RTSIG_MAX;
    public static SysconfName _SC_SEM_NSEMS_MAX;
    public static SysconfName _SC_SEM_VALUE_MAX;
    public static SysconfName _SC_SIGQUEUE_MAX;
    public static SysconfName _SC_TIMER_MAX;
    public static SysconfName _SC_BC_BASE_MAX;
    public static SysconfName _SC_BC_DIM_MAX;
    public static SysconfName _SC_BC_SCALE_MAX;
    public static SysconfName _SC_BC_STRING_MAX;
    public static SysconfName _SC_COLL_WEIGHTS_MAX;
    public static SysconfName _SC_EQUIV_CLASS_MAX;
    public static SysconfName _SC_EXPR_NEST_MAX;
    public static SysconfName _SC_LINE_MAX;
    public static SysconfName _SC_RE_DUP_MAX;
    public static SysconfName _SC_CHARCLASS_NAME_MAX;
    public static SysconfName _SC_2_VERSION;
    public static SysconfName _SC_2_C_BIND;
    public static SysconfName _SC_2_C_DEV;
    public static SysconfName _SC_2_FORT_DEV;
    public static SysconfName _SC_2_FORT_RUN;
    public static SysconfName _SC_2_SW_DEV;
    public static SysconfName _SC_2_LOCALEDEF;
    public static SysconfName _SC_PII;
    public static SysconfName _SC_PII_XTI;
    public static SysconfName _SC_PII_SOCKET;
    public static SysconfName _SC_PII_INTERNET;
    public static SysconfName _SC_PII_OSI;
    public static SysconfName _SC_POLL;
    public static SysconfName _SC_SELECT;
    public static SysconfName _SC_UIO_MAXIOV;
    public static SysconfName _SC_IOV_MAX;
    public static SysconfName _SC_PII_INTERNET_STREAM;
    public static SysconfName _SC_PII_INTERNET_DGRAM;
    public static SysconfName _SC_PII_OSI_COTS;
    public static SysconfName _SC_PII_OSI_CLTS;
    public static SysconfName _SC_PII_OSI_M;
    public static SysconfName _SC_T_IOV_MAX;
    public static SysconfName _SC_THREADS;
    public static SysconfName _SC_THREAD_SAFE_FUNCTIONS;
    public static SysconfName _SC_GETGR_R_SIZE_MAX;
    public static SysconfName _SC_GETPW_R_SIZE_MAX;
    public static SysconfName _SC_LOGIN_NAME_MAX;
    public static SysconfName _SC_TTY_NAME_MAX;
    public static SysconfName _SC_THREAD_DESTRUCTOR_ITERATIONS;
    public static SysconfName _SC_THREAD_KEYS_MAX;
    public static SysconfName _SC_THREAD_STACK_MIN;
    public static SysconfName _SC_THREAD_THREADS_MAX;
    public static SysconfName _SC_THREAD_ATTR_STACKADDR;
    public static SysconfName _SC_THREAD_ATTR_STACKSIZE;
    public static SysconfName _SC_THREAD_PRIORITY_SCHEDULING;
    public static SysconfName _SC_THREAD_PRIO_INHERIT;
    public static SysconfName _SC_THREAD_PRIO_PROTECT;
    public static SysconfName _SC_THREAD_PROCESS_SHARED;
    public static SysconfName _SC_NPROCESSORS_CONF;
    public static SysconfName _SC_NPROCESSORS_ONLN;
    public static SysconfName _SC_PHYS_PAGES;
    public static SysconfName _SC_AVPHYS_PAGES;
    public static SysconfName _SC_ATEXIT_MAX;
    public static SysconfName _SC_PASS_MAX;
    public static SysconfName _SC_XOPEN_VERSION;
    public static SysconfName _SC_XOPEN_XCU_VERSION;
    public static SysconfName _SC_XOPEN_UNIX;
    public static SysconfName _SC_XOPEN_CRYPT;
    public static SysconfName _SC_XOPEN_ENH_I18N;
    public static SysconfName _SC_XOPEN_SHM;
    public static SysconfName _SC_2_CHAR_TERM;
    public static SysconfName _SC_2_C_VERSION;
    public static SysconfName _SC_2_UPE;
    public static SysconfName _SC_XOPEN_XPG2;
    public static SysconfName _SC_XOPEN_XPG3;
    public static SysconfName _SC_XOPEN_XPG4;
    public static SysconfName _SC_CHAR_BIT;
    public static SysconfName _SC_CHAR_MAX;
    public static SysconfName _SC_CHAR_MIN;
    public static SysconfName _SC_INT_MAX;
    public static SysconfName _SC_INT_MIN;
    public static SysconfName _SC_LONG_BIT;
    public static SysconfName _SC_WORD_BIT;
    public static SysconfName _SC_MB_LEN_MAX;
    public static SysconfName _SC_NZERO;
    public static SysconfName _SC_SSIZE_MAX;
    public static SysconfName _SC_SCHAR_MAX;
    public static SysconfName _SC_SCHAR_MIN;
    public static SysconfName _SC_SHRT_MAX;
    public static SysconfName _SC_SHRT_MIN;
    public static SysconfName _SC_UCHAR_MAX;
    public static SysconfName _SC_UINT_MAX;
    public static SysconfName _SC_ULONG_MAX;
    public static SysconfName _SC_USHRT_MAX;
    public static SysconfName _SC_NL_ARGMAX;
    public static SysconfName _SC_NL_LANGMAX;
    public static SysconfName _SC_NL_MSGMAX;
    public static SysconfName _SC_NL_NMAX;
    public static SysconfName _SC_NL_SETMAX;
    public static SysconfName _SC_NL_TEXTMAX;
    public static SysconfName _SC_XBS5_ILP32_OFF32;
    public static SysconfName _SC_XBS5_ILP32_OFFBIG;
    public static SysconfName _SC_XBS5_LP64_OFF64;
    public static SysconfName _SC_XBS5_LPBIG_OFFBIG;
    public static SysconfName _SC_XOPEN_LEGACY;
    public static SysconfName _SC_XOPEN_REALTIME;
    public static SysconfName _SC_XOPEN_REALTIME_THREADS;
    public static SysconfName _SC_ADVISORY_INFO;
    public static SysconfName _SC_BARRIERS;
    public static SysconfName _SC_BASE;
    public static SysconfName _SC_C_LANG_SUPPORT;
    public static SysconfName _SC_C_LANG_SUPPORT_R;
    public static SysconfName _SC_CLOCK_SELECTION;
    public static SysconfName _SC_CPUTIME;
    public static SysconfName _SC_THREAD_CPUTIME;
    public static SysconfName _SC_DEVICE_IO;
    public static SysconfName _SC_DEVICE_SPECIFIC;
    public static SysconfName _SC_DEVICE_SPECIFIC_R;
    public static SysconfName _SC_FD_MGMT;
    public static SysconfName _SC_FIFO;
    public static SysconfName _SC_PIPE;
    public static SysconfName _SC_FILE_ATTRIBUTES;
    public static SysconfName _SC_FILE_LOCKING;
    public static SysconfName _SC_FILE_SYSTEM;
    public static SysconfName _SC_MONOTONIC_CLOCK;
    public static SysconfName _SC_MULTI_PROCESS;
    public static SysconfName _SC_SINGLE_PROCESS;
    public static SysconfName _SC_NETWORKING;
    public static SysconfName _SC_READER_WRITER_LOCKS;
    public static SysconfName _SC_SPIN_LOCKS;
    public static SysconfName _SC_REGEXP;
    public static SysconfName _SC_REGEX_VERSION;
    public static SysconfName _SC_SHELL;
    public static SysconfName _SC_SIGNALS;
    public static SysconfName _SC_SPAWN;
    public static SysconfName _SC_SPORADIC_SERVER;
    public static SysconfName _SC_THREAD_SPORADIC_SERVER;
    public static SysconfName _SC_SYSTEM_DATABASE;
    public static SysconfName _SC_SYSTEM_DATABASE_R;
    public static SysconfName _SC_TIMEOUTS;
    public static SysconfName _SC_TYPED_MEMORY_OBJECTS;
    public static SysconfName _SC_USER_GROUPS;
    public static SysconfName _SC_USER_GROUPS_R;
    public static SysconfName _SC_2_PBS;
    public static SysconfName _SC_2_PBS_ACCOUNTING;
    public static SysconfName _SC_2_PBS_LOCATE;
    public static SysconfName _SC_2_PBS_MESSAGE;
    public static SysconfName _SC_2_PBS_TRACK;
    public static SysconfName _SC_SYMLOOP_MAX;
    public static SysconfName _SC_STREAMS;
    public static SysconfName _SC_2_PBS_CHECKPOINT;
    public static SysconfName _SC_V6_ILP32_OFF32;
    public static SysconfName _SC_V6_ILP32_OFFBIG;
    public static SysconfName _SC_V6_LP64_OFF64;
    public static SysconfName _SC_V6_LPBIG_OFFBIG;
    public static SysconfName _SC_HOST_NAME_MAX;
    public static SysconfName _SC_TRACE;
    public static SysconfName _SC_TRACE_EVENT_FILTER;
    public static SysconfName _SC_TRACE_INHERIT;
    public static SysconfName _SC_TRACE_LOG;
    public static SysconfName _SC_LEVEL1_ICACHE_SIZE;
    public static SysconfName _SC_LEVEL1_ICACHE_ASSOC;
    public static SysconfName _SC_LEVEL1_ICACHE_LINESIZE;
    public static SysconfName _SC_LEVEL1_DCACHE_SIZE;
    public static SysconfName _SC_LEVEL1_DCACHE_ASSOC;
    public static SysconfName _SC_LEVEL1_DCACHE_LINESIZE;
    public static SysconfName _SC_LEVEL2_CACHE_SIZE;
    public static SysconfName _SC_LEVEL2_CACHE_ASSOC;
    public static SysconfName _SC_LEVEL2_CACHE_LINESIZE;
    public static SysconfName _SC_LEVEL3_CACHE_SIZE;
    public static SysconfName _SC_LEVEL3_CACHE_ASSOC;
    public static SysconfName _SC_LEVEL3_CACHE_LINESIZE;
    public static SysconfName _SC_LEVEL4_CACHE_SIZE;
    public static SysconfName _SC_LEVEL4_CACHE_ASSOC;
    public static SysconfName _SC_LEVEL4_CACHE_LINESIZE;
}
[MapAttribute]
[CLSCompliantAttribute("False")]
internal enum Mono.Unix.Native.SyslogFacility : Enum {
    public int value__;
    public static SyslogFacility LOG_KERN;
    public static SyslogFacility LOG_USER;
    public static SyslogFacility LOG_MAIL;
    public static SyslogFacility LOG_DAEMON;
    public static SyslogFacility LOG_AUTH;
    public static SyslogFacility LOG_SYSLOG;
    public static SyslogFacility LOG_LPR;
    public static SyslogFacility LOG_NEWS;
    public static SyslogFacility LOG_UUCP;
    public static SyslogFacility LOG_CRON;
    public static SyslogFacility LOG_AUTHPRIV;
    public static SyslogFacility LOG_FTP;
    public static SyslogFacility LOG_LOCAL0;
    public static SyslogFacility LOG_LOCAL1;
    public static SyslogFacility LOG_LOCAL2;
    public static SyslogFacility LOG_LOCAL3;
    public static SyslogFacility LOG_LOCAL4;
    public static SyslogFacility LOG_LOCAL5;
    public static SyslogFacility LOG_LOCAL6;
    public static SyslogFacility LOG_LOCAL7;
}
[MapAttribute]
[CLSCompliantAttribute("False")]
internal enum Mono.Unix.Native.SyslogLevel : Enum {
    public int value__;
    public static SyslogLevel LOG_EMERG;
    public static SyslogLevel LOG_ALERT;
    public static SyslogLevel LOG_CRIT;
    public static SyslogLevel LOG_ERR;
    public static SyslogLevel LOG_WARNING;
    public static SyslogLevel LOG_NOTICE;
    public static SyslogLevel LOG_INFO;
    public static SyslogLevel LOG_DEBUG;
}
[MapAttribute]
[CLSCompliantAttribute("False")]
[FlagsAttribute]
internal enum Mono.Unix.Native.SyslogOptions : Enum {
    public int value__;
    public static SyslogOptions LOG_PID;
    public static SyslogOptions LOG_CONS;
    public static SyslogOptions LOG_ODELAY;
    public static SyslogOptions LOG_NDELAY;
    public static SyslogOptions LOG_NOWAIT;
    public static SyslogOptions LOG_PERROR;
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.time_tAttribute : MapAttribute {
}
[MapAttribute("struct timespec")]
internal class Mono.Unix.Native.Timespec : ValueType {
    [time_tAttribute]
public long tv_sec;
    public long tv_nsec;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Timespec value);
    public static bool op_Equality(Timespec lhs, Timespec rhs);
    public static bool op_Inequality(Timespec lhs, Timespec rhs);
}
[MapAttribute("struct timeval")]
internal class Mono.Unix.Native.Timeval : ValueType {
    [time_tAttribute]
public long tv_sec;
    [suseconds_tAttribute]
public long tv_usec;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Timeval value);
    public static bool op_Equality(Timeval lhs, Timeval rhs);
    public static bool op_Inequality(Timeval lhs, Timeval rhs);
}
[MapAttribute("struct timezone")]
internal class Mono.Unix.Native.Timezone : ValueType {
    public int tz_minuteswest;
    private int tz_dsttime;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Timezone value);
    public static bool op_Equality(Timezone lhs, Timezone rhs);
    public static bool op_Inequality(Timezone lhs, Timezone rhs);
}
[AttributeUsageAttribute("256")]
internal class Mono.Unix.Native.uid_tAttribute : MapAttribute {
}
[MapAttribute("struct utimbuf")]
internal class Mono.Unix.Native.Utimbuf : ValueType {
    [time_tAttribute]
public long actime;
    [time_tAttribute]
public long modtime;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Utimbuf value);
    public static bool op_Equality(Utimbuf lhs, Utimbuf rhs);
    public static bool op_Inequality(Utimbuf lhs, Utimbuf rhs);
}
internal class Mono.Unix.Native.Utsname : object {
    public string sysname;
    public string nodename;
    public string release;
    public string version;
    public string machine;
    public string domainname;
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Utsname value);
    public virtual string ToString();
    public static bool op_Equality(Utsname lhs, Utsname rhs);
    public static bool op_Inequality(Utsname lhs, Utsname rhs);
}
[MapAttribute]
[FlagsAttribute]
internal enum Mono.Unix.Native.WaitOptions : Enum {
    public int value__;
    public static WaitOptions WNOHANG;
    public static WaitOptions WUNTRACED;
}
[CLSCompliantAttribute("False")]
[MapAttribute]
[FlagsAttribute]
internal enum Mono.Unix.Native.XattrFlags : Enum {
    public int value__;
    public static XattrFlags XATTR_AUTO;
    public static XattrFlags XATTR_CREATE;
    public static XattrFlags XATTR_REPLACE;
}
internal class Mono.Unix.Native.XPrintfFunctions : object {
    internal static XPrintf printf;
    internal static XPrintf fprintf;
    internal static XPrintf snprintf;
    internal static XPrintf syslog;
    private static XPrintfFunctions();
}
internal class Mono.Unix.PeerCred : object {
    private static int so_peercred;
    private PeerCredData data;
    public int ProcessID { get; }
    public int UserID { get; }
    public int GroupID { get; }
    public PeerCred(Socket sock);
    public int get_ProcessID();
    public int get_UserID();
    public int get_GroupID();
}
internal class Mono.Unix.StdioFileStream : Stream {
    public static IntPtr InvalidFileStream;
    public static IntPtr StandardInput;
    public static IntPtr StandardOutput;
    public static IntPtr StandardError;
    private bool canSeek;
    private bool canRead;
    private bool canWrite;
    private bool owner;
    private IntPtr file;
    public IntPtr Handle { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public StdioFileStream(IntPtr fileStream);
    public StdioFileStream(IntPtr fileStream, bool ownsHandle);
    public StdioFileStream(IntPtr fileStream, FileAccess access);
    public StdioFileStream(IntPtr fileStream, FileAccess access, bool ownsHandle);
    public StdioFileStream(string path);
    public StdioFileStream(string path, string mode);
    public StdioFileStream(string path, FileMode mode);
    public StdioFileStream(string path, FileAccess access);
    public StdioFileStream(string path, FileMode mode, FileAccess access);
    private static StdioFileStream();
    private static IntPtr Fopen(string path, string mode);
    private void InitStream(IntPtr fileStream, bool ownsHandle);
    private void InitCanReadWrite(FileAccess access);
    private static string ToFopenMode(string file, FileMode mode);
    private static string ToFopenMode(string file, FileAccess access);
    private static string ToFopenMode(string file, FileMode mode, FileAccess access);
    private static bool AssertFileMode(string file, FileMode mode);
    private static bool FileExists(string file);
    private void AssertNotDisposed();
    public IntPtr get_Handle();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public void SaveFilePosition(FilePosition pos);
    public void RestoreFilePosition(FilePosition pos);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void AssertValidBuffer(Byte[] buffer, int offset, int count);
    public void Rewind();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    protected virtual void Finalize();
    public virtual void Close();
}
internal class Mono.Unix.UnixClient : MarshalByRefObject {
    private NetworkStream stream;
    private Socket client;
    private bool disposed;
    public Socket Client { get; public set; }
    public PeerCred PeerCredential { get; }
    public LingerOption LingerState { get; public set; }
    public int ReceiveBufferSize { get; public set; }
    public int ReceiveTimeout { get; public set; }
    public int SendBufferSize { get; public set; }
    public int SendTimeout { get; public set; }
    public UnixClient(string path);
    public UnixClient(UnixEndPoint ep);
    internal UnixClient(Socket sock);
    public Socket get_Client();
    public void set_Client(Socket value);
    public PeerCred get_PeerCredential();
    public LingerOption get_LingerState();
    public void set_LingerState(LingerOption value);
    public int get_ReceiveBufferSize();
    public void set_ReceiveBufferSize(int value);
    public int get_ReceiveTimeout();
    public void set_ReceiveTimeout(int value);
    public int get_SendBufferSize();
    public void set_SendBufferSize(int value);
    public int get_SendTimeout();
    public void set_SendTimeout(int value);
    public void Close();
    public void Connect(UnixEndPoint remoteEndPoint);
    public void Connect(string path);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public NetworkStream GetStream();
    private void CheckDisposed();
    protected virtual void Finalize();
}
internal class Mono.Unix.UnixDirectoryInfo : UnixFileSystemInfo {
    public string Name { get; }
    public UnixDirectoryInfo Parent { get; }
    public UnixDirectoryInfo Root { get; }
    public UnixDirectoryInfo(string path);
    internal UnixDirectoryInfo(string path, Stat stat);
    public virtual string get_Name();
    public UnixDirectoryInfo get_Parent();
    public UnixDirectoryInfo get_Root();
    [CLSCompliantAttribute("False")]
public void Create(FilePermissions mode);
    public void Create(FileAccessPermissions mode);
    public void Create();
    public virtual void Delete();
    public void Delete(bool recursive);
    public Dirent[] GetEntries();
    private static Dirent[] GetEntries(IntPtr dirp);
    public Dirent[] GetEntries(Regex regex);
    private static Dirent[] GetEntries(IntPtr dirp, Regex regex);
    public Dirent[] GetEntries(string regex);
    public UnixFileSystemInfo[] GetFileSystemEntries();
    private UnixFileSystemInfo[] GetFileSystemEntries(Dirent[] dentries);
    public UnixFileSystemInfo[] GetFileSystemEntries(Regex regex);
    public UnixFileSystemInfo[] GetFileSystemEntries(string regex);
    public static string GetCurrentDirectory();
    public static void SetCurrentDirectory(string path);
}
internal class Mono.Unix.UnixDriveInfo : object {
    private Statvfs stat;
    private string fstype;
    private string mount_point;
    private string block_device;
    public long AvailableFreeSpace { get; }
    public string DriveFormat { get; }
    public UnixDriveType DriveType { get; }
    public bool IsReady { get; }
    public string Name { get; }
    public UnixDirectoryInfo RootDirectory { get; }
    public long TotalFreeSpace { get; }
    public long TotalSize { get; }
    public string VolumeLabel { get; }
    public long MaximumFilenameLength { get; }
    public UnixDriveInfo(string mountPoint);
    private UnixDriveInfo(Fstab fstab);
    private void FromFstab(Fstab fstab);
    public static UnixDriveInfo GetForSpecialFile(string specialFile);
    public long get_AvailableFreeSpace();
    public string get_DriveFormat();
    public UnixDriveType get_DriveType();
    public bool get_IsReady();
    public string get_Name();
    public UnixDirectoryInfo get_RootDirectory();
    public long get_TotalFreeSpace();
    public long get_TotalSize();
    public string get_VolumeLabel();
    public long get_MaximumFilenameLength();
    public static UnixDriveInfo[] GetDrives();
    public virtual string ToString();
    private void Refresh();
    private bool Refresh(bool throwException);
}
internal enum Mono.Unix.UnixDriveType : Enum {
    public int value__;
    public static UnixDriveType Unknown;
    public static UnixDriveType NoRootDirectory;
    public static UnixDriveType Removable;
    public static UnixDriveType Fixed;
    public static UnixDriveType Network;
    public static UnixDriveType CDRom;
    public static UnixDriveType Ram;
}
internal class Mono.Unix.UnixEncoding : Encoding {
    public static Encoding Instance;
    public static char EscapeByte;
    private static UnixEncoding();
    private static int InternalGetByteCount(Char[] chars, int index, int count, UInt32 leftOver, bool flush);
    public virtual int GetByteCount(Char[] chars, int index, int count);
    public virtual int GetByteCount(string s);
    private static int InternalGetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, UInt32& leftOver, bool flush);
    public virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    private static int InternalGetCharCount(Byte[] bytes, int index, int count, UInt32 leftOverBits, UInt32 leftOverCount, bool throwOnInvalid, bool flush);
    public virtual int GetCharCount(Byte[] bytes, int index, int count);
    private static int InternalGetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, UInt32& leftOverBits, UInt32& leftOverCount, bool throwOnInvalid, bool flush);
    private static void CopyRaw(Byte[] raw, Int32& next_raw, Char[] chars, Int32& posn, int length);
    public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    public virtual int GetMaxByteCount(int charCount);
    public virtual int GetMaxCharCount(int byteCount);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public virtual Byte[] GetPreamble();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual Byte[] GetBytes(string s);
    private static string _(string arg);
}
internal class Mono.Unix.UnixEndPoint : EndPoint {
    private string filename;
    public string Filename { get; public set; }
    public AddressFamily AddressFamily { get; }
    public UnixEndPoint(string filename);
    public string get_Filename();
    public void set_Filename(string value);
    public virtual AddressFamily get_AddressFamily();
    public virtual EndPoint Create(SocketAddress socketAddress);
    public virtual SocketAddress Serialize();
    public virtual string ToString();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
internal class Mono.Unix.UnixEnvironment : object {
    public static string CurrentDirectory { get; public set; }
    public static string MachineName { get; public set; }
    public static string UserName { get; }
    public static UnixGroupInfo RealGroup { get; }
    public static long RealGroupId { get; }
    public static UnixUserInfo RealUser { get; }
    public static long RealUserId { get; }
    public static UnixGroupInfo EffectiveGroup { get; public set; }
    public static long EffectiveGroupId { get; public set; }
    public static UnixUserInfo EffectiveUser { get; public set; }
    public static long EffectiveUserId { get; public set; }
    public static string Login { get; }
    public static string get_CurrentDirectory();
    public static void set_CurrentDirectory(string value);
    public static string get_MachineName();
    public static void set_MachineName(string value);
    public static string get_UserName();
    public static UnixGroupInfo get_RealGroup();
    public static long get_RealGroupId();
    public static UnixUserInfo get_RealUser();
    public static long get_RealUserId();
    public static UnixGroupInfo get_EffectiveGroup();
    public static void set_EffectiveGroup(UnixGroupInfo value);
    public static long get_EffectiveGroupId();
    public static void set_EffectiveGroupId(long value);
    public static UnixUserInfo get_EffectiveUser();
    public static void set_EffectiveUser(UnixUserInfo value);
    public static long get_EffectiveUserId();
    public static void set_EffectiveUserId(long value);
    public static string get_Login();
    [CLSCompliantAttribute("False")]
public static long GetConfigurationValue(SysconfName name);
    [CLSCompliantAttribute("False")]
public static string GetConfigurationString(ConfstrName name);
    public static void SetNiceValue(int inc);
    public static int CreateSession();
    public static void SetProcessGroup();
    public static int GetProcessGroup();
    public static UnixGroupInfo[] GetSupplementaryGroups();
    private static UInt32[] _GetSupplementaryGroupIds();
    public static void SetSupplementaryGroups(UnixGroupInfo[] groups);
    public static Int64[] GetSupplementaryGroupIds();
    public static void SetSupplementaryGroupIds(Int64[] list);
    public static int GetParentProcessId();
    public static UnixProcess GetParentProcess();
    public static String[] GetUserShells();
}
internal class Mono.Unix.UnixFileInfo : UnixFileSystemInfo {
    public string Name { get; }
    public string DirectoryName { get; }
    public UnixDirectoryInfo Directory { get; }
    public UnixFileInfo(string path);
    internal UnixFileInfo(string path, Stat stat);
    public virtual string get_Name();
    public string get_DirectoryName();
    public UnixDirectoryInfo get_Directory();
    public virtual void Delete();
    public UnixStream Create();
    [CLSCompliantAttribute("False")]
public UnixStream Create(FilePermissions mode);
    public UnixStream Create(FileAccessPermissions mode);
    [CLSCompliantAttribute("False")]
public UnixStream Open(OpenFlags flags);
    [CLSCompliantAttribute("False")]
public UnixStream Open(OpenFlags flags, FilePermissions mode);
    public UnixStream Open(FileMode mode);
    public UnixStream Open(FileMode mode, FileAccess access);
    [CLSCompliantAttribute("False")]
public UnixStream Open(FileMode mode, FileAccess access, FilePermissions perms);
    public UnixStream OpenRead();
    public UnixStream OpenWrite();
}
internal abstract class Mono.Unix.UnixFileSystemInfo : object {
    internal static FileSpecialAttributes AllSpecialAttributes;
    internal static FileTypes AllFileTypes;
    private Stat stat;
    private string fullPath;
    private string originalPath;
    private bool valid;
    protected string FullPath { get; protected set; }
    protected string OriginalPath { get; protected set; }
    public string FullName { get; }
    public string Name { get; }
    public bool Exists { get; }
    public long Device { get; }
    public long Inode { get; }
    [CLSCompliantAttribute("False")]
public FilePermissions Protection { get; public set; }
    public FileTypes FileType { get; }
    public FileAccessPermissions FileAccessPermissions { get; public set; }
    public FileSpecialAttributes FileSpecialAttributes { get; public set; }
    public long LinkCount { get; }
    public UnixUserInfo OwnerUser { get; }
    public long OwnerUserId { get; }
    public UnixGroupInfo OwnerGroup { get; }
    public long OwnerGroupId { get; }
    public long DeviceType { get; }
    public long Length { get; }
    public long BlockSize { get; }
    public long BlocksAllocated { get; }
    public DateTime LastAccessTime { get; }
    public DateTime LastAccessTimeUtc { get; }
    public DateTime LastWriteTime { get; }
    public DateTime LastWriteTimeUtc { get; }
    public DateTime LastStatusChangeTime { get; }
    public DateTime LastStatusChangeTimeUtc { get; }
    public bool IsDirectory { get; }
    public bool IsCharacterDevice { get; }
    public bool IsBlockDevice { get; }
    public bool IsRegularFile { get; }
    public bool IsFifo { get; }
    public bool IsSymbolicLink { get; }
    public bool IsSocket { get; }
    public bool IsSetUser { get; }
    public bool IsSetGroup { get; }
    public bool IsSticky { get; }
    protected UnixFileSystemInfo(string path);
    internal UnixFileSystemInfo(string path, Stat stat);
    protected string get_FullPath();
    protected void set_FullPath(string value);
    protected string get_OriginalPath();
    protected void set_OriginalPath(string value);
    private void AssertValid();
    public virtual string get_FullName();
    public abstract virtual string get_Name();
    public bool get_Exists();
    public long get_Device();
    public long get_Inode();
    public FilePermissions get_Protection();
    public void set_Protection(FilePermissions value);
    public FileTypes get_FileType();
    public FileAccessPermissions get_FileAccessPermissions();
    public void set_FileAccessPermissions(FileAccessPermissions value);
    public FileSpecialAttributes get_FileSpecialAttributes();
    public void set_FileSpecialAttributes(FileSpecialAttributes value);
    public long get_LinkCount();
    public UnixUserInfo get_OwnerUser();
    public long get_OwnerUserId();
    public UnixGroupInfo get_OwnerGroup();
    public long get_OwnerGroupId();
    public long get_DeviceType();
    public long get_Length();
    public long get_BlockSize();
    public long get_BlocksAllocated();
    public DateTime get_LastAccessTime();
    public DateTime get_LastAccessTimeUtc();
    public DateTime get_LastWriteTime();
    public DateTime get_LastWriteTimeUtc();
    public DateTime get_LastStatusChangeTime();
    public DateTime get_LastStatusChangeTimeUtc();
    public bool get_IsDirectory();
    public bool get_IsCharacterDevice();
    public bool get_IsBlockDevice();
    public bool get_IsRegularFile();
    public bool get_IsFifo();
    public bool get_IsSymbolicLink();
    public bool get_IsSocket();
    public bool get_IsSetUser();
    public bool get_IsSetGroup();
    public bool get_IsSticky();
    internal static bool IsFileType(FilePermissions mode, FilePermissions type);
    internal static bool IsSet(FilePermissions mode, FilePermissions type);
    [CLSCompliantAttribute("False")]
public bool CanAccess(AccessModes mode);
    public UnixFileSystemInfo CreateLink(string path);
    public UnixSymbolicLinkInfo CreateSymbolicLink(string path);
    public abstract virtual void Delete();
    [CLSCompliantAttribute("False")]
public long GetConfigurationValue(PathconfName name);
    public void Refresh();
    internal void Refresh(bool force);
    protected virtual bool GetFileStatus(string path, Stat& stat);
    public void SetLength(long length);
    public virtual void SetOwner(long owner, long group);
    public void SetOwner(string owner);
    public void SetOwner(string owner, string group);
    public void SetOwner(UnixUserInfo owner);
    public void SetOwner(UnixUserInfo owner, UnixGroupInfo group);
    public virtual string ToString();
    public Stat ToStat();
    public static UnixFileSystemInfo GetFileSystemEntry(string path);
}
internal class Mono.Unix.UnixGroupInfo : object {
    private Group group;
    public string GroupName { get; }
    public string Password { get; }
    public long GroupId { get; }
    public UnixGroupInfo(string group);
    public UnixGroupInfo(long group);
    public UnixGroupInfo(Group group);
    private static Group CopyGroup(Group group);
    public string get_GroupName();
    public string get_Password();
    public long get_GroupId();
    public UnixUserInfo[] GetMembers();
    public String[] GetMemberNames();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public Group ToGroup();
    public static UnixGroupInfo[] GetLocalGroups();
}
internal class Mono.Unix.UnixIOException : IOException {
    private int errno;
    public int NativeErrorCode { get; }
    public Errno ErrorCode { get; }
    public UnixIOException(int errno);
    public UnixIOException(int errno, Exception inner);
    public UnixIOException(Errno errno);
    public UnixIOException(Errno errno, Exception inner);
    public UnixIOException(string message);
    public UnixIOException(string message, Exception inner);
    protected UnixIOException(SerializationInfo info, StreamingContext context);
    public int get_NativeErrorCode();
    public Errno get_ErrorCode();
    private static string GetMessage(Errno errno);
}
internal class Mono.Unix.UnixListener : MarshalByRefObject {
    private bool disposed;
    private bool listening;
    private Socket server;
    private EndPoint savedEP;
    public EndPoint LocalEndpoint { get; }
    protected Socket Server { get; }
    public UnixListener(string path);
    public UnixListener(UnixEndPoint localEndPoint);
    private void Init(UnixEndPoint ep);
    public EndPoint get_LocalEndpoint();
    protected Socket get_Server();
    public Socket AcceptSocket();
    public UnixClient AcceptUnixClient();
    protected virtual void Finalize();
    public bool Pending();
    public void Start();
    public void Start(int backlog);
    public void Stop();
    public sealed virtual void Dispose();
    protected void Dispose(bool disposing);
    private void CheckDisposed();
}
internal class Mono.Unix.UnixMarshal : object {
    [CLSCompliantAttribute("False")]
public static string GetErrorDescription(Errno errno);
    public static IntPtr AllocHeap(long size);
    public static IntPtr ReAllocHeap(IntPtr ptr, long size);
    public static void FreeHeap(IntPtr ptr);
    public static string PtrToStringUnix(IntPtr p);
    public static string PtrToString(IntPtr p);
    public static string PtrToString(IntPtr p, Encoding encoding);
    private static int GetStringByteLength(IntPtr p, Encoding encoding);
    private static int GetInt16BufferLength(IntPtr p);
    private static int GetInt32BufferLength(IntPtr p);
    private static int GetRandomBufferLength(IntPtr p, int nullLength);
    public static String[] PtrToStringArray(IntPtr stringArray);
    public static String[] PtrToStringArray(IntPtr stringArray, Encoding encoding);
    private static int CountStrings(IntPtr stringArray);
    public static String[] PtrToStringArray(int count, IntPtr stringArray);
    public static String[] PtrToStringArray(int count, IntPtr stringArray, Encoding encoding);
    public static IntPtr StringToHeap(string s);
    public static IntPtr StringToHeap(string s, Encoding encoding);
    public static IntPtr StringToHeap(string s, int index, int count);
    public static IntPtr StringToHeap(string s, int index, int count, Encoding encoding);
    public static bool ShouldRetrySyscall(int r);
    [CLSCompliantAttribute("False")]
public static bool ShouldRetrySyscall(int r, Errno& errno);
    internal static string EscapeFormatString(string message, Char[] permitted);
    private static bool IsCharPresent(Char[] array, char c);
    internal static Exception CreateExceptionForError(Errno errno);
    internal static Exception CreateExceptionForLastError();
    [CLSCompliantAttribute("False")]
public static void ThrowExceptionForError(Errno errno);
    public static void ThrowExceptionForLastError();
    [CLSCompliantAttribute("False")]
public static void ThrowExceptionForErrorIf(int retval, Errno errno);
    public static void ThrowExceptionForLastErrorIf(int retval);
}
internal class Mono.Unix.UnixPath : object {
    public static char DirectorySeparatorChar;
    public static char AltDirectorySeparatorChar;
    public static char PathSeparator;
    public static char VolumeSeparatorChar;
    private static Char[] _InvalidPathChars;
    private static UnixPath();
    public static Char[] GetInvalidPathChars();
    public static string Combine(string path1, String[] paths);
    private static void Combine(StringBuilder path, string part);
    public static string GetDirectoryName(string path);
    public static string GetFileName(string path);
    public static string GetFullPath(string path);
    private static string _GetFullPath(string path);
    public static string GetCanonicalPath(string path);
    private static void GetPathComponents(string path, String[]& components, Int32& lastIndex);
    public static string GetPathRoot(string path);
    public static string GetCompleteRealPath(string path);
    public static string GetRealPath(string path);
    internal static string ReadSymbolicLink(string path);
    private static string ReadSymbolicLink(string path, Errno& errno);
    public static string TryReadLink(string path);
    public static string ReadLink(string path);
    public static bool IsPathRooted(string path);
    internal static void CheckPath(string path);
}
internal class Mono.Unix.UnixPipes : ValueType {
    public UnixStream Reading;
    public UnixStream Writing;
    public UnixPipes(UnixStream reading, UnixStream writing);
    public static UnixPipes CreatePipes();
    public virtual bool Equals(object value);
    public sealed virtual bool Equals(UnixPipes value);
    public virtual int GetHashCode();
    public static bool op_Equality(UnixPipes lhs, UnixPipes rhs);
    public static bool op_Inequality(UnixPipes lhs, UnixPipes rhs);
}
internal class Mono.Unix.UnixProcess : object {
    private int pid;
    public int Id { get; }
    public bool HasExited { get; }
    public int ExitCode { get; }
    public bool HasSignaled { get; }
    public Signum TerminationSignal { get; }
    public bool HasStopped { get; }
    public Signum StopSignal { get; }
    public int ProcessGroupId { get; public set; }
    public int SessionId { get; }
    internal UnixProcess(int pid);
    public int get_Id();
    public bool get_HasExited();
    private int GetProcessStatus();
    public int get_ExitCode();
    public bool get_HasSignaled();
    public Signum get_TerminationSignal();
    public bool get_HasStopped();
    public Signum get_StopSignal();
    public int get_ProcessGroupId();
    public void set_ProcessGroupId(int value);
    public int get_SessionId();
    public static UnixProcess GetCurrentProcess();
    public static int GetCurrentProcessId();
    public void Kill();
    [CLSCompliantAttribute("False")]
public void Signal(Signum signal);
    public void WaitForExit();
}
internal class Mono.Unix.UnixSignal : WaitHandle {
    private int signum;
    private IntPtr signal_info;
    private static Mono_Posix_RuntimeIsShuttingDown ShuttingDown;
    public Signum Signum { get; }
    public RealTimeSignum RealTimeSignum { get; }
    public bool IsRealTimeSignal { get; }
    private SignalInfo* Info { get; }
    public bool IsSet { get; }
    public int Count { get; public set; }
    public UnixSignal(Signum signum);
    public UnixSignal(RealTimeSignum rtsig);
    private static UnixSignal();
    public Signum get_Signum();
    public RealTimeSignum get_RealTimeSignum();
    public bool get_IsRealTimeSignal();
    private static IntPtr install(int signum);
    private static int uninstall(IntPtr info);
    private static int RuntimeShuttingDownCallback();
    private static int WaitAny(IntPtr[] infos, int count, int timeout, Mono_Posix_RuntimeIsShuttingDown shutting_down);
    internal static int GetSIGRTMIN();
    internal static int GetSIGRTMAX();
    private void AssertValid();
    private SignalInfo* get_Info();
    public bool get_IsSet();
    public bool Reset();
    public int get_Count();
    public void set_Count(int value);
    protected virtual void Dispose(bool disposing);
    public virtual bool WaitOne();
    public virtual bool WaitOne(TimeSpan timeout, bool exitContext);
    public virtual bool WaitOne(int millisecondsTimeout, bool exitContext);
    public static int WaitAny(UnixSignal[] signals);
    public static int WaitAny(UnixSignal[] signals, TimeSpan timeout);
    public static int WaitAny(UnixSignal[] signals, int millisecondsTimeout);
}
internal class Mono.Unix.UnixStream : Stream {
    public static int InvalidFileDescriptor;
    public static int StandardInputFileDescriptor;
    public static int StandardOutputFileDescriptor;
    public static int StandardErrorFileDescriptor;
    private bool canSeek;
    private bool canRead;
    private bool canWrite;
    private bool owner;
    private int fileDescriptor;
    private Stat stat;
    public int Handle { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    [CLSCompliantAttribute("False")]
public FilePermissions Protection { get; public set; }
    public FileTypes FileType { get; }
    public FileAccessPermissions FileAccessPermissions { get; public set; }
    public FileSpecialAttributes FileSpecialAttributes { get; public set; }
    public UnixUserInfo OwnerUser { get; }
    public long OwnerUserId { get; }
    public UnixGroupInfo OwnerGroup { get; }
    public long OwnerGroupId { get; }
    public UnixStream(int fileDescriptor);
    public UnixStream(int fileDescriptor, bool ownsHandle);
    private sealed virtual override void System.IDisposable.Dispose();
    private void AssertNotDisposed();
    public int get_Handle();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public FilePermissions get_Protection();
    public void set_Protection(FilePermissions value);
    public FileTypes get_FileType();
    public FileAccessPermissions get_FileAccessPermissions();
    public void set_FileAccessPermissions(FileAccessPermissions value);
    public FileSpecialAttributes get_FileSpecialAttributes();
    public void set_FileSpecialAttributes(FileSpecialAttributes value);
    public UnixUserInfo get_OwnerUser();
    public long get_OwnerUserId();
    public UnixGroupInfo get_OwnerGroup();
    public long get_OwnerGroupId();
    private void RefreshStat();
    public void AdviseFileAccessPattern(FileAccessPattern pattern, long offset, long len);
    public void AdviseFileAccessPattern(FileAccessPattern pattern);
    public virtual void Flush();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void AssertValidBuffer(Byte[] buffer, int offset, int count);
    public int ReadAtOffset(Byte[] buffer, int offset, int count, long fileOffset);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public void WriteAtOffset(Byte[] buffer, int offset, int count, long fileOffset);
    public void SendTo(UnixStream output);
    [CLSCompliantAttribute("False")]
public void SendTo(UnixStream output, ulong count);
    [CLSCompliantAttribute("False")]
public void SendTo(int out_fd, ulong count);
    public void SetOwner(long user, long group);
    public void SetOwner(string user, string group);
    public void SetOwner(string user);
    [CLSCompliantAttribute("False")]
public long GetConfigurationValue(PathconfName name);
    protected virtual void Finalize();
    public virtual void Close();
}
internal class Mono.Unix.UnixSymbolicLinkInfo : UnixFileSystemInfo {
    public string Name { get; }
    [ObsoleteAttribute("Use GetContents()")]
public UnixFileSystemInfo Contents { get; }
    public string ContentsPath { get; }
    public bool HasContents { get; }
    public UnixSymbolicLinkInfo(string path);
    internal UnixSymbolicLinkInfo(string path, Stat stat);
    public virtual string get_Name();
    public UnixFileSystemInfo get_Contents();
    public string get_ContentsPath();
    public bool get_HasContents();
    public UnixFileSystemInfo GetContents();
    public void CreateSymbolicLinkTo(string path);
    public void CreateSymbolicLinkTo(UnixFileSystemInfo path);
    public virtual void Delete();
    public virtual void SetOwner(long owner, long group);
    protected virtual bool GetFileStatus(string path, Stat& stat);
    private string ReadLink();
    private string TryReadLink();
}
internal class Mono.Unix.UnixUserInfo : object {
    private Passwd passwd;
    public string UserName { get; }
    public string Password { get; }
    public long UserId { get; }
    public UnixGroupInfo Group { get; }
    public long GroupId { get; }
    public string GroupName { get; }
    public string RealName { get; }
    public string HomeDirectory { get; }
    public string ShellProgram { get; }
    public UnixUserInfo(string user);
    [CLSCompliantAttribute("False")]
public UnixUserInfo(UInt32 user);
    public UnixUserInfo(long user);
    public UnixUserInfo(Passwd passwd);
    private static Passwd CopyPasswd(Passwd pw);
    public string get_UserName();
    public string get_Password();
    public long get_UserId();
    public UnixGroupInfo get_Group();
    public long get_GroupId();
    public string get_GroupName();
    public string get_RealName();
    public string get_HomeDirectory();
    public string get_ShellProgram();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public virtual string ToString();
    public static UnixUserInfo GetRealUser();
    public static long GetRealUserId();
    public static string GetLoginName();
    public Passwd ToPasswd();
    public static UnixUserInfo[] GetLocalUsers();
}
