[ExtensionAttribute]
public static class Xamarin.Essentials.Accelerometer : object {
    private static double accelerationThreshold;
    private static double gravity;
    private static AccelerometerQueue queue;
    private static bool useSyncContext;
    [CompilerGeneratedAttribute]
private static EventHandler`1<AccelerometerChangedEventArgs> ReadingChanged;
    [CompilerGeneratedAttribute]
private static EventHandler ShakeDetected;
    [CompilerGeneratedAttribute]
private static bool <IsMonitoring>k__BackingField;
    public static bool IsMonitoring { get; private set; }
    internal static bool IsSupported { get; }
    private static Accelerometer();
    [CompilerGeneratedAttribute]
public static void add_ReadingChanged(EventHandler`1<AccelerometerChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_ReadingChanged(EventHandler`1<AccelerometerChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public static void add_ShakeDetected(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ShakeDetected(EventHandler value);
    [CompilerGeneratedAttribute]
public static bool get_IsMonitoring();
    [CompilerGeneratedAttribute]
private static void set_IsMonitoring(bool value);
    public static void Start(SensorSpeed sensorSpeed);
    public static void Stop();
    internal static void OnChanged(AccelerometerData reading);
    internal static void OnChanged(AccelerometerChangedEventArgs e);
    private static void ProcessShakeEvent(Vector3 acceleration);
    [ExtensionAttribute]
private static double Square(double q);
    [ExtensionAttribute]
internal static long Nanoseconds(DateTime time);
    internal static bool get_IsSupported();
    internal static void PlatformStart(SensorSpeed sensorSpeed);
    private static void DataUpdated(CMAccelerometerData data, NSError error);
    internal static void PlatformStop();
}
public class Xamarin.Essentials.AccelerometerChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private AccelerometerData <Reading>k__BackingField;
    public AccelerometerData Reading { get; }
    public AccelerometerChangedEventArgs(AccelerometerData reading);
    [CompilerGeneratedAttribute]
public AccelerometerData get_Reading();
}
[IsReadOnlyAttribute]
public class Xamarin.Essentials.AccelerometerData : ValueType {
    [CompilerGeneratedAttribute]
private Vector3 <Acceleration>k__BackingField;
    public Vector3 Acceleration { get; }
    public AccelerometerData(double x, double y, double z);
    public AccelerometerData(float x, float y, float z);
    [CompilerGeneratedAttribute]
public Vector3 get_Acceleration();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AccelerometerData other);
    public static bool op_Equality(AccelerometerData left, AccelerometerData right);
    public static bool op_Inequality(AccelerometerData left, AccelerometerData right);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class Xamarin.Essentials.AccelerometerQueue : object {
    private AccelerometerDataPool pool;
    private long maxWindowSize;
    private long minWindowSize;
    private int minQueueSize;
    private AccelerometerSample oldest;
    private AccelerometerSample newest;
    private int sampleCount;
    private int acceleratingCount;
    internal bool IsShaking { get; }
    internal void Add(long timestamp, bool accelerating);
    internal void Clear();
    private void Purge(long cutoff);
    internal bool get_IsShaking();
}
public enum Xamarin.Essentials.AltitudeReferenceSystem : Enum {
    public int value__;
    public static AltitudeReferenceSystem Unspecified;
    public static AltitudeReferenceSystem Terrain;
    public static AltitudeReferenceSystem Ellipsoid;
    public static AltitudeReferenceSystem Geoid;
    public static AltitudeReferenceSystem Surface;
}
public class Xamarin.Essentials.AppAction : object {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subtitle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Icon>k__BackingField;
    public string Title { get; public set; }
    public string Subtitle { get; public set; }
    public string Id { get; public set; }
    internal string Icon { get; internal set; }
    public AppAction(string id, string title, string subtitle, string icon);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Subtitle();
    [CompilerGeneratedAttribute]
public void set_Subtitle(string value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
internal string get_Icon();
    [CompilerGeneratedAttribute]
internal void set_Icon(string value);
}
public class Xamarin.Essentials.AppActionEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private AppAction <AppAction>k__BackingField;
    public AppAction AppAction { get; }
    public AppActionEventArgs(AppAction appAction);
    [CompilerGeneratedAttribute]
public AppAction get_AppAction();
}
public static class Xamarin.Essentials.AppActions : object {
    [CompilerGeneratedAttribute]
private static EventHandler`1<AppActionEventArgs> OnAppAction;
    internal static bool IsSupported { get; }
    internal static bool PlatformIsSupported { get; }
    internal static bool get_IsSupported();
    public static Task`1<IEnumerable`1<AppAction>> GetAsync();
    public static Task SetAsync(AppAction[] actions);
    public static Task SetAsync(IEnumerable`1<AppAction> actions);
    [CompilerGeneratedAttribute]
public static void add_OnAppAction(EventHandler`1<AppActionEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_OnAppAction(EventHandler`1<AppActionEventArgs> value);
    internal static void InvokeOnAppAction(object sender, AppAction appAction);
    internal static bool get_PlatformIsSupported();
    private static Task`1<IEnumerable`1<AppAction>> PlatformGetAsync();
    private static Task PlatformSetAsync(IEnumerable`1<AppAction> actions);
}
public static class Xamarin.Essentials.AppInfo : object {
    public static string PackageName { get; }
    public static string Name { get; }
    public static string VersionString { get; }
    public static Version Version { get; }
    public static string BuildString { get; }
    public static AppTheme RequestedTheme { get; }
    public static string get_PackageName();
    public static string get_Name();
    public static string get_VersionString();
    public static Version get_Version();
    public static string get_BuildString();
    public static void ShowSettingsUI();
    public static AppTheme get_RequestedTheme();
    private static string PlatformGetPackageName();
    private static string PlatformGetName();
    private static string PlatformGetVersionString();
    private static string PlatformGetBuild();
    private static string GetBundleValue(string key);
    private static void PlatformShowSettingsUI();
    private static AppTheme PlatformRequestedTheme();
    internal static bool VerifyHasUrlScheme(string scheme);
    internal static IEnumerable`1<string> GetCFBundleURLSchemes();
    [IteratorStateMachineAttribute("Xamarin.Essentials.AppInfo/<ConvertToIEnumerable>d__22`1")]
private static IEnumerable`1<T> ConvertToIEnumerable(NSArray array);
}
public static class Xamarin.Essentials.AppleSignInAuthenticator : object {
    public static Task`1<WebAuthenticatorResult> AuthenticateAsync(Options options);
    private static Task`1<WebAuthenticatorResult> PlatformAuthenticateAsync(Options options);
}
public enum Xamarin.Essentials.AppTheme : Enum {
    public int value__;
    public static AppTheme Unspecified;
    public static AppTheme Light;
    public static AppTheme Dark;
}
public static class Xamarin.Essentials.Barometer : object {
    private static bool useSyncContext;
    [CompilerGeneratedAttribute]
private static EventHandler`1<BarometerChangedEventArgs> ReadingChanged;
    [CompilerGeneratedAttribute]
private static bool <IsMonitoring>k__BackingField;
    private static CMAltimeter altitudeManager;
    public static bool IsMonitoring { get; private set; }
    internal static bool IsSupported { get; }
    [CompilerGeneratedAttribute]
public static void add_ReadingChanged(EventHandler`1<BarometerChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_ReadingChanged(EventHandler`1<BarometerChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public static bool get_IsMonitoring();
    [CompilerGeneratedAttribute]
private static void set_IsMonitoring(bool value);
    public static void Start(SensorSpeed sensorSpeed);
    public static void Stop();
    internal static void OnChanged(BarometerData reading);
    private static void OnChanged(BarometerChangedEventArgs e);
    internal static bool get_IsSupported();
    private static void PlatformStart(SensorSpeed sensorSpeed);
    private static void PlatformStop();
    [CompilerGeneratedAttribute]
internal static void <PlatformStart>g__LocationManagerUpdatedHeading|15_0(CMAltitudeData e, NSError error);
}
public class Xamarin.Essentials.BarometerChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private BarometerData <Reading>k__BackingField;
    public BarometerData Reading { get; }
    public BarometerChangedEventArgs(BarometerData reading);
    [CompilerGeneratedAttribute]
public BarometerData get_Reading();
}
[IsReadOnlyAttribute]
public class Xamarin.Essentials.BarometerData : ValueType {
    [CompilerGeneratedAttribute]
private double <PressureInHectopascals>k__BackingField;
    public double PressureInHectopascals { get; }
    public BarometerData(double pressure);
    [CompilerGeneratedAttribute]
public double get_PressureInHectopascals();
    public static bool op_Equality(BarometerData left, BarometerData right);
    public static bool op_Inequality(BarometerData left, BarometerData right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(BarometerData other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class Xamarin.Essentials.Battery : object {
    [CompilerGeneratedAttribute]
private static EventHandler`1<BatteryInfoChangedEventArgs> BatteryInfoChangedInternal;
    [CompilerGeneratedAttribute]
private static EventHandler`1<EnergySaverStatusChangedEventArgs> EnergySaverStatusChangedInternal;
    private static double currentLevel;
    private static BatteryPowerSource currentSource;
    private static BatteryState currentState;
    private static NSObject saverStatusObserver;
    public static double ChargeLevel { get; }
    public static BatteryState State { get; }
    public static BatteryPowerSource PowerSource { get; }
    public static EnergySaverStatus EnergySaverStatus { get; }
    private static EnergySaverStatus PlatformEnergySaverStatus { get; }
    private static double PlatformChargeLevel { get; }
    private static BatteryState PlatformState { get; }
    private static BatteryPowerSource PlatformPowerSource { get; }
    [CompilerGeneratedAttribute]
private static void add_BatteryInfoChangedInternal(EventHandler`1<BatteryInfoChangedEventArgs> value);
    [CompilerGeneratedAttribute]
private static void remove_BatteryInfoChangedInternal(EventHandler`1<BatteryInfoChangedEventArgs> value);
    [CompilerGeneratedAttribute]
private static void add_EnergySaverStatusChangedInternal(EventHandler`1<EnergySaverStatusChangedEventArgs> value);
    [CompilerGeneratedAttribute]
private static void remove_EnergySaverStatusChangedInternal(EventHandler`1<EnergySaverStatusChangedEventArgs> value);
    public static double get_ChargeLevel();
    public static BatteryState get_State();
    public static BatteryPowerSource get_PowerSource();
    public static EnergySaverStatus get_EnergySaverStatus();
    public static void add_BatteryInfoChanged(EventHandler`1<BatteryInfoChangedEventArgs> value);
    public static void remove_BatteryInfoChanged(EventHandler`1<BatteryInfoChangedEventArgs> value);
    public static void add_EnergySaverStatusChanged(EventHandler`1<EnergySaverStatusChangedEventArgs> value);
    public static void remove_EnergySaverStatusChanged(EventHandler`1<EnergySaverStatusChangedEventArgs> value);
    private static void SetCurrent();
    private static void OnBatteryInfoChanged(double level, BatteryState state, BatteryPowerSource source);
    private static void OnBatteryInfoChanged();
    private static void OnBatteryInfoChanged(BatteryInfoChangedEventArgs e);
    private static void OnEnergySaverChanged();
    private static void OnEnergySaverChanged(EnergySaverStatus saverStatus);
    private static void OnEnergySaverChanged(EnergySaverStatusChangedEventArgs e);
    private static void StartEnergySaverListeners();
    private static void StopEnergySaverListeners();
    private static void PowerChangedNotification(NSNotification notification);
    private static EnergySaverStatus get_PlatformEnergySaverStatus();
    private static void StartBatteryListeners();
    private static void StopBatteryListeners();
    private static void BatteryInfoChangedNotification(object sender, NSNotificationEventArgs args);
    private static double get_PlatformChargeLevel();
    private static BatteryState get_PlatformState();
    private static BatteryPowerSource get_PlatformPowerSource();
}
public class Xamarin.Essentials.BatteryInfoChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private double <ChargeLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private BatteryState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private BatteryPowerSource <PowerSource>k__BackingField;
    public double ChargeLevel { get; }
    public BatteryState State { get; }
    public BatteryPowerSource PowerSource { get; }
    public BatteryInfoChangedEventArgs(double level, BatteryState state, BatteryPowerSource source);
    [CompilerGeneratedAttribute]
public double get_ChargeLevel();
    [CompilerGeneratedAttribute]
public BatteryState get_State();
    [CompilerGeneratedAttribute]
public BatteryPowerSource get_PowerSource();
    public virtual string ToString();
}
public enum Xamarin.Essentials.BatteryPowerSource : Enum {
    public int value__;
    public static BatteryPowerSource Unknown;
    public static BatteryPowerSource Battery;
    public static BatteryPowerSource AC;
    public static BatteryPowerSource Usb;
    public static BatteryPowerSource Wireless;
}
public enum Xamarin.Essentials.BatteryState : Enum {
    public int value__;
    public static BatteryState Unknown;
    public static BatteryState Charging;
    public static BatteryState Discharging;
    public static BatteryState Full;
    public static BatteryState NotCharging;
    public static BatteryState NotPresent;
}
public static class Xamarin.Essentials.Browser : object {
    public static Task OpenAsync(string uri);
    public static Task OpenAsync(string uri, BrowserLaunchMode launchMode);
    public static Task OpenAsync(string uri, BrowserLaunchOptions options);
    public static Task OpenAsync(Uri uri);
    public static Task OpenAsync(Uri uri, BrowserLaunchMode launchMode);
    public static Task`1<bool> OpenAsync(Uri uri, BrowserLaunchOptions options);
    internal static Uri EscapeUri(Uri uri);
    private static Task`1<bool> PlatformOpenAsync(Uri uri, BrowserLaunchOptions options);
}
[FlagsAttribute]
public enum Xamarin.Essentials.BrowserLaunchFlags : Enum {
    public int value__;
    public static BrowserLaunchFlags None;
    public static BrowserLaunchFlags LaunchAdjacent;
    public static BrowserLaunchFlags PresentAsPageSheet;
    public static BrowserLaunchFlags PresentAsFormSheet;
}
public enum Xamarin.Essentials.BrowserLaunchMode : Enum {
    public int value__;
    public static BrowserLaunchMode SystemPreferred;
    public static BrowserLaunchMode External;
}
public class Xamarin.Essentials.BrowserLaunchOptions : object {
    [CompilerGeneratedAttribute]
private Nullable`1<Color> <PreferredToolbarColor>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Color> <PreferredControlColor>k__BackingField;
    [CompilerGeneratedAttribute]
private BrowserLaunchMode <LaunchMode>k__BackingField;
    [CompilerGeneratedAttribute]
private BrowserTitleMode <TitleMode>k__BackingField;
    [CompilerGeneratedAttribute]
private BrowserLaunchFlags <Flags>k__BackingField;
    public Nullable`1<Color> PreferredToolbarColor { get; public set; }
    public Nullable`1<Color> PreferredControlColor { get; public set; }
    public BrowserLaunchMode LaunchMode { get; public set; }
    public BrowserTitleMode TitleMode { get; public set; }
    public BrowserLaunchFlags Flags { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<Color> get_PreferredToolbarColor();
    [CompilerGeneratedAttribute]
public void set_PreferredToolbarColor(Nullable`1<Color> value);
    [CompilerGeneratedAttribute]
public Nullable`1<Color> get_PreferredControlColor();
    [CompilerGeneratedAttribute]
public void set_PreferredControlColor(Nullable`1<Color> value);
    [CompilerGeneratedAttribute]
public BrowserLaunchMode get_LaunchMode();
    [CompilerGeneratedAttribute]
public void set_LaunchMode(BrowserLaunchMode value);
    [CompilerGeneratedAttribute]
public BrowserTitleMode get_TitleMode();
    [CompilerGeneratedAttribute]
public void set_TitleMode(BrowserTitleMode value);
    [CompilerGeneratedAttribute]
public BrowserLaunchFlags get_Flags();
    [CompilerGeneratedAttribute]
public void set_Flags(BrowserLaunchFlags value);
    internal bool HasFlag(BrowserLaunchFlags flag);
}
public enum Xamarin.Essentials.BrowserTitleMode : Enum {
    public int value__;
    public static BrowserTitleMode Default;
    public static BrowserTitleMode Show;
    public static BrowserTitleMode Hide;
}
public static class Xamarin.Essentials.Clipboard : object {
    [CompilerGeneratedAttribute]
private static EventHandler`1<EventArgs> ClipboardContentChangedInternal;
    public static bool HasText { get; }
    private static bool PlatformHasText { get; }
    public static Task SetTextAsync(string text);
    public static bool get_HasText();
    public static Task`1<string> GetTextAsync();
    public static void add_ClipboardContentChanged(EventHandler`1<EventArgs> value);
    public static void remove_ClipboardContentChanged(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
private static void add_ClipboardContentChangedInternal(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
private static void remove_ClipboardContentChangedInternal(EventHandler`1<EventArgs> value);
    internal static void ClipboardChangedInternal();
    private static Task PlatformSetTextAsync(string text);
    private static bool get_PlatformHasText();
    private static Task`1<string> PlatformGetTextAsync();
    private static void StartClipboardListeners();
    private static void StopClipboardListeners();
}
public static class Xamarin.Essentials.ColorConverters : object {
    public static Color FromHsl(float hue, float saturation, float luminosity);
    public static Color FromHsla(float hue, float saturation, float luminosity, int alpha);
    public static Color FromHex(string hex);
    public static Color FromUInt(UInt32 argb);
    internal static void ConvertToRgb(float hue, float saturation, float luminosity, Int32& r, Int32& g, Int32& b);
    internal static void ConvertToHsl(float r, float g, float b, Single& h, Single& s, Single& l);
    internal static UInt32 ToHexD(char c);
    internal static UInt32 ToHex(char c);
}
[ExtensionAttribute]
public static class Xamarin.Essentials.ColorExtensions : object {
    [ExtensionAttribute]
public static Color MultiplyAlpha(Color color, float percentage);
    [ExtensionAttribute]
public static Color AddLuminosity(Color color, float delta);
    [ExtensionAttribute]
public static Color WithHue(Color color, float hue);
    [ExtensionAttribute]
public static Color WithSaturation(Color color, float saturation);
    [ExtensionAttribute]
public static Color WithAlpha(Color color, int alpha);
    [ExtensionAttribute]
public static Color WithLuminosity(Color color, float luminosity);
    [ExtensionAttribute]
public static UInt32 ToUInt(Color color);
    [ExtensionAttribute]
public static int ToInt(Color color);
    [ExtensionAttribute]
public static Color GetComplementary(Color color);
    [ExtensionAttribute]
public static ValueTuple`3<double, double, double> ToHsv(Color color);
    public static Color FromHsva(double h, double s, double v, double a);
    [ExtensionAttribute]
internal static double Clamp(double self, double min, double max);
    [ExtensionAttribute]
internal static int Clamp(int self, int min, int max);
    [ExtensionAttribute]
public static Color ToSystemColor(UIColor color);
    [ExtensionAttribute]
public static UIColor ToPlatformColor(Color color);
    [CompilerGeneratedAttribute]
internal static Color <FromHsva>g__ToRgba|10_0(double r, double g, double b, double a);
}
public static class Xamarin.Essentials.Compass : object {
    private static bool useSyncContext;
    [CompilerGeneratedAttribute]
private static EventHandler`1<CompassChangedEventArgs> ReadingChanged;
    [CompilerGeneratedAttribute]
private static bool <IsMonitoring>k__BackingField;
    public static bool IsMonitoring { get; private set; }
    internal static bool IsSupported { get; }
    [CompilerGeneratedAttribute]
public static void add_ReadingChanged(EventHandler`1<CompassChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_ReadingChanged(EventHandler`1<CompassChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public static bool get_IsMonitoring();
    [CompilerGeneratedAttribute]
private static void set_IsMonitoring(bool value);
    public static void Start(SensorSpeed sensorSpeed);
    public static void Start(SensorSpeed sensorSpeed, bool applyLowPassFilter);
    public static void Stop();
    internal static void OnChanged(CompassData reading);
    internal static void OnChanged(CompassChangedEventArgs e);
    internal static bool get_IsSupported();
    internal static void PlatformStart(SensorSpeed sensorSpeed, bool applyLowPassFilter);
    internal static void PlatformStop();
}
public class Xamarin.Essentials.CompassChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private CompassData <Reading>k__BackingField;
    public CompassData Reading { get; }
    public CompassChangedEventArgs(CompassData reading);
    [CompilerGeneratedAttribute]
public CompassData get_Reading();
}
[IsReadOnlyAttribute]
public class Xamarin.Essentials.CompassData : ValueType {
    [CompilerGeneratedAttribute]
private double <HeadingMagneticNorth>k__BackingField;
    public double HeadingMagneticNorth { get; }
    public CompassData(double headingMagneticNorth);
    [CompilerGeneratedAttribute]
public double get_HeadingMagneticNorth();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CompassData other);
    public static bool op_Equality(CompassData left, CompassData right);
    public static bool op_Inequality(CompassData left, CompassData right);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum Xamarin.Essentials.ConnectionProfile : Enum {
    public int value__;
    public static ConnectionProfile Unknown;
    public static ConnectionProfile Bluetooth;
    public static ConnectionProfile Cellular;
    public static ConnectionProfile Ethernet;
    public static ConnectionProfile WiFi;
}
public static class Xamarin.Essentials.Connectivity : object {
    [CompilerGeneratedAttribute]
private static EventHandler`1<ConnectivityChangedEventArgs> ConnectivityChangedInternal;
    private static NetworkAccess currentAccess;
    private static List`1<ConnectionProfile> currentProfiles;
    public static NetworkAccess NetworkAccess { get; }
    public static IEnumerable`1<ConnectionProfile> ConnectionProfiles { get; }
    private static NetworkAccess PlatformNetworkAccess { get; }
    private static IEnumerable`1<ConnectionProfile> PlatformConnectionProfiles { get; }
    [CompilerGeneratedAttribute]
private static void add_ConnectivityChangedInternal(EventHandler`1<ConnectivityChangedEventArgs> value);
    [CompilerGeneratedAttribute]
private static void remove_ConnectivityChangedInternal(EventHandler`1<ConnectivityChangedEventArgs> value);
    public static NetworkAccess get_NetworkAccess();
    public static IEnumerable`1<ConnectionProfile> get_ConnectionProfiles();
    public static void add_ConnectivityChanged(EventHandler`1<ConnectivityChangedEventArgs> value);
    public static void remove_ConnectivityChanged(EventHandler`1<ConnectivityChangedEventArgs> value);
    private static void SetCurrent();
    private static void OnConnectivityChanged(NetworkAccess access, IEnumerable`1<ConnectionProfile> profiles);
    private static void OnConnectivityChanged();
    private static void OnConnectivityChanged(ConnectivityChangedEventArgs e);
    private static NetworkAccess get_PlatformNetworkAccess();
    private static IEnumerable`1<ConnectionProfile> get_PlatformConnectionProfiles();
    private static void StartListeners();
    private static void StopListeners();
}
public class Xamarin.Essentials.ConnectivityChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private NetworkAccess <NetworkAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ConnectionProfile> <ConnectionProfiles>k__BackingField;
    public NetworkAccess NetworkAccess { get; }
    public IEnumerable`1<ConnectionProfile> ConnectionProfiles { get; }
    public ConnectivityChangedEventArgs(NetworkAccess access, IEnumerable`1<ConnectionProfile> connectionProfiles);
    [CompilerGeneratedAttribute]
public NetworkAccess get_NetworkAccess();
    [CompilerGeneratedAttribute]
public IEnumerable`1<ConnectionProfile> get_ConnectionProfiles();
    public virtual string ToString();
}
public class Xamarin.Essentials.Contact : object {
    private string displayName;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NamePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GivenName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MiddleName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FamilyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NameSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ContactPhone> <Phones>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ContactEmail> <Emails>k__BackingField;
    public string Id { get; public set; }
    public string DisplayName { get; private set; }
    public string NamePrefix { get; public set; }
    public string GivenName { get; public set; }
    public string MiddleName { get; public set; }
    public string FamilyName { get; public set; }
    public string NameSuffix { get; public set; }
    public List`1<ContactPhone> Phones { get; public set; }
    public List`1<ContactEmail> Emails { get; public set; }
    public Contact(string id, string namePrefix, string givenName, string middleName, string familyName, string nameSuffix, IEnumerable`1<ContactPhone> phones, IEnumerable`1<ContactEmail> email, string displayName);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    public string get_DisplayName();
    private void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_NamePrefix();
    [CompilerGeneratedAttribute]
public void set_NamePrefix(string value);
    [CompilerGeneratedAttribute]
public string get_GivenName();
    [CompilerGeneratedAttribute]
public void set_GivenName(string value);
    [CompilerGeneratedAttribute]
public string get_MiddleName();
    [CompilerGeneratedAttribute]
public void set_MiddleName(string value);
    [CompilerGeneratedAttribute]
public string get_FamilyName();
    [CompilerGeneratedAttribute]
public void set_FamilyName(string value);
    [CompilerGeneratedAttribute]
public string get_NameSuffix();
    [CompilerGeneratedAttribute]
public void set_NameSuffix(string value);
    [CompilerGeneratedAttribute]
public List`1<ContactPhone> get_Phones();
    [CompilerGeneratedAttribute]
public void set_Phones(List`1<ContactPhone> value);
    [CompilerGeneratedAttribute]
public List`1<ContactEmail> get_Emails();
    [CompilerGeneratedAttribute]
public void set_Emails(List`1<ContactEmail> value);
    public virtual string ToString();
    private string BuildDisplayName();
}
public class Xamarin.Essentials.ContactEmail : object {
    [CompilerGeneratedAttribute]
private string <EmailAddress>k__BackingField;
    public string EmailAddress { get; public set; }
    public ContactEmail(string emailAddress);
    [CompilerGeneratedAttribute]
public string get_EmailAddress();
    [CompilerGeneratedAttribute]
public void set_EmailAddress(string value);
    public virtual string ToString();
}
public class Xamarin.Essentials.ContactPhone : object {
    [CompilerGeneratedAttribute]
private string <PhoneNumber>k__BackingField;
    public string PhoneNumber { get; public set; }
    public ContactPhone(string phoneNumber);
    [CompilerGeneratedAttribute]
public string get_PhoneNumber();
    [CompilerGeneratedAttribute]
public void set_PhoneNumber(string value);
    public virtual string ToString();
}
public static class Xamarin.Essentials.Contacts : object {
    [AsyncStateMachineAttribute("Xamarin.Essentials.Contacts/<PickContactAsync>d__0")]
public static Task`1<Contact> PickContactAsync();
    public static Task`1<IEnumerable`1<Contact>> GetAllAsync(CancellationToken cancellationToken);
    private static Task`1<Contact> PlatformPickContactAsync();
    private static Task`1<IEnumerable`1<Contact>> PlatformGetAllAsync(CancellationToken cancellationToken);
}
public static class Xamarin.Essentials.DeviceDisplay : object {
    [CompilerGeneratedAttribute]
private static EventHandler`1<DisplayInfoChangedEventArgs> MainDisplayInfoChangedInternal;
    private static DisplayInfo currentMetrics;
    public static bool KeepScreenOn { get; public set; }
    public static DisplayInfo MainDisplayInfo { get; }
    private static bool PlatformKeepScreenOn { get; private set; }
    [CompilerGeneratedAttribute]
private static void add_MainDisplayInfoChangedInternal(EventHandler`1<DisplayInfoChangedEventArgs> value);
    [CompilerGeneratedAttribute]
private static void remove_MainDisplayInfoChangedInternal(EventHandler`1<DisplayInfoChangedEventArgs> value);
    public static bool get_KeepScreenOn();
    public static void set_KeepScreenOn(bool value);
    public static DisplayInfo get_MainDisplayInfo();
    private static void SetCurrent(DisplayInfo metrics);
    public static void add_MainDisplayInfoChanged(EventHandler`1<DisplayInfoChangedEventArgs> value);
    public static void remove_MainDisplayInfoChanged(EventHandler`1<DisplayInfoChangedEventArgs> value);
    private static void OnMainDisplayInfoChanged(DisplayInfo metrics);
    private static void OnMainDisplayInfoChanged(DisplayInfoChangedEventArgs e);
    private static bool get_PlatformKeepScreenOn();
    private static void set_PlatformKeepScreenOn(bool value);
    private static DisplayInfo GetMainDisplayInfo();
    private static void StartScreenMetricsListeners();
    private static void StopScreenMetricsListeners();
}
[IsReadOnlyAttribute]
public class Xamarin.Essentials.DeviceIdiom : ValueType {
    private string deviceIdiom;
    [CompilerGeneratedAttribute]
private static DeviceIdiom <Phone>k__BackingField;
    [CompilerGeneratedAttribute]
private static DeviceIdiom <Tablet>k__BackingField;
    [CompilerGeneratedAttribute]
private static DeviceIdiom <Desktop>k__BackingField;
    [CompilerGeneratedAttribute]
private static DeviceIdiom <TV>k__BackingField;
    [CompilerGeneratedAttribute]
private static DeviceIdiom <Watch>k__BackingField;
    [CompilerGeneratedAttribute]
private static DeviceIdiom <Unknown>k__BackingField;
    public static DeviceIdiom Phone { get; }
    public static DeviceIdiom Tablet { get; }
    public static DeviceIdiom Desktop { get; }
    public static DeviceIdiom TV { get; }
    public static DeviceIdiom Watch { get; }
    public static DeviceIdiom Unknown { get; }
    private DeviceIdiom(string deviceIdiom);
    private static DeviceIdiom();
    [CompilerGeneratedAttribute]
public static DeviceIdiom get_Phone();
    [CompilerGeneratedAttribute]
public static DeviceIdiom get_Tablet();
    [CompilerGeneratedAttribute]
public static DeviceIdiom get_Desktop();
    [CompilerGeneratedAttribute]
public static DeviceIdiom get_TV();
    [CompilerGeneratedAttribute]
public static DeviceIdiom get_Watch();
    [CompilerGeneratedAttribute]
public static DeviceIdiom get_Unknown();
    public static DeviceIdiom Create(string deviceIdiom);
    public sealed virtual bool Equals(DeviceIdiom other);
    internal bool Equals(string other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(DeviceIdiom left, DeviceIdiom right);
    public static bool op_Inequality(DeviceIdiom left, DeviceIdiom right);
}
public static class Xamarin.Essentials.DeviceInfo : object {
    public static string Model { get; }
    public static string Manufacturer { get; }
    public static string Name { get; }
    public static string VersionString { get; }
    public static Version Version { get; }
    public static DevicePlatform Platform { get; }
    public static DeviceIdiom Idiom { get; }
    public static DeviceType DeviceType { get; }
    public static string get_Model();
    public static string get_Manufacturer();
    public static string get_Name();
    public static string get_VersionString();
    public static Version get_Version();
    public static DevicePlatform get_Platform();
    public static DeviceIdiom get_Idiom();
    public static DeviceType get_DeviceType();
    private static string GetModel();
    private static string GetManufacturer();
    private static string GetDeviceName();
    private static string GetVersionString();
    private static DevicePlatform GetPlatform();
    private static DeviceIdiom GetIdiom();
    private static DeviceType GetDeviceType();
}
[IsReadOnlyAttribute]
public class Xamarin.Essentials.DevicePlatform : ValueType {
    private string devicePlatform;
    [CompilerGeneratedAttribute]
private static DevicePlatform <Android>k__BackingField;
    [CompilerGeneratedAttribute]
private static DevicePlatform <iOS>k__BackingField;
    [CompilerGeneratedAttribute]
private static DevicePlatform <macOS>k__BackingField;
    [CompilerGeneratedAttribute]
private static DevicePlatform <tvOS>k__BackingField;
    [CompilerGeneratedAttribute]
private static DevicePlatform <Tizen>k__BackingField;
    [CompilerGeneratedAttribute]
private static DevicePlatform <UWP>k__BackingField;
    [CompilerGeneratedAttribute]
private static DevicePlatform <watchOS>k__BackingField;
    [CompilerGeneratedAttribute]
private static DevicePlatform <Unknown>k__BackingField;
    public static DevicePlatform Android { get; }
    public static DevicePlatform iOS { get; }
    public static DevicePlatform macOS { get; }
    public static DevicePlatform tvOS { get; }
    public static DevicePlatform Tizen { get; }
    public static DevicePlatform UWP { get; }
    public static DevicePlatform watchOS { get; }
    public static DevicePlatform Unknown { get; }
    private DevicePlatform(string devicePlatform);
    private static DevicePlatform();
    [CompilerGeneratedAttribute]
public static DevicePlatform get_Android();
    [CompilerGeneratedAttribute]
public static DevicePlatform get_iOS();
    [CompilerGeneratedAttribute]
public static DevicePlatform get_macOS();
    [CompilerGeneratedAttribute]
public static DevicePlatform get_tvOS();
    [CompilerGeneratedAttribute]
public static DevicePlatform get_Tizen();
    [CompilerGeneratedAttribute]
public static DevicePlatform get_UWP();
    [CompilerGeneratedAttribute]
public static DevicePlatform get_watchOS();
    [CompilerGeneratedAttribute]
public static DevicePlatform get_Unknown();
    public static DevicePlatform Create(string devicePlatform);
    public sealed virtual bool Equals(DevicePlatform other);
    internal bool Equals(string other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(DevicePlatform left, DevicePlatform right);
    public static bool op_Inequality(DevicePlatform left, DevicePlatform right);
}
public enum Xamarin.Essentials.DeviceType : Enum {
    public int value__;
    public static DeviceType Unknown;
    public static DeviceType Physical;
    public static DeviceType Virtual;
}
[IsReadOnlyAttribute]
[PreserveAttribute]
public class Xamarin.Essentials.DisplayInfo : ValueType {
    [CompilerGeneratedAttribute]
private double <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Density>k__BackingField;
    [CompilerGeneratedAttribute]
private DisplayOrientation <Orientation>k__BackingField;
    [CompilerGeneratedAttribute]
private DisplayRotation <Rotation>k__BackingField;
    [CompilerGeneratedAttribute]
private float <RefreshRate>k__BackingField;
    public double Width { get; }
    public double Height { get; }
    public double Density { get; }
    public DisplayOrientation Orientation { get; }
    public DisplayRotation Rotation { get; }
    public float RefreshRate { get; }
    public DisplayInfo(double width, double height, double density, DisplayOrientation orientation, DisplayRotation rotation);
    public DisplayInfo(double width, double height, double density, DisplayOrientation orientation, DisplayRotation rotation, float rate);
    [CompilerGeneratedAttribute]
public double get_Width();
    [CompilerGeneratedAttribute]
public double get_Height();
    [CompilerGeneratedAttribute]
public double get_Density();
    [CompilerGeneratedAttribute]
public DisplayOrientation get_Orientation();
    [CompilerGeneratedAttribute]
public DisplayRotation get_Rotation();
    [CompilerGeneratedAttribute]
public float get_RefreshRate();
    public static bool op_Equality(DisplayInfo left, DisplayInfo right);
    public static bool op_Inequality(DisplayInfo left, DisplayInfo right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DisplayInfo other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Xamarin.Essentials.DisplayInfoChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private DisplayInfo <DisplayInfo>k__BackingField;
    public DisplayInfo DisplayInfo { get; }
    public DisplayInfoChangedEventArgs(DisplayInfo displayInfo);
    [CompilerGeneratedAttribute]
public DisplayInfo get_DisplayInfo();
}
public enum Xamarin.Essentials.DisplayOrientation : Enum {
    public int value__;
    public static DisplayOrientation Unknown;
    public static DisplayOrientation Portrait;
    public static DisplayOrientation Landscape;
}
public enum Xamarin.Essentials.DisplayRotation : Enum {
    public int value__;
    public static DisplayRotation Unknown;
    public static DisplayRotation Rotation0;
    public static DisplayRotation Rotation90;
    public static DisplayRotation Rotation180;
    public static DisplayRotation Rotation270;
}
public enum Xamarin.Essentials.DistanceUnits : Enum {
    public int value__;
    public static DistanceUnits Kilometers;
    public static DistanceUnits Miles;
}
public static class Xamarin.Essentials.Email : object {
    internal static bool IsComposeSupported { get; }
    public static Task ComposeAsync();
    public static Task ComposeAsync(string subject, string body, String[] to);
    public static Task ComposeAsync(EmailMessage message);
    private static string GetMailToUri(EmailMessage message);
    internal static bool get_IsComposeSupported();
    private static Task PlatformComposeAsync(EmailMessage message);
}
public class Xamarin.Essentials.EmailAttachment : FileBase {
    public EmailAttachment(string fullPath);
    public EmailAttachment(string fullPath, string contentType);
    public EmailAttachment(FileBase file);
}
public enum Xamarin.Essentials.EmailBodyFormat : Enum {
    public int value__;
    public static EmailBodyFormat PlainText;
    public static EmailBodyFormat Html;
}
public class Xamarin.Essentials.EmailMessage : object {
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private EmailBodyFormat <BodyFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <To>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Cc>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Bcc>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<EmailAttachment> <Attachments>k__BackingField;
    public string Subject { get; public set; }
    public string Body { get; public set; }
    public EmailBodyFormat BodyFormat { get; public set; }
    public List`1<string> To { get; public set; }
    public List`1<string> Cc { get; public set; }
    public List`1<string> Bcc { get; public set; }
    public List`1<EmailAttachment> Attachments { get; public set; }
    public EmailMessage(string subject, string body, String[] to);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(string value);
    [CompilerGeneratedAttribute]
public string get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(string value);
    [CompilerGeneratedAttribute]
public EmailBodyFormat get_BodyFormat();
    [CompilerGeneratedAttribute]
public void set_BodyFormat(EmailBodyFormat value);
    [CompilerGeneratedAttribute]
public List`1<string> get_To();
    [CompilerGeneratedAttribute]
public void set_To(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Cc();
    [CompilerGeneratedAttribute]
public void set_Cc(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Bcc();
    [CompilerGeneratedAttribute]
public void set_Bcc(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<EmailAttachment> get_Attachments();
    [CompilerGeneratedAttribute]
public void set_Attachments(List`1<EmailAttachment> value);
}
public enum Xamarin.Essentials.EnergySaverStatus : Enum {
    public int value__;
    public static EnergySaverStatus Unknown;
    public static EnergySaverStatus On;
    public static EnergySaverStatus Off;
}
public class Xamarin.Essentials.EnergySaverStatusChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EnergySaverStatus <EnergySaverStatus>k__BackingField;
    public EnergySaverStatus EnergySaverStatus { get; }
    public EnergySaverStatusChangedEventArgs(EnergySaverStatus saverStatus);
    [CompilerGeneratedAttribute]
public EnergySaverStatus get_EnergySaverStatus();
    public virtual string ToString();
}
internal static class Xamarin.Essentials.ExceptionUtils : object {
    internal static FeatureNotSupportedException NotSupportedOrImplementedException { get; }
    internal static FeatureNotSupportedException get_NotSupportedOrImplementedException();
}
public static class Xamarin.Essentials.ExperimentalFeatures : object {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ExperimentalFeatures.ShareFileRequest is obsolete as of version 1.3.0 and no longer required to use the feature.")]
public static string ShareFileRequest;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ExperimentalFeatures.OpenFileRequest is obsolete as of version 1.3.0 and no longer required to use the feature.")]
public static string OpenFileRequest;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("ExperimentalFeatures.EmailAttachments is obsolete as of version 1.3.0 and no longer required to use the feature.")]
public static string EmailAttachments;
    public static string MediaPicker;
    private static HashSet`1<string> enabledFeatures;
    public static void Enable(String[] featureNames);
    [EditorBrowsableAttribute("1")]
internal static void VerifyEnabled(string featureName, string memberName);
}
public class Xamarin.Essentials.FeatureNotEnabledException : InvalidOperationException {
    public FeatureNotEnabledException(string message);
    public FeatureNotEnabledException(string message, Exception innerException);
}
public class Xamarin.Essentials.FeatureNotSupportedException : NotSupportedException {
    public FeatureNotSupportedException(string message);
    public FeatureNotSupportedException(string message, Exception innerException);
}
public abstract class Xamarin.Essentials.FileBase : object {
    internal static string DefaultContentType;
    private string contentType;
    [CompilerGeneratedAttribute]
private string <FullPath>k__BackingField;
    private string fileName;
    public string FullPath { get; internal set; }
    public string ContentType { get; public set; }
    public string FileName { get; public set; }
    internal FileBase(string fullPath);
    public FileBase(FileBase file);
    internal FileBase(string fullPath, string contentType);
    internal FileBase(NSUrl file);
    [CompilerGeneratedAttribute]
public string get_FullPath();
    [CompilerGeneratedAttribute]
internal void set_FullPath(string value);
    public string get_ContentType();
    public void set_ContentType(string value);
    internal string GetContentType();
    public string get_FileName();
    public void set_FileName(string value);
    internal string GetFileName();
    public Task`1<Stream> OpenReadAsync();
    internal static string PlatformGetContentType(string extension);
    internal void PlatformInit(FileBase file);
    internal virtual Task`1<Stream> PlatformOpenReadAsync();
}
public static class Xamarin.Essentials.FilePicker : object {
    [AsyncStateMachineAttribute("Xamarin.Essentials.FilePicker/<PickAsync>d__0")]
public static Task`1<FileResult> PickAsync(PickOptions options);
    public static Task`1<IEnumerable`1<FileResult>> PickMultipleAsync(PickOptions options);
    private static Task`1<IEnumerable`1<FileResult>> PlatformPickAsync(PickOptions options, bool allowMultiple);
}
public class Xamarin.Essentials.FilePickerFileType : object {
    public static FilePickerFileType Images;
    public static FilePickerFileType Png;
    public static FilePickerFileType Jpeg;
    public static FilePickerFileType Videos;
    public static FilePickerFileType Pdf;
    private IDictionary`2<DevicePlatform, IEnumerable`1<string>> fileTypes;
    public IEnumerable`1<string> Value { get; }
    public FilePickerFileType(IDictionary`2<DevicePlatform, IEnumerable`1<string>> fileTypes);
    private static FilePickerFileType();
    public IEnumerable`1<string> get_Value();
    protected virtual IEnumerable`1<string> GetPlatformFileType(DevicePlatform platform);
    private static FilePickerFileType PlatformImageFileType();
    private static FilePickerFileType PlatformPngFileType();
    private static FilePickerFileType PlatformJpegFileType();
    private static FilePickerFileType PlatformVideoFileType();
    private static FilePickerFileType PlatformPdfFileType();
}
public class Xamarin.Essentials.FileResult : FileBase {
    public FileResult(string fullPath);
    public FileResult(string fullPath, string contentType);
    public FileResult(FileBase file);
}
public static class Xamarin.Essentials.FileSystem : object {
    public static string CacheDirectory { get; }
    public static string AppDataDirectory { get; }
    private static string PlatformCacheDirectory { get; }
    private static string PlatformAppDataDirectory { get; }
    public static string get_CacheDirectory();
    public static string get_AppDataDirectory();
    public static Task`1<Stream> OpenAppPackageFileAsync(string filename);
    private static string get_PlatformCacheDirectory();
    private static string get_PlatformAppDataDirectory();
    private static Task`1<Stream> PlatformOpenAppPackageFileAsync(string filename);
    private static string GetDirectory(NSSearchPathDirectory directory);
}
public static class Xamarin.Essentials.Flashlight : object {
    public static Task TurnOnAsync();
    public static Task TurnOffAsync();
    private static Task PlatformTurnOnAsync();
    private static Task PlatformTurnOffAsync();
}
public static class Xamarin.Essentials.Geocoding : object {
    public static Task`1<IEnumerable`1<Placemark>> GetPlacemarksAsync(Location location);
    public static Task`1<IEnumerable`1<Placemark>> GetPlacemarksAsync(double latitude, double longitude);
    public static Task`1<IEnumerable`1<Location>> GetLocationsAsync(string address);
    [AsyncStateMachineAttribute("Xamarin.Essentials.Geocoding/<PlatformGetPlacemarksAsync>d__3")]
private static Task`1<IEnumerable`1<Placemark>> PlatformGetPlacemarksAsync(double latitude, double longitude);
    [AsyncStateMachineAttribute("Xamarin.Essentials.Geocoding/<PlatformGetLocationsAsync>d__4")]
private static Task`1<IEnumerable`1<Location>> PlatformGetLocationsAsync(string address);
}
public static class Xamarin.Essentials.Geolocation : object {
    public static Task`1<Location> GetLastKnownLocationAsync();
    public static Task`1<Location> GetLocationAsync();
    public static Task`1<Location> GetLocationAsync(GeolocationRequest request);
    public static Task`1<Location> GetLocationAsync(GeolocationRequest request, CancellationToken cancelToken);
    private static Task`1<Location> PlatformLastKnownLocationAsync();
    private static Task`1<Location> PlatformLocationAsync(GeolocationRequest request, CancellationToken cancellationToken);
}
public enum Xamarin.Essentials.GeolocationAccuracy : Enum {
    public int value__;
    public static GeolocationAccuracy Default;
    public static GeolocationAccuracy Lowest;
    public static GeolocationAccuracy Low;
    public static GeolocationAccuracy Medium;
    public static GeolocationAccuracy High;
    public static GeolocationAccuracy Best;
}
public class Xamarin.Essentials.GeolocationRequest : object {
    [CompilerGeneratedAttribute]
private TimeSpan <Timeout>k__BackingField;
    [CompilerGeneratedAttribute]
private GeolocationAccuracy <DesiredAccuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequestFullAccuracy>k__BackingField;
    public TimeSpan Timeout { get; public set; }
    public GeolocationAccuracy DesiredAccuracy { get; public set; }
    public bool RequestFullAccuracy { get; public set; }
    public GeolocationRequest(GeolocationAccuracy accuracy);
    public GeolocationRequest(GeolocationAccuracy accuracy, TimeSpan timeout);
    [CompilerGeneratedAttribute]
public TimeSpan get_Timeout();
    [CompilerGeneratedAttribute]
public void set_Timeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public GeolocationAccuracy get_DesiredAccuracy();
    [CompilerGeneratedAttribute]
public void set_DesiredAccuracy(GeolocationAccuracy value);
    [CompilerGeneratedAttribute]
public bool get_RequestFullAccuracy();
    [CompilerGeneratedAttribute]
public void set_RequestFullAccuracy(bool value);
    public virtual string ToString();
}
public static class Xamarin.Essentials.Gyroscope : object {
    private static bool useSyncContext;
    [CompilerGeneratedAttribute]
private static EventHandler`1<GyroscopeChangedEventArgs> ReadingChanged;
    [CompilerGeneratedAttribute]
private static bool <IsMonitoring>k__BackingField;
    public static bool IsMonitoring { get; private set; }
    internal static bool IsSupported { get; }
    [CompilerGeneratedAttribute]
public static void add_ReadingChanged(EventHandler`1<GyroscopeChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_ReadingChanged(EventHandler`1<GyroscopeChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public static bool get_IsMonitoring();
    [CompilerGeneratedAttribute]
private static void set_IsMonitoring(bool value);
    public static void Start(SensorSpeed sensorSpeed);
    public static void Stop();
    internal static void OnChanged(GyroscopeData reading);
    internal static void OnChanged(GyroscopeChangedEventArgs e);
    internal static bool get_IsSupported();
    internal static void PlatformStart(SensorSpeed sensorSpeed);
    private static void DataUpdated(CMGyroData data, NSError error);
    internal static void PlatformStop();
}
public class Xamarin.Essentials.GyroscopeChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private GyroscopeData <Reading>k__BackingField;
    public GyroscopeData Reading { get; }
    public GyroscopeChangedEventArgs(GyroscopeData reading);
    [CompilerGeneratedAttribute]
public GyroscopeData get_Reading();
}
[IsReadOnlyAttribute]
public class Xamarin.Essentials.GyroscopeData : ValueType {
    [CompilerGeneratedAttribute]
private Vector3 <AngularVelocity>k__BackingField;
    public Vector3 AngularVelocity { get; }
    public GyroscopeData(double x, double y, double z);
    public GyroscopeData(float x, float y, float z);
    [CompilerGeneratedAttribute]
public Vector3 get_AngularVelocity();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(GyroscopeData other);
    public static bool op_Equality(GyroscopeData left, GyroscopeData right);
    public static bool op_Inequality(GyroscopeData left, GyroscopeData right);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class Xamarin.Essentials.HapticFeedback : object {
    internal static bool IsSupported { get; }
    public static void Perform(HapticFeedbackType type);
    internal static bool get_IsSupported();
    private static void PlatformPerform(HapticFeedbackType type);
}
public enum Xamarin.Essentials.HapticFeedbackType : Enum {
    public int value__;
    public static HapticFeedbackType Click;
    public static HapticFeedbackType LongPress;
}
internal class Xamarin.Essentials.KeyChain : object {
    private SecAccessible accessible;
    internal KeyChain(SecAccessible accessible);
    private SecRecord ExistingRecordForKey(string key, string service);
    internal string ValueForKey(string key, string service);
    internal void SetValueForKey(string value, string key, string service);
    internal bool Remove(string key, string service);
    internal void RemoveAll(string service);
    private SecRecord CreateRecordForNewKeyValue(string key, string value, string service);
    private bool RemoveRecord(SecRecord record);
}
public static class Xamarin.Essentials.Launcher : object {
    public static Task`1<bool> CanOpenAsync(string uri);
    public static Task`1<bool> CanOpenAsync(Uri uri);
    public static Task OpenAsync(string uri);
    public static Task OpenAsync(Uri uri);
    public static Task OpenAsync(OpenFileRequest request);
    public static Task`1<bool> TryOpenAsync(string uri);
    public static Task`1<bool> TryOpenAsync(Uri uri);
    private static Task`1<bool> PlatformCanOpenAsync(Uri uri);
    private static Task PlatformOpenAsync(Uri uri);
    private static Task PlatformOpenAsync(OpenFileRequest request);
    private static Task`1<bool> PlatformTryOpenAsync(Uri uri);
}
public class Xamarin.Essentials.Locale : object {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Country>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string Language { get; }
    public string Country { get; }
    public string Name { get; }
    public string Id { get; }
    internal Locale(string language, string country, string name, string id);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public string get_Country();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Id();
}
public class Xamarin.Essentials.Location : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Latitude>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Longitude>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Altitude>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Accuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <VerticalAccuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReducedAccuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Speed>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<double> <Course>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFromMockProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private AltitudeReferenceSystem <AltitudeReferenceSystem>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public double Latitude { get; public set; }
    public double Longitude { get; public set; }
    public Nullable`1<double> Altitude { get; public set; }
    public Nullable`1<double> Accuracy { get; public set; }
    public Nullable`1<double> VerticalAccuracy { get; public set; }
    public bool ReducedAccuracy { get; public set; }
    public Nullable`1<double> Speed { get; public set; }
    public Nullable`1<double> Course { get; public set; }
    public bool IsFromMockProvider { get; public set; }
    public AltitudeReferenceSystem AltitudeReferenceSystem { get; public set; }
    public Location(double latitude, double longitude);
    public Location(double latitude, double longitude, DateTimeOffset timestamp);
    public Location(double latitude, double longitude, double altitude);
    public Location(Location point);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public double get_Latitude();
    [CompilerGeneratedAttribute]
public void set_Latitude(double value);
    [CompilerGeneratedAttribute]
public double get_Longitude();
    [CompilerGeneratedAttribute]
public void set_Longitude(double value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Altitude();
    [CompilerGeneratedAttribute]
public void set_Altitude(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Accuracy();
    [CompilerGeneratedAttribute]
public void set_Accuracy(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_VerticalAccuracy();
    [CompilerGeneratedAttribute]
public void set_VerticalAccuracy(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public bool get_ReducedAccuracy();
    [CompilerGeneratedAttribute]
public void set_ReducedAccuracy(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Speed();
    [CompilerGeneratedAttribute]
public void set_Speed(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public Nullable`1<double> get_Course();
    [CompilerGeneratedAttribute]
public void set_Course(Nullable`1<double> value);
    [CompilerGeneratedAttribute]
public bool get_IsFromMockProvider();
    [CompilerGeneratedAttribute]
public void set_IsFromMockProvider(bool value);
    [CompilerGeneratedAttribute]
public AltitudeReferenceSystem get_AltitudeReferenceSystem();
    [CompilerGeneratedAttribute]
public void set_AltitudeReferenceSystem(AltitudeReferenceSystem value);
    public static double CalculateDistance(double latitudeStart, double longitudeStart, Location locationEnd, DistanceUnits units);
    public static double CalculateDistance(Location locationStart, double latitudeEnd, double longitudeEnd, DistanceUnits units);
    public static double CalculateDistance(Location locationStart, Location locationEnd, DistanceUnits units);
    public static double CalculateDistance(double latitudeStart, double longitudeStart, double latitudeEnd, double longitudeEnd, DistanceUnits units);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Xamarin.Essentials.LocationExtensions : object {
    [ExtensionAttribute]
public static double CalculateDistance(Location locationStart, double latitudeEnd, double longitudeEnd, DistanceUnits units);
    [ExtensionAttribute]
public static double CalculateDistance(Location locationStart, Location locationEnd, DistanceUnits units);
    [ExtensionAttribute]
public static Task OpenMapsAsync(Location location, MapLaunchOptions options);
    [ExtensionAttribute]
public static Task OpenMapsAsync(Location location);
    private static CLAuthorizationStatus CLAuthorizationStatus_objc_msgSend(IntPtr receiver, IntPtr selector);
    [ExtensionAttribute]
internal static Location ToLocation(CLPlacemark placemark);
    [ExtensionAttribute]
internal static IEnumerable`1<Location> ToLocations(IEnumerable`1<CLPlacemark> placemarks);
    [ExtensionAttribute]
internal static Location ToLocation(CLLocation location, bool reducedAccuracy);
    [ExtensionAttribute]
internal static DateTimeOffset ToDateTime(NSDate timestamp);
    [ExtensionAttribute]
internal static CLAuthorizationStatus GetAuthorizationStatus(CLLocationManager locationManager);
}
internal class Xamarin.Essentials.LowPassFilter : object {
    private static int length;
    private Queue`1<float> history;
    private float sin;
    private float cos;
    internal void Add(float radians);
    internal float Average();
}
public static class Xamarin.Essentials.Magnetometer : object {
    private static bool useSyncContext;
    [CompilerGeneratedAttribute]
private static EventHandler`1<MagnetometerChangedEventArgs> ReadingChanged;
    [CompilerGeneratedAttribute]
private static bool <IsMonitoring>k__BackingField;
    public static bool IsMonitoring { get; private set; }
    internal static bool IsSupported { get; }
    [CompilerGeneratedAttribute]
public static void add_ReadingChanged(EventHandler`1<MagnetometerChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_ReadingChanged(EventHandler`1<MagnetometerChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public static bool get_IsMonitoring();
    [CompilerGeneratedAttribute]
private static void set_IsMonitoring(bool value);
    public static void Start(SensorSpeed sensorSpeed);
    public static void Stop();
    internal static void OnChanged(MagnetometerData reading);
    internal static void OnChanged(MagnetometerChangedEventArgs e);
    internal static bool get_IsSupported();
    internal static void PlatformStart(SensorSpeed sensorSpeed);
    private static void DataUpdated(CMMagnetometerData data, NSError error);
    internal static void PlatformStop();
}
public class Xamarin.Essentials.MagnetometerChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private MagnetometerData <Reading>k__BackingField;
    public MagnetometerData Reading { get; }
    public MagnetometerChangedEventArgs(MagnetometerData reading);
    [CompilerGeneratedAttribute]
public MagnetometerData get_Reading();
}
[IsReadOnlyAttribute]
public class Xamarin.Essentials.MagnetometerData : ValueType {
    [CompilerGeneratedAttribute]
private Vector3 <MagneticField>k__BackingField;
    public Vector3 MagneticField { get; }
    public MagnetometerData(double x, double y, double z);
    public MagnetometerData(float x, float y, float z);
    [CompilerGeneratedAttribute]
public Vector3 get_MagneticField();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(MagnetometerData other);
    public static bool op_Equality(MagnetometerData left, MagnetometerData right);
    public static bool op_Inequality(MagnetometerData left, MagnetometerData right);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class Xamarin.Essentials.MainThread : object {
    public static bool IsMainThread { get; }
    private static bool PlatformIsMainThread { get; }
    public static bool get_IsMainThread();
    public static void BeginInvokeOnMainThread(Action action);
    public static Task InvokeOnMainThreadAsync(Action action);
    public static Task`1<T> InvokeOnMainThreadAsync(Func`1<T> func);
    public static Task InvokeOnMainThreadAsync(Func`1<Task> funcTask);
    public static Task`1<T> InvokeOnMainThreadAsync(Func`1<Task`1<T>> funcTask);
    [AsyncStateMachineAttribute("Xamarin.Essentials.MainThread/<GetMainThreadSynchronizationContextAsync>d__7")]
public static Task`1<SynchronizationContext> GetMainThreadSynchronizationContextAsync();
    private static bool get_PlatformIsMainThread();
    private static void PlatformBeginInvokeOnMainThread(Action action);
    internal static T InvokeOnMainThread(Func`1<T> factory);
}
public static class Xamarin.Essentials.Map : object {
    public static Task OpenAsync(Location location);
    public static Task OpenAsync(Location location, MapLaunchOptions options);
    public static Task OpenAsync(double latitude, double longitude);
    public static Task OpenAsync(double latitude, double longitude, MapLaunchOptions options);
    public static Task OpenAsync(Placemark placemark);
    public static Task OpenAsync(Placemark placemark, MapLaunchOptions options);
    internal static Task PlatformOpenMapsAsync(double latitude, double longitude, MapLaunchOptions options);
    [AsyncStateMachineAttribute("Xamarin.Essentials.Map/<PlatformOpenMapsAsync>d__7")]
internal static Task PlatformOpenMapsAsync(Placemark placemark, MapLaunchOptions options);
    [AsyncStateMachineAttribute("Xamarin.Essentials.Map/<GetPlacemarksAsync>d__8")]
private static Task`1<CLPlacemark[]> GetPlacemarksAsync(NSDictionary address);
    private static Task`1<bool> OpenPlacemark(MKPlacemark placemark, MapLaunchOptions options);
}
public class Xamarin.Essentials.MapLaunchOptions : object {
    [CompilerGeneratedAttribute]
private NavigationMode <NavigationMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public NavigationMode NavigationMode { get; public set; }
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public NavigationMode get_NavigationMode();
    [CompilerGeneratedAttribute]
public void set_NavigationMode(NavigationMode value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
public static class Xamarin.Essentials.MediaPicker : object {
    public static bool IsCaptureSupported { get; }
    private static bool PlatformIsCaptureSupported { get; }
    public static bool get_IsCaptureSupported();
    public static Task`1<FileResult> PickPhotoAsync(MediaPickerOptions options);
    public static Task`1<FileResult> CapturePhotoAsync(MediaPickerOptions options);
    public static Task`1<FileResult> PickVideoAsync(MediaPickerOptions options);
    public static Task`1<FileResult> CaptureVideoAsync(MediaPickerOptions options);
    private static bool get_PlatformIsCaptureSupported();
    private static Task`1<FileResult> PlatformPickPhotoAsync(MediaPickerOptions options);
    private static Task`1<FileResult> PlatformCapturePhotoAsync(MediaPickerOptions options);
    private static Task`1<FileResult> PlatformPickVideoAsync(MediaPickerOptions options);
    private static Task`1<FileResult> PlatformCaptureVideoAsync(MediaPickerOptions options);
}
public class Xamarin.Essentials.MediaPickerOptions : object {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
}
public enum Xamarin.Essentials.NavigationMode : Enum {
    public int value__;
    public static NavigationMode None;
    public static NavigationMode Default;
    public static NavigationMode Bicycling;
    public static NavigationMode Driving;
    public static NavigationMode Transit;
    public static NavigationMode Walking;
}
public enum Xamarin.Essentials.NetworkAccess : Enum {
    public int value__;
    public static NetworkAccess Unknown;
    public static NetworkAccess None;
    public static NetworkAccess Local;
    public static NetworkAccess ConstrainedInternet;
    public static NetworkAccess Internet;
}
public class Xamarin.Essentials.NotImplementedInReferenceAssemblyException : NotImplementedException {
}
public class Xamarin.Essentials.OpenFileRequest : object {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyFile <File>k__BackingField;
    [CompilerGeneratedAttribute]
private Rectangle <PresentationSourceBounds>k__BackingField;
    public string Title { get; public set; }
    public ReadOnlyFile File { get; public set; }
    public Rectangle PresentationSourceBounds { get; public set; }
    public OpenFileRequest(string title, ReadOnlyFile file);
    public OpenFileRequest(string title, FileBase file);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public ReadOnlyFile get_File();
    [CompilerGeneratedAttribute]
public void set_File(ReadOnlyFile value);
    [CompilerGeneratedAttribute]
public Rectangle get_PresentationSourceBounds();
    [CompilerGeneratedAttribute]
public void set_PresentationSourceBounds(Rectangle value);
}
public static class Xamarin.Essentials.OrientationSensor : object {
    private static bool useSyncContext;
    [CompilerGeneratedAttribute]
private static EventHandler`1<OrientationSensorChangedEventArgs> ReadingChanged;
    [CompilerGeneratedAttribute]
private static bool <IsMonitoring>k__BackingField;
    public static bool IsMonitoring { get; private set; }
    internal static bool IsSupported { get; }
    [CompilerGeneratedAttribute]
public static void add_ReadingChanged(EventHandler`1<OrientationSensorChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_ReadingChanged(EventHandler`1<OrientationSensorChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public static bool get_IsMonitoring();
    [CompilerGeneratedAttribute]
private static void set_IsMonitoring(bool value);
    public static void Start(SensorSpeed sensorSpeed);
    public static void Stop();
    internal static void OnChanged(OrientationSensorData reading);
    internal static void OnChanged(OrientationSensorChangedEventArgs e);
    internal static bool get_IsSupported();
    internal static void PlatformStart(SensorSpeed sensorSpeed);
    private static void DataUpdated(CMDeviceMotion data, NSError error);
    internal static void PlatformStop();
}
public class Xamarin.Essentials.OrientationSensorChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private OrientationSensorData <Reading>k__BackingField;
    public OrientationSensorData Reading { get; }
    public OrientationSensorChangedEventArgs(OrientationSensorData reading);
    [CompilerGeneratedAttribute]
public OrientationSensorData get_Reading();
}
[IsReadOnlyAttribute]
public class Xamarin.Essentials.OrientationSensorData : ValueType {
    [CompilerGeneratedAttribute]
private Quaternion <Orientation>k__BackingField;
    public Quaternion Orientation { get; }
    public OrientationSensorData(double x, double y, double z, double w);
    public OrientationSensorData(float x, float y, float z, float w);
    [CompilerGeneratedAttribute]
public Quaternion get_Orientation();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OrientationSensorData other);
    public static bool op_Equality(OrientationSensorData left, OrientationSensorData right);
    public static bool op_Inequality(OrientationSensorData left, OrientationSensorData right);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public class Xamarin.Essentials.PermissionException : UnauthorizedAccessException {
    public PermissionException(string message);
}
public static class Xamarin.Essentials.Permissions : object {
    [CompilerGeneratedAttribute]
private static TimeSpan <LocationTimeout>k__BackingField;
    public static TimeSpan LocationTimeout { get; public set; }
    private static Permissions();
    public static Task`1<PermissionStatus> CheckStatusAsync();
    public static Task`1<PermissionStatus> RequestAsync();
    public static bool ShouldShowRationale();
    internal static void EnsureDeclared();
    [AsyncStateMachineAttribute("Xamarin.Essentials.Permissions/<EnsureGrantedAsync>d__4`1")]
internal static Task EnsureGrantedAsync();
    [AsyncStateMachineAttribute("Xamarin.Essentials.Permissions/<EnsureGrantedOrRestrictedAsync>d__5`1")]
internal static Task EnsureGrantedOrRestrictedAsync();
    public static bool IsKeyDeclaredInInfoPlist(string usageKey);
    [CompilerGeneratedAttribute]
public static TimeSpan get_LocationTimeout();
    [CompilerGeneratedAttribute]
public static void set_LocationTimeout(TimeSpan value);
}
public enum Xamarin.Essentials.PermissionStatus : Enum {
    public int value__;
    public static PermissionStatus Unknown;
    public static PermissionStatus Denied;
    public static PermissionStatus Disabled;
    public static PermissionStatus Granted;
    public static PermissionStatus Restricted;
}
public static class Xamarin.Essentials.PhoneDialer : object {
    internal static bool IsSupported { get; }
    internal static void ValidateOpen(string number);
    public static void Open(string number);
    internal static bool get_IsSupported();
    private static void PlatformOpen(string number);
}
public class Xamarin.Essentials.PickOptions : object {
    [CompilerGeneratedAttribute]
private string <PickerTitle>k__BackingField;
    [CompilerGeneratedAttribute]
private FilePickerFileType <FileTypes>k__BackingField;
    public static PickOptions Default { get; }
    public static PickOptions Images { get; }
    public string PickerTitle { get; public set; }
    public FilePickerFileType FileTypes { get; public set; }
    public static PickOptions get_Default();
    public static PickOptions get_Images();
    [CompilerGeneratedAttribute]
public string get_PickerTitle();
    [CompilerGeneratedAttribute]
public void set_PickerTitle(string value);
    [CompilerGeneratedAttribute]
public FilePickerFileType get_FileTypes();
    [CompilerGeneratedAttribute]
public void set_FileTypes(FilePickerFileType value);
}
public class Xamarin.Essentials.Placemark : object {
    [CompilerGeneratedAttribute]
private Location <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CountryCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CountryName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FeatureName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PostalCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubLocality>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Thoroughfare>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubThoroughfare>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Locality>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AdminArea>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubAdminArea>k__BackingField;
    public Location Location { get; public set; }
    public string CountryCode { get; public set; }
    public string CountryName { get; public set; }
    public string FeatureName { get; public set; }
    public string PostalCode { get; public set; }
    public string SubLocality { get; public set; }
    public string Thoroughfare { get; public set; }
    public string SubThoroughfare { get; public set; }
    public string Locality { get; public set; }
    public string AdminArea { get; public set; }
    public string SubAdminArea { get; public set; }
    public Placemark(Placemark placemark);
    [CompilerGeneratedAttribute]
public Location get_Location();
    [CompilerGeneratedAttribute]
public void set_Location(Location value);
    [CompilerGeneratedAttribute]
public string get_CountryCode();
    [CompilerGeneratedAttribute]
public void set_CountryCode(string value);
    [CompilerGeneratedAttribute]
public string get_CountryName();
    [CompilerGeneratedAttribute]
public void set_CountryName(string value);
    [CompilerGeneratedAttribute]
public string get_FeatureName();
    [CompilerGeneratedAttribute]
public void set_FeatureName(string value);
    [CompilerGeneratedAttribute]
public string get_PostalCode();
    [CompilerGeneratedAttribute]
public void set_PostalCode(string value);
    [CompilerGeneratedAttribute]
public string get_SubLocality();
    [CompilerGeneratedAttribute]
public void set_SubLocality(string value);
    [CompilerGeneratedAttribute]
public string get_Thoroughfare();
    [CompilerGeneratedAttribute]
public void set_Thoroughfare(string value);
    [CompilerGeneratedAttribute]
public string get_SubThoroughfare();
    [CompilerGeneratedAttribute]
public void set_SubThoroughfare(string value);
    [CompilerGeneratedAttribute]
public string get_Locality();
    [CompilerGeneratedAttribute]
public void set_Locality(string value);
    [CompilerGeneratedAttribute]
public string get_AdminArea();
    [CompilerGeneratedAttribute]
public void set_AdminArea(string value);
    [CompilerGeneratedAttribute]
public string get_SubAdminArea();
    [CompilerGeneratedAttribute]
public void set_SubAdminArea(string value);
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Xamarin.Essentials.PlacemarkExtensions : object {
    [ExtensionAttribute]
public static Task OpenMapsAsync(Placemark placemark, MapLaunchOptions options);
    [ExtensionAttribute]
public static Task OpenMapsAsync(Placemark placemark);
    [ExtensionAttribute]
internal static string GetEscapedAddress(Placemark placemark);
    [ExtensionAttribute]
internal static IEnumerable`1<Placemark> ToPlacemarks(IEnumerable`1<CLPlacemark> addresses);
}
public static class Xamarin.Essentials.Platform : object {
    private static CMMotionManager motionManager;
    internal static CMMotionManager MotionManager { get; }
    internal static int SysctlByName(string property, IntPtr output, IntPtr oldLen, IntPtr newp, UInt32 newlen);
    internal static string GetSystemLibraryProperty(string property);
    internal static bool HasOSVersion(int major, int minor);
    internal static CMMotionManager get_MotionManager();
    internal static NSOperationQueue GetCurrentQueue();
}
[ExtensionAttribute]
public static class Xamarin.Essentials.PointExtensions : object {
    [ExtensionAttribute]
public static Point ToSystemPoint(CGPoint point);
    [ExtensionAttribute]
public static PointF ToSystemPointF(CGPoint point);
    [ExtensionAttribute]
public static CGPoint ToPlatformPoint(Point point);
    [ExtensionAttribute]
public static CGPoint ToPlatformPoint(PointF point);
}
public static class Xamarin.Essentials.Preferences : object {
    private static object locker;
    private static Preferences();
    internal static string GetPrivatePreferencesSharedName(string feature);
    public static bool ContainsKey(string key);
    public static void Remove(string key);
    public static void Clear();
    public static string Get(string key, string defaultValue);
    public static bool Get(string key, bool defaultValue);
    public static int Get(string key, int defaultValue);
    public static double Get(string key, double defaultValue);
    public static float Get(string key, float defaultValue);
    public static long Get(string key, long defaultValue);
    public static void Set(string key, string value);
    public static void Set(string key, bool value);
    public static void Set(string key, int value);
    public static void Set(string key, double value);
    public static void Set(string key, float value);
    public static void Set(string key, long value);
    public static bool ContainsKey(string key, string sharedName);
    public static void Remove(string key, string sharedName);
    public static void Clear(string sharedName);
    public static string Get(string key, string defaultValue, string sharedName);
    public static bool Get(string key, bool defaultValue, string sharedName);
    public static int Get(string key, int defaultValue, string sharedName);
    public static double Get(string key, double defaultValue, string sharedName);
    public static float Get(string key, float defaultValue, string sharedName);
    public static long Get(string key, long defaultValue, string sharedName);
    public static void Set(string key, string value, string sharedName);
    public static void Set(string key, bool value, string sharedName);
    public static void Set(string key, int value, string sharedName);
    public static void Set(string key, double value, string sharedName);
    public static void Set(string key, float value, string sharedName);
    public static void Set(string key, long value, string sharedName);
    public static DateTime Get(string key, DateTime defaultValue);
    public static void Set(string key, DateTime value);
    public static DateTime Get(string key, DateTime defaultValue, string sharedName);
    public static void Set(string key, DateTime value, string sharedName);
    private static bool PlatformContainsKey(string key, string sharedName);
    private static void PlatformRemove(string key, string sharedName);
    private static void PlatformClear(string sharedName);
    private static void PlatformSet(string key, T value, string sharedName);
    private static T PlatformGet(string key, T defaultValue, string sharedName);
    private static NSUserDefaults GetUserDefaults(string sharedName);
}
[AttributeUsageAttribute("32767")]
[EditorBrowsableAttribute("1")]
internal class Xamarin.Essentials.PreserveAttribute : Attribute {
    public bool AllMembers;
    public bool Conditional;
    public PreserveAttribute(bool allMembers, bool conditional);
}
public class Xamarin.Essentials.ReadOnlyFile : FileBase {
    public ReadOnlyFile(string fullPath);
    public ReadOnlyFile(string fullPath, string contentType);
    public ReadOnlyFile(FileBase file);
}
[ExtensionAttribute]
public static class Xamarin.Essentials.RectangleExtensions : object {
    [ExtensionAttribute]
public static Rectangle ToSystemRectangle(CGRect rect);
    [ExtensionAttribute]
public static RectangleF ToSystemRectangleF(CGRect rect);
    [ExtensionAttribute]
public static CGRect ToPlatformRectangle(Rectangle rect);
    [ExtensionAttribute]
public static CGRect ToPlatformRectangle(RectangleF rect);
}
public static class Xamarin.Essentials.Screenshot : object {
    public static bool IsCaptureSupported { get; }
    private static bool PlatformIsCaptureSupported { get; }
    public static bool get_IsCaptureSupported();
    public static Task`1<ScreenshotResult> CaptureAsync();
    private static bool get_PlatformIsCaptureSupported();
    private static Task`1<ScreenshotResult> PlatformCaptureAsync();
}
public enum Xamarin.Essentials.ScreenshotFormat : Enum {
    public int value__;
    public static ScreenshotFormat Png;
    public static ScreenshotFormat Jpeg;
}
public class Xamarin.Essentials.ScreenshotResult : object {
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    public int Width { get; }
    public int Height { get; }
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public int get_Height();
    public Task`1<Stream> OpenReadAsync(ScreenshotFormat format);
    internal Task`1<Stream> PlatformOpenReadAsync(ScreenshotFormat format);
}
public static class Xamarin.Essentials.SecureStorage : object {
    internal static string Alias;
    [CompilerGeneratedAttribute]
private static SecAccessible <DefaultAccessible>k__BackingField;
    public static SecAccessible DefaultAccessible { get; public set; }
    private static SecureStorage();
    public static Task`1<string> GetAsync(string key);
    public static Task SetAsync(string key, string value);
    public static bool Remove(string key);
    public static void RemoveAll();
    [CompilerGeneratedAttribute]
public static SecAccessible get_DefaultAccessible();
    [CompilerGeneratedAttribute]
public static void set_DefaultAccessible(SecAccessible value);
    public static Task SetAsync(string key, string value, SecAccessible accessible);
    private static Task`1<string> PlatformGetAsync(string key);
    private static Task PlatformSetAsync(string key, string data);
    private static bool PlatformRemove(string key);
    private static void PlatformRemoveAll();
}
public enum Xamarin.Essentials.SensorSpeed : Enum {
    public int value__;
    public static SensorSpeed Default;
    public static SensorSpeed UI;
    public static SensorSpeed Game;
    public static SensorSpeed Fastest;
}
[ExtensionAttribute]
internal static class Xamarin.Essentials.SensorSpeedExtensions : object {
    [ExtensionAttribute]
internal static double ToPlatform(SensorSpeed sensorSpeed);
}
public static class Xamarin.Essentials.Share : object {
    public static Task RequestAsync(string text);
    public static Task RequestAsync(string text, string title);
    public static Task RequestAsync(ShareTextRequest request);
    public static Task RequestAsync(ShareFileRequest request);
    public static Task RequestAsync(ShareMultipleFilesRequest request);
    private static string FileNullExeption(string file);
    private static Task PlatformRequestAsync(ShareTextRequest request);
    private static Task PlatformRequestAsync(ShareMultipleFilesRequest request);
}
public class Xamarin.Essentials.ShareFile : FileBase {
    public ShareFile(string fullPath);
    public ShareFile(string fullPath, string contentType);
    public ShareFile(FileBase file);
}
public class Xamarin.Essentials.ShareFileRequest : ShareRequestBase {
    [CompilerGeneratedAttribute]
private ShareFile <File>k__BackingField;
    public ShareFile File { get; public set; }
    public ShareFileRequest(string title, ShareFile file);
    public ShareFileRequest(string title, FileBase file);
    public ShareFileRequest(ShareFile file);
    public ShareFileRequest(FileBase file);
    [CompilerGeneratedAttribute]
public ShareFile get_File();
    [CompilerGeneratedAttribute]
public void set_File(ShareFile value);
}
public class Xamarin.Essentials.ShareMultipleFilesRequest : ShareRequestBase {
    [CompilerGeneratedAttribute]
private List`1<ShareFile> <Files>k__BackingField;
    public List`1<ShareFile> Files { get; public set; }
    public ShareMultipleFilesRequest(IEnumerable`1<ShareFile> files);
    public ShareMultipleFilesRequest(IEnumerable`1<FileBase> files);
    public ShareMultipleFilesRequest(string title, IEnumerable`1<ShareFile> files);
    public ShareMultipleFilesRequest(string title, IEnumerable`1<FileBase> files);
    [CompilerGeneratedAttribute]
public List`1<ShareFile> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(List`1<ShareFile> value);
    public static ShareMultipleFilesRequest op_Explicit(ShareFileRequest request);
    private static IEnumerable`1<ShareFile> ConvertList(IEnumerable`1<FileBase> files);
}
public abstract class Xamarin.Essentials.ShareRequestBase : object {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private Rectangle <PresentationSourceBounds>k__BackingField;
    public string Title { get; public set; }
    public Rectangle PresentationSourceBounds { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public Rectangle get_PresentationSourceBounds();
    [CompilerGeneratedAttribute]
public void set_PresentationSourceBounds(Rectangle value);
}
public class Xamarin.Essentials.ShareTextRequest : ShareRequestBase {
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    public string Subject { get; public set; }
    public string Text { get; public set; }
    public string Uri { get; public set; }
    public ShareTextRequest(string text);
    public ShareTextRequest(string text, string title);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(string value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public void set_Uri(string value);
}
public static class Xamarin.Essentials.Sms : object {
    internal static bool IsComposeSupported { get; }
    public static Task ComposeAsync();
    public static Task ComposeAsync(SmsMessage message);
    internal static bool get_IsComposeSupported();
    private static Task PlatformComposeAsync(SmsMessage message);
}
public class Xamarin.Essentials.SmsMessage : object {
    [CompilerGeneratedAttribute]
private string <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Recipients>k__BackingField;
    public string Body { get; public set; }
    public List`1<string> Recipients { get; public set; }
    public SmsMessage(string body, string recipient);
    public SmsMessage(string body, IEnumerable`1<string> recipients);
    [CompilerGeneratedAttribute]
public string get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_Recipients();
    [CompilerGeneratedAttribute]
public void set_Recipients(List`1<string> value);
}
public class Xamarin.Essentials.SpeechOptions : object {
    [CompilerGeneratedAttribute]
private Locale <Locale>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <Pitch>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<float> <Volume>k__BackingField;
    public Locale Locale { get; public set; }
    public Nullable`1<float> Pitch { get; public set; }
    public Nullable`1<float> Volume { get; public set; }
    [CompilerGeneratedAttribute]
public Locale get_Locale();
    [CompilerGeneratedAttribute]
public void set_Locale(Locale value);
    [CompilerGeneratedAttribute]
public Nullable`1<float> get_Pitch();
    [CompilerGeneratedAttribute]
public void set_Pitch(Nullable`1<float> value);
    [CompilerGeneratedAttribute]
public Nullable`1<float> get_Volume();
    [CompilerGeneratedAttribute]
public void set_Volume(Nullable`1<float> value);
}
public static class Xamarin.Essentials.TextToSpeech : object {
    internal static float PitchMax;
    internal static float PitchDefault;
    internal static float PitchMin;
    internal static float VolumeMax;
    internal static float VolumeDefault;
    internal static float VolumeMin;
    private static SemaphoreSlim semaphore;
    private static Lazy`1<AVSpeechSynthesizer> speechSynthesizer;
    private static TextToSpeech();
    public static Task`1<IEnumerable`1<Locale>> GetLocalesAsync();
    public static Task SpeakAsync(string text, CancellationToken cancelToken);
    [AsyncStateMachineAttribute("Xamarin.Essentials.TextToSpeech/<SpeakAsync>d__9")]
public static Task SpeakAsync(string text, SpeechOptions options, CancellationToken cancelToken);
    internal static float PlatformNormalize(float min, float max, float percent);
    internal static Task`1<IEnumerable`1<Locale>> PlatformGetLocalesAsync();
    [AsyncStateMachineAttribute("Xamarin.Essentials.TextToSpeech/<PlatformSpeakAsync>d__13")]
internal static Task PlatformSpeakAsync(string text, SpeechOptions options, CancellationToken cancelToken);
    private static AVSpeechUtterance GetSpeechUtterance(string text, SpeechOptions options);
    [AsyncStateMachineAttribute("Xamarin.Essentials.TextToSpeech/<SpeakUtterance>d__15")]
internal static Task SpeakUtterance(AVSpeechUtterance speechUtterance, CancellationToken cancelToken);
}
[ExtensionAttribute]
internal static class Xamarin.Essentials.TextToSpeechExtensions : object {
    [ExtensionAttribute]
internal static List`1<string> SplitSpeak(string text, int max);
}
public static class Xamarin.Essentials.UnitConverters : object {
    private static double twoPi;
    private static double totalDegrees;
    private static double atmospherePascals;
    private static double degreesToRadians;
    private static double milesToKilometers;
    private static double milesToMeters;
    private static double kilometersToMiles;
    private static double celsiusToKelvin;
    private static double poundsToKg;
    private static double poundsToStones;
    private static double stonesToPounds;
    private static double kgToPounds;
    private static double meanEarthRadiusInKilometers;
    private static double internationalFootDefinition;
    private static double usSurveyFootDefinition;
    public static double FahrenheitToCelsius(double fahrenheit);
    public static double CelsiusToFahrenheit(double celsius);
    public static double CelsiusToKelvin(double celsius);
    public static double KelvinToCelsius(double kelvin);
    public static double MilesToMeters(double miles);
    public static double MilesToKilometers(double miles);
    public static double KilometersToMiles(double kilometers);
    public static double DegreesToRadians(double degrees);
    public static double RadiansToDegrees(double radians);
    public static double PoundsToKilograms(double pounds);
    public static double PoundsToStones(double pounds);
    public static double StonesToPounds(double stones);
    public static double KilogramsToPounds(double kilograms);
    public static double DegreesPerSecondToRadiansPerSecond(double degrees);
    public static double RadiansPerSecondToDegreesPerSecond(double radians);
    public static double DegreesPerSecondToHertz(double degrees);
    public static double RadiansPerSecondToHertz(double radians);
    public static double HertzToDegreesPerSecond(double hertz);
    public static double HertzToRadiansPerSecond(double hertz);
    public static double KilopascalsToHectopascals(double kpa);
    public static double HectopascalsToKilopascals(double hpa);
    public static double KilopascalsToPascals(double kpa);
    public static double HectopascalsToPascals(double hpa);
    public static double AtmospheresToPascals(double atm);
    public static double PascalsToAtmospheres(double pascals);
    public static double CoordinatesToMiles(double lat1, double lon1, double lat2, double lon2);
    public static double CoordinatesToKilometers(double lat1, double lon1, double lat2, double lon2);
    public static double MetersToInternationalFeet(double meters);
    public static double InternationalFeetToMeters(double internationalFeet);
    public static double MetersToUSSurveyFeet(double meters);
    public static double USSurveyFeetToMeters(double usFeet);
}
internal static class Xamarin.Essentials.Utils : object {
    internal static Version ParseVersion(string version);
    internal static CancellationToken TimeoutToken(CancellationToken cancellationToken, TimeSpan timeout);
    [AsyncStateMachineAttribute("Xamarin.Essentials.Utils/<WithTimeout>d__2`1")]
internal static Task`1<T> WithTimeout(Task`1<T> task, TimeSpan timeSpan);
}
public static class Xamarin.Essentials.VersionTracking : object {
    private static string versionTrailKey;
    private static string versionsKey;
    private static string buildsKey;
    private static string sharedName;
    private static Dictionary`2<string, List`1<string>> versionTrail;
    [CompilerGeneratedAttribute]
private static bool <IsFirstLaunchEver>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsFirstLaunchForCurrentVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <IsFirstLaunchForCurrentBuild>k__BackingField;
    public static bool IsFirstLaunchEver { get; private set; }
    public static bool IsFirstLaunchForCurrentVersion { get; private set; }
    public static bool IsFirstLaunchForCurrentBuild { get; private set; }
    public static string CurrentVersion { get; }
    public static string CurrentBuild { get; }
    public static string PreviousVersion { get; }
    public static string PreviousBuild { get; }
    public static string FirstInstalledVersion { get; }
    public static string FirstInstalledBuild { get; }
    public static IEnumerable`1<string> VersionHistory { get; }
    public static IEnumerable`1<string> BuildHistory { get; }
    private static string LastInstalledVersion { get; }
    private static string LastInstalledBuild { get; }
    private static VersionTracking();
    internal static void InitVersionTracking();
    [PreserveAttribute]
public static void Track();
    [CompilerGeneratedAttribute]
public static bool get_IsFirstLaunchEver();
    [CompilerGeneratedAttribute]
private static void set_IsFirstLaunchEver(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsFirstLaunchForCurrentVersion();
    [CompilerGeneratedAttribute]
private static void set_IsFirstLaunchForCurrentVersion(bool value);
    [CompilerGeneratedAttribute]
public static bool get_IsFirstLaunchForCurrentBuild();
    [CompilerGeneratedAttribute]
private static void set_IsFirstLaunchForCurrentBuild(bool value);
    public static string get_CurrentVersion();
    public static string get_CurrentBuild();
    public static string get_PreviousVersion();
    public static string get_PreviousBuild();
    public static string get_FirstInstalledVersion();
    public static string get_FirstInstalledBuild();
    public static IEnumerable`1<string> get_VersionHistory();
    public static IEnumerable`1<string> get_BuildHistory();
    public static bool IsFirstLaunchForVersion(string version);
    public static bool IsFirstLaunchForBuild(string build);
    internal static string GetStatus();
    private static String[] ReadHistory(string key);
    private static void WriteHistory(string key, IEnumerable`1<string> history);
    private static string GetPrevious(string key);
    private static string get_LastInstalledVersion();
    private static string get_LastInstalledBuild();
}
public static class Xamarin.Essentials.Vibration : object {
    internal static bool IsSupported { get; }
    public static void Vibrate();
    public static void Vibrate(double duration);
    public static void Vibrate(TimeSpan duration);
    public static void Cancel();
    internal static bool get_IsSupported();
    private static void PlatformVibrate(TimeSpan duration);
    private static void PlatformCancel();
}
public static class Xamarin.Essentials.WebAuthenticator : object {
    public static Task`1<WebAuthenticatorResult> AuthenticateAsync(Uri url, Uri callbackUrl);
    public static Task`1<WebAuthenticatorResult> AuthenticateAsync(WebAuthenticatorOptions webAuthenticatorOptions);
    private static Task`1<WebAuthenticatorResult> PlatformAuthenticateAsync(WebAuthenticatorOptions webAuthenticatorOptions);
}
public class Xamarin.Essentials.WebAuthenticatorOptions : object {
    [CompilerGeneratedAttribute]
private Uri <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <CallbackUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PrefersEphemeralWebBrowserSession>k__BackingField;
    public Uri Url { get; public set; }
    public Uri CallbackUrl { get; public set; }
    public bool PrefersEphemeralWebBrowserSession { get; public set; }
    [CompilerGeneratedAttribute]
public Uri get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_CallbackUrl();
    [CompilerGeneratedAttribute]
public void set_CallbackUrl(Uri value);
    [CompilerGeneratedAttribute]
public bool get_PrefersEphemeralWebBrowserSession();
    [CompilerGeneratedAttribute]
public void set_PrefersEphemeralWebBrowserSession(bool value);
}
public class Xamarin.Essentials.WebAuthenticatorResult : object {
    [CompilerGeneratedAttribute]
private DateTimeOffset <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    public DateTimeOffset Timestamp { get; public set; }
    public Dictionary`2<string, string> Properties { get; public set; }
    public string AccessToken { get; }
    public string RefreshToken { get; }
    public string IdToken { get; }
    public Nullable`1<DateTimeOffset> RefreshTokenExpiresIn { get; }
    public Nullable`1<DateTimeOffset> ExpiresIn { get; }
    public WebAuthenticatorResult(Uri uri);
    public WebAuthenticatorResult(IDictionary`2<string, string> properties);
    [CompilerGeneratedAttribute]
public DateTimeOffset get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(Dictionary`2<string, string> value);
    public void Put(string key, string value);
    public string Get(string key);
    public string get_AccessToken();
    public string get_RefreshToken();
    public string get_IdToken();
    public Nullable`1<DateTimeOffset> get_RefreshTokenExpiresIn();
    public Nullable`1<DateTimeOffset> get_ExpiresIn();
}
internal static class Xamarin.Essentials.WebUtils : object {
    internal static IDictionary`2<string, string> ParseQueryString(string url);
    internal static bool CanHandleCallback(Uri expectedUrl, Uri callbackUrl);
}
