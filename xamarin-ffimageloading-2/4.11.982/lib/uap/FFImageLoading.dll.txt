internal class FFImageLoading.AnimatedImage`1 : object {
    [CompilerGeneratedAttribute]
private TNativeImageContainer <Image>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Delay>k__BackingField;
    public TNativeImageContainer Image { get; public set; }
    public int Delay { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual TNativeImageContainer get_Image();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Image(TNativeImageContainer value);
    [CompilerGeneratedAttribute]
public sealed virtual int get_Delay();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Delay(int value);
}
[PreserveAttribute]
public class FFImageLoading.Args.DownloadProgressEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private DownloadProgress <DownloadProgress>k__BackingField;
    public DownloadProgress DownloadProgress { get; private set; }
    public DownloadProgressEventArgs(DownloadProgress downloadProgress);
    [CompilerGeneratedAttribute]
public DownloadProgress get_DownloadProgress();
    [CompilerGeneratedAttribute]
private void set_DownloadProgress(DownloadProgress value);
}
[PreserveAttribute]
public class FFImageLoading.Args.DownloadStartedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private DownloadInformation <DownloadInformation>k__BackingField;
    public DownloadInformation DownloadInformation { get; private set; }
    public DownloadStartedEventArgs(DownloadInformation downloadInformation);
    [CompilerGeneratedAttribute]
public DownloadInformation get_DownloadInformation();
    [CompilerGeneratedAttribute]
private void set_DownloadInformation(DownloadInformation value);
}
[PreserveAttribute]
public class FFImageLoading.Args.ErrorEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public Exception Exception { get; private set; }
    public ErrorEventArgs(Exception exception);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
}
[PreserveAttribute]
public class FFImageLoading.Args.FileWriteFinishedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private FileWriteInfo <FileWriteInfo>k__BackingField;
    public FileWriteInfo FileWriteInfo { get; private set; }
    public FileWriteFinishedEventArgs(FileWriteInfo fileWriteInfo);
    [CompilerGeneratedAttribute]
public FileWriteInfo get_FileWriteInfo();
    [CompilerGeneratedAttribute]
private void set_FileWriteInfo(FileWriteInfo value);
}
[PreserveAttribute]
public class FFImageLoading.Args.FinishEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private IScheduledWork <ScheduledWork>k__BackingField;
    public IScheduledWork ScheduledWork { get; private set; }
    public FinishEventArgs(IScheduledWork scheduledWork);
    [CompilerGeneratedAttribute]
public IScheduledWork get_ScheduledWork();
    [CompilerGeneratedAttribute]
private void set_ScheduledWork(IScheduledWork value);
}
[PreserveAttribute]
public class FFImageLoading.Args.SuccessEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ImageInformation <ImageInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private LoadingResult <LoadingResult>k__BackingField;
    public ImageInformation ImageInformation { get; private set; }
    public LoadingResult LoadingResult { get; private set; }
    public SuccessEventArgs(ImageInformation imageInformation, LoadingResult loadingResult);
    [CompilerGeneratedAttribute]
public ImageInformation get_ImageInformation();
    [CompilerGeneratedAttribute]
private void set_ImageInformation(ImageInformation value);
    [CompilerGeneratedAttribute]
public LoadingResult get_LoadingResult();
    [CompilerGeneratedAttribute]
private void set_LoadingResult(LoadingResult value);
}
[ExtensionAttribute]
public static class FFImageLoading.ArrayExtensions : object {
    [ExtensionAttribute]
public static void Fill(T[] originalArray, T with);
    [ExtensionAttribute]
public static void Fill(T[] originalArray, int fromIdx, int toIdx, T with);
}
[ExtensionAttribute]
[PreserveAttribute]
public static class FFImageLoading.AssemblyExtensions : object {
    [ExtensionAttribute]
public static string GetTypeAssemblyFullName(Type type);
}
[IsReadOnlyAttribute]
internal class FFImageLoading.Cache.CacheEntry : ValueType {
    public DateTime Origin;
    public TimeSpan TimeToLive;
    public string FileName;
    public CacheEntry(DateTime o, TimeSpan ttl, string fileName);
}
[PreserveAttribute]
public enum FFImageLoading.Cache.CacheResult : Enum {
    public int value__;
    public static CacheResult Found;
    public static CacheResult NotFound;
    public static CacheResult ErrorOccured;
}
[PreserveAttribute]
public class FFImageLoading.Cache.CacheStream : object {
    [CompilerGeneratedAttribute]
private Stream <ImageStream>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RetrievedFromDiskCache>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public Stream ImageStream { get; private set; }
    public bool RetrievedFromDiskCache { get; private set; }
    public string FilePath { get; private set; }
    public CacheStream(Stream stream, bool retrievedFromDiskCache, string filePath);
    [CompilerGeneratedAttribute]
public Stream get_ImageStream();
    [CompilerGeneratedAttribute]
private void set_ImageStream(Stream value);
    [CompilerGeneratedAttribute]
public bool get_RetrievedFromDiskCache();
    [CompilerGeneratedAttribute]
private void set_RetrievedFromDiskCache(bool value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
private void set_FilePath(string value);
}
[PreserveAttribute]
public enum FFImageLoading.Cache.CacheType : Enum {
    public int value__;
    public static CacheType Memory;
    public static CacheType Disk;
    public static CacheType All;
    public static CacheType None;
}
[PreserveAttribute]
public class FFImageLoading.Cache.DownloadCache : object {
    [CompilerGeneratedAttribute]
private String[] <InvalidContentTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DelayBetweenRetry>k__BackingField;
    public String[] InvalidContentTypes { get; public set; }
    protected Configuration Configuration { get; private set; }
    protected IMD5Helper MD5Helper { get; }
    public TimeSpan DelayBetweenRetry { get; public set; }
    public DownloadCache(Configuration configuration);
    [CompilerGeneratedAttribute]
public String[] get_InvalidContentTypes();
    [CompilerGeneratedAttribute]
public void set_InvalidContentTypes(String[] value);
    [CompilerGeneratedAttribute]
protected Configuration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(Configuration value);
    protected virtual IMD5Helper get_MD5Helper();
    [CompilerGeneratedAttribute]
public virtual TimeSpan get_DelayBetweenRetry();
    [CompilerGeneratedAttribute]
public virtual void set_DelayBetweenRetry(TimeSpan value);
    [AsyncStateMachineAttribute("FFImageLoading.Cache.DownloadCache/<DownloadAndCacheIfNeededAsync>d__15")]
public virtual Task`1<CacheStream> DownloadAndCacheIfNeededAsync(string url, TaskParameter parameters, Configuration configuration, CancellationToken token);
    [AsyncStateMachineAttribute("FFImageLoading.Cache.DownloadCache/<DownloadAsync>d__16")]
protected virtual Task`1<Byte[]> DownloadAsync(string url, CancellationToken token, HttpClient client, TaskParameter parameters, DownloadInformation downloadInformation);
    protected virtual void ModifyParametersAfterResponse(HttpResponseMessage response, TaskParameter parameters);
    protected virtual bool AllowDiskCaching(Nullable`1<CacheType> cacheType);
}
[PreserveAttribute]
public interface FFImageLoading.Cache.IDiskCache {
    public abstract virtual Task AddToSavingQueueIfNotExistsAsync(string key, Byte[] bytes, TimeSpan duration, Action writeFinished);
    public abstract virtual Task`1<Stream> TryGetStreamAsync(string key);
    public abstract virtual Task RemoveAsync(string key);
    public abstract virtual Task ClearAsync();
    public abstract virtual Task`1<bool> ExistsAsync(string key);
    public abstract virtual Task`1<string> GetFilePathAsync(string key);
}
[PreserveAttribute]
public interface FFImageLoading.Cache.IDownloadCache {
    public abstract virtual Task`1<CacheStream> DownloadAndCacheIfNeededAsync(string url, TaskParameter parameters, Configuration configuration, CancellationToken token);
}
[PreserveAttribute]
public interface FFImageLoading.Cache.IMemoryCache`1 {
    public abstract virtual ImageInformation GetInfo(string key);
    public abstract virtual Tuple`2<TImageContainer, ImageInformation> Get(string key);
    public abstract virtual void Add(string key, ImageInformation imageInformation, TImageContainer bitmap);
    public abstract virtual void Clear();
    public abstract virtual void Remove(string key);
    public abstract virtual void RemoveSimilar(string baseKey);
}
internal static class FFImageLoading.Concurrency.ArrayHelper : object {
    public static KeyValuePair`2[] Empty();
}
public class FFImageLoading.Concurrency.GenericPriorityQueue`2 : object {
    private int _numNodes;
    private TItem[] _nodes;
    private long _numNodesEverEnqueued;
    private Comparison`1<TPriority> _comparer;
    public int Count { get; }
    public int MaxSize { get; }
    public TItem First { get; }
    public GenericPriorityQueue`2(int maxNodes);
    public GenericPriorityQueue`2(int maxNodes, IComparer`1<TPriority> comparer);
    public GenericPriorityQueue`2(int maxNodes, Comparison`1<TPriority> comparer);
    public sealed virtual int get_Count();
    public sealed virtual int get_MaxSize();
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TItem node);
    public sealed virtual void Enqueue(TItem node, TPriority priority);
    private void CascadeUp(TItem node);
    private void CascadeDown(TItem node);
    private bool HasHigherPriority(TItem higher, TItem lower);
    public sealed virtual TItem Dequeue();
    public sealed virtual void Resize(int maxNodes);
    public sealed virtual TItem get_First();
    public sealed virtual void UpdatePriority(TItem node, TPriority priority);
    private void OnNodeUpdated(TItem node);
    public sealed virtual void Remove(TItem node);
    [IteratorStateMachineAttribute("FFImageLoading.Concurrency.GenericPriorityQueue`2/<GetEnumerator>d__24")]
public sealed virtual IEnumerator`1<TItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool IsValidQueue();
}
public class FFImageLoading.Concurrency.GenericPriorityQueueNode`1 : object {
    [CompilerGeneratedAttribute]
private TPriority <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private int <QueueIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private long <InsertionIndex>k__BackingField;
    public TPriority Priority { get; protected internal set; }
    public int QueueIndex { get; internal set; }
    public long InsertionIndex { get; internal set; }
    [CompilerGeneratedAttribute]
public TPriority get_Priority();
    [CompilerGeneratedAttribute]
protected internal void set_Priority(TPriority value);
    [CompilerGeneratedAttribute]
public int get_QueueIndex();
    [CompilerGeneratedAttribute]
internal void set_QueueIndex(int value);
    [CompilerGeneratedAttribute]
public long get_InsertionIndex();
    [CompilerGeneratedAttribute]
internal void set_InsertionIndex(long value);
}
public interface FFImageLoading.Concurrency.IFixedSizePriorityQueue`2 {
    public int MaxSize { get; }
    public abstract virtual void Resize(int maxNodes);
    public abstract virtual int get_MaxSize();
}
public interface FFImageLoading.Concurrency.IPriorityQueue`2 {
    public TItem First { get; }
    public int Count { get; }
    public abstract virtual void Enqueue(TItem node, TPriority priority);
    public abstract virtual TItem Dequeue();
    public abstract virtual void Clear();
    public abstract virtual bool Contains(TItem node);
    public abstract virtual void Remove(TItem node);
    public abstract virtual void UpdatePriority(TItem node, TPriority priority);
    public abstract virtual TItem get_First();
    public abstract virtual int get_Count();
}
public class FFImageLoading.Concurrency.PendingTasksQueue : SimplePriorityQueue`2<IImageLoaderTask, int> {
    public IImageLoaderTask FirstOrDefaultByRawKey(string rawKey);
}
public class FFImageLoading.Concurrency.SimplePriorityQueue`2 : object {
    private static int INITIAL_QUEUE_SIZE;
    protected GenericPriorityQueue`2<SimpleNode<TItem, TPriority>, TPriority> _queue;
    private Dictionary`2<TItem, IList`1<SimpleNode<TItem, TPriority>>> _itemToNodesCache;
    private IList`1<SimpleNode<TItem, TPriority>> _nullNodesCache;
    public int Count { get; }
    public TItem First { get; }
    public SimplePriorityQueue`2(IComparer`1<TPriority> comparer);
    public SimplePriorityQueue`2(Comparison`1<TPriority> comparer);
    private SimpleNode<TItem, TPriority> GetExistingNode(TItem item);
    private void AddToNodeCache(SimpleNode<TItem, TPriority> node);
    private void RemoveFromNodeCache(SimpleNode<TItem, TPriority> node);
    public sealed virtual int get_Count();
    public sealed virtual TItem get_First();
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TItem item);
    public sealed virtual TItem Dequeue();
    private SimpleNode<TItem, TPriority> EnqueueNoLockOrCache(TItem item, TPriority priority);
    public sealed virtual void Enqueue(TItem item, TPriority priority);
    public bool EnqueueWithoutDuplicates(TItem item, TPriority priority);
    public sealed virtual void Remove(TItem item);
    public sealed virtual void UpdatePriority(TItem item, TPriority priority);
    public TPriority GetPriority(TItem item);
    public bool TryFirst(TItem& first);
    public bool TryDequeue(TItem& first);
    public bool TryRemove(TItem item);
    public bool TryUpdatePriority(TItem item, TPriority priority);
    public bool TryGetPriority(TItem item, TPriority& priority);
    public sealed virtual IEnumerator`1<TItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool IsValidQueue();
}
public class FFImageLoading.Config.Configuration : object {
    [CompilerGeneratedAttribute]
private static Configuration <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpClient <HttpClient>k__BackingField;
    [CompilerGeneratedAttribute]
private IWorkScheduler <Scheduler>k__BackingField;
    [CompilerGeneratedAttribute]
private IMiniLogger <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IDiskCache <DiskCache>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DiskCachePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IDownloadCache <DownloadCache>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataResolverFactory <DataResolverFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private IMD5Helper <MD5Helper>k__BackingField;
    [CompilerGeneratedAttribute]
private IMainThreadDispatcher <MainThreadDispatcher>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BitmapOptimizations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StreamChecksumsAsKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FadeAnimationEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FadeAnimationForCachedImages>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FadeAnimationDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TransformPlaceholders>k__BackingField;
    [CompilerGeneratedAttribute]
private InterpolationMode <DownsampleInterpolationMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUpscale>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HttpHeadersTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HttpReadTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HttpReadBufferSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxMemoryCacheSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DelayInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VerbosePerformanceLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VerboseMemoryCacheLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VerboseLoadingCancelledLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VerboseLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DecodingMaxParallelTasks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SchedulerMaxParallelTasks>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Configuration, int> <SchedulerMaxParallelTasksFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <DiskCacheDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TryToReadDiskCacheDurationFromHttpHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExecuteCallbacksOnUIThread>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AnimateGifs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ClearMemoryCacheOnOutOfMemory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InvalidateLayout>k__BackingField;
    public static Configuration Default { get; }
    public HttpClient HttpClient { get; public set; }
    public IWorkScheduler Scheduler { get; public set; }
    public IMiniLogger Logger { get; public set; }
    public IDiskCache DiskCache { get; public set; }
    public string DiskCachePath { get; public set; }
    public IDownloadCache DownloadCache { get; public set; }
    public IDataResolverFactory DataResolverFactory { get; public set; }
    public IMD5Helper MD5Helper { get; public set; }
    public IMainThreadDispatcher MainThreadDispatcher { get; public set; }
    public bool BitmapOptimizations { get; public set; }
    public bool StreamChecksumsAsKeys { get; public set; }
    public bool FadeAnimationEnabled { get; public set; }
    public bool FadeAnimationForCachedImages { get; public set; }
    public int FadeAnimationDuration { get; public set; }
    public bool TransformPlaceholders { get; public set; }
    public InterpolationMode DownsampleInterpolationMode { get; public set; }
    public bool AllowUpscale { get; public set; }
    public int HttpHeadersTimeout { get; public set; }
    public int HttpReadTimeout { get; public set; }
    public int HttpReadBufferSize { get; public set; }
    public int MaxMemoryCacheSize { get; public set; }
    public int DelayInMs { get; public set; }
    public bool VerbosePerformanceLogging { get; public set; }
    public bool VerboseMemoryCacheLogging { get; public set; }
    public bool VerboseLoadingCancelledLogging { get; public set; }
    public bool VerboseLogging { get; public set; }
    public int DecodingMaxParallelTasks { get; public set; }
    public int SchedulerMaxParallelTasks { get; public set; }
    public Func`2<Configuration, int> SchedulerMaxParallelTasksFactory { get; public set; }
    public TimeSpan DiskCacheDuration { get; public set; }
    public bool TryToReadDiskCacheDurationFromHttpHeaders { get; public set; }
    public bool ExecuteCallbacksOnUIThread { get; public set; }
    public bool AnimateGifs { get; public set; }
    public bool ClearMemoryCacheOnOutOfMemory { get; public set; }
    public bool InvalidateLayout { get; public set; }
    private static Configuration();
    [CompilerGeneratedAttribute]
public static Configuration get_Default();
    [CompilerGeneratedAttribute]
public HttpClient get_HttpClient();
    [CompilerGeneratedAttribute]
public void set_HttpClient(HttpClient value);
    [CompilerGeneratedAttribute]
public IWorkScheduler get_Scheduler();
    [CompilerGeneratedAttribute]
public void set_Scheduler(IWorkScheduler value);
    [CompilerGeneratedAttribute]
public IMiniLogger get_Logger();
    [CompilerGeneratedAttribute]
public void set_Logger(IMiniLogger value);
    [CompilerGeneratedAttribute]
public IDiskCache get_DiskCache();
    [CompilerGeneratedAttribute]
public void set_DiskCache(IDiskCache value);
    [CompilerGeneratedAttribute]
public string get_DiskCachePath();
    [CompilerGeneratedAttribute]
public void set_DiskCachePath(string value);
    [CompilerGeneratedAttribute]
public IDownloadCache get_DownloadCache();
    [CompilerGeneratedAttribute]
public void set_DownloadCache(IDownloadCache value);
    [CompilerGeneratedAttribute]
public IDataResolverFactory get_DataResolverFactory();
    [CompilerGeneratedAttribute]
public void set_DataResolverFactory(IDataResolverFactory value);
    [CompilerGeneratedAttribute]
public IMD5Helper get_MD5Helper();
    [CompilerGeneratedAttribute]
public void set_MD5Helper(IMD5Helper value);
    [CompilerGeneratedAttribute]
public IMainThreadDispatcher get_MainThreadDispatcher();
    [CompilerGeneratedAttribute]
public void set_MainThreadDispatcher(IMainThreadDispatcher value);
    [CompilerGeneratedAttribute]
public bool get_BitmapOptimizations();
    [CompilerGeneratedAttribute]
public void set_BitmapOptimizations(bool value);
    [CompilerGeneratedAttribute]
public bool get_StreamChecksumsAsKeys();
    [CompilerGeneratedAttribute]
public void set_StreamChecksumsAsKeys(bool value);
    [CompilerGeneratedAttribute]
public bool get_FadeAnimationEnabled();
    [CompilerGeneratedAttribute]
public void set_FadeAnimationEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_FadeAnimationForCachedImages();
    [CompilerGeneratedAttribute]
public void set_FadeAnimationForCachedImages(bool value);
    [CompilerGeneratedAttribute]
public int get_FadeAnimationDuration();
    [CompilerGeneratedAttribute]
public void set_FadeAnimationDuration(int value);
    [CompilerGeneratedAttribute]
public bool get_TransformPlaceholders();
    [CompilerGeneratedAttribute]
public void set_TransformPlaceholders(bool value);
    [CompilerGeneratedAttribute]
public InterpolationMode get_DownsampleInterpolationMode();
    [CompilerGeneratedAttribute]
public void set_DownsampleInterpolationMode(InterpolationMode value);
    [CompilerGeneratedAttribute]
public bool get_AllowUpscale();
    [CompilerGeneratedAttribute]
public void set_AllowUpscale(bool value);
    [CompilerGeneratedAttribute]
public int get_HttpHeadersTimeout();
    [CompilerGeneratedAttribute]
public void set_HttpHeadersTimeout(int value);
    [CompilerGeneratedAttribute]
public int get_HttpReadTimeout();
    [CompilerGeneratedAttribute]
public void set_HttpReadTimeout(int value);
    [CompilerGeneratedAttribute]
public int get_HttpReadBufferSize();
    [CompilerGeneratedAttribute]
public void set_HttpReadBufferSize(int value);
    [CompilerGeneratedAttribute]
public int get_MaxMemoryCacheSize();
    [CompilerGeneratedAttribute]
public void set_MaxMemoryCacheSize(int value);
    [CompilerGeneratedAttribute]
public int get_DelayInMs();
    [CompilerGeneratedAttribute]
public void set_DelayInMs(int value);
    [CompilerGeneratedAttribute]
public bool get_VerbosePerformanceLogging();
    [CompilerGeneratedAttribute]
public void set_VerbosePerformanceLogging(bool value);
    [CompilerGeneratedAttribute]
public bool get_VerboseMemoryCacheLogging();
    [CompilerGeneratedAttribute]
public void set_VerboseMemoryCacheLogging(bool value);
    [CompilerGeneratedAttribute]
public bool get_VerboseLoadingCancelledLogging();
    [CompilerGeneratedAttribute]
public void set_VerboseLoadingCancelledLogging(bool value);
    [CompilerGeneratedAttribute]
public bool get_VerboseLogging();
    [CompilerGeneratedAttribute]
public void set_VerboseLogging(bool value);
    [CompilerGeneratedAttribute]
public int get_DecodingMaxParallelTasks();
    [CompilerGeneratedAttribute]
public void set_DecodingMaxParallelTasks(int value);
    [CompilerGeneratedAttribute]
public int get_SchedulerMaxParallelTasks();
    [CompilerGeneratedAttribute]
public void set_SchedulerMaxParallelTasks(int value);
    [CompilerGeneratedAttribute]
public Func`2<Configuration, int> get_SchedulerMaxParallelTasksFactory();
    [CompilerGeneratedAttribute]
public void set_SchedulerMaxParallelTasksFactory(Func`2<Configuration, int> value);
    [CompilerGeneratedAttribute]
public TimeSpan get_DiskCacheDuration();
    [CompilerGeneratedAttribute]
public void set_DiskCacheDuration(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_TryToReadDiskCacheDurationFromHttpHeaders();
    [CompilerGeneratedAttribute]
public void set_TryToReadDiskCacheDurationFromHttpHeaders(bool value);
    [CompilerGeneratedAttribute]
public bool get_ExecuteCallbacksOnUIThread();
    [CompilerGeneratedAttribute]
public void set_ExecuteCallbacksOnUIThread(bool value);
    [CompilerGeneratedAttribute]
public bool get_AnimateGifs();
    [CompilerGeneratedAttribute]
public void set_AnimateGifs(bool value);
    [CompilerGeneratedAttribute]
public bool get_ClearMemoryCacheOnOutOfMemory();
    [CompilerGeneratedAttribute]
public void set_ClearMemoryCacheOnOutOfMemory(bool value);
    [CompilerGeneratedAttribute]
public bool get_InvalidateLayout();
    [CompilerGeneratedAttribute]
public void set_InvalidateLayout(bool value);
}
public class FFImageLoading.DataResolvers.DataUrlResolver : object {
    private static Regex _regex1;
    private static Regex _regex2;
    private static DataUrlResolver();
    public sealed virtual Task`1<DataResolverResult> Resolve(string identifier, TaskParameter parameters, CancellationToken token);
    private Task`1<DataResolverResult> GetBase64Stream(string data, ImageInformation imageInformation);
    private Task`1<DataResolverResult> GetRAWStream(string data, ImageInformation imageInformation);
}
public class FFImageLoading.DataResolvers.EmbeddedResourceResolver : object {
    public sealed virtual Task`1<DataResolverResult> Resolve(string identifier, TaskParameter parameters, CancellationToken token);
}
public class FFImageLoading.DataResolvers.StreamDataResolver : object {
    [AsyncStateMachineAttribute("FFImageLoading.DataResolvers.StreamDataResolver/<Resolve>d__0")]
public virtual Task`1<DataResolverResult> Resolve(string identifier, TaskParameter parameters, CancellationToken token);
}
public class FFImageLoading.DataResolvers.UrlDataResolver : object {
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    protected IDownloadCache DownloadCache { get; }
    protected Configuration Configuration { get; private set; }
    public UrlDataResolver(Configuration configuration);
    protected IDownloadCache get_DownloadCache();
    [CompilerGeneratedAttribute]
protected Configuration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(Configuration value);
    [AsyncStateMachineAttribute("FFImageLoading.DataResolvers.UrlDataResolver/<Resolve>d__7")]
public virtual Task`1<DataResolverResult> Resolve(string identifier, TaskParameter parameters, CancellationToken token);
}
public class FFImageLoading.DataResolvers.WrappedDataResolver : object {
    private IDataResolver _resolver;
    public WrappedDataResolver(IDataResolver resolver);
    [AsyncStateMachineAttribute("FFImageLoading.DataResolvers.WrappedDataResolver/<Resolve>d__2")]
public sealed virtual Task`1<DataResolverResult> Resolve(string identifier, TaskParameter parameters, CancellationToken token);
}
public class FFImageLoading.DataResolvers.WrappedDataResolverFactory : object {
    private IDataResolverFactory _factory;
    public WrappedDataResolverFactory(IDataResolverFactory factory);
    public sealed virtual IDataResolver GetResolver(string identifier, ImageSource source, TaskParameter parameters, Configuration configuration);
}
internal class FFImageLoading.DecodedImage`1 : object {
    [CompilerGeneratedAttribute]
private bool <IsAnimated>k__BackingField;
    [CompilerGeneratedAttribute]
private TNativeImageContainer <Image>k__BackingField;
    [CompilerGeneratedAttribute]
private IAnimatedImage`1[] <AnimatedImages>k__BackingField;
    public bool IsAnimated { get; public set; }
    public TNativeImageContainer Image { get; public set; }
    public IAnimatedImage`1[] AnimatedImages { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAnimated();
    [CompilerGeneratedAttribute]
public void set_IsAnimated(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual TNativeImageContainer get_Image();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Image(TNativeImageContainer value);
    [CompilerGeneratedAttribute]
public sealed virtual IAnimatedImage`1[] get_AnimatedImages();
    [CompilerGeneratedAttribute]
public void set_AnimatedImages(IAnimatedImage`1[] value);
}
public interface FFImageLoading.Decoders.IDecoder`1 {
    public abstract virtual Task`1<IDecodedImage`1<TDecoderContainer>> DecodeAsync(Stream stream, string path, ImageSource source, ImageInformation imageInformation, TaskParameter parameters);
}
public class FFImageLoading.DownloadInformation : ValueType {
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomCacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowDiskCaching>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <CacheValidity>k__BackingField;
    public string Url { get; internal set; }
    public string CustomCacheKey { get; internal set; }
    public string FileName { get; internal set; }
    public bool AllowDiskCaching { get; internal set; }
    public TimeSpan CacheValidity { get; internal set; }
    public DownloadInformation(string url, string customCacheKey, string fileName, bool allowDiskCaching, TimeSpan cacheValidity);
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
internal void set_Url(string value);
    [CompilerGeneratedAttribute]
public string get_CustomCacheKey();
    [CompilerGeneratedAttribute]
internal void set_CustomCacheKey(string value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
internal void set_FileName(string value);
    [CompilerGeneratedAttribute]
public bool get_AllowDiskCaching();
    [CompilerGeneratedAttribute]
internal void set_AllowDiskCaching(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_CacheValidity();
    [CompilerGeneratedAttribute]
internal void set_CacheValidity(TimeSpan value);
}
[IsReadOnlyAttribute]
public class FFImageLoading.DownloadProgress : ValueType {
    public int Current;
    public int Total;
    public DownloadProgress(int current, int total);
}
[PreserveAttribute]
public class FFImageLoading.Exceptions.DownloadAggregateException : AggregateException {
    public DownloadAggregateException(IEnumerable`1<Exception> exceptions);
}
[PreserveAttribute]
public class FFImageLoading.Exceptions.DownloadException : Exception {
    public DownloadException(string message);
}
[PreserveAttribute]
public class FFImageLoading.Exceptions.DownloadHeadersTimeoutException : Exception {
}
[PreserveAttribute]
public class FFImageLoading.Exceptions.DownloadHttpStatusCodeException : Exception {
    [CompilerGeneratedAttribute]
private HttpStatusCode <HttpStatusCode>k__BackingField;
    public HttpStatusCode HttpStatusCode { get; }
    public DownloadHttpStatusCodeException(HttpStatusCode httpStatusCode, string content);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_HttpStatusCode();
}
[PreserveAttribute]
public class FFImageLoading.Exceptions.DownloadReadTimeoutException : Exception {
}
[IsReadOnlyAttribute]
public class FFImageLoading.FileWriteInfo : ValueType {
    public string SourcePath;
    public string FilePath;
    public FileWriteInfo(string filePath, string sourcePath);
}
public class FFImageLoading.Helpers.EmptyPlatformPerformance : object {
    public sealed virtual int GetCurrentManagedThreadId();
    public sealed virtual int GetCurrentSystemThreadId();
    public sealed virtual string GetMemoryInfo();
}
internal class FFImageLoading.Helpers.Exif.ByteArrayReader : IndexedReader {
    private Byte[] _buffer;
    private int _baseOffset;
    public long Length { get; }
    public ByteArrayReader(Byte[] buffer, int baseOffset, bool isMotorolaByteOrder);
    public virtual IndexedReader WithByteOrder(bool isMotorolaByteOrder);
    public virtual IndexedReader WithShiftedBaseOffset(int shift);
    public virtual int ToUnshiftedOffset(int localOffset);
    public virtual long get_Length();
    public virtual byte GetByte(int index);
    protected virtual void ValidateIndex(int index, int bytesRequested);
    protected virtual bool IsValidIndex(int index, int bytesRequested);
    public virtual Byte[] GetBytes(int index, int count);
}
public abstract class FFImageLoading.Helpers.Exif.Directory : object {
    private Dictionary`2<int, object> _tagMap;
    private List`1<Tag> _definedTagList;
    private List`1<string> _errorList;
    private ITagDescriptor _descriptor;
    [CompilerGeneratedAttribute]
private Directory <Parent>k__BackingField;
    public string Name { get; }
    public Directory Parent { get; internal set; }
    public bool IsEmpty { get; }
    public IReadOnlyList`1<Tag> Tags { get; }
    public int TagCount { get; }
    public bool HasError { get; }
    public IReadOnlyList`1<string> Errors { get; }
    public abstract virtual string get_Name();
    [CompilerGeneratedAttribute]
public Directory get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(Directory value);
    protected abstract virtual bool TryGetTagName(int tagType, String& tagName);
    public bool get_IsEmpty();
    public bool ContainsTag(int tagType);
    public IReadOnlyList`1<Tag> get_Tags();
    public int get_TagCount();
    internal void SetDescriptor(ITagDescriptor descriptor);
    internal void AddError(string message);
    public bool get_HasError();
    public IReadOnlyList`1<string> get_Errors();
    internal virtual void Set(int tagType, object value);
    public object GetObject(int tagType);
    public string GetTagName(int tagType);
    public bool HasTagName(int tagType);
    public string GetValue(int tagType);
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class FFImageLoading.Helpers.Exif.DirectoryExtensions : object {
    [ExtensionAttribute]
public static string GetString(Directory directory, int tagType);
}
internal abstract class FFImageLoading.Helpers.Exif.DirectoryTiffHandler : object {
    private Stack`1<Directory> _directoryStack;
    [CompilerGeneratedAttribute]
private List`1<Directory> <Directories>k__BackingField;
    [CompilerGeneratedAttribute]
private Directory <CurrentDirectory>k__BackingField;
    protected List`1<Directory> Directories { get; }
    protected Directory CurrentDirectory { get; private set; }
    protected DirectoryTiffHandler(List`1<Directory> directories);
    [CompilerGeneratedAttribute]
protected List`1<Directory> get_Directories();
    [CompilerGeneratedAttribute]
protected Directory get_CurrentDirectory();
    [CompilerGeneratedAttribute]
private void set_CurrentDirectory(Directory value);
    public sealed virtual void EndingIfd();
    protected void PushDirectory(Directory directory);
    public sealed virtual void Warn(string message);
    public sealed virtual void Error(string message);
    private Directory GetCurrentOrErrorDirectory();
    public sealed virtual void SetByteArray(int tagId, Byte[] bytes);
    public sealed virtual void SetString(int tagId, StringValue stringValue);
    public sealed virtual void SetRational(int tagId, Rational rational);
    public sealed virtual void SetRationalArray(int tagId, Rational[] array);
    public sealed virtual void SetFloat(int tagId, float float32);
    public sealed virtual void SetFloatArray(int tagId, Single[] array);
    public sealed virtual void SetDouble(int tagId, double double64);
    public sealed virtual void SetDoubleArray(int tagId, Double[] array);
    public sealed virtual void SetInt8S(int tagId, sbyte int8S);
    public sealed virtual void SetInt8SArray(int tagId, SByte[] array);
    public sealed virtual void SetInt8U(int tagId, byte int8U);
    public sealed virtual void SetInt8UArray(int tagId, Byte[] array);
    public sealed virtual void SetInt16S(int tagId, short int16S);
    public sealed virtual void SetInt16SArray(int tagId, Int16[] array);
    public sealed virtual void SetInt16U(int tagId, ushort int16U);
    public sealed virtual void SetInt16UArray(int tagId, UInt16[] array);
    public sealed virtual void SetInt32S(int tagId, int int32S);
    public sealed virtual void SetInt32SArray(int tagId, Int32[] array);
    public sealed virtual void SetInt32U(int tagId, UInt32 int32U);
    public sealed virtual void SetInt32UArray(int tagId, UInt32[] array);
    public abstract virtual bool CustomProcessTag(int tagOffset, ICollection`1<int> processedIfdOffsets, IndexedReader reader, int tagId, int byteCount);
    public abstract virtual bool TryCustomProcessFormat(int tagId, TiffDataFormatCode formatCode, UInt32 componentCount, Int64& byteCount);
    public abstract virtual bool HasFollowerIfd();
    public abstract virtual bool TryEnterSubIfd(int tagType);
    public abstract virtual void SetTiffMarker(int marker);
}
internal class FFImageLoading.Helpers.Exif.ErrorDirectory : Directory {
    public string Name { get; }
    public ErrorDirectory(string error);
    public virtual string get_Name();
    protected virtual bool TryGetTagName(int tagType, String& tagName);
    internal virtual void Set(int tagType, object value);
}
internal abstract class FFImageLoading.Helpers.Exif.ExifDescriptorBase`1 : TagDescriptor`1<T> {
    protected ExifDescriptorBase`1(T directory);
    public virtual string GetDescription(int tagType);
}
public abstract class FFImageLoading.Helpers.Exif.ExifDirectoryBase : Directory {
    public static int TagInteropIndex;
    public static int TagInteropVersion;
    public static int TagNewSubfileType;
    public static int TagSubfileType;
    public static int TagImageWidth;
    public static int TagImageHeight;
    public static int TagBitsPerSample;
    public static int TagCompression;
    public static int TagPhotometricInterpretation;
    public static int TagThresholding;
    public static int TagFillOrder;
    public static int TagDocumentName;
    public static int TagImageDescription;
    public static int TagMake;
    public static int TagModel;
    public static int TagStripOffsets;
    public static int TagOrientation;
    public static int TagSamplesPerPixel;
    public static int TagRowsPerStrip;
    public static int TagStripByteCounts;
    public static int TagMinSampleValue;
    public static int TagMaxSampleValue;
    public static int TagXResolution;
    public static int TagYResolution;
    public static int TagPlanarConfiguration;
    public static int TagPageName;
    public static int TagResolutionUnit;
    public static int TagPageNumber;
    public static int TagTransferFunction;
    public static int TagSoftware;
    public static int TagDateTime;
    public static int TagArtist;
    public static int TagHostComputer;
    public static int TagPredictor;
    public static int TagWhitePoint;
    public static int TagPrimaryChromaticities;
    public static int TagTileWidth;
    public static int TagTileLength;
    public static int TagTileOffsets;
    public static int TagTileByteCounts;
    public static int TagSubIfdOffset;
    public static int TagTransferRange;
    public static int TagJpegTables;
    public static int TagJpegProc;
    public static int TagJpegRestartInterval;
    public static int TagJpegLosslessPredictors;
    public static int TagJpegPointTransforms;
    public static int TagJpegQTables;
    public static int TagJpegDcTables;
    public static int TagJpegAcTables;
    public static int TagYCbCrCoefficients;
    public static int TagYCbCrSubsampling;
    public static int TagYCbCrPositioning;
    public static int TagReferenceBlackWhite;
    public static int TagStripRowCounts;
    public static int TagApplicationNotes;
    public static int TagRelatedImageFileFormat;
    public static int TagRelatedImageWidth;
    public static int TagRelatedImageHeight;
    public static int TagRating;
    public static int TagCfaRepeatPatternDim;
    public static int TagCfaPattern2;
    public static int TagBatteryLevel;
    public static int TagCopyright;
    public static int TagExposureTime;
    public static int TagFNumber;
    public static int TagIptcNaa;
    public static int TagInterColorProfile;
    public static int TagExposureProgram;
    public static int TagSpectralSensitivity;
    public static int TagIsoEquivalent;
    public static int TagOptoElectricConversionFunction;
    public static int TagInterlace;
    public static int TagTimeZoneOffsetTiffEp;
    public static int TagSelfTimerModeTiffEp;
    public static int TagSensitivityType;
    public static int TagStandardOutputSensitivity;
    public static int TagRecommendedExposureIndex;
    public static int TagTimeZoneOffset;
    public static int TagSelfTimerMode;
    public static int TagExifVersion;
    public static int TagDateTimeOriginal;
    public static int TagDateTimeDigitized;
    public static int TagComponentsConfiguration;
    public static int TagCompressedAverageBitsPerPixel;
    public static int TagShutterSpeed;
    public static int TagAperture;
    public static int TagBrightnessValue;
    public static int TagExposureBias;
    public static int TagMaxAperture;
    public static int TagSubjectDistance;
    public static int TagMeteringMode;
    public static int TagWhiteBalance;
    public static int TagFlash;
    public static int TagFocalLength;
    public static int TagFlashEnergyTiffEp;
    public static int TagSpatialFreqResponseTiffEp;
    public static int TagNoise;
    public static int TagFocalPlaneXResolutionTiffEp;
    public static int TagFocalPlaneYResolutionTiffEp;
    public static int TagImageNumber;
    public static int TagSecurityClassification;
    public static int TagImageHistory;
    public static int TagSubjectLocationTiffEp;
    public static int TagExposureIndexTiffEp;
    public static int TagStandardIdTiffEp;
    public static int TagMakernote;
    public static int TagUserComment;
    public static int TagSubsecondTime;
    public static int TagSubsecondTimeOriginal;
    public static int TagSubsecondTimeDigitized;
    public static int TagWinTitle;
    public static int TagWinComment;
    public static int TagWinAuthor;
    public static int TagWinKeywords;
    public static int TagWinSubject;
    public static int TagFlashpixVersion;
    public static int TagColorSpace;
    public static int TagExifImageWidth;
    public static int TagExifImageHeight;
    public static int TagRelatedSoundFile;
    public static int TagFlashEnergy;
    public static int TagSpatialFreqResponse;
    public static int TagFocalPlaneXResolution;
    public static int TagFocalPlaneYResolution;
    public static int TagFocalPlaneResolutionUnit;
    public static int TagSubjectLocation;
    public static int TagExposureIndex;
    public static int TagSensingMethod;
    public static int TagFileSource;
    public static int TagSceneType;
    public static int TagCfaPattern;
    public static int TagCustomRendered;
    public static int TagExposureMode;
    public static int TagWhiteBalanceMode;
    public static int TagDigitalZoomRatio;
    public static int Tag35MMFilmEquivFocalLength;
    public static int TagSceneCaptureType;
    public static int TagGainControl;
    public static int TagContrast;
    public static int TagSaturation;
    public static int TagSharpness;
    public static int TagDeviceSettingDescription;
    public static int TagSubjectDistanceRange;
    public static int TagImageUniqueId;
    public static int TagCameraOwnerName;
    public static int TagBodySerialNumber;
    public static int TagLensSpecification;
    public static int TagLensMake;
    public static int TagLensModel;
    public static int TagLensSerialNumber;
    public static int TagGamma;
    public static int TagPrintImageMatchingInfo;
    public static int TagPanasonicTitle;
    public static int TagPanasonicTitle2;
    public static int TagPadding;
    public static int TagLens;
    protected static void AddExifTagNames(Dictionary`2<int, string> map);
}
internal class FFImageLoading.Helpers.Exif.ExifIfd0Descriptor : ExifDescriptorBase`1<ExifIfd0Directory> {
    public ExifIfd0Descriptor(ExifIfd0Directory directory);
}
internal class FFImageLoading.Helpers.Exif.ExifIfd0Directory : ExifDirectoryBase {
    public static int TagExifSubIfdOffset;
    public static int TagGpsInfoOffset;
    private static Dictionary`2<int, string> _tagNameMap;
    public string Name { get; }
    private static ExifIfd0Directory();
    public virtual string get_Name();
    protected virtual bool TryGetTagName(int tagType, String& tagName);
}
public enum FFImageLoading.Helpers.Exif.ExifOrientation : Enum {
    public int value__;
    public static ExifOrientation ORIENTATION_UNDEFINED;
    public static ExifOrientation ORIENTATION_NORMAL;
    public static ExifOrientation ORIENTATION_FLIP_HORIZONTAL;
    public static ExifOrientation ORIENTATION_ROTATE_180;
    public static ExifOrientation ORIENTATION_FLIP_VERTICAL;
    public static ExifOrientation ORIENTATION_TRANSPOSE;
    public static ExifOrientation ORIENTATION_ROTATE_90;
    public static ExifOrientation ORIENTATION_TRANSVERSE;
    public static ExifOrientation ORIENTATION_ROTATE_270;
}
internal class FFImageLoading.Helpers.Exif.ExifReader : object {
    public static string JpegSegmentPreamble;
    public ICollection`1<JpegSegmentType> SegmentTypes { get; }
    public sealed virtual ICollection`1<JpegSegmentType> get_SegmentTypes();
    public sealed virtual IReadOnlyList`1<Directory> ReadJpegSegments(IEnumerable`1<JpegSegment> segments);
    public IReadOnlyList`1<Directory> Extract(IndexedReader reader);
    [CompilerGeneratedAttribute]
private IEnumerable`1<Directory> <ReadJpegSegments>b__3_1(JpegSegment segment);
}
internal class FFImageLoading.Helpers.Exif.ExifSubIfdDescriptor : ExifDescriptorBase`1<ExifSubIfdDirectory> {
    public ExifSubIfdDescriptor(ExifSubIfdDirectory directory);
}
internal class FFImageLoading.Helpers.Exif.ExifSubIfdDirectory : ExifDirectoryBase {
    public static int TagInteropOffset;
    private static Dictionary`2<int, string> _tagNameMap;
    public string Name { get; }
    private static ExifSubIfdDirectory();
    public virtual string get_Name();
    protected virtual bool TryGetTagName(int tagType, String& tagName);
}
internal class FFImageLoading.Helpers.Exif.ExifTiffHandler : DirectoryTiffHandler {
    public ExifTiffHandler(List`1<Directory> directories);
    public virtual void SetTiffMarker(int marker);
    public virtual bool TryEnterSubIfd(int tagId);
    public virtual bool HasFollowerIfd();
    public virtual bool CustomProcessTag(int tagOffset, ICollection`1<int> processedIfdOffsets, IndexedReader reader, int tagId, int byteCount);
    public virtual bool TryCustomProcessFormat(int tagId, TiffDataFormatCode formatCode, UInt32 componentCount, Int64& byteCount);
    private static void ProcessBinary(Directory directory, int tagValueOffset, IndexedReader reader, int byteCount, bool issigned, int arrayLength);
}
internal interface FFImageLoading.Helpers.Exif.IJpegSegmentMetadataReader {
    public ICollection`1<JpegSegmentType> SegmentTypes { get; }
    public abstract virtual ICollection`1<JpegSegmentType> get_SegmentTypes();
    public abstract virtual IReadOnlyList`1<Directory> ReadJpegSegments(IEnumerable`1<JpegSegment> segments);
}
internal abstract class FFImageLoading.Helpers.Exif.IndexedReader : object {
    [CompilerGeneratedAttribute]
private bool <IsMotorolaByteOrder>k__BackingField;
    public bool IsMotorolaByteOrder { get; }
    public long Length { get; }
    protected IndexedReader(bool isMotorolaByteOrder);
    [CompilerGeneratedAttribute]
public bool get_IsMotorolaByteOrder();
    public abstract virtual IndexedReader WithByteOrder(bool isMotorolaByteOrder);
    public abstract virtual IndexedReader WithShiftedBaseOffset(int shift);
    public abstract virtual int ToUnshiftedOffset(int localOffset);
    public abstract virtual byte GetByte(int index);
    public abstract virtual Byte[] GetBytes(int index, int count);
    protected abstract virtual void ValidateIndex(int index, int bytesRequested);
    protected abstract virtual bool IsValidIndex(int index, int bytesRequested);
    public abstract virtual long get_Length();
    public bool GetBit(int index);
    public sbyte GetSByte(int index);
    public ushort GetUInt16(int index);
    public short GetInt16(int index);
    public int GetInt24(int index);
    public UInt32 GetUInt32(int index);
    public int GetInt32(int index);
    public long GetInt64(int index);
    public float GetS15Fixed16(int index);
    public float GetFloat32(int index);
    public double GetDouble64(int index);
    public string GetString(int index, int bytesRequested, Encoding encoding);
    public string GetNullTerminatedString(int index, int maxLengthBytes, Encoding encoding);
    public StringValue GetNullTerminatedStringValue(int index, int maxLengthBytes, Encoding encoding);
    public Byte[] GetNullTerminatedBytes(int index, int maxLengthBytes);
}
internal interface FFImageLoading.Helpers.Exif.ITagDescriptor {
    public abstract virtual string GetDescription(int tagType);
}
internal interface FFImageLoading.Helpers.Exif.ITiffHandler {
    public abstract virtual void SetTiffMarker(int marker);
    public abstract virtual bool TryEnterSubIfd(int tagType);
    public abstract virtual bool HasFollowerIfd();
    public abstract virtual void EndingIfd();
    public abstract virtual bool CustomProcessTag(int tagOffset, ICollection`1<int> processedIfdOffsets, IndexedReader reader, int tagId, int byteCount);
    public abstract virtual bool TryCustomProcessFormat(int tagId, TiffDataFormatCode formatCode, UInt32 componentCount, Int64& byteCount);
    public abstract virtual void Warn(string message);
    public abstract virtual void Error(string message);
    public abstract virtual void SetByteArray(int tagId, Byte[] bytes);
    public abstract virtual void SetString(int tagId, StringValue str);
    public abstract virtual void SetRational(int tagId, Rational rational);
    public abstract virtual void SetRationalArray(int tagId, Rational[] array);
    public abstract virtual void SetFloat(int tagId, float float32);
    public abstract virtual void SetFloatArray(int tagId, Single[] array);
    public abstract virtual void SetDouble(int tagId, double double64);
    public abstract virtual void SetDoubleArray(int tagId, Double[] array);
    public abstract virtual void SetInt8S(int tagId, sbyte int8S);
    public abstract virtual void SetInt8SArray(int tagId, SByte[] array);
    public abstract virtual void SetInt8U(int tagId, byte int8U);
    public abstract virtual void SetInt8UArray(int tagId, Byte[] array);
    public abstract virtual void SetInt16S(int tagId, short int16S);
    public abstract virtual void SetInt16SArray(int tagId, Int16[] array);
    public abstract virtual void SetInt16U(int tagId, ushort int16U);
    public abstract virtual void SetInt16UArray(int tagId, UInt16[] array);
    public abstract virtual void SetInt32S(int tagId, int int32S);
    public abstract virtual void SetInt32SArray(int tagId, Int32[] array);
    public abstract virtual void SetInt32U(int tagId, UInt32 int32U);
    public abstract virtual void SetInt32UArray(int tagId, UInt32[] array);
}
internal class FFImageLoading.Helpers.Exif.JpegSegment : object {
    [CompilerGeneratedAttribute]
private JpegSegmentType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Offset>k__BackingField;
    public JpegSegmentType Type { get; }
    public Byte[] Bytes { get; }
    public long Offset { get; }
    public JpegSegment(JpegSegmentType type, Byte[] bytes, long offset);
    [CompilerGeneratedAttribute]
public JpegSegmentType get_Type();
    [CompilerGeneratedAttribute]
public Byte[] get_Bytes();
    [CompilerGeneratedAttribute]
public long get_Offset();
}
internal static class FFImageLoading.Helpers.Exif.JpegSegmentReader : object {
    [IteratorStateMachineAttribute("FFImageLoading.Helpers.Exif.JpegSegmentReader/<ReadSegments>d__0")]
public static IEnumerable`1<JpegSegment> ReadSegments(SequentialReader reader, ICollection`1<JpegSegmentType> segmentTypes);
}
internal enum FFImageLoading.Helpers.Exif.JpegSegmentType : Enum {
    public byte value__;
    public static JpegSegmentType Tem;
    public static JpegSegmentType Soi;
    public static JpegSegmentType Dqt;
    public static JpegSegmentType Sof0;
    public static JpegSegmentType Sof1;
    public static JpegSegmentType Sof2;
    public static JpegSegmentType Sof3;
    public static JpegSegmentType Dht;
    public static JpegSegmentType Sof5;
    public static JpegSegmentType Sof6;
    public static JpegSegmentType Sof7;
    public static JpegSegmentType Sof9;
    public static JpegSegmentType Sof10;
    public static JpegSegmentType Sof11;
    public static JpegSegmentType Dac;
    public static JpegSegmentType Sof13;
    public static JpegSegmentType Sof14;
    public static JpegSegmentType Sof15;
    public static JpegSegmentType Rst0;
    public static JpegSegmentType Rst1;
    public static JpegSegmentType Rst2;
    public static JpegSegmentType Rst3;
    public static JpegSegmentType Rst4;
    public static JpegSegmentType Rst5;
    public static JpegSegmentType Rst6;
    public static JpegSegmentType Rst7;
    public static JpegSegmentType Eoi;
    public static JpegSegmentType Sos;
    public static JpegSegmentType Dnl;
    public static JpegSegmentType Dri;
    public static JpegSegmentType Dhp;
    public static JpegSegmentType Exp;
    public static JpegSegmentType App0;
    public static JpegSegmentType App1;
    public static JpegSegmentType App2;
    public static JpegSegmentType App3;
    public static JpegSegmentType App4;
    public static JpegSegmentType App5;
    public static JpegSegmentType App6;
    public static JpegSegmentType App7;
    public static JpegSegmentType App8;
    public static JpegSegmentType App9;
    public static JpegSegmentType AppA;
    public static JpegSegmentType AppB;
    public static JpegSegmentType AppC;
    public static JpegSegmentType AppD;
    public static JpegSegmentType AppE;
    public static JpegSegmentType AppF;
    public static JpegSegmentType Com;
}
internal class FFImageLoading.Helpers.Exif.Rational : ValueType {
    [CompilerGeneratedAttribute]
private long <Denominator>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Numerator>k__BackingField;
    public long Denominator { get; }
    public long Numerator { get; }
    public Rational Reciprocal { get; }
    public bool IsInteger { get; }
    public bool IsZero { get; }
    public Rational(long numerator, long denominator);
    [CompilerGeneratedAttribute]
public long get_Denominator();
    [CompilerGeneratedAttribute]
public long get_Numerator();
    public double ToDouble();
    public float ToSingle();
    public byte ToByte();
    public sbyte ToSByte();
    public int ToInt32();
    public UInt32 ToUInt32();
    public long ToInt64();
    public ulong ToUInt64();
    public short ToInt16();
    public ushort ToUInt16();
    public decimal ToDecimal();
    public bool ToBoolean();
    public Rational get_Reciprocal();
    public bool get_IsInteger();
    public bool get_IsZero();
    public virtual string ToString();
    public string ToString(IFormatProvider provider);
    public string ToSimpleString(bool allowDecimal, IFormatProvider provider);
    public sealed virtual bool Equals(Rational other);
    public bool EqualsExact(Rational other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Rational GetSimplifiedInstance();
    public static bool op_Equality(Rational a, Rational b);
    public static bool op_Inequality(Rational a, Rational b);
    [CompilerGeneratedAttribute]
internal static long <GetSimplifiedInstance>g__GCD|32_0(long a, long b);
}
internal abstract class FFImageLoading.Helpers.Exif.SequentialReader : object {
    [CompilerGeneratedAttribute]
private bool <IsMotorolaByteOrder>k__BackingField;
    public bool IsMotorolaByteOrder { get; }
    public long Position { get; }
    protected SequentialReader(bool isMotorolaByteOrder);
    [CompilerGeneratedAttribute]
public bool get_IsMotorolaByteOrder();
    public abstract virtual long get_Position();
    public abstract virtual SequentialReader WithByteOrder(bool isMotorolaByteOrder);
    public abstract virtual Byte[] GetBytes(int count);
    public abstract virtual void GetBytes(Byte[] buffer, int offset, int count);
    public abstract virtual void Skip(long n);
    public abstract virtual bool TrySkip(long n);
    public abstract virtual byte GetByte();
    public sbyte GetSByte();
    public ushort GetUInt16();
    public short GetInt16();
    public UInt32 GetUInt32();
    public int GetInt32();
    public long GetInt64();
    public float GetS15Fixed16();
    public float GetFloat32();
    public double GetDouble64();
    public string GetString(int bytesRequested, Encoding encoding);
    public StringValue GetStringValue(int bytesRequested, Encoding encoding);
    public string GetNullTerminatedString(int maxLengthBytes, Encoding encoding);
    public StringValue GetNullTerminatedStringValue(int maxLengthBytes, Encoding encoding);
    public Byte[] GetNullTerminatedBytes(int maxLengthBytes);
}
internal class FFImageLoading.Helpers.Exif.SequentialStreamReader : SequentialReader {
    private Stream _stream;
    public long Position { get; }
    public SequentialStreamReader(Stream stream, bool isMotorolaByteOrder);
    public virtual long get_Position();
    public virtual byte GetByte();
    public virtual SequentialReader WithByteOrder(bool isMotorolaByteOrder);
    public virtual Byte[] GetBytes(int count);
    public virtual void GetBytes(Byte[] buffer, int offset, int count);
    public virtual void Skip(long n);
    public virtual bool TrySkip(long n);
}
internal class FFImageLoading.Helpers.Exif.StringValue : ValueType {
    public static Encoding DefaultEncoding;
    [CompilerGeneratedAttribute]
private Byte[] <Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    public Byte[] Bytes { get; }
    public Encoding Encoding { get; }
    public StringValue(Byte[] bytes, Encoding encoding);
    private static StringValue();
    [CompilerGeneratedAttribute]
public Byte[] get_Bytes();
    [CompilerGeneratedAttribute]
public Encoding get_Encoding();
    public virtual string ToString();
    public string ToString(Encoding encoder);
}
public class FFImageLoading.Helpers.Exif.Tag : object {
    private Directory _directory;
    [CompilerGeneratedAttribute]
private int <Type>k__BackingField;
    public int Type { get; }
    public string Value { get; }
    public bool HasName { get; }
    public string Name { get; }
    public string DirectoryName { get; }
    internal Tag(int type, Directory directory);
    [CompilerGeneratedAttribute]
public int get_Type();
    public string get_Value();
    public bool get_HasName();
    public string get_Name();
    public string get_DirectoryName();
}
internal class FFImageLoading.Helpers.Exif.TagDescriptor`1 : object {
    protected T Directory;
    public TagDescriptor`1(T directory);
    public virtual string GetDescription(int tagType);
}
internal class FFImageLoading.Helpers.Exif.TiffDataFormat : object {
    public static TiffDataFormat Int8U;
    public static TiffDataFormat String;
    public static TiffDataFormat Int16U;
    public static TiffDataFormat Int32U;
    public static TiffDataFormat RationalU;
    public static TiffDataFormat Int8S;
    public static TiffDataFormat Undefined;
    public static TiffDataFormat Int16S;
    public static TiffDataFormat Int32S;
    public static TiffDataFormat RationalS;
    public static TiffDataFormat Single;
    public static TiffDataFormat Double;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ComponentSizeBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private TiffDataFormatCode <TiffFormatCode>k__BackingField;
    public string Name { get; }
    public int ComponentSizeBytes { get; }
    public TiffDataFormatCode TiffFormatCode { get; }
    private TiffDataFormat(string name, TiffDataFormatCode tiffFormatCode, int componentSizeBytes);
    private static TiffDataFormat();
    public static TiffDataFormat FromTiffFormatCode(TiffDataFormatCode tiffFormatCode);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_ComponentSizeBytes();
    [CompilerGeneratedAttribute]
public TiffDataFormatCode get_TiffFormatCode();
    public virtual string ToString();
}
internal enum FFImageLoading.Helpers.Exif.TiffDataFormatCode : Enum {
    public ushort value__;
    public static TiffDataFormatCode Int8U;
    public static TiffDataFormatCode String;
    public static TiffDataFormatCode Int16U;
    public static TiffDataFormatCode Int32U;
    public static TiffDataFormatCode RationalU;
    public static TiffDataFormatCode Int8S;
    public static TiffDataFormatCode Undefined;
    public static TiffDataFormatCode Int16S;
    public static TiffDataFormatCode Int32S;
    public static TiffDataFormatCode RationalS;
    public static TiffDataFormatCode Single;
    public static TiffDataFormatCode Double;
}
internal static class FFImageLoading.Helpers.Exif.TiffReader : object {
    public static void ProcessTiff(IndexedReader reader, ITiffHandler handler);
    public static void ProcessIfd(ITiffHandler handler, IndexedReader reader, ICollection`1<int> processedGlobalIfdOffsets, int ifdOffset);
    private static void ProcessTag(ITiffHandler handler, int tagId, int tagValueOffset, int componentCount, TiffDataFormatCode formatCode, IndexedReader reader);
    private static int CalculateTagOffset(int ifdStartOffset, int entryNumber);
}
internal static class FFImageLoading.Helpers.ExifHelper : object {
    private static ExifReader _exifReader;
    private static ExifHelper();
    public static IList`1<Directory> Read(Stream stream);
}
public static class FFImageLoading.Helpers.FileHeader : object {
    private static Byte[] _jpeg;
    private static Byte[] _png;
    private static Byte[] _svg;
    private static Byte[] _webp;
    private static Byte[] _gif;
    private static Byte[] _bmp;
    private static Byte[] _tiff;
    private static Byte[] _tiff2;
    private static Byte[] _ico;
    private static FileHeader();
    public static ImageType GetImageType(Byte[] header);
}
public enum FFImageLoading.Helpers.Gif.GifDecodeStatus : Enum {
    public int value__;
    public static GifDecodeStatus STATUS_OK;
    public static GifDecodeStatus STATUS_FORMAT_ERROR;
    public static GifDecodeStatus STATUS_OPEN_ERROR;
    public static GifDecodeStatus STATUS_PARTIAL_DECODE;
    public static GifDecodeStatus TOTAL_ITERATION_COUNT_FOREVER;
}
public class FFImageLoading.Helpers.Gif.GifFrame : object {
    [CompilerGeneratedAttribute]
private int <X>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Y>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Interlace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Transparency>k__BackingField;
    [CompilerGeneratedAttribute]
private Disposal <Dispose>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TransparencyIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Delay>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BufferFrameStart>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <LCT>k__BackingField;
    public int X { get; public set; }
    public int Y { get; public set; }
    public int Width { get; public set; }
    public int Height { get; public set; }
    public bool Interlace { get; public set; }
    public bool Transparency { get; public set; }
    public Disposal Dispose { get; public set; }
    public int TransparencyIndex { get; public set; }
    public int Delay { get; public set; }
    public int BufferFrameStart { get; public set; }
    public Int32[] LCT { get; public set; }
    [CompilerGeneratedAttribute]
public int get_X();
    [CompilerGeneratedAttribute]
public void set_X(int value);
    [CompilerGeneratedAttribute]
public int get_Y();
    [CompilerGeneratedAttribute]
public void set_Y(int value);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [CompilerGeneratedAttribute]
public bool get_Interlace();
    [CompilerGeneratedAttribute]
public void set_Interlace(bool value);
    [CompilerGeneratedAttribute]
public bool get_Transparency();
    [CompilerGeneratedAttribute]
public void set_Transparency(bool value);
    [CompilerGeneratedAttribute]
public Disposal get_Dispose();
    [CompilerGeneratedAttribute]
public void set_Dispose(Disposal value);
    [CompilerGeneratedAttribute]
public int get_TransparencyIndex();
    [CompilerGeneratedAttribute]
public void set_TransparencyIndex(int value);
    [CompilerGeneratedAttribute]
public int get_Delay();
    [CompilerGeneratedAttribute]
public void set_Delay(int value);
    [CompilerGeneratedAttribute]
public int get_BufferFrameStart();
    [CompilerGeneratedAttribute]
public void set_BufferFrameStart(int value);
    [CompilerGeneratedAttribute]
public Int32[] get_LCT();
    [CompilerGeneratedAttribute]
public void set_LCT(Int32[] value);
}
public class FFImageLoading.Helpers.Gif.GifHeader : object {
    [CompilerGeneratedAttribute]
private Int32[] <GCT>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<GifFrame> <Frames>k__BackingField;
    [CompilerGeneratedAttribute]
private GifFrame <CurrentFrame>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FrameCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GCTFlag>k__BackingField;
    [CompilerGeneratedAttribute]
private int <GCTSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PixelAspect>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BackgroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BackgroundIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LoopCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumFrames>k__BackingField;
    [CompilerGeneratedAttribute]
private GifDecodeStatus <Status>k__BackingField;
    public Int32[] GCT { get; public set; }
    public IList`1<GifFrame> Frames { get; public set; }
    public GifFrame CurrentFrame { get; public set; }
    public int FrameCount { get; public set; }
    public bool GCTFlag { get; public set; }
    public int GCTSize { get; public set; }
    public int PixelAspect { get; public set; }
    public int BackgroundColor { get; public set; }
    public int BackgroundIndex { get; public set; }
    public int LoopCount { get; public set; }
    public int Height { get; public set; }
    public int Width { get; public set; }
    public int NumFrames { get; public set; }
    public GifDecodeStatus Status { get; public set; }
    [CompilerGeneratedAttribute]
public Int32[] get_GCT();
    [CompilerGeneratedAttribute]
public void set_GCT(Int32[] value);
    [CompilerGeneratedAttribute]
public IList`1<GifFrame> get_Frames();
    [CompilerGeneratedAttribute]
public void set_Frames(IList`1<GifFrame> value);
    [CompilerGeneratedAttribute]
public GifFrame get_CurrentFrame();
    [CompilerGeneratedAttribute]
public void set_CurrentFrame(GifFrame value);
    [CompilerGeneratedAttribute]
public int get_FrameCount();
    [CompilerGeneratedAttribute]
public void set_FrameCount(int value);
    [CompilerGeneratedAttribute]
public bool get_GCTFlag();
    [CompilerGeneratedAttribute]
public void set_GCTFlag(bool value);
    [CompilerGeneratedAttribute]
public int get_GCTSize();
    [CompilerGeneratedAttribute]
public void set_GCTSize(int value);
    [CompilerGeneratedAttribute]
public int get_PixelAspect();
    [CompilerGeneratedAttribute]
public void set_PixelAspect(int value);
    [CompilerGeneratedAttribute]
public int get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(int value);
    [CompilerGeneratedAttribute]
public int get_BackgroundIndex();
    [CompilerGeneratedAttribute]
public void set_BackgroundIndex(int value);
    [CompilerGeneratedAttribute]
public int get_LoopCount();
    [CompilerGeneratedAttribute]
public void set_LoopCount(int value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
public void set_Height(int value);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
    [CompilerGeneratedAttribute]
public int get_NumFrames();
    [CompilerGeneratedAttribute]
public void set_NumFrames(int value);
    [CompilerGeneratedAttribute]
public GifDecodeStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(GifDecodeStatus value);
}
public class FFImageLoading.Helpers.Gif.GifHeaderParser : object {
    private static int MASK_INT_LOWEST_BYTE;
    private static int MIN_FRAME_DELAY;
    private static int LSD_MASK_GCT_FLAG;
    private static int LSD_MASK_GCT_SIZE;
    private static int IMAGE_SEPARATOR;
    private static int EXTENSION_INTRODUCER;
    private static int TRAILER;
    private static int LABEL_GRAPHIC_CONTROL_EXTENSION;
    private static int LABEL_APPLICATION_EXTENSION;
    private static int LABEL_COMMENT_EXTENSION;
    private static int LABEL_PLAIN_TEXT_EXTENSION;
    private static int GCE_MASK_DISPOSAL_METHOD;
    private static int GCE_DISPOSAL_METHOD_SHIFT;
    private static int GCE_MASK_TRANSPARENT_COLOR_FLAG;
    private static int DESCRIPTOR_MASK_LCT_FLAG;
    private static int DESCRIPTOR_MASK_INTERLACE_FLAG;
    private static int DESCRIPTOR_MASK_LCT_SIZE;
    private static int DEFAULT_FRAME_DELAY;
    private static int MAX_BLOCK_SIZE;
    private Byte[] _block;
    private int _blockSize;
    private Stream _rawData;
    private GifHeader _header;
    private bool Error { get; }
    public GifHeaderParser(Stream data);
    [AsyncStateMachineAttribute("FFImageLoading.Helpers.Gif.GifHeaderParser/<ParseHeaderAsync>d__24")]
public Task`1<GifHeader> ParseHeaderAsync();
    [AsyncStateMachineAttribute("FFImageLoading.Helpers.Gif.GifHeaderParser/<IsAnimatedAsync>d__25")]
public Task`1<bool> IsAnimatedAsync();
    [AsyncStateMachineAttribute("FFImageLoading.Helpers.Gif.GifHeaderParser/<ReadContentsAsync>d__26")]
private Task ReadContentsAsync();
    [AsyncStateMachineAttribute("FFImageLoading.Helpers.Gif.GifHeaderParser/<ReadContentsAsync>d__27")]
private Task ReadContentsAsync(int maxFrames);
    private void ReadGraphicControlExt();
    private void ReadBitmap();
    [AsyncStateMachineAttribute("FFImageLoading.Helpers.Gif.GifHeaderParser/<ReadNetscapeExtAsync>d__30")]
private Task ReadNetscapeExtAsync();
    private void ReadHeader();
    private void ReadLSD();
    private Int32[] ReadColorTable(int nColors);
    private void SkipImageData();
    private void Skip();
    [AsyncStateMachineAttribute("FFImageLoading.Helpers.Gif.GifHeaderParser/<ReadBlockAsync>d__36")]
private Task ReadBlockAsync();
    private int Read();
    private short ReadShort();
    private bool get_Error();
    public sealed virtual void Dispose();
}
internal static class FFImageLoading.Helpers.Gif.GifHelper : object {
    public static int GetValidFrameDelay(int ms);
    [AsyncStateMachineAttribute("FFImageLoading.Helpers.Gif.GifHelper/<CheckIfAnimatedAsync>d__1")]
public static Task`1<bool> CheckIfAnimatedAsync(Stream st);
}
public abstract class FFImageLoading.Helpers.Gif.GifHelperBase`1 : object {
    private static int MAX_STACK_SIZE;
    private static int NULL_CODE;
    private static int INITIAL_FRAME_POINTER;
    private static int BYTES_PER_INTEGER;
    private static int MASK_INT_LOWEST_BYTE;
    private static int COLOR_TRANSPARENT_BLACK;
    private static int TOTAL_ITERATION_COUNT_FOREVER;
    private Int32[] _act;
    private Int32[] _pct;
    private Byte[] _block;
    private Int16[] _prefix;
    private Byte[] _suffix;
    private Byte[] _pixelStack;
    private Byte[] _mainPixels;
    private Int32[] _mainScratch;
    private GifHeader _header;
    private TNativeImageContainer _previousImage;
    private bool _savePrevious;
    private int _sampleSize;
    [CompilerGeneratedAttribute]
private Stream <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private GifDecodeStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DownsampledHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DownsampledWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsFirstFrameTransparent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentFrameIndex>k__BackingField;
    public int Width { get; }
    public int Height { get; }
    protected Stream Data { get; private set; }
    public GifDecodeStatus Status { get; private set; }
    public int DownsampledHeight { get; private set; }
    public int DownsampledWidth { get; private set; }
    public Nullable`1<bool> IsFirstFrameTransparent { get; private set; }
    public int FrameCount { get; }
    public int CurrentFrameIndex { get; private set; }
    public int NetscapeLoopCount { get; }
    protected abstract virtual void Release(TNativeImageContainer bitmap);
    protected abstract virtual void SetPixels(TNativeImageContainer bitmap, Int32[] pixels, int width, int height);
    protected abstract virtual void GetPixels(TNativeImageContainer bitmap, Int32[] pixels, int width, int height);
    public int get_Width();
    public int get_Height();
    [CompilerGeneratedAttribute]
protected Stream get_Data();
    [CompilerGeneratedAttribute]
private void set_Data(Stream value);
    [CompilerGeneratedAttribute]
public GifDecodeStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(GifDecodeStatus value);
    [CompilerGeneratedAttribute]
public int get_DownsampledHeight();
    [CompilerGeneratedAttribute]
private void set_DownsampledHeight(int value);
    [CompilerGeneratedAttribute]
public int get_DownsampledWidth();
    [CompilerGeneratedAttribute]
private void set_DownsampledWidth(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsFirstFrameTransparent();
    [CompilerGeneratedAttribute]
private void set_IsFirstFrameTransparent(Nullable`1<bool> value);
    [AsyncStateMachineAttribute("FFImageLoading.Helpers.Gif.GifHelperBase`1/<ReadHeaderAsync>d__46")]
public Task ReadHeaderAsync(Stream input);
    [AsyncStateMachineAttribute("FFImageLoading.Helpers.Gif.GifHelperBase`1/<ReadAsync>d__47")]
public Task`1<GifDecodeStatus> ReadAsync(Stream input, int sampleSize);
    public void Advance();
    public int GetDelay(int n);
    public int GetNextDelay();
    public int get_FrameCount();
    [CompilerGeneratedAttribute]
public int get_CurrentFrameIndex();
    [CompilerGeneratedAttribute]
private void set_CurrentFrameIndex(int value);
    public void ResetFrameIndex();
    public int get_NetscapeLoopCount();
    public int GetTotalIterationCount();
    public int GetByteSize();
    [AsyncStateMachineAttribute("FFImageLoading.Helpers.Gif.GifHelperBase`1/<GetNextFrameAsync>d__62")]
public Task`1<TNativeImageContainer> GetNextFrameAsync();
    public void Clear();
    private void SetData(GifHeader header, Stream buffer, int sampleSize);
    [AsyncStateMachineAttribute("FFImageLoading.Helpers.Gif.GifHelperBase`1/<SetPixelsAsync>d__65")]
private Task`1<TNativeImageContainer> SetPixelsAsync(GifFrame currentFrame, GifFrame previousFrame);
    private void CopyIntoScratchFast(GifFrame currentFrame);
    private void CopyCopyIntoScratchRobust(GifFrame currentFrame);
    private int AverageColorsNear(int positionInMainPixels, int maxPositionInMainPixels, int currentFrameIw);
    [AsyncStateMachineAttribute("FFImageLoading.Helpers.Gif.GifHelperBase`1/<DecodeBitmapDataAsync>d__69")]
private Task DecodeBitmapDataAsync(GifFrame frame);
    private int ReadByte();
    [AsyncStateMachineAttribute("FFImageLoading.Helpers.Gif.GifHelperBase`1/<ReadBlockAsync>d__71")]
private Task`1<int> ReadBlockAsync();
    protected abstract virtual TNativeImageContainer GetNextBitmap();
    public sealed virtual void Dispose();
}
[PreserveAttribute]
public interface FFImageLoading.Helpers.IMainThreadDispatcher {
    public abstract virtual Task PostAsync(Action action);
    public abstract virtual Task PostAsync(Func`1<Task> action);
}
[PreserveAttribute]
public interface FFImageLoading.Helpers.IMD5Helper {
    public abstract virtual string MD5(string input);
    public abstract virtual string MD5(Stream stream);
}
[PreserveAttribute]
public interface FFImageLoading.Helpers.IMiniLogger {
    public abstract virtual void Debug(string message);
    public abstract virtual void Error(string errorMessage);
    public abstract virtual void Error(string errorMessage, Exception ex);
}
internal static class FFImageLoading.Helpers.StaticLocks : object {
    [CompilerGeneratedAttribute]
private static SemaphoreSlim <DecodingLock>k__BackingField;
    public static SemaphoreSlim DecodingLock { get; public set; }
    [CompilerGeneratedAttribute]
public static SemaphoreSlim get_DecodingLock();
    [CompilerGeneratedAttribute]
public static void set_DecodingLock(SemaphoreSlim value);
}
public interface FFImageLoading.IAnimatedImage`1 {
    public int Delay { get; public set; }
    public TNativeImageContainer Image { get; public set; }
    public abstract virtual int get_Delay();
    public abstract virtual void set_Delay(int value);
    public abstract virtual TNativeImageContainer get_Image();
    public abstract virtual void set_Image(TNativeImageContainer value);
}
public interface FFImageLoading.IDecodedImage`1 {
    public bool IsAnimated { get; }
    public TNativeImageContainer Image { get; public set; }
    public IAnimatedImage`1[] AnimatedImages { get; }
    public abstract virtual bool get_IsAnimated();
    public abstract virtual TNativeImageContainer get_Image();
    public abstract virtual void set_Image(TNativeImageContainer value);
    public abstract virtual IAnimatedImage`1[] get_AnimatedImages();
}
[PreserveAttribute]
public interface FFImageLoading.IImageService {
    public Configuration Config { get; }
    public bool ExitTasksEarly { get; }
    public bool PauseWork { get; }
    public abstract virtual Configuration get_Config();
    public abstract virtual void Initialize();
    public abstract virtual void Initialize(Configuration configuration);
    public abstract virtual TaskParameter LoadFile(string filepath);
    public abstract virtual TaskParameter LoadUrl(string url, Nullable`1<TimeSpan> cacheDuration);
    public abstract virtual TaskParameter LoadString(string data, DataEncodingType encoding);
    public abstract virtual TaskParameter LoadBase64String(string data);
    public abstract virtual TaskParameter LoadFileFromApplicationBundle(string filepath);
    public abstract virtual TaskParameter LoadCompiledResource(string resourceName);
    public abstract virtual TaskParameter LoadEmbeddedResource(string resourceUri);
    public abstract virtual TaskParameter LoadEmbeddedResource(string resourceName, Assembly resourceAssembly);
    public abstract virtual TaskParameter LoadStream(Func`2<CancellationToken, Task`1<Stream>> stream);
    public abstract virtual bool get_ExitTasksEarly();
    public abstract virtual void SetExitTasksEarly(bool exitTasksEarly);
    public abstract virtual bool get_PauseWork();
    public abstract virtual void SetPauseWork(bool pauseWork, bool cancelExisting);
    public abstract virtual void SetPauseWorkAndCancelExisting(bool pauseWork);
    public abstract virtual void CancelWorkFor(IImageLoaderTask task);
    public abstract virtual void CancelWorkForView(object view);
    public abstract virtual void RemovePendingTask(IImageLoaderTask task);
    public abstract virtual void LoadImage(IImageLoaderTask task);
    public abstract virtual Task InvalidateCacheAsync(CacheType cacheType);
    public abstract virtual void InvalidateMemoryCache();
    public abstract virtual Task InvalidateDiskCacheAsync();
    public abstract virtual Task InvalidateCacheEntryAsync(string key, CacheType cacheType, bool removeSimilar);
    public abstract virtual void Cancel(Func`2<IImageLoaderTask, bool> predicate);
    public abstract virtual void Cancel(Func`2<TaskParameter, bool> predicate);
    public abstract virtual int DpToPixels(double dp);
    public abstract virtual double PixelsToDp(double px);
}
public abstract class FFImageLoading.ImageServiceBase`1 : object {
    protected bool _initialized;
    protected bool _isInitializing;
    protected object _initializeLock;
    private Configuration _config;
    public Configuration Config { get; }
    public bool ExitTasksEarly { get; }
    public bool PauseWork { get; }
    protected IDiskCache DiskCache { get; }
    protected IWorkScheduler Scheduler { get; }
    protected IMD5Helper MD5Helper { get; }
    protected IMemoryCache`1<TImageContainer> MemoryCache { get; }
    protected virtual void PlatformSpecificConfiguration(Configuration configuration);
    protected abstract virtual IMD5Helper CreatePlatformMD5HelperInstance(Configuration configuration);
    protected abstract virtual IMiniLogger CreatePlatformLoggerInstance(Configuration configuration);
    protected abstract virtual IDiskCache CreatePlatformDiskCacheInstance(Configuration configuration);
    protected abstract virtual IPlatformPerformance CreatePlatformPerformanceInstance(Configuration configuration);
    protected abstract virtual IMainThreadDispatcher CreateMainThreadDispatcherInstance(Configuration configuration);
    protected abstract virtual IDataResolverFactory CreateDataResolverFactoryInstance(Configuration configuration);
    protected abstract virtual void SetTaskForTarget(IImageLoaderTask currentTask);
    public abstract virtual void CancelWorkForView(object view);
    public abstract virtual int DpToPixels(double dp);
    public abstract virtual double PixelsToDp(double px);
    public sealed virtual Configuration get_Config();
    public sealed virtual bool get_ExitTasksEarly();
    public sealed virtual bool get_PauseWork();
    protected IDiskCache get_DiskCache();
    protected IWorkScheduler get_Scheduler();
    protected IMD5Helper get_MD5Helper();
    protected abstract virtual IMemoryCache`1<TImageContainer> get_MemoryCache();
    public sealed virtual void Initialize();
    public sealed virtual void Initialize(Configuration configuration);
    private void InitializeIfNeeded(Configuration userDefinedConfig);
    public sealed virtual TaskParameter LoadFile(string filepath);
    public sealed virtual TaskParameter LoadUrl(string url, Nullable`1<TimeSpan> cacheDuration);
    public sealed virtual TaskParameter LoadString(string data, DataEncodingType encoding);
    public sealed virtual TaskParameter LoadBase64String(string data);
    public sealed virtual TaskParameter LoadFileFromApplicationBundle(string filepath);
    public sealed virtual TaskParameter LoadCompiledResource(string resourceName);
    public sealed virtual TaskParameter LoadEmbeddedResource(string resourceUri);
    public sealed virtual TaskParameter LoadEmbeddedResource(string resourceName, Assembly resourceAssembly);
    public sealed virtual TaskParameter LoadStream(Func`2<CancellationToken, Task`1<Stream>> stream);
    [ObsoleteAttribute("Use SetPauseWork(bool pauseWork, bool cancelExistingTasks = false)")]
public sealed virtual void SetExitTasksEarly(bool exitTasksEarly);
    public sealed virtual void SetPauseWorkAndCancelExisting(bool pauseWork);
    public sealed virtual void SetPauseWork(bool pauseWork, bool cancelExisting);
    public sealed virtual void CancelWorkFor(IImageLoaderTask task);
    public sealed virtual void RemovePendingTask(IImageLoaderTask task);
    public sealed virtual void LoadImage(IImageLoaderTask task);
    [AsyncStateMachineAttribute("FFImageLoading.ImageServiceBase`1/<InvalidateCacheAsync>d__47")]
public sealed virtual Task InvalidateCacheAsync(CacheType cacheType);
    public sealed virtual void InvalidateMemoryCache();
    public sealed virtual Task InvalidateDiskCacheAsync();
    [AsyncStateMachineAttribute("FFImageLoading.ImageServiceBase`1/<InvalidateCacheEntryAsync>d__50")]
public sealed virtual Task InvalidateCacheEntryAsync(string key, CacheType cacheType, bool removeSimilar);
    public sealed virtual void Cancel(Func`2<IImageLoaderTask, bool> predicate);
    public sealed virtual void Cancel(Func`2<TaskParameter, bool> predicate);
}
[ExtensionAttribute]
public static class FFImageLoading.IntExtensions : object {
    [ExtensionAttribute]
public static int HighestOneBit(int number);
}
[PreserveAttribute]
public interface FFImageLoading.IPlatformPerformance {
    public abstract virtual int GetCurrentManagedThreadId();
    public abstract virtual int GetCurrentSystemThreadId();
    public abstract virtual string GetMemoryInfo();
}
[PreserveAttribute]
internal class FFImageLoading.MiniLoggerWrapper : object {
    private IMiniLogger _logger;
    private bool _verboseLogging;
    public MiniLoggerWrapper(IMiniLogger logger, bool verboseLogging);
    public sealed virtual void Debug(string message);
    public sealed virtual void Error(string errorMessage);
    public sealed virtual void Error(string errorMessage, Exception ex);
}
[ExtensionAttribute]
public static class FFImageLoading.ObjectExtensions : object {
    [ExtensionAttribute]
public static bool TryDispose(IDisposable obj);
}
[AttributeUsageAttribute("6141")]
public class FFImageLoading.PreserveAttribute : Attribute {
    public bool AllMembers;
    public bool Conditional;
}
public class FFImageLoading.QueueComparer`1 : Comparer`1<TPriority> {
    private Comparer`1<TPriority> _comparer;
    public virtual int Compare(TPriority x, TPriority y);
}
[PreserveAttribute]
public static class FFImageLoading.Retry : object {
    [AsyncStateMachineAttribute("FFImageLoading.Retry/<DoAsync>d__0`1")]
public static Task`1<T> DoAsync(Func`1<Task`1<T>> action, TimeSpan retryInterval, int retryCount, Action onRetry);
}
[ExtensionAttribute]
public static class FFImageLoading.StreamExtensions : object {
    [AsyncStateMachineAttribute("FFImageLoading.StreamExtensions/<AsSeekableStreamAsync>d__0")]
[ExtensionAttribute]
public static Task`1<Stream> AsSeekableStreamAsync(Stream stream, bool forceCopy);
    [ExtensionAttribute]
public static Byte[] ToByteArray(Stream stream);
}
[ExtensionAttribute]
[PreserveAttribute]
public static class FFImageLoading.StringExtensions : object {
    [ExtensionAttribute]
public static string ToSanitizedKey(string key);
    [ExtensionAttribute]
public static bool Contains(string source, string toCheck, StringComparison comp);
    [ExtensionAttribute]
public static bool IsDataUrl(string str);
    [ExtensionAttribute]
public static bool IsSvgFileUrl(string str);
    [ExtensionAttribute]
public static bool IsSvgDataUrl(string str);
}
public class FFImageLoading.ThreadSafeCollection`1 : object {
    private List`1<T> _list;
    private object _lock;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual bool Remove(T item);
    public void RemoveAll(Func`2<T, bool> predicate);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class FFImageLoading.Transformations.FFColorMatrix : object {
    public static Single[][] GrayscaleColorMatrix;
    public static Single[][] InvertColorMatrix;
    public static Single[][] SepiaColorMatrix;
    public static Single[][] BlackAndWhiteColorMatrix;
    public static Single[][] PolaroidColorMatrix;
    public static Single[][] WhiteToAlphaColorMatrix;
    private static FFColorMatrix();
    public static Single[][] ColorToTintMatrix(int r, int g, int b, int a);
}
public interface FFImageLoading.Views.ICachedImageView {
    public bool IsLoading { get; }
    public int RetryCount { get; public set; }
    public int RetryDelay { get; public set; }
    public int LoadingDelay { get; public set; }
    public double DownsampleWidth { get; public set; }
    public double DownsampleHeight { get; public set; }
    public bool DownsampleUseDipUnits { get; public set; }
    public Nullable`1<TimeSpan> CacheDuration { get; public set; }
    public LoadingPriority LoadingPriority { get; public set; }
    public Nullable`1<bool> BitmapOptimizations { get; public set; }
    public Nullable`1<bool> FadeAnimationEnabled { get; public set; }
    public Nullable`1<int> FadeAnimationDuration { get; public set; }
    public Nullable`1<bool> FadeAnimationForCachedImages { get; public set; }
    public Nullable`1<bool> TransformPlaceholders { get; public set; }
    public Nullable`1<CacheType> CacheType { get; public set; }
    public List`1<ITransformation> Transformations { get; public set; }
    public Nullable`1<bool> InvalidateLayoutAfterLoaded { get; public set; }
    public IDataResolver CustomDataResolver { get; public set; }
    public IDataResolver CustomLoadingPlaceholderDataResolver { get; public set; }
    public IDataResolver CustomErrorPlaceholderDataResolver { get; public set; }
    public abstract virtual bool get_IsLoading();
    public abstract virtual int get_RetryCount();
    public abstract virtual void set_RetryCount(int value);
    public abstract virtual int get_RetryDelay();
    public abstract virtual void set_RetryDelay(int value);
    public abstract virtual int get_LoadingDelay();
    public abstract virtual void set_LoadingDelay(int value);
    public abstract virtual double get_DownsampleWidth();
    public abstract virtual void set_DownsampleWidth(double value);
    public abstract virtual double get_DownsampleHeight();
    public abstract virtual void set_DownsampleHeight(double value);
    public abstract virtual bool get_DownsampleUseDipUnits();
    public abstract virtual void set_DownsampleUseDipUnits(bool value);
    public abstract virtual Nullable`1<TimeSpan> get_CacheDuration();
    public abstract virtual void set_CacheDuration(Nullable`1<TimeSpan> value);
    public abstract virtual LoadingPriority get_LoadingPriority();
    public abstract virtual void set_LoadingPriority(LoadingPriority value);
    public abstract virtual Nullable`1<bool> get_BitmapOptimizations();
    public abstract virtual void set_BitmapOptimizations(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_FadeAnimationEnabled();
    public abstract virtual void set_FadeAnimationEnabled(Nullable`1<bool> value);
    public abstract virtual Nullable`1<int> get_FadeAnimationDuration();
    public abstract virtual void set_FadeAnimationDuration(Nullable`1<int> value);
    public abstract virtual Nullable`1<bool> get_FadeAnimationForCachedImages();
    public abstract virtual void set_FadeAnimationForCachedImages(Nullable`1<bool> value);
    public abstract virtual Nullable`1<bool> get_TransformPlaceholders();
    public abstract virtual void set_TransformPlaceholders(Nullable`1<bool> value);
    public abstract virtual Nullable`1<CacheType> get_CacheType();
    public abstract virtual void set_CacheType(Nullable`1<CacheType> value);
    public abstract virtual List`1<ITransformation> get_Transformations();
    public abstract virtual void set_Transformations(List`1<ITransformation> value);
    public abstract virtual Nullable`1<bool> get_InvalidateLayoutAfterLoaded();
    public abstract virtual void set_InvalidateLayoutAfterLoaded(Nullable`1<bool> value);
    public abstract virtual IDataResolver get_CustomDataResolver();
    public abstract virtual void set_CustomDataResolver(IDataResolver value);
    public abstract virtual IDataResolver get_CustomLoadingPlaceholderDataResolver();
    public abstract virtual void set_CustomLoadingPlaceholderDataResolver(IDataResolver value);
    public abstract virtual IDataResolver get_CustomErrorPlaceholderDataResolver();
    public abstract virtual void set_CustomErrorPlaceholderDataResolver(IDataResolver value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnSuccess(EventHandler`1<SuccessEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnSuccess(EventHandler`1<SuccessEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnError(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnError(EventHandler`1<ErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnFinish(EventHandler`1<FinishEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnFinish(EventHandler`1<FinishEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnDownloadStarted(EventHandler`1<DownloadStartedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnDownloadStarted(EventHandler`1<DownloadStartedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnDownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnDownloadProgress(EventHandler`1<DownloadProgressEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OnFileWriteFinished(EventHandler`1<FileWriteFinishedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OnFileWriteFinished(EventHandler`1<FileWriteFinishedEventArgs> value);
}
public enum FFImageLoading.Work.DataEncodingType : Enum {
    public int value__;
    public static DataEncodingType RAW;
    public static DataEncodingType Base64Encoded;
}
public class FFImageLoading.Work.DataResolverResult : object {
    [CompilerGeneratedAttribute]
private Stream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private IDecodedImage`1<object> <Decoded>k__BackingField;
    [CompilerGeneratedAttribute]
private LoadingResult <LoadingResult>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageInformation <ImageInformation>k__BackingField;
    public Stream Stream { get; internal set; }
    public IDecodedImage`1<object> Decoded { get; internal set; }
    public LoadingResult LoadingResult { get; internal set; }
    public ImageInformation ImageInformation { get; internal set; }
    public DataResolverResult(IDecodedImage`1<object> decoded, LoadingResult loadingResult, ImageInformation imageInformation);
    public DataResolverResult(Stream stream, LoadingResult loadingResult, ImageInformation imageInformation);
    [CompilerGeneratedAttribute]
public Stream get_Stream();
    [CompilerGeneratedAttribute]
internal void set_Stream(Stream value);
    [CompilerGeneratedAttribute]
public IDecodedImage`1<object> get_Decoded();
    [CompilerGeneratedAttribute]
internal void set_Decoded(IDecodedImage`1<object> value);
    [CompilerGeneratedAttribute]
public LoadingResult get_LoadingResult();
    [CompilerGeneratedAttribute]
internal void set_LoadingResult(LoadingResult value);
    [CompilerGeneratedAttribute]
public ImageInformation get_ImageInformation();
    [CompilerGeneratedAttribute]
internal void set_ImageInformation(ImageInformation value);
}
public interface FFImageLoading.Work.IBitmap {
    public int Width { get; }
    public int Height { get; }
    public abstract virtual int get_Width();
    public abstract virtual int get_Height();
}
public interface FFImageLoading.Work.IDataResolver {
    public abstract virtual Task`1<DataResolverResult> Resolve(string identifier, TaskParameter parameters, CancellationToken token);
}
public interface FFImageLoading.Work.IDataResolverFactory {
    public abstract virtual IDataResolver GetResolver(string identifier, ImageSource source, TaskParameter parameters, Configuration configuration);
}
[PreserveAttribute]
public interface FFImageLoading.Work.IImageLoaderTask {
    public TaskParameter Parameters { get; }
    public bool CanUseMemoryCache { get; }
    public string Key { get; }
    public string KeyRaw { get; }
    public ITarget Target { get; }
    public Configuration Configuration { get; }
    public ImageInformation ImageInformation { get; }
    public DownloadInformation DownloadInformation { get; }
    public abstract virtual Task Init();
    public abstract virtual TaskParameter get_Parameters();
    public abstract virtual bool get_CanUseMemoryCache();
    public abstract virtual string get_Key();
    public abstract virtual string get_KeyRaw();
    public abstract virtual Task`1<bool> TryLoadFromMemoryCacheAsync();
    public abstract virtual Task RunAsync();
    public abstract virtual ITarget get_Target();
    public abstract virtual Configuration get_Configuration();
    public abstract virtual ImageInformation get_ImageInformation();
    public abstract virtual DownloadInformation get_DownloadInformation();
}
public class FFImageLoading.Work.ImageInformation : object {
    [CompilerGeneratedAttribute]
private IList`1<Directory> <Exif>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CurrentHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OriginalWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private int <OriginalHeight>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserCustomCacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageType <Type>k__BackingField;
    public IList`1<Directory> Exif { get; private set; }
    public int CurrentWidth { get; private set; }
    public int CurrentHeight { get; private set; }
    public int OriginalWidth { get; private set; }
    public int OriginalHeight { get; private set; }
    public string Path { get; private set; }
    public string FilePath { get; private set; }
    public string CacheKey { get; private set; }
    public string UserCustomCacheKey { get; private set; }
    public ImageType Type { get; private set; }
    internal string BaseKey { get; }
    internal void SetCurrentSize(int width, int height);
    internal void SetOriginalSize(int width, int height);
    internal void SetPath(string path);
    internal void SetFilePath(string filePath);
    internal void SetKey(string cacheKey, string userCustomCacheKey);
    internal void SetType(ImageType type);
    internal void SetExif(IList`1<Directory> exif);
    [CompilerGeneratedAttribute]
public IList`1<Directory> get_Exif();
    [CompilerGeneratedAttribute]
private void set_Exif(IList`1<Directory> value);
    [CompilerGeneratedAttribute]
public int get_CurrentWidth();
    [CompilerGeneratedAttribute]
private void set_CurrentWidth(int value);
    [CompilerGeneratedAttribute]
public int get_CurrentHeight();
    [CompilerGeneratedAttribute]
private void set_CurrentHeight(int value);
    [CompilerGeneratedAttribute]
public int get_OriginalWidth();
    [CompilerGeneratedAttribute]
private void set_OriginalWidth(int value);
    [CompilerGeneratedAttribute]
public int get_OriginalHeight();
    [CompilerGeneratedAttribute]
private void set_OriginalHeight(int value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
private void set_FilePath(string value);
    [CompilerGeneratedAttribute]
public string get_CacheKey();
    [CompilerGeneratedAttribute]
private void set_CacheKey(string value);
    [CompilerGeneratedAttribute]
public string get_UserCustomCacheKey();
    [CompilerGeneratedAttribute]
private void set_UserCustomCacheKey(string value);
    [CompilerGeneratedAttribute]
public ImageType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(ImageType value);
    internal string get_BaseKey();
}
public abstract class FFImageLoading.Work.ImageLoaderTask`3 : object {
    private bool _isLoadingPlaceholderLoaded;
    protected static SemaphoreSlim _placeholdersResolveLock;
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    private ImageInformation _imageInformation;
    [CompilerGeneratedAttribute]
private DownloadInformation <DownloadInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private ITarget`2<TImageContainer, TImageView> <PlatformTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private IImageService <ImageService>k__BackingField;
    [CompilerGeneratedAttribute]
private IMemoryCache`1<TImageContainer> <MemoryCache>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataResolverFactory <DataResolverFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationTokenSource <CancellationTokenSource>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanUseMemoryCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyRaw>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyWithoutTransformations>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyTransformationsOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyDownsamplingOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyForLoadingPlaceholder>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyForErrorPlaceholder>k__BackingField;
    [CompilerGeneratedAttribute]
private WeakReference`1<TImageContainer> <PlaceholderWeakReference>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskParameter <Parameters>k__BackingField;
    private bool _isDisposed;
    public Configuration Configuration { get; private set; }
    public ImageInformation ImageInformation { get; private set; }
    public DownloadInformation DownloadInformation { get; private set; }
    public ITarget`2<TImageContainer, TImageView> PlatformTarget { get; private set; }
    public ITarget Target { get; }
    protected IImageService ImageService { get; private set; }
    protected IMemoryCache`1<TImageContainer> MemoryCache { get; private set; }
    protected IDataResolverFactory DataResolverFactory { get; private set; }
    protected IDiskCache DiskCache { get; }
    protected IDownloadCache DownloadCache { get; }
    protected IMiniLogger Logger { get; }
    protected CancellationTokenSource CancellationTokenSource { get; private set; }
    protected IMainThreadDispatcher MainThreadDispatcher { get; }
    public bool IsCancelled { get; }
    public bool CanUseMemoryCache { get; private set; }
    public bool IsCompleted { get; private set; }
    public string Key { get; private set; }
    public string KeyRaw { get; private set; }
    public string KeyWithoutTransformations { get; private set; }
    protected string KeyTransformationsOnly { get; private set; }
    protected string KeyDownsamplingOnly { get; private set; }
    protected string KeyForLoadingPlaceholder { get; private set; }
    protected string KeyForErrorPlaceholder { get; private set; }
    protected WeakReference`1<TImageContainer> PlaceholderWeakReference { get; private set; }
    protected bool TransformPlaceholders { get; }
    public TaskParameter Parameters { get; private set; }
    protected ImageLoaderTask`3(IMemoryCache`1<TImageContainer> memoryCache, ITarget`2<TImageContainer, TImageView> target, TaskParameter parameters, IImageService imageService);
    private static ImageLoaderTask`3();
    [AsyncStateMachineAttribute("FFImageLoading.Work.ImageLoaderTask`3/<Init>d__3")]
public virtual Task Init();
    private void SetKeys();
    [CompilerGeneratedAttribute]
public sealed virtual Configuration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(Configuration value);
    public sealed virtual ImageInformation get_ImageInformation();
    private void set_ImageInformation(ImageInformation value);
    [CompilerGeneratedAttribute]
public sealed virtual DownloadInformation get_DownloadInformation();
    [CompilerGeneratedAttribute]
private void set_DownloadInformation(DownloadInformation value);
    [CompilerGeneratedAttribute]
public ITarget`2<TImageContainer, TImageView> get_PlatformTarget();
    [CompilerGeneratedAttribute]
private void set_PlatformTarget(ITarget`2<TImageContainer, TImageView> value);
    public sealed virtual ITarget get_Target();
    [CompilerGeneratedAttribute]
protected IImageService get_ImageService();
    [CompilerGeneratedAttribute]
private void set_ImageService(IImageService value);
    [CompilerGeneratedAttribute]
protected IMemoryCache`1<TImageContainer> get_MemoryCache();
    [CompilerGeneratedAttribute]
private void set_MemoryCache(IMemoryCache`1<TImageContainer> value);
    [CompilerGeneratedAttribute]
protected IDataResolverFactory get_DataResolverFactory();
    [CompilerGeneratedAttribute]
private void set_DataResolverFactory(IDataResolverFactory value);
    protected IDiskCache get_DiskCache();
    protected IDownloadCache get_DownloadCache();
    protected IMiniLogger get_Logger();
    [CompilerGeneratedAttribute]
protected CancellationTokenSource get_CancellationTokenSource();
    [CompilerGeneratedAttribute]
private void set_CancellationTokenSource(CancellationTokenSource value);
    protected IMainThreadDispatcher get_MainThreadDispatcher();
    protected abstract virtual int DpiToPixels(int size);
    protected abstract virtual IDecoder`1<TDecoderContainer> ResolveDecoder(ImageType type);
    protected abstract virtual Task`1<TDecoderContainer> TransformAsync(TDecoderContainer bitmap, IList`1<ITransformation> transformations, string path, ImageSource source, bool isPlaceholder);
    public sealed virtual bool get_IsCancelled();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanUseMemoryCache();
    [CompilerGeneratedAttribute]
private void set_CanUseMemoryCache(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void set_IsCompleted(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_KeyRaw();
    [CompilerGeneratedAttribute]
private void set_KeyRaw(string value);
    [CompilerGeneratedAttribute]
public string get_KeyWithoutTransformations();
    [CompilerGeneratedAttribute]
private void set_KeyWithoutTransformations(string value);
    [CompilerGeneratedAttribute]
protected string get_KeyTransformationsOnly();
    [CompilerGeneratedAttribute]
private void set_KeyTransformationsOnly(string value);
    [CompilerGeneratedAttribute]
protected string get_KeyDownsamplingOnly();
    [CompilerGeneratedAttribute]
private void set_KeyDownsamplingOnly(string value);
    [CompilerGeneratedAttribute]
protected string get_KeyForLoadingPlaceholder();
    [CompilerGeneratedAttribute]
private void set_KeyForLoadingPlaceholder(string value);
    [CompilerGeneratedAttribute]
protected string get_KeyForErrorPlaceholder();
    [CompilerGeneratedAttribute]
private void set_KeyForErrorPlaceholder(string value);
    [CompilerGeneratedAttribute]
protected WeakReference`1<TImageContainer> get_PlaceholderWeakReference();
    [CompilerGeneratedAttribute]
private void set_PlaceholderWeakReference(WeakReference`1<TImageContainer> value);
    protected bool get_TransformPlaceholders();
    [CompilerGeneratedAttribute]
public sealed virtual TaskParameter get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(TaskParameter value);
    protected void ThrowIfCancellationRequested();
    public sealed virtual void Cancel();
    protected abstract virtual Task`1<TImageContainer> GenerateImageFromDecoderContainerAsync(IDecodedImage`1<TDecoderContainer> decoded, ImageInformation imageInformation, bool isPlaceholder);
    protected abstract virtual Task SetTargetAsync(TImageContainer image, bool animated);
    protected virtual void BeforeLoading(TImageContainer image, bool fromMemoryCache);
    protected virtual void AfterLoading(TImageContainer image, bool fromMemoryCache);
    [AsyncStateMachineAttribute("FFImageLoading.Work.ImageLoaderTask`3/<GenerateImageAsync>d__104")]
protected virtual Task`1<TImageContainer> GenerateImageAsync(string path, ImageSource source, Stream imageData, ImageInformation imageInformation, bool enableTransformations, bool isPlaceholder);
    [AsyncStateMachineAttribute("FFImageLoading.Work.ImageLoaderTask`3/<GenerateImageAsync>d__105")]
protected virtual Task`1<TImageContainer> GenerateImageAsync(string path, ImageSource source, IDecodedImage`1<object> decoded, ImageInformation imageInformation, bool enableTransformations, bool isPlaceholder);
    [AsyncStateMachineAttribute("FFImageLoading.Work.ImageLoaderTask`3/<TryLoadFromMemoryCacheAsync>d__106")]
public virtual Task`1<bool> TryLoadFromMemoryCacheAsync();
    [AsyncStateMachineAttribute("FFImageLoading.Work.ImageLoaderTask`3/<TryLoadFromMemoryCacheAsync>d__107")]
private Task`1<bool> TryLoadFromMemoryCacheAsync(string key, bool updateImageInformation, bool animated, bool isLoadingPlaceholder);
    [AsyncStateMachineAttribute("FFImageLoading.Work.ImageLoaderTask`3/<ShowPlaceholder>d__108")]
protected virtual Task ShowPlaceholder(string path, string key, ImageSource source, bool isLoadingPlaceholder);
    [AsyncStateMachineAttribute("FFImageLoading.Work.ImageLoaderTask`3/<RunAsync>d__109")]
public sealed virtual Task RunAsync();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <TryLoadFromMemoryCacheAsync>b__106_0();
}
public enum FFImageLoading.Work.ImageSource : Enum {
    public int value__;
    public static ImageSource Url;
    public static ImageSource Filepath;
    public static ImageSource ApplicationBundle;
    public static ImageSource CompiledResource;
    public static ImageSource EmbeddedResource;
    public static ImageSource Stream;
}
public enum FFImageLoading.Work.InterpolationMode : Enum {
    public int value__;
    public static InterpolationMode Default;
    public static InterpolationMode None;
    public static InterpolationMode Low;
    public static InterpolationMode Medium;
    public static InterpolationMode High;
}
public interface FFImageLoading.Work.IScheduledWork {
    public bool IsCancelled { get; }
    public bool IsCompleted { get; }
    public abstract virtual void Cancel();
    public abstract virtual bool get_IsCancelled();
    public abstract virtual bool get_IsCompleted();
}
public interface FFImageLoading.Work.ITarget {
    public bool IsValid { get; }
    public object TargetControl { get; }
    public abstract virtual bool get_IsValid();
    public abstract virtual object get_TargetControl();
}
public interface FFImageLoading.Work.ITarget`2 {
    public TImageView Control { get; }
    public abstract virtual TImageView get_Control();
    public abstract virtual void Set(IImageLoaderTask task, TImageContainer image, bool animated);
    public abstract virtual void SetAsEmpty(IImageLoaderTask task);
}
public interface FFImageLoading.Work.ITransformation {
    public string Key { get; }
    public abstract virtual string get_Key();
    public abstract virtual IBitmap Transform(IBitmap sourceBitmap, string path, ImageSource source, bool isPlaceholder, string key);
}
public interface FFImageLoading.Work.IVectorDataResolver {
    public int VectorWidth { get; }
    public int VectorHeight { get; }
    public bool UseDipUnits { get; }
    public Dictionary`2<string, string> ReplaceStringMap { get; public set; }
    public abstract virtual int get_VectorWidth();
    public abstract virtual int get_VectorHeight();
    public abstract virtual bool get_UseDipUnits();
    public abstract virtual Dictionary`2<string, string> get_ReplaceStringMap();
    public abstract virtual void set_ReplaceStringMap(Dictionary`2<string, string> value);
}
public interface FFImageLoading.Work.IWorkScheduler {
    [ObsoleteAttribute("Use SetPauseWork(bool pauseWork, bool cancelExistingTasks = false)")]
public bool ExitTasksEarly { get; }
    public bool PauseWork { get; }
    public abstract virtual void Cancel(Func`2<IImageLoaderTask, bool> predicate);
    public abstract virtual bool get_ExitTasksEarly();
    [ObsoleteAttribute("Use SetPauseWork(bool pauseWork, bool cancelExistingTasks = false)")]
public abstract virtual void SetExitTasksEarly(bool exitTasksEarly);
    public abstract virtual bool get_PauseWork();
    public abstract virtual void SetPauseWork(bool pauseWork, bool cancelExisting);
    public abstract virtual void RemovePendingTask(IImageLoaderTask task);
    public abstract virtual void LoadImage(IImageLoaderTask task);
}
public enum FFImageLoading.Work.LoadingPriority : Enum {
    public int value__;
    public static LoadingPriority Lowest;
    public static LoadingPriority Low;
    public static LoadingPriority Normal;
    public static LoadingPriority High;
    public static LoadingPriority Highest;
}
public enum FFImageLoading.Work.LoadingResult : Enum {
    public int value__;
    public static LoadingResult NotFound;
    public static LoadingResult InvalidTarget;
    public static LoadingResult Canceled;
    public static LoadingResult Failed;
    public static LoadingResult MemoryCache;
    public static LoadingResult DiskCache;
    public static LoadingResult Internet;
    public static LoadingResult Disk;
    public static LoadingResult ApplicationBundle;
    public static LoadingResult CompiledResource;
    public static LoadingResult EmbeddedResource;
    public static LoadingResult Stream;
}
public class FFImageLoading.Work.Target`2 : object {
    [CompilerGeneratedAttribute]
private bool <IsValid>k__BackingField;
    public TImageView Control { get; }
    public bool IsValid { get; }
    public object TargetControl { get; }
    public virtual TImageView get_Control();
    [CompilerGeneratedAttribute]
public virtual bool get_IsValid();
    public sealed virtual object get_TargetControl();
    public virtual void SetAsEmpty(IImageLoaderTask task);
    public virtual void Set(IImageLoaderTask task, TImageContainer image, bool animated);
}
public class FFImageLoading.Work.TaskParameter : object {
    private bool _disposed;
    [CompilerGeneratedAttribute]
private Stream <StreamRead>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StreamChecksum>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageSource <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, Task`1<Stream>> <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <CacheDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private Tuple`2<int, int> <DownSampleSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DownSampleUseDipUnits>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowUpscale>k__BackingField;
    [CompilerGeneratedAttribute]
private InterpolationMode <DownSampleInterpolationMode>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageSource <LoadingPlaceholderSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoadingPlaceholderPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ImageSource <ErrorPlaceholderSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorPlaceholderPath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RetryDelayInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<ImageInformation, LoadingResult> <OnSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<Exception> <OnError>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<IScheduledWork> <OnFinish>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<DownloadInformation> <OnDownloadStarted>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <OnLoadingPlaceholderSet>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<FileWriteInfo> <OnFileWriteFinished>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<DownloadProgress> <OnDownloadProgress>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ITransformation> <Transformations>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <BitmapOptimizationsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <FadeAnimationEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataResolver <CustomDataResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataResolver <CustomErrorPlaceholderDataResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IDataResolver <CustomLoadingPlaceholderDataResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <FadeAnimationForCachedImagesEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <FadeAnimationDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <TransformPlaceholdersEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomCacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Priority>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CacheType> <CacheType>k__BackingField;
    [CompilerGeneratedAttribute]
private DataEncodingType <DataEncoding>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <DelayInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <InvalidateLayoutEnabled>k__BackingField;
    private bool _preload;
    internal Stream StreamRead { get; internal set; }
    internal string StreamChecksum { get; internal set; }
    [EditorBrowsableAttribute("2")]
public ImageSource Source { get; private set; }
    [EditorBrowsableAttribute("2")]
public string Path { get; private set; }
    [EditorBrowsableAttribute("2")]
public Func`2<CancellationToken, Task`1<Stream>> Stream { get; private set; }
    [EditorBrowsableAttribute("2")]
public Nullable`1<TimeSpan> CacheDuration { get; private set; }
    [EditorBrowsableAttribute("2")]
public Tuple`2<int, int> DownSampleSize { get; private set; }
    [EditorBrowsableAttribute("2")]
public bool DownSampleUseDipUnits { get; private set; }
    [EditorBrowsableAttribute("2")]
public Nullable`1<bool> AllowUpscale { get; private set; }
    [EditorBrowsableAttribute("2")]
public InterpolationMode DownSampleInterpolationMode { get; private set; }
    [EditorBrowsableAttribute("2")]
public ImageSource LoadingPlaceholderSource { get; private set; }
    [EditorBrowsableAttribute("2")]
public string LoadingPlaceholderPath { get; private set; }
    [EditorBrowsableAttribute("2")]
public ImageSource ErrorPlaceholderSource { get; private set; }
    [EditorBrowsableAttribute("2")]
public string ErrorPlaceholderPath { get; private set; }
    [EditorBrowsableAttribute("2")]
public int RetryCount { get; private set; }
    [EditorBrowsableAttribute("2")]
public int RetryDelayInMs { get; private set; }
    [EditorBrowsableAttribute("2")]
public Action`2<ImageInformation, LoadingResult> OnSuccess { get; private set; }
    [EditorBrowsableAttribute("2")]
public Action`1<Exception> OnError { get; private set; }
    [EditorBrowsableAttribute("2")]
public Action`1<IScheduledWork> OnFinish { get; private set; }
    [EditorBrowsableAttribute("2")]
public Action`1<DownloadInformation> OnDownloadStarted { get; private set; }
    internal Action OnLoadingPlaceholderSet { get; private set; }
    [EditorBrowsableAttribute("2")]
public Action`1<FileWriteInfo> OnFileWriteFinished { get; private set; }
    [EditorBrowsableAttribute("2")]
public Action`1<DownloadProgress> OnDownloadProgress { get; private set; }
    [EditorBrowsableAttribute("2")]
public List`1<ITransformation> Transformations { get; private set; }
    [EditorBrowsableAttribute("2")]
public Nullable`1<bool> BitmapOptimizationsEnabled { get; private set; }
    [EditorBrowsableAttribute("2")]
public Nullable`1<bool> FadeAnimationEnabled { get; private set; }
    [EditorBrowsableAttribute("2")]
public IDataResolver CustomDataResolver { get; private set; }
    [EditorBrowsableAttribute("2")]
public IDataResolver CustomErrorPlaceholderDataResolver { get; private set; }
    [EditorBrowsableAttribute("2")]
public IDataResolver CustomLoadingPlaceholderDataResolver { get; private set; }
    [EditorBrowsableAttribute("2")]
public Nullable`1<bool> FadeAnimationForCachedImagesEnabled { get; private set; }
    [EditorBrowsableAttribute("2")]
public Nullable`1<int> FadeAnimationDuration { get; private set; }
    [EditorBrowsableAttribute("2")]
public Nullable`1<bool> TransformPlaceholdersEnabled { get; private set; }
    [EditorBrowsableAttribute("2")]
public string CustomCacheKey { get; private set; }
    [EditorBrowsableAttribute("2")]
public Nullable`1<int> Priority { get; private set; }
    [EditorBrowsableAttribute("2")]
public Nullable`1<CacheType> CacheType { get; private set; }
    [EditorBrowsableAttribute("2")]
public DataEncodingType DataEncoding { get; private set; }
    [EditorBrowsableAttribute("2")]
public Nullable`1<int> DelayInMs { get; private set; }
    [EditorBrowsableAttribute("2")]
public Nullable`1<bool> InvalidateLayoutEnabled { get; private set; }
    [EditorBrowsableAttribute("2")]
public bool Preload { get; internal set; }
    public static TaskParameter FromFile(string filepath);
    public static TaskParameter FromEmbeddedResource(string resourceUri);
    public static TaskParameter FromUrl(string url, Nullable`1<TimeSpan> cacheDuration);
    public static TaskParameter FromApplicationBundle(string filePath);
    public static TaskParameter FromCompiledResource(string resourceName);
    public static TaskParameter FromStream(Func`2<CancellationToken, Task`1<Stream>> stream);
    public static TaskParameter FromString(string data, DataEncodingType encoding);
    [CompilerGeneratedAttribute]
internal Stream get_StreamRead();
    [CompilerGeneratedAttribute]
internal void set_StreamRead(Stream value);
    [CompilerGeneratedAttribute]
internal string get_StreamChecksum();
    [CompilerGeneratedAttribute]
internal void set_StreamChecksum(string value);
    [CompilerGeneratedAttribute]
public ImageSource get_Source();
    [CompilerGeneratedAttribute]
private void set_Source(ImageSource value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public Func`2<CancellationToken, Task`1<Stream>> get_Stream();
    [CompilerGeneratedAttribute]
private void set_Stream(Func`2<CancellationToken, Task`1<Stream>> value);
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_CacheDuration();
    [CompilerGeneratedAttribute]
private void set_CacheDuration(Nullable`1<TimeSpan> value);
    [CompilerGeneratedAttribute]
public Tuple`2<int, int> get_DownSampleSize();
    [CompilerGeneratedAttribute]
private void set_DownSampleSize(Tuple`2<int, int> value);
    [CompilerGeneratedAttribute]
public bool get_DownSampleUseDipUnits();
    [CompilerGeneratedAttribute]
private void set_DownSampleUseDipUnits(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllowUpscale();
    [CompilerGeneratedAttribute]
private void set_AllowUpscale(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public InterpolationMode get_DownSampleInterpolationMode();
    [CompilerGeneratedAttribute]
private void set_DownSampleInterpolationMode(InterpolationMode value);
    [CompilerGeneratedAttribute]
public ImageSource get_LoadingPlaceholderSource();
    [CompilerGeneratedAttribute]
private void set_LoadingPlaceholderSource(ImageSource value);
    [CompilerGeneratedAttribute]
public string get_LoadingPlaceholderPath();
    [CompilerGeneratedAttribute]
private void set_LoadingPlaceholderPath(string value);
    [CompilerGeneratedAttribute]
public ImageSource get_ErrorPlaceholderSource();
    [CompilerGeneratedAttribute]
private void set_ErrorPlaceholderSource(ImageSource value);
    [CompilerGeneratedAttribute]
public string get_ErrorPlaceholderPath();
    [CompilerGeneratedAttribute]
private void set_ErrorPlaceholderPath(string value);
    [CompilerGeneratedAttribute]
public int get_RetryCount();
    [CompilerGeneratedAttribute]
private void set_RetryCount(int value);
    [CompilerGeneratedAttribute]
public int get_RetryDelayInMs();
    [CompilerGeneratedAttribute]
private void set_RetryDelayInMs(int value);
    [CompilerGeneratedAttribute]
public Action`2<ImageInformation, LoadingResult> get_OnSuccess();
    [CompilerGeneratedAttribute]
private void set_OnSuccess(Action`2<ImageInformation, LoadingResult> value);
    [CompilerGeneratedAttribute]
public Action`1<Exception> get_OnError();
    [CompilerGeneratedAttribute]
private void set_OnError(Action`1<Exception> value);
    [CompilerGeneratedAttribute]
public Action`1<IScheduledWork> get_OnFinish();
    [CompilerGeneratedAttribute]
private void set_OnFinish(Action`1<IScheduledWork> value);
    [CompilerGeneratedAttribute]
public Action`1<DownloadInformation> get_OnDownloadStarted();
    [CompilerGeneratedAttribute]
private void set_OnDownloadStarted(Action`1<DownloadInformation> value);
    [CompilerGeneratedAttribute]
internal Action get_OnLoadingPlaceholderSet();
    [CompilerGeneratedAttribute]
private void set_OnLoadingPlaceholderSet(Action value);
    [CompilerGeneratedAttribute]
public Action`1<FileWriteInfo> get_OnFileWriteFinished();
    [CompilerGeneratedAttribute]
private void set_OnFileWriteFinished(Action`1<FileWriteInfo> value);
    [CompilerGeneratedAttribute]
public Action`1<DownloadProgress> get_OnDownloadProgress();
    [CompilerGeneratedAttribute]
private void set_OnDownloadProgress(Action`1<DownloadProgress> value);
    [CompilerGeneratedAttribute]
public List`1<ITransformation> get_Transformations();
    [CompilerGeneratedAttribute]
private void set_Transformations(List`1<ITransformation> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_BitmapOptimizationsEnabled();
    [CompilerGeneratedAttribute]
private void set_BitmapOptimizationsEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_FadeAnimationEnabled();
    [CompilerGeneratedAttribute]
private void set_FadeAnimationEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public IDataResolver get_CustomDataResolver();
    [CompilerGeneratedAttribute]
private void set_CustomDataResolver(IDataResolver value);
    [CompilerGeneratedAttribute]
public IDataResolver get_CustomErrorPlaceholderDataResolver();
    [CompilerGeneratedAttribute]
private void set_CustomErrorPlaceholderDataResolver(IDataResolver value);
    [CompilerGeneratedAttribute]
public IDataResolver get_CustomLoadingPlaceholderDataResolver();
    [CompilerGeneratedAttribute]
private void set_CustomLoadingPlaceholderDataResolver(IDataResolver value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_FadeAnimationForCachedImagesEnabled();
    [CompilerGeneratedAttribute]
private void set_FadeAnimationForCachedImagesEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_FadeAnimationDuration();
    [CompilerGeneratedAttribute]
private void set_FadeAnimationDuration(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_TransformPlaceholdersEnabled();
    [CompilerGeneratedAttribute]
private void set_TransformPlaceholdersEnabled(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_CustomCacheKey();
    [CompilerGeneratedAttribute]
private void set_CustomCacheKey(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Priority();
    [CompilerGeneratedAttribute]
private void set_Priority(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<CacheType> get_CacheType();
    [CompilerGeneratedAttribute]
private void set_CacheType(Nullable`1<CacheType> value);
    [CompilerGeneratedAttribute]
public DataEncodingType get_DataEncoding();
    [CompilerGeneratedAttribute]
private void set_DataEncoding(DataEncodingType value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_DelayInMs();
    [CompilerGeneratedAttribute]
private void set_DelayInMs(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_InvalidateLayoutEnabled();
    [CompilerGeneratedAttribute]
private void set_InvalidateLayoutEnabled(Nullable`1<bool> value);
    public bool get_Preload();
    internal void set_Preload(bool value);
    public TaskParameter InvalidateLayout(bool enabled);
    public TaskParameter Transform(ITransformation transformation);
    public TaskParameter Transform(IEnumerable`1<ITransformation> transformations);
    public TaskParameter LoadingPlaceholder(string path, ImageSource source);
    public TaskParameter ErrorPlaceholder(string filepath, ImageSource source);
    public TaskParameter DownSample(int width, int height, Nullable`1<bool> allowUpscale);
    public TaskParameter DownSampleInDip(int width, int height, Nullable`1<bool> allowUpscale);
    public TaskParameter DownSampleMode(InterpolationMode mode);
    public TaskParameter WithPriority(LoadingPriority priority);
    public TaskParameter WithCustomDataResolver(IDataResolver resolver);
    public TaskParameter WithCustomLoadingPlaceholderDataResolver(IDataResolver resolver);
    public TaskParameter WithCustomErrorPlaceholderDataResolver(IDataResolver resolver);
    public TaskParameter WithPriority(int priority);
    public TaskParameter WithCache(CacheType cacheType);
    public TaskParameter BitmapOptimizations(bool enabled);
    public TaskParameter FadeAnimation(bool enabled, Nullable`1<bool> enabledForCachedImages, Nullable`1<int> duration);
    public TaskParameter TransformPlaceholders(bool enabled);
    public TaskParameter Retry(int retryCount, int millisecondDelay);
    public TaskParameter CacheKey(string customCacheKey);
    public TaskParameter Delay(int milliseconds);
    public TaskParameter Success(Action action);
    public TaskParameter Success(Action`2<ImageInformation, LoadingResult> action);
    public TaskParameter Error(Action`1<Exception> action);
    public TaskParameter Finish(Action`1<IScheduledWork> action);
    public TaskParameter DownloadStarted(Action`1<DownloadInformation> action);
    public TaskParameter DownloadProgress(Action`1<DownloadProgress> action);
    public TaskParameter FileWriteFinished(Action`1<FileWriteInfo> action);
    internal TaskParameter LoadingPlaceholderSet(Action action);
    public sealed virtual void Dispose();
}
public class FFImageLoading.Work.WorkScheduler : object {
    private object _lock;
    private long _statsTotalPending;
    private long _statsTotalRunning;
    private long _statsTotalMemoryCacheHits;
    private long _statsTotalWaiting;
    private long _loadCount;
    [CompilerGeneratedAttribute]
private IPlatformPerformance <Performance>k__BackingField;
    [CompilerGeneratedAttribute]
private PendingTasksQueue <PendingTasks>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, IImageLoaderTask> <RunningTasks>k__BackingField;
    [CompilerGeneratedAttribute]
private ThreadSafeCollection`1<IImageLoaderTask> <SimilarTasks>k__BackingField;
    [CompilerGeneratedAttribute]
private Configuration <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExitTasksEarly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PauseWork>k__BackingField;
    protected int MaxParallelTasks { get; }
    protected IPlatformPerformance Performance { get; private set; }
    protected PendingTasksQueue PendingTasks { get; private set; }
    protected Dictionary`2<string, IImageLoaderTask> RunningTasks { get; private set; }
    protected ThreadSafeCollection`1<IImageLoaderTask> SimilarTasks { get; private set; }
    protected Configuration Configuration { get; private set; }
    protected IMiniLogger Logger { get; }
    public bool ExitTasksEarly { get; private set; }
    public bool PauseWork { get; private set; }
    public WorkScheduler(Configuration configuration, IPlatformPerformance performance);
    protected int get_MaxParallelTasks();
    [CompilerGeneratedAttribute]
protected IPlatformPerformance get_Performance();
    [CompilerGeneratedAttribute]
private void set_Performance(IPlatformPerformance value);
    [CompilerGeneratedAttribute]
protected PendingTasksQueue get_PendingTasks();
    [CompilerGeneratedAttribute]
private void set_PendingTasks(PendingTasksQueue value);
    [CompilerGeneratedAttribute]
protected Dictionary`2<string, IImageLoaderTask> get_RunningTasks();
    [CompilerGeneratedAttribute]
private void set_RunningTasks(Dictionary`2<string, IImageLoaderTask> value);
    [CompilerGeneratedAttribute]
protected ThreadSafeCollection`1<IImageLoaderTask> get_SimilarTasks();
    [CompilerGeneratedAttribute]
private void set_SimilarTasks(ThreadSafeCollection`1<IImageLoaderTask> value);
    [CompilerGeneratedAttribute]
protected Configuration get_Configuration();
    [CompilerGeneratedAttribute]
private void set_Configuration(Configuration value);
    protected IMiniLogger get_Logger();
    public virtual void Cancel(Func`2<IImageLoaderTask, bool> predicate);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ExitTasksEarly();
    [CompilerGeneratedAttribute]
private void set_ExitTasksEarly(bool value);
    public sealed virtual void SetExitTasksEarly(bool exitTasksEarly);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PauseWork();
    [CompilerGeneratedAttribute]
private void set_PauseWork(bool value);
    public sealed virtual void SetPauseWork(bool pauseWork, bool cancelExisting);
    public virtual void RemovePendingTask(IImageLoaderTask task);
    [AsyncStateMachineAttribute("FFImageLoading.Work.WorkScheduler/<LoadImage>d__43")]
public virtual void LoadImage(IImageLoaderTask task);
    private void Enqueue(IImageLoaderTask task);
    protected void QueueImageLoadingTask(IImageLoaderTask task);
    [AsyncStateMachineAttribute("FFImageLoading.Work.WorkScheduler/<TakeFromPendingTasksAndRun>d__46")]
protected void TakeFromPendingTasksAndRun();
    protected Task CreateFrameworkTask(IImageLoaderTask imageLoadingTask);
    [AsyncStateMachineAttribute("FFImageLoading.Work.WorkScheduler/<TakeFromPendingTasksAndRunAsync>d__48")]
protected Task TakeFromPendingTasksAndRunAsync();
    [AsyncStateMachineAttribute("FFImageLoading.Work.WorkScheduler/<RunImageLoadingTaskAsync>d__49")]
protected Task RunImageLoadingTaskAsync(IImageLoaderTask pendingTask);
    protected void LogSchedulerStats();
    protected virtual int GetDefaultPriority(ImageSource source);
    [AsyncStateMachineAttribute("FFImageLoading.Work.WorkScheduler/<<TakeFromPendingTasksAndRunAsync>b__48_2>d")]
[CompilerGeneratedAttribute]
private Task <TakeFromPendingTasksAndRunAsync>b__48_2(KeyValuePair`2<string, IImageLoaderTask> p);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
