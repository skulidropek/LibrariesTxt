internal class DocoptNet.ApplicationResult : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReadOnlyList`1<LeafPattern> _collected;
    internal ApplicationResult(ReadOnlyList`1<LeafPattern> collected);
    [NullableContextAttribute("1")]
public TResult Accumulate(TState initialState, IApplicationResultAccumulator`2<TState, TResult> accumulator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class DocoptNet.ApplicationResultAccumulators : object {
    public static IApplicationResultAccumulator`1<IDictionary`2<string, ArgValue>> ValueDictionary;
    public static IApplicationResultAccumulator`1<IDictionary`2<string, ValueObject>> ValueObjectDictionary;
    private static ApplicationResultAccumulators();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocoptNet.ApplicationResultExtensions : object {
    [ExtensionAttribute]
internal static IDictionary`2<string, ValueObject> ToValueObjectDictionary(ApplicationResult result);
    [ExtensionAttribute]
internal static IDictionary`2<string, ArgValue> ToValueDictionary(ApplicationResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocoptNet.ArgsParseOptions : object {
    public static ArgsParseOptions Default;
    [CompilerGeneratedAttribute]
private bool <OptionsFirst>k__BackingField;
    private static ArgsParseOptions OptionsFirstTrue;
    public bool OptionsFirst { get; }
    private ArgsParseOptions(bool optionFirst);
    private static ArgsParseOptions();
    [CompilerGeneratedAttribute]
public bool get_OptionsFirst();
    public ArgsParseOptions WithOptionsFirst(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocoptNet.ArgumentsResult`1 : object {
    [CompilerGeneratedAttribute]
private T <Arguments>k__BackingField;
    public T Arguments { get; }
    public ArgumentsResult`1(T args);
    [CompilerGeneratedAttribute]
public sealed virtual T get_Arguments();
    public virtual string ToString();
    private sealed virtual override TResult DocoptNet.IParser<T>.IResult.Match(Func`2<T, TResult> args, Func`2<IHelpResult, TResult> help, Func`2<IVersionResult, TResult> version, Func`2<IInputErrorResult, TResult> error);
    private sealed virtual override TResult DocoptNet.IParser<T>.IResult.Match(Func`3<T, IResult<T>, TResult> args, Func`3<IHelpResult, IResult<T>, TResult> help, Func`3<IVersionResult, IResult<T>, TResult> version, Func`3<IInputErrorResult, IResult<T>, TResult> error);
    private sealed virtual override TResult DocoptNet.IHelpFeaturingParser<T>.IResult.Match(Func`2<T, TResult> args, Func`2<IHelpResult, TResult> help, Func`2<IInputErrorResult, TResult> error);
    private sealed virtual override TResult DocoptNet.IVersionFeaturingParser<T>.IResult.Match(Func`2<T, TResult> args, Func`2<IVersionResult, TResult> version, Func`2<IInputErrorResult, TResult> error);
    private sealed virtual override TResult DocoptNet.IBaselineParser<T>.IResult.Match(Func`2<T, TResult> args, Func`2<IInputErrorResult, TResult> error);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebugDisplay(),nq}")]
public class DocoptNet.ArgValue : ValueType {
    private int _int;
    [NullableAttribute("2")]
private object _ref;
    public static ArgValue None;
    public static ArgValue True;
    public static ArgValue False;
    [CompilerGeneratedAttribute]
private ArgValueKind <Kind>k__BackingField;
    public ArgValueKind Kind { get; }
    public bool IsNone { get; }
    public bool IsBoolean { get; }
    public bool IsInteger { get; }
    public bool IsString { get; }
    public bool IsStringList { get; }
    public bool IsTrue { get; }
    public bool IsFalse { get; }
    [NullableAttribute("2")]
public object Object { get; }
    [NullableContextAttribute("2")]
private ArgValue(ArgValueKind kind, object value);
    [NullableContextAttribute("2")]
private ArgValue(ArgValueKind kind, int int, object ref);
    private static ArgValue();
    [CompilerGeneratedAttribute]
public ArgValueKind get_Kind();
    public bool get_IsNone();
    public bool get_IsBoolean();
    public bool get_IsInteger();
    public bool get_IsString();
    public bool get_IsStringList();
    public bool get_IsTrue();
    public bool get_IsFalse();
    [NullableContextAttribute("2")]
public object get_Object();
    private string DebugDisplay();
    public virtual string ToString();
    public static ArgValue op_Implicit(bool value);
    public static ArgValue op_Implicit(int value);
    public static ArgValue op_Implicit(string value);
    public static ArgValue op_Implicit(StringList value);
    public bool TryAsBoolean(Boolean& value);
    public bool TryAsInteger(Int32& value);
    [NullableContextAttribute("2")]
public bool TryAsString(String& value);
    [NullableContextAttribute("2")]
public bool TryAsStringList(StringList& value);
    public static bool op_Explicit(ArgValue value);
    public static int op_Explicit(ArgValue value);
    public static string op_Explicit(ArgValue value);
    public static StringList op_Explicit(ArgValue value);
}
public enum DocoptNet.ArgValueKind : Enum {
    public int value__;
    public static ArgValueKind None;
    public static ArgValueKind Boolean;
    public static ArgValueKind Integer;
    public static ArgValueKind String;
    public static ArgValueKind StringList;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class DocoptNet.CodeGeneration.CSharpSourceBuilder : object {
    private bool _skipNextNewLine;
    [CompilerGeneratedAttribute]
private StringBuilder <StringBuilder>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Level>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNewLine>k__BackingField;
    private static Char[] ForbiddenRegularStringLiteralChars;
    private static string Quote;
    public StringBuilder StringBuilder { get; }
    public int Level { get; private set; }
    public bool IsNewLine { get; private set; }
    private CSharpSourceBuilder Indent { get; }
    private CSharpSourceBuilder Outdent { get; }
    public CSharpSourceBuilder SkipNextNewLine { get; }
    public CSharpSourceBuilder Item { get; }
    public CSharpSourceBuilder Item { get; }
    public CSharpSourceBuilder Item { get; }
    public CSharpSourceBuilder Item { get; }
    public CSharpSourceBuilder NewLine { get; }
    private CSharpSourceBuilder Equal { get; }
    public IStatementFlow UsingStatic { get; }
    public CSharpSourceBuilder Null { get; }
    public CSharpSourceBuilder True { get; }
    public CSharpSourceBuilder False { get; }
    public CSharpSourceBuilder Break { get; }
    public CSharpSourceBuilder Partial { get; }
    public CSharpSourceBuilder Static { get; }
    public CSharpSourceBuilder ReadOnly { get; }
    public CSharpSourceBuilder Class { get; }
    public CSharpSourceBuilder Public { get; }
    public CSharpSourceBuilder Yield { get; }
    public CSharpSourceBuilder New { get; }
    public CSharpSourceBuilder NewTargeted { get; }
    public IControlBlockFlow If { get; }
    public IControlBlockFlow While { get; }
    public IControlBlockFlow ForEach { get; }
    public CSharpSourceBuilder BlockStart { get; }
    public CSharpSourceBuilder BlockEnd { get; }
    public CSharpSourceBuilder EndStatement { get; }
    public IStatementFlow Return { get; }
    public IStatementFlow Lambda { get; }
    public IBlockFlow Block { get; }
    private CSharpSourceBuilder DocoptNet.CodeGeneration.CSharpSourceBuilder.IBlockFlow.Item { get; }
    private CSharpSourceBuilder DocoptNet.CodeGeneration.CSharpSourceBuilder.IBlockFlow.Item { get; }
    private CSharpSourceBuilder DocoptNet.CodeGeneration.CSharpSourceBuilder.IStatementFlow.Item { get; }
    private CSharpSourceBuilder DocoptNet.CodeGeneration.CSharpSourceBuilder.IStatementFlow.Item { get; }
    private IControlBlockFlow Control { get; }
    private IBlockFlow DocoptNet.CodeGeneration.CSharpSourceBuilder.IControlBlockFlow.Item { get; }
    private IBlockFlow DocoptNet.CodeGeneration.CSharpSourceBuilder.IControlBlockFlow.Item { get; }
    public ISwitchFlow Switch { get; }
    private ISwitchCasesFlow DocoptNet.CodeGeneration.CSharpSourceBuilder.ISwitchFlow.Item { get; }
    private ISwitchCasesFlow DocoptNet.CodeGeneration.CSharpSourceBuilder.ISwitchFlow.Item { get; }
    public CSharpSourceBuilder(StringBuilder sb);
    private static CSharpSourceBuilder();
    [CompilerGeneratedAttribute]
public StringBuilder get_StringBuilder();
    [CompilerGeneratedAttribute]
public int get_Level();
    [CompilerGeneratedAttribute]
private void set_Level(int value);
    [CompilerGeneratedAttribute]
public bool get_IsNewLine();
    [CompilerGeneratedAttribute]
private void set_IsNewLine(bool value);
    private CSharpSourceBuilder get_Indent();
    private CSharpSourceBuilder get_Outdent();
    private StringBuilder OnAppending();
    private void Append(char value);
    private void Append(string value);
    private void Append(int value);
    private void AppendLine();
    public virtual string ToString();
    public CSharpSourceBuilder get_SkipNextNewLine();
    [ConditionalAttribute("DEBUG")]
private void AssertSame(CSharpSourceBuilder other);
    public CSharpSourceBuilder get_Item(string code);
    public CSharpSourceBuilder get_Item(char code);
    public CSharpSourceBuilder get_Item(CSharpSourceBuilder code);
    public CSharpSourceBuilder get_Item(IEnumerable`1<CSharpSourceBuilder> codes);
    public CSharpSourceBuilder Blank();
    public CSharpSourceBuilder get_NewLine();
    public CSharpSourceBuilder Literal(string value);
    public CSharpSourceBuilder Literal(int value);
    public CSharpSourceBuilder Each(IEnumerable`1<T> source, Func`4<CSharpSourceBuilder, T, int, CSharpSourceBuilder> builder);
    private CSharpSourceBuilder get_Equal();
    public CSharpSourceBuilder Using(string ns);
    public IStatementFlow UsingAlias(string alias);
    public IStatementFlow get_UsingStatic();
    public CSharpSourceBuilder Namespace(string name);
    public CSharpSourceBuilder get_Null();
    public CSharpSourceBuilder get_True();
    public CSharpSourceBuilder get_False();
    public CSharpSourceBuilder get_Break();
    public CSharpSourceBuilder get_Partial();
    public CSharpSourceBuilder get_Static();
    public CSharpSourceBuilder get_ReadOnly();
    public CSharpSourceBuilder get_Class();
    public CSharpSourceBuilder get_Public();
    public CSharpSourceBuilder get_Yield();
    public CSharpSourceBuilder get_New();
    public CSharpSourceBuilder get_NewTargeted();
    public IControlBlockFlow get_If();
    public IControlBlockFlow get_While();
    public IControlBlockFlow get_ForEach();
    public CSharpSourceBuilder get_BlockStart();
    public CSharpSourceBuilder get_BlockEnd();
    public CSharpSourceBuilder get_EndStatement();
    public CSharpSourceBuilder LineComment(string comment);
    public CSharpSourceBuilder Const(string name, string value);
    public IStatementFlow get_Return();
    public IStatementFlow get_Lambda();
    public IStatementFlow Var(string name);
    public IStatementFlow Assign(string name);
    public IStatementFlow Assign(CSharpSourceBuilder code);
    public IBlockFlow get_Block();
    private sealed virtual override CSharpSourceBuilder DocoptNet.CodeGeneration.CSharpSourceBuilder.IBlockFlow.get_Item(string code);
    private sealed virtual override CSharpSourceBuilder DocoptNet.CodeGeneration.CSharpSourceBuilder.IBlockFlow.get_Item(CSharpSourceBuilder code);
    private CSharpSourceBuilder BlockFlow(CSharpSourceBuilder code);
    private sealed virtual override CSharpSourceBuilder DocoptNet.CodeGeneration.CSharpSourceBuilder.IStatementFlow.get_Item(string code);
    private sealed virtual override CSharpSourceBuilder DocoptNet.CodeGeneration.CSharpSourceBuilder.IStatementFlow.get_Item(CSharpSourceBuilder code);
    private CSharpSourceBuilder StatementFlow(CSharpSourceBuilder code);
    private IControlBlockFlow get_Control();
    private sealed virtual override IBlockFlow DocoptNet.CodeGeneration.CSharpSourceBuilder.IControlBlockFlow.get_Item(string code);
    private sealed virtual override IBlockFlow DocoptNet.CodeGeneration.CSharpSourceBuilder.IControlBlockFlow.get_Item(CSharpSourceBuilder code);
    private IBlockFlow ControlBlockFlow(CSharpSourceBuilder code);
    public ISwitchFlow get_Switch();
    private sealed virtual override ISwitchCasesFlow DocoptNet.CodeGeneration.CSharpSourceBuilder.ISwitchFlow.get_Item(string code);
    private sealed virtual override ISwitchCasesFlow DocoptNet.CodeGeneration.CSharpSourceBuilder.ISwitchFlow.get_Item(CSharpSourceBuilder code);
    private ISwitchCasesFlow SwitchFlow(CSharpSourceBuilder code);
    private sealed virtual override CSharpSourceBuilder DocoptNet.CodeGeneration.CSharpSourceBuilder.ISwitchCasesFlow.Cases(IEnumerable`1<T> source, TArg arg, Func`4<TArg, T, int, SwitchCaseChoice> caseChooser, Func`4<CSharpSourceBuilder, TArg, T, CSharpSourceBuilder> caseBlock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocoptNet.CodeGeneration.Extensions : object {
    [IteratorStateMachineAttribute("DocoptNet.CodeGeneration.Extensions/<GetParents>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<TypeDeclarationSyntax> GetParents(BaseTypeDeclarationSyntax syntax);
    [ExtensionAttribute]
public static void LaunchDebuggerIfFlagged(GeneratorExecutionContext context, string generatorName);
    [ExtensionAttribute]
public static void LaunchDebuggerIfFlagged(AnalyzerConfigOptions options, string generatorName);
    [ExtensionAttribute]
public static bool IsFlagged(AnalyzerConfigOptions options, string name);
    [ExtensionAttribute]
public static string EncodeXmlText(string str);
    [ExtensionAttribute]
public static string EncodeXmlAttributeValue(string str);
    [ExtensionAttribute]
private static string EncodeXmlText(string str, bool attribute);
    [CompilerGeneratedAttribute]
internal static StringBuilder <EncodeXmlText>g__StringBuilder|6_0(<>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static void <EncodeXmlText>g__Append|6_1(string s, <>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
internal static void <EncodeXmlText>g__AppendChar|6_2(char ch, <>c__DisplayClass6_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[GeneratorAttribute]
public class DocoptNet.CodeGeneration.SourceGenerator : object {
    private static DiagnosticDescriptor SyntaxError;
    private static DiagnosticDescriptor MissingHelpConstError;
    private static SymbolDisplayFormat FullyQualifiedFormatWithoutGlobalNamespace;
    private static string DefaultHelpConstName;
    private static SourceText EmptySourceText;
    private static Encoding Utf8BomlessEncoding;
    private static String[] Vars;
    private static SourceGenerator();
    public sealed virtual void Initialize(GeneratorInitializationContext context);
    public sealed virtual void Execute(GeneratorExecutionContext context);
    [IteratorStateMachineAttribute("DocoptNet.CodeGeneration.SourceGenerator/<GetEmbeddedCSharpSources>d__10")]
private IEnumerable`1<ValueTuple`2<string, SourceText>> GetEmbeddedCSharpSources(Func`2<string, bool> predicate);
    private static bool DoesFileNameEndIn(string fileName, string ending);
    public static SourceText Generate(string ns, string name, SourceText text);
    private static SourceText Generate(string ns, string name, IEnumerable`1<string> parents, string helpConstName, SourceText text, GenerationOptions generationOptions);
    public static SourceText Generate(string ns, string name, SourceText text, Encoding outputEncoding);
    private static SourceText Generate(string ns, string name, IEnumerable`1<string> parents, string helpConstName, SourceText text, Encoding outputEncoding, GenerationOptions options);
    private static void Generate(CSharpSourceBuilder code, string ns, string name, IEnumerable`1<string> parents, string helpConstName, string helpText, GenerationOptions generationOptions);
    [CompilerGeneratedAttribute]
private void <Initialize>b__2_1(GeneratorPostInitializationContext context);
    [CompilerGeneratedAttribute]
internal static CSharpSourceBuilder <Generate>g__GeneratePatternMatchingCode|18_11(CSharpSourceBuilder code, Pattern pattern, string pmv, int level);
    [CompilerGeneratedAttribute]
internal static string <Generate>g__InferPropertyName|18_12(LeafPattern leaf);
    [CompilerGeneratedAttribute]
internal static string <Generate>g__MapType|18_13(ArgValueKind kind);
    [CompilerGeneratedAttribute]
internal static CSharpSourceBuilder <Generate>g__Value|18_14(CSharpSourceBuilder code, ArgValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class DocoptNet.CodeGeneration.StringBuilderSourceText : SourceText {
    private StringBuilder _builder;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    [NullableAttribute("2")]
public Encoding Encoding { get; }
    public int Length { get; }
    public char Item { get; }
    public StringBuilderSourceText(StringBuilder builder, Encoding encoding);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual Encoding get_Encoding();
    public virtual int get_Length();
    public virtual char get_Item(int position);
    public virtual string ToString(TextSpan span);
    public virtual void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocoptNet.Docopt : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<PrintExitEventArgs> PrintExit;
    public static IHelpFeaturingParser`1<IDictionary`2<string, ArgValue>> CreateParser(string doc);
    private static IHelpFeaturingParser`1<T> CreateParser(string doc, Func`2<ApplicationResult, T> resultSelector);
    [CompilerGeneratedAttribute]
public void add_PrintExit(EventHandler`1<PrintExitEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PrintExit(EventHandler`1<PrintExitEventArgs> value);
    public IDictionary`2<string, ValueObject> Apply(string doc);
    public IDictionary`2<string, ValueObject> Apply(string doc, ICollection`1<string> argv, bool help, object version, bool optionsFirst, bool exit);
    private ApplicationResult Apply(string doc, IEnumerable`1<string> argv, bool help, object version, bool optionsFirst, bool exit);
    private void SetDefaultPrintExitHandlerIfNecessary(bool exit);
    protected void OnPrintExit(string doc, int errorCode);
    internal static IList`1<LeafPattern> ParseArgv(Tokens tokens, ICollection`1<Option> options, bool optionsFirst);
    internal static string FormalUsage(string exitUsage);
    internal static Required ParsePattern(string source, ICollection`1<Option> options);
    private static IEnumerable`1<Pattern> ParseExpr(Tokens tokens, ICollection`1<Option> options);
    private static ICollection`1<Pattern> ParseSeq(Tokens tokens, ICollection`1<Option> options);
    private static IEnumerable`1<Pattern> ParseAtom(Tokens tokens, ICollection`1<Option> options);
    private static IEnumerable`1<Option> ParseShorts(Tokens tokens, ICollection`1<Option> options);
    private static IEnumerable`1<Option> ParseLong(Tokens tokens, ICollection`1<Option> options);
    internal static ICollection`1<Option> ParseDefaults(string doc);
    internal static String[] ParseSection(string name, string source);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class DocoptNet.DocoptArgumentsAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <HelpConstName>k__BackingField;
    public string HelpConstName { get; public set; }
    [CompilerGeneratedAttribute]
public string get_HelpConstName();
    [CompilerGeneratedAttribute]
public void set_HelpConstName(string value);
    [NullableContextAttribute("1")]
internal static DocoptArgumentsAttribute From(AttributeData data);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class DocoptNet.DocoptBaseException : Exception {
    public int ErrorCode { get; }
    public DocoptBaseException(string message);
    public DocoptBaseException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected DocoptBaseException(SerializationInfo info, StreamingContext context);
    public int get_ErrorCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class DocoptNet.DocoptExitException : DocoptBaseException {
    public DocoptExitException(string message);
    public DocoptExitException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected DocoptExitException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class DocoptNet.DocoptInputErrorException : DocoptBaseException {
    public DocoptInputErrorException(string message);
    public DocoptInputErrorException(string message, Exception inner);
    [NullableContextAttribute("1")]
protected DocoptInputErrorException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocoptNet.DocoptLanguageErrorException : DocoptBaseException {
    [NullableContextAttribute("2")]
public DocoptLanguageErrorException(string message);
    public DocoptLanguageErrorException(string message, Exception inner);
    protected DocoptLanguageErrorException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class DocoptNet.Extensions : object {
    [ExtensionAttribute]
public static ValueTuple`3<string, string, string> Partition(string input, string separator);
}
[NullableContextAttribute("2")]
internal interface DocoptNet.IApplicationResultAccumulator`1 {
}
[NullableContextAttribute("1")]
internal interface DocoptNet.IApplicationResultAccumulator`2 {
    public abstract virtual T Command(T state, string name, bool value);
    public abstract virtual T Command(T state, string name, int value);
    public abstract virtual T Argument(T state, string name);
    public abstract virtual T Argument(T state, string name, string value);
    public abstract virtual T Argument(T state, string name, StringList value);
    public abstract virtual T Option(T state, string name);
    public abstract virtual T Option(T state, string name, bool value);
    public abstract virtual T Option(T state, string name, string value);
    public abstract virtual T Option(T state, string name, int value);
    public abstract virtual T Option(T state, string name, StringList value);
    public abstract virtual TResult GetResult(T state);
}
[NullableContextAttribute("1")]
public interface DocoptNet.IArgumentsResult`1 {
    public T Arguments { get; }
    public abstract virtual T get_Arguments();
}
[NullableContextAttribute("1")]
public interface DocoptNet.IBaselineParser`1 {
    public ArgsParseOptions Options { get; }
    public abstract virtual IResult<T> Parse(IEnumerable`1<string> argv);
    public abstract virtual ArgsParseOptions get_Options();
    public abstract virtual IBaselineParser`1<T> WithOptions(ArgsParseOptions value);
    public abstract virtual IHelpFeaturingParser`1<T> EnableHelp();
    public abstract virtual IVersionFeaturingParser`1<T> WithVersion(string value);
}
[NullableContextAttribute("1")]
public interface DocoptNet.IHelpFeaturingParser`1 {
    public ArgsParseOptions Options { get; }
    public abstract virtual IResult<T> Parse(IEnumerable`1<string> argv);
    public abstract virtual ArgsParseOptions get_Options();
    public abstract virtual IHelpFeaturingParser`1<T> WithOptions(ArgsParseOptions value);
    public abstract virtual IParser`1<T> WithVersion(string value);
    public abstract virtual IBaselineParser`1<T> DisableHelp();
}
[NullableContextAttribute("1")]
public interface DocoptNet.IHelpResult {
    public string Help { get; }
    public abstract virtual string get_Help();
}
[NullableContextAttribute("1")]
public interface DocoptNet.IInputErrorResult {
    public string Error { get; }
    public string Usage { get; }
    public abstract virtual string get_Error();
    public abstract virtual string get_Usage();
}
internal class DocoptNet.Internals.Argument : LeafPattern {
    public Argument(string name);
    public Argument(string name, string value);
    public Argument(string name, String[] values);
    public Argument(string name, int value);
}
[EditorBrowsableAttribute("1")]
public abstract class DocoptNet.Internals.BranchPattern : Pattern {
    public string Name { get; }
    protected BranchPattern(Pattern[] children);
    public virtual string get_Name();
    public IEnumerable`1<Pattern> Flat();
    public virtual ICollection`1<Pattern> Flat(Type[] types);
    public virtual string ToString();
}
internal static class DocoptNet.Internals.BranchPatternMatcher : object {
    public static bool Next(Int32& i, int count);
}
internal class DocoptNet.Internals.Command : LeafPattern {
    public Command(string name, bool value);
}
[EditorBrowsableAttribute("1")]
public class DocoptNet.Internals.Either : BranchPattern {
    public Either(Pattern[] patterns);
}
[EditorBrowsableAttribute("1")]
public class DocoptNet.Internals.EitherMatcher : ValueType {
    private int _count;
    private int _i;
    private MatchResult _match;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ReadOnlyList`1<LeafPattern> <Left>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ReadOnlyList`1<LeafPattern> <Collected>k__BackingField;
    public int Index { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyList`1<LeafPattern> Left { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyList`1<LeafPattern> Collected { get; }
    public bool LastMatched { get; }
    public MatchResult Result { get; }
    public EitherMatcher(int count, ReadOnlyList`1<LeafPattern> left, ReadOnlyList`1<LeafPattern> collected);
    public sealed virtual int get_Index();
    public sealed virtual bool Next();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ReadOnlyList`1<LeafPattern> get_Left();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ReadOnlyList`1<LeafPattern> get_Collected();
    [NullableContextAttribute("1")]
public sealed virtual bool Match(LeafPatternMatcher matcher, string name, ArgValueKind kind);
    [NullableContextAttribute("1")]
public sealed virtual bool Match(Pattern pattern);
    public sealed virtual bool Fold(MatchResult match);
    public sealed virtual bool get_LastMatched();
    public sealed virtual MatchResult get_Result();
}
internal static class DocoptNet.Internals.GenerateCodeHelper : object {
    public static string ConvertToPascalCase(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public static class DocoptNet.Internals.GeneratedSourceModule : object {
    public static IResult<T> Parse(string doc, string usage, IEnumerable`1<string> args, List`1<Option> options, ParseFlags flags, string version, Func`2<ReadOnlyList`1<LeafPattern>, IResult<T>> resultSelector);
    public static IBaselineParser`1<T> CreateParser(string doc, Func`4<IEnumerable`1<string>, ParseFlags, string, IResult<T>> parseFunction);
    public static IResult<T> CreateArgumentsResult(T args);
    public static IResult<T> CreateInputErrorResult(string error, string usage);
}
[NullableContextAttribute("1")]
internal interface DocoptNet.Internals.IBranchPatternMatcher {
    public int Index { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyList`1<LeafPattern> Left { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyList`1<LeafPattern> Collected { get; }
    public bool LastMatched { get; }
    public MatchResult Result { get; }
    public abstract virtual int get_Index();
    public abstract virtual bool Next();
    public abstract virtual ReadOnlyList`1<LeafPattern> get_Left();
    public abstract virtual ReadOnlyList`1<LeafPattern> get_Collected();
    public abstract virtual bool Match(LeafPatternMatcher matcher, string name, ArgValueKind kind);
    public abstract virtual bool Match(Pattern pattern);
    public abstract virtual bool Fold(MatchResult match);
    public abstract virtual bool get_LastMatched();
    public abstract virtual MatchResult get_Result();
}
[ExtensionAttribute]
internal static class DocoptNet.Internals.LeafMatcherExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static MatchResult Match(LeafPatternMatcher matcher, ReadOnlyList`1<LeafPattern> left, ReadOnlyList`1<LeafPattern> collected, string name, ArgValueKind kind);
}
[EditorBrowsableAttribute("1")]
public abstract class DocoptNet.Internals.LeafPattern : Pattern {
    private string _name;
    [CompilerGeneratedAttribute]
private ArgValue <Value>k__BackingField;
    public string Name { get; }
    public ArgValue Value { get; public set; }
    protected LeafPattern(string name, ArgValue value);
    public virtual string get_Name();
    [CompilerGeneratedAttribute]
public ArgValue get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(ArgValue value);
    public virtual ICollection`1<Pattern> Flat(Type[] types);
    public virtual string ToString();
}
[EditorBrowsableAttribute("1")]
public class DocoptNet.Internals.LeafPatternMatcher : MulticastDelegate {
    public LeafPatternMatcher(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual ValueTuple`2<int, LeafPattern> Invoke(ReadOnlyList`1<LeafPattern> left, string name);
    public virtual IAsyncResult BeginInvoke(ReadOnlyList`1<LeafPattern> left, string name, AsyncCallback callback, object object);
    public virtual ValueTuple`2<int, LeafPattern> EndInvoke(IAsyncResult result);
}
[IsReadOnlyAttribute]
[EditorBrowsableAttribute("1")]
public class DocoptNet.Internals.MatchResult : ValueType {
    public bool Matched;
    public ReadOnlyList`1<LeafPattern> Left;
    public ReadOnlyList`1<LeafPattern> Collected;
    public MatchResult(bool matched, ReadOnlyList`1<LeafPattern> left, ReadOnlyList`1<LeafPattern> collected);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public void Deconstruct(Boolean& matched, ReadOnlyList`1& left, ReadOnlyList`1& collected);
    public static bool op_True(MatchResult result);
    public static bool op_False(MatchResult result);
    public static bool op_LogicalNot(MatchResult result);
}
internal class DocoptNet.Internals.OneOrMore : BranchPattern {
    public OneOrMore(Pattern[] patterns);
}
[EditorBrowsableAttribute("1")]
public class DocoptNet.Internals.OneOrMoreMatcher : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReadOnlyList`1<LeafPattern> _initLeft;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReadOnlyList`1<LeafPattern> _initCollected;
    private int _times;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ReadOnlyList`1<LeafPattern>> _lastLeft;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ReadOnlyList`1<LeafPattern> <Left>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ReadOnlyList`1<LeafPattern> <Collected>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LastMatched>k__BackingField;
    public int Index { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyList`1<LeafPattern> Left { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyList`1<LeafPattern> Collected { get; private set; }
    public bool LastMatched { get; private set; }
    public MatchResult Result { get; }
    public OneOrMoreMatcher(int count, ReadOnlyList`1<LeafPattern> left, ReadOnlyList`1<LeafPattern> collected);
    public sealed virtual int get_Index();
    public sealed virtual bool Next();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ReadOnlyList`1<LeafPattern> get_Left();
    [CompilerGeneratedAttribute]
private void set_Left(ReadOnlyList`1<LeafPattern> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ReadOnlyList`1<LeafPattern> get_Collected();
    [CompilerGeneratedAttribute]
private void set_Collected(ReadOnlyList`1<LeafPattern> value);
    [NullableContextAttribute("1")]
public sealed virtual bool Match(LeafPatternMatcher matcher, string name, ArgValueKind kind);
    [NullableContextAttribute("1")]
public sealed virtual bool Match(Pattern pattern);
    public sealed virtual bool Fold(MatchResult match);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool get_LastMatched();
    [CompilerGeneratedAttribute]
private void set_LastMatched(bool value);
    public sealed virtual MatchResult get_Result();
}
[EditorBrowsableAttribute("1")]
public class DocoptNet.Internals.Option : LeafPattern {
    [CompilerGeneratedAttribute]
private string <ShortName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LongName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ArgCount>k__BackingField;
    private static string DESC_SEPARATOR;
    private static Char[] OptionDelimiters;
    public string ShortName { get; private set; }
    public string LongName { get; private set; }
    public int ArgCount { get; private set; }
    public string Name { get; }
    public Option(string shortName, string longName, int argCount, Nullable`1<ArgValue> value);
    public Option(string shortName, string longName, int argCount, string value);
    private static Option();
    [CompilerGeneratedAttribute]
public string get_ShortName();
    [CompilerGeneratedAttribute]
private void set_ShortName(string value);
    [CompilerGeneratedAttribute]
public string get_LongName();
    [CompilerGeneratedAttribute]
private void set_LongName(string value);
    [CompilerGeneratedAttribute]
public int get_ArgCount();
    [CompilerGeneratedAttribute]
private void set_ArgCount(int value);
    public virtual string get_Name();
    public virtual string ToString();
    public static Option Parse(string optionDescription);
}
internal class DocoptNet.Internals.Optional : BranchPattern {
    public Optional(Pattern[] patterns);
}
[EditorBrowsableAttribute("1")]
public class DocoptNet.Internals.OptionalMatcher : ValueType {
    private int _count;
    private int _i;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ReadOnlyList`1<LeafPattern> <Left>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ReadOnlyList`1<LeafPattern> <Collected>k__BackingField;
    public int Index { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyList`1<LeafPattern> Left { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyList`1<LeafPattern> Collected { get; private set; }
    public bool LastMatched { get; }
    public MatchResult Result { get; }
    public OptionalMatcher(int count, ReadOnlyList`1<LeafPattern> left, ReadOnlyList`1<LeafPattern> collected);
    public sealed virtual int get_Index();
    public sealed virtual bool Next();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ReadOnlyList`1<LeafPattern> get_Left();
    [CompilerGeneratedAttribute]
private void set_Left(ReadOnlyList`1<LeafPattern> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ReadOnlyList`1<LeafPattern> get_Collected();
    [CompilerGeneratedAttribute]
private void set_Collected(ReadOnlyList`1<LeafPattern> value);
    [NullableContextAttribute("1")]
public sealed virtual bool Match(LeafPatternMatcher matcher, string name, ArgValueKind kind);
    [NullableContextAttribute("1")]
public sealed virtual bool Match(Pattern pattern);
    public sealed virtual bool Fold(MatchResult match);
    public sealed virtual bool get_LastMatched();
    public sealed virtual MatchResult get_Result();
}
internal class DocoptNet.Internals.OptionsShortcut : Optional {
    public OptionsShortcut(Pattern[] patterns);
}
[FlagsAttribute]
public enum DocoptNet.Internals.ParseFlags : Enum {
    public int value__;
    public static ParseFlags None;
    public static ParseFlags OptionsFirst;
    public static ParseFlags DisableHelp;
}
[EditorBrowsableAttribute("1")]
public abstract class DocoptNet.Internals.Pattern : object {
    [CompilerGeneratedAttribute]
private IList`1<Pattern> <Children>k__BackingField;
    public string Name { get; }
    public IList`1<Pattern> Children { get; public set; }
    public abstract virtual string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public IList`1<Pattern> get_Children();
    [CompilerGeneratedAttribute]
public void set_Children(IList`1<Pattern> value);
    public Pattern Fix();
    public void FixIdentities(ICollection`1<Pattern> uniq);
    public Pattern FixRepeatingArguments();
    public static Either Transform(Pattern pattern);
    public abstract virtual ICollection`1<Pattern> Flat(Type[] types);
    public IEnumerable`1<Pattern> Flat();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static class DocoptNet.Internals.PatternMatcher : object {
    public static LeafPatternMatcher CommandMatcher;
    public static LeafPatternMatcher ArgumentMatcher;
    public static LeafPatternMatcher OptionMatcher;
    private static PatternMatcher();
    [ExtensionAttribute]
public static MatchResult Match(Pattern pattern, ReadOnlyList`1<LeafPattern> left);
    [ExtensionAttribute]
public static MatchResult Match(Pattern pattern, ReadOnlyList`1<LeafPattern> left, ReadOnlyList`1<LeafPattern> collected);
    public static MatchResult MatchLeaf(ReadOnlyList`1<LeafPattern> left, ReadOnlyList`1<LeafPattern> collected, string name, ArgValueKind kind, int index, LeafPattern match);
    public static ValueTuple`2<int, LeafPattern> MatchCommand(ReadOnlyList`1<LeafPattern> left, string command);
    public static ValueTuple`2<int, LeafPattern> MatchArgument(ReadOnlyList`1<LeafPattern> left, string name);
    public static ValueTuple`2<int, LeafPattern> MatchOption(ReadOnlyList`1<LeafPattern> left, string name);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static MatchResult <Match>g__MatchBranch|1_0(IList`1<Pattern> children, T matcher);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class DocoptNet.Internals.ReadOnlyList : object {
    [ExtensionAttribute]
public static ReadOnlyList`1<T> ToReadOnlyList(IEnumerable`1<T> sequence);
    [ExtensionAttribute]
public static ReadOnlyList`1<T> AsReadOnly(IList`1<T> list);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[EditorBrowsableAttribute("1")]
public class DocoptNet.Internals.ReadOnlyList`1 : ValueType {
    private IList`1<T> _list;
    private IList`1<T> List { get; }
    public int Count { get; }
    public T Item { get; }
    public ReadOnlyList`1(IList`1<T> list);
    private IList`1<T> get_List();
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ReadOnlyList`1<T> Append(T item);
    public ReadOnlyList`1<T> RemoveAt(int index);
    private void CopyTo(T[] array, int index, int count);
    private void CopyTo(T[] array, int targetIndex, int sourceIndex, int count);
}
internal class DocoptNet.Internals.Required : BranchPattern {
    public Required(Pattern[] patterns);
}
[EditorBrowsableAttribute("1")]
public class DocoptNet.Internals.RequiredMatcher : ValueType {
    private int _count;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReadOnlyList`1<LeafPattern> _initLeft;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReadOnlyList`1<LeafPattern> _initCollected;
    private int _i;
    private Nullable`1<MatchResult> _result;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ReadOnlyList`1<LeafPattern> <Left>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ReadOnlyList`1<LeafPattern> <Collected>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LastMatched>k__BackingField;
    public int Index { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyList`1<LeafPattern> Left { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyList`1<LeafPattern> Collected { get; private set; }
    public bool LastMatched { get; private set; }
    public MatchResult Result { get; }
    public RequiredMatcher(int count, ReadOnlyList`1<LeafPattern> left, ReadOnlyList`1<LeafPattern> collected);
    public sealed virtual int get_Index();
    public sealed virtual bool Next();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ReadOnlyList`1<LeafPattern> get_Left();
    [CompilerGeneratedAttribute]
private void set_Left(ReadOnlyList`1<LeafPattern> value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual ReadOnlyList`1<LeafPattern> get_Collected();
    [CompilerGeneratedAttribute]
private void set_Collected(ReadOnlyList`1<LeafPattern> value);
    [NullableContextAttribute("1")]
public sealed virtual bool Match(LeafPatternMatcher matcher, string name, ArgValueKind kind);
    [NullableContextAttribute("1")]
public sealed virtual bool Match(Pattern pattern);
    public sealed virtual bool Fold(MatchResult match);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool get_LastMatched();
    [CompilerGeneratedAttribute]
private void set_LastMatched(bool value);
    public sealed virtual MatchResult get_Result();
}
[NullableContextAttribute("1")]
public interface DocoptNet.IParser`1 {
    public ArgsParseOptions Options { get; }
    public abstract virtual IResult<T> Parse(IEnumerable`1<string> argv);
    public abstract virtual ArgsParseOptions get_Options();
    public abstract virtual IParser`1<T> WithOptions(ArgsParseOptions value);
    public abstract virtual IVersionFeaturingParser`1<T> DisableHelp();
    public abstract virtual IHelpFeaturingParser`1<T> DisableVersion();
}
[NullableContextAttribute("1")]
public interface DocoptNet.IVersionFeaturingParser`1 {
    public abstract virtual IResult<T> Parse(IEnumerable`1<string> argv);
    public abstract virtual IParser`1<T> EnableHelp();
    public abstract virtual IBaselineParser`1<T> DisableVersion();
}
[NullableContextAttribute("1")]
public interface DocoptNet.IVersionResult {
    public string Version { get; }
    public abstract virtual string get_Version();
}
internal class DocoptNet.ParseHandler`1 : MulticastDelegate {
    public ParseHandler`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IResult<T> Invoke(string doc, IEnumerable`1<string> argv, ParseFlags flags, string version);
    public virtual IAsyncResult BeginInvoke(string doc, IEnumerable`1<string> argv, ParseFlags flags, string version, AsyncCallback callback, object object);
    public virtual IResult<T> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocoptNet.ParseHelpResult`1 : object {
    [CompilerGeneratedAttribute]
private string <Help>k__BackingField;
    public string Help { get; }
    public ParseHelpResult`1(string help);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Help();
    private sealed virtual override TResult DocoptNet.IParser<T>.IResult.Match(Func`2<T, TResult> args, Func`2<IHelpResult, TResult> help, Func`2<IVersionResult, TResult> version, Func`2<IInputErrorResult, TResult> error);
    private sealed virtual override TResult DocoptNet.IParser<T>.IResult.Match(Func`3<T, IResult<T>, TResult> args, Func`3<IHelpResult, IResult<T>, TResult> help, Func`3<IVersionResult, IResult<T>, TResult> version, Func`3<IInputErrorResult, IResult<T>, TResult> error);
    private sealed virtual override TResult DocoptNet.IHelpFeaturingParser<T>.IResult.Match(Func`2<T, TResult> args, Func`2<IHelpResult, TResult> help, Func`2<IInputErrorResult, TResult> error);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocoptNet.ParseInputErrorResult`1 : object {
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Usage>k__BackingField;
    public string Error { get; }
    public string Usage { get; }
    public ParseInputErrorResult`1(string error, string usage);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Error();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Usage();
    private sealed virtual override TResult DocoptNet.IParser<T>.IResult.Match(Func`2<T, TResult> args, Func`2<IHelpResult, TResult> help, Func`2<IVersionResult, TResult> version, Func`2<IInputErrorResult, TResult> error);
    private sealed virtual override TResult DocoptNet.IParser<T>.IResult.Match(Func`3<T, IResult<T>, TResult> args, Func`3<IHelpResult, IResult<T>, TResult> help, Func`3<IVersionResult, IResult<T>, TResult> version, Func`3<IInputErrorResult, IResult<T>, TResult> error);
    private sealed virtual override TResult DocoptNet.IHelpFeaturingParser<T>.IResult.Match(Func`2<T, TResult> args, Func`2<IHelpResult, TResult> help, Func`2<IInputErrorResult, TResult> error);
    private sealed virtual override TResult DocoptNet.IVersionFeaturingParser<T>.IResult.Match(Func`2<T, TResult> args, Func`2<IVersionResult, TResult> version, Func`2<IInputErrorResult, TResult> error);
    private sealed virtual override TResult DocoptNet.IBaselineParser<T>.IResult.Match(Func`2<T, TResult> args, Func`2<IInputErrorResult, TResult> error);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocoptNet.Parser`1 : object {
    private string _doc;
    [NullableAttribute("2")]
private string _version;
    private ParseHandler`1<T> _handler;
    private ArgsParseOptions _options;
    private string Version { get; }
    private ParseFlags ParseFlags { get; }
    private ArgsParseOptions DocoptNet.IParser<T>.Options { get; }
    private ArgsParseOptions DocoptNet.IHelpFeaturingParser<T>.Options { get; }
    private ArgsParseOptions DocoptNet.IBaselineParser<T>.Options { get; }
    public Parser`1(string doc, ParseHandler`1<T> handler);
    public Parser`1(string doc, ArgsParseOptions options, string version, ParseHandler`1<T> handler);
    private string get_Version();
    private ParseFlags get_ParseFlags();
    private sealed virtual override IResult<T> DocoptNet.IParser<T>.Parse(IEnumerable`1<string> argv);
    private sealed virtual override IResult<T> DocoptNet.IHelpFeaturingParser<T>.Parse(IEnumerable`1<string> argv);
    private sealed virtual override IParser`1<T> DocoptNet.IHelpFeaturingParser<T>.WithVersion(string value);
    private sealed virtual override IVersionFeaturingParser`1<T> DocoptNet.IBaselineParser<T>.WithVersion(string value);
    private sealed virtual override IHelpFeaturingParser`1<T> DocoptNet.IParser<T>.DisableVersion();
    private sealed virtual override IBaselineParser`1<T> DocoptNet.IVersionFeaturingParser<T>.DisableVersion();
    private sealed virtual override IVersionFeaturingParser`1<T> DocoptNet.IParser<T>.DisableHelp();
    private sealed virtual override IBaselineParser`1<T> DocoptNet.IHelpFeaturingParser<T>.DisableHelp();
    private sealed virtual override IHelpFeaturingParser`1<T> DocoptNet.IBaselineParser<T>.EnableHelp();
    private sealed virtual override IParser`1<T> DocoptNet.IVersionFeaturingParser<T>.EnableHelp();
    private sealed virtual override IResult<T> DocoptNet.IVersionFeaturingParser<T>.Parse(IEnumerable`1<string> argv);
    private sealed virtual override IResult<T> DocoptNet.IBaselineParser<T>.Parse(IEnumerable`1<string> argv);
    private Parser`1<T> WithOptions(ArgsParseOptions value);
    private sealed virtual override ArgsParseOptions DocoptNet.IParser<T>.get_Options();
    private sealed virtual override IParser`1<T> DocoptNet.IParser<T>.WithOptions(ArgsParseOptions value);
    private sealed virtual override ArgsParseOptions DocoptNet.IHelpFeaturingParser<T>.get_Options();
    private sealed virtual override IHelpFeaturingParser`1<T> DocoptNet.IHelpFeaturingParser<T>.WithOptions(ArgsParseOptions value);
    private sealed virtual override ArgsParseOptions DocoptNet.IBaselineParser<T>.get_Options();
    private sealed virtual override IBaselineParser`1<T> DocoptNet.IBaselineParser<T>.WithOptions(ArgsParseOptions value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class DocoptNet.ParseVersionResult`1 : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Version { get; }
    public ParseVersionResult`1(string version);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Version();
    private sealed virtual override TResult DocoptNet.IParser<T>.IResult.Match(Func`2<T, TResult> args, Func`2<IHelpResult, TResult> help, Func`2<IVersionResult, TResult> version, Func`2<IInputErrorResult, TResult> error);
    private sealed virtual override TResult DocoptNet.IParser<T>.IResult.Match(Func`3<T, IResult<T>, TResult> args, Func`3<IHelpResult, IResult<T>, TResult> help, Func`3<IVersionResult, IResult<T>, TResult> version, Func`3<IInputErrorResult, IResult<T>, TResult> error);
    private sealed virtual override TResult DocoptNet.IVersionFeaturingParser<T>.IResult.Match(Func`2<T, TResult> args, Func`2<IVersionResult, TResult> version, Func`2<IInputErrorResult, TResult> error);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class DocoptNet.PrintExitEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ErrorCode>k__BackingField;
    public string Message { get; public set; }
    public int ErrorCode { get; public set; }
    public PrintExitEventArgs(string msg, int errorCode);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public int get_ErrorCode();
    [CompilerGeneratedAttribute]
public void set_ErrorCode(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{DebugDisplay(),nq}")]
public class DocoptNet.StringList : object {
    public static StringList Empty;
    private string _top;
    [NullableAttribute("2")]
private StringList _next;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public bool IsEmpty { get; }
    public int Count { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private StringList(string value, StringList next);
    private StringList(string value, StringList next, int count);
    private static StringList();
    public static StringList BottomTop(String[] items);
    public static StringList TopBottom(String[] items);
    public bool get_IsEmpty();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Count();
    private string DebugDisplay();
    public string Peek();
    public StringList Pop();
    public StringList Push(string value);
    public StringList Reverse();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(StringList other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(StringList left, StringList right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(StringList left, StringList right);
    [IteratorStateMachineAttribute("DocoptNet.StringList/<GetEnumerator>d__22")]
public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class DocoptNet.Tokens : object {
    private Queue`1<string> _tokens;
    public Type ErrorType { get; }
    public bool ThrowsInputError { get; }
    protected Tokens(IEnumerable`1<string> source);
    private static Tokens New(IEnumerable`1<string> source, Func`2<string, TError> errorFactory);
    public static Tokens From(IEnumerable`1<string> source);
    public static Tokens FromPattern(string pattern);
    public abstract virtual Type get_ErrorType();
    public abstract virtual Exception CreateException(string message);
    public bool get_ThrowsInputError();
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public string Move();
    [NullableContextAttribute("2")]
public string Current();
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class DocoptNet.ValueObject : object {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public bool IsNullOrEmpty { get; }
    public bool IsFalse { get; }
    public bool IsTrue { get; }
    public bool IsList { get; }
    internal bool IsOfTypeInt { get; }
    public bool IsInt { get; }
    public bool IsString { get; }
    public int AsInt { get; }
    [NullableAttribute("1")]
public ArrayList AsList { get; }
    internal ValueObject(object obj);
    [CompilerGeneratedAttribute]
public object get_Value();
    public bool get_IsNullOrEmpty();
    public bool get_IsFalse();
    public bool get_IsTrue();
    public bool get_IsList();
    internal bool get_IsOfTypeInt();
    public bool get_IsInt();
    public bool get_IsString();
    public int get_AsInt();
    [NullableContextAttribute("1")]
public ArrayList get_AsList();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
internal static string Format(object value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
internal static class MoreLinq.MoreEnumerable : object {
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Choose(IEnumerable`1<T> source, Func`2<T, ValueTuple`2<bool, TResult>> chooser);
}
internal static class OptionModule : object {
    [NullableContextAttribute("1")]
public static ValueTuple`2<bool, T> Some(T value);
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class System.Runtime.CompilerServices.SwitchExpressionException : InvalidOperationException {
    [CompilerGeneratedAttribute]
private object <UnmatchedValue>k__BackingField;
    public object UnmatchedValue { get; }
    [NullableAttribute("1")]
public string Message { get; }
    public SwitchExpressionException(Exception innerException);
    public SwitchExpressionException(object unmatchedValue);
    public SwitchExpressionException(string message);
    public SwitchExpressionException(string message, Exception innerException);
    [NullableContextAttribute("1")]
private SwitchExpressionException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public object get_UnmatchedValue();
    [NullableContextAttribute("1")]
public virtual string get_Message();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
