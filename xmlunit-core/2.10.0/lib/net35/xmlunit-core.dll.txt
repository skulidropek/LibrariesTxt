internal abstract class Org.XmlUnit.Builder.AbstractTransformationBuilder`1 : object {
    private Transformation t;
    protected Transformation Helper { get; }
    private B AsB { get; }
    protected AbstractTransformationBuilder`1(ISource s);
    public sealed virtual B WithStylesheet(ISource s);
    public sealed virtual B WithExtensionObject(string namespaceUri, object extension);
    public sealed virtual B WithParameter(string name, string namespaceUri, object parameter);
    public sealed virtual B WithXmlResolver(XmlResolver r);
    public sealed virtual B WithScripting();
    public sealed virtual B WithoutScripting();
    private B WithScripting(bool b);
    public sealed virtual B WithDocumentFunction();
    public sealed virtual B WithoutDocumentFunction();
    private B WithDocumentFunction(bool b);
    protected Transformation get_Helper();
    private B get_AsB();
}
public class Org.XmlUnit.Builder.DiffBuilder : object {
    private static ComparisonResult[] CHECK_FOR_SIMILAR;
    private static ComparisonResult[] CHECK_FOR_IDENTICAL;
    private ISource controlSource;
    private ISource testSource;
    private INodeMatcher nodeMatcher;
    private ComparisonController comparisonController;
    private DifferenceEvaluator differenceEvaluator;
    private List`1<ComparisonListener> comparisonListeners;
    private List`1<ComparisonListener> differenceListeners;
    private Predicate`1<XmlAttribute> attributeFilter;
    private Predicate`1<XmlNode> nodeFilter;
    private IComparisonFormatter formatter;
    private ComparisonResult[] comparisonResultsToCheck;
    private IDictionary`2<string, string> namespaceContext;
    private bool ignoreWhitespace;
    private bool normalizeWhitespace;
    private bool ignoreECW;
    private bool ignoreXmlWhitespace;
    private bool normalizeXmlWhitespace;
    private bool ignoreXmlECW;
    private bool ignoreComments;
    private string ignoreCommentVersion;
    private DiffBuilder(ISource controlSource);
    private static DiffBuilder();
    public static DiffBuilder Compare(object control);
    public DiffBuilder WithTest(object test);
    private static ISource GetSource(object source);
    public DiffBuilder IgnoreWhitespace();
    public DiffBuilder IgnoreXmlWhitespace();
    public DiffBuilder IgnoreElementContentWhitespace();
    public DiffBuilder IgnoreXmlElementContentWhitespace();
    public DiffBuilder NormalizeWhitespace();
    public DiffBuilder NormalizeXmlWhitespace();
    public DiffBuilder IgnoreComments();
    public DiffBuilder IgnoreCommentsUsingXSLTVersion(string xsltVersion);
    public sealed virtual DiffBuilder WithNodeMatcher(INodeMatcher nodeMatcher);
    public sealed virtual DiffBuilder WithDifferenceEvaluator(DifferenceEvaluator differenceEvaluator);
    public sealed virtual DiffBuilder WithComparisonController(ComparisonController comparisonController);
    public sealed virtual DiffBuilder WithComparisonListeners(ComparisonListener[] comparisonListeners);
    public sealed virtual DiffBuilder WithDifferenceListeners(ComparisonListener[] comparisonListeners);
    public sealed virtual DiffBuilder WithAttributeFilter(Predicate`1<XmlAttribute> attributeFilter);
    public sealed virtual DiffBuilder WithNodeFilter(Predicate`1<XmlNode> nodeFilter);
    public DiffBuilder CheckForSimilar();
    public DiffBuilder CheckForIdentical();
    public sealed virtual DiffBuilder WithNamespaceContext(IDictionary`2<string, string> ctx);
    public sealed virtual DiffBuilder WithComparisonFormatter(IComparisonFormatter formatter);
    public Diff Build();
    private ISource Wrap(ISource source);
}
public interface Org.XmlUnit.Builder.IDifferenceEngineConfigurer`1 {
    public abstract virtual D WithNodeMatcher(INodeMatcher nodeMatcher);
    public abstract virtual D WithDifferenceEvaluator(DifferenceEvaluator differenceEvaluator);
    public abstract virtual D WithComparisonController(ComparisonController comparisonController);
    public abstract virtual D WithComparisonListeners(ComparisonListener[] comparisonListeners);
    public abstract virtual D WithDifferenceListeners(ComparisonListener[] comparisonListeners);
    public abstract virtual D WithNamespaceContext(IDictionary`2<string, string> prefix2Uri);
    public abstract virtual D WithAttributeFilter(Predicate`1<XmlAttribute> attributeFilter);
    public abstract virtual D WithNodeFilter(Predicate`1<XmlNode> nodeFilter);
    public abstract virtual D WithComparisonFormatter(IComparisonFormatter formatter);
}
public class Org.XmlUnit.Builder.Input : object {
    public static IBuilder FromDocument(XmlDocument d);
    public static IBuilder FromNode(XmlNode n);
    public static IBuilder FromFile(string name);
    public static IBuilder FromStream(Stream s);
    public static IBuilder FromReader(TextReader r);
    public static IBuilder FromString(string s);
    public static IBuilder FromByteArray(Byte[] b);
    public static IBuilder FromURI(string uri);
    public static IBuilder FromURI(Uri uri);
    public static ITransformationBuilder ByTransforming(ISource s);
    public static ITransformationBuilder ByTransforming(IBuilder b);
    public static IBuilder FromDocument(XDocument d);
    public static IBuilder FromNode(XNode n);
    public static IBuilder From(object source);
}
public interface Org.XmlUnit.Builder.ITransformationBuilderBase`1 {
    public abstract virtual B WithDocumentFunction();
    public abstract virtual B WithExtensionObject(string namespaceUri, object extension);
    public abstract virtual B WithParameter(string name, string namespaceUri, object parameter);
    public abstract virtual B WithScripting();
    public abstract virtual B WithStylesheet(ISource s);
    public abstract virtual B WithXmlResolver(XmlResolver r);
    public abstract virtual B WithoutDocumentFunction();
    public abstract virtual B WithoutScripting();
}
public class Org.XmlUnit.Builder.Transform : object {
    public static IBuilder Source(ISource s);
}
public abstract class Org.XmlUnit.Diff.AbstractDifferenceEngine : object {
    private ComparisonListener ComparisonListener;
    private ComparisonListener MatchListener;
    private ComparisonListener DifferenceListener;
    private INodeMatcher nodeMatcher;
    private Predicate`1<XmlAttribute> attributeFilter;
    private Predicate`1<XmlNode> nodeFilter;
    private DifferenceEvaluator diffEvaluator;
    private ComparisonController comparisonController;
    private IDictionary`2<string, string> namespaceContext;
    [CompilerGeneratedAttribute]
private static Predicate`1<XmlAttribute> CS$<>9__CachedAnonymousMethodDelegate1;
    public INodeMatcher NodeMatcher { get; public set; }
    public DifferenceEvaluator DifferenceEvaluator { get; public set; }
    public ComparisonController ComparisonController { get; public set; }
    public Predicate`1<XmlAttribute> AttributeFilter { get; public set; }
    public Predicate`1<XmlNode> NodeFilter { get; public set; }
    protected IDictionary`2<string, string> NamespaceContext { get; public set; }
    public sealed virtual void add_ComparisonListener(ComparisonListener value);
    public sealed virtual void remove_ComparisonListener(ComparisonListener value);
    public sealed virtual void add_MatchListener(ComparisonListener value);
    public sealed virtual void remove_MatchListener(ComparisonListener value);
    public sealed virtual void add_DifferenceListener(ComparisonListener value);
    public sealed virtual void remove_DifferenceListener(ComparisonListener value);
    public virtual void set_NodeMatcher(INodeMatcher value);
    public virtual INodeMatcher get_NodeMatcher();
    public virtual void set_DifferenceEvaluator(DifferenceEvaluator value);
    public virtual DifferenceEvaluator get_DifferenceEvaluator();
    public virtual void set_ComparisonController(ComparisonController value);
    public virtual ComparisonController get_ComparisonController();
    public virtual void set_AttributeFilter(Predicate`1<XmlAttribute> value);
    public virtual Predicate`1<XmlAttribute> get_AttributeFilter();
    public virtual void set_NodeFilter(Predicate`1<XmlNode> value);
    public virtual Predicate`1<XmlNode> get_NodeFilter();
    public abstract virtual void Compare(ISource control, ISource test);
    public sealed virtual void set_NamespaceContext(IDictionary`2<string, string> value);
    protected IDictionary`2<string, string> get_NamespaceContext();
    protected internal ComparisonState Compare(Comparison comp);
    private void FireComparisonPerformed(Comparison comp, ComparisonResult outcome);
    protected static string GetXPath(XPathContext ctx);
    protected static string GetParentXPath(XPathContext ctx);
    [CompilerGeneratedAttribute]
private static bool <.ctor>b__0(XmlAttribute a);
}
public static class Org.XmlUnit.Diff.ByNameAndTextRecSelector : object {
    public static bool CanBeCompared(XmlElement controlElement, XmlElement testElement);
    private static XmlNode FindNonText(XmlNodeList nl, Int32& current, int len);
    private static bool IsText(XmlNode n);
}
internal class Org.XmlUnit.Diff.ChildNodeXPathContextProvider : object {
    private XPathContext xpathContext;
    private Dictionary`2<XmlNode, int> childIndex;
    [CompilerGeneratedAttribute]
private static Func`3<XmlNode, int, <>f__AnonymousType0`2<XmlNode, int>> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType0`2<XmlNode, int>, XmlNode> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<<>f__AnonymousType0`2<XmlNode, int>, int> CS$<>9__CachedAnonymousMethodDelegate5;
    internal ChildNodeXPathContextProvider(XPathContext parentContext, IEnumerable`1<XmlNode> children);
    internal XPathContext Map(XmlNode n);
    [CompilerGeneratedAttribute]
private static <>f__AnonymousType0`2<XmlNode, int> <.ctor>b__0(XmlNode n, int i);
    [CompilerGeneratedAttribute]
private static XmlNode <.ctor>b__1(<>f__AnonymousType0`2<XmlNode, int> t);
    [CompilerGeneratedAttribute]
private static int <.ctor>b__2(<>f__AnonymousType0`2<XmlNode, int> t);
}
public class Org.XmlUnit.Diff.Comparison : object {
    private Detail control;
    private Detail test;
    private ComparisonType type;
    public ComparisonType Type { get; }
    public Detail ControlDetails { get; }
    public Detail TestDetails { get; }
    public Comparison(ComparisonType t, XmlNode controlTarget, string controlXPath, object controlValue, string controlParentXPath, XmlNode testTarget, string testXPath, object testValue, string testParentXPath);
    public ComparisonType get_Type();
    public Detail get_ControlDetails();
    public Detail get_TestDetails();
    public string ToString(IComparisonFormatter formatter);
    public virtual string ToString();
}
public class Org.XmlUnit.Diff.ComparisonController : MulticastDelegate {
    public ComparisonController(object object, IntPtr method);
    public virtual bool Invoke(Difference difference);
    public virtual IAsyncResult BeginInvoke(Difference difference, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public static class Org.XmlUnit.Diff.ComparisonControllers : object {
    public static bool Default(Difference diff);
    public static bool StopWhenDifferent(Difference diff);
    public static bool StopWhenSimilar(Difference diff);
    private static bool Stop(Difference d, ComparisonResult minimumComparisonResult);
}
public class Org.XmlUnit.Diff.ComparisonListener : MulticastDelegate {
    public ComparisonListener(object object, IntPtr method);
    public virtual void Invoke(Comparison comparison, ComparisonResult outcome);
    public virtual IAsyncResult BeginInvoke(Comparison comparison, ComparisonResult outcome, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum Org.XmlUnit.Diff.ComparisonResult : Enum {
    public int value__;
    public static ComparisonResult EQUAL;
    public static ComparisonResult SIMILAR;
    public static ComparisonResult DIFFERENT;
}
public enum Org.XmlUnit.Diff.ComparisonType : Enum {
    public int value__;
    public static ComparisonType XML_VERSION;
    public static ComparisonType XML_STANDALONE;
    public static ComparisonType XML_ENCODING;
    public static ComparisonType HAS_DOCTYPE_DECLARATION;
    public static ComparisonType DOCTYPE_NAME;
    public static ComparisonType DOCTYPE_PUBLIC_ID;
    public static ComparisonType DOCTYPE_SYSTEM_ID;
    public static ComparisonType SCHEMA_LOCATION;
    public static ComparisonType NO_NAMESPACE_SCHEMA_LOCATION;
    public static ComparisonType NODE_TYPE;
    public static ComparisonType NAMESPACE_PREFIX;
    public static ComparisonType NAMESPACE_URI;
    public static ComparisonType TEXT_VALUE;
    public static ComparisonType PROCESSING_INSTRUCTION_TARGET;
    public static ComparisonType PROCESSING_INSTRUCTION_DATA;
    public static ComparisonType ELEMENT_TAG_NAME;
    public static ComparisonType ATTR_VALUE_EXPLICITLY_SPECIFIED;
    public static ComparisonType ELEMENT_NUM_ATTRIBUTES;
    public static ComparisonType ATTR_VALUE;
    public static ComparisonType CHILD_NODELIST_LENGTH;
    public static ComparisonType CHILD_NODELIST_SEQUENCE;
    public static ComparisonType CHILD_LOOKUP;
    public static ComparisonType ATTR_NAME_LOOKUP;
}
[ExtensionAttribute]
public static class Org.XmlUnit.Diff.ComparisonTypes : object {
    private static IDictionary`2<ComparisonType, string> DESCS;
    private static HashSet`1<ComparisonType> DOCTYPE_COMPARISONS;
    private static ComparisonTypes();
    [ExtensionAttribute]
public static string GetDescription(ComparisonType type);
    [ExtensionAttribute]
internal static bool IsDoctypeComparison(ComparisonType type);
}
public class Org.XmlUnit.Diff.DefaultComparisonFormatter : object {
    public sealed virtual string GetDescription(Comparison difference);
    protected virtual object GetValue(object value, ComparisonType type);
    protected virtual string GetShortString(XmlNode node, string xpath, ComparisonType type);
    protected virtual void AppendXPath(StringBuilder sb, string xpath);
    protected virtual bool AppendDocumentXmlDeclaration(StringBuilder sb, XmlDeclaration dec);
    protected virtual void AppendDocumentElementIndication(StringBuilder sb, XmlDocument doc);
    protected virtual bool AppendDocumentType(StringBuilder sb, XmlDocumentType type);
    protected virtual void AppendProcessingInstruction(StringBuilder sb, XmlProcessingInstruction instr);
    protected virtual void AppendComment(StringBuilder sb, XmlComment aNode);
    protected virtual void AppendText(StringBuilder sb, XmlCharacterData aNode);
    protected virtual void AppendElement(StringBuilder sb, XmlElement aNode);
    protected virtual void AppendAttribute(StringBuilder sb, XmlAttribute aNode);
    public sealed virtual string GetDetails(Detail difference, ComparisonType type, bool formatXml);
    protected virtual string GetFullFormattedXml(XmlNode node, ComparisonType type, bool formatXml);
    protected virtual void AppendFullDocumentHeader(StringBuilder sb, XmlDocument doc);
    private void AppendOnlyElementStartTagWithAttributes(StringBuilder sb, XmlElement element);
    protected virtual string GetFormattedNodeXml(XmlNode nodeToConvert, bool formatXml);
    protected virtual XmlWriter CreateXmlWriter(StringBuilder sb, int numberOfBlanksToIndent);
    protected virtual string NodeType(XmlNodeType type);
}
internal class Org.XmlUnit.Diff.DefaultConditionalSelectorBuilder : object {
    private ElementSelector defaultSelector;
    private IList`1<KeyValuePair`2<Predicate`1<XmlElement>, ElementSelector>> conditionalSelectors;
    private Predicate`1<XmlElement> pendingCondition;
    public sealed virtual IConditionalSelectorBuilder ThenUse(ElementSelector es);
    public sealed virtual IConditionalSelectorBuilderThen When(Predicate`1<XmlElement> predicate);
    public sealed virtual IConditionalSelectorBuilder ElseUse(ElementSelector es);
    public sealed virtual IConditionalSelectorBuilderThen WhenElementIsNamed(string expectedName);
    public sealed virtual IConditionalSelectorBuilderThen WhenElementIsNamed(XmlQualifiedName expectedName);
    public sealed virtual ElementSelector Build();
}
public class Org.XmlUnit.Diff.DefaultNodeMatcher : object {
    private ElementSelector[] elementSelectors;
    private NodeTypeMatcher nodeTypeMatcher;
    public DefaultNodeMatcher(ElementSelector[] es);
    public DefaultNodeMatcher(NodeTypeMatcher ntm, ElementSelector[] es);
    public sealed virtual IEnumerable`1<KeyValuePair`2<XmlNode, XmlNode>> Match(IEnumerable`1<XmlNode> controlNodes, IEnumerable`1<XmlNode> testNodes);
    private MatchInfo FindMatchingNode(XmlNode searchFor, IList`1<XmlNode> searchIn, int indexOfLastMatch, ICollection`1<int> availableIndexes, ElementSelector e);
    private MatchInfo SearchIn(XmlNode searchFor, IList`1<XmlNode> searchIn, ICollection`1<int> availableIndexes, int fromInclusive, int toExclusive, ElementSelector e);
    private bool NodesMatch(XmlNode n1, XmlNode n2, ElementSelector elementSelector);
    public static bool DefaultNodeTypeMatcher(XmlNodeType controlType, XmlNodeType testType);
}
public class Org.XmlUnit.Diff.Diff : object {
    private static IComparisonFormatter DEFAULT_FORMATTER;
    private IEnumerable`1<Difference> differences;
    private ISource controlSource;
    private ISource testSource;
    private IComparisonFormatter formatter;
    public IEnumerable`1<Difference> Differences { get; }
    public ISource ControlSource { get; }
    public ISource TestSource { get; }
    public Diff(ISource controlSource, ISource testSource, IEnumerable`1<Difference> differences);
    public Diff(ISource controlSource, ISource testSource, IComparisonFormatter formatter, IEnumerable`1<Difference> differences);
    private static Diff();
    public bool HasDifferences();
    public IEnumerable`1<Difference> get_Differences();
    public ISource get_ControlSource();
    public ISource get_TestSource();
    public virtual string ToString();
    public string ToString(IComparisonFormatter formatter);
    public string FullDescription();
    public string FullDescription(IComparisonFormatter formatter);
}
public class Org.XmlUnit.Diff.Difference : object {
    private ComparisonResult result;
    private Comparison comparison;
    private IComparisonFormatter formatter;
    public ComparisonResult Result { get; }
    public Comparison Comparison { get; }
    unknown IComparisonFormatter Formatter {public set; }
    public Difference(Comparison comparison, ComparisonResult result);
    public ComparisonResult get_Result();
    public Comparison get_Comparison();
    public void set_Formatter(IComparisonFormatter value);
    public string ToString(IComparisonFormatter formatter);
    public virtual string ToString();
}
public class Org.XmlUnit.Diff.DifferenceEvaluator : MulticastDelegate {
    public DifferenceEvaluator(object object, IntPtr method);
    public virtual ComparisonResult Invoke(Comparison comparison, ComparisonResult outcome);
    public virtual IAsyncResult BeginInvoke(Comparison comparison, ComparisonResult outcome, AsyncCallback callback, object object);
    public virtual ComparisonResult EndInvoke(IAsyncResult result);
}
public static class Org.XmlUnit.Diff.DifferenceEvaluators : object {
    [CompilerGeneratedAttribute]
private static DifferenceEvaluator CS$<>9__CachedAnonymousMethodDelegatee;
    [CompilerGeneratedAttribute]
private static DifferenceEvaluator CS$<>9__CachedAnonymousMethodDelegate10;
    public static ComparisonResult Accept(Comparison comparison, ComparisonResult outcome);
    public static ComparisonResult Default(Comparison comparison, ComparisonResult outcome);
    public static DifferenceEvaluator First(DifferenceEvaluator[] evaluators);
    public static DifferenceEvaluator Chain(DifferenceEvaluator[] evaluators);
    public static DifferenceEvaluator DowngradeDifferencesToEqual(ComparisonType[] types);
    public static DifferenceEvaluator DowngradeDifferencesToSimilar(ComparisonType[] types);
    public static DifferenceEvaluator UpgradeDifferencesToDifferent(ComparisonType[] types);
    public static DifferenceEvaluator IgnorePrologDifferences();
    public static DifferenceEvaluator IgnorePrologDifferencesExceptDoctype();
    private static DifferenceEvaluator RecordDifferencesAs(ComparisonResult outcome, ComparisonType[] types);
    private static bool BelongsToProlog(Comparison comparison, bool ignoreDoctypeDeclarationAsWell);
    private static bool BelongsToProlog(XmlNode n, bool ignoreDoctypeDeclarationAsWell);
    private static bool IsSequenceOfRootElement(Comparison comparison);
    [CompilerGeneratedAttribute]
private static ComparisonResult <IgnorePrologDifferences>b__d(Comparison comparison, ComparisonResult orig);
    [CompilerGeneratedAttribute]
private static ComparisonResult <IgnorePrologDifferencesExceptDoctype>b__f(Comparison comparison, ComparisonResult orig);
}
public class Org.XmlUnit.Diff.DOMDifferenceEngine : AbstractDifferenceEngine {
    public virtual void Compare(ISource control, ISource test);
    private XPathContext XPathContextFor(XmlNode n);
    internal ComparisonState CompareNodes(XmlNode control, XPathContext controlContext, XmlNode test, XPathContext testContext);
    private ComparisonState NodeTypeSpecificComparison(XmlNode control, XPathContext controlContext, XmlNode test, XPathContext testContext);
    private Func`1<ComparisonState> CompareChildren(XPathContext controlContext, IEnumerable`1<XmlNode> allControlChildren, IEnumerable`1<XmlNode> controlChildren, XPathContext testContext, IEnumerable`1<XmlNode> allTestChildren, IEnumerable`1<XmlNode> testChildren);
    private ComparisonState CompareCharacterData(XmlCharacterData control, XPathContext controlContext, XmlCharacterData test, XPathContext testContext);
    private ComparisonState CompareDocuments(XmlDocument control, XPathContext controlContext, XmlDocument test, XPathContext testContext);
    private T FilterNode(T n);
    private ComparisonState CompareDocTypes(XmlDocumentType control, XPathContext controlContext, XmlDocumentType test, XPathContext testContext);
    private ComparisonState CompareDeclarations(XmlDeclaration control, XPathContext controlContext, XmlDeclaration test, XPathContext testContext);
    private ComparisonState CompareElements(XmlElement control, XPathContext controlContext, XmlElement test, XPathContext testContext);
    private ComparisonState CompareElementAttributes(XmlElement control, XPathContext controlContext, XmlElement test, XPathContext testContext);
    private Func`1<ComparisonState> NormalAttributeComparer(XmlElement control, XPathContext controlContext, Attributes controlAttributes, XmlElement test, XPathContext testContext, Attributes testAttributes);
    private ComparisonState CompareProcessingInstructions(XmlProcessingInstruction control, XPathContext controlContext, XmlProcessingInstruction test, XPathContext testContext);
    private ComparisonState CompareNodeLists(IEnumerable`1<XmlNode> allControlChildren, IEnumerable`1<XmlNode> controlSeq, XPathContext controlContext, IEnumerable`1<XmlNode> allTestChildren, IEnumerable`1<XmlNode> testSeq, XPathContext testContext);
    private Func`1<ComparisonState> UnmatchedControlNodes(IDictionary`2<XmlNode, int> controlListForXpathIndex, IList`1<XmlNode> controlList, XPathContext controlContext, ICollection`1<XmlNode> seen, XPathContext testContext);
    private Func`1<ComparisonState> UnmatchedTestNodes(IDictionary`2<XmlNode, int> testListForXpathIndex, IList`1<XmlNode> testList, XPathContext testContext, ICollection`1<XmlNode> seen, XPathContext controlContext);
    private ComparisonState CompareXsiType(XmlAttribute control, XPathContext controlContext, XmlAttribute test, XPathContext testContext);
    private ComparisonState CompareAttributes(XmlAttribute control, XPathContext controlContext, XmlAttribute test, XPathContext testContext);
    private ComparisonState CompareAttributeExplicitness(XmlAttribute control, XPathContext controlContext, XmlAttribute test, XPathContext testContext);
    private Attributes SplitAttributes(XmlAttributeCollection map);
    private static XmlQualifiedName ValueAsQName(XmlAttribute attribute);
    private static XmlAttribute FindMatchingAttr(IList`1<XmlAttribute> attrs, XmlAttribute attrToMatch);
    private static IDictionary`2<XmlNode, int> Index(IEnumerable`1<XmlNode> nodes);
    [CompilerGeneratedAttribute]
private bool <CompareNodes>b__0(XmlNode n);
    [CompilerGeneratedAttribute]
private bool <CompareNodes>b__1(XmlNode n);
}
public class Org.XmlUnit.Diff.ElementSelector : MulticastDelegate {
    public ElementSelector(object object, IntPtr method);
    public virtual bool Invoke(XmlElement controlElement, XmlElement testElement);
    public virtual IAsyncResult BeginInvoke(XmlElement controlElement, XmlElement testElement, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public static class Org.XmlUnit.Diff.ElementSelectors : object {
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<string, XmlQualifiedName> CS$<>9__CachedAnonymousMethodDelegate3;
    [CompilerGeneratedAttribute]
private static Func`2<XmlQualifiedName, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegateb;
    [CompilerGeneratedAttribute]
private static Predicate`1<XmlAttribute> CS$<>9__CachedAnonymousMethodDelegatef;
    [CompilerGeneratedAttribute]
private static Func`2<ElementSelector, bool> CS$<>9__CachedAnonymousMethodDelegate19;
    [CompilerGeneratedAttribute]
private static Func`2<ElementSelector, bool> CS$<>9__CachedAnonymousMethodDelegate21;
    public static bool Default(XmlElement controlElement, XmlElement testElement);
    public static bool ByName(XmlElement controlElement, XmlElement testElement);
    public static bool ByNameAndText(XmlElement controlElement, XmlElement testElement);
    public static ElementSelector ByNameAndAttributes(String[] attribs);
    public static ElementSelector ByNameAndAttributes(XmlQualifiedName[] attribs);
    public static ElementSelector ByNameAndAttributesControlNS(String[] attribs);
    public static bool ByNameAndAllAttributes(XmlElement controlElement, XmlElement testElement);
    public static ElementSelector ByNameAndAllAttributes(Predicate`1<XmlAttribute> attributeFiler);
    public static ElementSelector Not(ElementSelector es);
    public static ElementSelector Or(ElementSelector[] selectors);
    public static ElementSelector And(ElementSelector[] selectors);
    public static ElementSelector Xor(ElementSelector es1, ElementSelector es2);
    public static ElementSelector ConditionalSelector(Predicate`1<XmlElement> predicate, ElementSelector es);
    public static ElementSelector SelectorForElementNamed(string expectedName, ElementSelector es);
    public static ElementSelector SelectorForElementNamed(XmlQualifiedName expectedName, ElementSelector es);
    public static ElementSelector ByXPath(string xpath, ElementSelector childSelector);
    public static ElementSelector ByXPath(string xpath, IDictionary`2<string, string> prefix2Uri, ElementSelector childSelector);
    public static IConditionalSelectorBuilder ConditionalBuilder();
    internal static Predicate`1<XmlElement> ElementNamePredicate(string expectedName);
    internal static Predicate`1<XmlElement> ElementNamePredicate(XmlQualifiedName expectedName);
    internal static INodeInfo TO_NODE_INFO(XmlNode n);
    private static bool MapsEqualForKeys(IDictionary`2<XmlQualifiedName, string> control, IDictionary`2<XmlQualifiedName, string> test, IEnumerable`1<XmlQualifiedName> keys);
    private static bool ByNameAndAllAttributes(Predicate`1<XmlAttribute> attributeFiler, XmlElement controlElement, XmlElement testElement);
    [CompilerGeneratedAttribute]
private static bool <ByNameAndAttributes>b__0(string a);
    [CompilerGeneratedAttribute]
private static XmlQualifiedName <ByNameAndAttributes>b__1(string a);
    [CompilerGeneratedAttribute]
private static bool <ByNameAndAttributes>b__4(XmlQualifiedName a);
    [CompilerGeneratedAttribute]
private static bool <ByNameAndAttributesControlNS>b__9(string a);
    [CompilerGeneratedAttribute]
private static bool <ByNameAndAllAttributes>b__e(XmlAttribute ignored);
    [CompilerGeneratedAttribute]
private static bool <Or>b__16(ElementSelector s);
    [CompilerGeneratedAttribute]
private static bool <And>b__1e(ElementSelector s);
}
public interface Org.XmlUnit.Diff.IComparisonFormatter {
    public abstract virtual string GetDescription(Comparison comparison);
    public abstract virtual string GetDetails(Detail details, ComparisonType type, bool formatXml);
}
public interface Org.XmlUnit.Diff.IDifferenceEngine {
    unknown INodeMatcher NodeMatcher {public set; }
    unknown DifferenceEvaluator DifferenceEvaluator {public set; }
    unknown ComparisonController ComparisonController {public set; }
    unknown IDictionary`2<string, string> NamespaceContext {public set; }
    unknown Predicate`1<XmlAttribute> AttributeFilter {public set; }
    unknown Predicate`1<XmlNode> NodeFilter {public set; }
    public abstract virtual void add_ComparisonListener(ComparisonListener value);
    public abstract virtual void remove_ComparisonListener(ComparisonListener value);
    public abstract virtual void add_MatchListener(ComparisonListener value);
    public abstract virtual void remove_MatchListener(ComparisonListener value);
    public abstract virtual void add_DifferenceListener(ComparisonListener value);
    public abstract virtual void remove_DifferenceListener(ComparisonListener value);
    public abstract virtual void set_NodeMatcher(INodeMatcher value);
    public abstract virtual void set_DifferenceEvaluator(DifferenceEvaluator value);
    public abstract virtual void set_ComparisonController(ComparisonController value);
    public abstract virtual void set_NamespaceContext(IDictionary`2<string, string> value);
    public abstract virtual void set_AttributeFilter(Predicate`1<XmlAttribute> value);
    public abstract virtual void set_NodeFilter(Predicate`1<XmlNode> value);
    public abstract virtual void Compare(ISource control, ISource test);
}
public interface Org.XmlUnit.Diff.INodeMatcher {
    public abstract virtual IEnumerable`1<KeyValuePair`2<XmlNode, XmlNode>> Match(IEnumerable`1<XmlNode> controlNodes, IEnumerable`1<XmlNode> testNodes);
}
public class Org.XmlUnit.Diff.MultiLevelByNameAndTextSelector : object {
    private int levels;
    private bool ignoreEmptyTexts;
    public MultiLevelByNameAndTextSelector(int levels);
    public MultiLevelByNameAndTextSelector(int levels, bool ignoreEmptyTexts);
    public bool CanBeCompared(XmlElement controlElement, XmlElement testElement);
    private XmlNode GetFirstEligibleChild(XmlNode parent);
    private static bool IsText(XmlNode n);
}
public static class Org.XmlUnit.Diff.NodeFilters : object {
    public static bool Default(XmlNode n);
    public static bool AcceptAll(XmlNode n);
    public static Predicate`1<XmlNode> SatifiesAll(Predicate`1[] predicates);
    public static Predicate`1<XmlNode> SatifiesAny(Predicate`1[] predicates);
}
public class Org.XmlUnit.Diff.RecursiveXPathBuilder : object {
    private IDictionary`2<string, string> prefix2uri;
    unknown IDictionary`2<string, string> NamespaceContext {public set; }
    public void set_NamespaceContext(IDictionary`2<string, string> value);
    public XPathContext Map(XmlNode n);
    private XPathContext GetXPathForNonAttribute(XmlNode n);
    private XPathContext GetXPathForAttribute(XmlAttribute a);
}
public class Org.XmlUnit.Diff.XPathContext : object {
    private static string COMMENT;
    private static string PI;
    private static string TEXT;
    private static string OPEN;
    private static string CLOSE;
    private static string SEP;
    private static string ATTR;
    private LinkedList`1<Level> path;
    private IDictionary`2<string, string> uri2Prefix;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, string>, string> CS$<>9__CachedAnonymousMethodDelegate2;
    [CompilerGeneratedAttribute]
private static Func`2<KeyValuePair`2<string, string>, string> CS$<>9__CachedAnonymousMethodDelegate3;
    public string XPath { get; }
    public string ParentXPath { get; }
    public XPathContext(XmlNode root);
    public XPathContext(IDictionary`2<string, string> prefix2uri);
    public XPathContext(IDictionary`2<string, string> prefix2uri, XmlNode root);
    public void NavigateToChild(int n);
    public void NavigateToAttribute(XmlQualifiedName attribute);
    public void NavigateToParent();
    public void AddAttributes(IEnumerable`1<Q> attributes);
    public void AddAttribute(XmlQualifiedName attribute);
    public void SetChildren(IEnumerable`1<N> children);
    public void AppendChildren(IEnumerable`1<N> children);
    public string get_XPath();
    public string get_ParentXPath();
    public sealed virtual object Clone();
    private static string GetXPath(LinkedListNode`1<Level> l);
    private string GetName(XmlQualifiedName name);
    private static int Add1OrIncrement(string name, IDictionary`2<string, int> map);
    private static IDictionary`2<string, string> Invert(IDictionary`2<string, string> m);
    [CompilerGeneratedAttribute]
private static string <Invert>b__0(KeyValuePair`2<string, string> e);
    [CompilerGeneratedAttribute]
private static string <Invert>b__1(KeyValuePair`2<string, string> e);
}
public abstract class Org.XmlUnit.Input.AbstractSource : object {
    private bool disposed;
    private string systemId;
    private XmlReader reader;
    public XmlReader Reader { get; }
    public string SystemId { get; public set; }
    protected AbstractSource(XmlReader r);
    public sealed virtual XmlReader get_Reader();
    public sealed virtual string get_SystemId();
    public sealed virtual void set_SystemId(string value);
    public virtual string ToString();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Org.XmlUnit.Input.ByteArraySource : object {
    private string systemId;
    private Byte[] content;
    public XmlReader Reader { get; }
    public string SystemId { get; public set; }
    public ByteArraySource(Byte[] c);
    public sealed virtual XmlReader get_Reader();
    public sealed virtual string get_SystemId();
    public sealed virtual void set_SystemId(string value);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
public class Org.XmlUnit.Input.CommentLessSource : object {
    private static string DEFAULT_VERSION;
    private static string STYLE_TEMPLATE;
    private bool disposed;
    private XmlReader reader;
    private string systemId;
    private static string STYLE;
    public XmlReader Reader { get; }
    public string SystemId { get; public set; }
    public CommentLessSource(ISource originalSource);
    public CommentLessSource(ISource originalSource, string xsltVersion);
    private static CommentLessSource();
    public sealed virtual XmlReader get_Reader();
    public sealed virtual string get_SystemId();
    public sealed virtual void set_SystemId(string value);
    public sealed virtual void Dispose();
    private static ISource GetStylesheet(string xsltVersion);
    private static string GetStylesheetContentCached(string xsltVersion);
    private static string GetStylesheetContent(string xsltVersion);
}
public class Org.XmlUnit.Input.DOMSource : AbstractSource {
    private XmlNode node;
    public XmlNode Node { get; }
    public DOMSource(XmlNode node);
    public XmlNode get_Node();
}
public class Org.XmlUnit.Input.ElementContentWhitespaceStrippedSource : DOMSource {
    public ElementContentWhitespaceStrippedSource(ISource originalSource);
}
public class Org.XmlUnit.Input.LinqSource : AbstractSource {
    private XNode node;
    public XNode Node { get; }
    public LinqSource(XNode node);
    public XNode get_Node();
}
public class Org.XmlUnit.Input.NormalizedSource : object {
    private bool disposed;
    private string systemId;
    private XmlReader reader;
    private XmlNode node;
    public XmlNode Node { get; }
    public XmlReader Reader { get; }
    public string SystemId { get; public set; }
    public NormalizedSource(XmlNode node);
    public NormalizedSource(XmlNode node, string systemId);
    public NormalizedSource(ISource originalSource);
    public XmlNode get_Node();
    public sealed virtual XmlReader get_Reader();
    public sealed virtual string get_SystemId();
    public sealed virtual void set_SystemId(string value);
    public virtual string ToString();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class Org.XmlUnit.Input.ReaderSource : AbstractSource {
    public ReaderSource(XmlReader rdr);
}
public class Org.XmlUnit.Input.StreamSource : AbstractSource {
    public StreamSource(TextReader rdr);
    public StreamSource(Stream stream);
    public StreamSource(string uri);
}
public class Org.XmlUnit.Input.StringSource : object {
    private string systemId;
    private string content;
    public XmlReader Reader { get; }
    public string SystemId { get; public set; }
    public StringSource(string c);
    public sealed virtual XmlReader get_Reader();
    public sealed virtual string get_SystemId();
    public sealed virtual void set_SystemId(string value);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
public class Org.XmlUnit.Input.WhitespaceNormalizedSource : DOMSource {
    public WhitespaceNormalizedSource(ISource originalSource);
}
public class Org.XmlUnit.Input.WhitespaceStrippedSource : DOMSource {
    public WhitespaceStrippedSource(ISource originalSource);
}
public class Org.XmlUnit.Input.XmlElementContentWhitespaceStrippedSource : DOMSource {
    public XmlElementContentWhitespaceStrippedSource(ISource originalSource);
}
public class Org.XmlUnit.Input.XmlWhitespaceNormalizedSource : DOMSource {
    public XmlWhitespaceNormalizedSource(ISource originalSource);
}
public class Org.XmlUnit.Input.XmlWhitespaceStrippedSource : DOMSource {
    public XmlWhitespaceStrippedSource(ISource originalSource);
}
public interface Org.XmlUnit.ISource {
    public XmlReader Reader { get; }
    public string SystemId { get; public set; }
    public abstract virtual XmlReader get_Reader();
    public abstract virtual string get_SystemId();
    public abstract virtual void set_SystemId(string value);
}
public class Org.XmlUnit.Transform.Transformation : object {
    private ISource source;
    private ISource styleSheet;
    private XmlResolver xmlResolver;
    private XsltSettings settings;
    private XsltArgumentList args;
    unknown ISource Source {public set; }
    unknown ISource Stylesheet {public set; }
    unknown XmlResolver XmlResolver {public set; }
    unknown bool EnableDocumentFunction {public set; }
    unknown bool EnableScriptBlocks {public set; }
    public Transformation(ISource s);
    public void set_Source(ISource value);
    public void set_Stylesheet(ISource value);
    public void AddExtensionObject(string namespaceUri, object extension);
    public void Clear();
    public void AddParameter(string name, string nsUri, object parameter);
    public void set_XmlResolver(XmlResolver value);
    public void set_EnableDocumentFunction(bool value);
    public void set_EnableScriptBlocks(bool value);
    public void TransformTo(Stream stream);
    public void TransformTo(TextWriter writer);
    public void TransformTo(XmlWriter writer);
    internal void Transform(Transformer transformer);
    public string TransformToString();
    public XmlDocument TransformToDocument();
    public XmlDocument TransformToDocument(XmlResolver resolver);
    private static Transformer TransformToStream(Stream stream);
    private static Transformer TransformToTextWriter(TextWriter tw);
    private static Transformer TransformToXmlWriter(XmlWriter xw);
}
[ExtensionAttribute]
public static class Org.XmlUnit.Util.Convert : object {
    [ExtensionAttribute]
public static XmlDocument ToDocument(ISource s);
    public static XmlDocument ToDocument(ISource s, bool prohibitDTD);
    public static XmlDocument ToDocument(ISource s, bool prohibitDTD, XmlResolver resolver);
    [ExtensionAttribute]
public static XmlNode ToNode(ISource s);
    public static XmlNamespaceManager ToNamespaceContext(IDictionary`2<string, string> prefix2URI);
}
[ExtensionAttribute]
public static class Org.XmlUnit.Util.Linqy : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> Singleton(T t);
    [ExtensionAttribute]
public static T FirstOrDefault(IEnumerable`1<T> enumerable, Func`2<T, bool> predicate, T defaultValue);
    [ExtensionAttribute]
public static T FirstOrDefaultValue(IEnumerable`1<T> enumerable, Predicate`1<T> predicate, T defaultValue);
}
[ExtensionAttribute]
public static class Org.XmlUnit.Util.Nodes : object {
    private static char SPACE;
    private static Char[] XML_WHITESPACE_CHARS;
    [CompilerGeneratedAttribute]
private static Func`2<XmlNode, bool> CS$<>9__CachedAnonymousMethodDelegate4;
    [CompilerGeneratedAttribute]
private static Func`2<XmlNode, string> CS$<>9__CachedAnonymousMethodDelegate5;
    [CompilerGeneratedAttribute]
private static Func`2<string, bool> CS$<>9__CachedAnonymousMethodDelegate6;
    [CompilerGeneratedAttribute]
private static Func`3<StringBuilder, string, StringBuilder> CS$<>9__CachedAnonymousMethodDelegate7;
    [CompilerGeneratedAttribute]
private static Predicate`1<XmlAttribute> CS$<>9__CachedAnonymousMethodDelegate9;
    [CompilerGeneratedAttribute]
private static Func`2<XmlAttribute, string> CS$<>9__CachedAnonymousMethodDelegated;
    [CompilerGeneratedAttribute]
private static Predicate`1<char> CS$<>9__CachedAnonymousMethodDelegate11;
    [CompilerGeneratedAttribute]
private static Predicate`1<char> CS$<>9__CachedAnonymousMethodDelegate13;
    private static Nodes();
    [ExtensionAttribute]
public static XmlQualifiedName GetQName(XmlNode n);
    public static string GetMergedNestedText(XmlNode n);
    public static IDictionary`2<XmlQualifiedName, string> GetAttributes(XmlNode n);
    public static IDictionary`2<XmlQualifiedName, string> GetAttributes(XmlNode n, Predicate`1<XmlAttribute> attributeFilter);
    public static XmlNode StripWhitespace(XmlNode original);
    public static XmlNode StripXmlWhitespace(XmlNode original);
    public static XmlNode NormalizeWhitespace(XmlNode original);
    public static XmlNode NormalizeXmlWhitespace(XmlNode original);
    public static XmlNode StripElementContentWhitespace(XmlNode original);
    public static XmlNode StripXmlElementContentWhitespace(XmlNode original);
    private static string TrimValue(XmlNode n);
    private static string TrimAndNormalizeValue(XmlNode n);
    private static string XmlTrimValue(XmlNode n);
    private static string XmlTrimAndNormalizeValue(XmlNode n);
    private static void HandleWsRec(XmlNode n, Func`2<XmlNode, string> handleWs);
    internal static string Normalize(string s);
    internal static string XmlNormalize(string s);
    private static string Normalize(string s, Predicate`1<char> isWhiteSpace);
    private static void StripECW(XmlNode n, Func`2<XmlNode, string> trimmer);
    private static bool IsTextualContentNode(XmlNode n);
    [CompilerGeneratedAttribute]
private static bool <GetMergedNestedText>b__0(XmlNode child);
    [CompilerGeneratedAttribute]
private static string <GetMergedNestedText>b__1(XmlNode child);
    [CompilerGeneratedAttribute]
private static bool <GetMergedNestedText>b__2(string s);
    [CompilerGeneratedAttribute]
private static StringBuilder <GetMergedNestedText>b__3(StringBuilder sb, string s);
    [CompilerGeneratedAttribute]
private static bool <GetAttributes>b__8(XmlAttribute ignored);
    [CompilerGeneratedAttribute]
private static string <GetAttributes>b__b(XmlAttribute a);
    [CompilerGeneratedAttribute]
private static bool <Normalize>b__10(char c);
    [CompilerGeneratedAttribute]
private static bool <XmlNormalize>b__12(char c);
}
public static class Org.XmlUnit.Validation.Languages : object {
    public static string W3C_XML_SCHEMA_NS_URI;
    public static string XML_DTD_NS_URI;
    public static string XDR_NS_URI;
}
public class Org.XmlUnit.Validation.ValidationProblem : object {
    public static int UNKNOWN;
    private int line;
    private int column;
    private XmlSeverityType type;
    private string message;
    public int Line { get; }
    public int Column { get; }
    public XmlSeverityType Type { get; }
    public string Message { get; }
    public ValidationProblem(string message, int line, int column, XmlSeverityType type);
    public int get_Line();
    public int get_Column();
    public XmlSeverityType get_Type();
    public string get_Message();
    internal static ValidationProblem FromEvent(ValidationEventArgs e);
    public virtual string ToString();
}
public class Org.XmlUnit.Validation.ValidationResult : object {
    private bool valid;
    private IEnumerable`1<ValidationProblem> problems;
    public bool Valid { get; }
    public IEnumerable`1<ValidationProblem> Problems { get; }
    public ValidationResult(bool valid, IEnumerable`1<ValidationProblem> problems);
    public bool get_Valid();
    public IEnumerable`1<ValidationProblem> get_Problems();
}
public class Org.XmlUnit.Validation.Validator : object {
    private ValidationType language;
    private XmlSchema schema;
    private ISource[] sourceLocations;
    private static IDictionary`2<string, ValidationType> types;
    public ISource[] SchemaSources { get; public set; }
    unknown ISource SchemaSource {public set; }
    public XmlSchema Schema { get; public set; }
    private Validator(ValidationType language);
    private static Validator();
    public virtual void set_SchemaSources(ISource[] value);
    public virtual ISource[] get_SchemaSources();
    public void set_SchemaSource(ISource value);
    public virtual void set_Schema(XmlSchema value);
    public virtual XmlSchema get_Schema();
    public virtual ValidationResult ValidateSchema();
    public virtual ValidationResult ValidateInstance(ISource instance);
    public static Validator ForLanguage(string language);
    private static ValidationEventHandler CollectProblems(List`1<ValidationProblem> problems);
    private static void ThrowOnError(object sender, ValidationEventArgs e);
}
public class Org.XmlUnit.XMLUnitException : Exception {
    public XMLUnitException(string message, Exception cause);
    public XMLUnitException(string message);
    public XMLUnitException(Exception cause);
}
internal static class Org.XmlUnit.XmlUnitVersion : object {
    internal static string ApiVersion;
    internal static string AssemblyVersion;
    internal static string Version;
}
public interface Org.XmlUnit.Xpath.IXPathEngine {
    unknown IDictionary`2<string, string> NamespaceContext {public set; }
    public abstract virtual IEnumerable`1<XmlNode> SelectNodes(string xPath, ISource s);
    public abstract virtual string Evaluate(string xPath, ISource s);
    public abstract virtual IEnumerable`1<XmlNode> SelectNodes(string xPath, XmlNode n);
    public abstract virtual string Evaluate(string xPath, XmlNode n);
    public abstract virtual void set_NamespaceContext(IDictionary`2<string, string> value);
}
public class Org.XmlUnit.Xpath.XPathEngine : object {
    private XmlNamespaceManager nsContext;
    unknown IDictionary`2<string, string> NamespaceContext {public set; }
    public sealed virtual IEnumerable`1<XmlNode> SelectNodes(string xPath, ISource s);
    public sealed virtual string Evaluate(string xPath, ISource s);
    public sealed virtual IEnumerable`1<XmlNode> SelectNodes(string xPath, XmlNode n);
    public sealed virtual string Evaluate(string xPath, XmlNode n);
    public sealed virtual void set_NamespaceContext(IDictionary`2<string, string> value);
    private string Evaluate(string xPath, XPathNavigator navigator);
}
