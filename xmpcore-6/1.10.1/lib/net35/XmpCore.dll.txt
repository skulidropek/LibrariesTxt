public abstract class Sharpen.Calendar : object {
    private static TimeZoneInfo DefaultTimeZone;
    private DateTime _mCalendarDate;
    private TimeZoneInfo _mTz;
    protected Calendar(TimeZoneInfo value);
    protected Calendar(int year, int month, int dayOfMonth);
    protected Calendar(int year, int month, int dayOfMonth, int hourOfDay, int minute, int second);
    private static Calendar();
    public long GetTimeInMillis();
    public void SetTimeInMillis(long millis);
    public DateTime GetTime();
    public void SetTime(DateTime date);
    public TimeZoneInfo GetTimeZone();
    public void SetTimeZone(TimeZoneInfo value);
    public int Get(CalendarEnum field);
    public void Set(CalendarEnum field, int value);
    public abstract virtual int GetMaximum(CalendarEnum field);
    public void Set(int year, int month, int day, int hourOfDay, int minute, int second);
    public static Calendar GetInstance(CultureInfo culture);
    public static Calendar GetInstance(TimeZoneInfo value);
}
public enum Sharpen.CalendarEnum : Enum {
    public int value__;
    public static CalendarEnum Year;
    public static CalendarEnum Month;
    public static CalendarEnum MonthOneBased;
    public static CalendarEnum DayOfMonth;
    public static CalendarEnum Hour;
    public static CalendarEnum HourOfDay;
    public static CalendarEnum Minute;
    public static CalendarEnum Second;
    public static CalendarEnum Millisecond;
}
public class Sharpen.EnumeratorWrapper`1 : Iterator`1<T> {
    private object _collection;
    private IEnumerator`1<T> _e;
    private T _lastVal;
    private bool _more;
    private bool _copied;
    public EnumeratorWrapper`1(object collection, IEnumerator`1<T> e);
    public virtual bool HasNext();
    public virtual T Next();
    public virtual void Remove();
}
[ExtensionAttribute]
public static class Sharpen.Extensions : object {
    [ExtensionAttribute]
public static Iterator`1<T> Iterator(IEnumerable`1<T> col);
}
public class Sharpen.GregorianCalendar : Calendar {
    public static int January;
    public GregorianCalendar(TimeZoneInfo timeZoneInfo);
    public GregorianCalendar(int year, int month, int day);
    public GregorianCalendar(int year, int month, int dayOfMonth, int hourOfDay, int minute, int second);
    public void SetGregorianChange(DateTime date);
    public virtual int GetMaximum(CalendarEnum field);
}
public enum Sharpen.GregorianCalendarEnum : Enum {
    public int value__;
    public static GregorianCalendarEnum January;
}
public interface Sharpen.IIterator {
    public abstract virtual bool HasNext();
    public abstract virtual object Next();
    public abstract virtual void Remove();
}
public abstract class Sharpen.Iterator`1 : object {
    private T _lastValue;
    private T System.Collections.Generic.IEnumerator<T>.Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    private sealed virtual override object Sharpen.IIterator.Next();
    public abstract virtual bool HasNext();
    public abstract virtual T Next();
    public abstract virtual void Remove();
    private sealed virtual override bool System.Collections.IEnumerator.MoveNext();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override void System.IDisposable.Dispose();
    private sealed virtual override T System.Collections.Generic.IEnumerator<T>.get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
public class Sharpen.PushbackReader : StreamReader {
    private object _lock;
    private Char[] _buf;
    private int _pos;
    public PushbackReader(StreamReader stream, int size);
    public virtual int Read();
    public virtual int Read(Char[] buffer, int off, int len);
    public void Unread(Char[] buffer, int off, int len);
}
public class XmpCore.Impl.ByteBuffer : object {
    private Byte[] _buffer;
    private Encoding _encoding;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Length { get; private set; }
    public ByteBuffer(int initialCapacity);
    public ByteBuffer(Byte[] buffer);
    public ByteBuffer(Byte[] buffer, int length);
    public ByteBuffer(Stream stream);
    public ByteBuffer(Byte[] buffer, int offset, int length);
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
private void set_Length(int value);
    public Stream GetByteStream();
    public byte ByteAt(int index);
    public int CharAt(int index);
    public void Append(byte b);
    public void Append(Byte[] bytes, int offset, int len);
    public void Append(Byte[] bytes);
    public void Append(ByteBuffer anotherBuffer);
    public Encoding GetEncoding();
    private void EnsureCapacity(int requestedLength);
}
public class XmpCore.Impl.FixAsciiControlsReader : PushbackReader {
    private static int StateStart;
    private static int StateAmp;
    private static int StateHash;
    private static int StateHex;
    private static int StateDig1;
    private static int StateError;
    private static int BufferSize;
    private int _state;
    private int _control;
    private int _digits;
    public FixAsciiControlsReader(StreamReader reader);
    public virtual int Read(Char[] buffer, int off, int len);
    private char ProcessChar(char ch);
}
public static class XmpCore.Impl.Iso8601Converter : object {
    public static IXmpDateTime Parse(string iso8601String);
    public static IXmpDateTime Parse(string iso8601String, IXmpDateTime binValue);
    public static string Render(IXmpDateTime dateTime);
}
public static class XmpCore.Impl.Latin1Converter : object {
    private static int StateStart;
    private static int StateUtf8Char;
    public static ByteBuffer Convert(ByteBuffer buffer);
    private static Byte[] ConvertToUtf8(byte ch);
}
internal static class XmpCore.Impl.ParameterAsserts : object {
    public static void AssertArrayName(string arrayName);
    public static void AssertPropName(string propName);
    public static void AssertSchemaNs(string schemaNs);
    public static void AssertPrefix(string prefix);
    public static void AssertSpecificLang(string specificLang);
    public static void AssertStructName(string structName);
    public static void AssertNotNull(object param);
    public static void AssertNotNullOrEmpty(string param);
    public static void AssertImplementation(IXmpMeta xmp);
}
public static class XmpCore.Impl.ParseRdf : object {
    public static string DefaultPrefix;
    internal static XmpMeta Parse(XElement xmlRoot, ParseOptions options);
    private static void Rdf_RDF(XmpMeta xmp, XElement rdfRdfNode, ParseOptions options);
    private static void Rdf_NodeElementList(XmpMeta xmp, XmpNode xmpParent, XElement rdfRdfNode, ParseOptions options);
    private static void Rdf_NodeElement(XmpMeta xmp, XmpNode xmpParent, XElement xmlNode, bool isTopLevel, ParseOptions options);
    private static void Rdf_NodeElementAttrs(XmpMeta xmp, XmpNode xmpParent, XElement xmlNode, bool isTopLevel, ParseOptions options);
    private static void Rdf_PropertyElementList(XmpMeta xmp, XmpNode xmpParent, XElement xmlParent, bool isTopLevel, ParseOptions options);
    private static void Rdf_PropertyElement(XmpMeta xmp, XmpNode xmpParent, XElement xmlNode, bool isTopLevel, ParseOptions options);
    private static void Rdf_ResourcePropertyElement(XmpMeta xmp, XmpNode xmpParent, XElement xmlNode, bool isTopLevel, ParseOptions options);
    private static void Rdf_LiteralPropertyElement(XmpMeta xmp, XmpNode xmpParent, XElement xmlNode, bool isTopLevel);
    private static void Rdf_ParseTypeLiteralPropertyElement();
    private static void Rdf_ParseTypeResourcePropertyElement(XmpMeta xmp, XmpNode xmpParent, XElement xmlNode, bool isTopLevel, ParseOptions options);
    private static void Rdf_ParseTypeCollectionPropertyElement();
    private static void Rdf_ParseTypeOtherPropertyElement();
    private static void Rdf_EmptyPropertyElement(XmpMeta xmp, XmpNode xmpParent, XElement xmlNode, bool isTopLevel);
    private static XmpNode AddChildNode(XmpMeta xmp, XmpNode xmpParent, XElement xmlNode, string value, bool isTopLevel);
    private static XmpNode AddChildNode(XmpMeta xmp, XmpNode xmpParent, XAttribute xmlNode, string value, bool isTopLevel);
    private static XmpNode AddChildNode(XmpMeta xmp, XmpNode xmpParent, XName nodeName, string nodeNamespacePrefix, string value, bool isTopLevel);
    private static void AddQualifierNode(XmpNode xmpParent, string name, string value);
    private static void FixupQualifiedNode(XmpNode xmpParent);
    private static bool IsWhitespaceNode(XNode node);
    private static bool IsPropertyElementName(RdfTerm term);
    private static bool IsOldTerm(RdfTerm term);
    private static bool IsCoreSyntaxTerm(RdfTerm term);
    private static RdfTerm GetRdfTermKind(XElement node);
    private static RdfTerm GetRdfTermKind(XAttribute node);
    private static RdfTerm GetRdfTermKind(XName name, XmlNodeType nodeType, XName parentName);
    private static bool IsNumberedArrayItemName(string nodeName);
}
internal class XmpCore.Impl.ParseState : object {
    private string _str;
    [CompilerGeneratedAttribute]
private int <Pos>k__BackingField;
    public int Pos { get; private set; }
    public bool HasNext { get; }
    public ParseState(string str);
    [CompilerGeneratedAttribute]
public int get_Pos();
    [CompilerGeneratedAttribute]
private void set_Pos(int value);
    public bool get_HasNext();
    public char Ch(int index);
    public char Ch();
    public void Skip();
    public int GatherInt(string errorMsg, int maxValue);
}
public class XmpCore.Impl.QName : object {
    [CompilerGeneratedAttribute]
private string <LocalName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    public bool HasPrefix { get; }
    public string LocalName { get; }
    public string Prefix { get; }
    public QName(string qname);
    public QName(string prefix, string localName);
    public bool get_HasPrefix();
    [CompilerGeneratedAttribute]
public string get_LocalName();
    [CompilerGeneratedAttribute]
public string get_Prefix();
}
public enum XmpCore.Impl.RdfTerm : Enum {
    public int value__;
    public static RdfTerm Other;
    public static RdfTerm Rdf;
    public static RdfTerm Id;
    public static RdfTerm About;
    public static RdfTerm ParseType;
    public static RdfTerm Resource;
    public static RdfTerm NodeId;
    public static RdfTerm Datatype;
    public static RdfTerm Description;
    public static RdfTerm Li;
    public static RdfTerm AboutEach;
    public static RdfTerm AboutEachPrefix;
    public static RdfTerm BagId;
    public static RdfTerm FirstCore;
    public static RdfTerm LastCore;
    public static RdfTerm FirstSyntax;
    public static RdfTerm LastSyntax;
    public static RdfTerm FirstOld;
    public static RdfTerm LastOld;
}
public static class XmpCore.Impl.Utils : object {
    public static int UuidSegmentCount;
    public static int UuidLength;
    private static Boolean[] _xmlNameStartChars;
    private static Boolean[] _xmlNameChars;
    private static HashSet`1<string> EXTERNAL_XMPDM_PROPS;
    private static Utils();
    public static string NormalizeLangValue(string value);
    internal static void SplitNameAndValue(string selector, String& name, String& value);
    internal static bool IsInternalProperty(string schema, string prop);
    internal static bool CheckUuidFormat(string uuid);
    public static bool IsXmlName(string name);
    public static bool IsXmlNameNs(string name);
    internal static bool IsControlChar(char c);
    public static string EscapeXml(string value, bool forAttribute, bool escapeWhitespaces);
    internal static string RemoveControlChars(string value);
    private static bool IsNameStartChar(char ch);
    private static bool IsNameChar(char ch);
}
public class XmpCore.Impl.XmpDateTime : object {
    private int _year;
    private int _month;
    private int _day;
    private int _hour;
    private int _minute;
    private int _second;
    private TimeZoneInfo _timeZone;
    private int _nanoseconds;
    [CompilerGeneratedAttribute]
private TimeSpan <Offset>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasDate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTimeZone>k__BackingField;
    private static DateTime _unixEpoch;
    public int Year { get; public set; }
    public int Month { get; public set; }
    public int Day { get; public set; }
    public int Hour { get; public set; }
    public int Minute { get; public set; }
    public int Second { get; public set; }
    public int Nanosecond { get; public set; }
    public TimeZoneInfo TimeZone { get; public set; }
    public TimeSpan Offset { get; public set; }
    public bool HasDate { get; private set; }
    public bool HasTime { get; private set; }
    public bool HasTimeZone { get; private set; }
    public Calendar Calendar { get; }
    public XmpDateTime(Calendar calendar);
    public XmpDateTime(DateTime date, TimeZoneInfo timeZone);
    public XmpDateTime(string strValue);
    private static XmpDateTime();
    public sealed virtual int get_Year();
    public sealed virtual void set_Year(int value);
    public sealed virtual int get_Month();
    public sealed virtual void set_Month(int value);
    public sealed virtual int get_Day();
    public sealed virtual void set_Day(int value);
    public sealed virtual int get_Hour();
    public sealed virtual void set_Hour(int value);
    public sealed virtual int get_Minute();
    public sealed virtual void set_Minute(int value);
    public sealed virtual int get_Second();
    public sealed virtual void set_Second(int value);
    public sealed virtual int get_Nanosecond();
    public sealed virtual void set_Nanosecond(int value);
    public sealed virtual int CompareTo(object dt);
    public sealed virtual TimeZoneInfo get_TimeZone();
    public sealed virtual void set_TimeZone(TimeZoneInfo value);
    [CompilerGeneratedAttribute]
public sealed virtual TimeSpan get_Offset();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Offset(TimeSpan value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasDate();
    [CompilerGeneratedAttribute]
private void set_HasDate(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasTime();
    [CompilerGeneratedAttribute]
private void set_HasTime(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasTimeZone();
    [CompilerGeneratedAttribute]
private void set_HasTimeZone(bool value);
    public sealed virtual Calendar get_Calendar();
    public sealed virtual string ToIso8601String();
    public virtual string ToString();
    internal static DateTime UnixTimeToDateTime(long unixTime);
    public static DateTimeOffset UnixTimeToDateTimeOffset(long unixTime);
}
public class XmpCore.Impl.XmpIterator : object {
    private bool _skipSiblings;
    private IIterator _nodeIterator;
    [CompilerGeneratedAttribute]
private IteratorOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseNamespace>k__BackingField;
    private IteratorOptions Options { get; }
    private string BaseNamespace { get; private set; }
    public XmpIterator(XmpMeta xmp, string schemaNs, string propPath, IteratorOptions options);
    public sealed virtual void SkipSubtree();
    public sealed virtual void SkipSiblings();
    public sealed virtual bool HasNext();
    public sealed virtual object Next();
    public sealed virtual void Remove();
    [CompilerGeneratedAttribute]
private IteratorOptions get_Options();
    [CompilerGeneratedAttribute]
private string get_BaseNamespace();
    [CompilerGeneratedAttribute]
private void set_BaseNamespace(string value);
}
public class XmpCore.Impl.XmpMeta : object {
    private XmpNode _tree;
    private string _packetHeader;
    public IEnumerable`1<IXmpPropertyInfo> Properties { get; }
    public XmpMeta(XmpNode tree);
    public sealed virtual void AppendArrayItem(string schemaNs, string arrayName, PropertyOptions arrayOptions, string itemValue, PropertyOptions itemOptions);
    public sealed virtual void AppendArrayItem(string schemaNs, string arrayName, string itemValue);
    public sealed virtual int CountArrayItems(string schemaNs, string arrayName);
    public sealed virtual void DeleteArrayItem(string schemaNs, string arrayName, int itemIndex);
    public sealed virtual void DeleteProperty(string schemaNs, string propName);
    public sealed virtual void DeleteQualifier(string schemaNs, string propName, string qualNs, string qualName);
    public sealed virtual void DeleteStructField(string schemaNs, string structName, string fieldNs, string fieldName);
    public sealed virtual bool DoesPropertyExist(string schemaNs, string propName);
    public sealed virtual bool DoesArrayItemExist(string schemaNs, string arrayName, int itemIndex);
    public sealed virtual bool DoesStructFieldExist(string schemaNs, string structName, string fieldNs, string fieldName);
    public sealed virtual bool DoesQualifierExist(string schemaNs, string propName, string qualNs, string qualName);
    public sealed virtual IXmpProperty GetArrayItem(string schemaNs, string arrayName, int itemIndex);
    public sealed virtual IXmpProperty GetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang);
    public sealed virtual void SetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang, string itemValue, PropertyOptions options);
    public sealed virtual void SetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang, string itemValue);
    public sealed virtual IXmpProperty GetProperty(string schemaNs, string propName);
    private IXmpProperty GetProperty(string schemaNs, string propName, ValueType valueType);
    private object GetPropertyObject(string schemaNs, string propName, ValueType valueType);
    public sealed virtual bool GetPropertyBoolean(string schemaNs, string propName);
    public sealed virtual void SetPropertyBoolean(string schemaNs, string propName, bool propValue, PropertyOptions options);
    public sealed virtual void SetPropertyBoolean(string schemaNs, string propName, bool propValue);
    public sealed virtual int GetPropertyInteger(string schemaNs, string propName);
    public sealed virtual void SetPropertyInteger(string schemaNs, string propName, int propValue, PropertyOptions options);
    public sealed virtual void SetPropertyInteger(string schemaNs, string propName, int propValue);
    public sealed virtual long GetPropertyLong(string schemaNs, string propName);
    public sealed virtual void SetPropertyLong(string schemaNs, string propName, long propValue, PropertyOptions options);
    public sealed virtual void SetPropertyLong(string schemaNs, string propName, long propValue);
    public sealed virtual double GetPropertyDouble(string schemaNs, string propName);
    public sealed virtual void SetPropertyDouble(string schemaNs, string propName, double propValue, PropertyOptions options);
    public sealed virtual void SetPropertyDouble(string schemaNs, string propName, double propValue);
    public sealed virtual IXmpDateTime GetPropertyDate(string schemaNs, string propName);
    public sealed virtual void SetPropertyDate(string schemaNs, string propName, IXmpDateTime propValue, PropertyOptions options);
    public sealed virtual void SetPropertyDate(string schemaNs, string propName, IXmpDateTime propValue);
    public sealed virtual Calendar GetPropertyCalendar(string schemaNs, string propName);
    public sealed virtual void SetPropertyCalendar(string schemaNs, string propName, Calendar propValue, PropertyOptions options);
    public sealed virtual void SetPropertyCalendar(string schemaNs, string propName, Calendar propValue);
    public sealed virtual Byte[] GetPropertyBase64(string schemaNs, string propName);
    public sealed virtual string GetPropertyString(string schemaNs, string propName);
    public sealed virtual void SetPropertyBase64(string schemaNs, string propName, Byte[] propValue, PropertyOptions options);
    public sealed virtual void SetPropertyBase64(string schemaNs, string propName, Byte[] propValue);
    public sealed virtual IXmpProperty GetQualifier(string schemaNs, string propName, string qualNs, string qualName);
    public sealed virtual IXmpProperty GetStructField(string schemaNs, string structName, string fieldNs, string fieldName);
    public sealed virtual IEnumerable`1<IXmpPropertyInfo> get_Properties();
    public sealed virtual void SetArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue, PropertyOptions options);
    public sealed virtual void SetArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue);
    public sealed virtual void InsertArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue, PropertyOptions options);
    public sealed virtual void InsertArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue);
    public sealed virtual void SetProperty(string schemaNs, string propName, object propValue, PropertyOptions options);
    public sealed virtual void SetProperty(string schemaNs, string propName, object propValue);
    public sealed virtual void SetQualifier(string schemaNs, string propName, string qualNs, string qualName, string qualValue, PropertyOptions options);
    public sealed virtual void SetQualifier(string schemaNs, string propName, string qualNs, string qualName, string qualValue);
    public sealed virtual void SetStructField(string schemaNs, string structName, string fieldNs, string fieldName, string fieldValue, PropertyOptions options);
    public sealed virtual void SetStructField(string schemaNs, string structName, string fieldNs, string fieldName, string fieldValue);
    public sealed virtual string GetObjectName();
    public sealed virtual void SetObjectName(string name);
    public sealed virtual string GetPacketHeader();
    public void SetPacketHeader(string packetHeader);
    public sealed virtual IXmpMeta Clone();
    public sealed virtual string DumpObject();
    public sealed virtual void Sort();
    public sealed virtual void Normalize(ParseOptions options);
    public XmpNode GetRoot();
    private static void DoSetArrayItem(XmpNode arrayNode, int itemIndex, string itemValue, PropertyOptions itemOptions, bool insert);
    internal static void SetNode(XmpNode node, object value, PropertyOptions newOptions, bool deleteExisting);
    private static object EvaluateNodeValue(ValueType valueType, XmpNode propNode);
}
public static class XmpCore.Impl.XmpMetaParser : object {
    private static object XmpRdf;
    private static XmpMetaParser();
    public static IXmpMeta Parse(Stream stream, ParseOptions options);
    public static IXmpMeta Parse(Byte[] bytes, ParseOptions options);
    public static IXmpMeta Parse(ByteBuffer byteBuffer, ParseOptions options);
    public static IXmpMeta Parse(string xmlStr, ParseOptions options);
    public static IXmpMeta Parse(XDocument doc, ParseOptions options);
    public static XDocument Extract(Byte[] bytes, ParseOptions options);
    private static IXmpMeta ParseXmlDoc(XDocument document, ParseOptions options);
    private static XDocument ParseXmlFromInputStream(Stream stream, ParseOptions options);
    private static XDocument ParseXmlFromByteBuffer(ByteBuffer buffer, ParseOptions options);
    private static XDocument ParseXmlString(string input, ParseOptions options);
    private static XDocument ParseStream(Stream stream, ParseOptions options);
    private static XDocument ParseTextReader(TextReader reader, ParseOptions options);
    private static Object[] FindRootNode(IEnumerable`1<XNode> nodes, bool xmpmetaRequired, Object[] result);
}
public class XmpCore.Impl.XmpNode : object {
    private List`1<XmpNode> _children;
    private Dictionary`2<string, XmpNode> _childrenLookup;
    private List`1<XmpNode> _qualifier;
    private PropertyOptions _options;
    [CompilerGeneratedAttribute]
private XmpNode <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasAliases>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAlias>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValueChild>k__BackingField;
    public XmpNode Parent { get; internal set; }
    public bool HasChildren { get; }
    public bool HasQualifier { get; }
    public string Name { get; public set; }
    public string Value { get; public set; }
    public PropertyOptions Options { get; public set; }
    public bool IsImplicit { get; public set; }
    public bool HasAliases { get; public set; }
    public bool IsAlias { get; public set; }
    public bool HasValueChild { get; public set; }
    private bool IsLanguageNode { get; }
    private bool IsTypeNode { get; }
    public XmpNode(string name, string value, PropertyOptions options);
    public XmpNode(string name, PropertyOptions options);
    public void Clear();
    [CompilerGeneratedAttribute]
public XmpNode get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(XmpNode value);
    public XmpNode GetChild(int index);
    public void AddChild(XmpNode node);
    public void AddChild(int index, XmpNode node);
    public void ReplaceChild(int index, XmpNode node);
    public void RemoveChild(int itemIndex);
    public void RemoveChild(XmpNode node);
    private void CleanupChildren();
    public void RemoveChildren();
    public int GetChildrenLength();
    public XmpNode FindChildByName(string expr);
    public XmpNode GetQualifier(int index);
    public int GetQualifierLength();
    public void AddQualifier(XmpNode qualNode);
    public void RemoveQualifier(XmpNode qualNode);
    public void RemoveQualifiers();
    public XmpNode FindQualifierByName(string expr);
    public bool get_HasChildren();
    public IIterator IterateChildren();
    public bool get_HasQualifier();
    public IIterator IterateQualifier();
    public object Clone();
    public object Clone(bool skipEmpty);
    public void CloneSubtree(XmpNode destination, bool skipEmpty);
    public string DumpNode(bool recursive);
    public sealed virtual int CompareTo(object xmpNode);
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    public PropertyOptions get_Options();
    public void set_Options(PropertyOptions value);
    [CompilerGeneratedAttribute]
public bool get_IsImplicit();
    [CompilerGeneratedAttribute]
public void set_IsImplicit(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasAliases();
    [CompilerGeneratedAttribute]
public void set_HasAliases(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAlias();
    [CompilerGeneratedAttribute]
public void set_IsAlias(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasValueChild();
    [CompilerGeneratedAttribute]
public void set_HasValueChild(bool value);
    public void Sort();
    private void DumpNode(StringBuilder result, bool recursive, int indent, int index);
    private bool get_IsLanguageNode();
    private bool get_IsTypeNode();
    private List`1<XmpNode> GetChildren();
    public IEnumerable`1<object> GetUnmodifiableChildren();
    private List`1<XmpNode> GetQualifier();
    private static XmpNode Find(IEnumerable`1<XmpNode> list, string expr);
    private static XmpNode FindChild(List`1<XmpNode> children, Dictionary`2& lookup, string expr);
    private void AssertChildNotExisting(string childName);
    private void AssertQualifierNotExisting(string qualifierName);
}
public static class XmpCore.Impl.XmpNodeUtils : object {
    internal static int CltNoValues;
    internal static int CltSpecificMatch;
    internal static int CltSingleGeneric;
    internal static int CltMultipleGeneric;
    internal static int CltXDefault;
    internal static int CltFirstItem;
    internal static XmpNode FindSchemaNode(XmpNode tree, string namespaceUri, bool createNodes);
    internal static XmpNode FindSchemaNode(XmpNode tree, string namespaceUri, string suggestedPrefix, bool createNodes);
    internal static XmpNode FindChildNode(XmpNode parent, string childName, bool createNodes);
    internal static XmpNode FindNode(XmpNode xmpTree, XmpPath xpath, bool createNodes, PropertyOptions leafOptions);
    internal static void DeleteNode(XmpNode node);
    internal static void SetNodeValue(XmpNode node, object value);
    internal static PropertyOptions VerifySetOptions(PropertyOptions options, object itemValue);
    private static string SerializeNodeValue(object value);
    private static XmpNode FollowXPathStep(XmpNode parentNode, XmpPathSegment nextStep, bool createNodes);
    private static XmpNode FindQualifierNode(XmpNode parent, string qualName, bool createNodes);
    private static int FindIndexedItem(XmpNode arrayNode, string segment, bool createNodes);
    private static int LookupFieldSelector(XmpNode arrayNode, string fieldName, string fieldValue);
    private static int LookupQualSelector(XmpNode arrayNode, string qualName, string qualValue, int aliasForm);
    internal static void NormalizeLangArray(XmpNode arrayNode);
    internal static void DetectAltText(XmpNode arrayNode);
    internal static void AppendLangItem(XmpNode arrayNode, string itemLang, string itemValue);
    internal static Object[] ChooseLocalizedText(XmpNode arrayNode, string genericLang, string specificLang);
    internal static int LookupLanguageItem(XmpNode arrayNode, string language);
}
public static class XmpCore.Impl.XmpNormalizer : object {
    private static IDictionary _dcArrayForms;
    private static XmpNormalizer();
    internal static IXmpMeta Process(XmpMeta xmp, ParseOptions options);
    private static void TweakOldXmp(XmpNode tree);
    private static void TouchUpDataModel(XmpMeta xmp);
    private static void NormalizeDcArrays(XmpNode dcSchema);
    private static void RepairAltText(XmpNode arrayNode);
    private static void MoveExplicitAliases(XmpNode tree, ParseOptions options);
    private static void TransplantArrayItemAlias(IIterator propertyIt, XmpNode childNode, XmpNode baseArray);
    private static void FixGpsTimeStamp(XmpNode exifSchema);
    private static void DeleteEmptySchemas(XmpNode tree);
    private static void CompareAliasedSubtrees(XmpNode aliasNode, XmpNode baseNode, bool outerCall);
    private static void MigrateAudioCopyright(IXmpMeta xmp, XmpNode dmCopyright);
}
public class XmpCore.Impl.XmpSchemaRegistry : object {
    private Dictionary`2<string, string> _namespaceToPrefixMap;
    private Dictionary`2<string, string> _prefixToNamespaceMap;
    private Dictionary`2<string, IXmpAliasInfo> _aliasMap;
    private Regex _p;
    private object _lock;
    public IDictionary`2<string, string> Namespaces { get; }
    public IDictionary`2<string, string> Prefixes { get; }
    public IDictionary`2<string, IXmpAliasInfo> Aliases { get; }
    public sealed virtual string RegisterNamespace(string namespaceUri, string suggestedPrefix);
    public sealed virtual void DeleteNamespace(string namespaceUri);
    public sealed virtual string GetNamespacePrefix(string namespaceUri);
    public sealed virtual string GetNamespaceUri(string namespacePrefix);
    public sealed virtual IDictionary`2<string, string> get_Namespaces();
    public sealed virtual IDictionary`2<string, string> get_Prefixes();
    private void RegisterStandardNamespaces();
    public sealed virtual IXmpAliasInfo ResolveAlias(string aliasNs, string aliasProp);
    public sealed virtual IXmpAliasInfo FindAlias(string qname);
    public sealed virtual IEnumerable`1<IXmpAliasInfo> FindAliases(string aliasNs);
    private void RegisterAlias(string aliasNs, string aliasProp, string actualNs, string actualProp, AliasOptions aliasForm);
    public sealed virtual IDictionary`2<string, IXmpAliasInfo> get_Aliases();
    private void RegisterStandardAliases();
}
public static class XmpCore.Impl.XmpSerializerHelper : object {
    public static void Serialize(XmpMeta xmp, Stream stream, SerializeOptions options);
    public static string SerializeToString(XmpMeta xmp, SerializeOptions options);
    public static Byte[] SerializeToBuffer(XmpMeta xmp, SerializeOptions options);
}
public class XmpCore.Impl.XmpSerializerRdf : object {
    private static int DefaultPad;
    private static string PacketHeader;
    private static string PacketTrailer;
    private static string PacketTrailer2;
    private static string RdfXmpmetaStart;
    private static string RdfXmpmetaEnd;
    private static string RdfRdfStart;
    private static string RdfRdfEnd;
    private static string RdfSchemaStart;
    private static string RdfSchemaEnd;
    private static string RdfStructStart;
    private static string RdfStructEnd;
    private static string RdfEmptyStruct;
    private static ICollection`1<object> RdfAttrQualifier;
    private XmpMeta _xmp;
    private Stream _stream;
    private StreamWriter _writer;
    private SerializeOptions _options;
    private int _unicodeSize;
    private int _padding;
    private long _startPos;
    private static XmpSerializerRdf();
    public void Serialize(IXmpMeta xmp, Stream stream, SerializeOptions options);
    private void AddPadding(int tailLength);
    private void CheckOptionsConsistence();
    private string SerializeAsRdf();
    private void SerializeCanonicalRdfSchemas(int level);
    private void WriteTreeName();
    private void SerializeCompactRdfSchemas(int level);
    private bool SerializeCompactRdfAttrProps(XmpNode parentNode, int indent);
    private void SerializeCompactRdfElementProps(XmpNode parentNode, int indent);
    private Object[] SerializeCompactRdfSimpleProp(XmpNode node);
    private void SerializeCompactRdfArrayProp(XmpNode node, int indent);
    private bool SerializeCompactRdfStructProp(XmpNode node, int indent, bool hasRdfResourceQual);
    private void SerializeCompactRdfGeneralQualifier(int indent, XmpNode node);
    private void SerializeCanonicalRdfSchema(XmpNode schemaNode, int level);
    private void DeclareUsedNamespaces(XmpNode node, ICollection`1<object> usedPrefixes, int indent);
    private void DeclareNamespace(string prefix, string ns, ICollection`1<object> usedPrefixes, int indent);
    private void StartOuterRdfDescription(XmpNode schemaNode, int level);
    private void EndOuterRdfDescription(int level);
    private void SerializeCanonicalRdfProperty(XmpNode node, bool useCanonicalRdf, bool emitAsRdfValue, int indent);
    private void EmitRdfArrayTag(XmpNode arrayNode, bool isStartTag, int indent);
    private void AppendNodeValue(string value, bool forAttribute);
    private static bool CanBeRdfAttrProp(XmpNode node);
    private void WriteIndent(int times);
    private void Write(int c);
    private void Write(char c);
    private void Write(string str);
    private void WriteChars(int number, char c);
    private void WriteNewline();
}
public static class XmpCore.Impl.XmpUtils : object {
    private static string Spaces;
    private static string Commas;
    private static string Semicola;
    private static string Quotes;
    private static string Controls;
    public static string CatenateArrayItems(IXmpMeta xmp, string schemaNs, string arrayName, string separator, string quotes, bool allowCommas);
    public static void SeparateArrayItems(IXmpMeta xmp, string schemaNs, string arrayName, string catedStr, PropertyOptions arrayOptions, bool preserveCommas);
    private static XmpNode SeparateFindCreateArray(string schemaNs, string arrayName, PropertyOptions arrayOptions, XmpMeta xmp);
    public static void RemoveProperties(IXmpMeta xmp, string schemaNs, string propName, bool doAllProperties, bool includeAliases);
    public static void AppendProperties(IXmpMeta source, IXmpMeta destination, bool doAllProperties, bool replaceOldValues, bool deleteEmptyValues);
    private static bool RemoveSchemaChildren(XmpNode schemaNode, bool doAllProperties);
    private static void AppendSubtree(XmpMeta destXmp, XmpNode sourceNode, XmpNode destParent, bool mergeCompound, bool replaceOldValues, bool deleteEmptyValues);
    private static bool ItemValuesMatch(XmpNode leftNode, XmpNode rightNode);
    public static void DuplicateSubtree(IXmpMeta source, IXmpMeta dest, string sourceNS, string sourceRoot, string destNS, string destRoot, PropertyOptions options);
    private static void CheckSeparator(string separator);
    private static char CheckQuotes(string quotes, char openQuote);
    private static UnicodeKind ClassifyCharacter(char ch);
    private static char GetClosingQuote(char openQuote);
    private static string ApplyQuotes(string item, char openQuote, char closeQuote, bool allowCommas);
    private static bool IsSurroundingQuote(char ch, char openQuote, char closeQuote);
    private static bool IsClosingQuote(char ch, char openQuote, char closeQuote);
    private static bool MoveOneProperty(XmpMeta stdXMP, XmpMeta extXMP, string schemaURI, string propName);
    private static int EstimateSizeForJPEG(XmpNode xmpNode);
    private static void PutObjectsInMultiMap(SortedDictionary`2<int, List`1<List`1<string>>> multiMap, int key, List`1<string> stringPair);
    private static List`1<string> GetBiggestEntryInMultiMap(SortedDictionary`2<int, List`1<List`1<string>>> multiMap);
    private static void CreateEstimatedSizeMap(XmpMeta stdXMP, SortedDictionary`2<int, List`1<List`1<string>>> propSizes);
    private static int MoveLargestProperty(XmpMeta stdXMP, XmpMeta extXMP, SortedDictionary`2<int, List`1<List`1<string>>> propSizes);
    public static void PackageForJPEG(IXmpMeta origXMPImpl, StringBuilder stdStr, StringBuilder extStr, StringBuilder digestStr);
    public static void MergeFromJPEG(IXmpMeta fullXMP, IXmpMeta extendedXMP);
    public static void ApplyTemplate(IXmpMeta origXMP, IXmpMeta tempXMP, TemplateOptions actions);
}
internal class XmpCore.Impl.XPath.PathPosition : object {
    public string Path;
    internal int NameStart;
    internal int NameEnd;
    internal int StepBegin;
    internal int StepEnd;
}
public class XmpCore.Impl.XPath.XmpPath : object {
    public static int StepSchema;
    public static int StepRootProp;
    private List`1<XmpPathSegment> _segments;
    public void Add(XmpPathSegment segment);
    public XmpPathSegment GetSegment(int index);
    public int Size();
    public virtual string ToString();
}
public static class XmpCore.Impl.XPath.XmpPathParser : object {
    public static XmpPath ExpandXPath(string schemaNs, string path);
    private static void SkipPathDelimiter(string path, PathPosition pos);
    private static XmpPathSegment ParseStructSegment(PathPosition pos);
    private static XmpPathSegment ParseIndexSegment(PathPosition pos);
    private static void ParseRootNode(string schemaNs, PathPosition pos, XmpPath expandedXPath);
    private static void VerifyQualName(string qualName);
    private static void VerifySimpleXmlName(string name);
    private static string VerifyXPathRoot(string schemaNs, string rootProp);
}
public class XmpCore.Impl.XPath.XmpPathSegment : object {
    [CompilerGeneratedAttribute]
private XmpPathStepType <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAlias>k__BackingField;
    [CompilerGeneratedAttribute]
private int <AliasForm>k__BackingField;
    public XmpPathStepType Kind { get; public set; }
    public string Name { get; public set; }
    public bool IsAlias { get; public set; }
    public int AliasForm { get; public set; }
    public XmpPathSegment(string name);
    public XmpPathSegment(string name, XmpPathStepType kind);
    [CompilerGeneratedAttribute]
public XmpPathStepType get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(XmpPathStepType value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_IsAlias();
    [CompilerGeneratedAttribute]
public void set_IsAlias(bool value);
    [CompilerGeneratedAttribute]
public int get_AliasForm();
    [CompilerGeneratedAttribute]
public void set_AliasForm(int value);
    public virtual string ToString();
}
public enum XmpCore.Impl.XPath.XmpPathStepType : Enum {
    public int value__;
    public static XmpPathStepType StructFieldStep;
    public static XmpPathStepType QualifierStep;
    public static XmpPathStepType ArrayIndexStep;
    public static XmpPathStepType ArrayLastStep;
    public static XmpPathStepType QualSelectorStep;
    public static XmpPathStepType FieldSelectorStep;
    public static XmpPathStepType SchemaNode;
}
public interface XmpCore.IXmpAliasInfo {
    public string Namespace { get; }
    public string Prefix { get; }
    public string PropName { get; }
    public AliasOptions AliasForm { get; }
    public abstract virtual string get_Namespace();
    public abstract virtual string get_Prefix();
    public abstract virtual string get_PropName();
    public abstract virtual AliasOptions get_AliasForm();
}
public interface XmpCore.IXmpDateTime {
    public int Year { get; public set; }
    public int Month { get; public set; }
    public int Day { get; public set; }
    public int Hour { get; public set; }
    public int Minute { get; public set; }
    public int Second { get; public set; }
    public int Nanosecond { get; public set; }
    public TimeZoneInfo TimeZone { get; public set; }
    public TimeSpan Offset { get; public set; }
    public bool HasDate { get; }
    public bool HasTime { get; }
    public bool HasTimeZone { get; }
    public Calendar Calendar { get; }
    public abstract virtual int get_Year();
    public abstract virtual void set_Year(int value);
    public abstract virtual int get_Month();
    public abstract virtual void set_Month(int value);
    public abstract virtual int get_Day();
    public abstract virtual void set_Day(int value);
    public abstract virtual int get_Hour();
    public abstract virtual void set_Hour(int value);
    public abstract virtual int get_Minute();
    public abstract virtual void set_Minute(int value);
    public abstract virtual int get_Second();
    public abstract virtual void set_Second(int value);
    public abstract virtual int get_Nanosecond();
    public abstract virtual void set_Nanosecond(int value);
    public abstract virtual TimeZoneInfo get_TimeZone();
    public abstract virtual void set_TimeZone(TimeZoneInfo value);
    public abstract virtual TimeSpan get_Offset();
    public abstract virtual void set_Offset(TimeSpan value);
    public abstract virtual bool get_HasDate();
    public abstract virtual bool get_HasTime();
    public abstract virtual bool get_HasTimeZone();
    public abstract virtual Calendar get_Calendar();
    public abstract virtual string ToIso8601String();
}
public interface XmpCore.IXmpIterator {
    public abstract virtual void SkipSubtree();
    public abstract virtual void SkipSiblings();
}
public interface XmpCore.IXmpMeta {
    public IEnumerable`1<IXmpPropertyInfo> Properties { get; }
    public abstract virtual IXmpMeta Clone();
    public abstract virtual IXmpProperty GetProperty(string schemaNs, string propName);
    public abstract virtual IXmpProperty GetArrayItem(string schemaNs, string arrayName, int itemIndex);
    public abstract virtual int CountArrayItems(string schemaNs, string arrayName);
    public abstract virtual IXmpProperty GetStructField(string schemaNs, string structName, string fieldNs, string fieldName);
    public abstract virtual IXmpProperty GetQualifier(string schemaNs, string propName, string qualNs, string qualName);
    public abstract virtual void SetProperty(string schemaNs, string propName, object propValue, PropertyOptions options);
    public abstract virtual void SetProperty(string schemaNs, string propName, object propValue);
    public abstract virtual void SetArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue, PropertyOptions options);
    public abstract virtual void SetArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue);
    public abstract virtual void InsertArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue, PropertyOptions options);
    public abstract virtual void InsertArrayItem(string schemaNs, string arrayName, int itemIndex, string itemValue);
    public abstract virtual void AppendArrayItem(string schemaNs, string arrayName, PropertyOptions arrayOptions, string itemValue, PropertyOptions itemOptions);
    public abstract virtual void AppendArrayItem(string schemaNs, string arrayName, string itemValue);
    public abstract virtual void SetStructField(string schemaNs, string structName, string fieldNs, string fieldName, string fieldValue, PropertyOptions options);
    public abstract virtual void SetStructField(string schemaNs, string structName, string fieldNs, string fieldName, string fieldValue);
    public abstract virtual void SetQualifier(string schemaNs, string propName, string qualNs, string qualName, string qualValue, PropertyOptions options);
    public abstract virtual void SetQualifier(string schemaNs, string propName, string qualNs, string qualName, string qualValue);
    public abstract virtual void DeleteProperty(string schemaNs, string propName);
    public abstract virtual void DeleteArrayItem(string schemaNs, string arrayName, int itemIndex);
    public abstract virtual void DeleteStructField(string schemaNs, string structName, string fieldNs, string fieldName);
    public abstract virtual void DeleteQualifier(string schemaNs, string propName, string qualNs, string qualName);
    public abstract virtual bool DoesPropertyExist(string schemaNs, string propName);
    public abstract virtual bool DoesArrayItemExist(string schemaNs, string arrayName, int itemIndex);
    public abstract virtual bool DoesStructFieldExist(string schemaNs, string structName, string fieldNs, string fieldName);
    public abstract virtual bool DoesQualifierExist(string schemaNs, string propName, string qualNs, string qualName);
    public abstract virtual IXmpProperty GetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang);
    public abstract virtual void SetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang, string itemValue, PropertyOptions options);
    public abstract virtual void SetLocalizedText(string schemaNs, string altTextName, string genericLang, string specificLang, string itemValue);
    public abstract virtual bool GetPropertyBoolean(string schemaNs, string propName);
    public abstract virtual int GetPropertyInteger(string schemaNs, string propName);
    public abstract virtual long GetPropertyLong(string schemaNs, string propName);
    public abstract virtual double GetPropertyDouble(string schemaNs, string propName);
    public abstract virtual IXmpDateTime GetPropertyDate(string schemaNs, string propName);
    public abstract virtual Calendar GetPropertyCalendar(string schemaNs, string propName);
    public abstract virtual Byte[] GetPropertyBase64(string schemaNs, string propName);
    public abstract virtual string GetPropertyString(string schemaNs, string propName);
    public abstract virtual void SetPropertyBoolean(string schemaNs, string propName, bool propValue, PropertyOptions options);
    public abstract virtual void SetPropertyBoolean(string schemaNs, string propName, bool propValue);
    public abstract virtual void SetPropertyInteger(string schemaNs, string propName, int propValue, PropertyOptions options);
    public abstract virtual void SetPropertyInteger(string schemaNs, string propName, int propValue);
    public abstract virtual void SetPropertyLong(string schemaNs, string propName, long propValue, PropertyOptions options);
    public abstract virtual void SetPropertyLong(string schemaNs, string propName, long propValue);
    public abstract virtual void SetPropertyDouble(string schemaNs, string propName, double propValue, PropertyOptions options);
    public abstract virtual void SetPropertyDouble(string schemaNs, string propName, double propValue);
    public abstract virtual void SetPropertyDate(string schemaNs, string propName, IXmpDateTime propValue, PropertyOptions options);
    public abstract virtual void SetPropertyDate(string schemaNs, string propName, IXmpDateTime propValue);
    public abstract virtual void SetPropertyCalendar(string schemaNs, string propName, Calendar propValue, PropertyOptions options);
    public abstract virtual void SetPropertyCalendar(string schemaNs, string propName, Calendar propValue);
    public abstract virtual void SetPropertyBase64(string schemaNs, string propName, Byte[] propValue, PropertyOptions options);
    public abstract virtual void SetPropertyBase64(string schemaNs, string propName, Byte[] propValue);
    public abstract virtual IEnumerable`1<IXmpPropertyInfo> get_Properties();
    public abstract virtual string GetObjectName();
    public abstract virtual void SetObjectName(string name);
    public abstract virtual string GetPacketHeader();
    public abstract virtual void Sort();
    public abstract virtual void Normalize(ParseOptions options);
    public abstract virtual string DumpObject();
}
public interface XmpCore.IXmpProperty {
    public string Value { get; }
    public PropertyOptions Options { get; }
    public string Language { get; }
    public abstract virtual string get_Value();
    public abstract virtual PropertyOptions get_Options();
    public abstract virtual string get_Language();
}
public interface XmpCore.IXmpPropertyInfo {
    public string Namespace { get; }
    public string Path { get; }
    public abstract virtual string get_Namespace();
    public abstract virtual string get_Path();
}
public interface XmpCore.IXmpSchemaRegistry {
    public IDictionary`2<string, string> Namespaces { get; }
    public IDictionary`2<string, string> Prefixes { get; }
    public IDictionary`2<string, IXmpAliasInfo> Aliases { get; }
    public abstract virtual string RegisterNamespace(string namespaceUri, string suggestedPrefix);
    public abstract virtual string GetNamespacePrefix(string namespaceUri);
    public abstract virtual string GetNamespaceUri(string namespacePrefix);
    public abstract virtual IDictionary`2<string, string> get_Namespaces();
    public abstract virtual IDictionary`2<string, string> get_Prefixes();
    public abstract virtual void DeleteNamespace(string namespaceUri);
    public abstract virtual IXmpAliasInfo ResolveAlias(string aliasNs, string aliasProp);
    public abstract virtual IEnumerable`1<IXmpAliasInfo> FindAliases(string aliasNs);
    public abstract virtual IXmpAliasInfo FindAlias(string qname);
    public abstract virtual IDictionary`2<string, IXmpAliasInfo> get_Aliases();
}
public interface XmpCore.IXmpVersionInfo {
    public int Major { get; }
    public int Minor { get; }
    public int Micro { get; }
    public int Build { get; }
    public bool IsDebug { get; }
    public string Message { get; }
    public abstract virtual int get_Major();
    public abstract virtual int get_Minor();
    public abstract virtual int get_Micro();
    public abstract virtual int get_Build();
    public abstract virtual bool get_IsDebug();
    public abstract virtual string get_Message();
}
public class XmpCore.Options.AliasOptions : Options {
    public static int PropDirect;
    public static int PropArray;
    public static int PropArrayOrdered;
    public static int PropArrayAlternate;
    public static int PropArrayAltText;
    public bool IsArray { get; public set; }
    public bool IsArrayOrdered { get; public set; }
    public bool IsArrayAlternate { get; public set; }
    public bool IsArrayAltText { get; public set; }
    public AliasOptions(int options);
    public bool IsSimple();
    public bool get_IsArray();
    public void set_IsArray(bool value);
    public bool get_IsArrayOrdered();
    public void set_IsArrayOrdered(bool value);
    public bool get_IsArrayAlternate();
    public void set_IsArrayAlternate(bool value);
    public bool get_IsArrayAltText();
    public void set_IsArrayAltText(bool value);
    public PropertyOptions ToPropertyOptions();
    protected virtual string DefineOptionName(int option);
    protected virtual int GetValidOptions();
}
public class XmpCore.Options.IteratorOptions : Options {
    public static int JustChildren;
    public static int JustLeafNodes;
    public static int JustLeafName;
    public static int OmitQualifiers;
    public bool IsJustChildren { get; public set; }
    public bool IsJustLeafName { get; public set; }
    public bool IsJustLeafNodes { get; public set; }
    public bool IsOmitQualifiers { get; public set; }
    public bool get_IsJustChildren();
    public void set_IsJustChildren(bool value);
    public bool get_IsJustLeafName();
    public void set_IsJustLeafName(bool value);
    public bool get_IsJustLeafNodes();
    public void set_IsJustLeafNodes(bool value);
    public bool get_IsOmitQualifiers();
    public void set_IsOmitQualifiers(bool value);
    protected virtual string DefineOptionName(int option);
    protected virtual int GetValidOptions();
}
public abstract class XmpCore.Options.Options : object {
    private int _options;
    private IDictionary`2<int, string> _optionNames;
    protected Options(int options);
    public void Clear();
    public bool IsExactly(int optionBits);
    public bool ContainsAllOptions(int optionBits);
    public bool ContainsOneOf(int optionBits);
    protected bool GetOption(int optionBit);
    public void SetOption(int optionBits, bool value);
    public int GetOptions();
    public void SetOptions(int options);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string GetOptionsString();
    public virtual string ToString();
    protected abstract virtual int GetValidOptions();
    protected abstract virtual string DefineOptionName(int option);
    internal virtual void AssertConsistency(int options);
    private void AssertOptionsValid(int options);
    private string GetOptionName(int option);
    private IDictionary`2<int, string> ProcureOptionNames();
}
public class XmpCore.Options.ParseOptions : Options {
    private static int RequireXmpMetaFlag;
    private static int StrictAliasingFlag;
    private static int FixControlCharsFlag;
    private static int AcceptLatin1Flag;
    private static int OmitNormalizationFlag;
    public static int DisallowDoctypeFlag;
    private Dictionary`2<string, int> mXMPNodesToLimit;
    public bool RequireXmpMeta { get; public set; }
    public bool StrictAliasing { get; public set; }
    public bool FixControlChars { get; public set; }
    public bool AcceptLatin1 { get; public set; }
    public bool OmitNormalization { get; public set; }
    public bool DisallowDoctype { get; public set; }
    public bool AreXMPNodesLimited { get; }
    public bool get_RequireXmpMeta();
    public void set_RequireXmpMeta(bool value);
    public bool get_StrictAliasing();
    public void set_StrictAliasing(bool value);
    public bool get_FixControlChars();
    public void set_FixControlChars(bool value);
    public bool get_AcceptLatin1();
    public void set_AcceptLatin1(bool value);
    public bool get_OmitNormalization();
    public void set_OmitNormalization(bool value);
    public bool get_DisallowDoctype();
    public void set_DisallowDoctype(bool value);
    public bool get_AreXMPNodesLimited();
    public ParseOptions SetXMPNodesToLimit(Dictionary`2<string, int> nodeMap);
    public Dictionary`2<string, int> GetXMPNodesToLimit();
    protected virtual string DefineOptionName(int option);
    protected virtual int GetValidOptions();
}
public class XmpCore.Options.PropertyOptions : Options {
    internal static int NoOptionsFlag;
    internal static int IsUriFlag;
    internal static int HasQualifiersFlag;
    internal static int QualifierFlag;
    internal static int HasLanguageFlag;
    internal static int HasTypeFlag;
    internal static int StructFlag;
    internal static int ArrayFlag;
    internal static int ArrayOrderedFlag;
    internal static int ArrayAlternateFlag;
    internal static int ArrayAltTextFlag;
    internal static int SchemaNodeFlag;
    internal static int DeleteExisting;
    private int arrayElementsLimit;
    public bool IsUri { get; public set; }
    public bool HasQualifiers { get; public set; }
    public bool IsQualifier { get; public set; }
    public bool HasLanguage { get; public set; }
    public bool HasType { get; public set; }
    public bool IsStruct { get; public set; }
    public bool IsArray { get; public set; }
    public bool IsArrayOrdered { get; public set; }
    public bool IsArrayAlternate { get; public set; }
    public bool IsArrayAltText { get; public set; }
    public bool IsArrayLimited { get; }
    public int ArrayElementsLimit { get; }
    public bool IsSchemaNode { get; public set; }
    public bool IsCompositeProperty { get; }
    public bool IsSimple { get; }
    public bool IsOnlyArrayOptions { get; }
    public PropertyOptions(int options);
    public bool get_IsUri();
    public void set_IsUri(bool value);
    public bool get_HasQualifiers();
    public void set_HasQualifiers(bool value);
    public bool get_IsQualifier();
    public void set_IsQualifier(bool value);
    public bool get_HasLanguage();
    public void set_HasLanguage(bool value);
    public bool get_HasType();
    public void set_HasType(bool value);
    public bool get_IsStruct();
    public void set_IsStruct(bool value);
    public bool get_IsArray();
    public void set_IsArray(bool value);
    public bool get_IsArrayOrdered();
    public void set_IsArrayOrdered(bool value);
    public bool get_IsArrayAlternate();
    public void set_IsArrayAlternate(bool value);
    public bool get_IsArrayAltText();
    public void set_IsArrayAltText(bool value);
    public bool get_IsArrayLimited();
    public PropertyOptions SetArrayElementLimit(int arrayLimit);
    public int get_ArrayElementsLimit();
    public bool get_IsSchemaNode();
    public void set_IsSchemaNode(bool value);
    public bool get_IsCompositeProperty();
    public bool get_IsSimple();
    public bool EqualArrayTypes(PropertyOptions options);
    public void MergeWith(PropertyOptions options);
    public bool get_IsOnlyArrayOptions();
    protected virtual int GetValidOptions();
    protected virtual string DefineOptionName(int option);
    internal virtual void AssertConsistency(int options);
}
public class XmpCore.Options.SerializeOptions : Options {
    public static int OmitPacketWrapperFlag;
    public static int ReadonlyPacketFlag;
    public static int UseCompactFormatFlag;
    public static int UseCanonicalFormatFlag;
    public static int UsePlainXmpFlag;
    public static int IncludeThumbnailPadFlag;
    public static int ExactPacketLengthFlag;
    public static int OmitXmpmetaElementFlag;
    public static int SortFlag;
    private static int LittleEndianBit;
    private static int Utf16Bit;
    public static int EncodeUtf8;
    public static int EncodeUtf16BeFlag;
    public static int EncodeUtf16LeFlag;
    private static int EncodingMask;
    [CompilerGeneratedAttribute]
private int <BaseIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Indent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Newline>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Padding>k__BackingField;
    public bool OmitPacketWrapper { get; public set; }
    public bool OmitXmpMetaElement { get; public set; }
    public bool ReadOnlyPacket { get; public set; }
    public bool UseCompactFormat { get; public set; }
    public bool UseCanonicalFormat { get; public set; }
    public bool UsePlainXmp { get; public set; }
    public bool IncludeThumbnailPad { get; public set; }
    public bool ExactPacketLength { get; public set; }
    public bool Sort { get; public set; }
    public bool EncodeUtf16Be { get; public set; }
    public bool EncodeUtf16Le { get; public set; }
    public int BaseIndent { get; public set; }
    public string Indent { get; public set; }
    public string Newline { get; public set; }
    public int Padding { get; public set; }
    public SerializeOptions(int options);
    public bool get_OmitPacketWrapper();
    public void set_OmitPacketWrapper(bool value);
    public bool get_OmitXmpMetaElement();
    public void set_OmitXmpMetaElement(bool value);
    public bool get_ReadOnlyPacket();
    public void set_ReadOnlyPacket(bool value);
    public bool get_UseCompactFormat();
    public void set_UseCompactFormat(bool value);
    public bool get_UseCanonicalFormat();
    public void set_UseCanonicalFormat(bool value);
    public bool get_UsePlainXmp();
    public void set_UsePlainXmp(bool value);
    public bool get_IncludeThumbnailPad();
    public void set_IncludeThumbnailPad(bool value);
    public bool get_ExactPacketLength();
    public void set_ExactPacketLength(bool value);
    public bool get_Sort();
    public void set_Sort(bool value);
    public bool get_EncodeUtf16Be();
    public void set_EncodeUtf16Be(bool value);
    public bool get_EncodeUtf16Le();
    public void set_EncodeUtf16Le(bool value);
    [CompilerGeneratedAttribute]
public void set_BaseIndent(int value);
    [CompilerGeneratedAttribute]
public int get_BaseIndent();
    [CompilerGeneratedAttribute]
public void set_Indent(string value);
    [CompilerGeneratedAttribute]
public string get_Indent();
    [CompilerGeneratedAttribute]
public string get_Newline();
    [CompilerGeneratedAttribute]
public void set_Newline(string value);
    [CompilerGeneratedAttribute]
public int get_Padding();
    [CompilerGeneratedAttribute]
public void set_Padding(int value);
    public Encoding GetEncoding();
    public object Clone();
    protected virtual string DefineOptionName(int option);
    protected virtual int GetValidOptions();
}
public class XmpCore.Options.TemplateOptions : Options {
    public static int ClearUnnamedPropertiesFlag;
    public static int ReplaceExistingPropertiesFlag;
    public static int IncludeInternalPropertiesFlag;
    public static int AddNewPropertiesFlag;
    public static int ReplaceWithDeleteEmptyFlag;
    public bool ClearUnnamedProperties { get; public set; }
    public bool ReplaceExistingProperties { get; public set; }
    public bool IncludeInternalProperties { get; public set; }
    public bool AddNewProperties { get; public set; }
    public bool ReplaceWithDeleteEmpty { get; public set; }
    public TemplateOptions(int options);
    public bool get_ClearUnnamedProperties();
    public void set_ClearUnnamedProperties(bool value);
    public bool get_ReplaceExistingProperties();
    public void set_ReplaceExistingProperties(bool value);
    public bool get_IncludeInternalProperties();
    public void set_IncludeInternalProperties(bool value);
    public bool get_AddNewProperties();
    public void set_AddNewProperties(bool value);
    public bool get_ReplaceWithDeleteEmpty();
    public void set_ReplaceWithDeleteEmpty(bool value);
    public object Clone();
    protected virtual string DefineOptionName(int option);
    protected virtual int GetValidOptions();
}
public static class XmpCore.XmpConstants : object {
    public static string NsXml;
    public static string NsRdf;
    public static string NsDC;
    public static string NsIptccore;
    public static string NsIptcext;
    public static string NsDicom;
    public static string NsPlus;
    public static string NsX;
    public static string NsIx;
    public static string NsXmp;
    public static string NsXmpRights;
    public static string NsXmpMm;
    public static string NsXmpBj;
    public static string NsXmpNote;
    public static string NsPdf;
    public static string NsPdfx;
    public static string NsPdfxId;
    public static string NsPdfaSchema;
    public static string NsPdfaProperty;
    public static string NsPdfaType;
    public static string NsPdfaField;
    public static string NsPdfaId;
    public static string NsPdfaExtension;
    public static string NsPhotoshop;
    public static string NsPsalbum;
    public static string NsExif;
    public static string NsExifx;
    public static string NsExifAux;
    public static string NsTiff;
    public static string NsPng;
    public static string NsJpeg;
    public static string NsJp2K;
    public static string NsCameraraw;
    public static string NsAdobestockphoto;
    public static string NsCreatorAtom;
    public static string NsAsf;
    public static string NsWav;
    public static string NsBwf;
    public static string NsRiffinfo;
    public static string NsScript;
    public static string NsTxmp;
    public static string NsSwf;
    public static string NsCcv;
    public static string NsDm;
    public static string NsTransient;
    public static string NsDcDeprecated;
    public static string TypeIdentifierqual;
    public static string TypeDimensions;
    public static string TypeText;
    public static string TypePagedfile;
    public static string TypeGraphics;
    public static string TypeImage;
    public static string TypeFont;
    public static string TypeResourceevent;
    public static string TypeResourceref;
    public static string TypeStVersion;
    public static string TypeStJob;
    public static string TypeManifestitem;
    public static string TrueString;
    public static string FalseString;
    public static int ArrayLastItem;
    public static string ArrayItemName;
    public static string XDefault;
    public static string XmlLang;
    public static string RdfLi;
    public static string RdfType;
    public static string XmpPi;
    public static string TagXmpmeta;
    public static string TagXapmeta;
}
public static class XmpCore.XmpDateTimeFactory : object {
    public static IXmpDateTime CreateFromCalendar(Calendar calendar);
    public static IXmpDateTime Create();
    public static IXmpDateTime Create(int year, int month, int day);
    public static IXmpDateTime Create(int year, int month, int day, int hour, int minute, int second, int nanoSecond);
    public static IXmpDateTime CreateFromIso8601(string strValue);
    public static IXmpDateTime GetCurrentDateTime();
    public static IXmpDateTime SetLocalTimeZone(IXmpDateTime dateTime);
    public static IXmpDateTime ConvertToUtcTime(IXmpDateTime dateTime);
    public static IXmpDateTime ConvertToLocalTime(IXmpDateTime dateTime);
}
public enum XmpCore.XmpErrorCode : Enum {
    public int value__;
    public static XmpErrorCode Unknown;
    public static XmpErrorCode BadParam;
    public static XmpErrorCode BadValue;
    public static XmpErrorCode InternalFailure;
    public static XmpErrorCode BadSchema;
    public static XmpErrorCode BadXPath;
    public static XmpErrorCode BadOptions;
    public static XmpErrorCode BadIndex;
    public static XmpErrorCode BadSerialize;
    public static XmpErrorCode BadXml;
    public static XmpErrorCode BadRdf;
    public static XmpErrorCode BadXmp;
    public static XmpErrorCode BadStream;
}
public class XmpCore.XmpException : Exception {
    [CompilerGeneratedAttribute]
private XmpErrorCode <ErrorCode>k__BackingField;
    public XmpErrorCode ErrorCode { get; }
    public XmpException(string message, XmpErrorCode errorCode);
    public XmpException(string message, XmpErrorCode errorCode, Exception innerException);
    [CompilerGeneratedAttribute]
public XmpErrorCode get_ErrorCode();
}
public static class XmpCore.XmpMetaFactory : object {
    [CompilerGeneratedAttribute]
private static IXmpSchemaRegistry <SchemaRegistry>k__BackingField;
    public static IXmpSchemaRegistry SchemaRegistry { get; private set; }
    public static IXmpVersionInfo VersionInfo { get; }
    private static XmpMetaFactory();
    [CompilerGeneratedAttribute]
public static IXmpSchemaRegistry get_SchemaRegistry();
    [CompilerGeneratedAttribute]
private static void set_SchemaRegistry(IXmpSchemaRegistry value);
    public static IXmpMeta Create();
    public static IXmpMeta Parse(Stream stream, ParseOptions options);
    public static IXmpMeta ParseFromString(string packet, ParseOptions options);
    public static IXmpMeta ParseFromBuffer(Byte[] buffer, ParseOptions options);
    public static IXmpMeta ParseFromBuffer(Byte[] buffer, int offset, int length, ParseOptions options);
    public static IXmpMeta ParseFromXDocument(XDocument root, ParseOptions options);
    public static XDocument ExtractXDocumentFromBuffer(Byte[] buffer, ParseOptions options);
    public static void Serialize(IXmpMeta xmp, Stream stream, SerializeOptions options);
    public static Byte[] SerializeToBuffer(IXmpMeta xmp, SerializeOptions options);
    public static string SerializeToString(IXmpMeta xmp, SerializeOptions options);
    private static void AssertImplementation(IXmpMeta xmp);
    public static void Reset();
    public static IXmpVersionInfo get_VersionInfo();
}
public static class XmpCore.XmpPathFactory : object {
    public static string ComposeArrayItemPath(string arrayName, int itemIndex);
    public static string ComposeStructFieldPath(string fieldNs, string fieldName);
    public static string ComposeQualifierPath(string qualNs, string qualName);
    public static string ComposeLangSelector(string arrayName, string langName);
    public static string ComposeFieldSelector(string arrayName, string fieldNs, string fieldName, string fieldValue);
    private static void AssertQualNs(string qualNs);
    private static void AssertQualName(string qualName);
    private static void AssertFieldNs(string fieldNs);
    private static void AssertFieldName(string fieldName);
}
public static class XmpCore.XmpUtils : object {
    public static string CatenateArrayItems(IXmpMeta xmp, string schemaNs, string arrayName, string separator, string quotes, bool allowCommas);
    public static void SeparateArrayItems(IXmpMeta xmp, string schemaNs, string arrayName, string catedStr, PropertyOptions arrayOptions, bool preserveCommas);
    public static void RemoveProperties(IXmpMeta xmp, string schemaNs, string propName, bool doAllProperties, bool includeAliases);
    public static void AppendProperties(IXmpMeta source, IXmpMeta dest, bool doAllProperties, bool replaceOldValues, bool deleteEmptyValues);
    public static bool ConvertToBoolean(string value);
    public static string ConvertFromBoolean(bool value);
    public static int ConvertToInteger(string rawValue);
    public static string ConvertFromInteger(int value);
    public static long ConvertToLong(string rawValue);
    public static string ConvertFromLong(long value);
    public static double ConvertToDouble(string rawValue);
    public static string ConvertFromDouble(double value);
    public static IXmpDateTime ConvertToDate(string rawValue);
    public static string ConvertFromDate(IXmpDateTime value);
    public static string EncodeBase64(Byte[] buffer);
    public static Byte[] DecodeBase64(string base64String);
    public static void PackageForJPEG(IXmpMeta origXMP, StringBuilder stdStr, StringBuilder extStr, StringBuilder digestStr);
    public static void MergeFromJPEG(IXmpMeta fullXMP, IXmpMeta extendedXMP);
    public static void ApplyTemplate(IXmpMeta workingXMP, IXmpMeta templateXMP, TemplateOptions options);
    public static void DuplicateSubtree(IXmpMeta source, IXmpMeta dest, string sourceNS, string sourceRoot, string destNS, string destRoot, PropertyOptions options);
}
