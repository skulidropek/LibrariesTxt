[ExtensionAttribute]
internal static class AssemblyExtensions : object {
    [ExtensionAttribute]
public static string GetLocalCodeBase(Assembly assembly);
    public static string GetLocalCodeBase(string codeBase, char directorySeparator);
}
[ExtensionAttribute]
internal static class DictionaryExtensions : object {
    [ExtensionAttribute]
public static void Add(Dictionary`2<TKey, List`1<TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static TValue AddOrGet(Dictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue AddOrGet(Dictionary`2<TKey, TValue> dictionary, TKey key, Func`1<TValue> newValue);
    [ExtensionAttribute]
public static bool Contains(IReadOnlyDictionary`2<TKey, List`1<TValue>> dictionary, TKey key, TValue value, IEqualityComparer`1<TValue> valueComparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionaryIgnoringDuplicateKeys(IEnumerable`1<TValue> values, Func`2<TValue, TKey> keySelector, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> ToDictionaryIgnoringDuplicateKeys(IEnumerable`1<TInput> inputValues, Func`2<TInput, TKey> keySelector, Func`2<TInput, TValue> valueSelector, IEqualityComparer`1<TKey> comparer);
}
internal static class Guard : object {
    public static void ArgumentNotNull(string argName, object argValue);
    public static void ArgumentNotNullOrEmpty(string argName, IEnumerable argValue);
    public static void ArgumentValid(string argName, bool test, string message);
    public static void ArgumentValid(string argName, bool test, string messageFormat, Object[] args);
    public static void FileExists(string argName, string fileName);
}
internal static class Internal.Microsoft.DotNet.PlatformAbstractions.ApplicationEnvironment : object {
    [CompilerGeneratedAttribute]
private static string <ApplicationBasePath>k__BackingField;
    public static string ApplicationBasePath { get; }
    private static ApplicationEnvironment();
    [CompilerGeneratedAttribute]
public static string get_ApplicationBasePath();
    private static string GetApplicationBasePath();
}
internal class Internal.Microsoft.DotNet.PlatformAbstractions.HashCodeCombiner : ValueType {
    private long _combinedHash64;
    public int CombinedHash { get; }
    private HashCodeCombiner(long seed);
    public int get_CombinedHash();
    public void Add(int i);
    public void Add(string s);
    public void Add(object o);
    public void Add(TValue value, IEqualityComparer`1<TValue> comparer);
    public static HashCodeCombiner Start();
}
internal static class Internal.Microsoft.DotNet.PlatformAbstractions.Native.NativeMethods : object {
}
internal static class Internal.Microsoft.DotNet.PlatformAbstractions.Native.PlatformApis : object {
    private static Lazy`1<Platform> _platform;
    private static Lazy`1<DistroInfo> _distroInfo;
    private static PlatformApis();
    public static string GetOSName();
    public static string GetOSVersion();
    private static string GetDarwinVersion();
    public static Platform GetOSPlatform();
    private static string GetDistroId();
    private static string GetDistroVersionId();
    private static DistroInfo LoadDistroInfo();
    private static DistroInfo NormalizeDistroInfo(DistroInfo distroInfo);
    private static Platform DetermineOSPlatform();
}
internal enum Internal.Microsoft.DotNet.PlatformAbstractions.Platform : Enum {
    public int value__;
    public static Platform Unknown;
    public static Platform Windows;
    public static Platform Linux;
    public static Platform Darwin;
}
internal static class Internal.Microsoft.DotNet.PlatformAbstractions.RuntimeEnvironment : object {
    private static string OverrideEnvironmentVariableName;
    [CompilerGeneratedAttribute]
private static Platform <OperatingSystemPlatform>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OperatingSystemVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <OperatingSystem>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <RuntimeArchitecture>k__BackingField;
    public static Platform OperatingSystemPlatform { get; }
    public static string OperatingSystemVersion { get; }
    public static string OperatingSystem { get; }
    public static string RuntimeArchitecture { get; }
    private static RuntimeEnvironment();
    [CompilerGeneratedAttribute]
public static Platform get_OperatingSystemPlatform();
    [CompilerGeneratedAttribute]
public static string get_OperatingSystemVersion();
    [CompilerGeneratedAttribute]
public static string get_OperatingSystem();
    [CompilerGeneratedAttribute]
public static string get_RuntimeArchitecture();
    private static string GetArch();
    public static string GetRuntimeIdentifier();
    private static string GetRIDArch();
    private static string GetRIDVersion();
    private static string GetWindowsProductVersion();
    private static string GetRIDOS();
}
internal class Internal.Microsoft.Extensions.DependencyModel.CompilationLibrary : Library {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Assemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private static ICompilationAssemblyResolver <DefaultResolver>k__BackingField;
    public IReadOnlyList`1<string> Assemblies { get; }
    internal static ICompilationAssemblyResolver DefaultResolver { get; }
    public CompilationLibrary(string type, string name, string version, string hash, IEnumerable`1<string> assemblies, IEnumerable`1<Dependency> dependencies, bool serviceable);
    public CompilationLibrary(string type, string name, string version, string hash, IEnumerable`1<string> assemblies, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath);
    private static CompilationLibrary();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Assemblies();
    [CompilerGeneratedAttribute]
internal static ICompilationAssemblyResolver get_DefaultResolver();
    public IEnumerable`1<string> ResolveReferencePaths();
    public IEnumerable`1<string> ResolveReferencePaths(ICompilationAssemblyResolver[] customResolvers);
    private IEnumerable`1<string> ResolveReferencePaths(ICompilationAssemblyResolver resolver, List`1<string> assemblies);
}
internal class Internal.Microsoft.Extensions.DependencyModel.CompilationOptions : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Defines>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LanguageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowUnsafe>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Optimize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DelaySign>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PublicSign>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DebugType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EmitEntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <GenerateXmlDocumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private static CompilationOptions <Default>k__BackingField;
    public IReadOnlyList`1<string> Defines { get; }
    public string LanguageVersion { get; }
    public string Platform { get; }
    public Nullable`1<bool> AllowUnsafe { get; }
    public Nullable`1<bool> WarningsAsErrors { get; }
    public Nullable`1<bool> Optimize { get; }
    public string KeyFile { get; }
    public Nullable`1<bool> DelaySign { get; }
    public Nullable`1<bool> PublicSign { get; }
    public string DebugType { get; }
    public Nullable`1<bool> EmitEntryPoint { get; }
    public Nullable`1<bool> GenerateXmlDocumentation { get; }
    public static CompilationOptions Default { get; }
    public CompilationOptions(IEnumerable`1<string> defines, string languageVersion, string platform, Nullable`1<bool> allowUnsafe, Nullable`1<bool> warningsAsErrors, Nullable`1<bool> optimize, string keyFile, Nullable`1<bool> delaySign, Nullable`1<bool> publicSign, string debugType, Nullable`1<bool> emitEntryPoint, Nullable`1<bool> generateXmlDocumentation);
    private static CompilationOptions();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Defines();
    [CompilerGeneratedAttribute]
public string get_LanguageVersion();
    [CompilerGeneratedAttribute]
public string get_Platform();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllowUnsafe();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Optimize();
    [CompilerGeneratedAttribute]
public string get_KeyFile();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_DelaySign();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PublicSign();
    [CompilerGeneratedAttribute]
public string get_DebugType();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EmitEntryPoint();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_GenerateXmlDocumentation();
    [CompilerGeneratedAttribute]
public static CompilationOptions get_Default();
}
internal class Internal.Microsoft.Extensions.DependencyModel.Dependency : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Name { get; }
    public string Version { get; }
    public Dependency(string name, string version);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Name();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_Version();
    public bool Equals(Dependency other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContext : object {
    private static Lazy`1<DependencyContext> _defaultContext;
    [CompilerGeneratedAttribute]
private TargetInfo <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private CompilationOptions <CompilationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<CompilationLibrary> <CompileLibraries>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RuntimeLibrary> <RuntimeLibraries>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RuntimeFallbacks> <RuntimeGraph>k__BackingField;
    public static DependencyContext Default { get; }
    public TargetInfo Target { get; }
    public CompilationOptions CompilationOptions { get; }
    public IReadOnlyList`1<CompilationLibrary> CompileLibraries { get; }
    public IReadOnlyList`1<RuntimeLibrary> RuntimeLibraries { get; }
    public IReadOnlyList`1<RuntimeFallbacks> RuntimeGraph { get; }
    public DependencyContext(TargetInfo target, CompilationOptions compilationOptions, IEnumerable`1<CompilationLibrary> compileLibraries, IEnumerable`1<RuntimeLibrary> runtimeLibraries, IEnumerable`1<RuntimeFallbacks> runtimeGraph);
    private static DependencyContext();
    public static DependencyContext get_Default();
    [CompilerGeneratedAttribute]
public TargetInfo get_Target();
    [CompilerGeneratedAttribute]
public CompilationOptions get_CompilationOptions();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<CompilationLibrary> get_CompileLibraries();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RuntimeLibrary> get_RuntimeLibraries();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RuntimeFallbacks> get_RuntimeGraph();
    public DependencyContext Merge(DependencyContext other);
    private static DependencyContext LoadDefault();
    public static DependencyContext Load(Assembly assembly);
}
[ExtensionAttribute]
internal static class Internal.Microsoft.Extensions.DependencyModel.DependencyContextExtensions : object {
    private static string NativeImageSufix;
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDefaultNativeAssets(DependencyContext self);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetRuntimeNativeAssets(DependencyContext self, string runtimeIdentifier);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDefaultNativeAssets(RuntimeLibrary self, DependencyContext context);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetRuntimeNativeAssets(RuntimeLibrary self, DependencyContext context, string runtimeIdentifier);
    [ExtensionAttribute]
public static IEnumerable`1<AssemblyName> GetDefaultAssemblyNames(DependencyContext self);
    [ExtensionAttribute]
public static IEnumerable`1<AssemblyName> GetRuntimeAssemblyNames(DependencyContext self, string runtimeIdentifier);
    [ExtensionAttribute]
public static IEnumerable`1<AssemblyName> GetDefaultAssemblyNames(RuntimeLibrary self, DependencyContext context);
    [ExtensionAttribute]
public static IEnumerable`1<AssemblyName> GetRuntimeAssemblyNames(RuntimeLibrary self, DependencyContext context, string runtimeIdentifier);
    private static AssemblyName GetAssemblyName(string assetPath);
    private static IEnumerable`1<string> ResolveAssets(DependencyContext context, string runtimeIdentifier, IEnumerable`1<RuntimeAssetGroup> assets);
    private static IEnumerable`1<string> SelectAssets(IEnumerable`1<string> rids, IEnumerable`1<RuntimeAssetGroup> groups);
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContextJsonReader : object {
    private static String[] EmptyStringArray;
    private IDictionary`2<string, string> _stringPool;
    private static DependencyContextJsonReader();
    public sealed virtual DependencyContext Read(Stream stream);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    private DependencyContext Read(TextReader reader);
    private Target SelectRuntimeTarget(List`1<Target> targets, string runtimeTargetName);
    private bool IsRuntimeTarget(string name);
    private void ReadRuntimeTarget(JsonObject runtimeTargetJson, String& runtimeTargetName, String& runtimeSignature);
    private CompilationOptions ReadCompilationOptions(JsonObject compilationOptionsJson);
    private List`1<Target> ReadTargets(JsonObject targetsJson);
    private Target ReadTarget(string targetName, JsonObject targetJson);
    private TargetLibrary ReadTargetLibrary(string targetLibraryName, JsonObject targetLibraryJson);
    public IEnumerable`1<Dependency> ReadTargetLibraryDependencies(JsonObject targetLibraryDependenciesJson);
    private List`1<RuntimeTargetEntryStub> ReadTargetLibraryRuntimeTargets(JsonObject targetLibraryRuntimeTargetsJson);
    private List`1<ResourceAssembly> ReadTargetLibraryResources(JsonObject targetLibraryResourcesJson);
    private Dictionary`2<string, LibraryStub> ReadLibraries(JsonObject librariesJson);
    private LibraryStub ReadLibrary(JsonObject libraryJson);
    private List`1<RuntimeFallbacks> ReadRuntimes(JsonObject runtimesJson);
    private IEnumerable`1<Library> CreateLibraries(IEnumerable`1<TargetLibrary> libraries, bool runtime, Dictionary`2<string, LibraryStub> libraryStubs);
    private Library CreateLibrary(TargetLibrary targetLibrary, bool runtime, Dictionary`2<string, LibraryStub> libraryStubs);
    private string Pool(string s);
    [CompilerGeneratedAttribute]
private bool <Read>b__5_0(Target t);
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContextLoader : object {
    private static string DepsJsonExtension;
    private string _entryPointDepsLocation;
    private IEnumerable`1<string> _nonEntryPointDepsPaths;
    private IFileSystem _fileSystem;
    private Func`1<IDependencyContextReader> _jsonReaderFactory;
    [CompilerGeneratedAttribute]
private static DependencyContextLoader <Default>k__BackingField;
    public static DependencyContextLoader Default { get; }
    internal DependencyContextLoader(string entryPointDepsLocation, IEnumerable`1<string> nonEntryPointDepsPaths, IFileSystem fileSystem, Func`1<IDependencyContextReader> jsonReaderFactory);
    private static DependencyContextLoader();
    [CompilerGeneratedAttribute]
public static DependencyContextLoader get_Default();
    private static bool IsEntryAssembly(Assembly assembly);
    private static Stream GetResourceStream(Assembly assembly, string name);
    public DependencyContext Load(Assembly assembly);
    private DependencyContext LoadEntryAssemblyContext(IDependencyContextReader reader);
    private DependencyContext LoadContext(IDependencyContextReader reader, string location);
    private DependencyContext LoadAssemblyContext(Assembly assembly, IDependencyContextReader reader);
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContextPaths : object {
    private static string DepsFilesProperty;
    private static string FxDepsFileProperty;
    [CompilerGeneratedAttribute]
private static DependencyContextPaths <Current>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Application>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SharedRuntime>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <NonApplicationPaths>k__BackingField;
    public static DependencyContextPaths Current { get; }
    public string Application { get; }
    public string SharedRuntime { get; }
    public IEnumerable`1<string> NonApplicationPaths { get; }
    public DependencyContextPaths(string application, string sharedRuntime, IEnumerable`1<string> nonApplicationPaths);
    private static DependencyContextPaths();
    [CompilerGeneratedAttribute]
public static DependencyContextPaths get_Current();
    [CompilerGeneratedAttribute]
public string get_Application();
    [CompilerGeneratedAttribute]
public string get_SharedRuntime();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_NonApplicationPaths();
    private static DependencyContextPaths GetCurrent();
    internal static DependencyContextPaths Create(string depsFiles, string sharedRuntime);
}
internal class Internal.Microsoft.Extensions.DependencyModel.DependencyContextStrings : object {
    internal static char VersionSeperator;
    internal static string CompileTimeAssembliesKey;
    internal static string RuntimeAssembliesKey;
    internal static string NativeLibrariesKey;
    internal static string RuntimeTargetPropertyName;
    internal static string LibrariesPropertyName;
    internal static string TargetsPropertyName;
    internal static string DependenciesPropertyName;
    internal static string Sha512PropertyName;
    internal static string PathPropertyName;
    internal static string HashPathPropertyName;
    internal static string RuntimeStoreManifestPropertyName;
    internal static string TypePropertyName;
    internal static string ServiceablePropertyName;
    internal static string CompilationOptionsPropertName;
    internal static string DefinesPropertyName;
    internal static string LanguageVersionPropertyName;
    internal static string PlatformPropertyName;
    internal static string AllowUnsafePropertyName;
    internal static string WarningsAsErrorsPropertyName;
    internal static string OptimizePropertyName;
    internal static string KeyFilePropertyName;
    internal static string DelaySignPropertyName;
    internal static string PublicSignPropertyName;
    internal static string DebugTypePropertyName;
    internal static string EmitEntryPointPropertyName;
    internal static string GenerateXmlDocumentationPropertyName;
    internal static string PortablePropertyName;
    internal static string RuntimeTargetNamePropertyName;
    internal static string RuntimeTargetSignaturePropertyName;
    internal static string RuntimesPropertyName;
    internal static string RuntimeTargetsPropertyName;
    internal static string RidPropertyName;
    internal static string AssetTypePropertyName;
    internal static string RuntimeAssetType;
    internal static string NativeAssetType;
    internal static string ResourceAssembliesPropertyName;
    internal static string LocalePropertyName;
    internal static string CompilationOnlyPropertyName;
}
internal class Internal.Microsoft.Extensions.DependencyModel.DirectoryWrapper : object {
    public sealed virtual bool Exists(string path);
}
internal class Internal.Microsoft.Extensions.DependencyModel.EnvironmentWrapper : object {
    public static IEnvironment Default;
    private static EnvironmentWrapper();
    public sealed virtual string GetEnvironmentVariable(string name);
}
internal class Internal.Microsoft.Extensions.DependencyModel.FileSystemWrapper : object {
    [CompilerGeneratedAttribute]
private static IFileSystem <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private IFile <File>k__BackingField;
    [CompilerGeneratedAttribute]
private IDirectory <Directory>k__BackingField;
    public static IFileSystem Default { get; }
    public IFile File { get; }
    public IDirectory Directory { get; }
    private static FileSystemWrapper();
    [CompilerGeneratedAttribute]
public static IFileSystem get_Default();
    [CompilerGeneratedAttribute]
public sealed virtual IFile get_File();
    [CompilerGeneratedAttribute]
public sealed virtual IDirectory get_Directory();
}
internal class Internal.Microsoft.Extensions.DependencyModel.FileWrapper : object {
    public sealed virtual bool Exists(string path);
    public sealed virtual string ReadAllText(string path);
    public sealed virtual Stream OpenRead(string path);
    public sealed virtual Stream OpenFile(string path, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, int bufferSize, FileOptions fileOptions);
    public sealed virtual void CreateEmptyFile(string path);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IDependencyContextReader {
    public abstract virtual DependencyContext Read(Stream stream);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IDirectory {
    public abstract virtual bool Exists(string path);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IEnvironment {
    public abstract virtual string GetEnvironmentVariable(string name);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IFile {
    public abstract virtual bool Exists(string path);
    public abstract virtual string ReadAllText(string path);
    public abstract virtual Stream OpenRead(string path);
    public abstract virtual Stream OpenFile(string path, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, int bufferSize, FileOptions fileOptions);
    public abstract virtual void CreateEmptyFile(string path);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.IFileSystem {
    public IFile File { get; }
    public IDirectory Directory { get; }
    public abstract virtual IFile get_File();
    public abstract virtual IDirectory get_Directory();
}
internal class Internal.Microsoft.Extensions.DependencyModel.Library : object {
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Dependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeStoreManifestName>k__BackingField;
    public string Type { get; }
    public string Name { get; }
    public string Version { get; }
    public string Hash { get; }
    public IReadOnlyList`1<Dependency> Dependencies { get; }
    public bool Serviceable { get; }
    public string Path { get; }
    public string HashPath { get; }
    public string RuntimeStoreManifestName { get; }
    public Library(string type, string name, string version, string hash, IEnumerable`1<Dependency> dependencies, bool serviceable);
    public Library(string type, string name, string version, string hash, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath);
    public Library(string type, string name, string version, string hash, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath, string runtimeStoreManifestName);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public string get_Hash();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Dependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public bool get_Serviceable();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_HashPath();
    [CompilerGeneratedAttribute]
public string get_RuntimeStoreManifestName();
}
internal class Internal.Microsoft.Extensions.DependencyModel.Resolution.AppBaseCompilationAssemblyResolver : object {
    private static string RefsDirectoryName;
    private IFileSystem _fileSystem;
    private string _basePath;
    private DependencyContextPaths _dependencyContextPaths;
    public AppBaseCompilationAssemblyResolver(string basePath);
    internal AppBaseCompilationAssemblyResolver(IFileSystem fileSystem);
    internal AppBaseCompilationAssemblyResolver(IFileSystem fileSystem, string basePath, DependencyContextPaths dependencyContextPaths);
    private static AppBaseCompilationAssemblyResolver();
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
}
internal class Internal.Microsoft.Extensions.DependencyModel.Resolution.CompositeCompilationAssemblyResolver : object {
    private ICompilationAssemblyResolver[] _resolvers;
    public CompositeCompilationAssemblyResolver(ICompilationAssemblyResolver[] resolvers);
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
}
internal class Internal.Microsoft.Extensions.DependencyModel.Resolution.DotNetReferenceAssembliesPathResolver : object {
    public static string DotNetReferenceAssembliesPathEnv;
    private static DotNetReferenceAssembliesPathResolver();
    internal static string Resolve(IEnvironment envirnment, IFileSystem fileSystem);
    public static string Resolve();
    private static string GetDefaultDotNetReferenceAssembliesPath(IFileSystem fileSystem);
}
internal interface Internal.Microsoft.Extensions.DependencyModel.Resolution.ICompilationAssemblyResolver {
    public abstract virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
}
internal class Internal.Microsoft.Extensions.DependencyModel.Resolution.PackageCompilationAssemblyResolver : object {
    private IFileSystem _fileSystem;
    private String[] _nugetPackageDirectories;
    public PackageCompilationAssemblyResolver(string nugetPackageDirectory);
    internal PackageCompilationAssemblyResolver(IEnvironment environment, IFileSystem fileSystem);
    internal PackageCompilationAssemblyResolver(IFileSystem fileSystem, String[] nugetPackageDirectories);
    private static String[] GetDefaultProbeDirectories(IEnvironment environment);
    internal static String[] GetDefaultProbeDirectories(Platform osPlatform, IEnvironment environment);
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
    private static bool TryResolveFromPackagePath(IFileSystem fileSystem, CompilationLibrary library, string basePath, IEnumerable`1& results);
}
internal class Internal.Microsoft.Extensions.DependencyModel.Resolution.ReferenceAssemblyPathResolver : object {
    private IFileSystem _fileSystem;
    private string _defaultReferenceAssembliesPath;
    private String[] _fallbackSearchPaths;
    public ReferenceAssemblyPathResolver(string defaultReferenceAssembliesPath, String[] fallbackSearchPaths);
    internal ReferenceAssemblyPathResolver(IFileSystem fileSystem, IEnvironment environment);
    internal ReferenceAssemblyPathResolver(IFileSystem fileSystem, string defaultReferenceAssembliesPath, String[] fallbackSearchPaths);
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
    private bool TryResolveReferenceAssembly(string path, String& fullPath);
    internal static String[] GetFallbackSearchPaths(IFileSystem fileSystem, Platform platform, IEnvironment environment);
    internal static string GetDefaultReferenceAssembliesPath(IFileSystem fileSystem, Platform platform, IEnvironment environment);
}
internal static class Internal.Microsoft.Extensions.DependencyModel.Resolution.ResolverUtils : object {
    internal static bool TryResolvePackagePath(IFileSystem fileSystem, CompilationLibrary library, string basePath, String& packagePath);
    internal static bool TryResolveAssemblyFile(IFileSystem fileSystem, string basePath, string assemblyPath, String& fullName);
}
internal class Internal.Microsoft.Extensions.DependencyModel.ResourceAssembly : object {
    [CompilerGeneratedAttribute]
private string <Locale>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Locale { get; public set; }
    public string Path { get; public set; }
    public ResourceAssembly(string path, string locale);
    [CompilerGeneratedAttribute]
public string get_Locale();
    [CompilerGeneratedAttribute]
public void set_Locale(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
}
internal class Internal.Microsoft.Extensions.DependencyModel.RuntimeAssembly : object {
    private static string NativeImageSufix;
    private string _assemblyName;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public AssemblyName Name { get; }
    public string Path { get; }
    public RuntimeAssembly(string assemblyName, string path);
    public AssemblyName get_Name();
    [CompilerGeneratedAttribute]
public string get_Path();
    public static RuntimeAssembly Create(string path);
}
internal class Internal.Microsoft.Extensions.DependencyModel.RuntimeAssetGroup : object {
    [CompilerGeneratedAttribute]
private string <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <AssetPaths>k__BackingField;
    public string Runtime { get; }
    public IReadOnlyList`1<string> AssetPaths { get; }
    public RuntimeAssetGroup(string runtime, String[] assetPaths);
    public RuntimeAssetGroup(string runtime, IEnumerable`1<string> assetPaths);
    [CompilerGeneratedAttribute]
public string get_Runtime();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_AssetPaths();
}
internal class Internal.Microsoft.Extensions.DependencyModel.RuntimeFallbacks : object {
    [CompilerGeneratedAttribute]
private string <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <Fallbacks>k__BackingField;
    public string Runtime { get; public set; }
    public IReadOnlyList`1<string> Fallbacks { get; public set; }
    public RuntimeFallbacks(string runtime, String[] fallbacks);
    public RuntimeFallbacks(string runtime, IEnumerable`1<string> fallbacks);
    [CompilerGeneratedAttribute]
public string get_Runtime();
    [CompilerGeneratedAttribute]
public void set_Runtime(string value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_Fallbacks();
    [CompilerGeneratedAttribute]
public void set_Fallbacks(IReadOnlyList`1<string> value);
}
internal class Internal.Microsoft.Extensions.DependencyModel.RuntimeLibrary : Library {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RuntimeAssetGroup> <RuntimeAssemblyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<RuntimeAssetGroup> <NativeLibraryGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ResourceAssembly> <ResourceAssemblies>k__BackingField;
    public IReadOnlyList`1<RuntimeAssetGroup> RuntimeAssemblyGroups { get; }
    public IReadOnlyList`1<RuntimeAssetGroup> NativeLibraryGroups { get; }
    public IReadOnlyList`1<ResourceAssembly> ResourceAssemblies { get; }
    public RuntimeLibrary(string type, string name, string version, string hash, IReadOnlyList`1<RuntimeAssetGroup> runtimeAssemblyGroups, IReadOnlyList`1<RuntimeAssetGroup> nativeLibraryGroups, IEnumerable`1<ResourceAssembly> resourceAssemblies, IEnumerable`1<Dependency> dependencies, bool serviceable);
    public RuntimeLibrary(string type, string name, string version, string hash, IReadOnlyList`1<RuntimeAssetGroup> runtimeAssemblyGroups, IReadOnlyList`1<RuntimeAssetGroup> nativeLibraryGroups, IEnumerable`1<ResourceAssembly> resourceAssemblies, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath);
    public RuntimeLibrary(string type, string name, string version, string hash, IReadOnlyList`1<RuntimeAssetGroup> runtimeAssemblyGroups, IReadOnlyList`1<RuntimeAssetGroup> nativeLibraryGroups, IEnumerable`1<ResourceAssembly> resourceAssemblies, IEnumerable`1<Dependency> dependencies, bool serviceable, string path, string hashPath, string runtimeStoreManifestName);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RuntimeAssetGroup> get_RuntimeAssemblyGroups();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<RuntimeAssetGroup> get_NativeLibraryGroups();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ResourceAssembly> get_ResourceAssemblies();
}
internal class Internal.Microsoft.Extensions.DependencyModel.TargetInfo : object {
    [CompilerGeneratedAttribute]
private string <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPortable>k__BackingField;
    public string Framework { get; }
    public string Runtime { get; }
    public string RuntimeSignature { get; }
    public bool IsPortable { get; }
    public TargetInfo(string framework, string runtime, string runtimeSignature, bool isPortable);
    [CompilerGeneratedAttribute]
public string get_Framework();
    [CompilerGeneratedAttribute]
public string get_Runtime();
    [CompilerGeneratedAttribute]
public string get_RuntimeSignature();
    [CompilerGeneratedAttribute]
public bool get_IsPortable();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[ExtensionAttribute]
internal static class System.Collections.Generic.CollectionExtensions : object {
    [ExtensionAttribute]
public static RuntimeAssetGroup GetDefaultGroup(IEnumerable`1<RuntimeAssetGroup> self);
    [ExtensionAttribute]
public static RuntimeAssetGroup GetRuntimeGroup(IEnumerable`1<RuntimeAssetGroup> self, string runtime);
    private static RuntimeAssetGroup GetGroup(IEnumerable`1<RuntimeAssetGroup> groups, string runtime);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetDefaultAssets(IEnumerable`1<RuntimeAssetGroup> self);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetRuntimeAssets(IEnumerable`1<RuntimeAssetGroup> self, string runtime);
    private static IEnumerable`1<string> GetAssets(IEnumerable`1<RuntimeAssetGroup> groups, string runtime);
}
[AttributeUsageAttribute("749")]
internal class System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[GeneratedCodeAttribute("Nerdbank.GitVersioning.Tasks", "3.6.143.54359")]
[ExcludeFromCodeCoverageAttribute]
internal static class ThisAssembly : object {
    internal static string AssemblyConfiguration;
    internal static string AssemblyFileVersion;
    internal static string AssemblyInformationalVersion;
    internal static string AssemblyName;
    internal static string AssemblyTitle;
    internal static string AssemblyVersion;
    internal static DateTime GitCommitDate;
    internal static string GitCommitId;
    internal static bool IsPrerelease;
    internal static bool IsPublicRelease;
    internal static string PublicKey;
    internal static string PublicKeyToken;
    internal static string RootNamespace;
    private static ThisAssembly();
}
internal class Xunit._DiagnosticMessage : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; public set; }
    public _DiagnosticMessage(string message);
    public _DiagnosticMessage(string format, Object[] args);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
}
internal class Xunit.AssemblyHelper : AssemblyLoadContext {
    private DependencyContextAssemblyCache assemblyCache;
    private IMessageSink internalDiagnosticsMessageSink;
    public AssemblyHelper(string assemblyFileName, IMessageSink internalDiagnosticsMessageSink);
    public sealed virtual void Dispose();
    protected virtual Assembly Load(AssemblyName assemblyName);
    protected virtual IntPtr LoadUnmanagedDll(string unmanagedDllName);
    private Assembly OnResolving(AssemblyLoadContext context, AssemblyName name);
    public static IDisposable SubscribeResolveForAssembly(string assemblyFileName, IMessageSink internalDiagnosticsMessageSink);
    public static IDisposable SubscribeResolveForAssembly(Type typeInAssembly, IMessageSink internalDiagnosticsMessageSink);
    [CompilerGeneratedAttribute]
private IntPtr <LoadUnmanagedDll>b__5_0(string path);
    [CompilerGeneratedAttribute]
private Assembly <OnResolving>b__6_0(string path);
}
public class Xunit.ConsoleClient.CommandLine : object {
    private Stack`1<string> arguments;
    private List`1<string> unknownOptions;
    [CompilerGeneratedAttribute]
private Nullable`1<AppDomainSupport> <AppDomains>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Debug>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DiagnosticMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InternalDiagnosticMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FailSkips>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxParallelThreads>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoAutoReporters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoColor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoLogo>k__BackingField;
    [CompilerGeneratedAttribute]
private XunitProject <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ParallelAlgorithm> <ParallelAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ParallelizeAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ParallelizeTestCollections>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serialize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowLiveOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StopOnFail>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseAnsiColor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Wait>k__BackingField;
    public Nullable`1<AppDomainSupport> AppDomains { get; protected set; }
    public bool Debug { get; protected set; }
    public bool DiagnosticMessages { get; protected set; }
    public bool InternalDiagnosticMessages { get; protected set; }
    public bool FailSkips { get; protected set; }
    public Nullable`1<int> MaxParallelThreads { get; public set; }
    public bool NoAutoReporters { get; protected set; }
    public bool NoColor { get; protected set; }
    public bool NoLogo { get; protected set; }
    public XunitProject Project { get; protected set; }
    public Nullable`1<ParallelAlgorithm> ParallelAlgorithm { get; protected set; }
    public Nullable`1<bool> ParallelizeAssemblies { get; protected set; }
    public Nullable`1<bool> ParallelizeTestCollections { get; public set; }
    public bool Serialize { get; protected set; }
    public bool ShowLiveOutput { get; protected set; }
    public bool StopOnFail { get; protected set; }
    public bool UseAnsiColor { get; protected set; }
    public bool Wait { get; protected set; }
    protected CommandLine(String[] args, Predicate`1<string> fileExists);
    [CompilerGeneratedAttribute]
public Nullable`1<AppDomainSupport> get_AppDomains();
    [CompilerGeneratedAttribute]
protected void set_AppDomains(Nullable`1<AppDomainSupport> value);
    [CompilerGeneratedAttribute]
public bool get_Debug();
    [CompilerGeneratedAttribute]
protected void set_Debug(bool value);
    [CompilerGeneratedAttribute]
public bool get_DiagnosticMessages();
    [CompilerGeneratedAttribute]
protected void set_DiagnosticMessages(bool value);
    [CompilerGeneratedAttribute]
public bool get_InternalDiagnosticMessages();
    [CompilerGeneratedAttribute]
protected void set_InternalDiagnosticMessages(bool value);
    [CompilerGeneratedAttribute]
public bool get_FailSkips();
    [CompilerGeneratedAttribute]
protected void set_FailSkips(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxParallelThreads();
    [CompilerGeneratedAttribute]
public void set_MaxParallelThreads(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_NoAutoReporters();
    [CompilerGeneratedAttribute]
protected void set_NoAutoReporters(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoColor();
    [CompilerGeneratedAttribute]
protected void set_NoColor(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoLogo();
    [CompilerGeneratedAttribute]
protected void set_NoLogo(bool value);
    [CompilerGeneratedAttribute]
public XunitProject get_Project();
    [CompilerGeneratedAttribute]
protected void set_Project(XunitProject value);
    [CompilerGeneratedAttribute]
public Nullable`1<ParallelAlgorithm> get_ParallelAlgorithm();
    [CompilerGeneratedAttribute]
protected void set_ParallelAlgorithm(Nullable`1<ParallelAlgorithm> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ParallelizeAssemblies();
    [CompilerGeneratedAttribute]
protected void set_ParallelizeAssemblies(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_ParallelizeTestCollections();
    [CompilerGeneratedAttribute]
public void set_ParallelizeTestCollections(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_Serialize();
    [CompilerGeneratedAttribute]
protected void set_Serialize(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowLiveOutput();
    [CompilerGeneratedAttribute]
protected void set_ShowLiveOutput(bool value);
    [CompilerGeneratedAttribute]
public bool get_StopOnFail();
    [CompilerGeneratedAttribute]
protected void set_StopOnFail(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseAnsiColor();
    [CompilerGeneratedAttribute]
protected void set_UseAnsiColor(bool value);
    [CompilerGeneratedAttribute]
public bool get_Wait();
    [CompilerGeneratedAttribute]
protected void set_Wait(bool value);
    public IRunnerReporter ChooseReporter(IReadOnlyList`1<IRunnerReporter> reporters);
    protected virtual string GetFullPath(string fileName);
    private XunitProject GetProjectFile(List`1<Tuple`2<string, string>> assemblies);
    private static void GuardNoOptionValue(KeyValuePair`2<string, string> option);
    private static bool IsConfigFile(string fileName);
    public static CommandLine Parse(String[] args);
    protected XunitProject Parse(Predicate`1<string> fileExists);
    private static KeyValuePair`2<string, string> PopOption(Stack`1<string> arguments);
    private static void EnsurePathExists(string path);
}
public class Xunit.ConsoleClient.ConsoleLogger : object {
    public virtual void WriteLine(string format, Object[] arg);
}
internal class Xunit.ConsoleClient.ConsoleRunner : object {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) cancel;
    private CommandLine commandLine;
    private object consoleLock;
    private ConcurrentDictionary`2<string, ExecutionSummary> completionMessages;
    private bool failed;
    private IRunnerLogger logger;
    private IMessageSinkWithTypes reporterMessageHandler;
    public ConsoleRunner(object consoleLock);
    public int EntryPoint(String[] args);
    private List`1<IRunnerReporter> GetAvailableRunnerReporters();
    private void PrintHeader();
    private void PrintUsage(IReadOnlyList`1<IRunnerReporter> reporters);
    private int RunProject(XunitProject project, bool serialize, Nullable`1<bool> parallelizeAssemblies, Nullable`1<bool> parallelizeTestCollections, Nullable`1<int> maxThreadCount, bool diagnosticMessages, bool noColor, Nullable`1<AppDomainSupport> appDomains, bool failSkips, bool stopOnFail, bool internalDiagnosticMessages, Nullable`1<ParallelAlgorithm> parallelAlgorithm, bool showLiveOutput);
    private XElement ExecuteAssembly(object consoleLock, XunitProjectAssembly assembly, bool serialize, bool needsXml, Nullable`1<bool> parallelizeTestCollections, Nullable`1<int> maxThreadCount, bool diagnosticMessages, bool noColor, Nullable`1<AppDomainSupport> appDomains, bool failSkips, bool stopOnFail, XunitFilters filters, bool internalDiagnosticMessages, Nullable`1<ParallelAlgorithm> parallelAlgorithm, bool showLiveOutput);
    private bool ValidateFileExists(object consoleLock, string fileName);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <EntryPoint>b__8_0(object sender, ConsoleCancelEventArgs e);
    [CompilerGeneratedAttribute]
private bool <ExecuteAssembly>b__13_0();
    [CompilerGeneratedAttribute]
private bool <ExecuteAssembly>b__13_1();
}
public class Xunit.ConsoleClient.DiagnosticMessageSink : MarshalByRefObject {
    private string assemblyDisplayName;
    private object consoleLock;
    private ConsoleColor displayColor;
    private bool noColor;
    private bool showDiagnostics;
    private DiagnosticMessageSink(object consoleLock, string assemblyDisplayName, bool showDiagnostics, bool noColor, ConsoleColor displayColor);
    public static DiagnosticMessageSink ForDiagnostics(object consoleLock, string assemblyDisplayName, bool showDiagnostics, bool noColor);
    public static DiagnosticMessageSink ForInternalDiagnostics(object consoleLock, bool showDiagnostics, bool noColor);
    public static DiagnosticMessageSink ForInternalDiagnostics(object consoleLock, string assemblyDisplayName, bool showDiagnostics, bool noColor);
    public sealed virtual bool OnMessage(IMessageSinkMessage message);
}
public enum Xunit.ConsoleClient.ParallelismOption : Enum {
    public int value__;
    public static ParallelismOption none;
    public static ParallelismOption collections;
    public static ParallelismOption assemblies;
    public static ParallelismOption all;
}
public class Xunit.ConsoleClient.Program : object {
    [STAThreadAttribute]
public static int Main(String[] args);
}
public class Xunit.ConsoleClient.Transform : object {
    public string CommandLine;
    public string Description;
    public Action`2<XElement, string> OutputHandler;
}
public class Xunit.ConsoleClient.TransformFactory : object {
    private static TransformFactory instance;
    private Dictionary`2<string, Transform> availableTransforms;
    public static bool NoErrorColoring;
    public static List`1<Transform> AvailableTransforms { get; }
    private static TransformFactory();
    public static List`1<Transform> get_AvailableTransforms();
    public static List`1<Action`1<XElement>> GetXmlTransformers(XunitProject project);
    private static void Handler_DirectWrite(XElement xml, string outputFileName);
    private static void Handler_XslTransform(string key, string resourceName, XElement xml, string outputFileName);
}
internal static class Xunit.ConsoleHelper : object {
    internal static Action ResetColor;
    internal static Action`1<ConsoleColor> SetForegroundColor;
    private static ConsoleHelper();
    private static void SetForegroundColorANSI(ConsoleColor c);
    private static void SetForegroundColorConsole(ConsoleColor c);
    private static void ResetColorANSI();
    private static void ResetColorConsole();
    internal static void UseAnsiColor();
}
internal class Xunit.DependencyContextAssemblyCache : object {
    private static RuntimeFallbacks AnyAndBase;
    private static String[] ManagedAssemblyExtensions;
    private static Tuple`2<string, Assembly> ManagedAssemblyNotFound;
    private static Regex RuntimeIdRegex;
    private string assemblyFolder;
    private XunitPackageCompilationAssemblyResolver assemblyResolver;
    private string currentRuntimeIdentifier;
    private DependencyContext dependencyContext;
    private Lazy`1<string> fallbackRuntimeIdentifier;
    private IFileSystem fileSystem;
    private IMessageSink internalDiagnosticsMessageSink;
    private Dictionary`2<string, Assembly> managedAssemblyCache;
    private Dictionary`2<string, Tuple`2<RuntimeLibrary, RuntimeAssetGroup>> managedAssemblyMap;
    private Platform operatingSystemPlatform;
    private String[] unmanagedDllFormats;
    private Dictionary`2<string, string> unmanagedAssemblyCache;
    private Dictionary`2<string, Tuple`2<RuntimeLibrary, RuntimeAssetGroup>> unmanagedAssemblyMap;
    public DependencyContextAssemblyCache(string assemblyFolder, DependencyContext dependencyContext, IMessageSink internalDiagnosticsMessageSink, Nullable`1<Platform> operatingSystemPlatform, string currentRuntimeIdentifier, IFileSystem fileSystem);
    private static DependencyContextAssemblyCache();
    private List`1<string> GetCompatibleRuntimes(DependencyContext dependencyContext);
    private RuntimeFallbacks GetFallbacks(IReadOnlyList`1<RuntimeFallbacks> runtimeGraph);
    private string GetFallbackRuntime(string runtime);
    [IteratorStateMachineAttribute("Xunit.DependencyContextAssemblyCache/<GetUnmanagedDllFormats>d__21")]
private IEnumerable`1<string> GetUnmanagedDllFormats();
    public Assembly LoadManagedDll(string assemblyName, Func`2<string, Assembly> managedAssemblyLoader);
    public IntPtr LoadUnmanagedLibrary(string unmanagedLibraryName, Func`2<string, IntPtr> unmanagedAssemblyLoader);
    private Tuple`2<string, Assembly> ResolveManagedAssembly(string assemblyName, Func`2<string, Assembly> managedAssemblyLoader);
    public string ResolveUnmanagedLibrary(string unmanagedLibraryName);
    [CompilerGeneratedAttribute]
private string <.ctor>b__17_0();
    [CompilerGeneratedAttribute]
private bool <GetFallbacks>b__19_0(RuntimeFallbacks x);
    [CompilerGeneratedAttribute]
private bool <GetFallbacks>b__19_1(RuntimeFallbacks x);
}
[DefaultMemberAttribute("Item")]
internal class Xunit.JsonArray : JsonValue {
    private JsonValue[] _array;
    public int Length { get; }
    public JsonValue Item { get; }
    public JsonArray(JsonValue[] array, int line, int column);
    public int get_Length();
    public JsonValue get_Item(int index);
}
internal class Xunit.JsonBoolean : JsonValue {
    [CompilerGeneratedAttribute]
private bool <Value>k__BackingField;
    public bool Value { get; private set; }
    public JsonBoolean(JsonToken token);
    [CompilerGeneratedAttribute]
public bool get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(bool value);
    public static bool op_Implicit(JsonBoolean jsonBoolean);
}
internal class Xunit.JsonBuffer : object {
    public static string ValueNull;
    public static string ValueTrue;
    public static string ValueFalse;
    private StringBuilder _buffer;
    private StringBuilder _codePointBuffer;
    private TextReader _reader;
    private JsonToken _token;
    private int _line;
    private int _column;
    public JsonBuffer(TextReader reader);
    public JsonToken Read();
    private int ReadNextChar();
    private string ReadNumber(int firstRead);
    private void ReadLiteral(string literal);
    private string ReadString();
    private static bool IsWhitespace(int value);
}
internal static class Xunit.JsonDeserializer : object {
    public static JsonValue Deserialize(TextReader reader);
    private static JsonValue DeserializeInternal(JsonToken next, JsonBuffer buffer);
    private static JsonArray DeserializeArray(JsonToken head, JsonBuffer buffer);
    private static JsonObject DeserializeObject(JsonToken head, JsonBuffer buffer);
}
internal class Xunit.JsonDeserializerException : Exception {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public int Line { get; }
    public int Column { get; }
    public JsonDeserializerException(string message, Exception innerException, int line, int column);
    public JsonDeserializerException(string message, int line, int column);
    public JsonDeserializerException(string message, JsonToken nextToken);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public int get_Column();
}
internal static class Xunit.JsonDeserializerResource : object {
    internal static string JSON_OpenString { get; }
    internal static string JSON_InvalidEnd { get; }
    internal static string Format_IllegalCharacter(int value);
    internal static string Format_IllegalTrailingCharacterAfterLiteral(int value, string literal);
    internal static string Format_UnrecognizedLiteral(string literal);
    internal static string Format_DuplicateObjectMemberName(string memberName);
    internal static string Format_InvalidFloatNumberFormat(string raw);
    internal static string Format_FloatNumberOverflow(string raw);
    internal static string Format_InvalidSyntax(string syntaxName, string issue);
    internal static string Format_InvalidSyntaxNotExpected(string syntaxName, char unexpected);
    internal static string Format_InvalidSyntaxNotExpected(string syntaxName, string unexpected);
    internal static string Format_InvalidSyntaxExpectation(string syntaxName, char expectation);
    internal static string Format_InvalidSyntaxExpectation(string syntaxName, string expectation);
    internal static string Format_InvalidSyntaxExpectation(string syntaxName, char expectation1, char expectation2);
    internal static string Format_InvalidTokenExpectation(string tokenValue, string expectation);
    internal static string Format_InvalidUnicode(string unicode);
    internal static string Format_UnfinishedJSON(string nextTokenValue);
    internal static string get_JSON_OpenString();
    internal static string get_JSON_InvalidEnd();
}
internal class Xunit.JsonNull : JsonValue {
    public JsonNull(int line, int column);
}
internal class Xunit.JsonNumber : JsonValue {
    private string _raw;
    private double _double;
    public double Double { get; }
    public string Raw { get; }
    public JsonNumber(JsonToken token);
    public double get_Double();
    public string get_Raw();
}
internal class Xunit.JsonObject : JsonValue {
    private IDictionary`2<string, JsonValue> _data;
    public ICollection`1<string> Keys { get; }
    public JsonObject(IDictionary`2<string, JsonValue> data, int line, int column);
    public ICollection`1<string> get_Keys();
    public JsonValue Value(string key);
    public JsonObject ValueAsJsonObject(string key);
    public JsonString ValueAsString(string key);
    public int ValueAsInt(string key);
    public bool ValueAsBoolean(string key, bool defaultValue);
    public Nullable`1<bool> ValueAsNullableBoolean(string key);
    public String[] ValueAsStringArray(string key);
}
internal class Xunit.JsonString : JsonValue {
    private string _value;
    public string Value { get; }
    public JsonString(string value, int line, int column);
    public string get_Value();
    public virtual string ToString();
    public static string op_Implicit(JsonString instance);
}
internal class Xunit.JsonToken : ValueType {
    public JsonTokenType Type;
    public string Value;
    public int Line;
    public int Column;
}
internal enum Xunit.JsonTokenType : Enum {
    public int value__;
    public static JsonTokenType LeftCurlyBracket;
    public static JsonTokenType LeftSquareBracket;
    public static JsonTokenType RightCurlyBracket;
    public static JsonTokenType RightSquareBracket;
    public static JsonTokenType Colon;
    public static JsonTokenType Comma;
    public static JsonTokenType Null;
    public static JsonTokenType True;
    public static JsonTokenType False;
    public static JsonTokenType Number;
    public static JsonTokenType String;
    public static JsonTokenType EOF;
}
internal class Xunit.JsonValue : object {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public int Line { get; }
    public int Column { get; }
    public JsonValue(int line, int column);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public int get_Column();
}
internal class Xunit.XunitPackageCompilationAssemblyResolver : object {
    private IFileSystem fileSystem;
    private List`1<string> nugetPackageDirectories;
    public XunitPackageCompilationAssemblyResolver(IMessageSink internalDiagnosticsMessageSink, IFileSystem fileSystem);
    private static List`1<string> GetDefaultProbeDirectories(IMessageSink internalDiagnosticsMessageSink);
    private static List`1<string> GetDefaultProbeDirectories(Platform osPlatform, IMessageSink internalDiagnosticsMessageSink);
    public sealed virtual bool TryResolveAssemblyPaths(CompilationLibrary library, List`1<string> assemblies);
    private bool TryResolveFromPackagePath(CompilationLibrary library, string basePath, IEnumerable`1& results);
}
