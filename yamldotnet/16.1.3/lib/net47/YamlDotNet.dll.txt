[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
[ExcludeFromCodeCoverageAttribute]
[DebuggerNonUserCodeAttribute]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class YamlDotNet.Core.AnchorName : ValueType {
    public static AnchorName Empty;
    private static Regex AnchorPattern;
    [NullableAttribute("2")]
private string value;
    public string Value { get; }
    public bool IsEmpty { get; }
    public AnchorName(string value);
    private static AnchorName();
    public string get_Value();
    public bool get_IsEmpty();
    public virtual string ToString();
    public sealed virtual bool Equals(AnchorName other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AnchorName left, AnchorName right);
    public static bool op_Inequality(AnchorName left, AnchorName right);
    [NullableContextAttribute("2")]
public static AnchorName op_Implicit(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.AnchorNotFoundException : YamlException {
    public AnchorNotFoundException(string message);
    public AnchorNotFoundException(Mark& start, Mark& end, string message);
    public AnchorNotFoundException(string message, Exception inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerStepThroughAttribute]
internal class YamlDotNet.Core.CharacterAnalyzer`1 : ValueType {
    [CompilerGeneratedAttribute]
private TBuffer <Buffer>k__BackingField;
    public TBuffer Buffer { get; }
    public bool EndOfInput { get; }
    public CharacterAnalyzer`1(TBuffer buffer);
    [CompilerGeneratedAttribute]
public TBuffer get_Buffer();
    public bool get_EndOfInput();
    public char Peek(int offset);
    public void Skip(int length);
    public bool IsAlphaNumericDashOrUnderscore(int offset);
    public bool IsAscii(int offset);
    public bool IsPrintable(int offset);
    public bool IsDigit(int offset);
    public int AsDigit(int offset);
    public bool IsHex(int offset);
    public int AsHex(int offset);
    public bool IsSpace(int offset);
    public bool IsZero(int offset);
    public bool IsTab(int offset);
    public bool IsWhite(int offset);
    public bool IsBreak(int offset);
    public bool IsCrLf(int offset);
    public bool IsBreakOrZero(int offset);
    public bool IsWhiteBreakOrZero(int offset);
    public bool Check(char expected, int offset);
    public bool Check(string expectedCharacters, int offset);
}
public static class YamlDotNet.Core.Constants : object {
    [NullableAttribute("1")]
public static TagDirective[] DefaultTagDirectives;
    public static int MajorVersion;
    public static int MinorVersion;
    private static Constants();
}
[DebuggerStepThroughAttribute]
public class YamlDotNet.Core.Cursor : object {
    [CompilerGeneratedAttribute]
private long <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private long <LineOffset>k__BackingField;
    public long Index { get; private set; }
    public long Line { get; private set; }
    public long LineOffset { get; private set; }
    [NullableContextAttribute("1")]
public Cursor(Cursor cursor);
    [CompilerGeneratedAttribute]
public long get_Index();
    [CompilerGeneratedAttribute]
private void set_Index(long value);
    [CompilerGeneratedAttribute]
public long get_Line();
    [CompilerGeneratedAttribute]
private void set_Line(long value);
    [CompilerGeneratedAttribute]
public long get_LineOffset();
    [CompilerGeneratedAttribute]
private void set_LineOffset(long value);
    public Mark Mark();
    public void Skip();
    public void SkipLineByOffset(int offset);
    public void ForceSkipLineAfterNonBreak();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Emitter : object {
    private static Regex UriReplacer;
    private static String[] NewLineSeparators;
    private TextWriter output;
    private bool outputUsesUnicodeEncoding;
    private int maxSimpleKeyLength;
    private bool isCanonical;
    private bool skipAnchorName;
    private int bestIndent;
    private int bestWidth;
    private EmitterState state;
    private Stack`1<EmitterState> states;
    private Queue`1<ParsingEvent> events;
    private Stack`1<int> indents;
    private TagDirectiveCollection tagDirectives;
    private int indent;
    private int flowLevel;
    private bool isMappingContext;
    private bool isSimpleKeyContext;
    private int column;
    private bool isWhitespace;
    private bool isIndentation;
    private bool forceIndentLess;
    private string newLine;
    private bool isDocumentEndWritten;
    private AnchorData anchorData;
    private TagData tagData;
    private ScalarData scalarData;
    public Emitter(TextWriter output);
    public Emitter(TextWriter output, int bestIndent);
    public Emitter(TextWriter output, int bestIndent, int bestWidth);
    public Emitter(TextWriter output, int bestIndent, int bestWidth, bool isCanonical);
    public Emitter(TextWriter output, EmitterSettings settings);
    private static Emitter();
    public sealed virtual void Emit(ParsingEvent event);
    private bool NeedMoreEvents();
    private void AnalyzeEvent(ParsingEvent evt);
    private void AnalyzeAnchor(AnchorName anchor, bool isAlias);
    private void AnalyzeScalar(Scalar scalar);
    private bool ValueIsRepresentableInOutputEncoding(string value);
    private static bool IsUnicode(Encoding encoding);
    private void AnalyzeTag(TagName tag);
    private void StateMachine(ParsingEvent evt);
    private void EmitComment(Comment comment);
    private void EmitStreamStart(ParsingEvent evt);
    private void EmitDocumentStart(ParsingEvent evt, bool isFirst);
    private static TagDirectiveCollection NonDefaultTagsAmong(IEnumerable`1<TagDirective> tagCollection);
    private static void AnalyzeVersionDirective(VersionDirective versionDirective);
    private static void AppendTagDirectiveTo(TagDirective value, bool allowDuplicates, TagDirectiveCollection tagDirectives);
    private void EmitDocumentContent(ParsingEvent evt);
    private void EmitNode(ParsingEvent evt, bool isMapping, bool isSimpleKey);
    private void EmitAlias();
    private void EmitScalar(ParsingEvent evt);
    private void SelectScalarStyle(ParsingEvent evt);
    private void ProcessScalar();
    private void WritePlainScalar(string value, bool allowBreaks);
    private void WriteSingleQuotedScalar(string value, bool allowBreaks);
    private void WriteDoubleQuotedScalar(string value, bool allowBreaks);
    private void WriteLiteralScalar(string value);
    private void WriteFoldedScalar(string value);
    private static bool IsSpace(char character);
    private static bool IsBreak(char character, Char& breakChar);
    private static bool IsBlank(char character);
    private static bool IsPrintable(char character);
    private static bool IsHighSurrogate(char c);
    private static bool IsLowSurrogate(char c);
    private void EmitSequenceStart(ParsingEvent evt);
    private void EmitMappingStart(ParsingEvent evt);
    private void ProcessAnchor();
    private void ProcessTag();
    private void EmitDocumentEnd(ParsingEvent evt);
    private void EmitFlowSequenceItem(ParsingEvent evt, bool isFirst);
    private void EmitFlowMappingKey(ParsingEvent evt, bool isFirst);
    private void EmitFlowMappingValue(ParsingEvent evt, bool isSimple);
    private void EmitBlockSequenceItem(ParsingEvent evt, bool isFirst);
    private void EmitBlockMappingKey(ParsingEvent evt, bool isFirst);
    private void EmitBlockMappingValue(ParsingEvent evt, bool isSimple);
    private void IncreaseIndent(bool isFlow, bool isIndentless);
    private bool CheckEmptyDocument();
    private bool CheckSimpleKey();
    private static int AnchorNameLength(AnchorName value);
    [NullableContextAttribute("2")]
private static int SafeStringLength(string value);
    private bool CheckEmptySequence();
    private bool CheckEmptyMapping();
    [NullableContextAttribute("0")]
private bool CheckEmptyStructure();
    private void WriteBlockScalarHints(string value);
    private void WriteIndicator(string indicator, bool needWhitespace, bool whitespace, bool indentation);
    private void WriteIndent();
    private void WriteAnchor(AnchorName value);
    private void WriteTagHandle(string value);
    private void WriteTagContent(string value, bool needsWhitespace);
    private static string UrlEncode(string text);
    private void Write(char value);
    private void Write(string value);
    private void WriteBreak(char breakCharacter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.EmitterSettings : object {
    [CompilerGeneratedAttribute]
private int <BestIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BestWidth>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCanonical>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipAnchorName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxSimpleKeyLength>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IndentSequences>k__BackingField;
    public static EmitterSettings Default;
    public int BestIndent { get; }
    public int BestWidth { get; }
    public string NewLine { get; }
    public bool IsCanonical { get; }
    public bool SkipAnchorName { get; private set; }
    public int MaxSimpleKeyLength { get; }
    public bool IndentSequences { get; }
    [NullableContextAttribute("2")]
public EmitterSettings(int bestIndent, int bestWidth, bool isCanonical, int maxSimpleKeyLength, bool skipAnchorName, bool indentSequences, string newLine);
    private static EmitterSettings();
    [CompilerGeneratedAttribute]
public int get_BestIndent();
    [CompilerGeneratedAttribute]
public int get_BestWidth();
    [CompilerGeneratedAttribute]
public string get_NewLine();
    [CompilerGeneratedAttribute]
public bool get_IsCanonical();
    [CompilerGeneratedAttribute]
public bool get_SkipAnchorName();
    [CompilerGeneratedAttribute]
private void set_SkipAnchorName(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxSimpleKeyLength();
    [CompilerGeneratedAttribute]
public bool get_IndentSequences();
    public EmitterSettings WithBestIndent(int bestIndent);
    public EmitterSettings WithBestWidth(int bestWidth);
    public EmitterSettings WithMaxSimpleKeyLength(int maxSimpleKeyLength);
    public EmitterSettings WithNewLine(string newLine);
    public EmitterSettings Canonical();
    public EmitterSettings WithoutAnchorName();
    public EmitterSettings WithIndentedSequences();
}
internal enum YamlDotNet.Core.EmitterState : Enum {
    public int value__;
    public static EmitterState StreamStart;
    public static EmitterState StreamEnd;
    public static EmitterState FirstDocumentStart;
    public static EmitterState DocumentStart;
    public static EmitterState DocumentContent;
    public static EmitterState DocumentEnd;
    public static EmitterState FlowSequenceFirstItem;
    public static EmitterState FlowSequenceItem;
    public static EmitterState FlowMappingFirstKey;
    public static EmitterState FlowMappingKey;
    public static EmitterState FlowMappingSimpleValue;
    public static EmitterState FlowMappingValue;
    public static EmitterState BlockSequenceFirstItem;
    public static EmitterState BlockSequenceItem;
    public static EmitterState BlockMappingFirstKey;
    public static EmitterState BlockMappingKey;
    public static EmitterState BlockMappingSimpleValue;
    public static EmitterState BlockMappingValue;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Events.AnchorAlias : ParsingEvent {
    [CompilerGeneratedAttribute]
private AnchorName <Value>k__BackingField;
    internal EventType Type { get; }
    public AnchorName Value { get; }
    public AnchorAlias(AnchorName value, Mark start, Mark end);
    public AnchorAlias(AnchorName value);
    internal virtual EventType get_Type();
    [CompilerGeneratedAttribute]
public AnchorName get_Value();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Events.Comment : ParsingEvent {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInline>k__BackingField;
    public string Value { get; }
    public bool IsInline { get; }
    internal EventType Type { get; }
    public Comment(string value, bool isInline);
    public Comment(string value, bool isInline, Mark start, Mark end);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public bool get_IsInline();
    internal virtual EventType get_Type();
    public virtual void Accept(IParsingEventVisitor visitor);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Events.DocumentEnd : ParsingEvent {
    [CompilerGeneratedAttribute]
private bool <IsImplicit>k__BackingField;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public bool IsImplicit { get; }
    public DocumentEnd(bool isImplicit, Mark start, Mark end);
    public DocumentEnd(bool isImplicit);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    [CompilerGeneratedAttribute]
public bool get_IsImplicit();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Events.DocumentStart : ParsingEvent {
    [CompilerGeneratedAttribute]
private TagDirectiveCollection <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionDirective <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsImplicit>k__BackingField;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public TagDirectiveCollection Tags { get; }
    public VersionDirective Version { get; }
    public bool IsImplicit { get; }
    public DocumentStart(VersionDirective version, TagDirectiveCollection tags, bool isImplicit, Mark start, Mark end);
    public DocumentStart(VersionDirective version, TagDirectiveCollection tags, bool isImplicit);
    public DocumentStart(Mark& start, Mark& end);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    [CompilerGeneratedAttribute]
public TagDirectiveCollection get_Tags();
    [CompilerGeneratedAttribute]
public VersionDirective get_Version();
    [CompilerGeneratedAttribute]
public bool get_IsImplicit();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public virtual void Accept(IParsingEventVisitor visitor);
}
internal enum YamlDotNet.Core.Events.EventType : Enum {
    public int value__;
    public static EventType None;
    public static EventType StreamStart;
    public static EventType StreamEnd;
    public static EventType DocumentStart;
    public static EventType DocumentEnd;
    public static EventType Alias;
    public static EventType Scalar;
    public static EventType SequenceStart;
    public static EventType SequenceEnd;
    public static EventType MappingStart;
    public static EventType MappingEnd;
    public static EventType Comment;
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Core.Events.IParsingEventVisitor {
    public abstract virtual void Visit(AnchorAlias e);
    public abstract virtual void Visit(StreamStart e);
    public abstract virtual void Visit(StreamEnd e);
    public abstract virtual void Visit(DocumentStart e);
    public abstract virtual void Visit(DocumentEnd e);
    public abstract virtual void Visit(Scalar e);
    public abstract virtual void Visit(SequenceStart e);
    public abstract virtual void Visit(SequenceEnd e);
    public abstract virtual void Visit(MappingStart e);
    public abstract virtual void Visit(MappingEnd e);
    public abstract virtual void Visit(Comment e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Events.MappingEnd : ParsingEvent {
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public MappingEnd(Mark& start, Mark& end);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Events.MappingStart : NodeEvent {
    [CompilerGeneratedAttribute]
private bool <IsImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private MappingStyle <Style>k__BackingField;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public bool IsImplicit { get; }
    public bool IsCanonical { get; }
    public MappingStyle Style { get; }
    public MappingStart(AnchorName anchor, TagName tag, bool isImplicit, MappingStyle style, Mark start, Mark end);
    public MappingStart(AnchorName anchor, TagName tag, bool isImplicit, MappingStyle style);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    [CompilerGeneratedAttribute]
public bool get_IsImplicit();
    public virtual bool get_IsCanonical();
    [CompilerGeneratedAttribute]
public MappingStyle get_Style();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
public enum YamlDotNet.Core.Events.MappingStyle : Enum {
    public int value__;
    public static MappingStyle Any;
    public static MappingStyle Block;
    public static MappingStyle Flow;
}
public abstract class YamlDotNet.Core.Events.NodeEvent : ParsingEvent {
    [CompilerGeneratedAttribute]
private AnchorName <Anchor>k__BackingField;
    [CompilerGeneratedAttribute]
private TagName <Tag>k__BackingField;
    public AnchorName Anchor { get; }
    public TagName Tag { get; }
    public bool IsCanonical { get; }
    protected NodeEvent(AnchorName anchor, TagName tag, Mark start, Mark end);
    protected NodeEvent(AnchorName anchor, TagName tag);
    [CompilerGeneratedAttribute]
public AnchorName get_Anchor();
    [CompilerGeneratedAttribute]
public TagName get_Tag();
    public abstract virtual bool get_IsCanonical();
}
public abstract class YamlDotNet.Core.Events.ParsingEvent : object {
    [CompilerGeneratedAttribute]
private Mark <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Mark <End>k__BackingField;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public Mark Start { get; }
    public Mark End { get; }
    internal ParsingEvent(Mark& start, Mark& end);
    public virtual int get_NestingIncrease();
    internal abstract virtual EventType get_Type();
    [CompilerGeneratedAttribute]
public Mark get_Start();
    [CompilerGeneratedAttribute]
public Mark get_End();
    [NullableContextAttribute("1")]
public abstract virtual void Accept(IParsingEventVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Events.Scalar : NodeEvent {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ScalarStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPlainImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsQuotedImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsKey>k__BackingField;
    internal EventType Type { get; }
    public string Value { get; }
    public ScalarStyle Style { get; }
    public bool IsPlainImplicit { get; }
    public bool IsQuotedImplicit { get; }
    public bool IsCanonical { get; }
    public bool IsKey { get; }
    public Scalar(AnchorName anchor, TagName tag, string value, ScalarStyle style, bool isPlainImplicit, bool isQuotedImplicit, Mark start, Mark end, bool isKey);
    public Scalar(AnchorName anchor, TagName tag, string value, ScalarStyle style, bool isPlainImplicit, bool isQuotedImplicit);
    public Scalar(string value);
    public Scalar(TagName tag, string value);
    public Scalar(AnchorName anchor, TagName tag, string value);
    internal virtual EventType get_Type();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public ScalarStyle get_Style();
    [CompilerGeneratedAttribute]
public bool get_IsPlainImplicit();
    [CompilerGeneratedAttribute]
public bool get_IsQuotedImplicit();
    public virtual bool get_IsCanonical();
    [CompilerGeneratedAttribute]
public bool get_IsKey();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Events.SequenceEnd : ParsingEvent {
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public SequenceEnd(Mark& start, Mark& end);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Events.SequenceStart : NodeEvent {
    [CompilerGeneratedAttribute]
private bool <IsImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private SequenceStyle <Style>k__BackingField;
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public bool IsImplicit { get; }
    public bool IsCanonical { get; }
    public SequenceStyle Style { get; }
    public SequenceStart(AnchorName anchor, TagName tag, bool isImplicit, SequenceStyle style, Mark start, Mark end);
    public SequenceStart(AnchorName anchor, TagName tag, bool isImplicit, SequenceStyle style);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    [CompilerGeneratedAttribute]
public bool get_IsImplicit();
    public virtual bool get_IsCanonical();
    [CompilerGeneratedAttribute]
public SequenceStyle get_Style();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
public enum YamlDotNet.Core.Events.SequenceStyle : Enum {
    public int value__;
    public static SequenceStyle Any;
    public static SequenceStyle Block;
    public static SequenceStyle Flow;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Events.StreamEnd : ParsingEvent {
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public StreamEnd(Mark& start, Mark& end);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Events.StreamStart : ParsingEvent {
    public int NestingIncrease { get; }
    internal EventType Type { get; }
    public StreamStart(Mark& start, Mark& end);
    public virtual int get_NestingIncrease();
    internal virtual EventType get_Type();
    public virtual string ToString();
    public virtual void Accept(IParsingEventVisitor visitor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.ForwardAnchorNotSupportedException : YamlException {
    public ForwardAnchorNotSupportedException(string message);
    public ForwardAnchorNotSupportedException(Mark& start, Mark& end, string message);
    public ForwardAnchorNotSupportedException(string message, Exception inner);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class YamlDotNet.Core.HashCode : object {
    public static int CombineHashCodes(int h1, int h2);
    public static int CombineHashCodes(int h1, object o2);
    private static int GetHashCode(object obj);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Core.IEmitter {
    public abstract virtual void Emit(ParsingEvent event);
}
internal interface YamlDotNet.Core.ILookAheadBuffer {
    public bool EndOfInput { get; }
    public abstract virtual bool get_EndOfInput();
    public abstract virtual char Peek(int offset);
    public abstract virtual void Skip(int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.InsertionQueue`1 : object {
    private static int DefaultInitialCapacity;
    private T[] items;
    private int readPtr;
    private int writePtr;
    private int mask;
    private int count;
    public int Count { get; }
    public int Capacity { get; }
    public InsertionQueue`1(int initialCapacity);
    public int get_Count();
    public int get_Capacity();
    public void Enqueue(T item);
    public T Dequeue();
    public void Insert(int index, T item);
    private void ResizeIfNeeded();
    internal static void CalculateInsertionParameters(int mask, int count, int index, Int32& readPtr, Int32& writePtr, Int32& insertPtr, Int32& copyIndex, Int32& copyOffset, Int32& copyLength);
    [IteratorStateMachineAttribute("YamlDotNet.Core.InsertionQueue`1/<GetEnumerator>d__16")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("2")]
public interface YamlDotNet.Core.IParser {
    public ParsingEvent Current { get; }
    public abstract virtual ParsingEvent get_Current();
    public abstract virtual bool MoveNext();
}
[NullableContextAttribute("2")]
public interface YamlDotNet.Core.IScanner {
    public Mark CurrentPosition { get; }
    public Token Current { get; }
    public abstract virtual Mark get_CurrentPosition();
    public abstract virtual Token get_Current();
    public abstract virtual bool MoveNext();
    public abstract virtual bool MoveNextWithoutConsuming();
    public abstract virtual void ConsumeCurrent();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
public class YamlDotNet.Core.LookAheadBuffer : object {
    private TextReader input;
    private Char[] buffer;
    private int blockSize;
    private int mask;
    private int firstIndex;
    private int writeOffset;
    private int count;
    private bool endOfInput;
    public bool EndOfInput { get; }
    public LookAheadBuffer(TextReader input, int capacity);
    public sealed virtual bool get_EndOfInput();
    private int GetIndexForOffset(int offset);
    public sealed virtual char Peek(int offset);
    public void Cache(int length);
    private void FillBuffer();
    public sealed virtual void Skip(int length);
}
[IsReadOnlyAttribute]
public class YamlDotNet.Core.Mark : ValueType {
    public static Mark Empty;
    [CompilerGeneratedAttribute]
private long <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Column>k__BackingField;
    public long Index { get; }
    public long Line { get; }
    public long Column { get; }
    public Mark(long index, long line, long column);
    private static Mark();
    [CompilerGeneratedAttribute]
public long get_Index();
    [CompilerGeneratedAttribute]
public long get_Line();
    [CompilerGeneratedAttribute]
public long get_Column();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Mark other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(Mark other);
    public static bool op_Equality(Mark left, Mark right);
    public static bool op_Inequality(Mark left, Mark right);
    public static bool op_LessThan(Mark left, Mark right);
    public static bool op_LessThanOrEqual(Mark left, Mark right);
    public static bool op_GreaterThan(Mark left, Mark right);
    public static bool op_GreaterThanOrEqual(Mark left, Mark right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.MaximumRecursionLevelReachedException : YamlException {
    public MaximumRecursionLevelReachedException(string message);
    public MaximumRecursionLevelReachedException(Mark& start, Mark& end, string message);
    public MaximumRecursionLevelReachedException(string message, Exception inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.MergingParser : object {
    private ParsingEventCollection events;
    private IParser innerParser;
    private IEnumerator`1<LinkedListNode`1<ParsingEvent>> iterator;
    private bool merged;
    [NullableAttribute("2")]
public ParsingEvent Current { get; }
    public MergingParser(IParser innerParser);
    [NullableContextAttribute("2")]
public sealed virtual ParsingEvent get_Current();
    public sealed virtual bool MoveNext();
    private void Merge();
    private bool HandleMerge(LinkedListNode`1<ParsingEvent> node);
    private bool HandleMergeSequence(LinkedListNode`1<ParsingEvent> sequenceStart, LinkedListNode`1<ParsingEvent> node);
    private static bool IsMergeToken(LinkedListNode`1<ParsingEvent> node);
    private bool HandleAnchorAlias(LinkedListNode`1<ParsingEvent> node, LinkedListNode`1<ParsingEvent> anchorNode, AnchorAlias anchorAlias);
    private bool HandleSequence(LinkedListNode`1<ParsingEvent> node);
    private IEnumerable`1<ParsingEvent> GetMappingEvents(AnchorName anchor);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class YamlDotNet.Core.ObjectPool.DefaultObjectPool`1 : ObjectPool`1<T> {
    private Func`1<T> createFunc;
    private Func`2<T, bool> returnFunc;
    private int maxCapacity;
    private int numItems;
    private protected ConcurrentQueue`1<T> items;
    [NullableAttribute("2")]
private protected T fastItem;
    public DefaultObjectPool`1(IPooledObjectPolicy`1<T> policy);
    public DefaultObjectPool`1(IPooledObjectPolicy`1<T> policy, int maximumRetained);
    public virtual T Get();
    public virtual void Return(T obj);
    private protected bool ReturnCore(T obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class YamlDotNet.Core.ObjectPool.DefaultPooledObjectPolicy`1 : object {
    public sealed virtual T Create();
    public sealed virtual bool Return(T obj);
}
[NullableContextAttribute("1")]
internal interface YamlDotNet.Core.ObjectPool.IPooledObjectPolicy`1 {
    public abstract virtual T Create();
    public abstract virtual bool Return(T obj);
}
internal interface YamlDotNet.Core.ObjectPool.IResettable {
    public abstract virtual bool TryReset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class YamlDotNet.Core.ObjectPool.ObjectPool : object {
    public static ObjectPool`1<T> Create(IPooledObjectPolicy`1<T> policy);
    public static ObjectPool`1<T> Create(int maximumRetained, IPooledObjectPolicy`1<T> policy);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class YamlDotNet.Core.ObjectPool.ObjectPool`1 : object {
    public abstract virtual T Get();
    public abstract virtual void Return(T obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
internal static class YamlDotNet.Core.ObjectPool.StringBuilderPool : object {
    private static ObjectPool`1<StringBuilder> Pool;
    private static StringBuilderPool();
    public static BuilderWrapper Rent();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class YamlDotNet.Core.ObjectPool.StringBuilderPooledObjectPolicy : object {
    [CompilerGeneratedAttribute]
private int <InitialCapacity>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumRetainedCapacity>k__BackingField;
    public int InitialCapacity { get; public set; }
    public int MaximumRetainedCapacity { get; public set; }
    [CompilerGeneratedAttribute]
public int get_InitialCapacity();
    [CompilerGeneratedAttribute]
public void set_InitialCapacity(int value);
    [CompilerGeneratedAttribute]
public int get_MaximumRetainedCapacity();
    [CompilerGeneratedAttribute]
public void set_MaximumRetainedCapacity(int value);
    public sealed virtual StringBuilder Create();
    public sealed virtual bool Return(StringBuilder obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class YamlDotNet.Core.ObjectPool.StringLookAheadBufferPool : object {
    private static ObjectPool`1<StringLookAheadBuffer> Pool;
    private static StringLookAheadBufferPool();
    public static BufferWrapper Rent(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Parser : object {
    private Stack`1<ParserState> states;
    private TagDirectiveCollection tagDirectives;
    private ParserState state;
    private IScanner scanner;
    [NullableAttribute("2")]
private Token currentToken;
    [NullableAttribute("2")]
private VersionDirective version;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ParsingEvent <Current>k__BackingField;
    private EventQueue pendingEvents;
    [NullableAttribute("2")]
public ParsingEvent Current { get; private set; }
    public Parser(TextReader input);
    public Parser(IScanner scanner);
    [NullableContextAttribute("2")]
private Token GetCurrentToken();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual ParsingEvent get_Current();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Current(ParsingEvent value);
    public sealed virtual bool MoveNext();
    private ParsingEvent StateMachine();
    private void Skip();
    private StreamStart ParseStreamStart();
    private ParsingEvent ParseDocumentStart(bool isImplicit);
    private VersionDirective ProcessDirectives(TagDirectiveCollection tags);
    private static void AddTagDirectives(TagDirectiveCollection directives, IEnumerable`1<TagDirective> source);
    private ParsingEvent ParseDocumentContent();
    private static Scalar ProcessEmptyScalar(Mark& position);
    private ParsingEvent ParseNode(bool isBlock, bool isIndentlessSequence);
    private DocumentEnd ParseDocumentEnd();
    private ParsingEvent ParseBlockSequenceEntry(bool isFirst);
    private ParsingEvent ParseIndentlessSequenceEntry();
    private ParsingEvent ParseBlockMappingKey(bool isFirst);
    private ParsingEvent ParseBlockMappingValue();
    private ParsingEvent ParseFlowSequenceEntry(bool isFirst);
    private ParsingEvent ParseFlowSequenceEntryMappingKey();
    private ParsingEvent ParseFlowSequenceEntryMappingValue();
    private MappingEnd ParseFlowSequenceEntryMappingEnd();
    private ParsingEvent ParseFlowMappingKey(bool isFirst);
    private ParsingEvent ParseFlowMappingValue(bool isEmpty);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class YamlDotNet.Core.ParserExtensions : object {
    [ExtensionAttribute]
public static T Consume(IParser parser);
    [ExtensionAttribute]
public static bool TryConsume(IParser parser, T& event);
    [ExtensionAttribute]
public static T Require(IParser parser);
    [ExtensionAttribute]
public static bool Accept(IParser parser, T& event);
    [ExtensionAttribute]
public static void SkipThisAndNestedEvents(IParser parser);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Consume<T>() instead")]
public static T Expect(IParser parser);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use TryConsume<T>(out var evt) instead")]
public static T Allow(IParser parser);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use Accept<T>(out var evt) instead")]
public static T Peek(IParser parser);
    [ExtensionAttribute]
[ObsoleteAttribute("Please use TryConsume<T>(out var evt) or Accept<T>(out var evt) instead")]
public static bool Accept(IParser parser);
    [ExtensionAttribute]
public static bool TryFindMappingEntry(IParser parser, Func`2<Scalar, bool> selector, Scalar& key, ParsingEvent& value);
}
internal enum YamlDotNet.Core.ParserState : Enum {
    public int value__;
    public static ParserState StreamStart;
    public static ParserState StreamEnd;
    public static ParserState ImplicitDocumentStart;
    public static ParserState DocumentStart;
    public static ParserState DocumentContent;
    public static ParserState DocumentEnd;
    public static ParserState BlockNode;
    public static ParserState BlockNodeOrIndentlessSequence;
    public static ParserState FlowNode;
    public static ParserState BlockSequenceFirstEntry;
    public static ParserState BlockSequenceEntry;
    public static ParserState IndentlessSequenceEntry;
    public static ParserState BlockMappingFirstKey;
    public static ParserState BlockMappingKey;
    public static ParserState BlockMappingValue;
    public static ParserState FlowSequenceFirstEntry;
    public static ParserState FlowSequenceEntry;
    public static ParserState FlowSequenceEntryMappingKey;
    public static ParserState FlowSequenceEntryMappingValue;
    public static ParserState FlowSequenceEntryMappingEnd;
    public static ParserState FlowMappingFirstKey;
    public static ParserState FlowMappingKey;
    public static ParserState FlowMappingValue;
    public static ParserState FlowMappingEmptyValue;
}
internal class YamlDotNet.Core.RecursionLevel : object {
    private int current;
    [CompilerGeneratedAttribute]
private int <Maximum>k__BackingField;
    public int Maximum { get; }
    public RecursionLevel(int maximum);
    [CompilerGeneratedAttribute]
public int get_Maximum();
    public void Increment();
    public bool TryIncrement();
    public void Decrement();
}
public enum YamlDotNet.Core.ScalarStyle : Enum {
    public int value__;
    public static ScalarStyle Any;
    public static ScalarStyle Plain;
    public static ScalarStyle SingleQuoted;
    public static ScalarStyle DoubleQuoted;
    public static ScalarStyle Literal;
    public static ScalarStyle Folded;
    public static ScalarStyle ForcePlain;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Scanner : object {
    private static int MaxVersionNumberLength;
    private static SortedDictionary`2<char, char> SimpleEscapeCodes;
    private Stack`1<long> indents;
    private InsertionQueue`1<Token> tokens;
    private Stack`1<SimpleKey> simpleKeys;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private CharacterAnalyzer`1<LookAheadBuffer> analyzer;
    private Cursor cursor;
    private bool streamStartProduced;
    private bool streamEndProduced;
    private bool plainScalarFollowedByComment;
    private bool flowCollectionFetched;
    private bool startFlowCollectionFetched;
    private long indent;
    private bool flowScalarFetched;
    private bool simpleKeyAllowed;
    private int flowLevel;
    private int tokensParsed;
    private bool tokenAvailable;
    [NullableAttribute("2")]
private Token previous;
    [NullableAttribute("2")]
private Anchor previousAnchor;
    [NullableAttribute("2")]
private Scalar lastScalar;
    private int maxKeySize;
    [CompilerGeneratedAttribute]
private bool <SkipComments>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Token <Current>k__BackingField;
    private static Byte[] EmptyBytes;
    public bool SkipComments { get; private set; }
    [NullableAttribute("2")]
public Token Current { get; private set; }
    public Mark CurrentPosition { get; }
    public Scanner(TextReader input, bool skipComments);
    public Scanner(TextReader input, bool skipComments, int maxKeySize);
    private static Scanner();
    private bool IsDocumentStart();
    private bool IsDocumentEnd();
    private bool IsDocumentIndicator();
    [CompilerGeneratedAttribute]
public bool get_SkipComments();
    [CompilerGeneratedAttribute]
private void set_SkipComments(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Token get_Current();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Current(Token value);
    public sealed virtual Mark get_CurrentPosition();
    public sealed virtual bool MoveNext();
    public sealed virtual bool MoveNextWithoutConsuming();
    public sealed virtual void ConsumeCurrent();
    private char ReadCurrentCharacter();
    private char ReadLine();
    private void FetchMoreTokens();
    private static bool StartsWith(StringBuilder what, char start);
    private void StaleSimpleKeys();
    private void FetchNextToken();
    private bool CheckWhiteSpace();
    private void Skip();
    private void SkipLine();
    private void ScanToNextToken();
    private void ProcessComment();
    private void FetchStreamStart();
    private void UnrollIndent(long column);
    private void FetchStreamEnd();
    private void FetchDirective();
    [NullableContextAttribute("2")]
private Token ScanDirective();
    private void FetchDocumentIndicator(bool isStartToken);
    private void FetchFlowCollectionStart(bool isSequenceToken);
    private void IncreaseFlowLevel();
    private void FetchFlowCollectionEnd(bool isSequenceToken);
    private void DecreaseFlowLevel();
    private void FetchFlowEntry();
    private void FetchBlockEntry();
    private void FetchKey();
    private void FetchValue();
    private void RollIndent(long column, int number, bool isSequence, Mark position);
    private void FetchAnchor(bool isAlias);
    private Token ScanAnchor(bool isAlias);
    private void FetchTag();
    private Tag ScanTag();
    private void FetchBlockScalar(bool isLiteral);
    private Scalar ScanBlockScalar(bool isLiteral);
    private long ScanBlockScalarBreaks(long currentIndent, StringBuilder breaks, bool isLiteral, Mark& end, Nullable`1& isFirstLine);
    private void FetchQuotedScalar(bool isSingleQuoted);
    private Scalar ScanFlowScalar(bool isSingleQuoted);
    private void FetchPlainScalar();
    private Scalar ScanPlainScalar(Boolean& isMultiline);
    private void RemoveSimpleKey();
    private string ScanDirectiveName(Mark& start);
    private void SkipWhitespaces();
    private VersionDirective ScanVersionDirectiveValue(Mark& start);
    private TagDirective ScanTagDirectiveValue(Mark& start);
    private string ScanTagUri(string head, Mark start);
    private string ScanUriEscapes(Mark& start);
    private string ScanTagHandle(bool isDirective, Mark start);
    private int ScanVersionDirectiveNumber(Mark& start);
    private void SaveSimpleKey();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.SemanticErrorException : YamlException {
    public SemanticErrorException(string message);
    public SemanticErrorException(Mark& start, Mark& end, string message);
    public SemanticErrorException(string message, Exception inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class YamlDotNet.Core.SimpleKey : object {
    private Cursor cursor;
    [CompilerGeneratedAttribute]
private bool <IsPossible>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TokenNumber>k__BackingField;
    public bool IsPossible { get; private set; }
    public bool IsRequired { get; }
    public int TokenNumber { get; }
    public long Index { get; }
    public long Line { get; }
    public long LineOffset { get; }
    public Mark Mark { get; }
    public SimpleKey(bool isRequired, int tokenNumber, Cursor cursor);
    [CompilerGeneratedAttribute]
public bool get_IsPossible();
    [CompilerGeneratedAttribute]
private void set_IsPossible(bool value);
    public void MarkAsImpossible();
    [CompilerGeneratedAttribute]
public bool get_IsRequired();
    [CompilerGeneratedAttribute]
public int get_TokenNumber();
    public long get_Index();
    public long get_Line();
    public long get_LineOffset();
    public Mark get_Mark();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class YamlDotNet.Core.StringLookAheadBuffer : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    public string Value { get; public set; }
    public int Position { get; private set; }
    public int Length { get; }
    public bool EndOfInput { get; }
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
    public int get_Length();
    public sealed virtual bool get_EndOfInput();
    public sealed virtual char Peek(int offset);
    private bool IsOutside(int index);
    public sealed virtual void Skip(int length);
    public sealed virtual bool TryReset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.SyntaxErrorException : YamlException {
    public SyntaxErrorException(string message);
    public SyntaxErrorException(Mark& start, Mark& end, string message);
    public SyntaxErrorException(string message, Exception inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class YamlDotNet.Core.TagDirectiveCollection : KeyedCollection`2<string, TagDirective> {
    public TagDirectiveCollection(IEnumerable`1<TagDirective> tagDirectives);
    protected virtual string GetKeyForItem(TagDirective item);
    public bool Contains(TagDirective directive);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class YamlDotNet.Core.TagName : ValueType {
    public static TagName Empty;
    [NullableAttribute("2")]
private string value;
    public string Value { get; }
    public bool IsEmpty { get; }
    public bool IsNonSpecific { get; }
    public bool IsLocal { get; }
    public bool IsGlobal { get; }
    public TagName(string value);
    public string get_Value();
    public bool get_IsEmpty();
    public bool get_IsNonSpecific();
    public bool get_IsLocal();
    public bool get_IsGlobal();
    public virtual string ToString();
    public sealed virtual bool Equals(TagName other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(TagName left, TagName right);
    public static bool op_Inequality(TagName left, TagName right);
    public static bool op_Equality(TagName left, string right);
    public static bool op_Inequality(TagName left, string right);
    [NullableContextAttribute("2")]
public static TagName op_Implicit(string value);
}
public class YamlDotNet.Core.Tokens.Anchor : Token {
    [CompilerGeneratedAttribute]
private AnchorName <Value>k__BackingField;
    public AnchorName Value { get; }
    public Anchor(AnchorName value);
    public Anchor(AnchorName value, Mark start, Mark end);
    [CompilerGeneratedAttribute]
public AnchorName get_Value();
}
public class YamlDotNet.Core.Tokens.AnchorAlias : Token {
    [CompilerGeneratedAttribute]
private AnchorName <Value>k__BackingField;
    public AnchorName Value { get; }
    public AnchorAlias(AnchorName value);
    public AnchorAlias(AnchorName value, Mark start, Mark end);
    [CompilerGeneratedAttribute]
public AnchorName get_Value();
}
public class YamlDotNet.Core.Tokens.BlockEnd : Token {
    public BlockEnd(Mark& start, Mark& end);
}
public class YamlDotNet.Core.Tokens.BlockEntry : Token {
    public BlockEntry(Mark& start, Mark& end);
}
public class YamlDotNet.Core.Tokens.BlockMappingStart : Token {
    public BlockMappingStart(Mark& start, Mark& end);
}
public class YamlDotNet.Core.Tokens.BlockSequenceStart : Token {
    public BlockSequenceStart(Mark& start, Mark& end);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Tokens.Comment : Token {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInline>k__BackingField;
    public string Value { get; }
    public bool IsInline { get; }
    public Comment(string value, bool isInline);
    public Comment(string value, bool isInline, Mark start, Mark end);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public bool get_IsInline();
}
public class YamlDotNet.Core.Tokens.DocumentEnd : Token {
    public DocumentEnd(Mark& start, Mark& end);
}
public class YamlDotNet.Core.Tokens.DocumentStart : Token {
    public DocumentStart(Mark& start, Mark& end);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Tokens.Error : Token {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public Error(string value, Mark start, Mark end);
    [CompilerGeneratedAttribute]
public string get_Value();
}
public class YamlDotNet.Core.Tokens.FlowEntry : Token {
    public FlowEntry(Mark& start, Mark& end);
}
public class YamlDotNet.Core.Tokens.FlowMappingEnd : Token {
    public FlowMappingEnd(Mark& start, Mark& end);
}
public class YamlDotNet.Core.Tokens.FlowMappingStart : Token {
    public FlowMappingStart(Mark& start, Mark& end);
}
public class YamlDotNet.Core.Tokens.FlowSequenceEnd : Token {
    public FlowSequenceEnd(Mark& start, Mark& end);
}
public class YamlDotNet.Core.Tokens.FlowSequenceStart : Token {
    public FlowSequenceStart(Mark& start, Mark& end);
}
public class YamlDotNet.Core.Tokens.Key : Token {
    public Key(Mark& start, Mark& end);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Tokens.Scalar : Token {
    [CompilerGeneratedAttribute]
private bool <IsKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private ScalarStyle <Style>k__BackingField;
    public bool IsKey { get; public set; }
    public string Value { get; }
    public ScalarStyle Style { get; }
    public Scalar(string value);
    public Scalar(string value, ScalarStyle style);
    public Scalar(string value, ScalarStyle style, Mark start, Mark end);
    [CompilerGeneratedAttribute]
public bool get_IsKey();
    [CompilerGeneratedAttribute]
public void set_IsKey(bool value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public ScalarStyle get_Style();
}
public class YamlDotNet.Core.Tokens.StreamEnd : Token {
    public StreamEnd(Mark& start, Mark& end);
}
public class YamlDotNet.Core.Tokens.StreamStart : Token {
    public StreamStart(Mark& start, Mark& end);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Tokens.Tag : Token {
    [CompilerGeneratedAttribute]
private string <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    public string Handle { get; }
    public string Suffix { get; }
    public Tag(string handle, string suffix);
    public Tag(string handle, string suffix, Mark start, Mark end);
    [CompilerGeneratedAttribute]
public string get_Handle();
    [CompilerGeneratedAttribute]
public string get_Suffix();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Tokens.TagDirective : Token {
    [CompilerGeneratedAttribute]
private string <Handle>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    private static Regex TagHandlePattern;
    public string Handle { get; }
    public string Prefix { get; }
    public TagDirective(string handle, string prefix);
    public TagDirective(string handle, string prefix, Mark start, Mark end);
    private static TagDirective();
    [CompilerGeneratedAttribute]
public string get_Handle();
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public abstract class YamlDotNet.Core.Tokens.Token : object {
    [CompilerGeneratedAttribute]
private Mark <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Mark <End>k__BackingField;
    public Mark Start { get; }
    public Mark End { get; }
    protected Token(Mark& start, Mark& end);
    [CompilerGeneratedAttribute]
public Mark get_Start();
    [CompilerGeneratedAttribute]
public Mark get_End();
}
public class YamlDotNet.Core.Tokens.Value : Token {
    public Value(Mark& start, Mark& end);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.Tokens.VersionDirective : Token {
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public Version Version { get; }
    public VersionDirective(Version version);
    public VersionDirective(Version version, Mark start, Mark end);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class YamlDotNet.Core.Version : object {
    [CompilerGeneratedAttribute]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Minor>k__BackingField;
    public int Major { get; }
    public int Minor { get; }
    public Version(int major, int minor);
    [CompilerGeneratedAttribute]
public int get_Major();
    [CompilerGeneratedAttribute]
public int get_Minor();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Core.YamlException : Exception {
    [CompilerGeneratedAttribute]
private Mark <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Mark <End>k__BackingField;
    public Mark Start { get; }
    public Mark End { get; }
    public YamlException(string message);
    public YamlException(Mark& start, Mark& end, string message);
    public YamlException(Mark& start, Mark& end, string message, Exception innerException);
    public YamlException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public Mark get_Start();
    [CompilerGeneratedAttribute]
public Mark get_End();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class YamlDotNet.CultureInfoAdapter : CultureInfo {
    private IFormatProvider provider;
    public CultureInfoAdapter(CultureInfo baseCulture, IFormatProvider provider);
    public virtual object GetFormat(Type formatType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class YamlDotNet.Helpers.DictionaryExtensions : object {
    [ExtensionAttribute]
public static bool TryAdd(Dictionary`2<T, V> dictionary, T key, V value);
    [ExtensionAttribute]
public static TValue GetOrAdd(ConcurrentDictionary`2<TKey, TValue> dictionary, TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg arg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class YamlDotNet.Helpers.ExpressionExtensions : object {
    [ExtensionAttribute]
public static PropertyInfo AsProperty(LambdaExpression propertyAccessor);
    private static TMemberInfo TryGetMemberExpression(LambdaExpression lambdaExpression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class YamlDotNet.Helpers.FsharpHelper : object {
    private static bool IsFsharpCore(Type t);
    public static bool IsOptionType(Type t);
    public static Type GetOptionUnderlyingType(Type t);
    public static object GetValue(IObjectDescriptor objectDescriptor);
    public static bool IsFsharpListType(Type t);
    public static object CreateFsharpListFromArray(Type t, Type itemsType, Array arr);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class YamlDotNet.Helpers.GenericCollectionToNonGenericAdapter`1 : object {
    [NullableAttribute("1")]
private ICollection`1<T> genericCollection;
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    [NullableAttribute("1")]
public object SyncRoot { get; }
    [NullableContextAttribute("1")]
public GenericCollectionToNonGenericAdapter`1(ICollection`1<T> genericCollection);
    public sealed virtual int Add(object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object value);
    public sealed virtual int IndexOf(object value);
    public sealed virtual void Insert(int index, object value);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Remove(object value);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual object get_Item(int index);
    public sealed virtual void set_Item(int index, object value);
    [NullableContextAttribute("1")]
public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    [NullableContextAttribute("1")]
public sealed virtual object get_SyncRoot();
    [NullableContextAttribute("1")]
public sealed virtual IEnumerator GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class YamlDotNet.Helpers.GenericDictionaryToNonGenericAdapter`2 : object {
    private IDictionary`2<TKey, TValue> genericDictionary;
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public GenericDictionaryToNonGenericAdapter`2(IDictionary`2<TKey, TValue> genericDictionary);
    public sealed virtual void Add(object key, object value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(object key);
    public sealed virtual IDictionaryEnumerator GetEnumerator();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual ICollection get_Keys();
    public sealed virtual void Remove(object key);
    public sealed virtual ICollection get_Values();
    public sealed virtual object get_Item(object key);
    public sealed virtual void set_Item(object key, object value);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsSynchronized();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface YamlDotNet.Helpers.IOrderedDictionary`2 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyValuePair`2<TKey, TValue> Item { get; public set; }
    public abstract virtual KeyValuePair`2<TKey, TValue> get_Item(int index);
    public abstract virtual void set_Item(int index, KeyValuePair`2<TKey, TValue> value);
    public abstract virtual void Insert(int index, TKey key, TValue value);
    public abstract virtual void RemoveAt(int index);
}
[ExtensionAttribute]
internal static class YamlDotNet.Helpers.NumberExtensions : object {
    [ExtensionAttribute]
public static bool IsPowerOfTwo(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class YamlDotNet.Helpers.OrderedDictionary`2 : object {
    private Dictionary`2<TKey, TValue> dictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<KeyValuePair`2<TKey, TValue>> list;
    private IEqualityComparer`1<TKey> comparer;
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyValuePair`2<TKey, TValue> Item { get; public set; }
    public OrderedDictionary`2(IEqualityComparer`1<TKey> comparer);
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual KeyValuePair`2<TKey, TValue> get_Item(int index);
    public sealed virtual void set_Item(int index, KeyValuePair`2<TKey, TValue> value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Add(TKey key, TValue value);
    private static void ThrowDuplicateKeyException(TKey key);
    public bool TryAdd(TKey key, TValue value);
    public bool TryAdd(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    public sealed virtual void Insert(int index, TKey key, TValue value);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [OnDeserializedAttribute]
internal void OnDeserializedMethod(StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class YamlDotNet.Helpers.ReadOnlyCollectionExtensions : object {
    [ExtensionAttribute]
public static IReadOnlyList`1<T> AsReadonlyList(List`1<T> list);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<TKey, TValue> AsReadonlyDictionary(Dictionary`2<TKey, TValue> dictionary);
}
internal static class YamlDotNet.Helpers.ThrowHelper : object {
    [NullableContextAttribute("1")]
public static void ThrowArgumentOutOfRangeException(string paramName, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class YamlDotNet.Polyfills : object {
    [ExtensionAttribute]
internal static bool Contains(string source, char c);
    [ExtensionAttribute]
internal static bool EndsWith(string source, char c);
    [ExtensionAttribute]
internal static bool StartsWith(string source, char c);
}
[ExtensionAttribute]
internal static class YamlDotNet.PropertyInfoExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static object ReadValue(PropertyInfo property, object target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class YamlDotNet.ReflectionExtensions : object {
    private static Func`2<PropertyInfo, bool> IsInstance;
    private static Func`2<PropertyInfo, bool> IsInstancePublic;
    private static ConcurrentDictionary`2<Type, bool> TypesHaveNullContext;
    private static ReflectionExtensions();
    [ExtensionAttribute]
public static Type BaseType(Type type);
    [ExtensionAttribute]
public static bool IsValueType(Type type);
    [ExtensionAttribute]
public static bool IsGenericType(Type type);
    [ExtensionAttribute]
public static bool IsGenericTypeDefinition(Type type);
    [ExtensionAttribute]
public static Type GetImplementationOfOpenGenericInterface(Type type, Type openGenericType);
    [ExtensionAttribute]
public static bool IsInterface(Type type);
    [ExtensionAttribute]
public static bool IsEnum(Type type);
    [ExtensionAttribute]
public static bool IsRequired(MemberInfo member);
    [ExtensionAttribute]
public static bool HasDefaultConstructor(Type type, bool allowPrivateConstructors);
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type type, Type source);
    [ExtensionAttribute]
public static bool IsAssignableFrom(Type type, TypeInfo source);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
public static bool IsDbNull(object value);
    [ExtensionAttribute]
public static Type[] GetGenericArguments(Type type);
    [ExtensionAttribute]
public static PropertyInfo GetPublicProperty(Type type, string name);
    [ExtensionAttribute]
public static FieldInfo GetPublicStaticField(Type type, string name);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetProperties(Type type, bool includeNonPublic);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetPublicProperties(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<FieldInfo> GetPublicFields(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetPublicStaticMethods(Type type);
    [ExtensionAttribute]
public static MethodInfo GetPrivateStaticMethod(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo GetPublicStaticMethod(Type type, string name, Type[] parameterTypes);
    [ExtensionAttribute]
public static MethodInfo GetPublicInstanceMethod(Type type, string name);
    [ExtensionAttribute]
public static MethodInfo GetGetMethod(PropertyInfo property, bool nonPublic);
    [ExtensionAttribute]
public static MethodInfo GetSetMethod(PropertyInfo property);
    [ExtensionAttribute]
public static IEnumerable`1<Type> GetInterfaces(Type type);
    [ExtensionAttribute]
public static bool IsInstanceOf(Type type, object o);
    [ExtensionAttribute]
public static Attribute[] GetAllCustomAttributes(PropertyInfo member);
    [ExtensionAttribute]
public static bool AcceptsNull(MemberInfo member);
    [CompilerGeneratedAttribute]
internal static bool <GetImplementationOfOpenGenericInterface>g__IsGenericDefinitionOfType|4_1(Type t, object context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class YamlDotNet.RepresentationModel.DocumentLoadingState : object {
    private Dictionary`2<AnchorName, YamlNode> anchors;
    private List`1<YamlNode> nodesWithUnresolvedAliases;
    public void AddAnchor(YamlNode node);
    public YamlNode GetNode(AnchorName anchor, Mark start, Mark end);
    [NullableContextAttribute("2")]
public bool TryGetNode(AnchorName anchor, YamlNode& node);
    public void AddNodeWithUnresolvedAliases(YamlNode node);
    public void ResolveAliases();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class YamlDotNet.RepresentationModel.EmitterState : object {
    [CompilerGeneratedAttribute]
private HashSet`1<AnchorName> <EmittedAnchors>k__BackingField;
    public HashSet`1<AnchorName> EmittedAnchors { get; }
    [CompilerGeneratedAttribute]
public HashSet`1<AnchorName> get_EmittedAnchors();
}
[NullableContextAttribute("1")]
public interface YamlDotNet.RepresentationModel.IYamlVisitor {
    public abstract virtual void Visit(YamlStream stream);
    public abstract virtual void Visit(YamlDocument document);
    public abstract virtual void Visit(YamlScalarNode scalar);
    public abstract virtual void Visit(YamlSequenceNode sequence);
    public abstract virtual void Visit(YamlMappingNode mapping);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.RepresentationModel.LibYamlEventStream : object {
    private IParser parser;
    public LibYamlEventStream(IParser iParser);
    public void WriteTo(TextWriter textWriter);
    private static void WriteAnchorAndTag(TextWriter textWriter, NodeEvent nodeEvent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class YamlDotNet.RepresentationModel.YamlAliasNode : YamlNode {
    public YamlNodeType NodeType { get; }
    internal YamlAliasNode(AnchorName anchor);
    internal virtual void ResolveAliases(DocumentLoadingState state);
    internal virtual void Emit(IEmitter emitter, EmitterState state);
    public virtual void Accept(IYamlVisitor visitor);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal virtual string ToString(RecursionLevel level);
    [IteratorStateMachineAttribute("YamlDotNet.RepresentationModel.YamlAliasNode/<SafeAllNodes>d__7")]
internal virtual IEnumerable`1<YamlNode> SafeAllNodes(RecursionLevel level);
    public virtual YamlNodeType get_NodeType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.RepresentationModel.YamlDocument : object {
    [CompilerGeneratedAttribute]
private YamlNode <RootNode>k__BackingField;
    public YamlNode RootNode { get; private set; }
    public IEnumerable`1<YamlNode> AllNodes { get; }
    public YamlDocument(YamlNode rootNode);
    public YamlDocument(string rootNode);
    internal YamlDocument(IParser parser);
    [CompilerGeneratedAttribute]
public YamlNode get_RootNode();
    [CompilerGeneratedAttribute]
private void set_RootNode(YamlNode value);
    private void AssignAnchors();
    internal void Save(IEmitter emitter, bool assignAnchors);
    public void Accept(IYamlVisitor visitor);
    public IEnumerable`1<YamlNode> get_AllNodes();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.RepresentationModel.YamlMappingNode : YamlNode {
    private OrderedDictionary`2<YamlNode, YamlNode> children;
    [CompilerGeneratedAttribute]
private MappingStyle <Style>k__BackingField;
    public IOrderedDictionary`2<YamlNode, YamlNode> Children { get; }
    public MappingStyle Style { get; public set; }
    public YamlNodeType NodeType { get; }
    internal YamlMappingNode(IParser parser, DocumentLoadingState state);
    public YamlMappingNode(KeyValuePair`2[] children);
    public YamlMappingNode(IEnumerable`1<KeyValuePair`2<YamlNode, YamlNode>> children);
    public YamlMappingNode(YamlNode[] children);
    public YamlMappingNode(IEnumerable`1<YamlNode> children);
    public IOrderedDictionary`2<YamlNode, YamlNode> get_Children();
    [CompilerGeneratedAttribute]
public MappingStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(MappingStyle value);
    private void Load(IParser parser, DocumentLoadingState state);
    public void Add(YamlNode key, YamlNode value);
    public void Add(string key, YamlNode value);
    public void Add(YamlNode key, string value);
    public void Add(string key, string value);
    internal virtual void ResolveAliases(DocumentLoadingState state);
    internal virtual void Emit(IEmitter emitter, EmitterState state);
    public virtual void Accept(IYamlVisitor visitor);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [IteratorStateMachineAttribute("YamlDotNet.RepresentationModel.YamlMappingNode/<SafeAllNodes>d__23")]
internal virtual IEnumerable`1<YamlNode> SafeAllNodes(RecursionLevel level);
    public virtual YamlNodeType get_NodeType();
    internal virtual string ToString(RecursionLevel level);
    public sealed virtual IEnumerator`1<KeyValuePair`2<YamlNode, YamlNode>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void YamlDotNet.Serialization.IYamlConvertible.Read(IParser parser, Type expectedType, ObjectDeserializer nestedObjectDeserializer);
    private sealed virtual override void YamlDotNet.Serialization.IYamlConvertible.Write(IEmitter emitter, ObjectSerializer nestedObjectSerializer);
    public static YamlMappingNode FromObject(object mapping);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class YamlDotNet.RepresentationModel.YamlNode : object {
    private static int MaximumRecursionLevel;
    internal static string MaximumRecursionLevelReachedToStringValue;
    [CompilerGeneratedAttribute]
private AnchorName <Anchor>k__BackingField;
    [CompilerGeneratedAttribute]
private TagName <Tag>k__BackingField;
    [CompilerGeneratedAttribute]
private Mark <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Mark <End>k__BackingField;
    public AnchorName Anchor { get; public set; }
    public TagName Tag { get; public set; }
    public Mark Start { get; private set; }
    public Mark End { get; private set; }
    public IEnumerable`1<YamlNode> AllNodes { get; }
    public YamlNodeType NodeType { get; }
    public YamlNode Item { get; }
    public YamlNode Item { get; }
    [CompilerGeneratedAttribute]
public AnchorName get_Anchor();
    [CompilerGeneratedAttribute]
public void set_Anchor(AnchorName value);
    [CompilerGeneratedAttribute]
public TagName get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(TagName value);
    [CompilerGeneratedAttribute]
public Mark get_Start();
    [CompilerGeneratedAttribute]
private void set_Start(Mark value);
    [CompilerGeneratedAttribute]
public Mark get_End();
    [CompilerGeneratedAttribute]
private void set_End(Mark value);
    internal void Load(NodeEvent yamlEvent, DocumentLoadingState state);
    internal static YamlNode ParseNode(IParser parser, DocumentLoadingState state);
    internal abstract virtual void ResolveAliases(DocumentLoadingState state);
    internal void Save(IEmitter emitter, EmitterState state);
    internal abstract virtual void Emit(IEmitter emitter, EmitterState state);
    public abstract virtual void Accept(IYamlVisitor visitor);
    public virtual string ToString();
    internal abstract virtual string ToString(RecursionLevel level);
    public IEnumerable`1<YamlNode> get_AllNodes();
    internal abstract virtual IEnumerable`1<YamlNode> SafeAllNodes(RecursionLevel level);
    public abstract virtual YamlNodeType get_NodeType();
    public static YamlNode op_Implicit(string value);
    public static YamlNode op_Implicit(String[] sequence);
    public static string op_Explicit(YamlNode node);
    public YamlNode get_Item(int index);
    public YamlNode get_Item(YamlNode key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.RepresentationModel.YamlNodeIdentityEqualityComparer : object {
    public sealed virtual bool Equals(YamlNode x, YamlNode y);
    public sealed virtual int GetHashCode(YamlNode obj);
}
public enum YamlDotNet.RepresentationModel.YamlNodeType : Enum {
    public int value__;
    public static YamlNodeType Alias;
    public static YamlNodeType Mapping;
    public static YamlNodeType Scalar;
    public static YamlNodeType Sequence;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Value}")]
public class YamlDotNet.RepresentationModel.YamlScalarNode : YamlNode {
    private bool forceImplicitPlain;
    [NullableAttribute("2")]
private string value;
    [CompilerGeneratedAttribute]
private ScalarStyle <Style>k__BackingField;
    [NullableAttribute("2")]
public string Value { get; public set; }
    public ScalarStyle Style { get; public set; }
    public YamlNodeType NodeType { get; }
    internal YamlScalarNode(IParser parser, DocumentLoadingState state);
    [NullableContextAttribute("2")]
public YamlScalarNode(string value);
    [NullableContextAttribute("2")]
public string get_Value();
    [NullableContextAttribute("2")]
public void set_Value(string value);
    [CompilerGeneratedAttribute]
public ScalarStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(ScalarStyle value);
    private void Load(IParser parser, DocumentLoadingState state);
    internal virtual void ResolveAliases(DocumentLoadingState state);
    internal virtual void Emit(IEmitter emitter, EmitterState state);
    public virtual void Accept(IYamlVisitor visitor);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static string op_Explicit(YamlScalarNode value);
    internal virtual string ToString(RecursionLevel level);
    [IteratorStateMachineAttribute("YamlDotNet.RepresentationModel.YamlScalarNode/<SafeAllNodes>d__20")]
internal virtual IEnumerable`1<YamlNode> SafeAllNodes(RecursionLevel level);
    public virtual YamlNodeType get_NodeType();
    private sealed virtual override void YamlDotNet.Serialization.IYamlConvertible.Read(IParser parser, Type expectedType, ObjectDeserializer nestedObjectDeserializer);
    private sealed virtual override void YamlDotNet.Serialization.IYamlConvertible.Write(IEmitter emitter, ObjectSerializer nestedObjectSerializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Count = {children.Count}")]
public class YamlDotNet.RepresentationModel.YamlSequenceNode : YamlNode {
    private List`1<YamlNode> children;
    [CompilerGeneratedAttribute]
private SequenceStyle <Style>k__BackingField;
    public IList`1<YamlNode> Children { get; }
    public SequenceStyle Style { get; public set; }
    public YamlNodeType NodeType { get; }
    internal YamlSequenceNode(IParser parser, DocumentLoadingState state);
    public YamlSequenceNode(YamlNode[] children);
    public YamlSequenceNode(IEnumerable`1<YamlNode> children);
    public IList`1<YamlNode> get_Children();
    [CompilerGeneratedAttribute]
public SequenceStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(SequenceStyle value);
    private void Load(IParser parser, DocumentLoadingState state);
    public void Add(YamlNode child);
    public void Add(string child);
    internal virtual void ResolveAliases(DocumentLoadingState state);
    internal virtual void Emit(IEmitter emitter, EmitterState state);
    public virtual void Accept(IYamlVisitor visitor);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [IteratorStateMachineAttribute("YamlDotNet.RepresentationModel.YamlSequenceNode/<SafeAllNodes>d__19")]
internal virtual IEnumerable`1<YamlNode> SafeAllNodes(RecursionLevel level);
    public virtual YamlNodeType get_NodeType();
    internal virtual string ToString(RecursionLevel level);
    public sealed virtual IEnumerator`1<YamlNode> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void YamlDotNet.Serialization.IYamlConvertible.Read(IParser parser, Type expectedType, ObjectDeserializer nestedObjectDeserializer);
    private sealed virtual override void YamlDotNet.Serialization.IYamlConvertible.Write(IEmitter emitter, ObjectSerializer nestedObjectSerializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.RepresentationModel.YamlStream : object {
    private List`1<YamlDocument> documents;
    public IList`1<YamlDocument> Documents { get; }
    public YamlStream(YamlDocument[] documents);
    public YamlStream(IEnumerable`1<YamlDocument> documents);
    public IList`1<YamlDocument> get_Documents();
    public void Add(YamlDocument document);
    public void Load(TextReader input);
    public void Load(IParser parser);
    public void Save(TextWriter output);
    public void Save(TextWriter output, bool assignAnchors);
    public void Save(IEmitter emitter, bool assignAnchors);
    public void Accept(IYamlVisitor visitor);
    public sealed virtual IEnumerator`1<YamlDocument> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Use YamlVisitorBase")]
public abstract class YamlDotNet.RepresentationModel.YamlVisitor : object {
    protected virtual void Visit(YamlStream stream);
    protected virtual void Visited(YamlStream stream);
    protected virtual void Visit(YamlDocument document);
    protected virtual void Visited(YamlDocument document);
    protected virtual void Visit(YamlScalarNode scalar);
    protected virtual void Visited(YamlScalarNode scalar);
    protected virtual void Visit(YamlSequenceNode sequence);
    protected virtual void Visited(YamlSequenceNode sequence);
    protected virtual void Visit(YamlMappingNode mapping);
    protected virtual void Visited(YamlMappingNode mapping);
    protected virtual void VisitChildren(YamlStream stream);
    protected virtual void VisitChildren(YamlDocument document);
    protected virtual void VisitChildren(YamlSequenceNode sequence);
    protected virtual void VisitChildren(YamlMappingNode mapping);
    private sealed virtual override void YamlDotNet.RepresentationModel.IYamlVisitor.Visit(YamlStream stream);
    private sealed virtual override void YamlDotNet.RepresentationModel.IYamlVisitor.Visit(YamlDocument document);
    private sealed virtual override void YamlDotNet.RepresentationModel.IYamlVisitor.Visit(YamlScalarNode scalar);
    private sealed virtual override void YamlDotNet.RepresentationModel.IYamlVisitor.Visit(YamlSequenceNode sequence);
    private sealed virtual override void YamlDotNet.RepresentationModel.IYamlVisitor.Visit(YamlMappingNode mapping);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class YamlDotNet.RepresentationModel.YamlVisitorBase : object {
    public virtual void Visit(YamlStream stream);
    public virtual void Visit(YamlDocument document);
    public virtual void Visit(YamlScalarNode scalar);
    public virtual void Visit(YamlSequenceNode sequence);
    public virtual void Visit(YamlMappingNode mapping);
    protected virtual void VisitPair(YamlNode key, YamlNode value);
    protected virtual void VisitChildren(YamlStream stream);
    protected virtual void VisitChildren(YamlDocument document);
    protected virtual void VisitChildren(YamlSequenceNode sequence);
    protected virtual void VisitChildren(YamlMappingNode mapping);
}
public class YamlDotNet.Serialization.AliasEventInfo : EventInfo {
    [CompilerGeneratedAttribute]
private AnchorName <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NeedsExpansion>k__BackingField;
    public AnchorName Alias { get; }
    public bool NeedsExpansion { get; public set; }
    [NullableContextAttribute("1")]
public AliasEventInfo(IObjectDescriptor source, AnchorName alias);
    [CompilerGeneratedAttribute]
public AnchorName get_Alias();
    [CompilerGeneratedAttribute]
public bool get_NeedsExpansion();
    [CompilerGeneratedAttribute]
public void set_NeedsExpansion(bool value);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.BufferedDeserialization.ITypeDiscriminatingNodeDeserializerOptions {
    public abstract virtual void AddTypeDiscriminator(ITypeDiscriminator discriminator);
    public abstract virtual void AddKeyValueTypeDiscriminator(string discriminatorKey, IDictionary`2<string, Type> valueTypeMapping);
    public abstract virtual void AddUniqueKeyTypeDiscriminator(IDictionary`2<string, Type> uniqueKeyTypeMapping);
}
public class YamlDotNet.Serialization.BufferedDeserialization.ParserBuffer : object {
    [NullableAttribute("1")]
private LinkedList`1<ParsingEvent> buffer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private LinkedListNode`1<ParsingEvent> current;
    [NullableAttribute("2")]
public ParsingEvent Current { get; }
    [NullableContextAttribute("1")]
public ParserBuffer(IParser parserToBuffer, int maxDepth, int maxLength);
    [NullableContextAttribute("2")]
public sealed virtual ParsingEvent get_Current();
    public sealed virtual bool MoveNext();
    public void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.BufferedDeserialization.TypeDiscriminatingNodeDeserializer : object {
    private IList`1<INodeDeserializer> innerDeserializers;
    private IList`1<ITypeDiscriminator> typeDiscriminators;
    private int maxDepthToBuffer;
    private int maxLengthToBuffer;
    public TypeDiscriminatingNodeDeserializer(IList`1<INodeDeserializer> innerDeserializers, IList`1<ITypeDiscriminator> typeDiscriminators, int maxDepthToBuffer, int maxLengthToBuffer);
    public sealed virtual bool Deserialize(IParser reader, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value, ObjectDeserializer rootDeserializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.BufferedDeserialization.TypeDiscriminatingNodeDeserializerOptions : object {
    internal List`1<ITypeDiscriminator> discriminators;
    public sealed virtual void AddTypeDiscriminator(ITypeDiscriminator discriminator);
    public sealed virtual void AddKeyValueTypeDiscriminator(string discriminatorKey, IDictionary`2<string, Type> valueTypeMapping);
    public sealed virtual void AddUniqueKeyTypeDiscriminator(IDictionary`2<string, Type> uniqueKeyTypeMapping);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.BufferedDeserialization.TypeDiscriminators.ITypeDiscriminator {
    public Type BaseType { get; }
    public abstract virtual Type get_BaseType();
    public abstract virtual bool TryDiscriminate(IParser buffer, Type& suggestedType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.BufferedDeserialization.TypeDiscriminators.KeyValueTypeDiscriminator : object {
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    private string targetKey;
    private IDictionary`2<string, Type> typeMapping;
    public Type BaseType { get; private set; }
    public KeyValueTypeDiscriminator(Type baseType, string targetKey, IDictionary`2<string, Type> typeMapping);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_BaseType();
    [CompilerGeneratedAttribute]
private void set_BaseType(Type value);
    public sealed virtual bool TryDiscriminate(IParser parser, Type& suggestedType);
    [CompilerGeneratedAttribute]
private bool <TryDiscriminate>b__7_0(Scalar scalar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.BufferedDeserialization.TypeDiscriminators.UniqueKeyTypeDiscriminator : object {
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    private IDictionary`2<string, Type> typeMapping;
    public Type BaseType { get; private set; }
    public UniqueKeyTypeDiscriminator(Type baseType, IDictionary`2<string, Type> typeMapping);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_BaseType();
    [CompilerGeneratedAttribute]
private void set_BaseType(Type value);
    public sealed virtual bool TryDiscriminate(IParser parser, Type& suggestedType);
    [CompilerGeneratedAttribute]
private bool <TryDiscriminate>b__6_0(Scalar scalar);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class YamlDotNet.Serialization.BuilderSkeleton`1 : object {
    internal INamingConvention namingConvention;
    internal INamingConvention enumNamingConvention;
    internal ITypeResolver typeResolver;
    internal YamlAttributeOverrides overrides;
    internal LazyComponentRegistrationList`2<Nothing, IYamlTypeConverter> typeConverterFactories;
    internal LazyComponentRegistrationList`2<ITypeInspector, ITypeInspector> typeInspectorFactories;
    internal bool ignoreFields;
    internal bool includeNonPublicProperties;
    internal Settings settings;
    internal YamlFormatter yamlFormatter;
    protected TBuilder Self { get; }
    internal BuilderSkeleton`1(ITypeResolver typeResolver);
    protected abstract virtual TBuilder get_Self();
    public TBuilder IgnoreFields();
    public TBuilder IncludeNonPublicProperties();
    public TBuilder EnablePrivateConstructors();
    public TBuilder WithNamingConvention(INamingConvention namingConvention);
    public TBuilder WithEnumNamingConvention(INamingConvention enumNamingConvention);
    public TBuilder WithTypeResolver(ITypeResolver typeResolver);
    public abstract virtual TBuilder WithTagMapping(TagName tag, Type type);
    public TBuilder WithAttributeOverride(Expression`1<Func`2<TClass, object>> propertyAccessor, Attribute attribute);
    public TBuilder WithAttributeOverride(Type type, string member, Attribute attribute);
    public TBuilder WithTypeConverter(IYamlTypeConverter typeConverter);
    public TBuilder WithTypeConverter(IYamlTypeConverter typeConverter, Action`1<IRegistrationLocationSelectionSyntax`1<IYamlTypeConverter>> where);
    public TBuilder WithTypeConverter(WrapperFactory`2<IYamlTypeConverter, IYamlTypeConverter> typeConverterFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<IYamlTypeConverter>> where);
    public TBuilder WithoutTypeConverter();
    public TBuilder WithoutTypeConverter(Type converterType);
    public TBuilder WithTypeInspector(Func`2<ITypeInspector, TTypeInspector> typeInspectorFactory);
    public TBuilder WithTypeInspector(Func`2<ITypeInspector, TTypeInspector> typeInspectorFactory, Action`1<IRegistrationLocationSelectionSyntax`1<ITypeInspector>> where);
    public TBuilder WithTypeInspector(WrapperFactory`3<ITypeInspector, ITypeInspector, TTypeInspector> typeInspectorFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<ITypeInspector>> where);
    public TBuilder WithoutTypeInspector();
    public TBuilder WithoutTypeInspector(Type inspectorType);
    public TBuilder WithYamlFormatter(YamlFormatter formatter);
    protected IEnumerable`1<IYamlTypeConverter> BuildTypeConverters();
}
[AttributeUsageAttribute("64")]
public class YamlDotNet.Serialization.Callbacks.OnDeserializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class YamlDotNet.Serialization.Callbacks.OnDeserializingAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class YamlDotNet.Serialization.Callbacks.OnSerializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class YamlDotNet.Serialization.Callbacks.OnSerializingAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.Converters.DateTime8601Converter : object {
    private ScalarStyle scalarStyle;
    public DateTime8601Converter(ScalarStyle scalarStyle);
    public sealed virtual bool Accepts(Type type);
    public sealed virtual object ReadYaml(IParser parser, Type type, ObjectDeserializer rootDeserializer);
    public sealed virtual void WriteYaml(IEmitter emitter, object value, Type type, ObjectSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.Converters.DateTimeConverter : object {
    private DateTimeKind kind;
    private IFormatProvider provider;
    private bool doubleQuotes;
    private String[] formats;
    public DateTimeConverter(DateTimeKind kind, IFormatProvider provider, bool doubleQuotes, String[] formats);
    public sealed virtual bool Accepts(Type type);
    public sealed virtual object ReadYaml(IParser parser, Type type, ObjectDeserializer rootDeserializer);
    public sealed virtual void WriteYaml(IEmitter emitter, object value, Type type, ObjectSerializer serializer);
    private static DateTime EnsureDateTimeKind(DateTime dt, DateTimeKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.Converters.DateTimeOffsetConverter : object {
    private IFormatProvider provider;
    private ScalarStyle style;
    private DateTimeStyles dateStyle;
    private String[] formats;
    public DateTimeOffsetConverter(IFormatProvider provider, ScalarStyle style, DateTimeStyles dateStyle, String[] formats);
    public sealed virtual bool Accepts(Type type);
    public sealed virtual object ReadYaml(IParser parser, Type type, ObjectDeserializer rootDeserializer);
    public sealed virtual void WriteYaml(IEmitter emitter, object value, Type type, ObjectSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.Converters.GuidConverter : object {
    private bool jsonCompatible;
    public GuidConverter(bool jsonCompatible);
    public sealed virtual bool Accepts(Type type);
    public sealed virtual object ReadYaml(IParser parser, Type type, ObjectDeserializer rootDeserializer);
    public sealed virtual void WriteYaml(IEmitter emitter, object value, Type type, ObjectSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.Converters.SystemTypeConverter : object {
    public sealed virtual bool Accepts(Type type);
    public sealed virtual object ReadYaml(IParser parser, Type type, ObjectDeserializer rootDeserializer);
    public sealed virtual void WriteYaml(IEmitter emitter, object value, Type type, ObjectSerializer serializer);
}
[FlagsAttribute]
public enum YamlDotNet.Serialization.DefaultValuesHandling : Enum {
    public int value__;
    public static DefaultValuesHandling Preserve;
    public static DefaultValuesHandling OmitNull;
    public static DefaultValuesHandling OmitDefaults;
    public static DefaultValuesHandling OmitEmptyCollections;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.Deserializer : object {
    private IValueDeserializer valueDeserializer;
    private Deserializer(IValueDeserializer valueDeserializer);
    public static Deserializer FromValueDeserializer(IValueDeserializer valueDeserializer);
    public sealed virtual T Deserialize(string input);
    public sealed virtual T Deserialize(TextReader input);
    public sealed virtual T Deserialize(IParser parser);
    public sealed virtual object Deserialize(string input);
    public sealed virtual object Deserialize(TextReader input);
    public sealed virtual object Deserialize(IParser parser);
    public sealed virtual object Deserialize(string input, Type type);
    public sealed virtual object Deserialize(TextReader input, Type type);
    public sealed virtual object Deserialize(IParser parser, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class YamlDotNet.Serialization.DeserializerBuilder : BuilderSkeleton`1<DeserializerBuilder> {
    private Lazy`1<IObjectFactory> objectFactory;
    private LazyComponentRegistrationList`2<Nothing, INodeDeserializer> nodeDeserializerFactories;
    private LazyComponentRegistrationList`2<Nothing, INodeTypeResolver> nodeTypeResolverFactories;
    private Dictionary`2<TagName, Type> tagMappings;
    private Dictionary`2<Type, Type> typeMappings;
    private ITypeConverter typeConverter;
    private bool ignoreUnmatched;
    private bool duplicateKeyChecking;
    private bool attemptUnknownTypeDeserialization;
    private bool enforceNullability;
    private bool caseInsensitivePropertyMatching;
    private bool enforceRequiredProperties;
    protected DeserializerBuilder Self { get; }
    protected virtual DeserializerBuilder get_Self();
    public ITypeInspector BuildTypeInspector();
    public DeserializerBuilder WithAttemptingUnquotedStringTypeDeserialization();
    public DeserializerBuilder WithObjectFactory(IObjectFactory objectFactory);
    public DeserializerBuilder WithObjectFactory(Func`2<Type, object> objectFactory);
    public DeserializerBuilder WithNodeDeserializer(INodeDeserializer nodeDeserializer);
    public DeserializerBuilder WithNodeDeserializer(INodeDeserializer nodeDeserializer, Action`1<IRegistrationLocationSelectionSyntax`1<INodeDeserializer>> where);
    public DeserializerBuilder WithNodeDeserializer(WrapperFactory`2<INodeDeserializer, TNodeDeserializer> nodeDeserializerFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<INodeDeserializer>> where);
    public DeserializerBuilder WithoutNodeDeserializer();
    public DeserializerBuilder WithoutNodeDeserializer(Type nodeDeserializerType);
    public DeserializerBuilder WithTypeDiscriminatingNodeDeserializer(Action`1<ITypeDiscriminatingNodeDeserializerOptions> configureTypeDiscriminatingNodeDeserializerOptions, int maxDepth, int maxLength);
    public DeserializerBuilder WithNodeTypeResolver(INodeTypeResolver nodeTypeResolver);
    public DeserializerBuilder WithNodeTypeResolver(INodeTypeResolver nodeTypeResolver, Action`1<IRegistrationLocationSelectionSyntax`1<INodeTypeResolver>> where);
    public DeserializerBuilder WithNodeTypeResolver(WrapperFactory`2<INodeTypeResolver, TNodeTypeResolver> nodeTypeResolverFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<INodeTypeResolver>> where);
    public DeserializerBuilder WithCaseInsensitivePropertyMatching();
    public DeserializerBuilder WithEnforceNullability();
    public DeserializerBuilder WithEnforceRequiredMembers();
    public DeserializerBuilder WithoutNodeTypeResolver();
    public DeserializerBuilder WithoutNodeTypeResolver(Type nodeTypeResolverType);
    public virtual DeserializerBuilder WithTagMapping(TagName tag, Type type);
    public DeserializerBuilder WithTypeMapping();
    public DeserializerBuilder WithoutTagMapping(TagName tag);
    public DeserializerBuilder IgnoreUnmatchedProperties();
    public DeserializerBuilder WithDuplicateKeyChecking();
    public IDeserializer Build();
    public IValueDeserializer BuildValueDeserializer();
    [CompilerGeneratedAttribute]
private IObjectFactory <.ctor>b__12_0();
    [CompilerGeneratedAttribute]
private ITypeInspector <.ctor>b__12_2(ITypeInspector inner);
    [CompilerGeneratedAttribute]
private ITypeInspector <.ctor>b__12_4(ITypeInspector inner);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_6(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_7(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_8(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_10(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_11(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_12(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_13(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_15(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_16(Nothing _);
    [CompilerGeneratedAttribute]
private INodeTypeResolver <.ctor>b__12_17(Nothing _);
    [CompilerGeneratedAttribute]
private INodeTypeResolver <.ctor>b__12_20(Nothing _);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.EmissionPhaseObjectGraphVisitorArgs : object {
    [CompilerGeneratedAttribute]
private IObjectGraphVisitor`1<IEmitter> <InnerVisitor>k__BackingField;
    [CompilerGeneratedAttribute]
private IEventEmitter <EventEmitter>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectSerializer <NestedObjectSerializer>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IYamlTypeConverter> <TypeConverters>k__BackingField;
    private IEnumerable`1<IObjectGraphVisitor`1<Nothing>> preProcessingPhaseVisitors;
    public IObjectGraphVisitor`1<IEmitter> InnerVisitor { get; private set; }
    public IEventEmitter EventEmitter { get; private set; }
    public ObjectSerializer NestedObjectSerializer { get; private set; }
    public IEnumerable`1<IYamlTypeConverter> TypeConverters { get; private set; }
    public EmissionPhaseObjectGraphVisitorArgs(IObjectGraphVisitor`1<IEmitter> innerVisitor, IEventEmitter eventEmitter, IEnumerable`1<IObjectGraphVisitor`1<Nothing>> preProcessingPhaseVisitors, IEnumerable`1<IYamlTypeConverter> typeConverters, ObjectSerializer nestedObjectSerializer);
    [CompilerGeneratedAttribute]
public IObjectGraphVisitor`1<IEmitter> get_InnerVisitor();
    [CompilerGeneratedAttribute]
private void set_InnerVisitor(IObjectGraphVisitor`1<IEmitter> value);
    [CompilerGeneratedAttribute]
public IEventEmitter get_EventEmitter();
    [CompilerGeneratedAttribute]
private void set_EventEmitter(IEventEmitter value);
    [CompilerGeneratedAttribute]
public ObjectSerializer get_NestedObjectSerializer();
    [CompilerGeneratedAttribute]
private void set_NestedObjectSerializer(ObjectSerializer value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IYamlTypeConverter> get_TypeConverters();
    [CompilerGeneratedAttribute]
private void set_TypeConverters(IEnumerable`1<IYamlTypeConverter> value);
    public T GetPreProcessingPhaseObjectGraphVisitor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class YamlDotNet.Serialization.EventEmitters.ChainedEventEmitter : object {
    protected IEventEmitter nextEmitter;
    protected ChainedEventEmitter(IEventEmitter nextEmitter);
    public virtual void Emit(AliasEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(ScalarEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(MappingStartEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(MappingEndEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(SequenceStartEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(SequenceEndEventInfo eventInfo, IEmitter emitter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.EventEmitters.JsonEventEmitter : ChainedEventEmitter {
    private YamlFormatter formatter;
    private INamingConvention enumNamingConvention;
    private ITypeInspector typeInspector;
    private static Regex NumericRegex;
    public JsonEventEmitter(IEventEmitter nextEmitter, YamlFormatter formatter, INamingConvention enumNamingConvention, ITypeInspector typeInspector);
    private static JsonEventEmitter();
    public virtual void Emit(AliasEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(ScalarEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(MappingStartEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(SequenceStartEventInfo eventInfo, IEmitter emitter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.EventEmitters.TypeAssigningEventEmitter : ChainedEventEmitter {
    private IDictionary`2<Type, TagName> tagMappings;
    private bool quoteNecessaryStrings;
    [NullableAttribute("2")]
private Regex isSpecialStringValue_Regex;
    private static string SpecialStrings_Pattern;
    private static string CombinedYaml1_1SpecialStrings_Pattern;
    private ScalarStyle defaultScalarStyle;
    private YamlFormatter formatter;
    private INamingConvention enumNamingConvention;
    private ITypeInspector typeInspector;
    public TypeAssigningEventEmitter(IEventEmitter nextEmitter, IDictionary`2<Type, TagName> tagMappings, bool quoteNecessaryStrings, bool quoteYaml1_1Strings, ScalarStyle defaultScalarStyle, YamlFormatter formatter, INamingConvention enumNamingConvention, ITypeInspector typeInspector);
    private static TypeAssigningEventEmitter();
    public virtual void Emit(ScalarEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(MappingStartEventInfo eventInfo, IEmitter emitter);
    public virtual void Emit(SequenceStartEventInfo eventInfo, IEmitter emitter);
    private void AssignTypeIfNeeded(ObjectEventInfo eventInfo);
    private bool IsSpecialStringValue(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.EventEmitters.WriterEventEmitter : object {
    private sealed virtual override void YamlDotNet.Serialization.IEventEmitter.Emit(AliasEventInfo eventInfo, IEmitter emitter);
    private sealed virtual override void YamlDotNet.Serialization.IEventEmitter.Emit(ScalarEventInfo eventInfo, IEmitter emitter);
    private sealed virtual override void YamlDotNet.Serialization.IEventEmitter.Emit(MappingStartEventInfo eventInfo, IEmitter emitter);
    private sealed virtual override void YamlDotNet.Serialization.IEventEmitter.Emit(MappingEndEventInfo eventInfo, IEmitter emitter);
    private sealed virtual override void YamlDotNet.Serialization.IEventEmitter.Emit(SequenceStartEventInfo eventInfo, IEmitter emitter);
    private sealed virtual override void YamlDotNet.Serialization.IEventEmitter.Emit(SequenceEndEventInfo eventInfo, IEmitter emitter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class YamlDotNet.Serialization.EventInfo : object {
    [CompilerGeneratedAttribute]
private IObjectDescriptor <Source>k__BackingField;
    public IObjectDescriptor Source { get; }
    protected EventInfo(IObjectDescriptor source);
    [CompilerGeneratedAttribute]
public IObjectDescriptor get_Source();
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.IAliasProvider {
    public abstract virtual AnchorName GetAlias(object target);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.IDeserializer {
    public abstract virtual T Deserialize(string input);
    public abstract virtual T Deserialize(TextReader input);
    public abstract virtual T Deserialize(IParser parser);
    public abstract virtual object Deserialize(string input);
    public abstract virtual object Deserialize(TextReader input);
    public abstract virtual object Deserialize(IParser parser);
    public abstract virtual object Deserialize(string input, Type type);
    public abstract virtual object Deserialize(TextReader input, Type type);
    public abstract virtual object Deserialize(IParser parser, Type type);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.IEventEmitter {
    public abstract virtual void Emit(AliasEventInfo eventInfo, IEmitter emitter);
    public abstract virtual void Emit(ScalarEventInfo eventInfo, IEmitter emitter);
    public abstract virtual void Emit(MappingStartEventInfo eventInfo, IEmitter emitter);
    public abstract virtual void Emit(MappingEndEventInfo eventInfo, IEmitter emitter);
    public abstract virtual void Emit(SequenceStartEventInfo eventInfo, IEmitter emitter);
    public abstract virtual void Emit(SequenceEndEventInfo eventInfo, IEmitter emitter);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.INamingConvention {
    public abstract virtual string Apply(string value);
    public abstract virtual string Reverse(string value);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.INodeDeserializer {
    public abstract virtual bool Deserialize(IParser reader, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value, ObjectDeserializer rootDeserializer);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.INodeTypeResolver {
    public abstract virtual bool Resolve(NodeEvent nodeEvent, Type& currentType);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.IObjectAccessor {
    public abstract virtual void Set(string name, object target, object value);
    public abstract virtual object Read(string name, object target);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.IObjectDescriptor {
    [NullableAttribute("2")]
public object Value { get; }
    public Type Type { get; }
    public Type StaticType { get; }
    public ScalarStyle ScalarStyle { get; }
    [NullableContextAttribute("2")]
public abstract virtual object get_Value();
    public abstract virtual Type get_Type();
    public abstract virtual Type get_StaticType();
    public abstract virtual ScalarStyle get_ScalarStyle();
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.IObjectFactory {
    public abstract virtual object Create(Type type);
    public abstract virtual object CreatePrimitive(Type type);
    public abstract virtual bool GetDictionary(IObjectDescriptor descriptor, IDictionary& dictionary, Type[]& genericArguments);
    public abstract virtual Type GetValueType(Type type);
    public abstract virtual void ExecuteOnDeserializing(object value);
    public abstract virtual void ExecuteOnDeserialized(object value);
    public abstract virtual void ExecuteOnSerializing(object value);
    public abstract virtual void ExecuteOnSerialized(object value);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.IObjectGraphTraversalStrategy {
    public abstract virtual void Traverse(IObjectDescriptor graph, IObjectGraphVisitor`1<TContext> visitor, TContext context, ObjectSerializer serializer);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.IObjectGraphVisitor`1 {
    public abstract virtual bool Enter(IPropertyDescriptor propertyDescriptor, IObjectDescriptor value, TContext context, ObjectSerializer serializer);
    public abstract virtual bool EnterMapping(IObjectDescriptor key, IObjectDescriptor value, TContext context, ObjectSerializer serializer);
    public abstract virtual bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, TContext context, ObjectSerializer serializer);
    public abstract virtual void VisitScalar(IObjectDescriptor scalar, TContext context, ObjectSerializer serializer);
    public abstract virtual void VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, TContext context, ObjectSerializer serializer);
    public abstract virtual void VisitMappingEnd(IObjectDescriptor mapping, TContext context, ObjectSerializer serializer);
    public abstract virtual void VisitSequenceStart(IObjectDescriptor sequence, Type elementType, TContext context, ObjectSerializer serializer);
    public abstract virtual void VisitSequenceEnd(IObjectDescriptor sequence, TContext context, ObjectSerializer serializer);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.IPropertyDescriptor {
    public string Name { get; }
    public bool AllowNulls { get; }
    public bool CanWrite { get; }
    public Type Type { get; }
    [NullableAttribute("2")]
public Type TypeOverride { get; public set; }
    public int Order { get; public set; }
    public ScalarStyle ScalarStyle { get; public set; }
    public bool Required { get; }
    [NullableAttribute("2")]
public Type ConverterType { get; }
    public abstract virtual string get_Name();
    public abstract virtual bool get_AllowNulls();
    public abstract virtual bool get_CanWrite();
    public abstract virtual Type get_Type();
    [NullableContextAttribute("2")]
public abstract virtual Type get_TypeOverride();
    [NullableContextAttribute("2")]
public abstract virtual void set_TypeOverride(Type value);
    public abstract virtual int get_Order();
    public abstract virtual void set_Order(int value);
    public abstract virtual ScalarStyle get_ScalarStyle();
    public abstract virtual void set_ScalarStyle(ScalarStyle value);
    public abstract virtual bool get_Required();
    [NullableContextAttribute("2")]
public abstract virtual Type get_ConverterType();
    [NullableContextAttribute("0")]
public abstract virtual T GetCustomAttribute();
    public abstract virtual IObjectDescriptor Read(object target);
    public abstract virtual void Write(object target, object value);
}
public interface YamlDotNet.Serialization.IRegistrationLocationSelectionSyntax`1 {
    public abstract virtual void InsteadOf();
    public abstract virtual void Before();
    public abstract virtual void After();
    public abstract virtual void OnTop();
    public abstract virtual void OnBottom();
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.ISerializer {
    public abstract virtual string Serialize(object graph);
    public abstract virtual string Serialize(object graph, Type type);
    public abstract virtual void Serialize(TextWriter writer, object graph);
    public abstract virtual void Serialize(TextWriter writer, object graph, Type type);
    public abstract virtual void Serialize(IEmitter emitter, object graph);
    public abstract virtual void Serialize(IEmitter emitter, object graph, Type type);
}
public interface YamlDotNet.Serialization.ITrackingRegistrationLocationSelectionSyntax`1 {
    public abstract virtual void InsteadOf();
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.ITypeInspector {
    public abstract virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
    public abstract virtual IPropertyDescriptor GetProperty(Type type, object container, string name, bool ignoreUnmatched, bool caseInsensitivePropertyMatching);
    public abstract virtual string GetEnumName(Type enumType, string name);
    public abstract virtual string GetEnumValue(object enumValue);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.ITypeResolver {
    public abstract virtual Type Resolve(Type staticType, object actualValue);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.IValueDeserializer {
    public abstract virtual object DeserializeValue(IParser parser, Type expectedType, SerializerState state, IValueDeserializer nestedObjectDeserializer);
}
public interface YamlDotNet.Serialization.IValuePromise {
    [CompilerGeneratedAttribute]
public abstract virtual void add_ValueAvailable(Action`1<object> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ValueAvailable(Action`1<object> value);
}
[NullableContextAttribute("2")]
public interface YamlDotNet.Serialization.IValueSerializer {
    public abstract virtual void SerializeValue(IEmitter emitter, object value, Type type);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.IYamlConvertible {
    public abstract virtual void Read(IParser parser, Type expectedType, ObjectDeserializer nestedObjectDeserializer);
    public abstract virtual void Write(IEmitter emitter, ObjectSerializer nestedObjectSerializer);
}
[NullableContextAttribute("1")]
[ObsoleteAttribute("Please use IYamlConvertible instead")]
public interface YamlDotNet.Serialization.IYamlSerializable {
    public abstract virtual void ReadYaml(IParser parser);
    public abstract virtual void WriteYaml(IEmitter emitter);
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.IYamlTypeConverter {
    public abstract virtual bool Accepts(Type type);
    public abstract virtual object ReadYaml(IParser parser, Type type, ObjectDeserializer rootDeserializer);
    public abstract virtual void WriteYaml(IEmitter emitter, object value, Type type, ObjectSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class YamlDotNet.Serialization.LazyComponentRegistrationList`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<LazyComponentRegistration<TArgument, TComponent>> entries;
    public int Count { get; }
    public IEnumerable`1<Func`2<TArgument, TComponent>> InReverseOrder { get; }
    public LazyComponentRegistrationList`2<TArgument, TComponent> Clone();
    public void Clear();
    public void Add(Type componentType, Func`2<TArgument, TComponent> factory);
    public void Remove(Type componentType);
    public int get_Count();
    [IteratorStateMachineAttribute("YamlDotNet.Serialization.LazyComponentRegistrationList`2/<get_InReverseOrder>d__10")]
public IEnumerable`1<Func`2<TArgument, TComponent>> get_InReverseOrder();
    public IRegistrationLocationSelectionSyntax`1<TComponent> CreateRegistrationLocationSelector(Type componentType, Func`2<TArgument, TComponent> factory);
    public ITrackingRegistrationLocationSelectionSyntax`1<TComponent> CreateTrackingRegistrationLocationSelector(Type componentType, Func`3<TComponent, TArgument, TComponent> factory);
    public sealed virtual IEnumerator`1<Func`2<TArgument, TComponent>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private int IndexOfRegistration(Type registrationType);
    private void EnsureNoDuplicateRegistrationType(Type componentType);
    [NullableContextAttribute("2")]
private int EnsureRegistrationExists();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class YamlDotNet.Serialization.LazyComponentRegistrationListExtensions : object {
    [ExtensionAttribute]
public static TComponent BuildComponentChain(LazyComponentRegistrationList`2<TComponent, TComponent> registrations, TComponent innerComponent);
    [ExtensionAttribute]
public static TComponent BuildComponentChain(LazyComponentRegistrationList`2<TArgument, TComponent> registrations, TComponent innerComponent, Func`2<TComponent, TArgument> argumentBuilder);
    [ExtensionAttribute]
public static List`1<TComponent> BuildComponentList(LazyComponentRegistrationList`2<Nothing, TComponent> registrations);
    [ExtensionAttribute]
public static List`1<TComponent> BuildComponentList(LazyComponentRegistrationList`2<TArgument, TComponent> registrations, TArgument argument);
}
public class YamlDotNet.Serialization.MappingEndEventInfo : EventInfo {
    [NullableContextAttribute("1")]
public MappingEndEventInfo(IObjectDescriptor source);
}
public class YamlDotNet.Serialization.MappingStartEventInfo : ObjectEventInfo {
    [CompilerGeneratedAttribute]
private bool <IsImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private MappingStyle <Style>k__BackingField;
    public bool IsImplicit { get; public set; }
    public MappingStyle Style { get; public set; }
    [NullableContextAttribute("1")]
public MappingStartEventInfo(IObjectDescriptor source);
    [CompilerGeneratedAttribute]
public bool get_IsImplicit();
    [CompilerGeneratedAttribute]
public void set_IsImplicit(bool value);
    [CompilerGeneratedAttribute]
public MappingStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(MappingStyle value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NamingConventions.CamelCaseNamingConvention : object {
    public static INamingConvention Instance;
    private static CamelCaseNamingConvention();
    public sealed virtual string Apply(string value);
    public sealed virtual string Reverse(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NamingConventions.HyphenatedNamingConvention : object {
    public static INamingConvention Instance;
    private static HyphenatedNamingConvention();
    public sealed virtual string Apply(string value);
    public sealed virtual string Reverse(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NamingConventions.LowerCaseNamingConvention : object {
    public static INamingConvention Instance;
    private static LowerCaseNamingConvention();
    public sealed virtual string Apply(string value);
    public sealed virtual string Reverse(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NamingConventions.NullNamingConvention : object {
    public static INamingConvention Instance;
    private static NullNamingConvention();
    public sealed virtual string Apply(string value);
    public sealed virtual string Reverse(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NamingConventions.PascalCaseNamingConvention : object {
    public static INamingConvention Instance;
    private static PascalCaseNamingConvention();
    public sealed virtual string Apply(string value);
    public sealed virtual string Reverse(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NamingConventions.UnderscoredNamingConvention : object {
    public static INamingConvention Instance;
    private static UnderscoredNamingConvention();
    public sealed virtual string Apply(string value);
    public sealed virtual string Reverse(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NodeDeserializers.ArrayNodeDeserializer : object {
    private INamingConvention enumNamingConvention;
    private ITypeInspector typeInspector;
    public ArrayNodeDeserializer(INamingConvention enumNamingConvention, ITypeInspector typeInspector);
    public sealed virtual bool Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value, ObjectDeserializer rootDeserializer);
}
public abstract class YamlDotNet.Serialization.NodeDeserializers.CollectionDeserializer : object {
    [NullableContextAttribute("1")]
protected static void DeserializeHelper(Type tItem, IParser parser, Func`3<IParser, Type, object> nestedObjectDeserializer, IList result, bool canUpdate, IObjectFactory objectFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NodeDeserializers.CollectionNodeDeserializer : object {
    private IObjectFactory objectFactory;
    private INamingConvention enumNamingConvention;
    private ITypeInspector typeInspector;
    public CollectionNodeDeserializer(IObjectFactory objectFactory, INamingConvention enumNamingConvention, ITypeInspector typeInspector);
    public sealed virtual bool Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value, ObjectDeserializer rootDeserializer);
    internal static void DeserializeHelper(Type tItem, IParser parser, Func`3<IParser, Type, object> nestedObjectDeserializer, IList result, bool canUpdate, INamingConvention enumNamingConvention, ITypeInspector typeInspector, Action`2<int, object> promiseResolvedHandler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class YamlDotNet.Serialization.NodeDeserializers.DictionaryDeserializer : object {
    private bool duplicateKeyChecking;
    public DictionaryDeserializer(bool duplicateKeyChecking);
    private void TryAssign(IDictionary result, object key, object value, MappingStart propertyName);
    protected virtual void Deserialize(Type tKey, Type tValue, IParser parser, Func`3<IParser, Type, object> nestedObjectDeserializer, IDictionary result, ObjectDeserializer rootDeserializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NodeDeserializers.DictionaryNodeDeserializer : DictionaryDeserializer {
    private IObjectFactory objectFactory;
    public DictionaryNodeDeserializer(IObjectFactory objectFactory, bool duplicateKeyChecking);
    public sealed virtual bool Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value, ObjectDeserializer rootDeserializer);
}
public class YamlDotNet.Serialization.NodeDeserializers.EnumerableNodeDeserializer : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value, ObjectDeserializer rootDeserializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NodeDeserializers.FsharpListNodeDeserializer : object {
    private ITypeInspector typeInspector;
    private INamingConvention enumNamingConvention;
    public FsharpListNodeDeserializer(ITypeInspector typeInspector, INamingConvention enumNamingConvention);
    public sealed virtual bool Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value, ObjectDeserializer rootDeserializer);
}
public class YamlDotNet.Serialization.NodeDeserializers.NullNodeDeserializer : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value, ObjectDeserializer rootDeserializer);
    [NullableContextAttribute("1")]
private static bool NodeIsNull(NodeEvent nodeEvent);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NodeDeserializers.ObjectNodeDeserializer : object {
    private IObjectFactory objectFactory;
    private ITypeInspector typeInspector;
    private bool ignoreUnmatched;
    private bool duplicateKeyChecking;
    private ITypeConverter typeConverter;
    private INamingConvention enumNamingConvention;
    private bool enforceNullability;
    private bool caseInsensitivePropertyMatching;
    private bool enforceRequiredProperties;
    private TypeConverterCache typeConverters;
    public ObjectNodeDeserializer(IObjectFactory objectFactory, ITypeInspector typeInspector, bool ignoreUnmatched, bool duplicateKeyChecking, ITypeConverter typeConverter, INamingConvention enumNamingConvention, bool enforceNullability, bool caseInsensitivePropertyMatching, bool enforceRequiredProperties, IEnumerable`1<IYamlTypeConverter> typeConverters);
    public sealed virtual bool Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value, ObjectDeserializer rootDeserializer);
    public void NullCheck(object value, IPropertyDescriptor property, Scalar propertyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NodeDeserializers.ScalarNodeDeserializer : object {
    private static string BooleanTruePattern;
    private static string BooleanFalsePattern;
    private bool attemptUnknownTypeDeserialization;
    private ITypeConverter typeConverter;
    private ITypeInspector typeInspector;
    private YamlFormatter formatter;
    private INamingConvention enumNamingConvention;
    public ScalarNodeDeserializer(bool attemptUnknownTypeDeserialization, ITypeConverter typeConverter, ITypeInspector typeInspector, YamlFormatter formatter, INamingConvention enumNamingConvention);
    public sealed virtual bool Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value, ObjectDeserializer rootDeserializer);
    private static bool DeserializeBooleanHelper(string value);
    private object DeserializeIntegerHelper(TypeCode typeCode, string value);
    private static object CastInteger(long number, TypeCode typeCode);
    private static object CastInteger(ulong number, TypeCode typeCode);
    private object AttemptUnknownTypeDeserialization(Scalar value);
    private static bool TryAndSwallow(Func`1<object> attempt, Object& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NodeDeserializers.StaticArrayNodeDeserializer : object {
    private StaticObjectFactory factory;
    public StaticArrayNodeDeserializer(StaticObjectFactory factory);
    public sealed virtual bool Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value, ObjectDeserializer rootDeserializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NodeDeserializers.StaticCollectionNodeDeserializer : object {
    private StaticObjectFactory factory;
    public StaticCollectionNodeDeserializer(StaticObjectFactory factory);
    public sealed virtual bool Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value, ObjectDeserializer rootDeserializer);
    internal static void DeserializeHelper(Type tItem, IParser parser, Func`3<IParser, Type, object> nestedObjectDeserializer, IList result, IObjectFactory factory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NodeDeserializers.StaticDictionaryNodeDeserializer : DictionaryDeserializer {
    private StaticObjectFactory objectFactory;
    public StaticDictionaryNodeDeserializer(StaticObjectFactory objectFactory, bool duplicateKeyChecking);
    public sealed virtual bool Deserialize(IParser reader, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value, ObjectDeserializer rootDeserializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NodeDeserializers.TypeConverterNodeDeserializer : object {
    private TypeConverterCache converters;
    public TypeConverterNodeDeserializer(IEnumerable`1<IYamlTypeConverter> converters);
    public sealed virtual bool Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value, ObjectDeserializer rootDeserializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NodeDeserializers.YamlConvertibleNodeDeserializer : object {
    private IObjectFactory objectFactory;
    public YamlConvertibleNodeDeserializer(IObjectFactory objectFactory);
    public sealed virtual bool Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value, ObjectDeserializer rootDeserializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NodeDeserializers.YamlSerializableNodeDeserializer : object {
    private IObjectFactory objectFactory;
    public YamlSerializableNodeDeserializer(IObjectFactory objectFactory);
    public sealed virtual bool Deserialize(IParser parser, Type expectedType, Func`3<IParser, Type, object> nestedObjectDeserializer, Object& value, ObjectDeserializer rootDeserializer);
}
public class YamlDotNet.Serialization.NodeTypeResolvers.DefaultContainersNodeTypeResolver : object {
    [NullableContextAttribute("1")]
private sealed virtual override bool YamlDotNet.Serialization.INodeTypeResolver.Resolve(NodeEvent nodeEvent, Type& currentType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NodeTypeResolvers.MappingNodeTypeResolver : object {
    private IDictionary`2<Type, Type> mappings;
    public MappingNodeTypeResolver(IDictionary`2<Type, Type> mappings);
    public sealed virtual bool Resolve(NodeEvent nodeEvent, Type& currentType);
}
public class YamlDotNet.Serialization.NodeTypeResolvers.PreventUnknownTagsNodeTypeResolver : object {
    [NullableContextAttribute("1")]
private sealed virtual override bool YamlDotNet.Serialization.INodeTypeResolver.Resolve(NodeEvent nodeEvent, Type& currentType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.NodeTypeResolvers.TagNodeTypeResolver : object {
    private IDictionary`2<TagName, Type> tagMappings;
    public TagNodeTypeResolver(IDictionary`2<TagName, Type> tagMappings);
    private sealed virtual override bool YamlDotNet.Serialization.INodeTypeResolver.Resolve(NodeEvent nodeEvent, Type& currentType);
}
[ObsoleteAttribute("The mechanism that this class uses to specify type names is non-standard. Register the tags explicitly instead of using this convention.")]
public class YamlDotNet.Serialization.NodeTypeResolvers.TypeNameInTagNodeTypeResolver : object {
    [NullableContextAttribute("1")]
private sealed virtual override bool YamlDotNet.Serialization.INodeTypeResolver.Resolve(NodeEvent nodeEvent, Type& currentType);
}
public class YamlDotNet.Serialization.NodeTypeResolvers.YamlConvertibleTypeResolver : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Resolve(NodeEvent nodeEvent, Type& currentType);
}
public class YamlDotNet.Serialization.NodeTypeResolvers.YamlSerializableTypeResolver : object {
    [NullableContextAttribute("1")]
public sealed virtual bool Resolve(NodeEvent nodeEvent, Type& currentType);
}
public class YamlDotNet.Serialization.Nothing : ValueType {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.ObjectDescriptor : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <StaticType>k__BackingField;
    [CompilerGeneratedAttribute]
private ScalarStyle <ScalarStyle>k__BackingField;
    [NullableAttribute("2")]
public object Value { get; private set; }
    public Type Type { get; private set; }
    public Type StaticType { get; private set; }
    public ScalarStyle ScalarStyle { get; private set; }
    public ObjectDescriptor(object value, Type type, Type staticType);
    public ObjectDescriptor(object value, Type type, Type staticType, ScalarStyle scalarStyle);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual object get_Value();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Value(object value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_StaticType();
    [CompilerGeneratedAttribute]
private void set_StaticType(Type value);
    [CompilerGeneratedAttribute]
public sealed virtual ScalarStyle get_ScalarStyle();
    [CompilerGeneratedAttribute]
private void set_ScalarStyle(ScalarStyle value);
}
[ExtensionAttribute]
public static class YamlDotNet.Serialization.ObjectDescriptorExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static object NonNullValue(IObjectDescriptor objectDescriptor);
}
public class YamlDotNet.Serialization.ObjectDeserializer : MulticastDelegate {
    public ObjectDeserializer(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual object Invoke(Type type);
    public virtual IAsyncResult BeginInvoke(Type type, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
public class YamlDotNet.Serialization.ObjectEventInfo : EventInfo {
    [CompilerGeneratedAttribute]
private AnchorName <Anchor>k__BackingField;
    [CompilerGeneratedAttribute]
private TagName <Tag>k__BackingField;
    public AnchorName Anchor { get; public set; }
    public TagName Tag { get; public set; }
    [NullableContextAttribute("1")]
protected ObjectEventInfo(IObjectDescriptor source);
    [CompilerGeneratedAttribute]
public AnchorName get_Anchor();
    [CompilerGeneratedAttribute]
public void set_Anchor(AnchorName value);
    [CompilerGeneratedAttribute]
public TagName get_Tag();
    [CompilerGeneratedAttribute]
public void set_Tag(TagName value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.ObjectFactories.DefaultObjectFactory : ObjectFactoryBase {
    private Dictionary`2<Type, ConcurrentDictionary`2<Type, MethodInfo[]>> stateMethods;
    private Dictionary`2<Type, Type> defaultGenericInterfaceImplementations;
    private Dictionary`2<Type, Type> defaultNonGenericInterfaceImplementations;
    private Settings settings;
    public DefaultObjectFactory(IDictionary`2<Type, Type> mappings);
    public DefaultObjectFactory(IDictionary`2<Type, Type> mappings, Settings settings);
    public virtual object Create(Type type);
    public virtual void ExecuteOnDeserialized(object value);
    public virtual void ExecuteOnDeserializing(object value);
    public virtual void ExecuteOnSerialized(object value);
    public virtual void ExecuteOnSerializing(object value);
    private void ExecuteState(Type attributeType, object value);
    private MethodInfo[] GetStateMethods(Type attributeType, Type valueType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.ObjectFactories.LambdaObjectFactory : ObjectFactoryBase {
    private Func`2<Type, object> factory;
    public LambdaObjectFactory(Func`2<Type, object> factory);
    public virtual object Create(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class YamlDotNet.Serialization.ObjectFactories.ObjectFactoryBase : object {
    public abstract virtual object Create(Type type);
    public virtual object CreatePrimitive(Type type);
    public virtual void ExecuteOnDeserialized(object value);
    public virtual void ExecuteOnDeserializing(object value);
    public virtual void ExecuteOnSerialized(object value);
    public virtual void ExecuteOnSerializing(object value);
    public virtual bool GetDictionary(IObjectDescriptor descriptor, IDictionary& dictionary, Type[]& genericArguments);
    public virtual Type GetValueType(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class YamlDotNet.Serialization.ObjectFactories.StaticObjectFactory : object {
    public abstract virtual object Create(Type type);
    public abstract virtual Array CreateArray(Type type, int count);
    public abstract virtual bool IsDictionary(Type type);
    public abstract virtual bool IsArray(Type type);
    public abstract virtual bool IsList(Type type);
    public abstract virtual Type GetKeyType(Type type);
    public abstract virtual Type GetValueType(Type type);
    public virtual object CreatePrimitive(Type type);
    public sealed virtual bool GetDictionary(IObjectDescriptor descriptor, IDictionary& dictionary, Type[]& genericArguments);
    public abstract virtual void ExecuteOnDeserializing(object value);
    public abstract virtual void ExecuteOnDeserialized(object value);
    public abstract virtual void ExecuteOnSerializing(object value);
    public abstract virtual void ExecuteOnSerialized(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.ObjectGraphTraversalStrategies.FullObjectGraphTraversalStrategy : object {
    private int maxRecursion;
    private ITypeInspector typeDescriptor;
    private ITypeResolver typeResolver;
    private INamingConvention namingConvention;
    private IObjectFactory objectFactory;
    public FullObjectGraphTraversalStrategy(ITypeInspector typeDescriptor, ITypeResolver typeResolver, int maxRecursion, INamingConvention namingConvention, IObjectFactory objectFactory);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphTraversalStrategy.Traverse(IObjectDescriptor graph, IObjectGraphVisitor`1<TContext> visitor, TContext context, ObjectSerializer serializer);
    protected virtual void Traverse(IPropertyDescriptor propertyDescriptor, object name, IObjectDescriptor value, IObjectGraphVisitor`1<TContext> visitor, TContext context, Stack`1<ObjectPathSegment> path, ObjectSerializer serializer);
    protected virtual void TraverseObject(IPropertyDescriptor propertyDescriptor, IObjectDescriptor value, IObjectGraphVisitor`1<TContext> visitor, TContext context, Stack`1<ObjectPathSegment> path, ObjectSerializer serializer);
    protected virtual void TraverseDictionary(IPropertyDescriptor propertyDescriptor, IObjectDescriptor dictionary, IObjectGraphVisitor`1<TContext> visitor, Type keyType, Type valueType, TContext context, Stack`1<ObjectPathSegment> path, ObjectSerializer serializer);
    private void TraverseList(IPropertyDescriptor propertyDescriptor, IObjectDescriptor value, IObjectGraphVisitor`1<TContext> visitor, TContext context, Stack`1<ObjectPathSegment> path, ObjectSerializer serializer);
    protected virtual void TraverseProperties(IObjectDescriptor value, IObjectGraphVisitor`1<TContext> visitor, TContext context, Stack`1<ObjectPathSegment> path, ObjectSerializer serializer);
    private ObjectDescriptor GetObjectDescriptor(object value, Type staticType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.ObjectGraphTraversalStrategies.RoundtripObjectGraphTraversalStrategy : FullObjectGraphTraversalStrategy {
    private TypeConverterCache converters;
    private Settings settings;
    public RoundtripObjectGraphTraversalStrategy(IEnumerable`1<IYamlTypeConverter> converters, ITypeInspector typeDescriptor, ITypeResolver typeResolver, int maxRecursion, INamingConvention namingConvention, Settings settings, IObjectFactory factory);
    protected virtual void TraverseProperties(IObjectDescriptor value, IObjectGraphVisitor`1<TContext> visitor, TContext context, Stack`1<ObjectPathSegment> path, ObjectSerializer serializer);
}
public class YamlDotNet.Serialization.ObjectGraphTraversalStrategyFactory : MulticastDelegate {
    public ObjectGraphTraversalStrategyFactory(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IObjectGraphTraversalStrategy Invoke(ITypeInspector typeInspector, ITypeResolver typeResolver, IEnumerable`1<IYamlTypeConverter> typeConverters, int maximumRecursion);
    public virtual IAsyncResult BeginInvoke(ITypeInspector typeInspector, ITypeResolver typeResolver, IEnumerable`1<IYamlTypeConverter> typeConverters, int maximumRecursion, AsyncCallback callback, object object);
    public virtual IObjectGraphTraversalStrategy EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.ObjectGraphVisitors.AnchorAssigner : PreProcessingPhaseObjectGraphVisitorSkeleton {
    private Dictionary`2<object, AnchorAssignment> assignments;
    private UInt32 nextId;
    public AnchorAssigner(IEnumerable`1<IYamlTypeConverter> typeConverters);
    protected virtual bool Enter(IObjectDescriptor value, ObjectSerializer serializer);
    protected virtual bool EnterMapping(IObjectDescriptor key, IObjectDescriptor value, ObjectSerializer serializer);
    protected virtual bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, ObjectSerializer serializer);
    protected virtual void VisitScalar(IObjectDescriptor scalar, ObjectSerializer serializer);
    protected virtual void VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, ObjectSerializer serializer);
    protected virtual void VisitMappingEnd(IObjectDescriptor mapping, ObjectSerializer serializer);
    protected virtual void VisitSequenceStart(IObjectDescriptor sequence, Type elementType, ObjectSerializer serializer);
    protected virtual void VisitSequenceEnd(IObjectDescriptor sequence, ObjectSerializer serializer);
    private void VisitObject(IObjectDescriptor value);
    private sealed virtual override AnchorName YamlDotNet.Serialization.IAliasProvider.GetAlias(object target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.ObjectGraphVisitors.AnchorAssigningObjectGraphVisitor : ChainedObjectGraphVisitor {
    private IEventEmitter eventEmitter;
    private IAliasProvider aliasProvider;
    private HashSet`1<AnchorName> emittedAliases;
    public AnchorAssigningObjectGraphVisitor(IObjectGraphVisitor`1<IEmitter> nextVisitor, IEventEmitter eventEmitter, IAliasProvider aliasProvider);
    public virtual bool Enter(IPropertyDescriptor propertyDescriptor, IObjectDescriptor value, IEmitter context, ObjectSerializer serializer);
    public virtual void VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, IEmitter context, ObjectSerializer serializer);
    public virtual void VisitSequenceStart(IObjectDescriptor sequence, Type elementType, IEmitter context, ObjectSerializer serializer);
    public virtual void VisitScalar(IObjectDescriptor scalar, IEmitter context, ObjectSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class YamlDotNet.Serialization.ObjectGraphVisitors.ChainedObjectGraphVisitor : object {
    private IObjectGraphVisitor`1<IEmitter> nextVisitor;
    protected ChainedObjectGraphVisitor(IObjectGraphVisitor`1<IEmitter> nextVisitor);
    public virtual bool Enter(IPropertyDescriptor propertyDescriptor, IObjectDescriptor value, IEmitter context, ObjectSerializer serializer);
    public virtual bool EnterMapping(IObjectDescriptor key, IObjectDescriptor value, IEmitter context, ObjectSerializer serializer);
    public virtual bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, IEmitter context, ObjectSerializer serializer);
    public virtual void VisitScalar(IObjectDescriptor scalar, IEmitter context, ObjectSerializer serializer);
    public virtual void VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, IEmitter context, ObjectSerializer serializer);
    public virtual void VisitMappingEnd(IObjectDescriptor mapping, IEmitter context, ObjectSerializer serializer);
    public virtual void VisitSequenceStart(IObjectDescriptor sequence, Type elementType, IEmitter context, ObjectSerializer serializer);
    public virtual void VisitSequenceEnd(IObjectDescriptor sequence, IEmitter context, ObjectSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.ObjectGraphVisitors.CommentsObjectGraphVisitor : ChainedObjectGraphVisitor {
    public CommentsObjectGraphVisitor(IObjectGraphVisitor`1<IEmitter> nextVisitor);
    public virtual bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, IEmitter context, ObjectSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.ObjectGraphVisitors.CustomSerializationObjectGraphVisitor : ChainedObjectGraphVisitor {
    private TypeConverterCache typeConverters;
    private ObjectSerializer nestedObjectSerializer;
    public CustomSerializationObjectGraphVisitor(IObjectGraphVisitor`1<IEmitter> nextVisitor, IEnumerable`1<IYamlTypeConverter> typeConverters, ObjectSerializer nestedObjectSerializer);
    public virtual bool Enter(IPropertyDescriptor propertyDescriptor, IObjectDescriptor value, IEmitter context, ObjectSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.ObjectGraphVisitors.DefaultExclusiveObjectGraphVisitor : ChainedObjectGraphVisitor {
    public DefaultExclusiveObjectGraphVisitor(IObjectGraphVisitor`1<IEmitter> nextVisitor);
    private static object GetDefault(Type type);
    public virtual bool EnterMapping(IObjectDescriptor key, IObjectDescriptor value, IEmitter context, ObjectSerializer serializer);
    public virtual bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, IEmitter context, ObjectSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.ObjectGraphVisitors.DefaultValuesObjectGraphVisitor : ChainedObjectGraphVisitor {
    private DefaultValuesHandling handling;
    private IObjectFactory factory;
    public DefaultValuesObjectGraphVisitor(DefaultValuesHandling handling, IObjectGraphVisitor`1<IEmitter> nextVisitor, IObjectFactory factory);
    private object GetDefault(Type type);
    public virtual bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, IEmitter context, ObjectSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.ObjectGraphVisitors.EmittingObjectGraphVisitor : object {
    private IEventEmitter eventEmitter;
    public EmittingObjectGraphVisitor(IEventEmitter eventEmitter);
    private sealed virtual override bool YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Core.IEmitter>.Enter(IPropertyDescriptor propertyDescriptor, IObjectDescriptor value, IEmitter context, ObjectSerializer serializer);
    private sealed virtual override bool YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Core.IEmitter>.EnterMapping(IObjectDescriptor key, IObjectDescriptor value, IEmitter context, ObjectSerializer serializer);
    private sealed virtual override bool YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Core.IEmitter>.EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, IEmitter context, ObjectSerializer serializer);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Core.IEmitter>.VisitScalar(IObjectDescriptor scalar, IEmitter context, ObjectSerializer serializer);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Core.IEmitter>.VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, IEmitter context, ObjectSerializer serializer);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Core.IEmitter>.VisitMappingEnd(IObjectDescriptor mapping, IEmitter context, ObjectSerializer serializer);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Core.IEmitter>.VisitSequenceStart(IObjectDescriptor sequence, Type elementType, IEmitter context, ObjectSerializer serializer);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Core.IEmitter>.VisitSequenceEnd(IObjectDescriptor sequence, IEmitter context, ObjectSerializer serializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class YamlDotNet.Serialization.ObjectGraphVisitors.PreProcessingPhaseObjectGraphVisitorSkeleton : object {
    protected IEnumerable`1<IYamlTypeConverter> typeConverters;
    private TypeConverterCache typeConverterCache;
    public PreProcessingPhaseObjectGraphVisitorSkeleton(IEnumerable`1<IYamlTypeConverter> typeConverters);
    private sealed virtual override bool YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Serialization.Nothing>.Enter(IPropertyDescriptor propertyDescriptor, IObjectDescriptor value, Nothing context, ObjectSerializer serializer);
    private sealed virtual override bool YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Serialization.Nothing>.EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, Nothing context, ObjectSerializer serializer);
    private sealed virtual override bool YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Serialization.Nothing>.EnterMapping(IObjectDescriptor key, IObjectDescriptor value, Nothing context, ObjectSerializer serializer);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Serialization.Nothing>.VisitMappingEnd(IObjectDescriptor mapping, Nothing context, ObjectSerializer serializer);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Serialization.Nothing>.VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, Nothing context, ObjectSerializer serializer);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Serialization.Nothing>.VisitScalar(IObjectDescriptor scalar, Nothing context, ObjectSerializer serializer);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Serialization.Nothing>.VisitSequenceEnd(IObjectDescriptor sequence, Nothing context, ObjectSerializer serializer);
    private sealed virtual override void YamlDotNet.Serialization.IObjectGraphVisitor<YamlDotNet.Serialization.Nothing>.VisitSequenceStart(IObjectDescriptor sequence, Type elementType, Nothing context, ObjectSerializer serializer);
    protected abstract virtual bool Enter(IObjectDescriptor value, ObjectSerializer serializer);
    protected abstract virtual bool EnterMapping(IPropertyDescriptor key, IObjectDescriptor value, ObjectSerializer serializer);
    protected abstract virtual bool EnterMapping(IObjectDescriptor key, IObjectDescriptor value, ObjectSerializer serializer);
    protected abstract virtual void VisitMappingEnd(IObjectDescriptor mapping, ObjectSerializer serializer);
    protected abstract virtual void VisitMappingStart(IObjectDescriptor mapping, Type keyType, Type valueType, ObjectSerializer serializer);
    protected abstract virtual void VisitScalar(IObjectDescriptor scalar, ObjectSerializer serializer);
    protected abstract virtual void VisitSequenceEnd(IObjectDescriptor sequence, ObjectSerializer serializer);
    protected abstract virtual void VisitSequenceStart(IObjectDescriptor sequence, Type elementType, ObjectSerializer serializer);
}
public class YamlDotNet.Serialization.ObjectSerializer : MulticastDelegate {
    public ObjectSerializer(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual void Invoke(object value, Type type);
    public virtual IAsyncResult BeginInvoke(object value, Type type, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.PropertyDescriptor : object {
    private IPropertyDescriptor baseDescriptor;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    public bool AllowNulls { get; }
    public string Name { get; public set; }
    public bool Required { get; }
    public Type Type { get; }
    [NullableAttribute("2")]
public Type TypeOverride { get; public set; }
    [NullableAttribute("2")]
public Type ConverterType { get; }
    public int Order { get; public set; }
    public ScalarStyle ScalarStyle { get; public set; }
    public bool CanWrite { get; }
    public PropertyDescriptor(IPropertyDescriptor baseDescriptor);
    public sealed virtual bool get_AllowNulls();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public sealed virtual bool get_Required();
    public sealed virtual Type get_Type();
    [NullableContextAttribute("2")]
public sealed virtual Type get_TypeOverride();
    [NullableContextAttribute("2")]
public sealed virtual void set_TypeOverride(Type value);
    [NullableContextAttribute("2")]
public sealed virtual Type get_ConverterType();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Order();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Order(int value);
    public sealed virtual ScalarStyle get_ScalarStyle();
    public sealed virtual void set_ScalarStyle(ScalarStyle value);
    public sealed virtual bool get_CanWrite();
    public sealed virtual void Write(object target, object value);
    [NullableContextAttribute("0")]
public sealed virtual T GetCustomAttribute();
    public sealed virtual IObjectDescriptor Read(object target);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.ScalarEventInfo : ObjectEventInfo {
    [CompilerGeneratedAttribute]
private string <RenderedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private ScalarStyle <Style>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPlainImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsQuotedImplicit>k__BackingField;
    public string RenderedValue { get; public set; }
    public ScalarStyle Style { get; public set; }
    public bool IsPlainImplicit { get; public set; }
    public bool IsQuotedImplicit { get; public set; }
    public ScalarEventInfo(IObjectDescriptor source);
    [CompilerGeneratedAttribute]
public string get_RenderedValue();
    [CompilerGeneratedAttribute]
public void set_RenderedValue(string value);
    [CompilerGeneratedAttribute]
public ScalarStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(ScalarStyle value);
    [CompilerGeneratedAttribute]
public bool get_IsPlainImplicit();
    [CompilerGeneratedAttribute]
public void set_IsPlainImplicit(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsQuotedImplicit();
    [CompilerGeneratedAttribute]
public void set_IsQuotedImplicit(bool value);
}
public class YamlDotNet.Serialization.Schemas.CoreSchema : object {
}
public class YamlDotNet.Serialization.Schemas.DefaultSchema : object {
}
public class YamlDotNet.Serialization.Schemas.FailsafeSchema : object {
}
public class YamlDotNet.Serialization.Schemas.JsonSchema : object {
}
public class YamlDotNet.Serialization.SequenceEndEventInfo : EventInfo {
    [NullableContextAttribute("1")]
public SequenceEndEventInfo(IObjectDescriptor source);
}
public class YamlDotNet.Serialization.SequenceStartEventInfo : ObjectEventInfo {
    [CompilerGeneratedAttribute]
private bool <IsImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private SequenceStyle <Style>k__BackingField;
    public bool IsImplicit { get; public set; }
    public SequenceStyle Style { get; public set; }
    [NullableContextAttribute("1")]
public SequenceStartEventInfo(IObjectDescriptor source);
    [CompilerGeneratedAttribute]
public bool get_IsImplicit();
    [CompilerGeneratedAttribute]
public void set_IsImplicit(bool value);
    [CompilerGeneratedAttribute]
public SequenceStyle get_Style();
    [CompilerGeneratedAttribute]
public void set_Style(SequenceStyle value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.Serializer : object {
    private IValueSerializer valueSerializer;
    private EmitterSettings emitterSettings;
    private Serializer(IValueSerializer valueSerializer, EmitterSettings emitterSettings);
    public static Serializer FromValueSerializer(IValueSerializer valueSerializer, EmitterSettings emitterSettings);
    public sealed virtual string Serialize(object graph);
    public sealed virtual string Serialize(object graph, Type type);
    public sealed virtual void Serialize(TextWriter writer, object graph);
    public sealed virtual void Serialize(TextWriter writer, object graph, Type type);
    public sealed virtual void Serialize(IEmitter emitter, object graph);
    public sealed virtual void Serialize(IEmitter emitter, object graph, Type type);
    [NullableContextAttribute("2")]
private void EmitDocument(IEmitter emitter, object graph, Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class YamlDotNet.Serialization.SerializerBuilder : BuilderSkeleton`1<SerializerBuilder> {
    private ObjectGraphTraversalStrategyFactory objectGraphTraversalStrategyFactory;
    private LazyComponentRegistrationList`2<IEnumerable`1<IYamlTypeConverter>, IObjectGraphVisitor`1<Nothing>> preProcessingPhaseObjectGraphVisitorFactories;
    private LazyComponentRegistrationList`2<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor`1<IEmitter>> emissionPhaseObjectGraphVisitorFactories;
    private LazyComponentRegistrationList`2<IEventEmitter, IEventEmitter> eventEmitterFactories;
    private Dictionary`2<Type, TagName> tagMappings;
    private IObjectFactory objectFactory;
    private int maximumRecursion;
    private EmitterSettings emitterSettings;
    private DefaultValuesHandling defaultValuesHandlingConfiguration;
    private ScalarStyle defaultScalarStyle;
    private bool quoteNecessaryStrings;
    private bool quoteYaml1_1Strings;
    protected SerializerBuilder Self { get; }
    protected virtual SerializerBuilder get_Self();
    public SerializerBuilder WithQuotingNecessaryStrings(bool quoteYaml1_1Strings);
    public SerializerBuilder WithDefaultScalarStyle(ScalarStyle style);
    public SerializerBuilder WithMaximumRecursion(int maximumRecursion);
    public SerializerBuilder WithEventEmitter(Func`2<IEventEmitter, TEventEmitter> eventEmitterFactory);
    public SerializerBuilder WithEventEmitter(Func`3<IEventEmitter, ITypeInspector, TEventEmitter> eventEmitterFactory);
    public SerializerBuilder WithEventEmitter(Func`2<IEventEmitter, TEventEmitter> eventEmitterFactory, Action`1<IRegistrationLocationSelectionSyntax`1<IEventEmitter>> where);
    public SerializerBuilder WithEventEmitter(Func`3<IEventEmitter, ITypeInspector, TEventEmitter> eventEmitterFactory, Action`1<IRegistrationLocationSelectionSyntax`1<IEventEmitter>> where);
    public SerializerBuilder WithEventEmitter(WrapperFactory`3<IEventEmitter, IEventEmitter, TEventEmitter> eventEmitterFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<IEventEmitter>> where);
    public SerializerBuilder WithoutEventEmitter();
    public SerializerBuilder WithoutEventEmitter(Type eventEmitterType);
    public virtual SerializerBuilder WithTagMapping(TagName tag, Type type);
    public SerializerBuilder WithoutTagMapping(Type type);
    public SerializerBuilder EnsureRoundtrip();
    public SerializerBuilder DisableAliases();
    [ObsoleteAttribute("The default behavior is now to always emit default values, thefore calling this method has no effect. This behavior is now controlled by ConfigureDefaultValuesHandling.", "True")]
public SerializerBuilder EmitDefaults();
    public SerializerBuilder ConfigureDefaultValuesHandling(DefaultValuesHandling configuration);
    public SerializerBuilder JsonCompatible();
    public SerializerBuilder WithNewLine(string newLine);
    public SerializerBuilder WithPreProcessingPhaseObjectGraphVisitor(TObjectGraphVisitor objectGraphVisitor);
    public SerializerBuilder WithPreProcessingPhaseObjectGraphVisitor(Func`2<IEnumerable`1<IYamlTypeConverter>, TObjectGraphVisitor> objectGraphVisitorFactory);
    public SerializerBuilder WithPreProcessingPhaseObjectGraphVisitor(TObjectGraphVisitor objectGraphVisitor, Action`1<IRegistrationLocationSelectionSyntax`1<IObjectGraphVisitor`1<Nothing>>> where);
    public SerializerBuilder WithPreProcessingPhaseObjectGraphVisitor(Func`2<IEnumerable`1<IYamlTypeConverter>, TObjectGraphVisitor> objectGraphVisitorFactory, Action`1<IRegistrationLocationSelectionSyntax`1<IObjectGraphVisitor`1<Nothing>>> where);
    public SerializerBuilder WithPreProcessingPhaseObjectGraphVisitor(WrapperFactory`2<IObjectGraphVisitor`1<Nothing>, TObjectGraphVisitor> objectGraphVisitorFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<IObjectGraphVisitor`1<Nothing>>> where);
    public SerializerBuilder WithPreProcessingPhaseObjectGraphVisitor(WrapperFactory`3<IEnumerable`1<IYamlTypeConverter>, IObjectGraphVisitor`1<Nothing>, TObjectGraphVisitor> objectGraphVisitorFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<IObjectGraphVisitor`1<Nothing>>> where);
    public SerializerBuilder WithoutPreProcessingPhaseObjectGraphVisitor();
    public SerializerBuilder WithoutPreProcessingPhaseObjectGraphVisitor(Type objectGraphVisitorType);
    public SerializerBuilder WithObjectGraphTraversalStrategyFactory(ObjectGraphTraversalStrategyFactory objectGraphTraversalStrategyFactory);
    public SerializerBuilder WithEmissionPhaseObjectGraphVisitor(Func`2<EmissionPhaseObjectGraphVisitorArgs, TObjectGraphVisitor> objectGraphVisitorFactory);
    public SerializerBuilder WithEmissionPhaseObjectGraphVisitor(Func`2<EmissionPhaseObjectGraphVisitorArgs, TObjectGraphVisitor> objectGraphVisitorFactory, Action`1<IRegistrationLocationSelectionSyntax`1<IObjectGraphVisitor`1<IEmitter>>> where);
    public SerializerBuilder WithEmissionPhaseObjectGraphVisitor(WrapperFactory`3<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor`1<IEmitter>, TObjectGraphVisitor> objectGraphVisitorFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<IObjectGraphVisitor`1<IEmitter>>> where);
    public SerializerBuilder WithoutEmissionPhaseObjectGraphVisitor();
    public SerializerBuilder WithoutEmissionPhaseObjectGraphVisitor(Type objectGraphVisitorType);
    public SerializerBuilder WithIndentedSequences();
    public ISerializer Build();
    public IValueSerializer BuildValueSerializer();
    public ITypeInspector BuildTypeInspector();
    [CompilerGeneratedAttribute]
private ITypeInspector <.ctor>b__12_1(ITypeInspector inner);
    [CompilerGeneratedAttribute]
private ITypeInspector <.ctor>b__12_3(ITypeInspector inner);
    [CompilerGeneratedAttribute]
private IObjectGraphVisitor`1<IEmitter> <.ctor>b__12_8(EmissionPhaseObjectGraphVisitorArgs args);
    [CompilerGeneratedAttribute]
private IEventEmitter <.ctor>b__12_10(IEventEmitter inner);
    [CompilerGeneratedAttribute]
private IObjectGraphTraversalStrategy <.ctor>b__12_4(ITypeInspector typeInspector, ITypeResolver typeResolver, IEnumerable`1<IYamlTypeConverter> typeConverters, int maximumRecursion);
    [CompilerGeneratedAttribute]
private IObjectGraphTraversalStrategy <EnsureRoundtrip>b__27_0(ITypeInspector typeInspector, ITypeResolver typeResolver, IEnumerable`1<IYamlTypeConverter> typeConverters, int maximumRecursion);
    [CompilerGeneratedAttribute]
private TypeAssigningEventEmitter <EnsureRoundtrip>b__27_1(IEventEmitter inner);
    [CompilerGeneratedAttribute]
private JsonEventEmitter <JsonCompatible>b__31_1(IEventEmitter inner);
}
public class YamlDotNet.Serialization.Settings : object {
    [CompilerGeneratedAttribute]
private bool <AllowPrivateConstructors>k__BackingField;
    public bool AllowPrivateConstructors { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_AllowPrivateConstructors();
    [CompilerGeneratedAttribute]
public void set_AllowPrivateConstructors(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class YamlDotNet.Serialization.StaticBuilderSkeleton`1 : object {
    internal INamingConvention namingConvention;
    internal INamingConvention enumNamingConvention;
    internal ITypeResolver typeResolver;
    internal LazyComponentRegistrationList`2<Nothing, IYamlTypeConverter> typeConverterFactories;
    internal LazyComponentRegistrationList`2<ITypeInspector, ITypeInspector> typeInspectorFactories;
    internal bool includeNonPublicProperties;
    internal Settings settings;
    internal YamlFormatter yamlFormatter;
    protected TBuilder Self { get; }
    internal StaticBuilderSkeleton`1(ITypeResolver typeResolver);
    protected abstract virtual TBuilder get_Self();
    public TBuilder WithNamingConvention(INamingConvention namingConvention);
    public TBuilder WithEnumNamingConvention(INamingConvention enumNamingConvention);
    public TBuilder WithTypeResolver(ITypeResolver typeResolver);
    public abstract virtual TBuilder WithTagMapping(TagName tag, Type type);
    public TBuilder WithTypeConverter(IYamlTypeConverter typeConverter);
    public TBuilder WithTypeConverter(IYamlTypeConverter typeConverter, Action`1<IRegistrationLocationSelectionSyntax`1<IYamlTypeConverter>> where);
    public TBuilder WithTypeConverter(WrapperFactory`2<IYamlTypeConverter, IYamlTypeConverter> typeConverterFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<IYamlTypeConverter>> where);
    public TBuilder WithoutTypeConverter();
    public TBuilder WithoutTypeConverter(Type converterType);
    public TBuilder WithTypeInspector(Func`2<ITypeInspector, TTypeInspector> typeInspectorFactory);
    public TBuilder WithTypeInspector(Func`2<ITypeInspector, TTypeInspector> typeInspectorFactory, Action`1<IRegistrationLocationSelectionSyntax`1<ITypeInspector>> where);
    public TBuilder WithTypeInspector(WrapperFactory`3<ITypeInspector, ITypeInspector, TTypeInspector> typeInspectorFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<ITypeInspector>> where);
    public TBuilder WithoutTypeInspector();
    public TBuilder WithoutTypeInspector(Type inspectorType);
    public TBuilder WithYamlFormatter(YamlFormatter formatter);
    protected IEnumerable`1<IYamlTypeConverter> BuildTypeConverters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class YamlDotNet.Serialization.StaticContext : object {
    public virtual bool IsKnownType(Type type);
    public virtual ITypeResolver GetTypeResolver();
    public virtual StaticObjectFactory GetFactory();
    public virtual ITypeInspector GetTypeInspector();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class YamlDotNet.Serialization.StaticDeserializerBuilder : StaticBuilderSkeleton`1<StaticDeserializerBuilder> {
    private StaticContext context;
    private StaticObjectFactory factory;
    private LazyComponentRegistrationList`2<Nothing, INodeDeserializer> nodeDeserializerFactories;
    private LazyComponentRegistrationList`2<Nothing, INodeTypeResolver> nodeTypeResolverFactories;
    private Dictionary`2<TagName, Type> tagMappings;
    private ITypeConverter typeConverter;
    private Dictionary`2<Type, Type> typeMappings;
    private bool ignoreUnmatched;
    private bool duplicateKeyChecking;
    private bool attemptUnknownTypeDeserialization;
    private bool enforceNullability;
    private bool caseInsensitivePropertyMatching;
    protected StaticDeserializerBuilder Self { get; }
    public StaticDeserializerBuilder(StaticContext context);
    protected virtual StaticDeserializerBuilder get_Self();
    public ITypeInspector BuildTypeInspector();
    public StaticDeserializerBuilder WithAttemptingUnquotedStringTypeDeserialization();
    public StaticDeserializerBuilder WithNodeDeserializer(INodeDeserializer nodeDeserializer);
    public StaticDeserializerBuilder WithNodeDeserializer(INodeDeserializer nodeDeserializer, Action`1<IRegistrationLocationSelectionSyntax`1<INodeDeserializer>> where);
    public StaticDeserializerBuilder WithNodeDeserializer(WrapperFactory`2<INodeDeserializer, TNodeDeserializer> nodeDeserializerFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<INodeDeserializer>> where);
    public StaticDeserializerBuilder WithCaseInsensitivePropertyMatching();
    public StaticDeserializerBuilder WithEnforceNullability();
    public StaticDeserializerBuilder WithoutNodeDeserializer();
    public StaticDeserializerBuilder WithoutNodeDeserializer(Type nodeDeserializerType);
    public StaticDeserializerBuilder WithTypeDiscriminatingNodeDeserializer(Action`1<ITypeDiscriminatingNodeDeserializerOptions> configureTypeDiscriminatingNodeDeserializerOptions, int maxDepth, int maxLength);
    public StaticDeserializerBuilder WithNodeTypeResolver(INodeTypeResolver nodeTypeResolver);
    public StaticDeserializerBuilder WithNodeTypeResolver(INodeTypeResolver nodeTypeResolver, Action`1<IRegistrationLocationSelectionSyntax`1<INodeTypeResolver>> where);
    public StaticDeserializerBuilder WithNodeTypeResolver(WrapperFactory`2<INodeTypeResolver, TNodeTypeResolver> nodeTypeResolverFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<INodeTypeResolver>> where);
    public StaticDeserializerBuilder WithoutNodeTypeResolver();
    public StaticDeserializerBuilder WithoutNodeTypeResolver(Type nodeTypeResolverType);
    public virtual StaticDeserializerBuilder WithTagMapping(TagName tag, Type type);
    public StaticDeserializerBuilder WithTypeMapping();
    public StaticDeserializerBuilder WithoutTagMapping(TagName tag);
    public StaticDeserializerBuilder IgnoreUnmatchedProperties();
    public StaticDeserializerBuilder WithDuplicateKeyChecking();
    public IDeserializer Build();
    public IValueDeserializer BuildValueDeserializer();
    [CompilerGeneratedAttribute]
private ITypeInspector <.ctor>b__12_1(ITypeInspector inner);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_3(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_4(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_5(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_7(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_8(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_9(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_10(Nothing _);
    [CompilerGeneratedAttribute]
private INodeDeserializer <.ctor>b__12_11(Nothing _);
    [CompilerGeneratedAttribute]
private INodeTypeResolver <.ctor>b__12_12(Nothing _);
    [CompilerGeneratedAttribute]
private INodeTypeResolver <.ctor>b__12_15(Nothing _);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class YamlDotNet.Serialization.StaticSerializerBuilder : StaticBuilderSkeleton`1<StaticSerializerBuilder> {
    private StaticContext context;
    private StaticObjectFactory factory;
    private ObjectGraphTraversalStrategyFactory objectGraphTraversalStrategyFactory;
    private LazyComponentRegistrationList`2<IEnumerable`1<IYamlTypeConverter>, IObjectGraphVisitor`1<Nothing>> preProcessingPhaseObjectGraphVisitorFactories;
    private LazyComponentRegistrationList`2<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor`1<IEmitter>> emissionPhaseObjectGraphVisitorFactories;
    private LazyComponentRegistrationList`2<IEventEmitter, IEventEmitter> eventEmitterFactories;
    private Dictionary`2<Type, TagName> tagMappings;
    private int maximumRecursion;
    private EmitterSettings emitterSettings;
    private DefaultValuesHandling defaultValuesHandlingConfiguration;
    private bool quoteNecessaryStrings;
    private bool quoteYaml1_1Strings;
    private ScalarStyle defaultScalarStyle;
    protected StaticSerializerBuilder Self { get; }
    public StaticSerializerBuilder(StaticContext context);
    protected virtual StaticSerializerBuilder get_Self();
    public StaticSerializerBuilder WithQuotingNecessaryStrings(bool quoteYaml1_1Strings);
    public StaticSerializerBuilder WithQuotingNecessaryStrings();
    public StaticSerializerBuilder WithDefaultScalarStyle(ScalarStyle style);
    public StaticSerializerBuilder WithMaximumRecursion(int maximumRecursion);
    public StaticSerializerBuilder WithEventEmitter(Func`2<IEventEmitter, TEventEmitter> eventEmitterFactory);
    public StaticSerializerBuilder WithEventEmitter(Func`3<IEventEmitter, ITypeInspector, TEventEmitter> eventEmitterFactory);
    public StaticSerializerBuilder WithEventEmitter(Func`2<IEventEmitter, TEventEmitter> eventEmitterFactory, Action`1<IRegistrationLocationSelectionSyntax`1<IEventEmitter>> where);
    public StaticSerializerBuilder WithEventEmitter(Func`3<IEventEmitter, ITypeInspector, TEventEmitter> eventEmitterFactory, Action`1<IRegistrationLocationSelectionSyntax`1<IEventEmitter>> where);
    public StaticSerializerBuilder WithEventEmitter(WrapperFactory`3<IEventEmitter, IEventEmitter, TEventEmitter> eventEmitterFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<IEventEmitter>> where);
    public StaticSerializerBuilder WithoutEventEmitter();
    public StaticSerializerBuilder WithoutEventEmitter(Type eventEmitterType);
    public virtual StaticSerializerBuilder WithTagMapping(TagName tag, Type type);
    public StaticSerializerBuilder WithoutTagMapping(Type type);
    public StaticSerializerBuilder EnsureRoundtrip();
    public StaticSerializerBuilder DisableAliases();
    [ObsoleteAttribute("The default behavior is now to always emit default values, thefore calling this method has no effect. This behavior is now controlled by ConfigureDefaultValuesHandling.", "True")]
public StaticSerializerBuilder EmitDefaults();
    public StaticSerializerBuilder ConfigureDefaultValuesHandling(DefaultValuesHandling configuration);
    public StaticSerializerBuilder JsonCompatible();
    public StaticSerializerBuilder WithNewLine(string newLine);
    public StaticSerializerBuilder WithPreProcessingPhaseObjectGraphVisitor(TObjectGraphVisitor objectGraphVisitor);
    public StaticSerializerBuilder WithPreProcessingPhaseObjectGraphVisitor(Func`2<IEnumerable`1<IYamlTypeConverter>, TObjectGraphVisitor> objectGraphVisitorFactory);
    public StaticSerializerBuilder WithPreProcessingPhaseObjectGraphVisitor(TObjectGraphVisitor objectGraphVisitor, Action`1<IRegistrationLocationSelectionSyntax`1<IObjectGraphVisitor`1<Nothing>>> where);
    public StaticSerializerBuilder WithPreProcessingPhaseObjectGraphVisitor(Func`2<IEnumerable`1<IYamlTypeConverter>, TObjectGraphVisitor> objectGraphVisitorFactory, Action`1<IRegistrationLocationSelectionSyntax`1<IObjectGraphVisitor`1<Nothing>>> where);
    public StaticSerializerBuilder WithPreProcessingPhaseObjectGraphVisitor(WrapperFactory`2<IObjectGraphVisitor`1<Nothing>, TObjectGraphVisitor> objectGraphVisitorFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<IObjectGraphVisitor`1<Nothing>>> where);
    public StaticSerializerBuilder WithPreProcessingPhaseObjectGraphVisitor(WrapperFactory`3<IEnumerable`1<IYamlTypeConverter>, IObjectGraphVisitor`1<Nothing>, TObjectGraphVisitor> objectGraphVisitorFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<IObjectGraphVisitor`1<Nothing>>> where);
    public StaticSerializerBuilder WithoutPreProcessingPhaseObjectGraphVisitor();
    public StaticSerializerBuilder WithoutPreProcessingPhaseObjectGraphVisitor(Type objectGraphVisitorType);
    public StaticSerializerBuilder WithObjectGraphTraversalStrategyFactory(ObjectGraphTraversalStrategyFactory objectGraphTraversalStrategyFactory);
    public StaticSerializerBuilder WithEmissionPhaseObjectGraphVisitor(Func`2<EmissionPhaseObjectGraphVisitorArgs, TObjectGraphVisitor> objectGraphVisitorFactory);
    public StaticSerializerBuilder WithEmissionPhaseObjectGraphVisitor(Func`2<EmissionPhaseObjectGraphVisitorArgs, TObjectGraphVisitor> objectGraphVisitorFactory, Action`1<IRegistrationLocationSelectionSyntax`1<IObjectGraphVisitor`1<IEmitter>>> where);
    public StaticSerializerBuilder WithEmissionPhaseObjectGraphVisitor(WrapperFactory`3<EmissionPhaseObjectGraphVisitorArgs, IObjectGraphVisitor`1<IEmitter>, TObjectGraphVisitor> objectGraphVisitorFactory, Action`1<ITrackingRegistrationLocationSelectionSyntax`1<IObjectGraphVisitor`1<IEmitter>>> where);
    public StaticSerializerBuilder WithoutEmissionPhaseObjectGraphVisitor();
    public StaticSerializerBuilder WithoutEmissionPhaseObjectGraphVisitor(Type objectGraphVisitorType);
    public StaticSerializerBuilder WithIndentedSequences();
    public ISerializer Build();
    public IValueSerializer BuildValueSerializer();
    public ITypeInspector BuildTypeInspector();
    [CompilerGeneratedAttribute]
private ITypeInspector <.ctor>b__13_1(ITypeInspector inner);
    [CompilerGeneratedAttribute]
private IObjectGraphVisitor`1<IEmitter> <.ctor>b__13_7(EmissionPhaseObjectGraphVisitorArgs args);
    [CompilerGeneratedAttribute]
private IEventEmitter <.ctor>b__13_9(IEventEmitter inner);
    [CompilerGeneratedAttribute]
private IObjectGraphTraversalStrategy <.ctor>b__13_3(ITypeInspector typeInspector, ITypeResolver typeResolver, IEnumerable`1<IYamlTypeConverter> typeConverters, int maximumRecursion);
    [CompilerGeneratedAttribute]
private IObjectGraphTraversalStrategy <EnsureRoundtrip>b__29_0(ITypeInspector typeInspector, ITypeResolver typeResolver, IEnumerable`1<IYamlTypeConverter> typeConverters, int maximumRecursion);
    [CompilerGeneratedAttribute]
private TypeAssigningEventEmitter <EnsureRoundtrip>b__29_1(IEventEmitter inner);
    [CompilerGeneratedAttribute]
private JsonEventEmitter <JsonCompatible>b__33_1(IEventEmitter inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.StreamFragment : object {
    private List`1<ParsingEvent> events;
    public IList`1<ParsingEvent> Events { get; }
    public IList`1<ParsingEvent> get_Events();
    private sealed virtual override void YamlDotNet.Serialization.IYamlConvertible.Read(IParser parser, Type expectedType, ObjectDeserializer nestedObjectDeserializer);
    private sealed virtual override void YamlDotNet.Serialization.IYamlConvertible.Write(IEmitter emitter, ObjectSerializer nestedObjectSerializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.TagMappings : object {
    private Dictionary`2<string, Type> mappings;
    public TagMappings(IDictionary`2<string, Type> mappings);
    public void Add(string tag, Type mapping);
    internal Type GetMapping(string tag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.TypeInspectors.CachedTypeInspector : TypeInspectorSkeleton {
    private ITypeInspector innerTypeDescriptor;
    private ConcurrentDictionary`2<Type, List`1<IPropertyDescriptor>> cache;
    private ConcurrentDictionary`2<Type, ConcurrentDictionary`2<string, string>> enumNameCache;
    private ConcurrentDictionary`2<object, string> enumValueCache;
    public CachedTypeInspector(ITypeInspector innerTypeDescriptor);
    public virtual string GetEnumName(Type enumType, string name);
    public virtual string GetEnumValue(object enumValue);
    public virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.TypeInspectors.CompositeTypeInspector : TypeInspectorSkeleton {
    private IEnumerable`1<ITypeInspector> typeInspectors;
    public CompositeTypeInspector(ITypeInspector[] typeInspectors);
    public CompositeTypeInspector(IEnumerable`1<ITypeInspector> typeInspectors);
    public virtual string GetEnumName(Type enumType, string name);
    public virtual string GetEnumValue(object enumValue);
    public virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.TypeInspectors.NamingConventionTypeInspector : TypeInspectorSkeleton {
    private ITypeInspector innerTypeDescriptor;
    private INamingConvention namingConvention;
    public NamingConventionTypeInspector(ITypeInspector innerTypeDescriptor, INamingConvention namingConvention);
    public virtual string GetEnumName(Type enumType, string name);
    public virtual string GetEnumValue(object enumValue);
    public virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IPropertyDescriptor <GetProperties>b__5_0(IPropertyDescriptor p);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.TypeInspectors.ReadableAndWritablePropertiesTypeInspector : TypeInspectorSkeleton {
    private ITypeInspector innerTypeDescriptor;
    public ReadableAndWritablePropertiesTypeInspector(ITypeInspector innerTypeDescriptor);
    public virtual string GetEnumName(Type enumType, string name);
    public virtual string GetEnumValue(object enumValue);
    public virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.TypeInspectors.ReadableFieldsTypeInspector : ReflectionTypeInspector {
    private ITypeResolver typeResolver;
    public ReadableFieldsTypeInspector(ITypeResolver typeResolver);
    public virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IPropertyDescriptor <GetProperties>b__2_0(FieldInfo p);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.TypeInspectors.ReadablePropertiesTypeInspector : ReflectionTypeInspector {
    private ITypeResolver typeResolver;
    private bool includeNonPublicProperties;
    public ReadablePropertiesTypeInspector(ITypeResolver typeResolver);
    public ReadablePropertiesTypeInspector(ITypeResolver typeResolver, bool includeNonPublicProperties);
    private static bool IsValidProperty(PropertyInfo property);
    public virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IPropertyDescriptor <GetProperties>b__5_0(PropertyInfo p);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class YamlDotNet.Serialization.TypeInspectors.ReflectionTypeInspector : TypeInspectorSkeleton {
    public virtual string GetEnumName(Type enumType, string name);
    public virtual string GetEnumValue(object enumValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class YamlDotNet.Serialization.TypeInspectors.TypeInspectorSkeleton : object {
    public abstract virtual string GetEnumName(Type enumType, string name);
    public abstract virtual string GetEnumValue(object enumValue);
    public abstract virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
    public sealed virtual IPropertyDescriptor GetProperty(Type type, object container, string name, bool ignoreUnmatched, bool caseInsensitivePropertyMatching);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.TypeInspectors.WritablePropertiesTypeInspector : ReflectionTypeInspector {
    private ITypeResolver typeResolver;
    private bool includeNonPublicProperties;
    public WritablePropertiesTypeInspector(ITypeResolver typeResolver);
    public WritablePropertiesTypeInspector(ITypeResolver typeResolver, bool includeNonPublicProperties);
    private static bool IsValidProperty(PropertyInfo property);
    public virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IPropertyDescriptor <GetProperties>b__5_0(PropertyInfo p);
}
public class YamlDotNet.Serialization.TypeResolvers.DynamicTypeResolver : object {
    [NullableContextAttribute("1")]
public sealed virtual Type Resolve(Type staticType, object actualValue);
}
public class YamlDotNet.Serialization.TypeResolvers.StaticTypeResolver : object {
    [NullableContextAttribute("1")]
public virtual Type Resolve(Type staticType, object actualValue);
}
public interface YamlDotNet.Serialization.Utilities.IPostDeserializationCallback {
    public abstract virtual void OnDeserialization();
}
[NullableContextAttribute("1")]
public interface YamlDotNet.Serialization.Utilities.ITypeConverter {
    public abstract virtual object ChangeType(object value, Type expectedType, INamingConvention enumNamingConvention, ITypeInspector typeInspector);
}
public class YamlDotNet.Serialization.Utilities.NullTypeConverter : object {
    [NullableContextAttribute("1")]
public sealed virtual object ChangeType(object value, Type expectedType, INamingConvention enumNamingConvention, ITypeInspector typeInspector);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class YamlDotNet.Serialization.Utilities.ObjectAnchorCollection : object {
    private Dictionary`2<string, object> objectsByAnchor;
    private Dictionary`2<object, string> anchorsByObject;
    public object Item { get; }
    public void Add(string anchor, object object);
    public bool TryGetAnchor(object object, String& anchor);
    public object get_Item(string anchor);
}
public class YamlDotNet.Serialization.Utilities.ReflectionTypeConverter : object {
    [NullableContextAttribute("1")]
public object ChangeType(object value, Type expectedType, ITypeInspector typeInspector);
    [NullableContextAttribute("1")]
public sealed virtual object ChangeType(object value, Type expectedType, INamingConvention enumNamingConvention, ITypeInspector typeInspector);
}
public class YamlDotNet.Serialization.Utilities.SerializerState : object {
    [NullableAttribute("1")]
private Dictionary`2<Type, object> items;
    [NullableContextAttribute("1")]
public T Get();
    public void OnDeserialization();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class YamlDotNet.Serialization.Utilities.StringExtensions : object {
    private static string ToCamelOrPascalCase(string str, Func`2<char, char> firstLetterTransform);
    [ExtensionAttribute]
public static string ToCamelCase(string str);
    [ExtensionAttribute]
public static string ToPascalCase(string str);
    [ExtensionAttribute]
public static string FromCamelCase(string str, string separator);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class YamlDotNet.Serialization.Utilities.TypeConverter : object {
    public static T ChangeType(object value, INamingConvention enumNamingConvention, ITypeInspector typeInspector);
    public static object ChangeType(object value, Type destinationType, INamingConvention enumNamingConvention, ITypeInspector typeInspector);
    public static object ChangeType(object value, Type destinationType, IFormatProvider provider, INamingConvention enumNamingConvention, ITypeInspector typeInspector);
    public static object ChangeType(object value, Type destinationType, CultureInfo culture, INamingConvention enumNamingConvention, ITypeInspector typeInspector);
    [NullableContextAttribute("0")]
public static void RegisterTypeConverter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class YamlDotNet.Serialization.Utilities.TypeConverterCache : object {
    private IYamlTypeConverter[] typeConverters;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<Type, ValueTuple`2<bool, IYamlTypeConverter>> cache;
    public TypeConverterCache(IEnumerable`1<IYamlTypeConverter> typeConverters);
    public TypeConverterCache(IYamlTypeConverter[] typeConverters);
    public bool TryGetConverterForType(Type type, IYamlTypeConverter& typeConverter);
    public IYamlTypeConverter GetConverterByType(Type converter);
    private static ValueTuple`2<bool, IYamlTypeConverter> LookupTypeConverter(Type type, IYamlTypeConverter[] typeConverters);
}
public class YamlDotNet.Serialization.ValueDeserializers.AliasValueDeserializer : object {
    [NullableAttribute("1")]
private IValueDeserializer innerDeserializer;
    [NullableContextAttribute("1")]
public AliasValueDeserializer(IValueDeserializer innerDeserializer);
    [NullableContextAttribute("1")]
public sealed virtual object DeserializeValue(IParser parser, Type expectedType, SerializerState state, IValueDeserializer nestedObjectDeserializer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.ValueDeserializers.NodeValueDeserializer : object {
    private IList`1<INodeDeserializer> deserializers;
    private IList`1<INodeTypeResolver> typeResolvers;
    private ITypeConverter typeConverter;
    private INamingConvention enumNamingConvention;
    private ITypeInspector typeInspector;
    public NodeValueDeserializer(IList`1<INodeDeserializer> deserializers, IList`1<INodeTypeResolver> typeResolvers, ITypeConverter typeConverter, INamingConvention enumNamingConvention, ITypeInspector typeInspector);
    public sealed virtual object DeserializeValue(IParser parser, Type expectedType, SerializerState state, IValueDeserializer nestedObjectDeserializer);
    private Type GetTypeFromEvent(NodeEvent nodeEvent, Type currentType);
}
public class YamlDotNet.Serialization.WrapperFactory`2 : MulticastDelegate {
    public WrapperFactory`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TComponent Invoke(TComponentBase wrapped);
    public virtual IAsyncResult BeginInvoke(TComponentBase wrapped, AsyncCallback callback, object object);
    public virtual TComponent EndInvoke(IAsyncResult result);
}
public class YamlDotNet.Serialization.WrapperFactory`3 : MulticastDelegate {
    public WrapperFactory`3(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TComponent Invoke(TComponentBase wrapped, TArgument argument);
    public virtual IAsyncResult BeginInvoke(TComponentBase wrapped, TArgument argument, AsyncCallback callback, object object);
    public virtual TComponent EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.YamlAttributeOverrides : object {
    private Dictionary`2<AttributeKey, List`1<AttributeMapping>> overrides;
    public T GetAttribute(Type type, string member);
    public void Add(Type type, string member, Attribute attribute);
    public YamlAttributeOverrides Clone();
    public void Add(Expression`1<Func`2<TClass, object>> propertyAccessor, Attribute attribute);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.YamlAttributeOverridesInspector : ReflectionTypeInspector {
    private ITypeInspector innerTypeDescriptor;
    private YamlAttributeOverrides overrides;
    public YamlAttributeOverridesInspector(ITypeInspector innerTypeDescriptor, YamlAttributeOverrides overrides);
    public virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.YamlAttributesTypeInspector : TypeInspectorSkeleton {
    private ITypeInspector innerTypeDescriptor;
    public YamlAttributesTypeInspector(ITypeInspector innerTypeDescriptor);
    public virtual string GetEnumName(Type enumType, string name);
    public virtual string GetEnumValue(object enumValue);
    public virtual IEnumerable`1<IPropertyDescriptor> GetProperties(Type type, object container);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("384")]
public class YamlDotNet.Serialization.YamlConverterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <ConverterType>k__BackingField;
    public Type ConverterType { get; }
    public YamlConverterAttribute(Type converterType);
    [CompilerGeneratedAttribute]
public Type get_ConverterType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class YamlDotNet.Serialization.YamlFormatter : object {
    [CompilerGeneratedAttribute]
private static YamlFormatter <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private NumberFormatInfo <NumberFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`4<object, ITypeInspector, INamingConvention, string> <FormatEnum>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<object, bool> <PotentiallyQuoteEnums>k__BackingField;
    public static YamlFormatter Default { get; }
    public NumberFormatInfo NumberFormat { get; public set; }
    public Func`4<object, ITypeInspector, INamingConvention, string> FormatEnum { get; public set; }
    public Func`2<object, bool> PotentiallyQuoteEnums { get; public set; }
    private static YamlFormatter();
    [CompilerGeneratedAttribute]
public static YamlFormatter get_Default();
    [CompilerGeneratedAttribute]
public NumberFormatInfo get_NumberFormat();
    [CompilerGeneratedAttribute]
public void set_NumberFormat(NumberFormatInfo value);
    public string FormatNumber(object number);
    public string FormatNumber(double number);
    public string FormatNumber(float number);
    public string FormatBoolean(object boolean);
    public string FormatDateTime(object dateTime);
    public string FormatTimeSpan(object timeSpan);
    [CompilerGeneratedAttribute]
public virtual Func`4<object, ITypeInspector, INamingConvention, string> get_FormatEnum();
    [CompilerGeneratedAttribute]
public virtual void set_FormatEnum(Func`4<object, ITypeInspector, INamingConvention, string> value);
    [CompilerGeneratedAttribute]
public virtual Func`2<object, bool> get_PotentiallyQuoteEnums();
    [CompilerGeneratedAttribute]
public virtual void set_PotentiallyQuoteEnums(Func`2<object, bool> value);
}
[AttributeUsageAttribute("384")]
public class YamlDotNet.Serialization.YamlIgnoreAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("384")]
public class YamlDotNet.Serialization.YamlMemberAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SerializeAs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Order>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ApplyNamingConventions>k__BackingField;
    [CompilerGeneratedAttribute]
private ScalarStyle <ScalarStyle>k__BackingField;
    private Nullable`1<DefaultValuesHandling> defaultValuesHandling;
    public string Description { get; public set; }
    public Type SerializeAs { get; public set; }
    public int Order { get; public set; }
    public string Alias { get; public set; }
    public bool ApplyNamingConventions { get; public set; }
    public ScalarStyle ScalarStyle { get; public set; }
    public DefaultValuesHandling DefaultValuesHandling { get; public set; }
    public bool IsDefaultValuesHandlingSpecified { get; }
    [NullableContextAttribute("1")]
public YamlMemberAttribute(Type serializeAs);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Type get_SerializeAs();
    [CompilerGeneratedAttribute]
public void set_SerializeAs(Type value);
    [CompilerGeneratedAttribute]
public int get_Order();
    [CompilerGeneratedAttribute]
public void set_Order(int value);
    [CompilerGeneratedAttribute]
public string get_Alias();
    [CompilerGeneratedAttribute]
public void set_Alias(string value);
    [CompilerGeneratedAttribute]
public bool get_ApplyNamingConventions();
    [CompilerGeneratedAttribute]
public void set_ApplyNamingConventions(bool value);
    [CompilerGeneratedAttribute]
public ScalarStyle get_ScalarStyle();
    [CompilerGeneratedAttribute]
public void set_ScalarStyle(ScalarStyle value);
    public DefaultValuesHandling get_DefaultValuesHandling();
    public void set_DefaultValuesHandling(DefaultValuesHandling value);
    public bool get_IsDefaultValuesHandlingSpecified();
}
[AttributeUsageAttribute("20")]
public class YamlDotNet.Serialization.YamlSerializableAttribute : Attribute {
    [NullableContextAttribute("1")]
public YamlSerializableAttribute(Type serializableType);
}
[AttributeUsageAttribute("4")]
public class YamlDotNet.Serialization.YamlStaticContextAttribute : Attribute {
}
internal static class YamlDotNet.StandardRegexOptions : object {
    public static RegexOptions Compiled;
}
