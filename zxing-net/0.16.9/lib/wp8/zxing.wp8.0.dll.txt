internal class BigIntegerLibrary.Base10BigInteger : object {
    private static long NumberBase;
    private static int MaxSize;
    private static Base10BigInteger Zero;
    private static Base10BigInteger One;
    private DigitContainer digits;
    private int size;
    private Sign sign;
    unknown Sign NumberSign {internal set; }
    public Base10BigInteger(long n);
    public Base10BigInteger(Base10BigInteger n);
    private static Base10BigInteger();
    internal void set_NumberSign(Sign value);
    public bool Equals(Base10BigInteger other);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static Base10BigInteger Opposite(Base10BigInteger n);
    public static bool Greater(Base10BigInteger a, Base10BigInteger b);
    public static bool GreaterOrEqual(Base10BigInteger a, Base10BigInteger b);
    public static bool Smaller(Base10BigInteger a, Base10BigInteger b);
    public static bool SmallerOrEqual(Base10BigInteger a, Base10BigInteger b);
    public static Base10BigInteger Abs(Base10BigInteger n);
    public static Base10BigInteger Addition(Base10BigInteger a, Base10BigInteger b);
    public static Base10BigInteger Subtraction(Base10BigInteger a, Base10BigInteger b);
    public static Base10BigInteger Multiplication(Base10BigInteger a, Base10BigInteger b);
    public static Base10BigInteger op_Implicit(long n);
    public static bool op_Equality(Base10BigInteger a, Base10BigInteger b);
    public static bool op_Inequality(Base10BigInteger a, Base10BigInteger b);
    public static bool op_GreaterThan(Base10BigInteger a, Base10BigInteger b);
    public static bool op_LessThan(Base10BigInteger a, Base10BigInteger b);
    public static bool op_GreaterThanOrEqual(Base10BigInteger a, Base10BigInteger b);
    public static bool op_LessThanOrEqual(Base10BigInteger a, Base10BigInteger b);
    public static Base10BigInteger op_UnaryNegation(Base10BigInteger n);
    public static Base10BigInteger op_Addition(Base10BigInteger a, Base10BigInteger b);
    public static Base10BigInteger op_Subtraction(Base10BigInteger a, Base10BigInteger b);
    public static Base10BigInteger op_Multiply(Base10BigInteger a, Base10BigInteger b);
    public static Base10BigInteger op_Increment(Base10BigInteger n);
    public static Base10BigInteger op_Decrement(Base10BigInteger n);
    private static Base10BigInteger Add(Base10BigInteger a, Base10BigInteger b);
    private static Base10BigInteger Subtract(Base10BigInteger a, Base10BigInteger b);
    private static Base10BigInteger Multiply(Base10BigInteger a, Base10BigInteger b);
}
internal class BigIntegerLibrary.BigInteger : object {
    private static long NumberBase;
    internal static int MaxSize;
    private static int RatioToBinaryDigits;
    public static BigInteger Zero;
    public static BigInteger One;
    public static BigInteger Two;
    public static BigInteger Ten;
    private DigitContainer digits;
    private int size;
    private Sign sign;
    public BigInteger(long n);
    public BigInteger(BigInteger n);
    public BigInteger(string numberString);
    public BigInteger(Byte[] byteArray);
    private static BigInteger();
    public sealed virtual bool Equals(BigInteger other);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static BigInteger Parse(string str);
    public sealed virtual int CompareTo(BigInteger other);
    public sealed virtual int CompareTo(object obj);
    public static int SizeInBinaryDigits(BigInteger n);
    public static BigInteger Opposite(BigInteger n);
    public static bool Greater(BigInteger a, BigInteger b);
    public static bool GreaterOrEqual(BigInteger a, BigInteger b);
    public static bool Smaller(BigInteger a, BigInteger b);
    public static bool SmallerOrEqual(BigInteger a, BigInteger b);
    public static BigInteger Abs(BigInteger n);
    public static BigInteger Addition(BigInteger a, BigInteger b);
    public static BigInteger Subtraction(BigInteger a, BigInteger b);
    public static BigInteger Multiplication(BigInteger a, BigInteger b);
    public static BigInteger Division(BigInteger a, BigInteger b);
    public static BigInteger Modulo(BigInteger a, BigInteger b);
    public static BigInteger Power(BigInteger a, int exponent);
    public static BigInteger IntegerSqrt(BigInteger n);
    public static BigInteger Gcd(BigInteger a, BigInteger b);
    public static BigInteger ExtendedEuclidGcd(BigInteger a, BigInteger b, BigInteger& u, BigInteger& v);
    public static BigInteger ModularInverse(BigInteger a, BigInteger n);
    public static BigInteger ModularExponentiation(BigInteger a, BigInteger exponent, BigInteger n);
    public static BigInteger op_Implicit(long n);
    public static BigInteger op_Implicit(int n);
    public static int op_Explicit(BigInteger value);
    public static ulong op_Explicit(BigInteger value);
    public static bool op_Equality(BigInteger a, BigInteger b);
    public static bool op_Inequality(BigInteger a, BigInteger b);
    public static bool op_GreaterThan(BigInteger a, BigInteger b);
    public static bool op_LessThan(BigInteger a, BigInteger b);
    public static bool op_GreaterThanOrEqual(BigInteger a, BigInteger b);
    public static bool op_LessThanOrEqual(BigInteger a, BigInteger b);
    public static BigInteger op_UnaryNegation(BigInteger n);
    public static BigInteger op_Addition(BigInteger a, BigInteger b);
    public static BigInteger op_Subtraction(BigInteger a, BigInteger b);
    public static BigInteger op_Multiply(BigInteger a, BigInteger b);
    public static BigInteger op_Division(BigInteger a, BigInteger b);
    public static BigInteger op_Modulus(BigInteger a, BigInteger b);
    public static BigInteger op_Increment(BigInteger n);
    public static BigInteger op_Decrement(BigInteger n);
    private static BigInteger Add(BigInteger a, BigInteger b);
    private static BigInteger Subtract(BigInteger a, BigInteger b);
    private static BigInteger Multiply(BigInteger a, BigInteger b);
    private static BigInteger DivideByOneDigitNumber(BigInteger a, long b);
    private static BigInteger DivideByBigNumber(BigInteger a, BigInteger b);
    private static bool DivideByBigNumberSmaller(BigInteger r, BigInteger dq, int k, int m);
    private static void Difference(BigInteger r, BigInteger dq, int k, int m);
    private static long Trial(BigInteger r, BigInteger d, int k, int m);
}
[SerializableAttribute]
public class BigIntegerLibrary.BigIntegerException : Exception {
    public BigIntegerException(string message, Exception innerException);
}
internal enum BigIntegerLibrary.Sign : Enum {
    public int value__;
    public static Sign Positive;
    public static Sign Negative;
}
[SerializableAttribute]
public class ZXing.Aztec.AztecEncodingOptions : EncodingOptions {
    public Nullable`1<int> ErrorCorrection { get; public set; }
    public Nullable`1<int> Layers { get; public set; }
    public string CharacterSet { get; public set; }
    public Nullable`1<int> get_ErrorCorrection();
    public void set_ErrorCorrection(Nullable`1<int> value);
    public Nullable`1<int> get_Layers();
    public void set_Layers(Nullable`1<int> value);
    public string get_CharacterSet();
    public void set_CharacterSet(string value);
}
public class ZXing.Aztec.AztecReader : object {
    public sealed virtual Result decode(BinaryBitmap image);
    public sealed virtual Result decode(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
    public sealed virtual void reset();
}
public class ZXing.Aztec.AztecResultMetadata : object {
    [CompilerGeneratedAttribute]
private bool <Compact>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Datablocks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Layers>k__BackingField;
    public bool Compact { get; private set; }
    public int Datablocks { get; private set; }
    public int Layers { get; private set; }
    public AztecResultMetadata(bool compact, int datablocks, int layers);
    [CompilerGeneratedAttribute]
public bool get_Compact();
    [CompilerGeneratedAttribute]
private void set_Compact(bool value);
    [CompilerGeneratedAttribute]
public int get_Datablocks();
    [CompilerGeneratedAttribute]
private void set_Datablocks(int value);
    [CompilerGeneratedAttribute]
public int get_Layers();
    [CompilerGeneratedAttribute]
private void set_Layers(int value);
    public virtual string ToString();
}
public class ZXing.Aztec.AztecWriter : object {
    public static Encoding DEFAULT_CHARSET;
    private static AztecWriter();
    public sealed virtual BitMatrix encode(string contents, BarcodeFormat format, int width, int height);
    public sealed virtual BitMatrix encode(string contents, BarcodeFormat format, int width, int height, IDictionary`2<EncodeHintType, object> hints);
    public BitMatrix encode(Byte[] contents, BarcodeFormat format, int width, int height, IDictionary`2<EncodeHintType, object> hints);
    private BitMatrix encode(Byte[] contents, BarcodeFormat format, int width, int height, Encoding charset, IDictionary`2<EncodeHintType, object> hints);
    private static BitMatrix encode(Byte[] contents, BarcodeFormat format, int width, int height, Encoding charset, int eccPercent, int layers, bool disableEci, int margin);
    private static BitMatrix renderResult(AztecCode code, int width, int height, int margin);
}
public class ZXing.Aztec.Internal.AztecCode : object {
    [CompilerGeneratedAttribute]
private bool <isCompact>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Layers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <CodeWords>k__BackingField;
    [CompilerGeneratedAttribute]
private BitMatrix <Matrix>k__BackingField;
    public bool isCompact { get; public set; }
    public int Size { get; public set; }
    public int Layers { get; public set; }
    public int CodeWords { get; public set; }
    public BitMatrix Matrix { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_isCompact();
    [CompilerGeneratedAttribute]
public void set_isCompact(bool value);
    [CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
public void set_Size(int value);
    [CompilerGeneratedAttribute]
public int get_Layers();
    [CompilerGeneratedAttribute]
public void set_Layers(int value);
    [CompilerGeneratedAttribute]
public int get_CodeWords();
    [CompilerGeneratedAttribute]
public void set_CodeWords(int value);
    [CompilerGeneratedAttribute]
public BitMatrix get_Matrix();
    [CompilerGeneratedAttribute]
public void set_Matrix(BitMatrix value);
}
public class ZXing.Aztec.Internal.AztecDetectorResult : DetectorResult {
    [CompilerGeneratedAttribute]
private bool <Compact>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NbDatablocks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NbLayers>k__BackingField;
    public bool Compact { get; private set; }
    public int NbDatablocks { get; private set; }
    public int NbLayers { get; private set; }
    public AztecDetectorResult(BitMatrix bits, ResultPoint[] points, bool compact, int nbDatablocks, int nbLayers);
    [CompilerGeneratedAttribute]
public bool get_Compact();
    [CompilerGeneratedAttribute]
private void set_Compact(bool value);
    [CompilerGeneratedAttribute]
public int get_NbDatablocks();
    [CompilerGeneratedAttribute]
private void set_NbDatablocks(int value);
    [CompilerGeneratedAttribute]
public int get_NbLayers();
    [CompilerGeneratedAttribute]
private void set_NbLayers(int value);
}
public class ZXing.Aztec.Internal.BinaryShiftToken : Token {
    private int binaryShiftStart;
    private int binaryShiftByteCount;
    public BinaryShiftToken(Token previous, int binaryShiftStart, int binaryShiftByteCount);
    public virtual void appendTo(BitArray bitArray, Byte[] text);
    public virtual string ToString();
}
public class ZXing.Aztec.Internal.Decoder : object {
    private static String[] UPPER_TABLE;
    private static String[] LOWER_TABLE;
    private static String[] MIXED_TABLE;
    private static String[] PUNCT_TABLE;
    private static String[] DIGIT_TABLE;
    private static Encoding DEFAULT_ENCODING;
    private static IDictionary`2<Table, String[]> codeTables;
    private static IDictionary`2<char, Table> codeTableMap;
    private AztecDetectorResult ddata;
    private static Decoder();
    public DecoderResult decode(AztecDetectorResult detectorResult);
    public static string highLevelDecode(Boolean[] correctedBits);
    private static string getEncodedData(Boolean[] correctedBits);
    private static Table getTable(char t);
    private static string getCharacter(String[] table, int code);
    private CorrectedBitsResult correctBits(Boolean[] rawbits);
    private Boolean[] extractBits(BitMatrix matrix);
    private static int readCode(Boolean[] rawbits, int startIndex, int length);
    private static byte readByte(Boolean[] rawbits, int startIndex);
    internal static Byte[] convertBoolArrayToByteArray(Boolean[] boolArr);
    private static int totalBitsInLayer(int layers, bool compact);
}
public class ZXing.Aztec.Internal.Detector : object {
    private static Int32[] EXPECTED_CORNER_BITS;
    private BitMatrix image;
    private bool compact;
    private int nbLayers;
    private int nbDataBlocks;
    private int nbCenterLayers;
    private int shift;
    public Detector(BitMatrix image);
    private static Detector();
    public AztecDetectorResult detect();
    public AztecDetectorResult detect(bool isMirror);
    private bool extractParameters(ResultPoint[] bullsEyeCorners);
    private static int getRotation(Int32[] sides, int length);
    private static int getCorrectedParameterData(long parameterData, bool compact);
    private ResultPoint[] getBullsEyeCorners(Point pCenter);
    private Point getMatrixCenter();
    private ResultPoint[] getMatrixCornerPoints(ResultPoint[] bullsEyeCorners);
    private BitMatrix sampleGrid(BitMatrix image, ResultPoint topLeft, ResultPoint topRight, ResultPoint bottomRight, ResultPoint bottomLeft);
    private int sampleLine(ResultPoint p1, ResultPoint p2, int size);
    private bool isWhiteOrBlackRectangle(Point p1, Point p2, Point p3, Point p4);
    private int getColor(Point p1, Point p2);
    private Point getFirstDifferent(Point init, bool color, int dx, int dy);
    private static ResultPoint[] expandSquare(ResultPoint[] cornerPoints, int oldSide, int newSide);
    private bool isValid(int x, int y);
    private bool isValid(ResultPoint point);
    private static float distance(Point a, Point b);
    private static float distance(ResultPoint a, ResultPoint b);
    private int getDimension();
}
public static class ZXing.Aztec.Internal.Encoder : object {
    public static int DEFAULT_EC_PERCENT;
    public static int DEFAULT_AZTEC_LAYERS;
    private static int MAX_NB_BITS;
    private static int MAX_NB_BITS_COMPACT;
    private static Int32[] WORD_SIZE;
    private static Encoder();
    public static AztecCode encode(string data);
    public static AztecCode encode(string data, int minECCPercent, int userSpecifiedLayers);
    public static AztecCode encode(string data, int minECCPercent, int userSpecifiedLayers, Encoding encoding);
    public static AztecCode encode(string data, int minECCPercent, int userSpecifiedLayers, Encoding encoding, bool disableEci);
    public static AztecCode encode(Byte[] data);
    public static AztecCode encode(Byte[] data, int minECCPercent, int userSpecifiedLayers);
    public static AztecCode encode(Byte[] data, int minECCPercent, int userSpecifiedLayers, Encoding encoding);
    public static AztecCode encode(Byte[] data, int minECCPercent, int userSpecifiedLayers, Encoding encoding, bool disableEci);
    private static void drawBullsEye(BitMatrix matrix, int center, int size);
    internal static BitArray generateModeMessage(bool compact, int layers, int messageSizeInWords);
    private static void drawModeMessage(BitMatrix matrix, bool compact, int matrixSize, BitArray modeMessage);
    private static BitArray generateCheckWords(BitArray bitArray, int totalBits, int wordSize);
    private static Int32[] bitsToWords(BitArray stuffedBits, int wordSize, int totalWords);
    private static GenericGF getGF(int wordSize);
    internal static BitArray stuffBits(BitArray bits, int wordSize);
    private static int TotalBitsInLayer(int layers, bool compact);
}
public class ZXing.Aztec.Internal.HighLevelEncoder : object {
    internal static String[] MODE_NAMES;
    internal static int MODE_UPPER;
    internal static int MODE_LOWER;
    internal static int MODE_DIGIT;
    internal static int MODE_MIXED;
    internal static int MODE_PUNCT;
    internal static Int32[][] LATCH_TABLE;
    internal static Int32[][] CHAR_MAP;
    internal static Int32[][] SHIFT_TABLE;
    private Byte[] text;
    private Encoding encoding;
    private bool disableEci;
    private static HighLevelEncoder();
    public HighLevelEncoder(Byte[] text);
    public HighLevelEncoder(Byte[] text, Encoding encoding);
    public HighLevelEncoder(Byte[] text, Encoding encoding, bool disableEci);
    public BitArray encode();
    private ICollection`1<State> updateStateListForChar(IEnumerable`1<State> states, int index);
    private void updateStateForChar(State state, int index, ICollection`1<State> result);
    private static ICollection`1<State> updateStateListForPair(IEnumerable`1<State> states, int index, int pairCode);
    private static void updateStateForPair(State state, int index, int pairCode, ICollection`1<State> result);
    private static ICollection`1<State> simplifyStates(IEnumerable`1<State> states);
}
public class ZXing.Aztec.Internal.SimpleToken : Token {
    private short value;
    private short bitCount;
    public SimpleToken(Token previous, int value, int bitCount);
    public virtual void appendTo(BitArray bitArray, Byte[] text);
    public virtual string ToString();
}
internal class ZXing.Aztec.Internal.State : object {
    public static State INITIAL_STATE;
    private int mode;
    private Token token;
    private int binaryShiftByteCount;
    private int bitCount;
    private int binaryShiftCost;
    public int Mode { get; }
    public Token Token { get; }
    public int BinaryShiftByteCount { get; }
    public int BitCount { get; }
    public State(Token token, int mode, int binaryBytes, int bitCount);
    private static State();
    public int get_Mode();
    public Token get_Token();
    public int get_BinaryShiftByteCount();
    public int get_BitCount();
    public State appendFLGn(int eci);
    public State latchAndAppend(int mode, int value);
    public State shiftAndAppend(int mode, int value);
    public State addBinaryShiftChar(int index);
    public State endBinaryShift(int index);
    public bool isBetterThanOrEqualTo(State other);
    public BitArray toBitArray(Byte[] text);
    public virtual string ToString();
    private static int calculateBinaryShiftCost(int binaryShiftByteCount);
}
public abstract class ZXing.Aztec.Internal.Token : object {
    public static Token EMPTY;
    private Token previous;
    public Token Previous { get; }
    protected Token(Token previous);
    private static Token();
    public Token get_Previous();
    public Token add(int value, int bitCount);
    public Token addBinaryShift(int start, int byteCount);
    public abstract virtual void appendTo(BitArray bitArray, Byte[] text);
}
[FlagsAttribute]
public enum ZXing.BarcodeFormat : Enum {
    public int value__;
    public static BarcodeFormat AZTEC;
    public static BarcodeFormat CODABAR;
    public static BarcodeFormat CODE_39;
    public static BarcodeFormat CODE_93;
    public static BarcodeFormat CODE_128;
    public static BarcodeFormat DATA_MATRIX;
    public static BarcodeFormat EAN_8;
    public static BarcodeFormat EAN_13;
    public static BarcodeFormat ITF;
    public static BarcodeFormat MAXICODE;
    public static BarcodeFormat PDF_417;
    public static BarcodeFormat QR_CODE;
    public static BarcodeFormat RSS_14;
    public static BarcodeFormat RSS_EXPANDED;
    public static BarcodeFormat UPC_A;
    public static BarcodeFormat UPC_E;
    public static BarcodeFormat UPC_EAN_EXTENSION;
    public static BarcodeFormat MSI;
    public static BarcodeFormat PLESSEY;
    public static BarcodeFormat IMB;
    public static BarcodeFormat PHARMA_CODE;
    public static BarcodeFormat All_1D;
}
[CLSCompliantAttribute("False")]
public class ZXing.BarcodeReader : BarcodeReader`1<WriteableBitmap> {
    private static Func`2<WriteableBitmap, LuminanceSource> defaultCreateLuminanceSource;
    public BarcodeReader(Reader reader, Func`2<WriteableBitmap, LuminanceSource> createLuminanceSource, Func`2<LuminanceSource, Binarizer> createBinarizer);
    public BarcodeReader(Reader reader, Func`2<WriteableBitmap, LuminanceSource> createLuminanceSource, Func`2<LuminanceSource, Binarizer> createBinarizer, Func`5<Byte[], int, int, BitmapFormat, LuminanceSource> createRGBLuminanceSource);
    private static BarcodeReader();
}
public class ZXing.BarcodeReader`1 : BarcodeReaderGeneric {
    private Func`2<T, LuminanceSource> createLuminanceSource;
    protected Func`2<T, LuminanceSource> CreateLuminanceSource { get; }
    public BarcodeReader`1(Func`2<T, LuminanceSource> createLuminanceSource);
    public BarcodeReader`1(Reader reader, Func`2<T, LuminanceSource> createLuminanceSource, Func`2<LuminanceSource, Binarizer> createBinarizer);
    public BarcodeReader`1(Reader reader, Func`2<T, LuminanceSource> createLuminanceSource, Func`2<LuminanceSource, Binarizer> createBinarizer, Func`5<Byte[], int, int, BitmapFormat, LuminanceSource> createRGBLuminanceSource);
    protected BarcodeReader`1(Reader reader, Func`2<LuminanceSource, Binarizer> createBinarizer, Func`5<Byte[], int, int, BitmapFormat, LuminanceSource> createRGBLuminanceSource);
    protected Func`2<T, LuminanceSource> get_CreateLuminanceSource();
    public sealed virtual Result Decode(T barcodeBitmap);
    public sealed virtual Result[] DecodeMultiple(T barcodeBitmap);
}
public class ZXing.BarcodeReaderGeneric : object {
    private static Func`2<LuminanceSource, Binarizer> defaultCreateBinarizer;
    protected static Func`5<Byte[], int, int, BitmapFormat, LuminanceSource> defaultCreateRGBLuminanceSource;
    private Reader reader;
    private Func`5<Byte[], int, int, BitmapFormat, LuminanceSource> createRGBLuminanceSource;
    private Func`2<LuminanceSource, Binarizer> createBinarizer;
    private bool usePreviousState;
    private DecodingOptions options;
    [CompilerGeneratedAttribute]
private Action`1<ResultPoint> explicitResultPointFound;
    [CompilerGeneratedAttribute]
private Action`1<Result> ResultFound;
    [CompilerGeneratedAttribute]
private bool <AutoRotate>k__BackingField;
    public DecodingOptions Options { get; public set; }
    protected Reader Reader { get; }
    public bool AutoRotate { get; public set; }
    [ObsoleteAttribute("Please use Options.TryInverted")]
public bool TryInverted { get; public set; }
    protected Func`2<LuminanceSource, Binarizer> CreateBinarizer { get; }
    public BarcodeReaderGeneric(Reader reader, Func`2<LuminanceSource, Binarizer> createBinarizer, Func`5<Byte[], int, int, BitmapFormat, LuminanceSource> createRGBLuminanceSource);
    private static BarcodeReaderGeneric();
    public sealed virtual DecodingOptions get_Options();
    public sealed virtual void set_Options(DecodingOptions value);
    protected Reader get_Reader();
    public sealed virtual void add_ResultPointFound(Action`1<ResultPoint> value);
    public sealed virtual void remove_ResultPointFound(Action`1<ResultPoint> value);
    [CompilerGeneratedAttribute]
private void add_explicitResultPointFound(Action`1<ResultPoint> value);
    [CompilerGeneratedAttribute]
private void remove_explicitResultPointFound(Action`1<ResultPoint> value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ResultFound(Action`1<Result> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ResultFound(Action`1<Result> value);
    [CompilerGeneratedAttribute]
public bool get_AutoRotate();
    [CompilerGeneratedAttribute]
public void set_AutoRotate(bool value);
    public bool get_TryInverted();
    public void set_TryInverted(bool value);
    protected Func`2<LuminanceSource, Binarizer> get_CreateBinarizer();
    public virtual Result Decode(LuminanceSource luminanceSource);
    public virtual Result[] DecodeMultiple(LuminanceSource luminanceSource);
    protected void OnResultsFound(IEnumerable`1<Result> results);
    protected void OnResultFound(Result result);
    protected void OnResultPointFound(ResultPoint resultPoint);
    public sealed virtual Result Decode(Byte[] rawRGB, int width, int height, BitmapFormat format);
    public sealed virtual Result[] DecodeMultiple(Byte[] rawRGB, int width, int height, BitmapFormat format);
    [CompilerGeneratedAttribute]
private void <get_Options>b__8_0(object o, EventArgs args);
    [CompilerGeneratedAttribute]
private void <set_Options>b__9_0(object o, EventArgs args);
}
[CLSCompliantAttribute("False")]
public class ZXing.BarcodeWriter : BarcodeWriter`1<WriteableBitmap> {
}
public class ZXing.BarcodeWriter`1 : BarcodeWriterGeneric {
    [CompilerGeneratedAttribute]
private IBarcodeRenderer`1<TOutput> <Renderer>k__BackingField;
    public IBarcodeRenderer`1<TOutput> Renderer { get; public set; }
    [CompilerGeneratedAttribute]
public IBarcodeRenderer`1<TOutput> get_Renderer();
    [CompilerGeneratedAttribute]
public void set_Renderer(IBarcodeRenderer`1<TOutput> value);
    public sealed virtual TOutput Write(string contents);
    public sealed virtual TOutput Write(BitMatrix matrix);
}
public class ZXing.BarcodeWriterGeneric : object {
    private EncodingOptions options;
    [CompilerGeneratedAttribute]
private BarcodeFormat <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private Writer <Encoder>k__BackingField;
    public BarcodeFormat Format { get; public set; }
    public EncodingOptions Options { get; public set; }
    public Writer Encoder { get; public set; }
    public BarcodeWriterGeneric(Writer encoder);
    [CompilerGeneratedAttribute]
public sealed virtual BarcodeFormat get_Format();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Format(BarcodeFormat value);
    public sealed virtual EncodingOptions get_Options();
    public sealed virtual void set_Options(EncodingOptions value);
    [CompilerGeneratedAttribute]
public sealed virtual Writer get_Encoder();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Encoder(Writer value);
    public sealed virtual BitMatrix Encode(string contents);
}
public class ZXing.BarcodeWriterPixelData : BarcodeWriter`1<PixelData> {
}
public class ZXing.BarcodeWriterSvg : BarcodeWriter`1<SvgImage> {
}
public abstract class ZXing.BaseLuminanceSource : LuminanceSource {
    protected static int RChannelWeight;
    protected static int GChannelWeight;
    protected static int BChannelWeight;
    protected static int ChannelWeight;
    protected Byte[] luminances;
    public Byte[] Matrix { get; }
    public bool RotateSupported { get; }
    public bool CropSupported { get; }
    public bool InversionSupported { get; }
    protected BaseLuminanceSource(int width, int height);
    protected BaseLuminanceSource(Byte[] luminanceArray, int width, int height);
    public virtual Byte[] getRow(int y, Byte[] row);
    public virtual Byte[] get_Matrix();
    public virtual LuminanceSource rotateCounterClockwise();
    public virtual LuminanceSource rotateCounterClockwise45();
    public virtual bool get_RotateSupported();
    public virtual LuminanceSource crop(int left, int top, int width, int height);
    public virtual bool get_CropSupported();
    public virtual bool get_InversionSupported();
    public virtual LuminanceSource invert();
    protected abstract virtual LuminanceSource CreateLuminanceSource(Byte[] newLuminances, int width, int height);
}
public abstract class ZXing.Binarizer : object {
    private LuminanceSource source;
    public LuminanceSource LuminanceSource { get; }
    public BitMatrix BlackMatrix { get; }
    public int Width { get; }
    public int Height { get; }
    protected internal Binarizer(LuminanceSource source);
    public virtual LuminanceSource get_LuminanceSource();
    public abstract virtual BitArray getBlackRow(int y, BitArray row);
    public abstract virtual BitMatrix get_BlackMatrix();
    public abstract virtual Binarizer createBinarizer(LuminanceSource source);
    public int get_Width();
    public int get_Height();
}
public class ZXing.BinaryBitmap : object {
    private Binarizer binarizer;
    private BitMatrix matrix;
    public int Width { get; }
    public int Height { get; }
    public BitMatrix BlackMatrix { get; }
    public bool CropSupported { get; }
    public bool RotateSupported { get; }
    public BinaryBitmap(Binarizer binarizer);
    internal BinaryBitmap(BitMatrix matrix);
    public int get_Width();
    public int get_Height();
    public BitArray getBlackRow(int y, BitArray row);
    public BitMatrix get_BlackMatrix();
    public bool get_CropSupported();
    public BinaryBitmap crop(int left, int top, int width, int height);
    public bool get_RotateSupported();
    public BinaryBitmap rotateCounterClockwise();
    public BinaryBitmap rotateCounterClockwise45();
    public virtual string ToString();
}
public class ZXing.BitmapLuminanceSource : BaseLuminanceSource {
    protected BitmapLuminanceSource(int width, int height);
    public BitmapLuminanceSource(WriteableBitmap writeableBitmap);
    protected virtual LuminanceSource CreateLuminanceSource(Byte[] newLuminances, int width, int height);
}
internal abstract class ZXing.Client.Result.AbstractDoCoMoResultParser : ResultParser {
    internal static String[] matchDoCoMoPrefixedField(string prefix, string rawText);
    internal static string matchSingleDoCoMoPrefixedField(string prefix, string rawText, bool trim);
}
internal class ZXing.Client.Result.AddressBookAUResultParser : ResultParser {
    public virtual ParsedResult parse(Result result);
    private static String[] matchMultipleValuePrefix(string prefix, string rawText);
}
internal class ZXing.Client.Result.AddressBookDoCoMoResultParser : AbstractDoCoMoResultParser {
    public virtual ParsedResult parse(Result result);
    private static string parseName(string name);
}
public class ZXing.Client.Result.AddressBookParsedResult : ParsedResult {
    private String[] names;
    private String[] nicknames;
    private string pronunciation;
    private String[] phoneNumbers;
    private String[] phoneTypes;
    private String[] emails;
    private String[] emailTypes;
    private string instantMessenger;
    private string note;
    private String[] addresses;
    private String[] addressTypes;
    private string org;
    private string birthday;
    private string title;
    private String[] urls;
    private String[] geo;
    public String[] Names { get; }
    public String[] Nicknames { get; }
    public string Pronunciation { get; }
    public String[] PhoneNumbers { get; }
    public String[] PhoneTypes { get; }
    public String[] Emails { get; }
    public String[] EmailTypes { get; }
    public string InstantMessenger { get; }
    public string Note { get; }
    public String[] Addresses { get; }
    public String[] AddressTypes { get; }
    public string Title { get; }
    public string Org { get; }
    public String[] URLs { get; }
    public string Birthday { get; }
    public String[] Geo { get; }
    public AddressBookParsedResult(String[] names, String[] phoneNumbers, String[] phoneTypes, String[] emails, String[] emailTypes, String[] addresses, String[] addressTypes);
    public AddressBookParsedResult(String[] names, String[] nicknames, string pronunciation, String[] phoneNumbers, String[] phoneTypes, String[] emails, String[] emailTypes, string instantMessenger, string note, String[] addresses, String[] addressTypes, string org, string birthday, string title, String[] urls, String[] geo);
    public String[] get_Names();
    public String[] get_Nicknames();
    public string get_Pronunciation();
    public String[] get_PhoneNumbers();
    public String[] get_PhoneTypes();
    public String[] get_Emails();
    public String[] get_EmailTypes();
    public string get_InstantMessenger();
    public string get_Note();
    public String[] get_Addresses();
    public String[] get_AddressTypes();
    public string get_Title();
    public string get_Org();
    public String[] get_URLs();
    public string get_Birthday();
    public String[] get_Geo();
    private string getDisplayResult();
}
internal class ZXing.Client.Result.BizcardResultParser : AbstractDoCoMoResultParser {
    public virtual ParsedResult parse(Result result);
    private static String[] buildPhoneNumbers(string number1, string number2, string number3);
    private static string buildName(string firstName, string lastName);
}
internal class ZXing.Client.Result.BookmarkDoCoMoResultParser : AbstractDoCoMoResultParser {
    public virtual ParsedResult parse(Result result);
}
public class ZXing.Client.Result.CalendarParsedResult : ParsedResult {
    private static Regex RFC2445_DURATION;
    private static Int64[] RFC2445_DURATION_FIELD_UNITS;
    private static Regex DATE_TIME;
    private string summary;
    private DateTime start;
    private bool startAllDay;
    private Nullable`1<DateTime> end;
    private bool endAllDay;
    private string location;
    private string organizer;
    private String[] attendees;
    private string description;
    private double latitude;
    private double longitude;
    public string Summary { get; }
    public DateTime Start { get; }
    public Nullable`1<DateTime> End { get; }
    public bool isEndAllDay { get; }
    public string Location { get; }
    public string Organizer { get; }
    public String[] Attendees { get; }
    public string Description { get; }
    public double Latitude { get; }
    public double Longitude { get; }
    public CalendarParsedResult(string summary, string startString, string endString, string durationString, string location, string organizer, String[] attendees, string description, double latitude, double longitude);
    private static CalendarParsedResult();
    public string get_Summary();
    public DateTime get_Start();
    public bool isStartAllDay();
    public Nullable`1<DateTime> get_End();
    public bool get_isEndAllDay();
    public string get_Location();
    public string get_Organizer();
    public String[] get_Attendees();
    public string get_Description();
    public double get_Latitude();
    public double get_Longitude();
    private static DateTime parseDate(string when);
    private static string format(bool allDay, Nullable`1<DateTime> date);
    private static long parseDurationMS(string durationString);
    private static DateTime parseDateTimeString(string dateTimeString);
}
public class ZXing.Client.Result.EmailAddressParsedResult : ParsedResult {
    [CompilerGeneratedAttribute]
private String[] <Tos>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <CCs>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <BCCs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Body>k__BackingField;
    public string EmailAddress { get; }
    public String[] Tos { get; private set; }
    public String[] CCs { get; private set; }
    public String[] BCCs { get; private set; }
    public string Subject { get; private set; }
    public string Body { get; private set; }
    [ObsoleteAttribute("deprecated without replacement")]
public string MailtoURI { get; }
    internal EmailAddressParsedResult(string to);
    internal EmailAddressParsedResult(String[] tos, String[] ccs, String[] bccs, string subject, string body);
    public string get_EmailAddress();
    [CompilerGeneratedAttribute]
public String[] get_Tos();
    [CompilerGeneratedAttribute]
private void set_Tos(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_CCs();
    [CompilerGeneratedAttribute]
private void set_CCs(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_BCCs();
    [CompilerGeneratedAttribute]
private void set_BCCs(String[] value);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(string value);
    [CompilerGeneratedAttribute]
public string get_Body();
    [CompilerGeneratedAttribute]
private void set_Body(string value);
    public string get_MailtoURI();
}
internal class ZXing.Client.Result.EmailAddressResultParser : ResultParser {
    private static Regex COMMA;
    private static EmailAddressResultParser();
    public virtual ParsedResult parse(Result result);
}
internal class ZXing.Client.Result.EmailDoCoMoResultParser : AbstractDoCoMoResultParser {
    private static Regex ATEXT_ALPHANUMERIC;
    private static EmailDoCoMoResultParser();
    public virtual ParsedResult parse(Result result);
    internal static bool isBasicallyValidEmailAddress(string email);
}
public class ZXing.Client.Result.ExpandedProductParsedResult : ParsedResult {
    public static string KILOGRAM;
    public static string POUND;
    private string rawText;
    private string productID;
    private string sscc;
    private string lotNumber;
    private string productionDate;
    private string packagingDate;
    private string bestBeforeDate;
    private string expirationDate;
    private string weight;
    private string weightType;
    private string weightIncrement;
    private string price;
    private string priceIncrement;
    private string priceCurrency;
    private IDictionary`2<string, string> uncommonAIs;
    public string RawText { get; }
    public string ProductID { get; }
    public string Sscc { get; }
    public string LotNumber { get; }
    public string ProductionDate { get; }
    public string PackagingDate { get; }
    public string BestBeforeDate { get; }
    public string ExpirationDate { get; }
    public string Weight { get; }
    public string WeightType { get; }
    public string WeightIncrement { get; }
    public string Price { get; }
    public string PriceIncrement { get; }
    public string PriceCurrency { get; }
    public IDictionary`2<string, string> UncommonAIs { get; }
    public string DisplayResult { get; }
    public ExpandedProductParsedResult(string rawText, string productID, string sscc, string lotNumber, string productionDate, string packagingDate, string bestBeforeDate, string expirationDate, string weight, string weightType, string weightIncrement, string price, string priceIncrement, string priceCurrency, IDictionary`2<string, string> uncommonAIs);
    private static ExpandedProductParsedResult();
    public virtual bool Equals(object o);
    private static bool equalsOrNull(object o1, object o2);
    private static bool equalsOrNull(IDictionary`2<string, string> o1, IDictionary`2<string, string> o2);
    public virtual int GetHashCode();
    private static int hashNotNull(object o);
    public string get_RawText();
    public string get_ProductID();
    public string get_Sscc();
    public string get_LotNumber();
    public string get_ProductionDate();
    public string get_PackagingDate();
    public string get_BestBeforeDate();
    public string get_ExpirationDate();
    public string get_Weight();
    public string get_WeightType();
    public string get_WeightIncrement();
    public string get_Price();
    public string get_PriceIncrement();
    public string get_PriceCurrency();
    public IDictionary`2<string, string> get_UncommonAIs();
    public virtual string get_DisplayResult();
}
public class ZXing.Client.Result.ExpandedProductResultParser : ResultParser {
    public virtual ParsedResult parse(Result result);
    private static string findAIvalue(int i, string rawText);
    private static string findValue(int i, string rawText);
}
public class ZXing.Client.Result.GeoParsedResult : ParsedResult {
    [CompilerGeneratedAttribute]
private double <Latitude>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Longitude>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Altitude>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Query>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GeoURI>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GoogleMapsURI>k__BackingField;
    public double Latitude { get; private set; }
    public double Longitude { get; private set; }
    public double Altitude { get; private set; }
    public string Query { get; private set; }
    public string GeoURI { get; private set; }
    public string GoogleMapsURI { get; private set; }
    internal GeoParsedResult(double latitude, double longitude, double altitude, string query);
    [CompilerGeneratedAttribute]
public double get_Latitude();
    [CompilerGeneratedAttribute]
private void set_Latitude(double value);
    [CompilerGeneratedAttribute]
public double get_Longitude();
    [CompilerGeneratedAttribute]
private void set_Longitude(double value);
    [CompilerGeneratedAttribute]
public double get_Altitude();
    [CompilerGeneratedAttribute]
private void set_Altitude(double value);
    [CompilerGeneratedAttribute]
public string get_Query();
    [CompilerGeneratedAttribute]
private void set_Query(string value);
    [CompilerGeneratedAttribute]
public string get_GeoURI();
    [CompilerGeneratedAttribute]
private void set_GeoURI(string value);
    [CompilerGeneratedAttribute]
public string get_GoogleMapsURI();
    [CompilerGeneratedAttribute]
private void set_GoogleMapsURI(string value);
    private string getDisplayResult();
    private string getGeoURI();
    private string getGoogleMapsURI();
}
internal class ZXing.Client.Result.GeoResultParser : ResultParser {
    private static Regex GEO_URL_PATTERN;
    private static GeoResultParser();
    public virtual ParsedResult parse(Result result);
}
public class ZXing.Client.Result.ISBNParsedResult : ParsedResult {
    [CompilerGeneratedAttribute]
private string <ISBN>k__BackingField;
    public string ISBN { get; private set; }
    internal ISBNParsedResult(string isbn);
    [CompilerGeneratedAttribute]
public string get_ISBN();
    [CompilerGeneratedAttribute]
private void set_ISBN(string value);
}
public class ZXing.Client.Result.ISBNResultParser : ResultParser {
    public virtual ParsedResult parse(Result result);
}
public abstract class ZXing.Client.Result.ParsedResult : object {
    protected string displayResultValue;
    [CompilerGeneratedAttribute]
private ParsedResultType <Type>k__BackingField;
    public ParsedResultType Type { get; private set; }
    public string DisplayResult { get; }
    protected ParsedResult(ParsedResultType type);
    [CompilerGeneratedAttribute]
public virtual ParsedResultType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(ParsedResultType value);
    public virtual string get_DisplayResult();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static void maybeAppend(string value, StringBuilder result);
    public static void maybeAppend(String[] values, StringBuilder result);
}
public enum ZXing.Client.Result.ParsedResultType : Enum {
    public int value__;
    public static ParsedResultType ADDRESSBOOK;
    public static ParsedResultType EMAIL_ADDRESS;
    public static ParsedResultType PRODUCT;
    public static ParsedResultType URI;
    public static ParsedResultType TEXT;
    public static ParsedResultType GEO;
    public static ParsedResultType TEL;
    public static ParsedResultType SMS;
    public static ParsedResultType CALENDAR;
    public static ParsedResultType WIFI;
    public static ParsedResultType ISBN;
    public static ParsedResultType VIN;
}
public class ZXing.Client.Result.ProductParsedResult : ParsedResult {
    [CompilerGeneratedAttribute]
private string <ProductID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NormalizedProductID>k__BackingField;
    public string ProductID { get; private set; }
    public string NormalizedProductID { get; private set; }
    internal ProductParsedResult(string productID);
    internal ProductParsedResult(string productID, string normalizedProductID);
    [CompilerGeneratedAttribute]
public string get_ProductID();
    [CompilerGeneratedAttribute]
private void set_ProductID(string value);
    [CompilerGeneratedAttribute]
public string get_NormalizedProductID();
    [CompilerGeneratedAttribute]
private void set_NormalizedProductID(string value);
}
internal class ZXing.Client.Result.ProductResultParser : ResultParser {
    public virtual ParsedResult parse(Result result);
}
public abstract class ZXing.Client.Result.ResultParser : object {
    private static ResultParser[] PARSERS;
    private static Regex DIGITS;
    private static Regex AMPERSAND;
    private static Regex EQUALS;
    private static ResultParser();
    public abstract virtual ParsedResult parse(Result theResult);
    public static ParsedResult parseResult(Result theResult);
    protected static void maybeAppend(string value, StringBuilder result);
    protected static void maybeAppend(String[] value, StringBuilder result);
    protected static String[] maybeWrap(string value);
    protected static string unescapeBackslash(string escaped);
    protected static int parseHexDigit(char c);
    internal static bool isStringOfDigits(string value, int length);
    internal static bool isSubstringOfDigits(string value, int offset, int length);
    internal static IDictionary`2<string, string> parseNameValuePairs(string uri);
    private static void appendKeyValue(string keyValue, IDictionary`2<string, string> result);
    internal static String[] matchPrefixedField(string prefix, string rawText, char endChar, bool trim);
    private static int countPrecedingBackslashes(string s, int pos);
    internal static string matchSinglePrefixedField(string prefix, string rawText, char endChar, bool trim);
    protected static string urlDecode(string escaped);
    private static int findFirstEscape(Char[] escapedArray);
}
internal class ZXing.Client.Result.SMSMMSResultParser : ResultParser {
    public virtual ParsedResult parse(Result result);
    private static void addNumberVia(ICollection`1<string> numbers, ICollection`1<string> vias, string numberPart);
}
public class ZXing.Client.Result.SMSParsedResult : ParsedResult {
    [CompilerGeneratedAttribute]
private String[] <Numbers>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Vias>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SMSURI>k__BackingField;
    public String[] Numbers { get; private set; }
    public String[] Vias { get; private set; }
    public string Subject { get; private set; }
    public string Body { get; private set; }
    public string SMSURI { get; private set; }
    public SMSParsedResult(string number, string via, string subject, string body);
    public SMSParsedResult(String[] numbers, String[] vias, string subject, string body);
    private string getSMSURI();
    [CompilerGeneratedAttribute]
public String[] get_Numbers();
    [CompilerGeneratedAttribute]
private void set_Numbers(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_Vias();
    [CompilerGeneratedAttribute]
private void set_Vias(String[] value);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(string value);
    [CompilerGeneratedAttribute]
public string get_Body();
    [CompilerGeneratedAttribute]
private void set_Body(string value);
    [CompilerGeneratedAttribute]
public string get_SMSURI();
    [CompilerGeneratedAttribute]
private void set_SMSURI(string value);
}
public class ZXing.Client.Result.SMSTOMMSTOResultParser : ResultParser {
    public virtual ParsedResult parse(Result result);
}
public class ZXing.Client.Result.SMTPResultParser : ResultParser {
    public virtual ParsedResult parse(Result result);
}
public class ZXing.Client.Result.TelParsedResult : ParsedResult {
    [CompilerGeneratedAttribute]
private string <Number>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TelURI>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Number { get; private set; }
    public string TelURI { get; private set; }
    public string Title { get; private set; }
    public TelParsedResult(string number, string telURI, string title);
    [CompilerGeneratedAttribute]
public string get_Number();
    [CompilerGeneratedAttribute]
private void set_Number(string value);
    [CompilerGeneratedAttribute]
public string get_TelURI();
    [CompilerGeneratedAttribute]
private void set_TelURI(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
private void set_Title(string value);
}
internal class ZXing.Client.Result.TelResultParser : ResultParser {
    public virtual ParsedResult parse(Result result);
}
public class ZXing.Client.Result.TextParsedResult : ParsedResult {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Text { get; private set; }
    public string Language { get; private set; }
    public TextParsedResult(string text, string language);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
private void set_Language(string value);
}
public class ZXing.Client.Result.URIParsedResult : ParsedResult {
    [CompilerGeneratedAttribute]
private string <URI>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PossiblyMaliciousURI>k__BackingField;
    public string URI { get; private set; }
    public string Title { get; private set; }
    [ObsoleteAttribute("deprecated, see {@link URIResultParser#isPossiblyMaliciousURI(String)")]
public bool PossiblyMaliciousURI { get; private set; }
    public URIParsedResult(string uri, string title);
    [CompilerGeneratedAttribute]
public string get_URI();
    [CompilerGeneratedAttribute]
private void set_URI(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
private void set_Title(string value);
    [CompilerGeneratedAttribute]
public bool get_PossiblyMaliciousURI();
    [CompilerGeneratedAttribute]
private void set_PossiblyMaliciousURI(bool value);
    private static string massageURI(string uri);
    private static bool isColonFollowedByPortNumber(string uri, int protocolEnd);
}
internal class ZXing.Client.Result.URIResultParser : ResultParser {
    private static Regex ALLOWED_URI_CHARS_PATTERN;
    private static Regex USER_IN_HOST;
    private static Regex URL_WITH_PROTOCOL_PATTERN;
    private static Regex URL_WITHOUT_PROTOCOL_PATTERN;
    private static URIResultParser();
    public virtual ParsedResult parse(Result result);
    internal static bool isPossiblyMaliciousURI(string uri);
    internal static bool isBasicallyValidURI(string uri);
}
internal class ZXing.Client.Result.URLTOResultParser : ResultParser {
    public virtual ParsedResult parse(Result result);
}
internal class ZXing.Client.Result.VCardResultParser : ResultParser {
    private static Regex BEGIN_VCARD;
    private static Regex VCARD_LIKE_DATE;
    private static Regex CR_LF_SPACE_TAB;
    private static Regex NEWLINE_ESCAPE;
    private static Regex VCARD_ESCAPES;
    private static Regex EQUALS;
    private static Regex SEMICOLON;
    private static Regex UNESCAPED_SEMICOLONS;
    private static Regex COMMA;
    private static Regex SEMICOLON_OR_COMMA;
    private static VCardResultParser();
    public virtual ParsedResult parse(Result result);
    public static List`1<List`1<string>> matchVCardPrefixedField(string prefix, string rawText, bool trim, bool parseFieldDivider);
    private static string decodeQuotedPrintable(string value, string charset);
    private static void maybeAppendFragment(MemoryStream fragmentBuffer, string charset, StringBuilder result);
    internal static List`1<string> matchSingleVCardPrefixedField(string prefix, string rawText, bool trim, bool parseFieldDivider);
    private static string toPrimaryValue(List`1<string> list);
    private static String[] toPrimaryValues(ICollection`1<List`1<string>> lists);
    private static String[] toTypes(ICollection`1<List`1<string>> lists);
    private static bool isLikeVCardDate(string value);
    private static void formatNames(IEnumerable`1<List`1<string>> names);
    private static void maybeAppendComponent(String[] components, int i, StringBuilder newName);
}
internal class ZXing.Client.Result.VEventResultParser : ResultParser {
    public virtual ParsedResult parse(Result result);
    private static string matchSingleVCardPrefixedField(string prefix, string rawText);
    private static String[] matchVCardPrefixedField(string prefix, string rawText);
    private static string stripMailto(string s);
}
public class ZXing.Client.Result.VINParsedResult : ParsedResult {
    [CompilerGeneratedAttribute]
private string <VIN>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorldManufacturerID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VehicleDescriptorSection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VehicleIdentifierSection>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CountryCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VehicleAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ModelYear>k__BackingField;
    [CompilerGeneratedAttribute]
private char <PlantCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SequentialNumber>k__BackingField;
    public string VIN { get; private set; }
    public string WorldManufacturerID { get; private set; }
    public string VehicleDescriptorSection { get; private set; }
    public string VehicleIdentifierSection { get; private set; }
    public string CountryCode { get; private set; }
    public string VehicleAttributes { get; private set; }
    public int ModelYear { get; private set; }
    public char PlantCode { get; private set; }
    public string SequentialNumber { get; private set; }
    public string DisplayResult { get; }
    public VINParsedResult(string vin, string worldManufacturerID, string vehicleDescriptorSection, string vehicleIdentifierSection, string countryCode, string vehicleAttributes, int modelYear, char plantCode, string sequentialNumber);
    [CompilerGeneratedAttribute]
public string get_VIN();
    [CompilerGeneratedAttribute]
private void set_VIN(string value);
    [CompilerGeneratedAttribute]
public string get_WorldManufacturerID();
    [CompilerGeneratedAttribute]
private void set_WorldManufacturerID(string value);
    [CompilerGeneratedAttribute]
public string get_VehicleDescriptorSection();
    [CompilerGeneratedAttribute]
private void set_VehicleDescriptorSection(string value);
    [CompilerGeneratedAttribute]
public string get_VehicleIdentifierSection();
    [CompilerGeneratedAttribute]
private void set_VehicleIdentifierSection(string value);
    [CompilerGeneratedAttribute]
public string get_CountryCode();
    [CompilerGeneratedAttribute]
private void set_CountryCode(string value);
    [CompilerGeneratedAttribute]
public string get_VehicleAttributes();
    [CompilerGeneratedAttribute]
private void set_VehicleAttributes(string value);
    [CompilerGeneratedAttribute]
public int get_ModelYear();
    [CompilerGeneratedAttribute]
private void set_ModelYear(int value);
    [CompilerGeneratedAttribute]
public char get_PlantCode();
    [CompilerGeneratedAttribute]
private void set_PlantCode(char value);
    [CompilerGeneratedAttribute]
public string get_SequentialNumber();
    [CompilerGeneratedAttribute]
private void set_SequentialNumber(string value);
    public virtual string get_DisplayResult();
}
public class ZXing.Client.Result.VINResultParser : ResultParser {
    private static Regex IOQ;
    private static Regex AZ09;
    private static VINResultParser();
    public virtual ParsedResult parse(Result result);
    private static bool checkChecksum(string vin);
    private static int vinCharValue(char c);
    private static int vinPositionWeight(int position);
    private static char checkChar(int remainder);
    private static int modelYear(char c);
    private static string countryCode(string wmi);
}
public class ZXing.Client.Result.WifiParsedResult : ParsedResult {
    [CompilerGeneratedAttribute]
private string <Ssid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NetworkEncryption>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Hidden>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AnonymousIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EapMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Phase2Method>k__BackingField;
    public string Ssid { get; private set; }
    public string NetworkEncryption { get; private set; }
    public string Password { get; private set; }
    public bool Hidden { get; private set; }
    public string Identity { get; private set; }
    public string AnonymousIdentity { get; private set; }
    public string EapMethod { get; private set; }
    public string Phase2Method { get; private set; }
    public WifiParsedResult(string networkEncryption, string ssid, string password);
    public WifiParsedResult(string networkEncryption, string ssid, string password, bool hidden);
    public WifiParsedResult(string networkEncryption, string ssid, string password, bool hidden, string identity, string anonymousIdentity, string eapMethod, string phase2Method);
    [CompilerGeneratedAttribute]
public string get_Ssid();
    [CompilerGeneratedAttribute]
private void set_Ssid(string value);
    [CompilerGeneratedAttribute]
public string get_NetworkEncryption();
    [CompilerGeneratedAttribute]
private void set_NetworkEncryption(string value);
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
private void set_Password(string value);
    [CompilerGeneratedAttribute]
public bool get_Hidden();
    [CompilerGeneratedAttribute]
private void set_Hidden(bool value);
    [CompilerGeneratedAttribute]
public string get_Identity();
    [CompilerGeneratedAttribute]
private void set_Identity(string value);
    [CompilerGeneratedAttribute]
public string get_AnonymousIdentity();
    [CompilerGeneratedAttribute]
private void set_AnonymousIdentity(string value);
    [CompilerGeneratedAttribute]
public string get_EapMethod();
    [CompilerGeneratedAttribute]
private void set_EapMethod(string value);
    [CompilerGeneratedAttribute]
public string get_Phase2Method();
    [CompilerGeneratedAttribute]
private void set_Phase2Method(string value);
}
public class ZXing.Client.Result.WifiResultParser : ResultParser {
    public virtual ParsedResult parse(Result result);
}
[DefaultMemberAttribute("Item")]
public class ZXing.Common.BitArray : object {
    private static Int32[] EMPTY_BITS;
    private static float LOAD_FACTOR;
    private Int32[] bits;
    private int size;
    private static Int32[] _lookup;
    public int Size { get; }
    public int SizeInBytes { get; }
    public bool Item { get; public set; }
    public Int32[] Array { get; }
    public BitArray(int size);
    private BitArray(Int32[] bits, int size);
    private static BitArray();
    public int get_Size();
    public int get_SizeInBytes();
    public bool get_Item(int i);
    public void set_Item(int i, bool value);
    private void ensureCapacity(int newSize);
    public void flip(int i);
    private static int numberOfTrailingZeros(int num);
    public int getNextSet(int from);
    public int getNextUnset(int from);
    public void setBulk(int i, int newBits);
    public void setRange(int start, int end);
    public void clear();
    public bool isRange(int start, int end, bool value);
    public void appendBit(bool bit);
    public Int32[] get_Array();
    public void appendBits(int value, int numBits);
    public void appendBitArray(BitArray other);
    public void xor(BitArray other);
    public void toBytes(int bitOffset, Byte[] array, int offset, int numBytes);
    public void reverse();
    private static Int32[] makeArray(int size);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
    public object Clone();
}
[DefaultMemberAttribute("Item")]
public class ZXing.Common.BitMatrix : object {
    private int width;
    private int height;
    private int rowSize;
    private Int32[] bits;
    public int Width { get; }
    public int Height { get; }
    public int Dimension { get; }
    public int RowSize { get; }
    public bool Item { get; public set; }
    public BitMatrix(int dimension);
    public BitMatrix(int width, int height);
    internal BitMatrix(int width, int height, int rowSize, Int32[] bits);
    internal BitMatrix(int width, int height, Int32[] bits);
    public int get_Width();
    public int get_Height();
    public int get_Dimension();
    public int get_RowSize();
    public static BitMatrix parse(Boolean[][] image);
    public static BitMatrix parse(string stringRepresentation, string setString, string unsetString);
    public bool get_Item(int x, int y);
    public void set_Item(int x, int y, bool value);
    public void flip(int x, int y);
    public void flip();
    public void flipWhen(Func`3<int, int, bool> shouldBeFlipped);
    public void xor(BitMatrix mask);
    public void clear();
    public void setRegion(int left, int top, int width, int height);
    public BitArray getRow(int y, BitArray row);
    public void setRow(int y, BitArray row);
    public void rotate(int degrees);
    public void rotate180();
    public void rotate90();
    public Int32[] getEnclosingRectangle();
    public Int32[] getTopLeftOnBit();
    public Int32[] getBottomRightOnBit();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToString(string setString, string unsetString);
    public string ToString(string setString, string unsetString, string lineSeparator);
    private string buildToString(string setString, string unsetString, string lineSeparator);
    public object Clone();
    [ObsoleteAttribute("Use BarcodeWriter instead")]
[CLSCompliantAttribute("False")]
public WriteableBitmap ToBitmap();
    [ObsoleteAttribute("Use BarcodeWriter instead")]
[CLSCompliantAttribute("False")]
public WriteableBitmap ToBitmap(BarcodeFormat format, string content);
}
public class ZXing.Common.BitSource : object {
    private Byte[] bytes;
    private int byteOffset;
    private int bitOffset;
    public int BitOffset { get; }
    public int ByteOffset { get; }
    public BitSource(Byte[] bytes);
    public int get_BitOffset();
    public int get_ByteOffset();
    public int readBits(int numBits);
    public int available();
}
public class ZXing.Common.CharacterSetECI : ECI {
    internal static IDictionary`2<int, CharacterSetECI> VALUE_TO_ECI;
    internal static IDictionary`2<string, CharacterSetECI> NAME_TO_ECI;
    private string encodingName;
    public string EncodingName { get; }
    private static CharacterSetECI();
    private CharacterSetECI(int value, string encodingName);
    public string get_EncodingName();
    private static void addCharacterSet(int value, string encodingName);
    private static void addCharacterSet(int value, String[] encodingNames);
    public static CharacterSetECI getCharacterSetECIByValue(int value);
    public static CharacterSetECI getCharacterSetECIByName(string name);
    public static CharacterSetECI getCharacterSetECI(Encoding encoding);
    public static Encoding getEncoding(CharacterSetECI charsetECI);
    public static Encoding getEncoding(string encodingName);
}
public class ZXing.Common.DecoderResult : object {
    [CompilerGeneratedAttribute]
private Byte[] <RawBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumBits>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<Byte[]> <ByteSegments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ECLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ErrorsCorrected>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StructuredAppendSequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Erasures>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StructuredAppendParity>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Other>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SymbologyModifier>k__BackingField;
    public Byte[] RawBytes { get; private set; }
    public int NumBits { get; private set; }
    public string Text { get; private set; }
    public IList`1<Byte[]> ByteSegments { get; private set; }
    public string ECLevel { get; private set; }
    public bool StructuredAppend { get; }
    public int ErrorsCorrected { get; public set; }
    public int StructuredAppendSequenceNumber { get; private set; }
    public int Erasures { get; public set; }
    public int StructuredAppendParity { get; private set; }
    public object Other { get; public set; }
    public int SymbologyModifier { get; public set; }
    public DecoderResult(Byte[] rawBytes, string text, List`1<Byte[]> byteSegments, string ecLevel);
    public DecoderResult(Byte[] rawBytes, string text, IList`1<Byte[]> byteSegments, string ecLevel, int symbologyModifier);
    public DecoderResult(Byte[] rawBytes, string text, List`1<Byte[]> byteSegments, string ecLevel, int saSequence, int saParity);
    public DecoderResult(Byte[] rawBytes, string text, IList`1<Byte[]> byteSegments, string ecLevel, int saSequence, int saParity, int symbologyModifier);
    public DecoderResult(Byte[] rawBytes, int numBits, string text, IList`1<Byte[]> byteSegments, string ecLevel);
    public DecoderResult(Byte[] rawBytes, int numBits, string text, IList`1<Byte[]> byteSegments, string ecLevel, int saSequence, int saParity, int symbologyModifier);
    [CompilerGeneratedAttribute]
public Byte[] get_RawBytes();
    [CompilerGeneratedAttribute]
private void set_RawBytes(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_NumBits();
    [CompilerGeneratedAttribute]
private void set_NumBits(int value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
    [CompilerGeneratedAttribute]
public IList`1<Byte[]> get_ByteSegments();
    [CompilerGeneratedAttribute]
private void set_ByteSegments(IList`1<Byte[]> value);
    [CompilerGeneratedAttribute]
public string get_ECLevel();
    [CompilerGeneratedAttribute]
private void set_ECLevel(string value);
    public bool get_StructuredAppend();
    [CompilerGeneratedAttribute]
public int get_ErrorsCorrected();
    [CompilerGeneratedAttribute]
public void set_ErrorsCorrected(int value);
    [CompilerGeneratedAttribute]
public int get_StructuredAppendSequenceNumber();
    [CompilerGeneratedAttribute]
private void set_StructuredAppendSequenceNumber(int value);
    [CompilerGeneratedAttribute]
public int get_Erasures();
    [CompilerGeneratedAttribute]
public void set_Erasures(int value);
    [CompilerGeneratedAttribute]
public int get_StructuredAppendParity();
    [CompilerGeneratedAttribute]
private void set_StructuredAppendParity(int value);
    [CompilerGeneratedAttribute]
public object get_Other();
    [CompilerGeneratedAttribute]
public void set_Other(object value);
    [CompilerGeneratedAttribute]
public int get_SymbologyModifier();
    [CompilerGeneratedAttribute]
public void set_SymbologyModifier(int value);
}
[SerializableAttribute]
public class ZXing.Common.DecodingOptions : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<DecodeHintType, object> <Hints>k__BackingField;
    [CompilerGeneratedAttribute]
[NonSerializedAttribute]
private Action`2<object, EventArgs> ValueChanged;
    [BrowsableAttribute("False")]
public IDictionary`2<DecodeHintType, object> Hints { get; private set; }
    public bool TryHarder { get; public set; }
    public bool TryInverted { get; public set; }
    public bool PureBarcode { get; public set; }
    public string CharacterSet { get; public set; }
    public IList`1<BarcodeFormat> PossibleFormats { get; public set; }
    public bool UseCode39ExtendedMode { get; public set; }
    public bool UseCode39RelaxedExtendedMode { get; public set; }
    public bool AssumeCode39CheckDigit { get; public set; }
    public bool ReturnCodabarStartEnd { get; public set; }
    public bool AssumeGS1 { get; public set; }
    public bool AssumeMSICheckDigit { get; public set; }
    public Int32[] AllowedLengths { get; public set; }
    public Int32[] AllowedEANExtensions { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<DecodeHintType, object> get_Hints();
    [CompilerGeneratedAttribute]
private void set_Hints(IDictionary`2<DecodeHintType, object> value);
    [CompilerGeneratedAttribute]
public void add_ValueChanged(Action`2<object, EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ValueChanged(Action`2<object, EventArgs> value);
    public bool get_TryHarder();
    public void set_TryHarder(bool value);
    public bool get_TryInverted();
    public void set_TryInverted(bool value);
    public bool get_PureBarcode();
    public void set_PureBarcode(bool value);
    public string get_CharacterSet();
    public void set_CharacterSet(string value);
    public IList`1<BarcodeFormat> get_PossibleFormats();
    public void set_PossibleFormats(IList`1<BarcodeFormat> value);
    public bool get_UseCode39ExtendedMode();
    public void set_UseCode39ExtendedMode(bool value);
    public bool get_UseCode39RelaxedExtendedMode();
    public void set_UseCode39RelaxedExtendedMode(bool value);
    public bool get_AssumeCode39CheckDigit();
    public void set_AssumeCode39CheckDigit(bool value);
    public bool get_ReturnCodabarStartEnd();
    public void set_ReturnCodabarStartEnd(bool value);
    public bool get_AssumeGS1();
    public void set_AssumeGS1(bool value);
    public bool get_AssumeMSICheckDigit();
    public void set_AssumeMSICheckDigit(bool value);
    public Int32[] get_AllowedLengths();
    public void set_AllowedLengths(Int32[] value);
    public Int32[] get_AllowedEANExtensions();
    public void set_AllowedEANExtensions(Int32[] value);
    [CompilerGeneratedAttribute]
private void <.ctor>b__46_0(object o, EventArgs args);
}
public class ZXing.Common.DefaultGridSampler : GridSampler {
    public virtual BitMatrix sampleGrid(BitMatrix image, int dimensionX, int dimensionY, float p1ToX, float p1ToY, float p2ToX, float p2ToY, float p3ToX, float p3ToY, float p4ToX, float p4ToY, float p1FromX, float p1FromY, float p2FromX, float p2FromY, float p3FromX, float p3FromY, float p4FromX, float p4FromY);
    public virtual BitMatrix sampleGrid(BitMatrix image, int dimensionX, int dimensionY, PerspectiveTransform transform);
}
public static class ZXing.Common.Detector.MathUtils : object {
    public static int round(float d);
    public static float distance(float aX, float aY, float bX, float bY);
    public static float distance(int aX, int aY, int bX, int bY);
    public static int sum(Int32[] array);
}
[ObsoleteAttribute]
public class ZXing.Common.Detector.MonochromeRectangleDetector : object {
    private static int MAX_MODULES;
    private BitMatrix image;
    public MonochromeRectangleDetector(BitMatrix image);
    public ResultPoint[] detect();
    private ResultPoint findCornerFromCenter(int centerX, int deltaX, int left, int right, int centerY, int deltaY, int top, int bottom, int maxWhiteRun);
    private Int32[] blackWhiteRange(int fixedDimension, int maxWhiteRun, int minDim, int maxDim, bool horizontal);
}
public class ZXing.Common.Detector.WhiteRectangleDetector : object {
    private static int INIT_SIZE;
    private static int CORR;
    private BitMatrix image;
    private int height;
    private int width;
    private int leftInit;
    private int rightInit;
    private int downInit;
    private int upInit;
    internal WhiteRectangleDetector(BitMatrix image);
    internal WhiteRectangleDetector(BitMatrix image, int initSize, int x, int y);
    public static WhiteRectangleDetector Create(BitMatrix image);
    public static WhiteRectangleDetector Create(BitMatrix image, int initSize, int x, int y);
    public ResultPoint[] detect();
    private ResultPoint getBlackPointOnSegment(float aX, float aY, float bX, float bY);
    private ResultPoint[] centerEdges(ResultPoint y, ResultPoint z, ResultPoint x, ResultPoint t);
    private bool containsBlackPoint(int a, int b, int fixed, bool horizontal);
}
public class ZXing.Common.DetectorResult : object {
    [CompilerGeneratedAttribute]
private BitMatrix <Bits>k__BackingField;
    [CompilerGeneratedAttribute]
private ResultPoint[] <Points>k__BackingField;
    public BitMatrix Bits { get; private set; }
    public ResultPoint[] Points { get; private set; }
    public DetectorResult(BitMatrix bits, ResultPoint[] points);
    [CompilerGeneratedAttribute]
public BitMatrix get_Bits();
    [CompilerGeneratedAttribute]
private void set_Bits(BitMatrix value);
    [CompilerGeneratedAttribute]
public ResultPoint[] get_Points();
    [CompilerGeneratedAttribute]
private void set_Points(ResultPoint[] value);
}
public abstract class ZXing.Common.ECI : object {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    public int Value { get; private set; }
    internal ECI(int val);
    [CompilerGeneratedAttribute]
public virtual int get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(int value);
    public static ECI getECIByValue(int val);
}
public class ZXing.Common.ECIEncoderSet : object {
    private static List`1<Encoding> ENCODERS;
    private Encoding[] encoders;
    private int priorityEncoderIndex;
    public int Length { get; }
    private static ECIEncoderSet();
    public ECIEncoderSet(string stringToEncode, Encoding priorityCharset, int fnc1);
    public static bool canEncode(Encoding encoding, char c);
    public int get_Length();
    public string getCharsetName(int index);
    public Encoding getCharset(int index);
    public int getECIValue(int encoderIndex);
    public int getPriorityEncoderIndex();
    public bool canEncode(char c, int encoderIndex);
    public Byte[] encode(char c, int encoderIndex);
    public Byte[] encode(string s, int encoderIndex);
    public static Encoding Clone(Encoding encoding);
}
public interface ZXing.Common.ECIInput {
    public int Length { get; }
    public abstract virtual int get_Length();
    public abstract virtual char charAt(int index);
    public abstract virtual string subSequence(int start, int end);
    public abstract virtual bool isECI(int index);
    public abstract virtual int getECIValue(int index);
    public abstract virtual bool haveNCharacters(int index, int n);
}
public class ZXing.Common.ECIStringBuilder : object {
    private StringBuilder currentBytes;
    private StringBuilder result;
    private Encoding currentCharset;
    private Encoding standardEncoding;
    public int Length { get; }
    public bool isEmpty { get; }
    public ECIStringBuilder(Encoding standardEncoding);
    public ECIStringBuilder(int initialCapacity);
    public ECIStringBuilder(int initialCapacity, Encoding standardEncoding, Encoding startWithEncoding);
    public void Append(char value);
    public void Append(byte value);
    public void Append(string value);
    public void Append(int value);
    public bool AppendECI(int value);
    private void encodeCurrentBytesIfAny();
    public void AppendCharacters(StringBuilder value);
    public int get_Length();
    public bool get_isEmpty();
    public virtual string ToString();
}
[SerializableAttribute]
public class ZXing.Common.EncodingOptions : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<EncodeHintType, object> <Hints>k__BackingField;
    [BrowsableAttribute("False")]
public IDictionary`2<EncodeHintType, object> Hints { get; private set; }
    public int Height { get; public set; }
    public int Width { get; public set; }
    public bool PureBarcode { get; public set; }
    public int Margin { get; public set; }
    public bool GS1Format { get; public set; }
    public bool NoPadding { get; public set; }
    [CompilerGeneratedAttribute]
public IDictionary`2<EncodeHintType, object> get_Hints();
    [CompilerGeneratedAttribute]
private void set_Hints(IDictionary`2<EncodeHintType, object> value);
    public int get_Height();
    public void set_Height(int value);
    public int get_Width();
    public void set_Width(int value);
    public bool get_PureBarcode();
    public void set_PureBarcode(bool value);
    public int get_Margin();
    public void set_Margin(int value);
    public bool get_GS1Format();
    public void set_GS1Format(bool value);
    public bool get_NoPadding();
    public void set_NoPadding(bool value);
}
public class ZXing.Common.GlobalHistogramBinarizer : Binarizer {
    private static int LUMINANCE_BITS;
    private static int LUMINANCE_SHIFT;
    private static int LUMINANCE_BUCKETS;
    private static Byte[] EMPTY;
    private Byte[] luminances;
    private Int32[] buckets;
    public BitMatrix BlackMatrix { get; }
    public GlobalHistogramBinarizer(LuminanceSource source);
    private static GlobalHistogramBinarizer();
    public virtual BitArray getBlackRow(int y, BitArray row);
    public virtual BitMatrix get_BlackMatrix();
    public virtual Binarizer createBinarizer(LuminanceSource source);
    private void initArrays(int luminanceSize);
    private static bool estimateBlackPoint(Int32[] buckets, Int32& blackPoint);
}
public abstract class ZXing.Common.GridSampler : object {
    private static GridSampler gridSampler;
    public static GridSampler Instance { get; }
    private static GridSampler();
    public static GridSampler get_Instance();
    public static void setGridSampler(GridSampler newGridSampler);
    public abstract virtual BitMatrix sampleGrid(BitMatrix image, int dimensionX, int dimensionY, float p1ToX, float p1ToY, float p2ToX, float p2ToY, float p3ToX, float p3ToY, float p4ToX, float p4ToY, float p1FromX, float p1FromY, float p2FromX, float p2FromY, float p3FromX, float p3FromY, float p4FromX, float p4FromY);
    public virtual BitMatrix sampleGrid(BitMatrix image, int dimensionX, int dimensionY, PerspectiveTransform transform);
    protected internal static bool checkAndNudgePoints(BitMatrix image, Single[] points);
}
public class ZXing.Common.HybridBinarizer : GlobalHistogramBinarizer {
    private static int BLOCK_SIZE_POWER;
    private static int BLOCK_SIZE;
    private static int BLOCK_SIZE_MASK;
    private static int MINIMUM_DIMENSION;
    private static int MIN_DYNAMIC_RANGE;
    private BitMatrix matrix;
    public BitMatrix BlackMatrix { get; }
    public HybridBinarizer(LuminanceSource source);
    public virtual BitMatrix get_BlackMatrix();
    public virtual Binarizer createBinarizer(LuminanceSource source);
    private void binarizeEntireImage();
    private static void calculateThresholdForBlock(Byte[] luminances, int subWidth, int subHeight, int width, int height, Int32[][] blackPoints, BitMatrix matrix);
    private static int cap(int value, int max);
    private static void thresholdBlock(Byte[] luminances, int xoffset, int yoffset, int threshold, int stride, BitMatrix matrix);
    private static Int32[][] calculateBlackPoints(Byte[] luminances, int subWidth, int subHeight, int width, int height);
}
public class ZXing.Common.MinimalECIInput : object {
    private static int COST_PER_ECI;
    private Int32[] bytes;
    private int fnc1;
    public int Length { get; }
    public MinimalECIInput(string stringToEncode, Encoding priorityCharset, int fnc1);
    private static MinimalECIInput();
    public int getFNC1Character();
    public sealed virtual int get_Length();
    public sealed virtual bool haveNCharacters(int index, int n);
    public sealed virtual char charAt(int index);
    public sealed virtual string subSequence(int start, int end);
    public sealed virtual bool isECI(int index);
    public bool isFNC1(int index);
    public sealed virtual int getECIValue(int index);
    public virtual string ToString();
    private static void addEdge(InputEdge[][] edges, int to, InputEdge edge);
    private static void addEdges(string stringToEncode, ECIEncoderSet encoderSet, InputEdge[][] edges, int from, InputEdge previous, int fnc1);
    private static Int32[] encodeMinimally(string stringToEncode, ECIEncoderSet encoderSet, int fnc1);
}
public class ZXing.Common.PerspectiveTransform : object {
    private float a11;
    private float a12;
    private float a13;
    private float a21;
    private float a22;
    private float a23;
    private float a31;
    private float a32;
    private float a33;
    private PerspectiveTransform(float a11, float a21, float a31, float a12, float a22, float a32, float a13, float a23, float a33);
    public static PerspectiveTransform quadrilateralToQuadrilateral(float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3, float x0p, float y0p, float x1p, float y1p, float x2p, float y2p, float x3p, float y3p);
    public void transformPoints(Single[] points);
    public void transformPoints(Single[] xValues, Single[] yValues);
    public static PerspectiveTransform squareToQuadrilateral(float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3);
    public static PerspectiveTransform quadrilateralToSquare(float x0, float y0, float x1, float y1, float x2, float y2, float x3, float y3);
    internal PerspectiveTransform buildAdjoint();
    internal PerspectiveTransform times(PerspectiveTransform other);
}
public class ZXing.Common.ReedSolomon.GenericGF : object {
    public static GenericGF AZTEC_DATA_12;
    public static GenericGF AZTEC_DATA_10;
    public static GenericGF AZTEC_DATA_6;
    public static GenericGF AZTEC_PARAM;
    public static GenericGF QR_CODE_FIELD_256;
    public static GenericGF DATA_MATRIX_FIELD_256;
    public static GenericGF AZTEC_DATA_8;
    public static GenericGF MAXICODE_FIELD_64;
    private Int32[] expTable;
    private Int32[] logTable;
    private GenericGFPoly zero;
    private GenericGFPoly one;
    private int size;
    private int primitive;
    private int generatorBase;
    internal GenericGFPoly Zero { get; }
    internal GenericGFPoly One { get; }
    public int Size { get; }
    public int GeneratorBase { get; }
    public GenericGF(int primitive, int size, int genBase);
    private static GenericGF();
    internal GenericGFPoly get_Zero();
    internal GenericGFPoly get_One();
    internal GenericGFPoly buildMonomial(int degree, int coefficient);
    internal static int addOrSubtract(int a, int b);
    internal int exp(int a);
    internal int log(int a);
    internal int inverse(int a);
    internal int multiply(int a, int b);
    public int get_Size();
    public int get_GeneratorBase();
    public virtual string ToString();
}
internal class ZXing.Common.ReedSolomon.GenericGFPoly : object {
    private GenericGF field;
    private Int32[] coefficients;
    internal Int32[] Coefficients { get; }
    internal int Degree { get; }
    internal bool isZero { get; }
    internal GenericGFPoly(GenericGF field, Int32[] coefficients);
    internal Int32[] get_Coefficients();
    internal int get_Degree();
    internal bool get_isZero();
    internal int getCoefficient(int degree);
    internal int evaluateAt(int a);
    internal GenericGFPoly addOrSubtract(GenericGFPoly other);
    internal GenericGFPoly multiply(GenericGFPoly other);
    internal GenericGFPoly multiply(int scalar);
    internal GenericGFPoly multiplyByMonomial(int degree, int coefficient);
    internal GenericGFPoly[] divide(GenericGFPoly other);
    public virtual string ToString();
}
public class ZXing.Common.ReedSolomon.ReedSolomonDecoder : object {
    private GenericGF field;
    public ReedSolomonDecoder(GenericGF field);
    public bool decode(Int32[] received, int twoS);
    internal GenericGFPoly[] runEuclideanAlgorithm(GenericGFPoly a, GenericGFPoly b, int R);
    private Int32[] findErrorLocations(GenericGFPoly errorLocator);
    private Int32[] findErrorMagnitudes(GenericGFPoly errorEvaluator, Int32[] errorLocations);
}
public class ZXing.Common.ReedSolomon.ReedSolomonEncoder : object {
    private GenericGF field;
    private IList`1<GenericGFPoly> cachedGenerators;
    public ReedSolomonEncoder(GenericGF field);
    private GenericGFPoly buildGenerator(int degree);
    public void encode(Int32[] toEncode, int ecBytes);
}
public static class ZXing.Common.StringUtils : object {
    public static string PLATFORM_DEFAULT_ENCODING;
    public static Encoding PLATFORM_DEFAULT_ENCODING_T;
    public static Encoding SHIFT_JIS_ENCODING;
    public static Encoding GB2312_ENCODING;
    public static Encoding EUC_JP_ENCODING;
    public static Encoding ISO88591_ENCODING;
    private static bool ASSUME_SHIFT_JIS;
    public static string SHIFT_JIS;
    public static string GB2312;
    public static string EUC_JP;
    public static string UTF8;
    public static string ISO88591;
    private static StringUtils();
    public static string guessEncoding(Byte[] bytes, IDictionary`2<DecodeHintType, object> hints);
    public static Encoding guessCharset(Byte[] bytes, IDictionary`2<DecodeHintType, object> hints);
}
[SerializableAttribute]
public class ZXing.Datamatrix.DatamatrixEncodingOptions : EncodingOptions {
    public Nullable`1<SymbolShapeHint> SymbolShape { get; public set; }
    public Dimension MinSize { get; public set; }
    public Dimension MaxSize { get; public set; }
    public Nullable`1<int> DefaultEncodation { get; public set; }
    public bool CompactEncoding { get; public set; }
    public bool ForceC40 { get; public set; }
    public string CharacterSet { get; public set; }
    public Nullable`1<SymbolShapeHint> get_SymbolShape();
    public void set_SymbolShape(Nullable`1<SymbolShapeHint> value);
    public Dimension get_MinSize();
    public void set_MinSize(Dimension value);
    public Dimension get_MaxSize();
    public void set_MaxSize(Dimension value);
    public Nullable`1<int> get_DefaultEncodation();
    public void set_DefaultEncodation(Nullable`1<int> value);
    public bool get_CompactEncoding();
    public void set_CompactEncoding(bool value);
    public bool get_ForceC40();
    public void set_ForceC40(bool value);
    public string get_CharacterSet();
    public void set_CharacterSet(string value);
}
public class ZXing.Datamatrix.DataMatrixReader : object {
    private static ResultPoint[] NO_POINTS;
    private Decoder decoder;
    private static DataMatrixReader();
    public sealed virtual Result decode(BinaryBitmap image);
    public sealed virtual Result decode(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
    public sealed virtual void reset();
    private static BitMatrix extractPureBits(BitMatrix image);
    private static bool moduleSize(Int32[] leftTopBlack, BitMatrix image, Int32& modulesize);
}
public class ZXing.Datamatrix.DataMatrixWriter : object {
    public sealed virtual BitMatrix encode(string contents, BarcodeFormat format, int width, int height);
    public sealed virtual BitMatrix encode(string contents, BarcodeFormat format, int width, int height, IDictionary`2<EncodeHintType, object> hints);
    private static BitMatrix encodeLowLevel(DefaultPlacement placement, SymbolInfo symbolInfo, int width, int height, int margin, bool noPadding);
    private static BitMatrix convertByteMatrixToBitMatrix(ByteMatrix matrix, int reqWidth, int reqHeight, int margin, bool noPadding);
}
internal class ZXing.Datamatrix.Encoder.ASCIIEncoder : object {
    public int EncodingMode { get; }
    public sealed virtual int get_EncodingMode();
    public sealed virtual void encode(EncoderContext context);
    private static char encodeASCIIDigits(char digit1, char digit2);
}
internal class ZXing.Datamatrix.Encoder.Base256Encoder : object {
    public int EncodingMode { get; }
    public sealed virtual int get_EncodingMode();
    public sealed virtual void encode(EncoderContext context);
    private static char randomize255State(char ch, int codewordPosition);
}
internal class ZXing.Datamatrix.Encoder.C40Encoder : object {
    public int EncodingMode { get; }
    public virtual int get_EncodingMode();
    public void encodeMaximal(EncoderContext context);
    public virtual void encode(EncoderContext context);
    private int backtrackOneCharacter(EncoderContext context, StringBuilder buffer, StringBuilder removed, int lastCharSize);
    internal static void writeNextTriplet(EncoderContext context, StringBuilder buffer);
    protected virtual void handleEOD(EncoderContext context, StringBuilder buffer);
    protected virtual int encodeChar(char c, StringBuilder sb);
    private static string encodeToCodewords(StringBuilder sb);
}
internal class ZXing.Datamatrix.Encoder.DataMatrixSymbolInfo144 : SymbolInfo {
    public virtual int getInterleavedBlockCount();
    public virtual int getDataLengthForInterleavedBlock(int index);
}
public class ZXing.Datamatrix.Encoder.DefaultPlacement : object {
    private string codewords;
    private int numrows;
    private int numcols;
    private Byte[] bits;
    public int Numrows { get; }
    public int Numcols { get; }
    public Byte[] Bits { get; }
    public DefaultPlacement(string codewords, int numcols, int numrows);
    public int get_Numrows();
    public int get_Numcols();
    public Byte[] get_Bits();
    public bool getBit(int col, int row);
    private void setBit(int col, int row, bool bit);
    private bool noBit(int col, int row);
    public void place();
    private void module(int row, int col, int pos, int bit);
    private void utah(int row, int col, int pos);
    private void corner1(int pos);
    private void corner2(int pos);
    private void corner3(int pos);
    private void corner4(int pos);
}
internal class ZXing.Datamatrix.Encoder.EdifactEncoder : object {
    public int EncodingMode { get; }
    public sealed virtual int get_EncodingMode();
    public sealed virtual void encode(EncoderContext context);
    private static void handleEOD(EncoderContext context, StringBuilder buffer);
    private static void encodeChar(char c, StringBuilder sb);
    private static string encodeToCodewords(StringBuilder sb);
}
public class ZXing.Datamatrix.Encoder.Encodation : object {
    public static int ASCII;
    public static int C40;
    public static int TEXT;
    public static int X12;
    public static int EDIFACT;
    public static int BASE256;
}
internal interface ZXing.Datamatrix.Encoder.Encoder {
    public int EncodingMode { get; }
    public abstract virtual int get_EncodingMode();
    public abstract virtual void encode(EncoderContext context);
}
internal class ZXing.Datamatrix.Encoder.EncoderContext : object {
    private string msg;
    private SymbolShapeHint shape;
    private Dimension minSize;
    private Dimension maxSize;
    private StringBuilder codewords;
    private int pos;
    private int newEncoding;
    private SymbolInfo symbolInfo;
    private int skipAtEnd;
    private static Encoding encoding;
    [CompilerGeneratedAttribute]
private bool <Fnc1CodewordIsWritten>k__BackingField;
    public char CurrentChar { get; }
    public char Current { get; }
    public int CodewordCount { get; }
    public bool HasMoreCharacters { get; }
    private int TotalMessageCharCount { get; }
    public int RemainingCharacters { get; }
    public int Pos { get; public set; }
    public StringBuilder Codewords { get; }
    public SymbolInfo SymbolInfo { get; }
    public int NewEncoding { get; }
    public string Message { get; }
    public bool Fnc1CodewordIsWritten { get; public set; }
    private static EncoderContext();
    public EncoderContext(string msg, Encoding customEncoding, bool disableEci);
    public void setSymbolShape(SymbolShapeHint shape);
    public void setSizeConstraints(Dimension minSize, Dimension maxSize);
    public void setSkipAtEnd(int count);
    public char get_CurrentChar();
    public char get_Current();
    public void writeCodewords(string codewords);
    public void writeCodeword(char codeword);
    public int get_CodewordCount();
    public void signalEncoderChange(int encoding);
    public void resetEncoderSignal();
    public bool get_HasMoreCharacters();
    private int get_TotalMessageCharCount();
    public int get_RemainingCharacters();
    public void updateSymbolInfo();
    public void updateSymbolInfo(int len);
    public void resetSymbolInfo();
    public int get_Pos();
    public void set_Pos(int value);
    public StringBuilder get_Codewords();
    public SymbolInfo get_SymbolInfo();
    public int get_NewEncoding();
    public string get_Message();
    [CompilerGeneratedAttribute]
public bool get_Fnc1CodewordIsWritten();
    [CompilerGeneratedAttribute]
public void set_Fnc1CodewordIsWritten(bool value);
}
public static class ZXing.Datamatrix.Encoder.ErrorCorrection : object {
    private static Int32[] FACTOR_SETS;
    private static Int32[][] FACTORS;
    private static int MODULO_VALUE;
    private static Int32[] LOG;
    private static Int32[] ALOG;
    private static ErrorCorrection();
    public static string encodeECC200(string codewords, SymbolInfo symbolInfo);
    private static string createECCBlock(string codewords, int numECWords);
}
internal static class ZXing.Datamatrix.Encoder.HighLevelEncoder : object {
    public static char PAD;
    public static char LATCH_TO_C40;
    public static char LATCH_TO_BASE256;
    public static char FNC1;
    public static char STRUCTURED_APPEND;
    public static char READER_PROGRAMMING;
    public static char UPPER_SHIFT;
    public static char MACRO_05;
    public static char MACRO_06;
    public static char LATCH_TO_ANSIX12;
    public static char LATCH_TO_TEXT;
    public static char LATCH_TO_EDIFACT;
    public static char ECI;
    public static char C40_UNLATCH;
    public static char X12_UNLATCH;
    public static string MACRO_05_HEADER;
    public static string MACRO_06_HEADER;
    public static string MACRO_TRAILER;
    private static char randomize253State(int codewordPosition);
    public static string encodeHighLevel(string msg);
    public static string encodeHighLevel(string msg, SymbolShapeHint shape, Dimension minSize, Dimension maxSize, int defaultEncodation);
    public static string encodeHighLevel(string msg, SymbolShapeHint shape, Dimension minSize, Dimension maxSize, int defaultEncodation, bool forceC40, Encoding encoding, bool disableEci);
    internal static int lookAheadTest(string msg, int startpos, int currentMode);
    internal static int lookAheadTestIntern(string msg, int startpos, int currentMode);
    private static int min(int f1, int f2, int f3, int f4, int f5);
    private static int min(int f1, int f2, int f3, int f4);
    private static int findMinimums(Single[] charCounts, Int32[] intCharCounts, int min, Byte[] mins);
    private static int getMinimumCount(Byte[] mins);
    internal static bool isDigit(char ch);
    internal static bool isExtendedASCII(char ch);
    internal static bool isNativeC40(char ch);
    internal static bool isNativeText(char ch);
    internal static bool isNativeX12(char ch);
    internal static bool isX12TermSep(char ch);
    internal static bool isNativeEDIFACT(char ch);
    internal static bool isSpecialB256(char ch);
    public static int determineConsecutiveDigitCount(string msg, int startpos);
    internal static void illegalCharacter(char c);
}
internal static class ZXing.Datamatrix.Encoder.MinimalEncoder : object {
    private static Char[] C40_SHIFT2_CHARS;
    private static MinimalEncoder();
    private static bool isExtendedASCII(char ch, int fnc1);
    private static bool isInC40Shift1Set(char ch);
    private static bool isInC40Shift2Set(char ch, int fnc1);
    private static bool isInTextShift1Set(char ch);
    private static bool isInTextShift2Set(char ch, int fnc1);
    public static string encodeHighLevel(string msg);
    public static string encodeHighLevel(string msg, Encoding priorityCharset, int fnc1, SymbolShapeHint shape);
    private static Byte[] encode(string input, Encoding priorityCharset, int fnc1, SymbolShapeHint shape, int macroId);
    private static void addEdge(Edge[][] edges, Edge edge);
    private static int getNumberOfC40Words(Input input, int from, bool c40, Int32[] characterLength);
    private static void addEdges(Input input, Edge[][] edges, int from, Edge previous);
    private static Result encodeMinimally(Input input);
}
public class ZXing.Datamatrix.Encoder.SymbolInfo : object {
    internal static SymbolInfo[] PROD_SYMBOLS;
    private static SymbolInfo[] symbols;
    private bool rectangular;
    internal int dataCapacity;
    internal int errorCodewords;
    public int matrixWidth;
    public int matrixHeight;
    private int dataRegions;
    private int rsBlockData;
    private int rsBlockError;
    public SymbolInfo(bool rectangular, int dataCapacity, int errorCodewords, int matrixWidth, int matrixHeight, int dataRegions);
    internal SymbolInfo(bool rectangular, int dataCapacity, int errorCodewords, int matrixWidth, int matrixHeight, int dataRegions, int rsBlockData, int rsBlockError);
    private static SymbolInfo();
    public static void overrideSymbolSet(SymbolInfo[] override);
    public static SymbolInfo lookup(int dataCodewords);
    public static SymbolInfo lookup(int dataCodewords, SymbolShapeHint shape);
    public static SymbolInfo lookup(int dataCodewords, bool allowRectangular, bool fail);
    private static SymbolInfo lookup(int dataCodewords, SymbolShapeHint shape, bool fail);
    public static SymbolInfo lookup(int dataCodewords, SymbolShapeHint shape, Dimension minSize, Dimension maxSize, bool fail);
    private int getHorizontalDataRegions();
    private int getVerticalDataRegions();
    public int getSymbolDataWidth();
    public int getSymbolDataHeight();
    public int getSymbolWidth();
    public int getSymbolHeight();
    public int getCodewordCount();
    public virtual int getInterleavedBlockCount();
    public virtual int getDataLengthForInterleavedBlock(int index);
    public int getErrorLengthForInterleavedBlock(int index);
    public virtual string ToString();
}
public enum ZXing.Datamatrix.Encoder.SymbolShapeHint : Enum {
    public int value__;
    public static SymbolShapeHint FORCE_NONE;
    public static SymbolShapeHint FORCE_SQUARE;
    public static SymbolShapeHint FORCE_RECTANGLE;
}
internal class ZXing.Datamatrix.Encoder.TextEncoder : C40Encoder {
    public int EncodingMode { get; }
    public virtual int get_EncodingMode();
    protected virtual int encodeChar(char c, StringBuilder sb);
}
internal class ZXing.Datamatrix.Encoder.X12Encoder : C40Encoder {
    public int EncodingMode { get; }
    public virtual int get_EncodingMode();
    public virtual void encode(EncoderContext context);
    protected virtual int encodeChar(char c, StringBuilder sb);
    protected virtual void handleEOD(EncoderContext context, StringBuilder buffer);
}
internal class ZXing.Datamatrix.Internal.BitMatrixParser : object {
    private BitMatrix mappingBitMatrix;
    private BitMatrix readMappingMatrix;
    private Version version;
    public Version Version { get; }
    internal BitMatrixParser(BitMatrix bitMatrix);
    public Version get_Version();
    internal static Version readVersion(BitMatrix bitMatrix);
    internal Byte[] readCodewords();
    private bool readModule(int row, int column, int numRows, int numColumns);
    private int readUtah(int row, int column, int numRows, int numColumns);
    private int readCorner1(int numRows, int numColumns);
    private int readCorner2(int numRows, int numColumns);
    private int readCorner3(int numRows, int numColumns);
    private int readCorner4(int numRows, int numColumns);
    private BitMatrix extractDataRegion(BitMatrix bitMatrix);
}
internal class ZXing.Datamatrix.Internal.DataBlock : object {
    private int numDataCodewords;
    private Byte[] codewords;
    internal int NumDataCodewords { get; }
    internal Byte[] Codewords { get; }
    private DataBlock(int numDataCodewords, Byte[] codewords);
    internal static DataBlock[] getDataBlocks(Byte[] rawCodewords, Version version);
    internal int get_NumDataCodewords();
    internal Byte[] get_Codewords();
}
internal static class ZXing.Datamatrix.Internal.DecodedBitStreamParser : object {
    private static Char[] C40_BASIC_SET_CHARS;
    private static Char[] C40_SHIFT2_SET_CHARS;
    private static Char[] TEXT_BASIC_SET_CHARS;
    private static Char[] TEXT_SHIFT2_SET_CHARS;
    private static Char[] TEXT_SHIFT3_SET_CHARS;
    private static DecodedBitStreamParser();
    internal static DecoderResult decode(Byte[] bytes);
    private static bool decodeAsciiSegment(BitSource bits, ECIStringBuilder result, StringBuilder resultTrailer, List`1<int> fnc1positions, Mode& mode);
    private static bool decodeC40Segment(BitSource bits, ECIStringBuilder result, List`1<int> fnc1positions);
    private static bool decodeTextSegment(BitSource bits, ECIStringBuilder result, List`1<int> fnc1positions);
    private static bool decodeAnsiX12Segment(BitSource bits, ECIStringBuilder result);
    private static void parseTwoBytes(int firstByte, int secondByte, Int32[] result);
    private static bool decodeEdifactSegment(BitSource bits, ECIStringBuilder result);
    private static bool decodeBase256Segment(BitSource bits, ECIStringBuilder result, IList`1<Byte[]> byteSegments);
    private static bool decodeECISegment(BitSource bits, ECIStringBuilder result);
    private static int unrandomize255State(int randomizedBase256Codeword, int base256CodewordPosition);
}
public class ZXing.Datamatrix.Internal.Decoder : object {
    private ReedSolomonDecoder rsDecoder;
    public DecoderResult decode(Boolean[][] image);
    public DecoderResult decode(BitMatrix bits);
    private bool correctErrors(Byte[] codewordBytes, int numDataCodewords);
}
public class ZXing.Datamatrix.Internal.Detector : object {
    private BitMatrix image;
    private WhiteRectangleDetector rectangleDetector;
    public Detector(BitMatrix image);
    public DetectorResult detect();
    private static ResultPoint shiftPoint(ResultPoint point, ResultPoint to, int div);
    private static ResultPoint moveAway(ResultPoint point, float fromX, float fromY);
    private ResultPoint[] detectSolid1(ResultPoint[] cornerPoints);
    private ResultPoint[] detectSolid2(ResultPoint[] points);
    private ResultPoint correctTopRight(ResultPoint[] points);
    private ResultPoint[] shiftToModuleCenter(ResultPoint[] points);
    private bool isValid(ResultPoint p);
    private static BitMatrix sampleGrid(BitMatrix image, ResultPoint topLeft, ResultPoint bottomLeft, ResultPoint bottomRight, ResultPoint topRight, int dimensionX, int dimensionY);
    private int transitionsBetween(ResultPoint from, ResultPoint to);
}
public class ZXing.Datamatrix.Internal.Version : object {
    private static Version[] VERSIONS;
    private int versionNumber;
    private int symbolSizeRows;
    private int symbolSizeColumns;
    private int dataRegionSizeRows;
    private int dataRegionSizeColumns;
    private ECBlocks ecBlocks;
    private int totalCodewords;
    internal Version(int versionNumber, int symbolSizeRows, int symbolSizeColumns, int dataRegionSizeRows, int dataRegionSizeColumns, ECBlocks ecBlocks);
    private static Version();
    public int getVersionNumber();
    public int getSymbolSizeRows();
    public int getSymbolSizeColumns();
    public int getDataRegionSizeRows();
    public int getDataRegionSizeColumns();
    public int getTotalCodewords();
    internal ECBlocks getECBlocks();
    public static Version getVersionForDimensions(int numRows, int numColumns);
    public virtual string ToString();
    private static Version[] buildVersions();
}
public enum ZXing.DecodeHintType : Enum {
    public int value__;
    public static DecodeHintType OTHER;
    public static DecodeHintType PURE_BARCODE;
    public static DecodeHintType POSSIBLE_FORMATS;
    public static DecodeHintType TRY_HARDER;
    public static DecodeHintType CHARACTER_SET;
    public static DecodeHintType ALLOWED_LENGTHS;
    public static DecodeHintType ASSUME_CODE_39_CHECK_DIGIT;
    public static DecodeHintType NEED_RESULT_POINT_CALLBACK;
    public static DecodeHintType ASSUME_MSI_CHECK_DIGIT;
    public static DecodeHintType USE_CODE_39_EXTENDED_MODE;
    public static DecodeHintType RELAXED_CODE_39_EXTENDED_MODE;
    public static DecodeHintType TRY_HARDER_WITHOUT_ROTATION;
    public static DecodeHintType ASSUME_GS1;
    public static DecodeHintType RETURN_CODABAR_START_END;
    public static DecodeHintType ALLOWED_EAN_EXTENSIONS;
    public static DecodeHintType ALSO_INVERTED;
}
public class ZXing.Dimension : object {
    private int width;
    private int height;
    public int Width { get; }
    public int Height { get; }
    public Dimension(int width, int height);
    public int get_Width();
    public int get_Height();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public enum ZXing.EncodeHintType : Enum {
    public int value__;
    public static EncodeHintType WIDTH;
    public static EncodeHintType HEIGHT;
    public static EncodeHintType PURE_BARCODE;
    public static EncodeHintType ERROR_CORRECTION;
    public static EncodeHintType CHARACTER_SET;
    public static EncodeHintType MARGIN;
    public static EncodeHintType PDF417_ASPECT_RATIO;
    public static EncodeHintType PDF417_IMAGE_ASPECT_RATIO;
    public static EncodeHintType PDF417_COMPACT;
    public static EncodeHintType PDF417_COMPACTION;
    public static EncodeHintType PDF417_DIMENSIONS;
    public static EncodeHintType PDF417_MACRO_META_DATA;
    public static EncodeHintType DISABLE_ECI;
    public static EncodeHintType DATA_MATRIX_SHAPE;
    public static EncodeHintType MIN_SIZE;
    public static EncodeHintType MAX_SIZE;
    public static EncodeHintType CODE128_FORCE_CODESET_B;
    public static EncodeHintType DATA_MATRIX_DEFAULT_ENCODATION;
    public static EncodeHintType AZTEC_LAYERS;
    public static EncodeHintType QR_VERSION;
    public static EncodeHintType GS1_FORMAT;
    public static EncodeHintType QR_MASK_PATTERN;
    public static EncodeHintType FORCE_CODE_SET;
    public static EncodeHintType QR_COMPACT;
    public static EncodeHintType NO_PADDING;
    public static EncodeHintType DATA_MATRIX_COMPACT;
    public static EncodeHintType CODE128_COMPACT;
    public static EncodeHintType FORCE_C40;
    public static EncodeHintType PDF417_AUTO_ECI;
}
[SerializableAttribute]
public class ZXing.FormatException : ReaderException {
    public FormatException(string message);
    public FormatException(Exception innerException);
    public FormatException(string message, Exception innerException);
}
[CLSCompliantAttribute("False")]
public interface ZXing.IBarcodeReader {
    public DecodingOptions Options { get; public set; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_ResultPointFound(Action`1<ResultPoint> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ResultPointFound(Action`1<ResultPoint> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ResultFound(Action`1<Result> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ResultFound(Action`1<Result> value);
    public abstract virtual DecodingOptions get_Options();
    public abstract virtual void set_Options(DecodingOptions value);
    public abstract virtual Result Decode(Byte[] rawRGB, int width, int height, BitmapFormat format);
    public abstract virtual Result Decode(LuminanceSource luminanceSource);
    public abstract virtual Result[] DecodeMultiple(Byte[] rawRGB, int width, int height, BitmapFormat format);
    public abstract virtual Result[] DecodeMultiple(LuminanceSource luminanceSource);
    [CLSCompliantAttribute("False")]
public abstract virtual Result[] DecodeMultiple(WriteableBitmap barcodeBitmap);
    public abstract virtual Result Decode(WriteableBitmap barcodeBitmap);
}
public interface ZXing.IBarcodeReader`1 {
    public abstract virtual Result Decode(T barcodeBitmap);
    public abstract virtual Result[] DecodeMultiple(T barcodeBitmap);
}
public interface ZXing.IBarcodeReaderGeneric {
    public DecodingOptions Options { get; public set; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_ResultPointFound(Action`1<ResultPoint> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ResultPointFound(Action`1<ResultPoint> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ResultFound(Action`1<Result> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ResultFound(Action`1<Result> value);
    public abstract virtual DecodingOptions get_Options();
    public abstract virtual void set_Options(DecodingOptions value);
    public abstract virtual Result Decode(Byte[] rawRGB, int width, int height, BitmapFormat format);
    public abstract virtual Result Decode(LuminanceSource luminanceSource);
    public abstract virtual Result[] DecodeMultiple(Byte[] rawRGB, int width, int height, BitmapFormat format);
    public abstract virtual Result[] DecodeMultiple(LuminanceSource luminanceSource);
}
[CLSCompliantAttribute("False")]
public interface ZXing.IBarcodeWriter {
    public BarcodeFormat Format { get; public set; }
    public EncodingOptions Options { get; public set; }
    public Writer Encoder { get; public set; }
    public abstract virtual BarcodeFormat get_Format();
    public abstract virtual void set_Format(BarcodeFormat value);
    public abstract virtual EncodingOptions get_Options();
    public abstract virtual void set_Options(EncodingOptions value);
    public abstract virtual Writer get_Encoder();
    public abstract virtual void set_Encoder(Writer value);
    public abstract virtual BitMatrix Encode(string contents);
    public abstract virtual WriteableBitmap Write(string contents);
    public abstract virtual WriteableBitmap Write(BitMatrix matrix);
}
public interface ZXing.IBarcodeWriter`1 {
    public abstract virtual TOutput Write(string contents);
    public abstract virtual TOutput Write(BitMatrix matrix);
}
public interface ZXing.IBarcodeWriterGeneric {
    public BarcodeFormat Format { get; public set; }
    public EncodingOptions Options { get; public set; }
    public Writer Encoder { get; public set; }
    public abstract virtual BarcodeFormat get_Format();
    public abstract virtual void set_Format(BarcodeFormat value);
    public abstract virtual EncodingOptions get_Options();
    public abstract virtual void set_Options(EncodingOptions value);
    public abstract virtual Writer get_Encoder();
    public abstract virtual void set_Encoder(Writer value);
    public abstract virtual BitMatrix Encode(string contents);
}
public interface ZXing.IBarcodeWriterPixelData {
    public abstract virtual PixelData Write(string contents);
    public abstract virtual PixelData Write(BitMatrix matrix);
}
public interface ZXing.IBarcodeWriterSvg {
    public abstract virtual SvgImage Write(string contents);
    public abstract virtual SvgImage Write(BitMatrix matrix);
}
internal static class ZXing.IDictionaryExtensions : object {
    public static bool IsBooleanFlagSet(IDictionary`2<EncodeHintType, object> hints, EncodeHintType encodeHintType);
    public static bool IsBooleanFlagSet(IDictionary`2<EncodeHintType, object> hints, EncodeHintType encodeHintType, bool defaultIfNotContained);
    public static int GetIntValue(IDictionary`2<EncodeHintType, object> hints, EncodeHintType encodeHintType);
    public static int GetIntValue(IDictionary`2<EncodeHintType, object> hints, EncodeHintType encodeHintType, int defaultIfNotContained);
    public static float GetFloatValue(IDictionary`2<EncodeHintType, object> hints, EncodeHintType encodeHintType);
    public static float GetFloatValue(IDictionary`2<EncodeHintType, object> hints, EncodeHintType encodeHintType, float defaultIfNotContained);
    public static int GetEnumValue(IDictionary`2<EncodeHintType, object> hints, EncodeHintType encodeHintType, Type enumType);
    public static int GetEnumValue(IDictionary`2<EncodeHintType, object> hints, EncodeHintType encodeHintType, Type enumType, int defaultIfNotContained);
    public static TEnum GetEnumValue(IDictionary`2<EncodeHintType, object> hints, EncodeHintType encodeHintType, TEnum defaultIfNotContained);
    public static T GetValue(IDictionary`2<EncodeHintType, object> hints, EncodeHintType encodeHintType);
    public static T GetValue(IDictionary`2<EncodeHintType, object> hints, EncodeHintType encodeHintType, T defaultIfNotContained);
    public static Encoding GetEncoding(IDictionary`2<EncodeHintType, object> hints);
    public static Encoding GetEncoding(IDictionary`2<EncodeHintType, object> hints, Encoding defaultIfNotContained);
    public static Encoding GetEncoding(IDictionary`2<EncodeHintType, object> hints, EncodeHintType encodeHintType, Encoding defaultIfNotContained);
}
public class ZXing.IMB.IMBReader : OneDReader {
    private static int NUM_BARS_IMB;
    private static Int32[] barPosA;
    private static Int32[] barPosB;
    private static Int32[] barPosC;
    private static Int32[] barPosD;
    private static Int32[] barPosE;
    private static Int32[] barPosF;
    private static Int32[] barPosG;
    private static Int32[] barPosH;
    private static Int32[] barPosI;
    private static Int32[] barPosJ;
    private static Int32[][] barPos;
    private static Char[] barTypeA;
    private static Char[] barTypeB;
    private static Char[] barTypeC;
    private static Char[] barTypeD;
    private static Char[] barTypeE;
    private static Char[] barTypeF;
    private static Char[] barTypeG;
    private static Char[] barTypeH;
    private static Char[] barTypeI;
    private static Char[] barTypeJ;
    private static Char[][] barType;
    private static int A;
    private static int B;
    private static int C;
    private static int D;
    private static int E;
    private static int F;
    private static int G;
    private static int H;
    private static int I;
    private static int J;
    private static IDictionary`2<int, int> table1Check;
    private static IDictionary`2<int, int> table2Check;
    private BinaryBitmap currentBitmap;
    private static IMBReader();
    protected virtual Result doDecode(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
    public virtual void reset();
    private ushort binaryStringToDec(string binary);
    private string invertedBinaryString(string binary);
    private bool getCodeWords(Int32[]& codeWord, string imb, IDictionary`2<int, int> table1Check, IDictionary`2<int, int> table2Check, Int32[][] barPos, Char[][] barType);
    private string getTrackingNumber(string imb);
    private void fillLists(BitArray row, BitArray topRow, BitArray botRow, List`1& listRow, List`1& listTop, List`1& listBot, int start, int stop);
    private int isIMB(BitArray row, Int32& pixelStartOffset, Int32& pixelStopOffset, Int32& pixelBarLength);
    private int getNumberBars(BitArray row, int start, int stop, int barWidth);
    public virtual Result decodeRow(int rowNumber, BitArray row, IDictionary`2<DecodeHintType, object> hints);
}
public class ZXing.InvertedLuminanceSource : LuminanceSource {
    private LuminanceSource delegate;
    private Byte[] invertedMatrix;
    public Byte[] Matrix { get; }
    public bool CropSupported { get; }
    public bool RotateSupported { get; }
    public InvertedLuminanceSource(LuminanceSource delegate);
    public virtual Byte[] getRow(int y, Byte[] row);
    public virtual Byte[] get_Matrix();
    public virtual bool get_CropSupported();
    public virtual LuminanceSource crop(int left, int top, int width, int height);
    public virtual bool get_RotateSupported();
    public virtual LuminanceSource invert();
    public virtual LuminanceSource rotateCounterClockwise();
    public virtual LuminanceSource rotateCounterClockwise45();
}
public abstract class ZXing.LuminanceSource : object {
    private int width;
    private int height;
    public Byte[] Matrix { get; }
    public int Width { get; protected set; }
    public int Height { get; protected set; }
    public bool CropSupported { get; }
    public bool RotateSupported { get; }
    public bool InversionSupported { get; }
    protected LuminanceSource(int width, int height);
    public abstract virtual Byte[] getRow(int y, Byte[] row);
    public abstract virtual Byte[] get_Matrix();
    public virtual int get_Width();
    protected virtual void set_Width(int value);
    public virtual int get_Height();
    protected virtual void set_Height(int value);
    public virtual bool get_CropSupported();
    public virtual LuminanceSource crop(int left, int top, int width, int height);
    public virtual bool get_RotateSupported();
    public virtual LuminanceSource rotateCounterClockwise();
    public virtual LuminanceSource rotateCounterClockwise45();
    public virtual bool get_InversionSupported();
    public virtual LuminanceSource invert();
    public virtual string ToString();
}
internal class ZXing.Maxicode.Internal.BitMatrixParser : object {
    private static Int32[][] BITNR;
    private BitMatrix bitMatrix;
    internal BitMatrixParser(BitMatrix bitMatrix);
    private static BitMatrixParser();
    internal Byte[] readCodewords();
}
internal static class ZXing.Maxicode.Internal.DecodedBitStreamParser : object {
    private static char SHIFTA;
    private static char SHIFTB;
    private static char SHIFTC;
    private static char SHIFTD;
    private static char SHIFTE;
    private static char TWOSHIFTA;
    private static char THREESHIFTA;
    private static char LATCHA;
    private static char LATCHB;
    private static char LOCK;
    private static char ECI;
    private static char NS;
    private static char PAD;
    private static char FS;
    private static char GS;
    private static char RS;
    private static Byte[] COUNTRY_BYTES;
    private static Byte[] SERVICE_CLASS_BYTES;
    private static Byte[] POSTCODE_2_LENGTH_BYTES;
    private static Byte[] POSTCODE_2_BYTES;
    private static Byte[][] POSTCODE_3_BYTES;
    private static string NINE_DIGITS;
    private static string THREE_DIGITS;
    private static String[] SETS;
    private static DecodedBitStreamParser();
    internal static DecoderResult decode(Byte[] bytes, int mode);
    private static int getBit(int bit, Byte[] bytes);
    private static int getInt(Byte[] bytes, Byte[] x);
    private static int getCountry(Byte[] bytes);
    private static int getServiceClass(Byte[] bytes);
    private static int getPostCode2Length(Byte[] bytes);
    private static int getPostCode2(Byte[] bytes);
    private static string getPostCode3(Byte[] bytes);
    private static string getMessage(Byte[] bytes, int start, int len);
}
public class ZXing.Maxicode.Internal.Decoder : object {
    private static int ALL;
    private static int EVEN;
    private static int ODD;
    private ReedSolomonDecoder rsDecoder;
    public DecoderResult decode(BitMatrix bits);
    public DecoderResult decode(BitMatrix bits, IDictionary`2<DecodeHintType, object> hints);
    private bool correctErrors(Byte[] codewordBytes, int start, int dataCodewords, int ecCodewords, int mode);
}
public class ZXing.Maxicode.MaxiCodeReader : object {
    private static ResultPoint[] NO_POINTS;
    private static int MATRIX_WIDTH;
    private static int MATRIX_HEIGHT;
    private Decoder decoder;
    private static MaxiCodeReader();
    public sealed virtual Result decode(BinaryBitmap image);
    public sealed virtual Result decode(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
    public sealed virtual void reset();
    private static BitMatrix extractPureBits(BitMatrix image);
}
public class ZXing.Multi.ByQuadrantReader : object {
    private Reader delegate;
    public ByQuadrantReader(Reader delegate);
    public sealed virtual Result decode(BinaryBitmap image);
    public sealed virtual Result decode(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
    public sealed virtual void reset();
    private static void makeAbsolute(ResultPoint[] points, int leftOffset, int topOffset);
}
public class ZXing.Multi.GenericMultipleBarcodeReader : object {
    private static int MIN_DIMENSION_TO_RECUR;
    private static int MAX_DEPTH;
    private Reader _delegate;
    public GenericMultipleBarcodeReader(Reader delegate);
    public sealed virtual Result[] decodeMultiple(BinaryBitmap image);
    public sealed virtual Result[] decodeMultiple(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
    private void doDecodeMultiple(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints, IList`1<Result> results, int xOffset, int yOffset, int currentDepth);
    private static Result translateResultPoints(Result result, int xOffset, int yOffset);
    public sealed virtual Result decode(BinaryBitmap image);
    public sealed virtual Result decode(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
    public sealed virtual void reset();
}
public interface ZXing.Multi.MultipleBarcodeReader {
    public abstract virtual Result[] decodeMultiple(BinaryBitmap image);
    public abstract virtual Result[] decodeMultiple(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
}
public class ZXing.Multi.QrCode.Internal.MultiDetector : Detector {
    private static DetectorResult[] EMPTY_DETECTOR_RESULTS;
    public MultiDetector(BitMatrix image);
    private static MultiDetector();
    public DetectorResult[] detectMulti(IDictionary`2<DecodeHintType, object> hints);
}
public class ZXing.Multi.QrCode.Internal.MultiFinderPatternFinder : FinderPatternFinder {
    private static FinderPatternInfo[] EMPTY_RESULT_ARRAY;
    private static float MAX_MODULE_COUNT_PER_EDGE;
    private static float MIN_MODULE_COUNT_PER_EDGE;
    private static float DIFF_MODSIZE_CUTOFF_PERCENT;
    private static float DIFF_MODSIZE_CUTOFF;
    public MultiFinderPatternFinder(BitMatrix image, ResultPointCallback resultPointCallback);
    private static MultiFinderPatternFinder();
    private FinderPattern[][] selectMultipleBestPatterns();
    public FinderPatternInfo[] findMulti(IDictionary`2<DecodeHintType, object> hints);
}
public class ZXing.Multi.QrCode.QRCodeMultiReader : QRCodeReader {
    private static ResultPoint[] NO_POINTS;
    private static QRCodeMultiReader();
    public sealed virtual Result[] decodeMultiple(BinaryBitmap image);
    public sealed virtual Result[] decodeMultiple(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
    internal static List`1<Result> ProcessStructuredAppend(List`1<Result> results);
    private static int SaSequenceSort(Result a, Result b);
}
public class ZXing.MultiFormatReader : object {
    private IDictionary`2<DecodeHintType, object> hints;
    private IList`1<Reader> readers;
    unknown IDictionary`2<DecodeHintType, object> Hints {public set; }
    public sealed virtual Result decode(BinaryBitmap image);
    public sealed virtual Result decode(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
    public Result decodeWithState(BinaryBitmap image);
    public void set_Hints(IDictionary`2<DecodeHintType, object> value);
    public sealed virtual void reset();
    private Result decodeInternal(BinaryBitmap image);
    private Result decodeInternal(BinaryBitmap image, ResultPointCallback rpCallback);
}
public class ZXing.MultiFormatWriter : object {
    private static IDictionary`2<BarcodeFormat, Func`1<Writer>> formatMap;
    public static ICollection`1<BarcodeFormat> SupportedWriters { get; }
    private static MultiFormatWriter();
    public static ICollection`1<BarcodeFormat> get_SupportedWriters();
    public sealed virtual BitMatrix encode(string contents, BarcodeFormat format, int width, int height);
    public sealed virtual BitMatrix encode(string contents, BarcodeFormat format, int width, int height, IDictionary`2<EncodeHintType, object> hints);
}
[AttributeUsageAttribute("256")]
internal class ZXing.NonSerializedAttribute : Attribute {
}
public class ZXing.OneD.CodaBarReader : OneDReader {
    private static int MAX_ACCEPTABLE;
    private static int PADDING;
    private static string ALPHABET_STRING;
    internal static Char[] ALPHABET;
    internal static Int32[] CHARACTER_ENCODINGS;
    private static int MIN_CHARACTER_LENGTH;
    private static Char[] STARTEND_ENCODING;
    private StringBuilder decodeRowResult;
    private Int32[] counters;
    private int counterLength;
    private static CodaBarReader();
    public virtual Result decodeRow(int rowNumber, BitArray row, IDictionary`2<DecodeHintType, object> hints);
    private bool validatePattern(int start);
    private bool setCounters(BitArray row);
    private void counterAppend(int e);
    private int findStartPattern();
    internal static bool arrayContains(Char[] array, char key);
    private int toNarrowWidePattern(int position);
}
public class ZXing.OneD.CodaBarWriter : OneDimensionalCodeWriter {
    private static Char[] START_END_CHARS;
    private static Char[] ALT_START_END_CHARS;
    private static Char[] CHARS_WHICH_ARE_TEN_LENGTH_EACH_AFTER_DECODED;
    private static char DEFAULT_GUARD;
    private static IList`1<BarcodeFormat> supportedWriteFormats;
    protected IList`1<BarcodeFormat> SupportedWriteFormats { get; }
    private static CodaBarWriter();
    protected virtual IList`1<BarcodeFormat> get_SupportedWriteFormats();
    public virtual Boolean[] encode(string contents);
}
[SerializableAttribute]
public class ZXing.OneD.Code128EncodingOptions : EncodingOptions {
    public bool ForceCodesetB { get; public set; }
    public Codesets ForceCodeset { get; public set; }
    public bool CompactEncoding { get; public set; }
    public bool get_ForceCodesetB();
    public void set_ForceCodesetB(bool value);
    public Codesets get_ForceCodeset();
    public void set_ForceCodeset(Codesets value);
    public bool get_CompactEncoding();
    public void set_CompactEncoding(bool value);
}
public class ZXing.OneD.Code128Reader : OneDReader {
    internal static Int32[][] CODE_PATTERNS;
    private static int MAX_AVG_VARIANCE;
    private static int MAX_INDIVIDUAL_VARIANCE;
    private static int CODE_SHIFT;
    private static int CODE_CODE_C;
    private static int CODE_CODE_B;
    private static int CODE_CODE_A;
    private static int CODE_FNC_1;
    private static int CODE_FNC_2;
    private static int CODE_FNC_3;
    private static int CODE_FNC_4_A;
    private static int CODE_FNC_4_B;
    private static int CODE_START_A;
    private static int CODE_START_B;
    private static int CODE_START_C;
    private static int CODE_STOP;
    private static Code128Reader();
    private static Int32[] findStartPattern(BitArray row);
    private static bool decodeCode(BitArray row, Int32[] counters, int rowOffset, Int32& code);
    public virtual Result decodeRow(int rowNumber, BitArray row, IDictionary`2<DecodeHintType, object> hints);
}
public class ZXing.OneD.Code128Writer : OneDimensionalCodeWriter {
    internal static int CODE_START_A;
    internal static int CODE_START_B;
    internal static int CODE_START_C;
    internal static int CODE_CODE_A;
    internal static int CODE_CODE_B;
    internal static int CODE_CODE_C;
    internal static int CODE_STOP;
    internal static char ESCAPE_FNC_1;
    internal static char ESCAPE_FNC_2;
    internal static char ESCAPE_FNC_3;
    internal static char ESCAPE_FNC_4;
    internal static int CODE_FNC_1;
    internal static int CODE_FNC_2;
    internal static int CODE_FNC_3;
    internal static int CODE_FNC_4_A;
    internal static int CODE_FNC_4_B;
    private bool forceCodesetB;
    private static IList`1<BarcodeFormat> supportedWriteFormats;
    protected IList`1<BarcodeFormat> SupportedWriteFormats { get; }
    private static Code128Writer();
    protected virtual IList`1<BarcodeFormat> get_SupportedWriteFormats();
    public virtual Boolean[] encode(string contents);
    protected virtual Boolean[] encode(string contents, IDictionary`2<EncodeHintType, object> hints);
    private int check(string contents, IDictionary`2<EncodeHintType, object> hints);
    private Boolean[] encodeFast(string contents, int forcedCodeSet);
    internal static Boolean[] produceResult(List`1<Int32[]> patterns, int checkSum);
    private static CType findCType(string value, int start);
    private int chooseCode(string value, int start, int oldCode);
}
public class ZXing.OneD.Code39Reader : OneDReader {
    internal static string ALPHABET_STRING;
    internal static Int32[] CHARACTER_ENCODINGS;
    internal static int ASTERISK_ENCODING;
    private bool usingCheckDigit;
    private bool extendedMode;
    private StringBuilder decodeRowResult;
    private Int32[] counters;
    public static string Alphabet { get; }
    public Code39Reader(bool usingCheckDigit);
    public Code39Reader(bool usingCheckDigit, bool extendedMode);
    private static Code39Reader();
    public static string get_Alphabet();
    public virtual Result decodeRow(int rowNumber, BitArray row, IDictionary`2<DecodeHintType, object> hints);
    private static Int32[] findAsteriskPattern(BitArray row, Int32[] counters);
    private static int toNarrowWidePattern(Int32[] counters);
    private static bool patternToChar(int pattern, Char& c);
    private static string decodeExtended(string encoded);
}
public class ZXing.OneD.Code39Writer : OneDimensionalCodeWriter {
    private static IList`1<BarcodeFormat> supportedWriteFormats;
    protected IList`1<BarcodeFormat> SupportedWriteFormats { get; }
    private static Code39Writer();
    protected virtual IList`1<BarcodeFormat> get_SupportedWriteFormats();
    public virtual Boolean[] encode(string contents);
    private static void toIntArray(int a, Int32[] toReturn);
    private static string tryToConvertToExtendedMode(string contents);
}
public class ZXing.OneD.Code93Reader : OneDReader {
    internal static string ALPHABET_STRING;
    private static Char[] ALPHABET;
    internal static Int32[] CHARACTER_ENCODINGS;
    internal static int ASTERISK_ENCODING;
    private StringBuilder decodeRowResult;
    private Int32[] counters;
    private static Code93Reader();
    public virtual Result decodeRow(int rowNumber, BitArray row, IDictionary`2<DecodeHintType, object> hints);
    private Int32[] findAsteriskPattern(BitArray row);
    private static int toPattern(Int32[] counters);
    private static bool patternToChar(int pattern, Char& c);
    private static string decodeExtended(StringBuilder encoded);
    private static bool checkChecksums(StringBuilder result);
    private static bool checkOneChecksum(StringBuilder result, int checkPosition, int weightMax);
}
public class ZXing.OneD.Code93Writer : OneDimensionalCodeWriter {
    private static IList`1<BarcodeFormat> supportedWriteFormats;
    protected IList`1<BarcodeFormat> SupportedWriteFormats { get; }
    private static Code93Writer();
    protected virtual IList`1<BarcodeFormat> get_SupportedWriteFormats();
    public virtual Boolean[] encode(string contents);
    [ObsoleteAttribute("without replacement; intended as an internal-only method")]
protected static int appendPattern(Boolean[] target, int pos, Int32[] pattern, bool startColor);
    private static int appendPattern(Boolean[] target, int pos, int a);
    private static int computeChecksumIndex(string contents, int maxWeight);
    internal static string convertToExtended(string contents);
}
public class ZXing.OneD.EAN13Reader : UPCEANReader {
    internal static Int32[] FIRST_DIGIT_ENCODINGS;
    private Int32[] decodeMiddleCounters;
    internal BarcodeFormat BarcodeFormat { get; }
    private static EAN13Reader();
    protected internal virtual int decodeMiddle(BitArray row, Int32[] startRange, StringBuilder resultString);
    internal virtual BarcodeFormat get_BarcodeFormat();
    private static bool determineFirstDigit(StringBuilder resultString, int lgPatternFound);
}
public class ZXing.OneD.EAN13Writer : UPCEANWriter {
    private static int CODE_WIDTH;
    private static IList`1<BarcodeFormat> supportedWriteFormats;
    protected IList`1<BarcodeFormat> SupportedWriteFormats { get; }
    private static EAN13Writer();
    protected virtual IList`1<BarcodeFormat> get_SupportedWriteFormats();
    public virtual Boolean[] encode(string contents);
}
public class ZXing.OneD.EAN8Reader : UPCEANReader {
    private Int32[] decodeMiddleCounters;
    internal BarcodeFormat BarcodeFormat { get; }
    protected internal virtual int decodeMiddle(BitArray row, Int32[] startRange, StringBuilder result);
    internal virtual BarcodeFormat get_BarcodeFormat();
}
public class ZXing.OneD.EAN8Writer : UPCEANWriter {
    private static int CODE_WIDTH;
    private static IList`1<BarcodeFormat> supportedWriteFormats;
    protected IList`1<BarcodeFormat> SupportedWriteFormats { get; }
    private static EAN8Writer();
    protected virtual IList`1<BarcodeFormat> get_SupportedWriteFormats();
    public virtual Boolean[] encode(string contents);
}
internal class ZXing.OneD.EANManufacturerOrgSupport : object {
    private List`1<Int32[]> ranges;
    private List`1<string> countryIdentifiers;
    internal string lookupCountryIdentifier(string productCode);
    private void add(Int32[] range, string id);
    private void initIfNeeded();
}
public class ZXing.OneD.ITFReader : OneDReader {
    private static int MAX_AVG_VARIANCE;
    private static int MAX_INDIVIDUAL_VARIANCE;
    private static int W;
    private static int w;
    private static int N;
    private static Int32[] DEFAULT_ALLOWED_LENGTHS;
    private static int LARGEST_DEFAULT_ALLOWED_LENGTH;
    private int narrowLineWidth;
    private static Int32[] START_PATTERN;
    private static Int32[][] END_PATTERN_REVERSED;
    internal static Int32[][] PATTERNS;
    private static ITFReader();
    public virtual Result decodeRow(int rowNumber, BitArray row, IDictionary`2<DecodeHintType, object> hints);
    private static bool decodeMiddle(BitArray row, int payloadStart, int payloadEnd, StringBuilder resultString);
    private Int32[] decodeStart(BitArray row);
    private bool validateQuietZone(BitArray row, int startPattern);
    private static int skipWhiteSpace(BitArray row);
    private Int32[] decodeEnd(BitArray row);
    private static Int32[] findGuardPattern(BitArray row, int rowOffset, Int32[] pattern);
    private static bool decodeDigit(Int32[] counters, Int32& bestMatch);
}
public class ZXing.OneD.ITFWriter : OneDimensionalCodeWriter {
    private static Int32[] START_PATTERN;
    private static Int32[] END_PATTERN;
    private static int W;
    private static int N;
    internal static Int32[][] PATTERNS;
    private static IList`1<BarcodeFormat> supportedWriteFormats;
    protected IList`1<BarcodeFormat> SupportedWriteFormats { get; }
    private static ITFWriter();
    protected virtual IList`1<BarcodeFormat> get_SupportedWriteFormats();
    public virtual Boolean[] encode(string contents);
}
internal class ZXing.OneD.MinimalEncoder : object {
    private static string A;
    private static string B;
    private static int CODE_SHIFT;
    private Int32[][] memoizedCost;
    private Latch[][] minPath;
    private static MinimalEncoder();
    public Boolean[] encode(string contents);
    private static void addPattern(List`1<Int32[]> patterns, int patternIndex, Int32[] checkSum, Int32[] checkWeight, int position);
    private static bool isDigit(char c);
    private bool canEncode(string contents, Charset charset, int position);
    private int encode(string contents, Charset charset, int position);
}
public class ZXing.OneD.MSIReader : OneDReader {
    internal static string ALPHABET_STRING;
    private static Char[] ALPHABET;
    internal static Int32[] CHARACTER_ENCODINGS;
    private static int START_ENCODING;
    private static int END_ENCODING;
    private bool usingCheckDigit;
    private StringBuilder decodeRowResult;
    private Int32[] counters;
    private int averageCounterWidth;
    private static Int32[] doubleAndCrossSum;
    public MSIReader(bool usingCheckDigit);
    private static MSIReader();
    public virtual Result decodeRow(int rowNumber, BitArray row, IDictionary`2<DecodeHintType, object> hints);
    private Int32[] findStartPattern(BitArray row, Int32[] counters);
    private Int32[] findEndPattern(BitArray row, int rowOffset, Int32[] counters);
    private void calculateAverageCounterWidth(Int32[] counters, int patternLength);
    private int toPattern(Int32[] counters, int patternLength);
    private static bool patternToChar(int pattern, Char& c);
    private static int CalculateChecksumLuhn(string number);
}
public class ZXing.OneD.MSIWriter : OneDimensionalCodeWriter {
    private static Int32[] startWidths;
    private static Int32[] endWidths;
    private static Int32[][] numberWidths;
    private static IList`1<BarcodeFormat> supportedWriteFormats;
    protected IList`1<BarcodeFormat> SupportedWriteFormats { get; }
    private static MSIWriter();
    protected virtual IList`1<BarcodeFormat> get_SupportedWriteFormats();
    public virtual Boolean[] encode(string contents);
}
public class ZXing.OneD.MultiFormatOneDReader : OneDReader {
    private IList`1<OneDReader> readers;
    public MultiFormatOneDReader(IDictionary`2<DecodeHintType, object> hints);
    public virtual Result decodeRow(int rowNumber, BitArray row, IDictionary`2<DecodeHintType, object> hints);
    public virtual void reset();
}
public class ZXing.OneD.MultiFormatUPCEANReader : OneDReader {
    private UPCEANReader[] readers;
    public MultiFormatUPCEANReader(IDictionary`2<DecodeHintType, object> hints);
    public virtual Result decodeRow(int rowNumber, BitArray row, IDictionary`2<DecodeHintType, object> hints);
    public virtual void reset();
}
public abstract class ZXing.OneD.OneDimensionalCodeWriter : object {
    private static Regex NUMERIC;
    private int defaultMargin;
    protected IList`1<BarcodeFormat> SupportedWriteFormats { get; }
    public int DefaultMargin { get; internal set; }
    private static OneDimensionalCodeWriter();
    protected abstract virtual IList`1<BarcodeFormat> get_SupportedWriteFormats();
    public abstract virtual Boolean[] encode(string contents);
    protected virtual Boolean[] encode(string contents, IDictionary`2<EncodeHintType, object> hints);
    public sealed virtual BitMatrix encode(string contents, BarcodeFormat format, int width, int height);
    public virtual BitMatrix encode(string contents, BarcodeFormat format, int width, int height, IDictionary`2<EncodeHintType, object> hints);
    private static BitMatrix renderResult(Boolean[] code, int width, int height, int sidesMargin, bool noPadding);
    protected static void checkNumeric(string contents);
    protected static int appendPattern(Boolean[] target, int pos, Int32[] pattern, bool startColor);
    public int get_DefaultMargin();
    internal void set_DefaultMargin(int value);
    public static string CalculateChecksumDigitModulo10(string contents);
}
public abstract class ZXing.OneD.OneDReader : object {
    protected static int INTEGER_MATH_SHIFT;
    protected static int PATTERN_MATCH_RESULT_SCALE_FACTOR;
    private static OneDReader();
    public sealed virtual Result decode(BinaryBitmap image);
    public virtual Result decode(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
    public virtual void reset();
    protected virtual Result doDecode(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
    protected static bool recordPattern(BitArray row, int start, Int32[] counters);
    protected static bool recordPattern(BitArray row, int start, Int32[] counters, int numCounters);
    protected static bool recordPatternInReverse(BitArray row, int start, Int32[] counters);
    protected static int patternMatchVariance(Int32[] counters, Int32[] pattern, int maxIndividualVariance);
    public abstract virtual Result decodeRow(int rowNumber, BitArray row, IDictionary`2<DecodeHintType, object> hints);
}
public class ZXing.OneD.PharmaCodeReader : OneDReader {
    private static bool isBlack;
    private static bool isWhite;
    private static PharmaCodeReader();
    public static double mean(Double[] m);
    public virtual Result decodeRow(int rowNumber, BitArray row, IDictionary`2<DecodeHintType, object> hints);
    private Nullable`1<int> finalProcessing(List`1<PixelInterval> gaps);
}
public class ZXing.OneD.PlesseyWriter : OneDimensionalCodeWriter {
    private static string ALPHABET_STRING;
    private static Int32[] startWidths;
    private static Int32[] terminationWidths;
    private static Int32[] endWidths;
    private static Int32[][] numberWidths;
    private static Byte[] crcGrid;
    private static Int32[] crc0Widths;
    private static Int32[] crc1Widths;
    private static IList`1<BarcodeFormat> supportedWriteFormats;
    protected IList`1<BarcodeFormat> SupportedWriteFormats { get; }
    private static PlesseyWriter();
    protected virtual IList`1<BarcodeFormat> get_SupportedWriteFormats();
    public virtual Boolean[] encode(string contents);
}
public abstract class ZXing.OneD.RSS.AbstractRSSReader : OneDReader {
    private static int MAX_AVG_VARIANCE;
    private static int MAX_INDIVIDUAL_VARIANCE;
    private static float MIN_FINDER_PATTERN_RATIO;
    private static float MAX_FINDER_PATTERN_RATIO;
    private Int32[] decodeFinderCounters;
    private Int32[] dataCharacterCounters;
    private Single[] oddRoundingErrors;
    private Single[] evenRoundingErrors;
    private Int32[] oddCounts;
    private Int32[] evenCounts;
    private static AbstractRSSReader();
    protected Int32[] getDecodeFinderCounters();
    protected Int32[] getDataCharacterCounters();
    protected Single[] getOddRoundingErrors();
    protected Single[] getEvenRoundingErrors();
    protected Int32[] getOddCounts();
    protected Int32[] getEvenCounts();
    protected static bool parseFinderValue(Int32[] counters, Int32[][] finderPatterns, Int32& value);
    [ObsoleteAttribute]
protected static int count(Int32[] array);
    protected static void increment(Int32[] array, Single[] errors);
    protected static void decrement(Int32[] array, Single[] errors);
    protected static bool isFinderPattern(Int32[] counters);
}
public class ZXing.OneD.RSS.DataCharacter : object {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ChecksumPortion>k__BackingField;
    public int Value { get; private set; }
    public int ChecksumPortion { get; private set; }
    public DataCharacter(int value, int checksumPortion);
    [CompilerGeneratedAttribute]
public int get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(int value);
    [CompilerGeneratedAttribute]
public int get_ChecksumPortion();
    [CompilerGeneratedAttribute]
private void set_ChecksumPortion(int value);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal static class ZXing.OneD.RSS.Expanded.BitArrayBuilder : object {
    internal static BitArray buildBitArray(List`1<ExpandedPair> pairs);
}
public abstract class ZXing.OneD.RSS.Expanded.Decoders.AbstractExpandedDecoder : object {
    private BitArray information;
    private GeneralAppIdDecoder generalDecoder;
    internal AbstractExpandedDecoder(BitArray information);
    protected BitArray getInformation();
    internal GeneralAppIdDecoder getGeneralDecoder();
    public abstract virtual string parseInformation();
    public static AbstractExpandedDecoder createDecoder(BitArray information);
}
internal class ZXing.OneD.RSS.Expanded.Decoders.AI013103decoder : AI013x0xDecoder {
    internal AI013103decoder(BitArray information);
    protected virtual void addWeightCode(StringBuilder buf, int weight);
    protected virtual int checkWeight(int weight);
}
internal class ZXing.OneD.RSS.Expanded.Decoders.AI01320xDecoder : AI013x0xDecoder {
    internal AI01320xDecoder(BitArray information);
    protected virtual void addWeightCode(StringBuilder buf, int weight);
    protected virtual int checkWeight(int weight);
}
internal class ZXing.OneD.RSS.Expanded.Decoders.AI01392xDecoder : AI01decoder {
    private static int HEADER_SIZE;
    private static int LAST_DIGIT_SIZE;
    internal AI01392xDecoder(BitArray information);
    public virtual string parseInformation();
}
internal class ZXing.OneD.RSS.Expanded.Decoders.AI01393xDecoder : AI01decoder {
    private static int HEADER_SIZE;
    private static int LAST_DIGIT_SIZE;
    private static int FIRST_THREE_DIGITS_SIZE;
    internal AI01393xDecoder(BitArray information);
    private static AI01393xDecoder();
    public virtual string parseInformation();
}
internal class ZXing.OneD.RSS.Expanded.Decoders.AI013x0x1xDecoder : AI01weightDecoder {
    private static int HEADER_SIZE;
    private static int WEIGHT_SIZE;
    private static int DATE_SIZE;
    private string dateCode;
    private string firstAIdigits;
    internal AI013x0x1xDecoder(BitArray information, string firstAIdigits, string dateCode);
    private static AI013x0x1xDecoder();
    public virtual string parseInformation();
    private void encodeCompressedDate(StringBuilder buf, int currentPos);
    protected virtual void addWeightCode(StringBuilder buf, int weight);
    protected virtual int checkWeight(int weight);
}
internal abstract class ZXing.OneD.RSS.Expanded.Decoders.AI013x0xDecoder : AI01weightDecoder {
    private static int HEADER_SIZE;
    private static int WEIGHT_SIZE;
    internal AI013x0xDecoder(BitArray information);
    private static AI013x0xDecoder();
    public virtual string parseInformation();
}
internal class ZXing.OneD.RSS.Expanded.Decoders.AI01AndOtherAIs : AI01decoder {
    private static int HEADER_SIZE;
    internal AI01AndOtherAIs(BitArray information);
    private static AI01AndOtherAIs();
    public virtual string parseInformation();
}
internal abstract class ZXing.OneD.RSS.Expanded.Decoders.AI01decoder : AbstractExpandedDecoder {
    protected static int GTIN_SIZE;
    internal AI01decoder(BitArray information);
    private static AI01decoder();
    protected void encodeCompressedGtin(StringBuilder buf, int currentPos);
    protected void encodeCompressedGtinWithoutAI(StringBuilder buf, int currentPos, int initialBufferPosition);
    private static void appendCheckDigit(StringBuilder buf, int currentPos);
}
internal abstract class ZXing.OneD.RSS.Expanded.Decoders.AI01weightDecoder : AI01decoder {
    internal AI01weightDecoder(BitArray information);
    protected void encodeCompressedWeight(StringBuilder buf, int currentPos, int weightSize);
    protected abstract virtual void addWeightCode(StringBuilder buf, int weight);
    protected abstract virtual int checkWeight(int weight);
}
internal class ZXing.OneD.RSS.Expanded.Decoders.AnyAIDecoder : AbstractExpandedDecoder {
    private static int HEADER_SIZE;
    internal AnyAIDecoder(BitArray information);
    private static AnyAIDecoder();
    public virtual string parseInformation();
}
internal class ZXing.OneD.RSS.Expanded.Decoders.BlockParsedResult : object {
    private DecodedInformation decodedInformation;
    private bool finished;
    internal BlockParsedResult(DecodedInformation information, bool finished);
    internal DecodedInformation getDecodedInformation();
    internal bool isFinished();
}
internal class ZXing.OneD.RSS.Expanded.Decoders.CurrentParsingState : object {
    private int position;
    private State encoding;
    internal int getPosition();
    internal void setPosition(int position);
    internal void incrementPosition(int delta);
    internal bool isAlpha();
    internal bool isNumeric();
    internal bool isIsoIec646();
    internal void setNumeric();
    internal void setAlpha();
    internal void setIsoIec646();
}
internal class ZXing.OneD.RSS.Expanded.Decoders.DataLength : object {
    internal bool variable;
    internal int length;
    private DataLength(bool variable, int length);
    public static DataLength fixedLength(int length);
    public static DataLength variableLength(int length);
}
internal class ZXing.OneD.RSS.Expanded.Decoders.DecodedChar : DecodedObject {
    private char value;
    internal static char FNC1;
    internal DecodedChar(int newPosition, char value);
    private static DecodedChar();
    internal char getValue();
    internal bool isFNC1();
}
internal class ZXing.OneD.RSS.Expanded.Decoders.DecodedInformation : DecodedObject {
    private string newString;
    private int remainingValue;
    private bool remaining;
    internal DecodedInformation(int newPosition, string newString);
    internal DecodedInformation(int newPosition, string newString, int remainingValue);
    internal string getNewString();
    internal bool isRemaining();
    internal int getRemainingValue();
}
internal class ZXing.OneD.RSS.Expanded.Decoders.DecodedNumeric : DecodedObject {
    private int firstDigit;
    private int secondDigit;
    internal static int FNC1;
    internal DecodedNumeric(int newPosition, int firstDigit, int secondDigit);
    private static DecodedNumeric();
    internal int getFirstDigit();
    internal int getSecondDigit();
    internal int getValue();
    internal bool isFirstDigitFNC1();
    internal bool isSecondDigitFNC1();
}
internal abstract class ZXing.OneD.RSS.Expanded.Decoders.DecodedObject : object {
    [CompilerGeneratedAttribute]
private int <NewPosition>k__BackingField;
    internal int NewPosition { get; private set; }
    internal DecodedObject(int newPosition);
    [CompilerGeneratedAttribute]
internal int get_NewPosition();
    [CompilerGeneratedAttribute]
private void set_NewPosition(int value);
}
internal static class ZXing.OneD.RSS.Expanded.Decoders.FieldParser : object {
    private static object VARIABLE_LENGTH;
    private static IDictionary`2<string, DataLength> TWO_DIGIT_DATA_LENGTH;
    private static IDictionary`2<string, DataLength> THREE_DIGIT_DATA_LENGTH;
    private static IDictionary`2<string, DataLength> THREE_DIGIT_PLUS_DIGIT_DATA_LENGTH;
    private static IDictionary`2<string, DataLength> FOUR_DIGIT_DATA_LENGTH;
    private static FieldParser();
    internal static string parseFieldsInGeneralPurpose(string rawInformation);
    private static string processFixedAI(int aiSize, int fieldSize, string rawInformation);
    private static string processVariableAI(int aiSize, int variableFieldSize, string rawInformation);
}
internal class ZXing.OneD.RSS.Expanded.Decoders.GeneralAppIdDecoder : object {
    private BitArray information;
    private CurrentParsingState current;
    private StringBuilder buffer;
    internal GeneralAppIdDecoder(BitArray information);
    internal string decodeAllCodes(StringBuilder buff, int initialPosition);
    private bool isStillNumeric(int pos);
    private DecodedNumeric decodeNumeric(int pos);
    internal int extractNumericValueFromBitArray(int pos, int bits);
    internal static int extractNumericValueFromBitArray(BitArray information, int pos, int bits);
    internal DecodedInformation decodeGeneralPurposeField(int pos, string remaining);
    private DecodedInformation parseBlocks();
    private BlockParsedResult parseNumericBlock();
    private BlockParsedResult parseIsoIec646Block();
    private BlockParsedResult parseAlphaBlock();
    private bool isStillIsoIec646(int pos);
    private DecodedChar decodeIsoIec646(int pos);
    private bool isStillAlpha(int pos);
    private DecodedChar decodeAlphanumeric(int pos);
    private bool isAlphaTo646ToAlphaLatch(int pos);
    private bool isAlphaOr646ToNumericLatch(int pos);
    private bool isNumericToAlphaNumericLatch(int pos);
}
internal class ZXing.OneD.RSS.Expanded.ExpandedPair : object {
    [CompilerGeneratedAttribute]
private bool <MayBeLast>k__BackingField;
    [CompilerGeneratedAttribute]
private DataCharacter <LeftChar>k__BackingField;
    [CompilerGeneratedAttribute]
private DataCharacter <RightChar>k__BackingField;
    [CompilerGeneratedAttribute]
private FinderPattern <FinderPattern>k__BackingField;
    internal bool MayBeLast { get; private set; }
    internal DataCharacter LeftChar { get; private set; }
    internal DataCharacter RightChar { get; private set; }
    internal FinderPattern FinderPattern { get; private set; }
    public bool MustBeLast { get; }
    internal ExpandedPair(DataCharacter leftChar, DataCharacter rightChar, FinderPattern finderPattern);
    [CompilerGeneratedAttribute]
internal bool get_MayBeLast();
    [CompilerGeneratedAttribute]
private void set_MayBeLast(bool value);
    [CompilerGeneratedAttribute]
internal DataCharacter get_LeftChar();
    [CompilerGeneratedAttribute]
private void set_LeftChar(DataCharacter value);
    [CompilerGeneratedAttribute]
internal DataCharacter get_RightChar();
    [CompilerGeneratedAttribute]
private void set_RightChar(DataCharacter value);
    [CompilerGeneratedAttribute]
internal FinderPattern get_FinderPattern();
    [CompilerGeneratedAttribute]
private void set_FinderPattern(FinderPattern value);
    public bool get_MustBeLast();
    public virtual string ToString();
    public virtual bool Equals(object o);
    private static bool EqualsOrNull(object o1, object o2);
    public virtual int GetHashCode();
    private static int hashNotNull(object o);
}
internal class ZXing.OneD.RSS.Expanded.ExpandedRow : object {
    [CompilerGeneratedAttribute]
private List`1<ExpandedPair> <Pairs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowNumber>k__BackingField;
    internal List`1<ExpandedPair> Pairs { get; private set; }
    internal int RowNumber { get; private set; }
    internal ExpandedRow(List`1<ExpandedPair> pairs, int rowNumber);
    [CompilerGeneratedAttribute]
internal List`1<ExpandedPair> get_Pairs();
    [CompilerGeneratedAttribute]
private void set_Pairs(List`1<ExpandedPair> value);
    [CompilerGeneratedAttribute]
internal int get_RowNumber();
    [CompilerGeneratedAttribute]
private void set_RowNumber(int value);
    internal bool IsEquivalent(List`1<ExpandedPair> otherPairs);
    public virtual string ToString();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
public class ZXing.OneD.RSS.Expanded.RSSExpandedReader : AbstractRSSReader {
    private static Int32[] SYMBOL_WIDEST;
    private static Int32[] EVEN_TOTAL_SUBSET;
    private static Int32[] GSUM;
    private static Int32[][] FINDER_PATTERNS;
    private static Int32[][] WEIGHTS;
    private static int FINDER_PAT_A;
    private static int FINDER_PAT_B;
    private static int FINDER_PAT_C;
    private static int FINDER_PAT_D;
    private static int FINDER_PAT_E;
    private static int FINDER_PAT_F;
    private static Int32[][] FINDER_PATTERN_SEQUENCES;
    private static int MAX_PAIRS;
    private List`1<ExpandedPair> pairs;
    private List`1<ExpandedRow> rows;
    private Int32[] startEnd;
    private bool startFromEven;
    internal List`1<ExpandedPair> Pairs { get; }
    internal List`1<ExpandedRow> Rows { get; }
    private static RSSExpandedReader();
    internal List`1<ExpandedPair> get_Pairs();
    public virtual Result decodeRow(int rowNumber, BitArray row, IDictionary`2<DecodeHintType, object> hints);
    public virtual void reset();
    internal bool decodeRow2pairs(int rowNumber, BitArray row);
    private List`1<ExpandedPair> checkRows(bool reverse);
    private List`1<ExpandedPair> checkRows(List`1<ExpandedRow> collectedRows, int currentRow);
    private static bool isValidSequence(List`1<ExpandedPair> pairs);
    private void storeRow(int rowNumber);
    private static void removePartialRows(List`1<ExpandedPair> pairs, List`1<ExpandedRow> rows);
    private static bool isPartialRow(IEnumerable`1<ExpandedPair> pairs, IEnumerable`1<ExpandedRow> rows);
    internal List`1<ExpandedRow> get_Rows();
    internal static Result constructResult(List`1<ExpandedPair> pairs);
    private bool checkChecksum();
    private static int getNextSecondBar(BitArray row, int initialPos);
    internal ExpandedPair retrieveNextPair(BitArray row, List`1<ExpandedPair> previousPairs, int rowNumber);
    private bool findNextPair(BitArray row, List`1<ExpandedPair> previousPairs, int forcedOffset);
    private static void reverseCounters(Int32[] counters);
    private FinderPattern parseFoundFinderPattern(BitArray row, int rowNumber, bool oddPattern);
    internal DataCharacter decodeDataCharacter(BitArray row, FinderPattern pattern, bool isOddPattern, bool leftChar);
    private static bool isNotA1left(FinderPattern pattern, bool isOddPattern, bool leftChar);
    private bool adjustOddEvenCounts(int numModules);
}
public class ZXing.OneD.RSS.FinderPattern : object {
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <StartEnd>k__BackingField;
    [CompilerGeneratedAttribute]
private ResultPoint[] <ResultPoints>k__BackingField;
    public int Value { get; private set; }
    public Int32[] StartEnd { get; private set; }
    public ResultPoint[] ResultPoints { get; private set; }
    public FinderPattern(int value, Int32[] startEnd, int start, int end, int rowNumber);
    [CompilerGeneratedAttribute]
public int get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(int value);
    [CompilerGeneratedAttribute]
public Int32[] get_StartEnd();
    [CompilerGeneratedAttribute]
private void set_StartEnd(Int32[] value);
    [CompilerGeneratedAttribute]
public ResultPoint[] get_ResultPoints();
    [CompilerGeneratedAttribute]
private void set_ResultPoints(ResultPoint[] value);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class ZXing.OneD.RSS.Pair : DataCharacter {
    [CompilerGeneratedAttribute]
private FinderPattern <FinderPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public FinderPattern FinderPattern { get; private set; }
    public int Count { get; private set; }
    internal Pair(int value, int checksumPortion, FinderPattern finderPattern);
    [CompilerGeneratedAttribute]
public FinderPattern get_FinderPattern();
    [CompilerGeneratedAttribute]
private void set_FinderPattern(FinderPattern value);
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
private void set_Count(int value);
    public void incrementCount();
}
public class ZXing.OneD.RSS.RSS14Reader : AbstractRSSReader {
    private static Int32[] OUTSIDE_EVEN_TOTAL_SUBSET;
    private static Int32[] INSIDE_ODD_TOTAL_SUBSET;
    private static Int32[] OUTSIDE_GSUM;
    private static Int32[] INSIDE_GSUM;
    private static Int32[] OUTSIDE_ODD_WIDEST;
    private static Int32[] INSIDE_ODD_WIDEST;
    private static Int32[][] FINDER_PATTERNS;
    private List`1<Pair> possibleLeftPairs;
    private List`1<Pair> possibleRightPairs;
    private static RSS14Reader();
    public virtual Result decodeRow(int rowNumber, BitArray row, IDictionary`2<DecodeHintType, object> hints);
    private static void addOrTally(IList`1<Pair> possiblePairs, Pair pair);
    public virtual void reset();
    private static Result constructResult(Pair leftPair, Pair rightPair);
    private static bool checkChecksum(Pair leftPair, Pair rightPair);
    private Pair decodePair(BitArray row, bool right, int rowNumber, IDictionary`2<DecodeHintType, object> hints);
    private DataCharacter decodeDataCharacter(BitArray row, FinderPattern pattern, bool outsideChar);
    private Int32[] findFinderPattern(BitArray row, bool rightFinderPattern);
    private FinderPattern parseFoundFinderPattern(BitArray row, int rowNumber, bool right, Int32[] startEnd);
    private bool adjustOddEvenCounts(bool outsideChar, int numModules);
}
public static class ZXing.OneD.RSS.RSSUtils : object {
    public static int getRSSvalue(Int32[] widths, int maxWidth, bool noNarrow);
    private static int combins(int n, int r);
}
public class ZXing.OneD.UPCAReader : UPCEANReader {
    private UPCEANReader ean13Reader;
    internal BarcodeFormat BarcodeFormat { get; }
    public virtual Result decodeRow(int rowNumber, BitArray row, Int32[] startGuardRange, IDictionary`2<DecodeHintType, object> hints);
    public virtual Result decodeRow(int rowNumber, BitArray row, IDictionary`2<DecodeHintType, object> hints);
    public virtual Result decode(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
    internal virtual BarcodeFormat get_BarcodeFormat();
    protected internal virtual int decodeMiddle(BitArray row, Int32[] startRange, StringBuilder resultString);
    private static Result maybeReturnResult(Result result);
}
public class ZXing.OneD.UPCAWriter : object {
    private EAN13Writer subWriter;
    public int DefaultMargin { get; internal set; }
    public int get_DefaultMargin();
    internal void set_DefaultMargin(int value);
    public sealed virtual BitMatrix encode(string contents, BarcodeFormat format, int width, int height);
    public sealed virtual BitMatrix encode(string contents, BarcodeFormat format, int width, int height, IDictionary`2<EncodeHintType, object> hints);
}
internal class ZXing.OneD.UPCEANExtension2Support : object {
    private Int32[] decodeMiddleCounters;
    private StringBuilder decodeRowStringBuffer;
    internal Result decodeRow(int rowNumber, BitArray row, Int32[] extensionStartRange);
    private int decodeMiddle(BitArray row, Int32[] startRange, StringBuilder resultString);
    private static IDictionary`2<ResultMetadataType, object> parseExtensionString(string raw);
}
internal class ZXing.OneD.UPCEANExtension5Support : object {
    private static Int32[] CHECK_DIGIT_ENCODINGS;
    private Int32[] decodeMiddleCounters;
    private StringBuilder decodeRowStringBuffer;
    private static UPCEANExtension5Support();
    internal Result decodeRow(int rowNumber, BitArray row, Int32[] extensionStartRange);
    private int decodeMiddle(BitArray row, Int32[] startRange, StringBuilder resultString);
    private static int extensionChecksum(string s);
    private static bool determineCheckDigit(int lgPatternFound, Int32& checkDigit);
    private static IDictionary`2<ResultMetadataType, object> parseExtensionString(string raw);
    private static string parseExtension5String(string raw);
}
internal class ZXing.OneD.UPCEANExtensionSupport : object {
    private static Int32[] EXTENSION_START_PATTERN;
    private UPCEANExtension2Support twoSupport;
    private UPCEANExtension5Support fiveSupport;
    private static UPCEANExtensionSupport();
    internal Result decodeRow(int rowNumber, BitArray row, int rowOffset);
}
public abstract class ZXing.OneD.UPCEANReader : OneDReader {
    private static int MAX_AVG_VARIANCE;
    private static int MAX_INDIVIDUAL_VARIANCE;
    internal static Int32[] START_END_PATTERN;
    internal static Int32[] MIDDLE_PATTERN;
    internal static Int32[] END_PATTERN;
    internal static Int32[][] L_PATTERNS;
    internal static Int32[][] L_AND_G_PATTERNS;
    private StringBuilder decodeRowStringBuffer;
    private UPCEANExtensionSupport extensionReader;
    private EANManufacturerOrgSupport eanManSupport;
    internal BarcodeFormat BarcodeFormat { get; }
    private static UPCEANReader();
    internal static Int32[] findStartGuardPattern(BitArray row);
    public virtual Result decodeRow(int rowNumber, BitArray row, IDictionary`2<DecodeHintType, object> hints);
    public virtual Result decodeRow(int rowNumber, BitArray row, Int32[] startGuardRange, IDictionary`2<DecodeHintType, object> hints);
    protected virtual bool checkChecksum(string s);
    internal static bool checkStandardUPCEANChecksum(string s);
    internal static Nullable`1<int> getStandardUPCEANChecksum(string s);
    protected virtual Int32[] decodeEnd(BitArray row, int endStart);
    internal static Int32[] findGuardPattern(BitArray row, int rowOffset, bool whiteFirst, Int32[] pattern);
    internal static Int32[] findGuardPattern(BitArray row, int rowOffset, bool whiteFirst, Int32[] pattern, Int32[] counters);
    internal static bool decodeDigit(BitArray row, Int32[] counters, int rowOffset, Int32[][] patterns, Int32& digit);
    internal abstract virtual BarcodeFormat get_BarcodeFormat();
    protected internal abstract virtual int decodeMiddle(BitArray row, Int32[] startRange, StringBuilder resultString);
}
public abstract class ZXing.OneD.UPCEANWriter : OneDimensionalCodeWriter {
}
public class ZXing.OneD.UPCEReader : UPCEANReader {
    private static Int32[] MIDDLE_END_PATTERN;
    internal static Int32[][] NUMSYS_AND_CHECK_DIGIT_PATTERNS;
    private Int32[] decodeMiddleCounters;
    internal BarcodeFormat BarcodeFormat { get; }
    private static UPCEReader();
    protected internal virtual int decodeMiddle(BitArray row, Int32[] startRange, StringBuilder result);
    protected virtual Int32[] decodeEnd(BitArray row, int endStart);
    protected virtual bool checkChecksum(string s);
    private static bool determineNumSysAndCheckDigit(StringBuilder resultString, int lgPatternFound);
    internal virtual BarcodeFormat get_BarcodeFormat();
    public static string convertUPCEtoUPCA(string upce);
}
public class ZXing.OneD.UPCEWriter : UPCEANWriter {
    private static int CODE_WIDTH;
    private static IList`1<BarcodeFormat> supportedWriteFormats;
    protected IList`1<BarcodeFormat> SupportedWriteFormats { get; }
    private static UPCEWriter();
    protected virtual IList`1<BarcodeFormat> get_SupportedWriteFormats();
    public virtual Boolean[] encode(string contents);
}
internal class ZXing.PDF417.Internal.BarcodeMatrix : object {
    private BarcodeRow[] matrix;
    private int currentRow;
    private int height;
    private int width;
    internal static int COLUMN_WIDTH;
    internal BarcodeMatrix(int height, int width, bool compact);
    internal void set(int x, int y, sbyte value);
    internal void startRow();
    internal BarcodeRow getCurrentRow();
    internal SByte[][] getMatrix();
    internal SByte[][] getScaledMatrix(int xScale, int yScale);
}
public class ZXing.PDF417.Internal.BarcodeMetadata : object {
    [CompilerGeneratedAttribute]
private int <ColumnCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ErrorCorrectionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowCountUpper>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowCountLower>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowCount>k__BackingField;
    public int ColumnCount { get; private set; }
    public int ErrorCorrectionLevel { get; private set; }
    public int RowCountUpper { get; private set; }
    public int RowCountLower { get; private set; }
    public int RowCount { get; private set; }
    public BarcodeMetadata(int columnCount, int rowCountUpperPart, int rowCountLowerPart, int errorCorrectionLevel);
    [CompilerGeneratedAttribute]
public int get_ColumnCount();
    [CompilerGeneratedAttribute]
private void set_ColumnCount(int value);
    [CompilerGeneratedAttribute]
public int get_ErrorCorrectionLevel();
    [CompilerGeneratedAttribute]
private void set_ErrorCorrectionLevel(int value);
    [CompilerGeneratedAttribute]
public int get_RowCountUpper();
    [CompilerGeneratedAttribute]
private void set_RowCountUpper(int value);
    [CompilerGeneratedAttribute]
public int get_RowCountLower();
    [CompilerGeneratedAttribute]
private void set_RowCountLower(int value);
    [CompilerGeneratedAttribute]
public int get_RowCount();
    [CompilerGeneratedAttribute]
private void set_RowCount(int value);
}
[DefaultMemberAttribute("Item")]
internal class ZXing.PDF417.Internal.BarcodeRow : object {
    private SByte[] row;
    private int currentLocation;
    internal sbyte Item { get; internal set; }
    internal BarcodeRow(int width);
    internal sbyte get_Item(int x);
    internal void set_Item(int x, sbyte value);
    internal void set(int x, bool black);
    internal void addBar(bool black, int width);
    internal SByte[] getScaledRow(int scale);
}
public class ZXing.PDF417.Internal.BarcodeValue : object {
    private IDictionary`2<int, int> values;
    public void setValue(int value);
    public Int32[] getValue();
    internal int getConfidence(int barcodeValue);
}
public class ZXing.PDF417.Internal.BoundingBox : object {
    private BitMatrix image;
    [CompilerGeneratedAttribute]
private ResultPoint <TopLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private ResultPoint <TopRight>k__BackingField;
    [CompilerGeneratedAttribute]
private ResultPoint <BottomLeft>k__BackingField;
    [CompilerGeneratedAttribute]
private ResultPoint <BottomRight>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinX>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxX>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinY>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxY>k__BackingField;
    public ResultPoint TopLeft { get; private set; }
    public ResultPoint TopRight { get; private set; }
    public ResultPoint BottomLeft { get; private set; }
    public ResultPoint BottomRight { get; private set; }
    public int MinX { get; private set; }
    public int MaxX { get; private set; }
    public int MinY { get; private set; }
    public int MaxY { get; private set; }
    private BoundingBox(BitMatrix image, ResultPoint topLeft, ResultPoint bottomLeft, ResultPoint topRight, ResultPoint bottomRight);
    private BoundingBox(BoundingBox boundingBox);
    [CompilerGeneratedAttribute]
public ResultPoint get_TopLeft();
    [CompilerGeneratedAttribute]
private void set_TopLeft(ResultPoint value);
    [CompilerGeneratedAttribute]
public ResultPoint get_TopRight();
    [CompilerGeneratedAttribute]
private void set_TopRight(ResultPoint value);
    [CompilerGeneratedAttribute]
public ResultPoint get_BottomLeft();
    [CompilerGeneratedAttribute]
private void set_BottomLeft(ResultPoint value);
    [CompilerGeneratedAttribute]
public ResultPoint get_BottomRight();
    [CompilerGeneratedAttribute]
private void set_BottomRight(ResultPoint value);
    [CompilerGeneratedAttribute]
public int get_MinX();
    [CompilerGeneratedAttribute]
private void set_MinX(int value);
    [CompilerGeneratedAttribute]
public int get_MaxX();
    [CompilerGeneratedAttribute]
private void set_MaxX(int value);
    [CompilerGeneratedAttribute]
public int get_MinY();
    [CompilerGeneratedAttribute]
private void set_MinY(int value);
    [CompilerGeneratedAttribute]
public int get_MaxY();
    [CompilerGeneratedAttribute]
private void set_MaxY(int value);
    public static BoundingBox Create(BitMatrix image, ResultPoint topLeft, ResultPoint bottomLeft, ResultPoint topRight, ResultPoint bottomRight);
    public static BoundingBox Create(BoundingBox box);
    internal static BoundingBox merge(BoundingBox leftBox, BoundingBox rightBox);
    public BoundingBox addMissingRows(int missingStartRows, int missingEndRows, bool isLeft);
}
public class ZXing.PDF417.Internal.Codeword : object {
    private static int BARCODE_ROW_UNKNOWN;
    [CompilerGeneratedAttribute]
private int <StartX>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndX>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Bucket>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowNumber>k__BackingField;
    public int StartX { get; private set; }
    public int EndX { get; private set; }
    public int Bucket { get; private set; }
    public int Value { get; private set; }
    public int RowNumber { get; public set; }
    public int Width { get; }
    public bool HasValidRowNumber { get; }
    public Codeword(int startX, int endX, int bucket, int value);
    private static Codeword();
    [CompilerGeneratedAttribute]
public int get_StartX();
    [CompilerGeneratedAttribute]
private void set_StartX(int value);
    [CompilerGeneratedAttribute]
public int get_EndX();
    [CompilerGeneratedAttribute]
private void set_EndX(int value);
    [CompilerGeneratedAttribute]
public int get_Bucket();
    [CompilerGeneratedAttribute]
private void set_Bucket(int value);
    [CompilerGeneratedAttribute]
public int get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(int value);
    [CompilerGeneratedAttribute]
public int get_RowNumber();
    [CompilerGeneratedAttribute]
public void set_RowNumber(int value);
    public int get_Width();
    public bool get_HasValidRowNumber();
    public bool IsValidRowNumber(int rowNumber);
    public void setRowNumberAsRowIndicatorColumn();
    public virtual string ToString();
}
public enum ZXing.PDF417.Internal.Compaction : Enum {
    public int value__;
    public static Compaction AUTO;
    public static Compaction TEXT;
    public static Compaction BYTE;
    public static Compaction NUMERIC;
}
internal static class ZXing.PDF417.Internal.DecodedBitStreamParser : object {
    private static int TEXT_COMPACTION_MODE_LATCH;
    private static int BYTE_COMPACTION_MODE_LATCH;
    private static int NUMERIC_COMPACTION_MODE_LATCH;
    private static int BYTE_COMPACTION_MODE_LATCH_6;
    private static int ECI_USER_DEFINED;
    private static int ECI_GENERAL_PURPOSE;
    private static int ECI_CHARSET;
    private static int BEGIN_MACRO_PDF417_CONTROL_BLOCK;
    private static int BEGIN_MACRO_PDF417_OPTIONAL_FIELD;
    private static int MACRO_PDF417_TERMINATOR;
    private static int MODE_SHIFT_TO_BYTE_COMPACTION_MODE;
    private static int MAX_NUMERIC_CODEWORDS;
    private static int MACRO_PDF417_OPTIONAL_FIELD_FILE_NAME;
    private static int MACRO_PDF417_OPTIONAL_FIELD_SEGMENT_COUNT;
    private static int MACRO_PDF417_OPTIONAL_FIELD_TIME_STAMP;
    private static int MACRO_PDF417_OPTIONAL_FIELD_SENDER;
    private static int MACRO_PDF417_OPTIONAL_FIELD_ADDRESSEE;
    private static int MACRO_PDF417_OPTIONAL_FIELD_FILE_SIZE;
    private static int MACRO_PDF417_OPTIONAL_FIELD_CHECKSUM;
    private static int PL;
    private static int LL;
    private static int AS;
    private static int ML;
    private static int AL;
    private static int PS;
    private static int PAL;
    private static Char[] PUNCT_CHARS;
    private static Char[] MIXED_CHARS;
    private static BigInteger[] EXP900;
    private static int NUMBER_OF_SEQUENCE_CODEWORDS;
    private static DecodedBitStreamParser();
    internal static DecoderResult decode(Int32[] codewords, string ecLevel, Encoding startWithEncoding);
    internal static int decodeMacroBlock(Int32[] codewords, int codeIndex, PDF417ResultMetadata resultMetadata);
    private static int textCompaction(Int32[] codewords, int codeIndex, ECIStringBuilder result);
    private static Mode decodeTextCompaction(Int32[] textCompactionData, Int32[] byteCompactionData, int length, ECIStringBuilder result, Mode startMode);
    private static int byteCompaction(int mode, Int32[] codewords, int codeIndex, ECIStringBuilder result);
    private static int numericCompaction(Int32[] codewords, int codeIndex, ECIStringBuilder result);
    private static string decodeBase900toBase10(Int32[] codewords, int count);
}
public class ZXing.PDF417.Internal.DetectionResult : object {
    private static int ADJUST_ROW_NUMBER_SKIP;
    [CompilerGeneratedAttribute]
private BarcodeMetadata <Metadata>k__BackingField;
    [CompilerGeneratedAttribute]
private DetectionResultColumn[] <DetectionResultColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private BoundingBox <Box>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnCount>k__BackingField;
    public BarcodeMetadata Metadata { get; private set; }
    public DetectionResultColumn[] DetectionResultColumns { get; public set; }
    public BoundingBox Box { get; internal set; }
    public int ColumnCount { get; private set; }
    public int RowCount { get; }
    public int ErrorCorrectionLevel { get; }
    public DetectionResult(BarcodeMetadata metadata, BoundingBox box);
    [CompilerGeneratedAttribute]
public BarcodeMetadata get_Metadata();
    [CompilerGeneratedAttribute]
private void set_Metadata(BarcodeMetadata value);
    [CompilerGeneratedAttribute]
public DetectionResultColumn[] get_DetectionResultColumns();
    [CompilerGeneratedAttribute]
public void set_DetectionResultColumns(DetectionResultColumn[] value);
    [CompilerGeneratedAttribute]
public BoundingBox get_Box();
    [CompilerGeneratedAttribute]
internal void set_Box(BoundingBox value);
    [CompilerGeneratedAttribute]
public int get_ColumnCount();
    [CompilerGeneratedAttribute]
private void set_ColumnCount(int value);
    public int get_RowCount();
    public int get_ErrorCorrectionLevel();
    public DetectionResultColumn[] getDetectionResultColumns();
    private void adjustIndicatorColumnRowNumbers(DetectionResultColumn detectionResultColumn);
    private int adjustRowNumbers();
    private int adjustRowNumbersByRow();
    private void adjustRowNumbersFromBothRI();
    private int adjustRowNumbersFromRRI();
    private int adjustRowNumbersFromLRI();
    private static int adjustRowNumberIfValid(int rowIndicatorRowNumber, int invalidRowCounts, Codeword codeword);
    private void adjustRowNumbers(int barcodeColumn, int codewordsRow, Codeword[] codewords);
    private static bool adjustRowNumber(Codeword codeword, Codeword otherCodeword);
    public virtual string ToString();
}
public class ZXing.PDF417.Internal.DetectionResultColumn : object {
    private static int MAX_NEARBY_DISTANCE;
    [CompilerGeneratedAttribute]
private BoundingBox <Box>k__BackingField;
    [CompilerGeneratedAttribute]
private Codeword[] <Codewords>k__BackingField;
    public BoundingBox Box { get; private set; }
    public Codeword[] Codewords { get; public set; }
    public DetectionResultColumn(BoundingBox box);
    [CompilerGeneratedAttribute]
public BoundingBox get_Box();
    [CompilerGeneratedAttribute]
private void set_Box(BoundingBox value);
    [CompilerGeneratedAttribute]
public Codeword[] get_Codewords();
    [CompilerGeneratedAttribute]
public void set_Codewords(Codeword[] value);
    public int IndexForRow(int imageRow);
    public int RowForIndex(int codewordIndex);
    public Codeword getCodeword(int imageRow);
    public Codeword getCodewordNearby(int imageRow);
    internal int imageRowToCodewordIndex(int imageRow);
    public void setCodeword(int imageRow, Codeword codeword);
    public virtual string ToString();
}
public class ZXing.PDF417.Internal.DetectionResultRowIndicatorColumn : DetectionResultColumn {
    [CompilerGeneratedAttribute]
private bool <IsLeft>k__BackingField;
    public bool IsLeft { get; public set; }
    public DetectionResultRowIndicatorColumn(BoundingBox box, bool isLeft);
    [CompilerGeneratedAttribute]
public bool get_IsLeft();
    [CompilerGeneratedAttribute]
public void set_IsLeft(bool value);
    private void setRowNumbers();
    public void adjustCompleteIndicatorColumnRowNumbers(BarcodeMetadata metadata);
    public Int32[] getRowHeights();
    private void adjustIncompleteIndicatorColumnRowNumbers(BarcodeMetadata metadata);
    public BarcodeMetadata getBarcodeMetadata();
    private void removeIncorrectCodewords(Codeword[] codewords, BarcodeMetadata metadata);
    public virtual string ToString();
}
public class ZXing.PDF417.Internal.Detector : object {
    private static Int32[] INDEXES_START_PATTERN;
    private static Int32[] INDEXES_STOP_PATTERN;
    private static int INTEGER_MATH_SHIFT;
    private static int PATTERN_MATCH_RESULT_SCALE_FACTOR;
    private static int MAX_AVG_VARIANCE;
    private static int MAX_INDIVIDUAL_VARIANCE;
    private static Int32[] START_PATTERN;
    private static Int32[] STOP_PATTERN;
    private static int MAX_PIXEL_DRIFT;
    private static int MAX_PATTERN_DRIFT;
    private static int SKIPPED_ROW_COUNT_MAX;
    private static int ROW_STEP;
    private static int BARCODE_MIN_HEIGHT;
    private static Int32[] ROTATIONS;
    private static Detector();
    public static PDF417DetectorResult detect(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints, bool multiple);
    private static BitMatrix applyRotation(BitMatrix matrix, int rotation);
    private static List`1<ResultPoint[]> detect(bool multiple, BitMatrix bitMatrix);
    private static ResultPoint[] findVertices(BitMatrix matrix, int startRow, int startColumn);
    private static void copyToResult(ResultPoint[] result, ResultPoint[] tmpResult, Int32[] destinationIndexes);
    private static ResultPoint[] findRowsWithPattern(BitMatrix matrix, int height, int width, int startRow, int startColumn, Int32[] pattern);
    private static Int32[] findGuardPattern(BitMatrix matrix, int column, int row, int width, Int32[] pattern, Int32[] counters);
    private static int patternMatchVariance(Int32[] counters, Int32[] pattern);
}
public class ZXing.PDF417.Internal.Dimensions : object {
    private int minCols;
    private int maxCols;
    private int minRows;
    private int maxRows;
    public int MinCols { get; }
    public int MaxCols { get; }
    public int MinRows { get; }
    public int MaxRows { get; }
    public Dimensions(int minCols, int maxCols, int minRows, int maxRows);
    public int get_MinCols();
    public int get_MaxCols();
    public int get_MinRows();
    public int get_MaxRows();
}
public class ZXing.PDF417.Internal.EC.ErrorCorrection : object {
    private ModulusGF field;
    public bool decode(Int32[] received, int numECCodewords, Int32[] erasures, Int32& errorLocationsCount);
    private ModulusPoly[] runEuclideanAlgorithm(ModulusPoly a, ModulusPoly b, int R);
    private Int32[] findErrorLocations(ModulusPoly errorLocator);
    private Int32[] findErrorMagnitudes(ModulusPoly errorEvaluator, ModulusPoly errorLocator, Int32[] errorLocations);
}
internal class ZXing.PDF417.Internal.EC.ModulusGF : object {
    public static ModulusGF PDF417_GF;
    private Int32[] expTable;
    private Int32[] logTable;
    [CompilerGeneratedAttribute]
private ModulusPoly <Zero>k__BackingField;
    [CompilerGeneratedAttribute]
private ModulusPoly <One>k__BackingField;
    private int modulus;
    public ModulusPoly Zero { get; private set; }
    public ModulusPoly One { get; private set; }
    internal int Size { get; }
    public ModulusGF(int modulus, int generator);
    private static ModulusGF();
    [CompilerGeneratedAttribute]
public ModulusPoly get_Zero();
    [CompilerGeneratedAttribute]
private void set_Zero(ModulusPoly value);
    [CompilerGeneratedAttribute]
public ModulusPoly get_One();
    [CompilerGeneratedAttribute]
private void set_One(ModulusPoly value);
    internal ModulusPoly buildMonomial(int degree, int coefficient);
    internal int add(int a, int b);
    internal int subtract(int a, int b);
    internal int exp(int a);
    internal int log(int a);
    internal int inverse(int a);
    internal int multiply(int a, int b);
    internal int get_Size();
}
internal class ZXing.PDF417.Internal.EC.ModulusPoly : object {
    private ModulusGF field;
    private Int32[] coefficients;
    internal Int32[] Coefficients { get; }
    internal int Degree { get; }
    internal bool isZero { get; }
    public ModulusPoly(ModulusGF field, Int32[] coefficients);
    internal Int32[] get_Coefficients();
    internal int get_Degree();
    internal bool get_isZero();
    internal int getCoefficient(int degree);
    internal int evaluateAt(int a);
    internal ModulusPoly add(ModulusPoly other);
    internal ModulusPoly subtract(ModulusPoly other);
    internal ModulusPoly multiply(ModulusPoly other);
    internal ModulusPoly getNegative();
    internal ModulusPoly multiply(int scalar);
    internal ModulusPoly multiplyByMonomial(int degree, int coefficient);
    public virtual string ToString();
}
internal class ZXing.PDF417.Internal.PDF417 : object {
    private static int START_PATTERN;
    private static int STOP_PATTERN;
    private static int MACRO_LAST_SEGMENT;
    private static int MACRO_SEGMENT_ID;
    private static int MACRO_OPTIONAL_FIELD_TAG;
    private static Int32[][] CODEWORD_TABLE;
    internal static float DEFAULT_PREFERRED_RATIO;
    private static float DEFAULT_MODULE_WIDTH;
    private static float HEIGHT;
    private BarcodeMatrix barcodeMatrix;
    private bool compact;
    private Compaction compaction;
    private Encoding encoding;
    private PDF417MacroMetadata metadata;
    private bool disableEci;
    private int minCols;
    private int maxCols;
    private int maxRows;
    private int minRows;
    private float preferredRatio;
    internal BarcodeMatrix BarcodeMatrix { get; }
    internal PDF417(bool compact);
    private static PDF417();
    internal BarcodeMatrix get_BarcodeMatrix();
    private static int calculateNumberOfRows(int m, int k, int c);
    private static int getNumberOfPadCodewords(int m, int k, int c, int r);
    private static void encodeChar(int pattern, int len, BarcodeRow logic);
    private void encodeLowLevel(string fullCodewords, int c, int r, int errorCorrectionLevel, BarcodeMatrix logic);
    internal void generateBarcodeLogic(string msg, int errorCorrectionLevel, int longDimension, int shortDimension, Int32& aspectRatio);
    internal void generateBarcodeLogic(string msg, int errorCorrectionLevel, int longDimension, int shortDimension, Int32& aspectRatio, bool autoECI);
    private string getMacroBlock(Int32& sourceCodeWords);
    private void appendMacroOptionalField(PDF417OptionalMacroFields field, string value, Int32& sourceCodeWords, StringBuilder macroCodewords);
    private Int32[] determineDimensions(int sourceCodeWords, int errorCorrectionCodeWords, int longDimension, int shortDimension, Int32& aspectRatio);
    internal void setDesiredAspectRatio(float ratio);
    internal void setDimensions(int maxCols, int minCols, int maxRows, int minRows);
    internal void setCompaction(Compaction compaction);
    internal void setCompact(bool compact);
    internal void setEncoding(Encoding encoding);
    internal void setDisableEci(bool disabled);
    internal void setMetaData(PDF417MacroMetadata metadata);
}
public enum ZXing.PDF417.Internal.PDF417AspectRatio : Enum {
    public int value__;
    public static PDF417AspectRatio A1;
    public static PDF417AspectRatio A2;
    public static PDF417AspectRatio A3;
    public static PDF417AspectRatio A4;
    public static PDF417AspectRatio AUTO;
}
public static class ZXing.PDF417.Internal.PDF417CodewordDecoder : object {
    private static Single[][] RATIOS_TABLE;
    private static PDF417CodewordDecoder();
    public static int getDecodedValue(Int32[] moduleBitCount);
    private static Int32[] sampleBitCounts(Int32[] moduleBitCount);
    private static int getDecodedCodewordValue(Int32[] moduleBitCount);
    private static int getBitValue(Int32[] moduleBitCount);
    private static int getClosestDecodedValue(Int32[] moduleBitCount);
}
public class ZXing.PDF417.Internal.PDF417DetectorResult : object {
    [CompilerGeneratedAttribute]
private BitMatrix <Bits>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ResultPoint[]> <Points>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rotation>k__BackingField;
    public BitMatrix Bits { get; private set; }
    public List`1<ResultPoint[]> Points { get; private set; }
    public int Rotation { get; private set; }
    public PDF417DetectorResult(BitMatrix bits, List`1<ResultPoint[]> points, int rotation);
    public PDF417DetectorResult(BitMatrix bits, List`1<ResultPoint[]> points);
    [CompilerGeneratedAttribute]
public BitMatrix get_Bits();
    [CompilerGeneratedAttribute]
private void set_Bits(BitMatrix value);
    [CompilerGeneratedAttribute]
public List`1<ResultPoint[]> get_Points();
    [CompilerGeneratedAttribute]
private void set_Points(List`1<ResultPoint[]> value);
    [CompilerGeneratedAttribute]
public int get_Rotation();
    [CompilerGeneratedAttribute]
private void set_Rotation(int value);
}
internal static class ZXing.PDF417.Internal.PDF417ErrorCorrection : object {
    private static Int32[][] EC_COEFFICIENTS;
    private static PDF417ErrorCorrection();
    internal static int getErrorCorrectionCodewordCount(int errorCorrectionLevel);
    internal static int getErrorCorrectionLevel(int errorCorrectionLevel, int sourceCodeWords);
    internal static int getRecommendedMinimumErrorCorrectionLevel(int n);
    internal static string generateErrorCorrection(string dataCodewords, int errorCorrectionLevel);
}
public enum ZXing.PDF417.Internal.PDF417ErrorCorrectionLevel : Enum {
    public int value__;
    public static PDF417ErrorCorrectionLevel L0;
    public static PDF417ErrorCorrectionLevel L1;
    public static PDF417ErrorCorrectionLevel L2;
    public static PDF417ErrorCorrectionLevel L3;
    public static PDF417ErrorCorrectionLevel L4;
    public static PDF417ErrorCorrectionLevel L5;
    public static PDF417ErrorCorrectionLevel L6;
    public static PDF417ErrorCorrectionLevel L7;
    public static PDF417ErrorCorrectionLevel L8;
    public static PDF417ErrorCorrectionLevel AUTO;
}
internal static class ZXing.PDF417.Internal.PDF417HighLevelEncoder : object {
    private static int TEXT_COMPACTION;
    private static int BYTE_COMPACTION;
    private static int NUMERIC_COMPACTION;
    private static int SUBMODE_ALPHA;
    private static int SUBMODE_LOWER;
    private static int SUBMODE_MIXED;
    private static int SUBMODE_PUNCTUATION;
    private static int LATCH_TO_TEXT;
    private static int LATCH_TO_BYTE_PADDED;
    private static int LATCH_TO_NUMERIC;
    private static int SHIFT_TO_BYTE;
    private static int LATCH_TO_BYTE;
    private static int ECI_USER_DEFINED;
    private static int ECI_GENERAL_PURPOSE;
    private static int ECI_CHARSET;
    private static SByte[] TEXT_MIXED_RAW;
    private static SByte[] TEXT_PUNCTUATION_RAW;
    private static SByte[] MIXED;
    private static SByte[] PUNCTUATION;
    internal static string DEFAULT_ENCODING_NAME;
    private static Encoding DEFAULT_ENCODING;
    private static PDF417HighLevelEncoder();
    internal static string encodeHighLevel(string msg, Compaction compaction, Encoding encoding, bool disableEci, bool autoECI);
    internal static Encoding getEncoder(Encoding encoding);
    private static Byte[] toBytes(string msg, Encoding encoding);
    private static Byte[] toBytes(char msg, Encoding encoding);
    private static int encodeText(ECIInput input, int startpos, int count, StringBuilder sb, int initialSubmode);
    private static void encodeMultiECIBinary(ECIInput input, int startpos, int count, int startmode, StringBuilder sb);
    private static Byte[] subBytes(ECIInput input, int start, int end);
    private static void encodeBinary(Byte[] bytes, int startpos, int count, int startmode, StringBuilder sb);
    private static void encodeNumeric(ECIInput input, int startpos, int count, StringBuilder sb);
    private static bool isDigit(char ch);
    private static bool isAlphaUpper(char ch);
    private static bool isAlphaLower(char ch);
    private static bool isMixed(char ch);
    private static bool isPunctuation(char ch);
    private static bool isText(char ch);
    private static int determineConsecutiveDigitCount(ECIInput input, int startpos);
    private static int determineConsecutiveTextCount(ECIInput input, int startpos);
    private static int determineConsecutiveBinaryCount(ECIInput input, int startpos, Encoding encoding);
    private static void encodingECI(int eci, StringBuilder sb);
}
internal enum ZXing.PDF417.Internal.PDF417OptionalMacroFields : Enum {
    public int value__;
    public static PDF417OptionalMacroFields FileName;
    public static PDF417OptionalMacroFields SegmentCount;
    public static PDF417OptionalMacroFields TimeStamp;
    public static PDF417OptionalMacroFields Sender;
    public static PDF417OptionalMacroFields Addressee;
    public static PDF417OptionalMacroFields FileSize;
    public static PDF417OptionalMacroFields Checksum;
}
public static class ZXing.PDF417.Internal.PDF417ScanningDecoder : object {
    private static int CODEWORD_SKEW_SIZE;
    private static int MAX_ERRORS;
    private static int MAX_EC_CODEWORDS;
    private static ErrorCorrection errorCorrection;
    private static PDF417ScanningDecoder();
    public static DecoderResult decode(BitMatrix image, ResultPoint imageTopLeft, ResultPoint imageBottomLeft, ResultPoint imageTopRight, ResultPoint imageBottomRight, int minCodewordWidth, int maxCodewordWidth, Encoding startWithEncoding);
    private static DetectionResult merge(DetectionResultRowIndicatorColumn leftRowIndicatorColumn, DetectionResultRowIndicatorColumn rightRowIndicatorColumn);
    private static BoundingBox adjustBoundingBox(DetectionResultRowIndicatorColumn rowIndicatorColumn);
    private static int getMax(Int32[] values);
    private static BarcodeMetadata getBarcodeMetadata(DetectionResultRowIndicatorColumn leftRowIndicatorColumn, DetectionResultRowIndicatorColumn rightRowIndicatorColumn);
    private static DetectionResultRowIndicatorColumn getRowIndicatorColumn(BitMatrix image, BoundingBox boundingBox, ResultPoint startPoint, bool leftToRight, int minCodewordWidth, int maxCodewordWidth);
    private static bool adjustCodewordCount(DetectionResult detectionResult, BarcodeValue[][] barcodeMatrix);
    private static DecoderResult createDecoderResult(DetectionResult detectionResult, Encoding startWithEncoding);
    private static DecoderResult createDecoderResultFromAmbiguousValues(int ecLevel, Int32[] codewords, Int32[] erasureArray, Int32[] ambiguousIndexes, Int32[][] ambiguousIndexValues, Encoding startWithEncoding);
    private static BarcodeValue[][] createBarcodeMatrix(DetectionResult detectionResult);
    private static bool isValidBarcodeColumn(DetectionResult detectionResult, int barcodeColumn);
    private static int getStartColumn(DetectionResult detectionResult, int barcodeColumn, int imageRow, bool leftToRight);
    private static Codeword detectCodeword(BitMatrix image, int minColumn, int maxColumn, bool leftToRight, int startColumn, int imageRow, int minCodewordWidth, int maxCodewordWidth);
    private static Int32[] getModuleBitCount(BitMatrix image, int minColumn, int maxColumn, bool leftToRight, int startColumn, int imageRow);
    private static int getNumberOfECCodeWords(int barcodeECLevel);
    private static int adjustCodewordStartColumn(BitMatrix image, int minColumn, int maxColumn, bool leftToRight, int codewordStartColumn, int imageRow);
    private static bool checkCodewordSkew(int codewordSize, int minCodewordWidth, int maxCodewordWidth);
    private static DecoderResult decodeCodewords(Int32[] codewords, int ecLevel, Int32[] erasures, Encoding startWithEncoding);
    private static int correctErrors(Int32[] codewords, Int32[] erasures, int numECCodewords);
    private static bool verifyCodewordCount(Int32[] codewords, int numECCodewords);
    private static Int32[] getBitCountForCodeword(int codeword);
    private static int getCodewordBucketNumber(int codeword);
    private static int getCodewordBucketNumber(Int32[] moduleBitCount);
    public static string ToString(BarcodeValue[][] barcodeMatrix);
}
internal static class ZXing.PDF417.PDF417Common : object {
    public static int INVALID_CODEWORD;
    public static int NUMBER_OF_CODEWORDS;
    public static int MAX_CODEWORDS_IN_BARCODE;
    public static int MIN_ROWS_IN_BARCODE;
    public static int MAX_ROWS_IN_BARCODE;
    public static int MODULES_IN_CODEWORD;
    public static int MODULES_IN_STOP_PATTERN;
    public static int BARS_IN_MODULE;
    private static Int32[] EMPTY_INT_ARRAY;
    public static Int32[] SYMBOL_TABLE;
    private static Int32[] CODEWORD_TABLE;
    private static PDF417Common();
    [ObsoleteAttribute]
public static int getBitCountSum(Int32[] moduleBitCount);
    public static Int32[] toIntArray(ICollection`1<int> list);
    public static int getCodeword(long symbol);
}
[SerializableAttribute]
public class ZXing.PDF417.PDF417EncodingOptions : EncodingOptions {
    public bool Compact { get; public set; }
    public Compaction Compaction { get; public set; }
    public Dimensions Dimensions { get; public set; }
    public PDF417ErrorCorrectionLevel ErrorCorrection { get; public set; }
    public PDF417AspectRatio AspectRatio { get; public set; }
    public float ImageAspectRatio { get; public set; }
    public string CharacterSet { get; public set; }
    public bool DisableECI { get; public set; }
    public bool get_Compact();
    public void set_Compact(bool value);
    public Compaction get_Compaction();
    public void set_Compaction(Compaction value);
    public Dimensions get_Dimensions();
    public void set_Dimensions(Dimensions value);
    public PDF417ErrorCorrectionLevel get_ErrorCorrection();
    public void set_ErrorCorrection(PDF417ErrorCorrectionLevel value);
    public PDF417AspectRatio get_AspectRatio();
    public void set_AspectRatio(PDF417AspectRatio value);
    public float get_ImageAspectRatio();
    public void set_ImageAspectRatio(float value);
    public string get_CharacterSet();
    public void set_CharacterSet(string value);
    public bool get_DisableECI();
    public void set_DisableECI(bool value);
}
public class ZXing.PDF417.PDF417MacroMetadata : object {
    [CompilerGeneratedAttribute]
private int <SegmentIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SegmentCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sender>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Addressee>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <FileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Checksum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <Timestamp>k__BackingField;
    public int SegmentIndex { get; public set; }
    public string FileId { get; public set; }
    public bool IsLastSegment { get; public set; }
    public int SegmentCount { get; public set; }
    public string Sender { get; public set; }
    public string Addressee { get; public set; }
    public string FileName { get; public set; }
    public Nullable`1<long> FileSize { get; public set; }
    public Nullable`1<int> Checksum { get; public set; }
    public Nullable`1<long> Timestamp { get; public set; }
    [CompilerGeneratedAttribute]
public int get_SegmentIndex();
    [CompilerGeneratedAttribute]
public void set_SegmentIndex(int value);
    [CompilerGeneratedAttribute]
public string get_FileId();
    [CompilerGeneratedAttribute]
public void set_FileId(string value);
    [CompilerGeneratedAttribute]
public bool get_IsLastSegment();
    [CompilerGeneratedAttribute]
public void set_IsLastSegment(bool value);
    [CompilerGeneratedAttribute]
public int get_SegmentCount();
    [CompilerGeneratedAttribute]
public void set_SegmentCount(int value);
    [CompilerGeneratedAttribute]
public string get_Sender();
    [CompilerGeneratedAttribute]
public void set_Sender(string value);
    [CompilerGeneratedAttribute]
public string get_Addressee();
    [CompilerGeneratedAttribute]
public void set_Addressee(string value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_FileSize();
    [CompilerGeneratedAttribute]
public void set_FileSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Checksum();
    [CompilerGeneratedAttribute]
public void set_Checksum(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(Nullable`1<long> value);
}
public class ZXing.PDF417.PDF417Reader : object {
    public sealed virtual Result decode(BinaryBitmap image);
    public sealed virtual Result decode(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
    public sealed virtual Result[] decodeMultiple(BinaryBitmap image);
    public sealed virtual Result[] decodeMultiple(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
    private static Result[] decode(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints, bool multiple);
    private static int getMaxWidth(ResultPoint p1, ResultPoint p2);
    private static int getMinWidth(ResultPoint p1, ResultPoint p2);
    private static int getMaxCodewordWidth(ResultPoint[] p);
    private static int getMinCodewordWidth(ResultPoint[] p);
    public sealed virtual void reset();
}
public class ZXing.PDF417.PDF417ResultMetadata : object {
    [CompilerGeneratedAttribute]
private int <SegmentIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileId>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <OptionalData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLastSegment>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SegmentCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sender>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Addressee>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FileSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Checksum>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Timestamp>k__BackingField;
    public int SegmentIndex { get; public set; }
    public string FileId { get; public set; }
    [ObsoleteAttribute("use dedicated already parsed fields")]
public Int32[] OptionalData { get; public set; }
    public bool IsLastSegment { get; public set; }
    public int SegmentCount { get; public set; }
    public string Sender { get; public set; }
    public string Addressee { get; public set; }
    public string FileName { get; public set; }
    public long FileSize { get; public set; }
    public int Checksum { get; public set; }
    public long Timestamp { get; public set; }
    [CompilerGeneratedAttribute]
public int get_SegmentIndex();
    [CompilerGeneratedAttribute]
public void set_SegmentIndex(int value);
    [CompilerGeneratedAttribute]
public string get_FileId();
    [CompilerGeneratedAttribute]
public void set_FileId(string value);
    [CompilerGeneratedAttribute]
public Int32[] get_OptionalData();
    [CompilerGeneratedAttribute]
public void set_OptionalData(Int32[] value);
    [CompilerGeneratedAttribute]
public bool get_IsLastSegment();
    [CompilerGeneratedAttribute]
public void set_IsLastSegment(bool value);
    [CompilerGeneratedAttribute]
public int get_SegmentCount();
    [CompilerGeneratedAttribute]
public void set_SegmentCount(int value);
    [CompilerGeneratedAttribute]
public string get_Sender();
    [CompilerGeneratedAttribute]
public void set_Sender(string value);
    [CompilerGeneratedAttribute]
public string get_Addressee();
    [CompilerGeneratedAttribute]
public void set_Addressee(string value);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public long get_FileSize();
    [CompilerGeneratedAttribute]
public void set_FileSize(long value);
    [CompilerGeneratedAttribute]
public int get_Checksum();
    [CompilerGeneratedAttribute]
public void set_Checksum(int value);
    [CompilerGeneratedAttribute]
public long get_Timestamp();
    [CompilerGeneratedAttribute]
public void set_Timestamp(long value);
    public virtual string ToString();
}
public class ZXing.PDF417.PDF417Writer : object {
    private static int WHITE_SPACE;
    private static int DEFAULT_ERROR_CORRECTION_LEVEL;
    private static int DEFAULT_ASPECT_RATIO;
    public sealed virtual BitMatrix encode(string contents, BarcodeFormat format, int width, int height, IDictionary`2<EncodeHintType, object> hints);
    public sealed virtual BitMatrix encode(string contents, BarcodeFormat format, int width, int height);
    private static BitMatrix bitMatrixFromEncoder(PDF417 encoder, string contents, int errorCorrectionLevel, int width, int height, int margin, int aspectRatio, bool autoECI);
    private static BitMatrix bitMatrixFromBitArray(SByte[][] input, int margin);
    private static SByte[][] rotateArray(SByte[][] bitarray);
}
public class ZXing.PlanarYUVLuminanceSource : BaseLuminanceSource {
    private static int THUMBNAIL_SCALE_FACTOR;
    private Byte[] yuvData;
    private int dataWidth;
    private int dataHeight;
    private int left;
    private int top;
    public Byte[] Matrix { get; }
    public bool CropSupported { get; }
    public int ThumbnailWidth { get; }
    public int ThumbnailHeight { get; }
    public PlanarYUVLuminanceSource(Byte[] yuvData, int dataWidth, int dataHeight, int left, int top, int width, int height, bool reverseHoriz);
    private PlanarYUVLuminanceSource(Byte[] luminances, int width, int height);
    public virtual Byte[] getRow(int y, Byte[] row);
    public virtual Byte[] get_Matrix();
    public virtual bool get_CropSupported();
    public virtual LuminanceSource crop(int left, int top, int width, int height);
    public Int32[] renderThumbnail();
    public int get_ThumbnailWidth();
    public int get_ThumbnailHeight();
    private void reverseHorizontal(int width, int height);
    protected virtual LuminanceSource CreateLuminanceSource(Byte[] newLuminances, int width, int height);
}
public class ZXing.QrCode.Internal.AlignmentPattern : ResultPoint {
    private float estimatedModuleSize;
    internal AlignmentPattern(float posX, float posY, float estimatedModuleSize);
    internal bool aboutEquals(float moduleSize, float i, float j);
    internal AlignmentPattern combineEstimate(float i, float j, float newModuleSize);
}
internal class ZXing.QrCode.Internal.AlignmentPatternFinder : object {
    private BitMatrix image;
    private IList`1<AlignmentPattern> possibleCenters;
    private int startX;
    private int startY;
    private int width;
    private int height;
    private float moduleSize;
    private Int32[] crossCheckStateCount;
    private ResultPointCallback resultPointCallback;
    internal AlignmentPatternFinder(BitMatrix image, int startX, int startY, int width, int height, float moduleSize, ResultPointCallback resultPointCallback);
    internal AlignmentPattern find();
    private static Nullable`1<float> centerFromEnd(Int32[] stateCount, int end);
    private bool foundPatternCross(Int32[] stateCount);
    private Nullable`1<float> crossCheckVertical(int startI, int centerJ, int maxCount, int originalStateCountTotal);
    private AlignmentPattern handlePossibleCenter(Int32[] stateCount, int i, int j);
}
internal class ZXing.QrCode.Internal.BitMatrixParser : object {
    private BitMatrix bitMatrix;
    private Version parsedVersion;
    private FormatInformation parsedFormatInfo;
    private bool mirrored;
    private BitMatrixParser(BitMatrix bitMatrix);
    internal static BitMatrixParser createBitMatrixParser(BitMatrix bitMatrix);
    internal FormatInformation readFormatInformation();
    internal Version readVersion();
    private int copyBit(int i, int j, int versionBits);
    internal Byte[] readCodewords();
    internal void remask();
    internal void setMirror(bool mirror);
    internal void mirror();
}
internal class ZXing.QrCode.Internal.BlockPair : object {
    private Byte[] dataBytes;
    private Byte[] errorCorrectionBytes;
    public Byte[] DataBytes { get; }
    public Byte[] ErrorCorrectionBytes { get; }
    public BlockPair(Byte[] data, Byte[] errorCorrection);
    public Byte[] get_DataBytes();
    public Byte[] get_ErrorCorrectionBytes();
}
[DefaultMemberAttribute("Item")]
public class ZXing.QrCode.Internal.ByteMatrix : object {
    private Byte[][] bytes;
    private int width;
    private int height;
    public int Height { get; }
    public int Width { get; }
    public int Item { get; public set; }
    public Byte[][] Array { get; }
    public ByteMatrix(int width, int height);
    public int get_Height();
    public int get_Width();
    public int get_Item(int x, int y);
    public void set_Item(int x, int y, int value);
    public Byte[][] get_Array();
    public void set(int x, int y, byte value);
    public void set(int x, int y, bool value);
    public void clear(byte value);
    public virtual string ToString();
}
internal class ZXing.QrCode.Internal.DataBlock : object {
    private int numDataCodewords;
    private Byte[] codewords;
    internal int NumDataCodewords { get; }
    internal Byte[] Codewords { get; }
    private DataBlock(int numDataCodewords, Byte[] codewords);
    internal static DataBlock[] getDataBlocks(Byte[] rawCodewords, Version version, ErrorCorrectionLevel ecLevel);
    internal int get_NumDataCodewords();
    internal Byte[] get_Codewords();
}
internal static class ZXing.QrCode.Internal.DataMask : object {
    private static Func`3[] DATA_MASKS;
    private static DataMask();
    internal static void unmaskBitMatrix(int reference, BitMatrix bits, int dimension);
}
internal static class ZXing.QrCode.Internal.DecodedBitStreamParser : object {
    private static Char[] ALPHANUMERIC_CHARS;
    private static int GB2312_SUBSET;
    private static DecodedBitStreamParser();
    internal static DecoderResult decode(Byte[] bytes, Version version, ErrorCorrectionLevel ecLevel, IDictionary`2<DecodeHintType, object> hints);
    private static bool decodeHanziSegment(BitSource bits, StringBuilder result, int count);
    private static bool decodeKanjiSegment(BitSource bits, StringBuilder result, int count);
    private static bool decodeByteSegment(BitSource bits, StringBuilder result, int count, CharacterSetECI currentCharacterSetECI, IList`1<Byte[]> byteSegments, IDictionary`2<DecodeHintType, object> hints);
    private static char toAlphaNumericChar(int value);
    private static bool decodeAlphanumericSegment(BitSource bits, StringBuilder result, int count, bool fc1InEffect);
    private static bool decodeNumericSegment(BitSource bits, StringBuilder result, int count);
    private static int parseECIValue(BitSource bits);
}
public class ZXing.QrCode.Internal.Decoder : object {
    private ReedSolomonDecoder rsDecoder;
    public DecoderResult decode(Boolean[][] image, IDictionary`2<DecodeHintType, object> hints);
    public DecoderResult decode(BitMatrix bits, IDictionary`2<DecodeHintType, object> hints);
    private DecoderResult decode(BitMatrixParser parser, IDictionary`2<DecodeHintType, object> hints);
    private bool correctErrors(Byte[] codewordBytes, int numDataCodewords);
}
public class ZXing.QrCode.Internal.Detector : object {
    private BitMatrix image;
    private ResultPointCallback resultPointCallback;
    protected internal BitMatrix Image { get; }
    protected internal ResultPointCallback ResultPointCallback { get; }
    public Detector(BitMatrix image);
    protected internal virtual BitMatrix get_Image();
    protected internal virtual ResultPointCallback get_ResultPointCallback();
    public virtual DetectorResult detect();
    public virtual DetectorResult detect(IDictionary`2<DecodeHintType, object> hints);
    protected internal virtual DetectorResult processFinderPatternInfo(FinderPatternInfo info);
    private static PerspectiveTransform createTransform(ResultPoint topLeft, ResultPoint topRight, ResultPoint bottomLeft, ResultPoint alignmentPattern, int dimension);
    private static BitMatrix sampleGrid(BitMatrix image, PerspectiveTransform transform, int dimension);
    private static bool computeDimension(ResultPoint topLeft, ResultPoint topRight, ResultPoint bottomLeft, float moduleSize, Int32& dimension);
    protected internal virtual float calculateModuleSize(ResultPoint topLeft, ResultPoint topRight, ResultPoint bottomLeft);
    private float calculateModuleSizeOneWay(ResultPoint pattern, ResultPoint otherPattern);
    private float sizeOfBlackWhiteBlackRunBothWays(int fromX, int fromY, int toX, int toY);
    private float sizeOfBlackWhiteBlackRun(int fromX, int fromY, int toX, int toY);
    protected AlignmentPattern findAlignmentInRegion(float overallEstModuleSize, int estAlignmentX, int estAlignmentY, float allowanceFactor);
}
public static class ZXing.QrCode.Internal.Encoder : object {
    private static Int32[] ALPHANUMERIC_TABLE;
    internal static Encoding DEFAULT_BYTE_MODE_ENCODING;
    private static Encoder();
    private static int calculateMaskPenalty(ByteMatrix matrix);
    public static QRCode encode(string content, ErrorCorrectionLevel ecLevel);
    public static QRCode encode(string content, ErrorCorrectionLevel ecLevel, IDictionary`2<EncodeHintType, object> hints);
    private static Version recommendVersion(ErrorCorrectionLevel ecLevel, Mode mode, BitArray headerBits, BitArray dataBits);
    private static int calculateBitsNeeded(Mode mode, BitArray headerBits, BitArray dataBits, Version version);
    internal static int getAlphanumericCode(int code);
    public static Mode chooseMode(string content);
    private static Mode chooseMode(string content, Encoding encoding);
    internal static bool isOnlyDoubleByteKanji(string content);
    private static int chooseMaskPattern(BitArray bits, ErrorCorrectionLevel ecLevel, Version version, ByteMatrix matrix);
    private static Version chooseVersion(int numInputBits, ErrorCorrectionLevel ecLevel);
    internal static bool willFit(int numInputBits, Version version, ErrorCorrectionLevel ecLevel);
    internal static void terminateBits(int numDataBytes, BitArray bits);
    internal static void getNumDataBytesAndNumECBytesForBlockID(int numTotalBytes, int numDataBytes, int numRSBlocks, int blockID, Int32[] numDataBytesInBlock, Int32[] numECBytesInBlock);
    internal static BitArray interleaveWithECBytes(BitArray bits, int numTotalBytes, int numDataBytes, int numRSBlocks);
    internal static Byte[] generateECBytes(Byte[] dataBytes, int numEcBytesInBlock);
    internal static void appendModeInfo(Mode mode, BitArray bits);
    internal static void appendLengthInfo(int numLetters, Version version, Mode mode, BitArray bits);
    internal static void appendBytes(string content, Mode mode, BitArray bits, Encoding encoding);
    internal static void appendNumericBytes(string content, BitArray bits);
    internal static void appendAlphanumericBytes(string content, BitArray bits);
    internal static void append8BitBytes(string content, BitArray bits, Encoding encoding);
    internal static void appendKanjiBytes(string content, BitArray bits);
    private static void appendECI(CharacterSetECI eci, BitArray bits);
}
public class ZXing.QrCode.Internal.ErrorCorrectionLevel : object {
    public static ErrorCorrectionLevel L;
    public static ErrorCorrectionLevel M;
    public static ErrorCorrectionLevel Q;
    public static ErrorCorrectionLevel H;
    private static ErrorCorrectionLevel[] FOR_BITS;
    private int bits;
    private int ordinal_Renamed_Field;
    private string name;
    public int Bits { get; }
    public string Name { get; }
    private ErrorCorrectionLevel(int ordinal, int bits, string name);
    private static ErrorCorrectionLevel();
    public int get_Bits();
    public string get_Name();
    public int ordinal();
    public virtual string ToString();
    public static ErrorCorrectionLevel forBits(int bits);
}
public class ZXing.QrCode.Internal.FinderPattern : ResultPoint {
    private float estimatedModuleSize;
    private int count;
    public float EstimatedModuleSize { get; }
    internal int Count { get; }
    internal FinderPattern(float posX, float posY, float estimatedModuleSize);
    internal FinderPattern(float posX, float posY, float estimatedModuleSize, int count);
    public float get_EstimatedModuleSize();
    internal int get_Count();
    internal bool aboutEquals(float moduleSize, float i, float j);
    internal FinderPattern combineEstimate(float i, float j, float newModuleSize);
}
public class ZXing.QrCode.Internal.FinderPatternFinder : object {
    private static int CENTER_QUORUM;
    private static EstimatedModuleComparator moduleComparator;
    protected internal static int MIN_SKIP;
    protected internal static int MAX_MODULES;
    private static int INTEGER_MATH_SHIFT;
    private BitMatrix image;
    private List`1<FinderPattern> possibleCenters;
    private bool hasSkipped;
    private Int32[] crossCheckStateCount;
    private ResultPointCallback resultPointCallback;
    protected internal BitMatrix Image { get; }
    protected internal List`1<FinderPattern> PossibleCenters { get; }
    private Int32[] CrossCheckStateCount { get; }
    public FinderPatternFinder(BitMatrix image);
    public FinderPatternFinder(BitMatrix image, ResultPointCallback resultPointCallback);
    private static FinderPatternFinder();
    protected internal virtual BitMatrix get_Image();
    protected internal virtual List`1<FinderPattern> get_PossibleCenters();
    internal virtual FinderPatternInfo find(IDictionary`2<DecodeHintType, object> hints);
    private static Nullable`1<float> centerFromEnd(Int32[] stateCount, int end);
    protected internal static bool foundPatternCross(Int32[] stateCount);
    protected static bool foundPatternDiagonal(Int32[] stateCount);
    private Int32[] get_CrossCheckStateCount();
    [ObsoleteAttribute]
protected void clearCounts(Int32[] counts);
    [ObsoleteAttribute]
protected void shiftCounts2(Int32[] stateCount);
    protected static void doClearCounts(Int32[] counts);
    protected static void doShiftCounts2(Int32[] stateCount);
    private bool crossCheckDiagonal(int centerI, int centerJ);
    private Nullable`1<float> crossCheckVertical(int startI, int centerJ, int maxCount, int originalStateCountTotal);
    private Nullable`1<float> crossCheckHorizontal(int startJ, int centerI, int maxCount, int originalStateCountTotal);
    [ObsoleteAttribute("only exists for backwards compatibility")]
protected bool handlePossibleCenter(Int32[] stateCount, int i, int j, bool pureBarcode);
    protected bool handlePossibleCenter(Int32[] stateCount, int i, int j);
    private int findRowSkip();
    private bool haveMultiplyConfirmedCenters();
    private static double squaredDistance(FinderPattern a, FinderPattern b);
    private FinderPattern[] selectBestPatterns();
}
public class ZXing.QrCode.Internal.FinderPatternInfo : object {
    private FinderPattern bottomLeft;
    private FinderPattern topLeft;
    private FinderPattern topRight;
    public FinderPattern BottomLeft { get; }
    public FinderPattern TopLeft { get; }
    public FinderPattern TopRight { get; }
    public FinderPatternInfo(FinderPattern[] patternCenters);
    public FinderPattern get_BottomLeft();
    public FinderPattern get_TopLeft();
    public FinderPattern get_TopRight();
}
internal class ZXing.QrCode.Internal.FormatInformation : object {
    private static int FORMAT_INFO_MASK_QR;
    private static Int32[][] FORMAT_INFO_DECODE_LOOKUP;
    private static Int32[] BITS_SET_IN_HALF_BYTE;
    private ErrorCorrectionLevel errorCorrectionLevel;
    private byte dataMask;
    internal ErrorCorrectionLevel ErrorCorrectionLevel { get; }
    internal byte DataMask { get; }
    private FormatInformation(int formatInfo);
    private static FormatInformation();
    internal static int numBitsDiffering(int a, int b);
    internal static FormatInformation decodeFormatInformation(int maskedFormatInfo1, int maskedFormatInfo2);
    private static FormatInformation doDecodeFormatInformation(int maskedFormatInfo1, int maskedFormatInfo2);
    internal ErrorCorrectionLevel get_ErrorCorrectionLevel();
    internal byte get_DataMask();
    public virtual int GetHashCode();
    public virtual bool Equals(object o);
}
public static class ZXing.QrCode.Internal.MaskUtil : object {
    private static int N1;
    private static int N2;
    private static int N3;
    private static int N4;
    public static int applyMaskPenaltyRule1(ByteMatrix matrix);
    public static int applyMaskPenaltyRule2(ByteMatrix matrix);
    public static int applyMaskPenaltyRule3(ByteMatrix matrix);
    private static bool isWhiteHorizontal(Byte[] rowArray, int from, int to);
    private static bool isWhiteVertical(Byte[][] array, int col, int from, int to);
    public static int applyMaskPenaltyRule4(ByteMatrix matrix);
    public static bool getDataMaskBit(int maskPattern, int x, int y);
    private static int applyMaskPenaltyRule1Internal(ByteMatrix matrix, bool isHorizontal);
}
public static class ZXing.QrCode.Internal.MatrixUtil : object {
    private static Int32[][] POSITION_DETECTION_PATTERN;
    private static Int32[][] POSITION_ADJUSTMENT_PATTERN;
    private static Int32[][] POSITION_ADJUSTMENT_PATTERN_COORDINATE_TABLE;
    private static Int32[][] TYPE_INFO_COORDINATES;
    private static int VERSION_INFO_POLY;
    private static int TYPE_INFO_POLY;
    private static int TYPE_INFO_MASK_PATTERN;
    private static MatrixUtil();
    public static void clearMatrix(ByteMatrix matrix);
    public static void buildMatrix(BitArray dataBits, ErrorCorrectionLevel ecLevel, Version version, int maskPattern, ByteMatrix matrix);
    public static void embedBasicPatterns(Version version, ByteMatrix matrix);
    public static void embedTypeInfo(ErrorCorrectionLevel ecLevel, int maskPattern, ByteMatrix matrix);
    public static void maybeEmbedVersionInfo(Version version, ByteMatrix matrix);
    public static void embedDataBits(BitArray dataBits, int maskPattern, ByteMatrix matrix);
    public static int findMSBSet(int value_Renamed);
    public static int calculateBCHCode(int value, int poly);
    public static void makeTypeInfoBits(ErrorCorrectionLevel ecLevel, int maskPattern, BitArray bits);
    public static void makeVersionInfoBits(Version version, BitArray bits);
    private static bool isEmpty(int value);
    private static void embedTimingPatterns(ByteMatrix matrix);
    private static void embedDarkDotAtLeftBottomCorner(ByteMatrix matrix);
    private static void embedHorizontalSeparationPattern(int xStart, int yStart, ByteMatrix matrix);
    private static void embedVerticalSeparationPattern(int xStart, int yStart, ByteMatrix matrix);
    private static void embedPositionAdjustmentPattern(int xStart, int yStart, ByteMatrix matrix);
    private static void embedPositionDetectionPattern(int xStart, int yStart, ByteMatrix matrix);
    private static void embedPositionDetectionPatternsAndSeparators(ByteMatrix matrix);
    private static void maybeEmbedPositionAdjustmentPatterns(Version version, ByteMatrix matrix);
}
internal class ZXing.QrCode.Internal.MinimalEncoder : object {
    private string stringToEncode;
    private bool isGS1;
    private ECIEncoderSet encoders;
    private ErrorCorrectionLevel ecLevel;
    public MinimalEncoder(string stringToEncode, Encoding priorityCharset, bool isGS1, ErrorCorrectionLevel ecLevel);
    public static ResultList encode(string stringToEncode, Version version, Encoding priorityCharset, bool isGS1, ErrorCorrectionLevel ecLevel);
    public ResultList encode(Version version);
    public static VersionSize getVersionSize(Version version);
    public static Version getVersion(VersionSize versionSize);
    private static bool isNumeric(char c);
    private static bool isDoubleByteKanji(char c);
    private static bool isAlphanumeric(char c);
    public bool canEncode(Mode mode, char c);
    private static int getCompactedOrdinal(Mode mode);
    private void addEdge(Edge[][][] edges, int position, Edge edge);
    private void addEdges(Version version, Edge[][][] edges, int from, Edge previous);
    public ResultList encodeSpecificVersion(Version version);
}
public class ZXing.QrCode.Internal.Mode : object {
    [CompilerGeneratedAttribute]
private Names <Name>k__BackingField;
    public static Mode TERMINATOR;
    public static Mode NUMERIC;
    public static Mode ALPHANUMERIC;
    public static Mode STRUCTURED_APPEND;
    public static Mode BYTE;
    public static Mode ECI;
    public static Mode KANJI;
    public static Mode FNC1_FIRST_POSITION;
    public static Mode FNC1_SECOND_POSITION;
    public static Mode HANZI;
    private Int32[] characterCountBitsForVersions;
    [CompilerGeneratedAttribute]
private int <Bits>k__BackingField;
    public Names Name { get; private set; }
    public int Bits { get; private set; }
    private Mode(Int32[] characterCountBitsForVersions, int bits, Names name);
    private static Mode();
    [CompilerGeneratedAttribute]
public Names get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(Names value);
    public static Mode forBits(int bits);
    public int getCharacterCountBits(Version version);
    [CompilerGeneratedAttribute]
public int get_Bits();
    [CompilerGeneratedAttribute]
private void set_Bits(int value);
    public virtual string ToString();
}
public class ZXing.QrCode.Internal.QRCode : object {
    public static int NUM_MASK_PATTERNS;
    [CompilerGeneratedAttribute]
private Mode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorCorrectionLevel <ECLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaskPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private ByteMatrix <Matrix>k__BackingField;
    public Mode Mode { get; public set; }
    public ErrorCorrectionLevel ECLevel { get; public set; }
    public Version Version { get; public set; }
    public int MaskPattern { get; public set; }
    public ByteMatrix Matrix { get; public set; }
    private static QRCode();
    [CompilerGeneratedAttribute]
public Mode get_Mode();
    [CompilerGeneratedAttribute]
public void set_Mode(Mode value);
    [CompilerGeneratedAttribute]
public ErrorCorrectionLevel get_ECLevel();
    [CompilerGeneratedAttribute]
public void set_ECLevel(ErrorCorrectionLevel value);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(Version value);
    [CompilerGeneratedAttribute]
public int get_MaskPattern();
    [CompilerGeneratedAttribute]
public void set_MaskPattern(int value);
    [CompilerGeneratedAttribute]
public ByteMatrix get_Matrix();
    [CompilerGeneratedAttribute]
public void set_Matrix(ByteMatrix value);
    public virtual string ToString();
    public static bool isValidMaskPattern(int maskPattern);
}
public class ZXing.QrCode.Internal.QRCodeDecoderMetaData : object {
    private bool mirrored;
    private int dataMask;
    public bool IsMirrored { get; }
    public int DataMask { get; }
    public QRCodeDecoderMetaData(bool mirrored, int dataMask);
    public bool get_IsMirrored();
    public int get_DataMask();
    public void applyMirroredCorrection(ResultPoint[] points);
}
public class ZXing.QrCode.Internal.Version : object {
    private static Int32[] VERSION_DECODE_INFO;
    private static Version[] VERSIONS;
    private int versionNumber;
    private Int32[] alignmentPatternCenters;
    private ECBlocks[] ecBlocks;
    private int totalCodewords;
    public int VersionNumber { get; }
    public Int32[] AlignmentPatternCenters { get; }
    public int TotalCodewords { get; }
    public int DimensionForVersion { get; }
    private Version(int versionNumber, Int32[] alignmentPatternCenters, ECBlocks[] ecBlocks);
    private static Version();
    public int get_VersionNumber();
    public Int32[] get_AlignmentPatternCenters();
    public int get_TotalCodewords();
    public int get_DimensionForVersion();
    public ECBlocks getECBlocksForLevel(ErrorCorrectionLevel ecLevel);
    public static Version getProvisionalVersionForDimension(int dimension);
    public static Version getVersionForNumber(int versionNumber);
    internal static Version decodeVersionInformation(int versionBits);
    internal BitMatrix buildFunctionPattern();
    public virtual string ToString();
    private static Version[] buildVersions();
}
[SerializableAttribute]
public class ZXing.QrCode.QrCodeEncodingOptions : EncodingOptions {
    public ErrorCorrectionLevel ErrorCorrection { get; public set; }
    public string CharacterSet { get; public set; }
    public bool DisableECI { get; public set; }
    public Nullable`1<int> QrVersion { get; public set; }
    public bool QrCompact { get; public set; }
    public ErrorCorrectionLevel get_ErrorCorrection();
    public void set_ErrorCorrection(ErrorCorrectionLevel value);
    public string get_CharacterSet();
    public void set_CharacterSet(string value);
    public bool get_DisableECI();
    public void set_DisableECI(bool value);
    public Nullable`1<int> get_QrVersion();
    public void set_QrVersion(Nullable`1<int> value);
    public bool get_QrCompact();
    public void set_QrCompact(bool value);
}
public class ZXing.QrCode.QRCodeReader : object {
    private static ResultPoint[] NO_POINTS;
    private Decoder decoder;
    private static QRCodeReader();
    protected Decoder getDecoder();
    public sealed virtual Result decode(BinaryBitmap image);
    public sealed virtual Result decode(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
    public sealed virtual void reset();
    private static BitMatrix extractPureBits(BitMatrix image);
    private static bool moduleSize(Int32[] leftTopBlack, BitMatrix image, Single& msize);
}
public class ZXing.QrCode.QRCodeWriter : object {
    private static int QUIET_ZONE_SIZE;
    public sealed virtual BitMatrix encode(string contents, BarcodeFormat format, int width, int height);
    public sealed virtual BitMatrix encode(string contents, BarcodeFormat format, int width, int height, IDictionary`2<EncodeHintType, object> hints);
    private static BitMatrix renderResult(QRCode code, int width, int height, int quietZone, bool noPadding);
}
public interface ZXing.Reader {
    public abstract virtual Result decode(BinaryBitmap image);
    public abstract virtual Result decode(BinaryBitmap image, IDictionary`2<DecodeHintType, object> hints);
    public abstract virtual void reset();
}
[SerializableAttribute]
public class ZXing.ReaderException : Exception {
    public ReaderException(string message);
    public ReaderException(Exception innerException);
    public ReaderException(string message, Exception innerException);
}
public interface ZXing.Rendering.IBarcodeRenderer`1 {
    public abstract virtual TOutput Render(BitMatrix matrix, BarcodeFormat format, string content);
    public abstract virtual TOutput Render(BitMatrix matrix, BarcodeFormat format, string content, EncodingOptions options);
}
public class ZXing.Rendering.PixelData : object {
    [CompilerGeneratedAttribute]
private Byte[] <Pixels>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Height>k__BackingField;
    public Byte[] Pixels { get; private set; }
    public int Width { get; private set; }
    public int Height { get; private set; }
    internal PixelData(int width, int height, Byte[] pixels);
    [CompilerGeneratedAttribute]
public Byte[] get_Pixels();
    [CompilerGeneratedAttribute]
private void set_Pixels(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
private void set_Width(int value);
    [CompilerGeneratedAttribute]
public int get_Height();
    [CompilerGeneratedAttribute]
private void set_Height(int value);
    public WriteableBitmap ToBitmap();
}
public class ZXing.Rendering.PixelDataRenderer : object {
    [CompilerGeneratedAttribute]
private Color <Foreground>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <Background>k__BackingField;
    [CLSCompliantAttribute("False")]
public Color Foreground { get; public set; }
    [CLSCompliantAttribute("False")]
public Color Background { get; public set; }
    [CompilerGeneratedAttribute]
public Color get_Foreground();
    [CompilerGeneratedAttribute]
public void set_Foreground(Color value);
    [CompilerGeneratedAttribute]
public Color get_Background();
    [CompilerGeneratedAttribute]
public void set_Background(Color value);
    public sealed virtual PixelData Render(BitMatrix matrix, BarcodeFormat format, string content);
    public sealed virtual PixelData Render(BitMatrix matrix, BarcodeFormat format, string content, EncodingOptions options);
}
public class ZXing.Rendering.SvgRenderer : object {
    public static string DefaultFontName;
    public static int DefaultFontSize;
    [CompilerGeneratedAttribute]
private Color <Foreground>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <Background>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FontName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <FontSize>k__BackingField;
    [CLSCompliantAttribute("False")]
public Color Foreground { get; public set; }
    [CLSCompliantAttribute("False")]
public Color Background { get; public set; }
    public string FontName { get; public set; }
    public int FontSize { get; public set; }
    [CompilerGeneratedAttribute]
public Color get_Foreground();
    [CompilerGeneratedAttribute]
public void set_Foreground(Color value);
    [CompilerGeneratedAttribute]
public Color get_Background();
    [CompilerGeneratedAttribute]
public void set_Background(Color value);
    [CompilerGeneratedAttribute]
public string get_FontName();
    [CompilerGeneratedAttribute]
public void set_FontName(string value);
    [CompilerGeneratedAttribute]
public int get_FontSize();
    [CompilerGeneratedAttribute]
public void set_FontSize(int value);
    public sealed virtual SvgImage Render(BitMatrix matrix, BarcodeFormat format, string content);
    public sealed virtual SvgImage Render(BitMatrix matrix, BarcodeFormat format, string content, EncodingOptions options);
    private void Create(SvgImage image, BitMatrix matrix, BarcodeFormat format, string content, EncodingOptions options);
    private string ModifyContentDependingOnBarcodeFormat(BarcodeFormat format, string content);
    private static void AppendDarkCell(SvgImage image, BitMatrix matrix, int offsetX, int offSetY);
    private static void FindMaximumRectangle(BitMatrix matrix, BitMatrix processed, int startPosX, int startPosY, int endPosY, Int32& endPosX);
}
public class ZXing.Rendering.WriteableBitmapRenderer : object {
    [CompilerGeneratedAttribute]
private Color <Foreground>k__BackingField;
    [CompilerGeneratedAttribute]
private Color <Background>k__BackingField;
    [CompilerGeneratedAttribute]
private FontFamily <FontFamily>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FontSize>k__BackingField;
    [CompilerGeneratedAttribute]
private FontStretch <FontStretch>k__BackingField;
    [CompilerGeneratedAttribute]
private FontStyle <FontStyle>k__BackingField;
    [CompilerGeneratedAttribute]
private FontWeight <FontWeight>k__BackingField;
    private static FontFamily DefaultFontFamily;
    public Color Foreground { get; public set; }
    public Color Background { get; public set; }
    public FontFamily FontFamily { get; public set; }
    public double FontSize { get; public set; }
    public FontStretch FontStretch { get; public set; }
    public FontStyle FontStyle { get; public set; }
    public FontWeight FontWeight { get; public set; }
    private static WriteableBitmapRenderer();
    [CompilerGeneratedAttribute]
public Color get_Foreground();
    [CompilerGeneratedAttribute]
public void set_Foreground(Color value);
    [CompilerGeneratedAttribute]
public Color get_Background();
    [CompilerGeneratedAttribute]
public void set_Background(Color value);
    [CompilerGeneratedAttribute]
public FontFamily get_FontFamily();
    [CompilerGeneratedAttribute]
public void set_FontFamily(FontFamily value);
    [CompilerGeneratedAttribute]
public double get_FontSize();
    [CompilerGeneratedAttribute]
public void set_FontSize(double value);
    [CompilerGeneratedAttribute]
public FontStretch get_FontStretch();
    [CompilerGeneratedAttribute]
public void set_FontStretch(FontStretch value);
    [CompilerGeneratedAttribute]
public FontStyle get_FontStyle();
    [CompilerGeneratedAttribute]
public void set_FontStyle(FontStyle value);
    [CompilerGeneratedAttribute]
public FontWeight get_FontWeight();
    [CompilerGeneratedAttribute]
public void set_FontWeight(FontWeight value);
    public sealed virtual WriteableBitmap Render(BitMatrix matrix, BarcodeFormat format, string content);
    public virtual WriteableBitmap Render(BitMatrix matrix, BarcodeFormat format, string content, EncodingOptions options);
}
public class ZXing.Result : object {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <RawBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private ResultPoint[] <ResultPoints>k__BackingField;
    [CompilerGeneratedAttribute]
private BarcodeFormat <BarcodeFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<ResultMetadataType, object> <ResultMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Timestamp>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumBits>k__BackingField;
    public string Text { get; private set; }
    public Byte[] RawBytes { get; private set; }
    public ResultPoint[] ResultPoints { get; private set; }
    public BarcodeFormat BarcodeFormat { get; private set; }
    public IDictionary`2<ResultMetadataType, object> ResultMetadata { get; private set; }
    public long Timestamp { get; private set; }
    public int NumBits { get; private set; }
    public Result(string text, Byte[] rawBytes, ResultPoint[] resultPoints, BarcodeFormat format);
    public Result(string text, Byte[] rawBytes, int numBits, ResultPoint[] resultPoints, BarcodeFormat format);
    public Result(string text, Byte[] rawBytes, ResultPoint[] resultPoints, BarcodeFormat format, long timestamp);
    public Result(string text, Byte[] rawBytes, int numBits, ResultPoint[] resultPoints, BarcodeFormat format, long timestamp);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
private void set_Text(string value);
    [CompilerGeneratedAttribute]
public Byte[] get_RawBytes();
    [CompilerGeneratedAttribute]
private void set_RawBytes(Byte[] value);
    [CompilerGeneratedAttribute]
public ResultPoint[] get_ResultPoints();
    [CompilerGeneratedAttribute]
private void set_ResultPoints(ResultPoint[] value);
    [CompilerGeneratedAttribute]
public BarcodeFormat get_BarcodeFormat();
    [CompilerGeneratedAttribute]
private void set_BarcodeFormat(BarcodeFormat value);
    [CompilerGeneratedAttribute]
public IDictionary`2<ResultMetadataType, object> get_ResultMetadata();
    [CompilerGeneratedAttribute]
private void set_ResultMetadata(IDictionary`2<ResultMetadataType, object> value);
    [CompilerGeneratedAttribute]
public long get_Timestamp();
    [CompilerGeneratedAttribute]
private void set_Timestamp(long value);
    [CompilerGeneratedAttribute]
public int get_NumBits();
    [CompilerGeneratedAttribute]
private void set_NumBits(int value);
    public void putMetadata(ResultMetadataType type, object value);
    public void putAllMetadata(IDictionary`2<ResultMetadataType, object> metadata);
    public void addResultPoints(ResultPoint[] newPoints);
    public virtual string ToString();
}
public enum ZXing.ResultMetadataType : Enum {
    public int value__;
    public static ResultMetadataType OTHER;
    public static ResultMetadataType ORIENTATION;
    public static ResultMetadataType BYTE_SEGMENTS;
    public static ResultMetadataType ERROR_CORRECTION_LEVEL;
    public static ResultMetadataType ISSUE_NUMBER;
    public static ResultMetadataType SUGGESTED_PRICE;
    public static ResultMetadataType POSSIBLE_COUNTRY;
    public static ResultMetadataType UPC_EAN_EXTENSION;
    public static ResultMetadataType STRUCTURED_APPEND_SEQUENCE;
    public static ResultMetadataType STRUCTURED_APPEND_PARITY;
    public static ResultMetadataType PDF417_EXTRA_METADATA;
    public static ResultMetadataType AZTEC_EXTRA_METADATA;
    public static ResultMetadataType SYMBOLOGY_IDENTIFIER;
    public static ResultMetadataType QR_MASK_PATTERN;
}
public class ZXing.ResultPoint : object {
    private float x;
    private float y;
    private Byte[] bytesX;
    private Byte[] bytesY;
    private string toString;
    public float X { get; }
    public float Y { get; }
    public ResultPoint(float x, float y);
    public virtual float get_X();
    public virtual float get_Y();
    public virtual bool Equals(object other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static void orderBestPatterns(ResultPoint[] patterns);
    public static float distance(ResultPoint pattern1, ResultPoint pattern2);
    private static float crossProductZ(ResultPoint pointA, ResultPoint pointB, ResultPoint pointC);
}
public class ZXing.ResultPointCallback : MulticastDelegate {
    public ResultPointCallback(object object, IntPtr method);
    public virtual void Invoke(ResultPoint point);
    public virtual IAsyncResult BeginInvoke(ResultPoint point, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class ZXing.RGBLuminanceSource : BaseLuminanceSource {
    protected RGBLuminanceSource(int width, int height);
    public RGBLuminanceSource(Byte[] rgbRawBytes, int width, int height);
    [ObsoleteAttribute("Use RGBLuminanceSource(luminanceArray, width, height, BitmapFormat.Gray8)")]
public RGBLuminanceSource(Byte[] luminanceArray, int width, int height, bool is8Bit);
    public RGBLuminanceSource(Byte[] rgbRawBytes, int width, int height, BitmapFormat bitmapFormat);
    protected virtual LuminanceSource CreateLuminanceSource(Byte[] newLuminances, int width, int height);
    private static BitmapFormat DetermineBitmapFormat(Byte[] rgbRawBytes, int width, int height);
    protected void CalculateLuminance(Byte[] rgbRawBytes, BitmapFormat bitmapFormat);
    private void CalculateLuminanceRGB565(Byte[] rgb565RawData);
    private void CalculateLuminanceRGB24(Byte[] rgbRawBytes);
    private void CalculateLuminanceBGR24(Byte[] rgbRawBytes);
    private void CalculateLuminanceRGB32(Byte[] rgbRawBytes);
    private void CalculateLuminanceBGR32(Byte[] rgbRawBytes);
    private void CalculateLuminanceBGRA32(Byte[] rgbRawBytes);
    private void CalculateLuminanceRGBA32(Byte[] rgbRawBytes);
    private void CalculateLuminanceARGB32(Byte[] rgbRawBytes);
    private void CalculateLuminanceUYVY(Byte[] uyvyRawBytes);
    private void CalculateLuminanceYUYV(Byte[] yuyvRawBytes);
    private void CalculateLuminanceGray16(Byte[] gray16RawBytes);
}
[AttributeUsageAttribute("4124")]
internal class ZXing.SerializableAttribute : Attribute {
}
public static class ZXing.SupportClass : object {
    public static void GetCharsFromString(string sourceString, int sourceStart, int sourceEnd, Char[] destinationArray, int destinationStart);
    public static void SetCapacity(IList`1<T> vector, int newCapacity);
    public static String[] toStringArray(ICollection`1<string> strings);
    public static string Join(string separator, IEnumerable`1<T> values);
    public static void Fill(T[] array, T value);
    public static void Fill(T[] array, int startIndex, int endIndex, T value);
    public static string ToBinaryString(int x);
    public static int bitCount(int n);
    public static T GetValue(IDictionary`2<DecodeHintType, object> hints, DecodeHintType hintType, T default);
}
public interface ZXing.Writer {
    public abstract virtual BitMatrix encode(string contents, BarcodeFormat format, int width, int height);
    public abstract virtual BitMatrix encode(string contents, BarcodeFormat format, int width, int height, IDictionary`2<EncodeHintType, object> hints);
}
[SerializableAttribute]
public class ZXing.WriterException : Exception {
    public WriterException(string message);
    public WriterException(string message, Exception innerExc);
}
